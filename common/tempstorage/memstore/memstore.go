//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore

import (
	_af "encoding/hex"
	_b "errors"
	_c "fmt"
	_dc "gitee.com/greatmusicians/unioffice/common/tempstorage"
	_a "io"
	_d "io/ioutil"
	_ee "math/rand"
	_e "sync"
)

type memStorage struct{ _de _e.Map }

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage() { _ef := memStorage{_de: _e.Map{}}; _dc.SetAsStorage(&_ef) }

type memDataCell struct {
	_gc string
	_ba []byte
	_ac int64
}

// TempFile creates a new empty file in the storage and returns it
func (_dca *memStorage) TempFile(dir, pattern string) (_dc.File, error) {
	_ded := dir + "\u002f" + _cc(pattern)
	_fc := &memDataCell{_gc: _ded, _ba: []byte{}}
	_gd := &memFile{_ad: _fc}
	_dca._de.Store(_ded, _fc)
	return _gd, nil
}

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_dd *memFile) Write(p []byte) (int, error) {
	_dd._ad._ba = append(_dd._ad._ba, p...)
	_dd._ad._ac += int64(len(p))
	return len(p), nil
}

// Name returns the filename of the underlying memDataCell
func (_eec *memFile) Name() string { return _eec._ad._gc }

// Add reads a file from a disk and adds it to the storage
func (_fga *memStorage) Add(path string) error {
	_, _cg := _fga._de.Load(path)
	if _cg {
		return nil
	}
	_efe, _da := _d.ReadFile(path)
	if _da != nil {
		return _da
	}
	_fga._de.Store(path, &memDataCell{_gc: path, _ba: _efe, _ac: int64(len(_efe))})
	return nil
}
func _bae(_edd int) (string, error) {
	_eea := make([]byte, _edd)
	if _, _eee := _ee.Read(_eea); _eee != nil {
		return "", _eee
	}
	return _af.EncodeToString(_eea), nil
}

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_fe *memFile) Read(p []byte) (int, error) {
	_ff := _fe._dg
	_ae := _fe._ad._ac
	_eg := int64(len(p))
	if _eg > _ae {
		_eg = _ae
		p = p[:_eg]
	}
	if _ff >= _ae {
		return 0, _a.EOF
	}
	_ffa := _ff + _eg
	if _ffa >= _ae {
		_ffa = _ae
	}
	_g := copy(p, _fe._ad._ba[_ff:_ffa])
	_fe._dg = _ffa
	return _g, nil
}
func _cc(_dde string) string { _fd, _ := _bae(6); return _dde + _fd }

// RemoveAll removes all files according to the dir argument prefix
func (_cb *memStorage) RemoveAll(dir string) error {
	_cb._de.Range(func(_cbb, _aa interface{}) bool { _cb._de.Delete(_cbb); return true })
	return nil
}

type memFile struct {
	_ad *memDataCell
	_dg int64
}

// Open returns tempstorage File object by name
func (_bb *memStorage) Open(path string) (_dc.File, error) {
	_fg, _acb := _bb._de.Load(path)
	if !_acb {
		return nil, _b.New(_c.Sprintf("Cannot\u0020open\u0020the\u0020file\u0020\u0025s", path))
	}
	return &memFile{_ad: _fg.(*memDataCell)}, nil
}

// TempDir creates a name for a new temp directory using a pattern argument
func (_be *memStorage) TempDir(pattern string) (string, error) { return _cc(pattern), nil }

// Close is not applicable in this implementation
func (_ed *memFile) Close() error { return nil }
