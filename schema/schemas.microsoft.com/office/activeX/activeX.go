//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package activeX

import (
	_e "encoding/xml"
	_a "fmt"
	_c "gitee.com/greatmusicians/unioffice"
)

func (_dgc ST_Persistence) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_dgc.String(), start)
}
func NewCT_OcxPr() *CT_OcxPr { _ecb := &CT_OcxPr{}; return _ecb }

type CT_Picture struct{ IdAttr *string }

func (_bffb ST_Persistence) ValidateWithPath(path string) error {
	switch _bffb {
	case 0, 1, 2, 3, 4:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bffb))
	}
	return nil
}

type CT_Font struct {
	PersistenceAttr ST_Persistence
	IdAttr          *string
	OcxPr           []*CT_OcxPr
}
type CT_OcxPr struct {
	NameAttr  string
	ValueAttr *string
	Choice    *CT_OcxPrChoice
}

func (_cg *Ocx) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cg.CT_Ocx = *NewCT_Ocx()
	for _, _fcb := range start.Attr {
		if _fcb.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _fcb.Name.Local == "id" || _fcb.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _fcb.Name.Local == "id" {
			_bfg, _bdcd := _fcb.Value, error(nil)
			if _bdcd != nil {
				return _bdcd
			}
			_cg.IdAttr = &_bfg
			continue
		}
		if _fcb.Name.Local == "classid" {
			_be, _bde := _fcb.Value, error(nil)
			if _bde != nil {
				return _bde
			}
			_cg.ClassidAttr = _be
			continue
		}
		if _fcb.Name.Local == "license" {
			_bge, _ebe := _fcb.Value, error(nil)
			if _ebe != nil {
				return _ebe
			}
			_cg.LicenseAttr = &_bge
			continue
		}
		if _fcb.Name.Local == "persistence" {
			_cg.PersistenceAttr.UnmarshalXMLAttr(_fcb)
			continue
		}
	}
_gcf:
	for {
		_bff, _bce := d.Token()
		if _bce != nil {
			return _bce
		}
		switch _eee := _bff.(type) {
		case _e.StartElement:
			switch _eee.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", Local: "ocxPr"}:
				_af := NewCT_OcxPr()
				if _dfga := d.DecodeElement(_af, &_eee); _dfga != nil {
					return _dfga
				}
				_cg.OcxPr = append(_cg.OcxPr, _af)
			default:
				_c.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Ocx\u0020\u0025v", _eee.Name)
				if _cgb := d.Skip(); _cgb != nil {
					return _cgb
				}
			}
		case _e.EndElement:
			break _gcf
		case _e.CharData:
		}
	}
	return nil
}
func (_deg *ST_Persistence) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cfc, _abg := d.Token()
	if _abg != nil {
		return _abg
	}
	if _bdce, _cee := _cfc.(_e.EndElement); _cee && _bdce.Name == start.Name {
		*_deg = 1
		return nil
	}
	if _fba, _fff := _cfc.(_e.CharData); !_fff {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cfc)
	} else {
		switch string(_fba) {
		case "":
			*_deg = 0
		case "persistPropertyBag":
			*_deg = 1
		case "persistStream":
			*_deg = 2
		case "persistStreamInit":
			*_deg = 3
		case "persistStorage":
			*_deg = 4
		}
	}
	_cfc, _abg = d.Token()
	if _abg != nil {
		return _abg
	}
	if _ffg, _dab := _cfc.(_e.EndElement); _dab && _ffg.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cfc)
}
func (_fbb *ST_Persistence) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_fbb = 0
	case "persistPropertyBag":
		*_fbb = 1
	case "persistStream":
		*_fbb = 2
	case "persistStreamInit":
		*_fbb = 3
	case "persistStorage":
		*_fbb = 4
	}
	return nil
}
func (_aaa *CT_OcxPr) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _fd := range start.Attr {
		if _fd.Name.Local == "name" {
			_bcc, _gb := _fd.Value, error(nil)
			if _gb != nil {
				return _gb
			}
			_aaa.NameAttr = _bcc
			continue
		}
		if _fd.Name.Local == "value" {
			_agf, _eg := _fd.Value, error(nil)
			if _eg != nil {
				return _eg
			}
			_aaa.ValueAttr = &_agf
			continue
		}
	}
_dcb:
	for {
		_bdcc, _ffd := d.Token()
		if _ffd != nil {
			return _ffd
		}
		switch _bcg := _bdcc.(type) {
		case _e.StartElement:
			switch _bcg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", Local: "font"}:
				_aaa.Choice = NewCT_OcxPrChoice()
				if _cac := d.DecodeElement(&_aaa.Choice.Font, &_bcg); _cac != nil {
					return _cac
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", Local: "picture"}:
				_aaa.Choice = NewCT_OcxPrChoice()
				if _gad := d.DecodeElement(&_aaa.Choice.Picture, &_bcg); _gad != nil {
					return _gad
				}
			default:
				_c.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OcxPr\u0020\u0025v", _bcg.Name)
				if _cec := d.Skip(); _cec != nil {
					return _cec
				}
			}
		case _e.EndElement:
			break _dcb
		case _e.CharData:
		}
	}
	return nil
}

type CT_Ocx struct {
	ClassidAttr     string
	LicenseAttr     *string
	IdAttr          *string
	PersistenceAttr ST_Persistence
	OcxPr           []*CT_OcxPr
}

func NewCT_Ocx() *CT_Ocx { _bdf := &CT_Ocx{}; _bdf.PersistenceAttr = ST_Persistence(1); return _bdf }

// ValidateWithPath validates the CT_OcxPrChoice and its children, prefixing error messages with path
func (_bbd *CT_OcxPrChoice) ValidateWithPath(path string) error {
	if _bbd.Font != nil {
		if _bca := _bbd.Font.ValidateWithPath(path + "\u002fFont"); _bca != nil {
			return _bca
		}
	}
	if _bbd.Picture != nil {
		if _aga := _bbd.Picture.ValidateWithPath(path + "\u002fPicture"); _aga != nil {
			return _aga
		}
	}
	return nil
}
func NewCT_Font() *CT_Font { _ea := &CT_Font{}; return _ea }

// ValidateWithPath validates the CT_OcxPr and its children, prefixing error messages with path
func (_gbf *CT_OcxPr) ValidateWithPath(path string) error {
	if _gbf.Choice != nil {
		if _bdde := _gbf.Choice.ValidateWithPath(path + "\u002fChoice"); _bdde != nil {
			return _bdde
		}
	}
	return nil
}

const (
	ST_PersistenceUnset              ST_Persistence = 0
	ST_PersistencePersistPropertyBag ST_Persistence = 1
	ST_PersistencePersistStream      ST_Persistence = 2
	ST_PersistencePersistStreamInit  ST_Persistence = 3
	ST_PersistencePersistStorage     ST_Persistence = 4
)

func NewCT_Picture() *CT_Picture { _ebd := &CT_Picture{}; return _ebd }
func (_gc *CT_Ocx) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gc.PersistenceAttr = ST_Persistence(1)
	for _, _ce := range start.Attr {
		if _ce.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _ce.Name.Local == "id" || _ce.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _ce.Name.Local == "id" {
			_faf, _dce := _ce.Value, error(nil)
			if _dce != nil {
				return _dce
			}
			_gc.IdAttr = &_faf
			continue
		}
		if _ce.Name.Local == "classid" {
			_ffe, _dg := _ce.Value, error(nil)
			if _dg != nil {
				return _dg
			}
			_gc.ClassidAttr = _ffe
			continue
		}
		if _ce.Name.Local == "license" {
			_cb, _db := _ce.Value, error(nil)
			if _db != nil {
				return _db
			}
			_gc.LicenseAttr = &_cb
			continue
		}
		if _ce.Name.Local == "persistence" {
			_gc.PersistenceAttr.UnmarshalXMLAttr(_ce)
			continue
		}
	}
_bdd:
	for {
		_df, _bc := d.Token()
		if _bc != nil {
			return _bc
		}
		switch _fafa := _df.(type) {
		case _e.StartElement:
			switch _fafa.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", Local: "ocxPr"}:
				_bdb := NewCT_OcxPr()
				if _ag := d.DecodeElement(_bdb, &_fafa); _ag != nil {
					return _ag
				}
				_gc.OcxPr = append(_gc.OcxPr, _bdb)
			default:
				_c.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Ocx\u0020\u0025v", _fafa.Name)
				if _de := d.Skip(); _de != nil {
					return _de
				}
			}
		case _e.EndElement:
			break _bdd
		case _e.CharData:
		}
	}
	return nil
}
func (_bg *CT_Picture) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _bg.IdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _a.Sprintf("\u0025v", *_bg.IdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Picture and its children
func (_gae *CT_Picture) Validate() error { return _gae.ValidateWithPath("CT_Picture") }
func (_ff *CT_Font) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cc := range start.Attr {
		if _cc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _cc.Name.Local == "id" || _cc.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _cc.Name.Local == "id" {
			_ac, _ga := _cc.Value, error(nil)
			if _ga != nil {
				return _ga
			}
			_ff.IdAttr = &_ac
			continue
		}
		if _cc.Name.Local == "persistence" {
			_ff.PersistenceAttr.UnmarshalXMLAttr(_cc)
			continue
		}
	}
_bd:
	for {
		_ee, _dc := d.Token()
		if _dc != nil {
			return _dc
		}
		switch _ca := _ee.(type) {
		case _e.StartElement:
			switch _ca.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", Local: "ocxPr"}:
				_fa := NewCT_OcxPr()
				if _gaa := d.DecodeElement(_fa, &_ca); _gaa != nil {
					return _gaa
				}
				_ff.OcxPr = append(_ff.OcxPr, _fa)
			default:
				_c.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Font\u0020\u0025v", _ca.Name)
				if _aca := d.Skip(); _aca != nil {
					return _aca
				}
			}
		case _e.EndElement:
			break _bd
		case _e.CharData:
		}
	}
	return nil
}
func (_bcea ST_Persistence) Validate() error { return _bcea.ValidateWithPath("") }

type ST_Persistence byte

func NewOcx() *Ocx { _eda := &Ocx{}; _eda.CT_Ocx = *NewCT_Ocx(); return _eda }

// Validate validates the Ocx and its children
func (_fb *Ocx) Validate() error { return _fb.ValidateWithPath("Ocx") }

// ValidateWithPath validates the CT_Picture and its children, prefixing error messages with path
func (_aeb *CT_Picture) ValidateWithPath(path string) error { return nil }

type Ocx struct{ CT_Ocx }
type CT_OcxPrChoice struct {
	Font    *CT_Font
	Picture *CT_Picture
}

func (_gbe *CT_Picture) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _bgd := range start.Attr {
		if _bgd.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bgd.Name.Local == "id" || _bgd.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bgd.Name.Local == "id" {
			_cca, _baeg := _bgd.Value, error(nil)
			if _baeg != nil {
				return _baeg
			}
			_gbe.IdAttr = &_cca
			continue
		}
	}
	for {
		_bbg, _cf := d.Token()
		if _cf != nil {
			return _a.Errorf("parsing\u0020CT_Picture:\u0020%s", _cf)
		}
		if _cd, _da := _bbg.(_e.EndElement); _da && _cd.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_OcxPrChoice() *CT_OcxPrChoice { _gf := &CT_OcxPrChoice{}; return _gf }

// Validate validates the CT_Ocx and its children
func (_bfc *CT_Ocx) Validate() error { return _bfc.ValidateWithPath("CT_Ocx") }
func (_bdc *CT_Ocx) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "ax:classid"}, Value: _a.Sprintf("\u0025v", _bdc.ClassidAttr)})
	if _bdc.LicenseAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "ax:license"}, Value: _a.Sprintf("\u0025v", *_bdc.LicenseAttr)})
	}
	if _bdc.IdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _a.Sprintf("\u0025v", *_bdc.IdAttr)})
	}
	_ef, _gdd := _bdc.PersistenceAttr.MarshalXMLAttr(_e.Name{Local: "ax:persistence"})
	if _gdd != nil {
		return _gdd
	}
	start.Attr = append(start.Attr, _ef)
	e.EncodeToken(start)
	if _bdc.OcxPr != nil {
		_ed := _e.StartElement{Name: _e.Name{Local: "ax:ocxPr"}}
		for _, _bac := range _bdc.OcxPr {
			e.EncodeElement(_bac, _ed)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_fdb *CT_OcxPrChoice) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_fg:
	for {
		_bab, _fc := d.Token()
		if _fc != nil {
			return _fc
		}
		switch _abc := _bab.(type) {
		case _e.StartElement:
			switch _abc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", Local: "font"}:
				_fdb.Font = NewCT_Font()
				if _dbcf := d.DecodeElement(_fdb.Font, &_abc); _dbcf != nil {
					return _dbcf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", Local: "picture"}:
				_fdb.Picture = NewCT_Picture()
				if _adf := d.DecodeElement(_fdb.Picture, &_abc); _adf != nil {
					return _adf
				}
			default:
				_c.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OcxPrChoice\u0020\u0025v", _abc.Name)
				if _ge := d.Skip(); _ge != nil {
					return _ge
				}
			}
		case _e.EndElement:
			break _fg
		case _e.CharData:
		}
	}
	return nil
}
func (_fdc ST_Persistence) String() string {
	switch _fdc {
	case 0:
		return ""
	case 1:
		return "persistPropertyBag"
	case 2:
		return "persistStream"
	case 3:
		return "persistStreamInit"
	case 4:
		return "persistStorage"
	}
	return ""
}
func (_cda *Ocx) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:ax"}, Value: "http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ax:ocx"
	return _cda.CT_Ocx.MarshalXML(e, start)
}

// Validate validates the CT_OcxPr and its children
func (_dcg *CT_OcxPr) Validate() error { return _dcg.ValidateWithPath("CT_OcxPr") }
func (_efa *CT_OcxPrChoice) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _efa.Font != nil {
		_ace := _e.StartElement{Name: _e.Name{Local: "ax:font"}}
		e.EncodeElement(_efa.Font, _ace)
	}
	if _efa.Picture != nil {
		_dbc := _e.StartElement{Name: _e.Name{Local: "ax:picture"}}
		e.EncodeElement(_efa.Picture, _dbc)
	}
	return nil
}
func (_ba *CT_Font) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ba.PersistenceAttr != ST_PersistenceUnset {
		_f, _bf := _ba.PersistenceAttr.MarshalXMLAttr(_e.Name{Local: "ax:persistence"})
		if _bf != nil {
			return _bf
		}
		start.Attr = append(start.Attr, _f)
	}
	if _ba.IdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _a.Sprintf("\u0025v", *_ba.IdAttr)})
	}
	e.EncodeToken(start)
	if _ba.OcxPr != nil {
		_bae := _e.StartElement{Name: _e.Name{Local: "ax:ocxPr"}}
		for _, _d := range _ba.OcxPr {
			e.EncodeElement(_d, _bae)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Ocx and its children, prefixing error messages with path
func (_fef *Ocx) ValidateWithPath(path string) error {
	if _aee := _fef.CT_Ocx.ValidateWithPath(path); _aee != nil {
		return _aee
	}
	return nil
}
func (_gfe ST_Persistence) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_dcc := _e.Attr{}
	_dcc.Name = name
	switch _gfe {
	case ST_PersistenceUnset:
		_dcc.Value = ""
	case ST_PersistencePersistPropertyBag:
		_dcc.Value = "persistPropertyBag"
	case ST_PersistencePersistStream:
		_dcc.Value = "persistStream"
	case ST_PersistencePersistStreamInit:
		_dcc.Value = "persistStreamInit"
	case ST_PersistencePersistStorage:
		_dcc.Value = "persistStorage"
	}
	return _dcc, nil
}
func (_dcd *CT_OcxPr) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "ax:name"}, Value: _a.Sprintf("\u0025v", _dcd.NameAttr)})
	if _dcd.ValueAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "ax:value"}, Value: _a.Sprintf("\u0025v", *_dcd.ValueAttr)})
	}
	e.EncodeToken(start)
	if _dcd.Choice != nil {
		_dcd.Choice.MarshalXML(e, _e.StartElement{})
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Font and its children
func (_aa *CT_Font) Validate() error { return _aa.ValidateWithPath("CT_Font") }

// ValidateWithPath validates the CT_Ocx and its children, prefixing error messages with path
func (_ad *CT_Ocx) ValidateWithPath(path string) error {
	if _ad.PersistenceAttr == ST_PersistenceUnset {
		return _a.Errorf("\u0025s\u002fPersistenceAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _ae := _ad.PersistenceAttr.ValidateWithPath(path + "\u002fPersistenceAttr"); _ae != nil {
		return _ae
	}
	for _ddb, _ccc := range _ad.OcxPr {
		if _dfg := _ccc.ValidateWithPath(_a.Sprintf("\u0025s\u002fOcxPr\u005b\u0025d\u005d", path, _ddb)); _dfg != nil {
			return _dfg
		}
	}
	return nil
}

// Validate validates the CT_OcxPrChoice and its children
func (_fe *CT_OcxPrChoice) Validate() error { return _fe.ValidateWithPath("CT_OcxPrChoice") }

// ValidateWithPath validates the CT_Font and its children, prefixing error messages with path
func (_eeb *CT_Font) ValidateWithPath(path string) error {
	if _aac := _eeb.PersistenceAttr.ValidateWithPath(path + "\u002fPersistenceAttr"); _aac != nil {
		return _aac
	}
	for _gd, _ab := range _eeb.OcxPr {
		if _eb := _ab.ValidateWithPath(_a.Sprintf("\u0025s\u002fOcxPr\u005b\u0025d\u005d", path, _gd)); _eb != nil {
			return _eb
		}
	}
	return nil
}
func init() {
	_c.RegisterConstructor("http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", "CT_Ocx", NewCT_Ocx)
	_c.RegisterConstructor("http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", "CT_OcxPr", NewCT_OcxPr)
	_c.RegisterConstructor("http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", "CT_Font", NewCT_Font)
	_c.RegisterConstructor("http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", "CT_Picture", NewCT_Picture)
	_c.RegisterConstructor("http:\u002f\u002fschemas\u002emicrosoft\u002ecom\u002foffice\u002f2006\u002factiveX", "ocx", NewOcx)
}
