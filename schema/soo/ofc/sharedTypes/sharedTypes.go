//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sharedTypes

import (
	_g "encoding/xml"
	_e "fmt"
	_dg "regexp"
)

const ST_PercentagePattern = "-\u003f[0\u002d9\u005d\u002b\u0028\u005c\u002e[0\u002d9\u005d+)\u003f\u0025"
const ST_FixedPercentagePattern = "-\u003f\u0028\u0028100\u0029\u007c\u0028\u005b0\u002d9\u005d\u005b0\u002d9]\u003f\u0029\u0029\u0028\u005c\u002e\u005b0\u002d9][0\u002d9]\u003f)\u003f\u0025"

func (_cba ST_VerticalAlignRun) ValidateWithPath(path string) error {
	switch _cba {
	case 0, 1, 2, 3:
	default:
		return _e.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cba))
	}
	return nil
}
func (_ce ST_CalendarType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ed := _g.Attr{}
	_ed.Name = name
	switch _ce {
	case ST_CalendarTypeUnset:
		_ed.Value = ""
	case ST_CalendarTypeGregorian:
		_ed.Value = "gregorian"
	case ST_CalendarTypeGregorianUs:
		_ed.Value = "gregorianUs"
	case ST_CalendarTypeGregorianMeFrench:
		_ed.Value = "gregorianMeFrench"
	case ST_CalendarTypeGregorianArabic:
		_ed.Value = "gregorianArabic"
	case ST_CalendarTypeHijri:
		_ed.Value = "hijri"
	case ST_CalendarTypeHebrew:
		_ed.Value = "hebrew"
	case ST_CalendarTypeTaiwan:
		_ed.Value = "taiwan"
	case ST_CalendarTypeJapan:
		_ed.Value = "japan"
	case ST_CalendarTypeThai:
		_ed.Value = "thai"
	case ST_CalendarTypeKorea:
		_ed.Value = "korea"
	case ST_CalendarTypeSaka:
		_ed.Value = "saka"
	case ST_CalendarTypeGregorianXlitEnglish:
		_ed.Value = "gregorianXlitEnglish"
	case ST_CalendarTypeGregorianXlitFrench:
		_ed.Value = "gregorianXlitFrench"
	case ST_CalendarTypeNone:
		_ed.Value = "none"
	}
	return _ed, nil
}

const (
	ST_YAlignUnset   ST_YAlign = 0
	ST_YAlignInline  ST_YAlign = 1
	ST_YAlignTop     ST_YAlign = 2
	ST_YAlignCenter  ST_YAlign = 3
	ST_YAlignBottom  ST_YAlign = 4
	ST_YAlignInside  ST_YAlign = 5
	ST_YAlignOutside ST_YAlign = 6
)

func (_fcb ST_OnOff1) ValidateWithPath(path string) error {
	switch _fcb {
	case 0, 1, 2:
	default:
		return _e.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fcb))
	}
	return nil
}
func (_gfe ST_TrueFalse) String() string {
	switch _gfe {
	case 0:
		return ""
	case 1:
		return "t"
	case 2:
		return "f"
	case 3:
		return "true"
	case 4:
		return "false"
	}
	return ""
}
func (_gfac ST_XAlign) String() string {
	switch _gfac {
	case 0:
		return ""
	case 1:
		return "left"
	case 2:
		return "center"
	case 3:
		return "right"
	case 4:
		return "inside"
	case 5:
		return "outside"
	}
	return ""
}

var ST_FixedPercentagePatternRe = _dg.MustCompile(ST_FixedPercentagePattern)

const (
	ST_VerticalAlignRunUnset       ST_VerticalAlignRun = 0
	ST_VerticalAlignRunBaseline    ST_VerticalAlignRun = 1
	ST_VerticalAlignRunSuperscript ST_VerticalAlignRun = 2
	ST_VerticalAlignRunSubscript   ST_VerticalAlignRun = 3
)
const ST_UniversalMeasurePattern = "\u002d\u003f\u005b0\u002d9\u005d\u002b\u0028\u005c\u002e\u005b0\u002d9\u005d\u002b\u0029\u003f\u0028mm\u007ccm\u007cin\u007cpt\u007cpc\u007cpi\u0029"

func (_abb *ST_YAlign) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_eab, _abbc := d.Token()
	if _abbc != nil {
		return _abbc
	}
	if _dcc, _eae := _eab.(_g.EndElement); _eae && _dcc.Name == start.Name {
		*_abb = 1
		return nil
	}
	if _bfff, _cc := _eab.(_g.CharData); !_cc {
		return _e.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eab)
	} else {
		switch string(_bfff) {
		case "":
			*_abb = 0
		case "inline":
			*_abb = 1
		case "top":
			*_abb = 2
		case "center":
			*_abb = 3
		case "bottom":
			*_abb = 4
		case "inside":
			*_abb = 5
		case "outside":
			*_abb = 6
		}
	}
	_eab, _abbc = d.Token()
	if _abbc != nil {
		return _abbc
	}
	if _gccc, _ecac := _eab.(_g.EndElement); _ecac && _gccc.Name == start.Name {
		return nil
	}
	return _e.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eab)
}
func (_egcf ST_YAlign) ValidateWithPath(path string) error {
	switch _egcf {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _e.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_egcf))
	}
	return nil
}
func (_ec ST_CalendarType) ValidateWithPath(path string) error {
	switch _ec {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14:
	default:
		return _e.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ec))
	}
	return nil
}
func (_dga *ST_XAlign) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fbb, _bcb := d.Token()
	if _bcb != nil {
		return _bcb
	}
	if _gcg, _fbd := _fbb.(_g.EndElement); _fbd && _gcg.Name == start.Name {
		*_dga = 1
		return nil
	}
	if _feg, _acdc := _fbb.(_g.CharData); !_acdc {
		return _e.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fbb)
	} else {
		switch string(_feg) {
		case "":
			*_dga = 0
		case "left":
			*_dga = 1
		case "center":
			*_dga = 2
		case "right":
			*_dga = 3
		case "inside":
			*_dga = 4
		case "outside":
			*_dga = 5
		}
	}
	_fbb, _bcb = d.Token()
	if _bcb != nil {
		return _bcb
	}
	if _bde, _bba := _fbb.(_g.EndElement); _bba && _bde.Name == start.Name {
		return nil
	}
	return _e.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fbb)
}
func (_acdf ST_AlgType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_acdf.String(), start)
}

var ST_PositivePercentagePatternRe = _dg.MustCompile(ST_PositivePercentagePattern)

const (
	ST_CalendarTypeUnset                ST_CalendarType = 0
	ST_CalendarTypeGregorian            ST_CalendarType = 1
	ST_CalendarTypeGregorianUs          ST_CalendarType = 2
	ST_CalendarTypeGregorianMeFrench    ST_CalendarType = 3
	ST_CalendarTypeGregorianArabic      ST_CalendarType = 4
	ST_CalendarTypeHijri                ST_CalendarType = 5
	ST_CalendarTypeHebrew               ST_CalendarType = 6
	ST_CalendarTypeTaiwan               ST_CalendarType = 7
	ST_CalendarTypeJapan                ST_CalendarType = 8
	ST_CalendarTypeThai                 ST_CalendarType = 9
	ST_CalendarTypeKorea                ST_CalendarType = 10
	ST_CalendarTypeSaka                 ST_CalendarType = 11
	ST_CalendarTypeGregorianXlitEnglish ST_CalendarType = 12
	ST_CalendarTypeGregorianXlitFrench  ST_CalendarType = 13
	ST_CalendarTypeNone                 ST_CalendarType = 14
)

// ST_OnOff is a union type
type ST_OnOff struct {
	Bool      *bool
	ST_OnOff1 ST_OnOff1
}

const (
	ST_ConformanceClassUnset        ST_ConformanceClass = 0
	ST_ConformanceClassStrict       ST_ConformanceClass = 1
	ST_ConformanceClassTransitional ST_ConformanceClass = 2
)

func (_a *ST_TwipsMeasure) Validate() error       { return _a.ValidateWithPath("") }
func (_eddg ST_VerticalAlignRun) Validate() error { return _eddg.ValidateWithPath("") }
func (_ecba ST_YAlign) String() string {
	switch _ecba {
	case 0:
		return ""
	case 1:
		return "inline"
	case 2:
		return "top"
	case 3:
		return "center"
	case 4:
		return "bottom"
	case 5:
		return "inside"
	case 6:
		return "outside"
	}
	return ""
}

type ST_TrueFalse byte

func (_agf ST_XAlign) Validate() error { return _agf.ValidateWithPath("") }
func (_beeb *ST_TrueFalse) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bfa, _aga := d.Token()
	if _aga != nil {
		return _aga
	}
	if _ecg, _aaf := _bfa.(_g.EndElement); _aaf && _ecg.Name == start.Name {
		*_beeb = 1
		return nil
	}
	if _fe, _caa := _bfa.(_g.CharData); !_caa {
		return _e.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bfa)
	} else {
		switch string(_fe) {
		case "":
			*_beeb = 0
		case "t":
			*_beeb = 1
		case "f":
			*_beeb = 2
		case "true":
			*_beeb = 3
		case "false":
			*_beeb = 4
		}
	}
	_bfa, _aga = d.Token()
	if _aga != nil {
		return _aga
	}
	if _bae, _fd := _bfa.(_g.EndElement); _fd && _bae.Name == start.Name {
		return nil
	}
	return _e.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bfa)
}
func (_ff *ST_CalendarType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_eed, _gbe := d.Token()
	if _gbe != nil {
		return _gbe
	}
	if _acf, _cg := _eed.(_g.EndElement); _cg && _acf.Name == start.Name {
		*_ff = 1
		return nil
	}
	if _da, _be := _eed.(_g.CharData); !_be {
		return _e.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eed)
	} else {
		switch string(_da) {
		case "":
			*_ff = 0
		case "gregorian":
			*_ff = 1
		case "gregorianUs":
			*_ff = 2
		case "gregorianMeFrench":
			*_ff = 3
		case "gregorianArabic":
			*_ff = 4
		case "hijri":
			*_ff = 5
		case "hebrew":
			*_ff = 6
		case "taiwan":
			*_ff = 7
		case "japan":
			*_ff = 8
		case "thai":
			*_ff = 9
		case "korea":
			*_ff = 10
		case "saka":
			*_ff = 11
		case "gregorianXlitEnglish":
			*_ff = 12
		case "gregorianXlitFrench":
			*_ff = 13
		case "none":
			*_ff = 14
		}
	}
	_eed, _gbe = d.Token()
	if _gbe != nil {
		return _gbe
	}
	if _bf, _af := _eed.(_g.EndElement); _af && _bf.Name == start.Name {
		return nil
	}
	return _e.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eed)
}
func (_dbd ST_VerticalAlignRun) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_dbd.String(), start)
}
func (_ffc ST_TrueFalseBlank) Validate() error { return _ffc.ValidateWithPath("") }
func (_dfd ST_YAlign) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_agfc := _g.Attr{}
	_agfc.Name = name
	switch _dfd {
	case ST_YAlignUnset:
		_agfc.Value = ""
	case ST_YAlignInline:
		_agfc.Value = "inline"
	case ST_YAlignTop:
		_agfc.Value = "top"
	case ST_YAlignCenter:
		_agfc.Value = "center"
	case ST_YAlignBottom:
		_agfc.Value = "bottom"
	case ST_YAlignInside:
		_agfc.Value = "inside"
	case ST_YAlignOutside:
		_agfc.Value = "outside"
	}
	return _agfc, nil
}
func (_gc *ST_CalendarType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_gc = 0
	case "gregorian":
		*_gc = 1
	case "gregorianUs":
		*_gc = 2
	case "gregorianMeFrench":
		*_gc = 3
	case "gregorianArabic":
		*_gc = 4
	case "hijri":
		*_gc = 5
	case "hebrew":
		*_gc = 6
	case "taiwan":
		*_gc = 7
	case "japan":
		*_gc = 8
	case "thai":
		*_gc = 9
	case "korea":
		*_gc = 10
	case "saka":
		*_gc = 11
	case "gregorianXlitEnglish":
		*_gc = 12
	case "gregorianXlitFrench":
		*_gc = 13
	case "none":
		*_gc = 14
	}
	return nil
}
func (_fba *ST_AlgClass) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_afd, _cdd := d.Token()
	if _cdd != nil {
		return _cdd
	}
	if _afg, _gcc := _afd.(_g.EndElement); _gcc && _afg.Name == start.Name {
		*_fba = 1
		return nil
	}
	if _ef, _gg := _afd.(_g.CharData); !_gg {
		return _e.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _afd)
	} else {
		switch string(_ef) {
		case "":
			*_fba = 0
		case "hash":
			*_fba = 1
		case "custom":
			*_fba = 2
		}
	}
	_afd, _cdd = d.Token()
	if _cdd != nil {
		return _cdd
	}
	if _fbac, _cdf := _afd.(_g.EndElement); _cdf && _fbac.Name == start.Name {
		return nil
	}
	return _e.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _afd)
}
func (_dge ST_TrueFalseBlank) ValidateWithPath(path string) error {
	switch _dge {
	case 0, 1, 2, 3, 4, 6, 7:
	default:
		return _e.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dge))
	}
	return nil
}
func (_de ST_VerticalAlignRun) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_bea := _g.Attr{}
	_bea.Name = name
	switch _de {
	case ST_VerticalAlignRunUnset:
		_bea.Value = ""
	case ST_VerticalAlignRunBaseline:
		_bea.Value = "baseline"
	case ST_VerticalAlignRunSuperscript:
		_bea.Value = "superscript"
	case ST_VerticalAlignRunSubscript:
		_bea.Value = "subscript"
	}
	return _bea, nil
}

var ST_PositiveUniversalMeasurePatternRe = _dg.MustCompile(ST_PositiveUniversalMeasurePattern)

func ParseUnionST_OnOff(s string) (ST_OnOff, error) {
	_gb := ST_OnOff{}
	switch s {
	case "true", "1", "on":
		_ba := true
		_gb.Bool = &_ba
	default:
		_ac := false
		_gb.Bool = &_ac
	}
	return _gb, nil
}

type ST_OnOff1 byte

func (_bef ST_CryptProv) Validate() error { return _bef.ValidateWithPath("") }
func (_dc ST_AlgClass) String() string {
	switch _dc {
	case 0:
		return ""
	case 1:
		return "hash"
	case 2:
		return "custom"
	}
	return ""
}
func (_df ST_AlgType) ValidateWithPath(path string) error {
	switch _df {
	case 0, 1, 2:
	default:
		return _e.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_df))
	}
	return nil
}
func (_daf ST_ConformanceClass) String() string {
	switch _daf {
	case 0:
		return ""
	case 1:
		return "strict"
	case 2:
		return "transitional"
	}
	return ""
}
func (_ggf ST_OnOff1) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_bda := _g.Attr{}
	_bda.Name = name
	switch _ggf {
	case ST_OnOff1Unset:
		_bda.Value = ""
	case ST_OnOff1On:
		_bda.Value = "on"
	case ST_OnOff1Off:
		_bda.Value = "off"
	}
	return _bda, nil
}
func (_dgg *ST_OnOff) ValidateWithPath(path string) error {
	_c := []string{}
	if _dgg.Bool != nil {
		_c = append(_c, "Bool")
	}
	if _dgg.ST_OnOff1 != ST_OnOff1Unset {
		_c = append(_c, "ST_OnOff1")
	}
	if len(_c) > 1 {
		return _e.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _c)
	}
	return nil
}
func (_ggb ST_TrueFalse) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ggb.String(), start)
}
func (_aa ST_AlgType) String() string {
	switch _aa {
	case 0:
		return ""
	case 1:
		return "typeAny"
	case 2:
		return "custom"
	}
	return ""
}
func (_fda ST_VerticalAlignRun) String() string {
	switch _fda {
	case 0:
		return ""
	case 1:
		return "baseline"
	case 2:
		return "superscript"
	case 3:
		return "subscript"
	}
	return ""
}

var ST_PositiveFixedPercentagePatternRe = _dg.MustCompile(ST_PositiveFixedPercentagePattern)

func (_edg ST_XAlign) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_egd := _g.Attr{}
	_egd.Name = name
	switch _edg {
	case ST_XAlignUnset:
		_egd.Value = ""
	case ST_XAlignLeft:
		_egd.Value = "left"
	case ST_XAlignCenter:
		_egd.Value = "center"
	case ST_XAlignRight:
		_egd.Value = "right"
	case ST_XAlignInside:
		_egd.Value = "inside"
	case ST_XAlignOutside:
		_egd.Value = "outside"
	}
	return _egd, nil
}
func (_eb *ST_OnOff) Validate() error { return _eb.ValidateWithPath("") }

const ST_PositiveFixedPercentagePattern = "\u0028\u0028100\u0029\u007c\u0028\u005b0\u002d9\u005d\u005b0\u002d9\u005d\u003f\u0029\u0029\u0028\u005c\u002e[0\u002d9\u005d\u005b0\u002d9]\u003f\u0029\u003f\u0025"

func (_baeb ST_TrueFalseBlank) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_baeb.String(), start)
}
func (_gd *ST_OnOff1) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_gd = 0
	case "on":
		*_gd = 1
	case "off":
		*_gd = 2
	}
	return nil
}

const (
	ST_TrueFalseBlankUnset  ST_TrueFalseBlank = 0
	ST_TrueFalseBlankT      ST_TrueFalseBlank = 1
	ST_TrueFalseBlankF      ST_TrueFalseBlank = 2
	ST_TrueFalseBlankTrue   ST_TrueFalseBlank = 3
	ST_TrueFalseBlankFalse  ST_TrueFalseBlank = 4
	ST_TrueFalseBlankTrue_  ST_TrueFalseBlank = 6
	ST_TrueFalseBlankFalse_ ST_TrueFalseBlank = 7
)

func (_egb ST_ConformanceClass) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dcg := _g.Attr{}
	_dcg.Name = name
	switch _egb {
	case ST_ConformanceClassUnset:
		_dcg.Value = ""
	case ST_ConformanceClassStrict:
		_dcg.Value = "strict"
	case ST_ConformanceClassTransitional:
		_dcg.Value = "transitional"
	}
	return _dcg, nil
}
func (_abd ST_CryptProv) ValidateWithPath(path string) error {
	switch _abd {
	case 0, 1, 2, 3:
	default:
		return _e.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_abd))
	}
	return nil
}
func (_ad *ST_AlgType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ea, _edd := d.Token()
	if _edd != nil {
		return _edd
	}
	if _dad, _bc := _ea.(_g.EndElement); _bc && _dad.Name == start.Name {
		*_ad = 1
		return nil
	}
	if _afdf, _fg := _ea.(_g.CharData); !_fg {
		return _e.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ea)
	} else {
		switch string(_afdf) {
		case "":
			*_ad = 0
		case "typeAny":
			*_ad = 1
		case "custom":
			*_ad = 2
		}
	}
	_ea, _edd = d.Token()
	if _edd != nil {
		return _edd
	}
	if _gacc, _cb := _ea.(_g.EndElement); _cb && _gacc.Name == start.Name {
		return nil
	}
	return _e.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ea)
}
func (_bfd ST_ConformanceClass) Validate() error { return _bfd.ValidateWithPath("") }
func (_fb *ST_TwipsMeasure) ValidateWithPath(path string) error {
	_gf := []string{}
	if _fb.ST_UnsignedDecimalNumber != nil {
		_gf = append(_gf, "ST_UnsignedDecimalNumber")
	}
	if _fb.ST_PositiveUniversalMeasure != nil {
		_gf = append(_gf, "ST_PositiveUniversalMeasure")
	}
	if len(_gf) > 1 {
		return _e.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _gf)
	}
	return nil
}

// ST_TwipsMeasure is a union type
type ST_TwipsMeasure struct {
	ST_UnsignedDecimalNumber    *uint64
	ST_PositiveUniversalMeasure *string
}

func (_fa *ST_CryptProv) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_efb, _daa := d.Token()
	if _daa != nil {
		return _daa
	}
	if _eca, _ede := _efb.(_g.EndElement); _ede && _eca.Name == start.Name {
		*_fa = 1
		return nil
	}
	if _eff, _ffb := _efb.(_g.CharData); !_ffb {
		return _e.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _efb)
	} else {
		switch string(_eff) {
		case "":
			*_fa = 0
		case "rsaAES":
			*_fa = 1
		case "rsaFull":
			*_fa = 2
		case "custom":
			*_fa = 3
		}
	}
	_efb, _daa = d.Token()
	if _daa != nil {
		return _daa
	}
	if _bb, _bg := _efb.(_g.EndElement); _bg && _bb.Name == start.Name {
		return nil
	}
	return _e.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _efb)
}
func (_dde ST_TrueFalse) Validate() error { return _dde.ValidateWithPath("") }
func (_fgg ST_XAlign) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_fgg.String(), start)
}
func (_gad ST_AlgClass) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_gad.String(), start)
}

var ST_PercentagePatternRe = _dg.MustCompile(ST_PercentagePattern)

func (_gfa *ST_TrueFalseBlank) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gfd, _fga := d.Token()
	if _fga != nil {
		return _fga
	}
	if _eg, _eec := _gfd.(_g.EndElement); _eec && _eg.Name == start.Name {
		*_gfa = 1
		return nil
	}
	if _aff, _dgf := _gfd.(_g.CharData); !_dgf {
		return _e.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gfd)
	} else {
		switch string(_aff) {
		case "":
			*_gfa = 0
		case "t":
			*_gfa = 1
		case "f":
			*_gfa = 2
		case "true":
			*_gfa = 3
		case "false":
			*_gfa = 4
		case "True":
			*_gfa = 6
		case "False":
			*_gfa = 7
		}
	}
	_gfd, _fga = d.Token()
	if _fga != nil {
		return _fga
	}
	if _edb, _cbe := _gfd.(_g.EndElement); _cbe && _edb.Name == start.Name {
		return nil
	}
	return _e.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gfd)
}
func (_deb *ST_VerticalAlignRun) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_deb = 0
	case "baseline":
		*_deb = 1
	case "superscript":
		*_deb = 2
	case "subscript":
		*_deb = 3
	}
	return nil
}

var ST_UniversalMeasurePatternRe = _dg.MustCompile(ST_UniversalMeasurePattern)

func (_gacd ST_XAlign) ValidateWithPath(path string) error {
	switch _gacd {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _e.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gacd))
	}
	return nil
}
func (_edf ST_AlgType) Validate() error { return _edf.ValidateWithPath("") }
func (_cace *ST_TrueFalseBlank) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_cace = 0
	case "t":
		*_cace = 1
	case "f":
		*_cace = 2
	case "true":
		*_cace = 3
	case "false":
		*_cace = 4
	case "True":
		*_cace = 6
	case "False":
		*_cace = 7
	}
	return nil
}
func (_efd ST_AlgClass) Validate() error { return _efd.ValidateWithPath("") }
func (_geaa *ST_YAlign) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_geaa = 0
	case "inline":
		*_geaa = 1
	case "top":
		*_geaa = 2
	case "center":
		*_geaa = 3
	case "bottom":
		*_geaa = 4
	case "inside":
		*_geaa = 5
	case "outside":
		*_geaa = 6
	}
	return nil
}

type ST_AlgType byte

const (
	ST_OnOff1Unset ST_OnOff1 = 0
	ST_OnOff1On    ST_OnOff1 = 1
	ST_OnOff1Off   ST_OnOff1 = 2
)

func (_gea *ST_AlgType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_gea = 0
	case "typeAny":
		*_gea = 1
	case "custom":
		*_gea = 2
	}
	return nil
}
func (_fgf *ST_OnOff1) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bee, _dac := d.Token()
	if _dac != nil {
		return _dac
	}
	if _db, _eba := _bee.(_g.EndElement); _eba && _db.Name == start.Name {
		*_fgf = 1
		return nil
	}
	if _ecb, _cfd := _bee.(_g.CharData); !_cfd {
		return _e.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bee)
	} else {
		switch string(_ecb) {
		case "":
			*_fgf = 0
		case "on":
			*_fgf = 1
		case "off":
			*_fgf = 2
		}
	}
	_bee, _dac = d.Token()
	if _dac != nil {
		return _dac
	}
	if _fc, _abg := _bee.(_g.EndElement); _abg && _fc.Name == start.Name {
		return nil
	}
	return _e.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bee)
}
func (_acga ST_YAlign) Validate() error { return _acga.ValidateWithPath("") }
func (_cd ST_CalendarType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cd.String(), start)
}
func (_bd ST_TwipsMeasure) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _bd.ST_UnsignedDecimalNumber != nil {
		e.EncodeToken(_g.CharData(_e.Sprintf("\u0025d", *_bd.ST_UnsignedDecimalNumber)))
	}
	if _bd.ST_PositiveUniversalMeasure != nil {
		e.EncodeToken(_g.CharData(*_bd.ST_PositiveUniversalMeasure))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}
func (_aca ST_YAlign) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_aca.String(), start)
}

const (
	ST_AlgTypeUnset   ST_AlgType = 0
	ST_AlgTypeTypeAny ST_AlgType = 1
	ST_AlgTypeCustom  ST_AlgType = 2
)

func (_b ST_OnOff) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _b.Bool != nil {
		e.EncodeToken(_g.CharData(_e.Sprintf("\u0025d", _ge(*_b.Bool))))
	}
	if _b.ST_OnOff1 != ST_OnOff1Unset {
		e.EncodeToken(_g.CharData(_b.ST_OnOff1.String()))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}
func (_geg ST_ConformanceClass) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_geg.String(), start)
}
func (_dcf *ST_XAlign) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_dcf = 0
	case "left":
		*_dcf = 1
	case "center":
		*_dcf = 2
	case "right":
		*_dcf = 3
	case "inside":
		*_dcf = 4
	case "outside":
		*_dcf = 5
	}
	return nil
}
func (_ceg ST_AlgClass) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ga := _g.Attr{}
	_ga.Name = name
	switch _ceg {
	case ST_AlgClassUnset:
		_ga.Value = ""
	case ST_AlgClassHash:
		_ga.Value = "hash"
	case ST_AlgClassCustom:
		_ga.Value = "custom"
	}
	return _ga, nil
}

type ST_TrueFalseBlank byte

func (_ecf ST_OnOff1) Validate() error { return _ecf.ValidateWithPath("") }

type ST_XAlign byte

const ST_PositiveUniversalMeasurePattern = "\u005b0-9\u005d\u002b\u0028\\\u002e\u005b0\u002d9]+\u0029?(mm\u007ccm\u007cin|pt\u007cpc\u007cpi\u0029"

type ST_VerticalAlignRun byte

func (_ggc ST_ConformanceClass) ValidateWithPath(path string) error {
	switch _ggc {
	case 0, 1, 2:
	default:
		return _e.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ggc))
	}
	return nil
}

type ST_YAlign byte

func (_afc ST_TrueFalse) ValidateWithPath(path string) error {
	switch _afc {
	case 0, 1, 2, 3, 4:
	default:
		return _e.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_afc))
	}
	return nil
}

const (
	ST_CryptProvUnset   ST_CryptProv = 0
	ST_CryptProvRsaAES  ST_CryptProv = 1
	ST_CryptProvRsaFull ST_CryptProv = 2
	ST_CryptProvCustom  ST_CryptProv = 3
)

func (_caea ST_OnOff1) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_caea.String(), start)
}
func (_gac ST_AlgType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_cae := _g.Attr{}
	_cae.Name = name
	switch _gac {
	case ST_AlgTypeUnset:
		_cae.Value = ""
	case ST_AlgTypeTypeAny:
		_cae.Value = "typeAny"
	case ST_AlgTypeCustom:
		_cae.Value = "custom"
	}
	return _cae, nil
}
func (_ab ST_CalendarType) Validate() error { return _ab.ValidateWithPath("") }

const ST_PositivePercentagePattern = "\u005b0\u002d9\u005d\u002b\u0028\u005c\u002e[0\u002d9\u005d\u002b\u0029\u003f\u0025"

func (_geb *ST_ConformanceClass) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_geb = 0
	case "strict":
		*_geb = 1
	case "transitional":
		*_geb = 2
	}
	return nil
}
func (_cdg *ST_TrueFalse) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_cdg = 0
	case "t":
		*_cdg = 1
	case "f":
		*_cdg = 2
	case "true":
		*_cdg = 3
	case "false":
		*_cdg = 4
	}
	return nil
}
func (_cec ST_CryptProv) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_efe := _g.Attr{}
	_efe.Name = name
	switch _cec {
	case ST_CryptProvUnset:
		_efe.Value = ""
	case ST_CryptProvRsaAES:
		_efe.Value = "rsaAES"
	case ST_CryptProvRsaFull:
		_efe.Value = "rsaFull"
	case ST_CryptProvCustom:
		_efe.Value = "custom"
	}
	return _efe, nil
}

var ST_GuidPatternRe = _dg.MustCompile(ST_GuidPattern)

type ST_AlgClass byte

const ST_GuidPattern = "\u005c\u007b\u005b0\u002d9A\u002dF\u005d\u007b8\u007d\u002d\u005b0\u002d9A\u002dF\u005d\u007b4\u007d\u002d\u005b0-9A\u002dF\u005d\u007b4\u007d\u002d\u005b0\u002d9A\u002dF\u005d\u007b4\u007d\u002d\u005b0\u002d9A\u002dF]\u007b12\u007d\\\u007d"

func (_ee ST_TwipsMeasure) String() string {
	if _ee.ST_UnsignedDecimalNumber != nil {
		return _e.Sprintf("\u0025v", *_ee.ST_UnsignedDecimalNumber)
	}
	if _ee.ST_PositiveUniversalMeasure != nil {
		return _e.Sprintf("\u0025v", *_ee.ST_PositiveUniversalMeasure)
	}
	return ""
}
func (_ag ST_AlgClass) ValidateWithPath(path string) error {
	switch _ag {
	case 0, 1, 2:
	default:
		return _e.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ag))
	}
	return nil
}
func (_cfa ST_TrueFalseBlank) String() string {
	switch _cfa {
	case 0:
		return ""
	case 1:
		return "t"
	case 2:
		return "f"
	case 3:
		return "true"
	case 4:
		return "false"
	case 6:
		return "True"
	case 7:
		return "False"
	}
	return ""
}
func (_acg ST_CryptProv) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_acg.String(), start)
}

type ST_CalendarType byte

func (_bff ST_CryptProv) String() string {
	switch _bff {
	case 0:
		return ""
	case 1:
		return "rsaAES"
	case 2:
		return "rsaFull"
	case 3:
		return "custom"
	}
	return ""
}

const (
	ST_XAlignUnset   ST_XAlign = 0
	ST_XAlignLeft    ST_XAlign = 1
	ST_XAlignCenter  ST_XAlign = 2
	ST_XAlignRight   ST_XAlign = 3
	ST_XAlignInside  ST_XAlign = 4
	ST_XAlignOutside ST_XAlign = 5
)
const (
	ST_AlgClassUnset  ST_AlgClass = 0
	ST_AlgClassHash   ST_AlgClass = 1
	ST_AlgClassCustom ST_AlgClass = 2
)

func (_cf *ST_CryptProv) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_cf = 0
	case "rsaAES":
		*_cf = 1
	case "rsaFull":
		*_cf = 2
	case "custom":
		*_cf = 3
	}
	return nil
}
func (_acd *ST_AlgClass) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_acd = 0
	case "hash":
		*_acd = 1
	case "custom":
		*_acd = 2
	}
	return nil
}
func (_f ST_OnOff) String() string {
	if _f.Bool != nil {
		return _e.Sprintf("\u0025v", *_f.Bool)
	}
	if _f.ST_OnOff1 != ST_OnOff1Unset {
		return _f.ST_OnOff1.String()
	}
	return ""
}
func (_bbc ST_OnOff1) String() string {
	switch _bbc {
	case 0:
		return ""
	case 1:
		return "on"
	case 2:
		return "off"
	}
	return ""
}

type ST_CryptProv byte

func (_dd ST_CalendarType) String() string {
	switch _dd {
	case 0:
		return ""
	case 1:
		return "gregorian"
	case 2:
		return "gregorianUs"
	case 3:
		return "gregorianMeFrench"
	case 4:
		return "gregorianArabic"
	case 5:
		return "hijri"
	case 6:
		return "hebrew"
	case 7:
		return "taiwan"
	case 8:
		return "japan"
	case 9:
		return "thai"
	case 10:
		return "korea"
	case 11:
		return "saka"
	case 12:
		return "gregorianXlitEnglish"
	case 13:
		return "gregorianXlitFrench"
	case 14:
		return "none"
	}
	return ""
}

const (
	ST_TrueFalseUnset ST_TrueFalse = 0
	ST_TrueFalseT     ST_TrueFalse = 1
	ST_TrueFalseF     ST_TrueFalse = 2
	ST_TrueFalseTrue  ST_TrueFalse = 3
	ST_TrueFalseFalse ST_TrueFalse = 4
)

func (_afgb ST_TrueFalseBlank) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_bgg := _g.Attr{}
	_bgg.Name = name
	switch _afgb {
	case ST_TrueFalseBlankUnset:
		_bgg.Value = ""
	case ST_TrueFalseBlankT:
		_bgg.Value = "t"
	case ST_TrueFalseBlankF:
		_bgg.Value = "f"
	case ST_TrueFalseBlankTrue:
		_bgg.Value = "true"
	case ST_TrueFalseBlankFalse:
		_bgg.Value = "false"
	case ST_TrueFalseBlankTrue_:
		_bgg.Value = "True"
	case ST_TrueFalseBlankFalse_:
		_bgg.Value = "False"
	}
	return _bgg, nil
}

type ST_ConformanceClass byte

func (_geba *ST_ConformanceClass) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cbae, _effc := d.Token()
	if _effc != nil {
		return _effc
	}
	if _gdgb, _gbg := _cbae.(_g.EndElement); _gbg && _gdgb.Name == start.Name {
		*_geba = 1
		return nil
	}
	if _gfc, _gfg := _cbae.(_g.CharData); !_gfg {
		return _e.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cbae)
	} else {
		switch string(_gfc) {
		case "":
			*_geba = 0
		case "strict":
			*_geba = 1
		case "transitional":
			*_geba = 2
		}
	}
	_cbae, _effc = d.Token()
	if _effc != nil {
		return _effc
	}
	if _cfac, _add := _cbae.(_g.EndElement); _add && _cfac.Name == start.Name {
		return nil
	}
	return _e.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cbae)
}
func (_eef ST_TrueFalse) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_cac := _g.Attr{}
	_cac.Name = name
	switch _eef {
	case ST_TrueFalseUnset:
		_cac.Value = ""
	case ST_TrueFalseT:
		_cac.Value = "t"
	case ST_TrueFalseF:
		_cac.Value = "f"
	case ST_TrueFalseTrue:
		_cac.Value = "true"
	case ST_TrueFalseFalse:
		_cac.Value = "false"
	}
	return _cac, nil
}
func _ge(_ca bool) uint8 {
	if _ca {
		return 1
	}
	return 0
}
func (_afb *ST_VerticalAlignRun) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ebe, _egc := d.Token()
	if _egc != nil {
		return _egc
	}
	if _gbc, _afcg := _ebe.(_g.EndElement); _afcg && _gbc.Name == start.Name {
		*_afb = 1
		return nil
	}
	if _gdg, _gdc := _ebe.(_g.CharData); !_gdc {
		return _e.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ebe)
	} else {
		switch string(_gdg) {
		case "":
			*_afb = 0
		case "baseline":
			*_afb = 1
		case "superscript":
			*_afb = 2
		case "subscript":
			*_afb = 3
		}
	}
	_ebe, _egc = d.Token()
	if _egc != nil {
		return _egc
	}
	if _fcbc, _eaf := _ebe.(_g.EndElement); _eaf && _fcbc.Name == start.Name {
		return nil
	}
	return _e.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ebe)
}
