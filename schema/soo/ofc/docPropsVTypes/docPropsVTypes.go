//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package docPropsVTypes

import (
	_d "encoding/xml"
	_g "fmt"
	_ae "gitee.com/greatmusicians/unioffice"
	_ec "gitee.com/greatmusicians/unioffice/schema/soo/ofc/sharedTypes"
	_c "regexp"
	_a "strconv"
	_f "time"
)

func NewCT_Array() *CT_Array {
	_dee := &CT_Array{}
	_dee.BaseTypeAttr = ST_ArrayBaseType(1)
	return _dee
}

// Validate validates the Null and its children
func (_dgdg *Null) Validate() error { return _dgdg.ValidateWithPath("Null") }
func (_cda *CT_Vector) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	_ecca, _ccf := _cda.BaseTypeAttr.MarshalXMLAttr(_d.Name{Local: "baseType"})
	if _ccf != nil {
		return _ccf
	}
	start.Attr = append(start.Attr, _ecca)
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "size"}, Value: _g.Sprintf("\u0025v", _cda.SizeAttr)})
	e.EncodeToken(start)
	if _cda.Variant != nil {
		_fgff := _d.StartElement{Name: _d.Name{Local: "vt:variant"}}
		for _, _bdee := range _cda.Variant {
			e.EncodeElement(_bdee, _fgff)
		}
	}
	if _cda.I1 != nil {
		_cdd := _d.StartElement{Name: _d.Name{Local: "vt:i1"}}
		for _, _eaag := range _cda.I1 {
			e.EncodeElement(_eaag, _cdd)
		}
	}
	if _cda.I2 != nil {
		_cdf := _d.StartElement{Name: _d.Name{Local: "vt:i2"}}
		for _, _cbd := range _cda.I2 {
			e.EncodeElement(_cbd, _cdf)
		}
	}
	if _cda.I4 != nil {
		_cegg := _d.StartElement{Name: _d.Name{Local: "vt:i4"}}
		for _, _gac := range _cda.I4 {
			e.EncodeElement(_gac, _cegg)
		}
	}
	if _cda.I8 != nil {
		_bdd := _d.StartElement{Name: _d.Name{Local: "vt:i8"}}
		for _, _aaeb := range _cda.I8 {
			e.EncodeElement(_aaeb, _bdd)
		}
	}
	if _cda.Ui1 != nil {
		_feab := _d.StartElement{Name: _d.Name{Local: "vt:ui1"}}
		for _, _daed := range _cda.Ui1 {
			e.EncodeElement(_daed, _feab)
		}
	}
	if _cda.Ui2 != nil {
		_caeg := _d.StartElement{Name: _d.Name{Local: "vt:ui2"}}
		for _, _fgg := range _cda.Ui2 {
			e.EncodeElement(_fgg, _caeg)
		}
	}
	if _cda.Ui4 != nil {
		_gbd := _d.StartElement{Name: _d.Name{Local: "vt:ui4"}}
		for _, _acde := range _cda.Ui4 {
			e.EncodeElement(_acde, _gbd)
		}
	}
	if _cda.Ui8 != nil {
		_fgec := _d.StartElement{Name: _d.Name{Local: "vt:ui8"}}
		for _, _bgdc := range _cda.Ui8 {
			e.EncodeElement(_bgdc, _fgec)
		}
	}
	if _cda.R4 != nil {
		_gec := _d.StartElement{Name: _d.Name{Local: "vt:r4"}}
		for _, _baff := range _cda.R4 {
			e.EncodeElement(_baff, _gec)
		}
	}
	if _cda.R8 != nil {
		_bbeb := _d.StartElement{Name: _d.Name{Local: "vt:r8"}}
		for _, _fec := range _cda.R8 {
			e.EncodeElement(_fec, _bbeb)
		}
	}
	if _cda.Lpstr != nil {
		_bgdg := _d.StartElement{Name: _d.Name{Local: "vt:lpstr"}}
		for _, _gcc := range _cda.Lpstr {
			e.EncodeElement(_gcc, _bgdg)
		}
	}
	if _cda.Lpwstr != nil {
		_feef := _d.StartElement{Name: _d.Name{Local: "vt:lpwstr"}}
		for _, _bca := range _cda.Lpwstr {
			e.EncodeElement(_bca, _feef)
		}
	}
	if _cda.Bstr != nil {
		_fgcf := _d.StartElement{Name: _d.Name{Local: "vt:bstr"}}
		for _, _gcfe := range _cda.Bstr {
			e.EncodeElement(_gcfe, _fgcf)
		}
	}
	if _cda.Date != nil {
		_bgc := _d.StartElement{Name: _d.Name{Local: "vt:date"}}
		for _, _dgd := range _cda.Date {
			e.EncodeElement(_dgd, _bgc)
		}
	}
	if _cda.Filetime != nil {
		_cbb := _d.StartElement{Name: _d.Name{Local: "vt:filetime"}}
		for _, _ggf := range _cda.Filetime {
			e.EncodeElement(_ggf, _cbb)
		}
	}
	if _cda.Bool != nil {
		_afg := _d.StartElement{Name: _d.Name{Local: "vt:bool"}}
		for _, _cad := range _cda.Bool {
			e.EncodeElement(_cad, _afg)
		}
	}
	if _cda.Cy != nil {
		_dfd := _d.StartElement{Name: _d.Name{Local: "vt:cy"}}
		for _, _dca := range _cda.Cy {
			e.EncodeElement(_dca, _dfd)
		}
	}
	if _cda.Error != nil {
		_dbb := _d.StartElement{Name: _d.Name{Local: "vt:error"}}
		for _, _dcd := range _cda.Error {
			e.EncodeElement(_dcd, _dbb)
		}
	}
	if _cda.Clsid != nil {
		_abe := _d.StartElement{Name: _d.Name{Local: "vt:clsid"}}
		for _, _fbdd := range _cda.Clsid {
			e.EncodeElement(_fbdd, _abe)
		}
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_eda *Vector) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return _eda.CT_Vector.MarshalXML(e, start)
}
func (_gbag ST_ArrayBaseType) Validate() error { return _gbag.ValidateWithPath("") }
func (_fae *CT_Empty) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for {
		_gge, _dec := d.Token()
		if _dec != nil {
			return _g.Errorf("parsing\u0020CT_Empty: \u0025s", _dec)
		}
		if _dae, _gcd := _gge.(_d.EndElement); _gcd && _dae.Name == start.Name {
			break
		}
	}
	return nil
}

type Vstream struct{ CT_Vstream }

func (_ceggd *Null) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ceggd.CT_Null = *NewCT_Null()
	for {
		_ecac, _bcff := d.Token()
		if _bcff != nil {
			return _g.Errorf("parsing\u0020Null:\u0020\u0025s", _bcff)
		}
		if _ccbc, _bea := _ecac.(_d.EndElement); _bea && _ccbc.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Vstream() *CT_Vstream {
	_afdb := &CT_Vstream{}
	_afdb.VersionAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	return _afdb
}

// ValidateWithPath validates the Array and its children, prefixing error messages with path
func (_cac *Array) ValidateWithPath(path string) error {
	if _cc := _cac.CT_Array.ValidateWithPath(path); _cc != nil {
		return _cc
	}
	return nil
}

// Validate validates the CT_Vector and its children
func (_cbc *CT_Vector) Validate() error { return _cbc.ValidateWithPath("CT_Vector") }

type CT_Empty struct{}

func NewVector() *Vector { _daac := &Vector{}; _daac.CT_Vector = *NewCT_Vector(); return _daac }

// Validate validates the Empty and its children
func (_baad *Empty) Validate() error { return _baad.ValidateWithPath("Empty") }
func NewEmpty() *Empty               { _gceg := &Empty{}; _gceg.CT_Empty = *NewCT_Empty(); return _gceg }
func (_daea *CT_Vector) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_daea.BaseTypeAttr = ST_VectorBaseType(1)
	for _, _faa := range start.Attr {
		if _faa.Name.Local == "size" {
			_edc, _feeb := _a.ParseUint(_faa.Value, 10, 32)
			if _feeb != nil {
				return _feeb
			}
			_daea.SizeAttr = uint32(_edc)
			continue
		}
		if _faa.Name.Local == "baseType" {
			_daea.BaseTypeAttr.UnmarshalXMLAttr(_faa)
			continue
		}
	}
_ecdf:
	for {
		_eeb, _gcad := d.Token()
		if _gcad != nil {
			return _gcad
		}
		switch _ccb := _eeb.(type) {
		case _d.StartElement:
			switch _ccb.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "variant"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "variant"}:
				_aded := NewVariant()
				if _eaga := d.DecodeElement(_aded, &_ccb); _eaga != nil {
					return _eaga
				}
				_daea.Variant = append(_daea.Variant, _aded)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i1"}:
				var _agcb int8
				if _dgae := d.DecodeElement(&_agcb, &_ccb); _dgae != nil {
					return _dgae
				}
				_daea.I1 = append(_daea.I1, _agcb)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i2"}:
				var _fbgc int16
				if _efc := d.DecodeElement(&_fbgc, &_ccb); _efc != nil {
					return _efc
				}
				_daea.I2 = append(_daea.I2, _fbgc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i4"}:
				var _cdge int32
				if _gabb := d.DecodeElement(&_cdge, &_ccb); _gabb != nil {
					return _gabb
				}
				_daea.I4 = append(_daea.I4, _cdge)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i8"}:
				var _ggd int64
				if _cdc := d.DecodeElement(&_ggd, &_ccb); _cdc != nil {
					return _cdc
				}
				_daea.I8 = append(_daea.I8, _ggd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui1"}:
				var _faad uint8
				if _cdb := d.DecodeElement(&_faad, &_ccb); _cdb != nil {
					return _cdb
				}
				_daea.Ui1 = append(_daea.Ui1, _faad)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui2"}:
				var _ffb uint16
				if _bfb := d.DecodeElement(&_ffb, &_ccb); _bfb != nil {
					return _bfb
				}
				_daea.Ui2 = append(_daea.Ui2, _ffb)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui4"}:
				var _geec uint32
				if _ggec := d.DecodeElement(&_geec, &_ccb); _ggec != nil {
					return _ggec
				}
				_daea.Ui4 = append(_daea.Ui4, _geec)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui8"}:
				var _cce uint64
				if _efdg := d.DecodeElement(&_cce, &_ccb); _efdg != nil {
					return _efdg
				}
				_daea.Ui8 = append(_daea.Ui8, _cce)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r4"}:
				var _ffc float32
				if _fdffb := d.DecodeElement(&_ffc, &_ccb); _fdffb != nil {
					return _fdffb
				}
				_daea.R4 = append(_daea.R4, _ffc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r8"}:
				var _eebd float64
				if _ega := d.DecodeElement(&_eebd, &_ccb); _ega != nil {
					return _ega
				}
				_daea.R8 = append(_daea.R8, _eebd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "lpstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "lpstr"}:
				var _fedd string
				if _dbgg := d.DecodeElement(&_fedd, &_ccb); _dbgg != nil {
					return _dbgg
				}
				_daea.Lpstr = append(_daea.Lpstr, _fedd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "lpwstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "lpwstr"}:
				var _gga string
				if _cfab := d.DecodeElement(&_gga, &_ccb); _cfab != nil {
					return _cfab
				}
				_daea.Lpwstr = append(_daea.Lpwstr, _gga)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bstr"}:
				var _fged string
				if _cfgf := d.DecodeElement(&_fged, &_ccb); _cfgf != nil {
					return _cfgf
				}
				_daea.Bstr = append(_daea.Bstr, _fged)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "date"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "date"}:
				var _ccd _f.Time
				if _bfe := d.DecodeElement(&_ccd, &_ccb); _bfe != nil {
					return _bfe
				}
				_daea.Date = append(_daea.Date, _ccd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "filetime"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "filetime"}:
				var _cddg _f.Time
				if _ebg := d.DecodeElement(&_cddg, &_ccb); _ebg != nil {
					return _ebg
				}
				_daea.Filetime = append(_daea.Filetime, _cddg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bool"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bool"}:
				var _fffc bool
				if _fcbg := d.DecodeElement(&_fffc, &_ccb); _fcbg != nil {
					return _fcbg
				}
				_daea.Bool = append(_daea.Bool, _fffc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "cy"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "cy"}:
				var _ggc string
				if _aba := d.DecodeElement(&_ggc, &_ccb); _aba != nil {
					return _aba
				}
				_daea.Cy = append(_daea.Cy, _ggc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "error"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "error"}:
				var _eaf string
				if _fgeg := d.DecodeElement(&_eaf, &_ccb); _fgeg != nil {
					return _fgeg
				}
				_daea.Error = append(_daea.Error, _eaf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "clsid"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "clsid"}:
				var _edec string
				if _ccfd := d.DecodeElement(&_edec, &_ccb); _ccfd != nil {
					return _ccfd
				}
				_daea.Clsid = append(_daea.Clsid, _edec)
			default:
				_ae.Log("skipping\u0020unsupported\u0020element on CT_Vector \u0025v", _ccb.Name)
				if _egb := d.Skip(); _egb != nil {
					return _egb
				}
			}
		case _d.EndElement:
			break _ecdf
		case _d.CharData:
		}
	}
	return nil
}
func (_ebaa *ST_ArrayBaseType) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_ebaa = 0
	case "variant":
		*_ebaa = 1
	case "i1":
		*_ebaa = 2
	case "i2":
		*_ebaa = 3
	case "i4":
		*_ebaa = 4
	case "int":
		*_ebaa = 5
	case "ui1":
		*_ebaa = 6
	case "ui2":
		*_ebaa = 7
	case "ui4":
		*_ebaa = 8
	case "uint":
		*_ebaa = 9
	case "r4":
		*_ebaa = 10
	case "r8":
		*_ebaa = 11
	case "decimal":
		*_ebaa = 12
	case "bstr":
		*_ebaa = 13
	case "date":
		*_ebaa = 14
	case "bool":
		*_ebaa = 15
	case "cy":
		*_ebaa = 16
	case "error":
		*_ebaa = 17
	}
	return nil
}
func NewArray() *Array { _de := &Array{}; _de.CT_Array = *NewCT_Array(); return _de }
func (_gcee *CT_Empty) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_fgee ST_VectorBaseType) Validate() error { return _fgee.ValidateWithPath("") }

// Validate validates the Array and its children
func (_bb *Array) Validate() error { return _bb.ValidateWithPath("Array") }
func NewVariant() *Variant         { _cfe := &Variant{}; _cfe.CT_Variant = *NewCT_Variant(); return _cfe }
func (_bab *Empty) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bab.CT_Empty = *NewCT_Empty()
	for {
		_cafe, _dceea := d.Token()
		if _dceea != nil {
			return _g.Errorf("parsing\u0020Empty:\u0020\u0025s", _dceea)
		}
		if _aab, _gff := _cafe.(_d.EndElement); _gff && _aab.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Null struct{}

func (_bfg *CT_Null) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type Vector struct{ CT_Vector }

func (_cgdg *CT_Null) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for {
		_aea, _ab := d.Token()
		if _ab != nil {
			return _g.Errorf("parsing\u0020CT_Null:\u0020\u0025s", _ab)
		}
		if _dbf, _gdb := _aea.(_d.EndElement); _gdb && _dbf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cbadg *Null) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return _cbadg.CT_Null.MarshalXML(e, start)
}
func (_bbgg ST_ArrayBaseType) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_bcce := _d.Attr{}
	_bcce.Name = name
	switch _bbgg {
	case ST_ArrayBaseTypeUnset:
		_bcce.Value = ""
	case ST_ArrayBaseTypeVariant:
		_bcce.Value = "variant"
	case ST_ArrayBaseTypeI1:
		_bcce.Value = "i1"
	case ST_ArrayBaseTypeI2:
		_bcce.Value = "i2"
	case ST_ArrayBaseTypeI4:
		_bcce.Value = "i4"
	case ST_ArrayBaseTypeInt:
		_bcce.Value = "int"
	case ST_ArrayBaseTypeUi1:
		_bcce.Value = "ui1"
	case ST_ArrayBaseTypeUi2:
		_bcce.Value = "ui2"
	case ST_ArrayBaseTypeUi4:
		_bcce.Value = "ui4"
	case ST_ArrayBaseTypeUint:
		_bcce.Value = "uint"
	case ST_ArrayBaseTypeR4:
		_bcce.Value = "r4"
	case ST_ArrayBaseTypeR8:
		_bcce.Value = "r8"
	case ST_ArrayBaseTypeDecimal:
		_bcce.Value = "decimal"
	case ST_ArrayBaseTypeBstr:
		_bcce.Value = "bstr"
	case ST_ArrayBaseTypeDate:
		_bcce.Value = "date"
	case ST_ArrayBaseTypeBool:
		_bcce.Value = "bool"
	case ST_ArrayBaseTypeCy:
		_bcce.Value = "cy"
	case ST_ArrayBaseTypeError:
		_bcce.Value = "error"
	}
	return _bcce, nil
}
func (_ffd ST_VectorBaseType) String() string {
	switch _ffd {
	case 0:
		return ""
	case 1:
		return "variant"
	case 2:
		return "i1"
	case 3:
		return "i2"
	case 4:
		return "i4"
	case 5:
		return "i8"
	case 6:
		return "ui1"
	case 7:
		return "ui2"
	case 8:
		return "ui4"
	case 9:
		return "ui8"
	case 10:
		return "r4"
	case 11:
		return "r8"
	case 12:
		return "lpstr"
	case 13:
		return "lpwstr"
	case 14:
		return "bstr"
	case 15:
		return "date"
	case 16:
		return "filetime"
	case 17:
		return "bool"
	case 18:
		return "cy"
	case 19:
		return "error"
	case 20:
		return "clsid"
	}
	return ""
}
func (_gcec ST_VectorBaseType) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_ffcc := _d.Attr{}
	_ffcc.Name = name
	switch _gcec {
	case ST_VectorBaseTypeUnset:
		_ffcc.Value = ""
	case ST_VectorBaseTypeVariant:
		_ffcc.Value = "variant"
	case ST_VectorBaseTypeI1:
		_ffcc.Value = "i1"
	case ST_VectorBaseTypeI2:
		_ffcc.Value = "i2"
	case ST_VectorBaseTypeI4:
		_ffcc.Value = "i4"
	case ST_VectorBaseTypeI8:
		_ffcc.Value = "i8"
	case ST_VectorBaseTypeUi1:
		_ffcc.Value = "ui1"
	case ST_VectorBaseTypeUi2:
		_ffcc.Value = "ui2"
	case ST_VectorBaseTypeUi4:
		_ffcc.Value = "ui4"
	case ST_VectorBaseTypeUi8:
		_ffcc.Value = "ui8"
	case ST_VectorBaseTypeR4:
		_ffcc.Value = "r4"
	case ST_VectorBaseTypeR8:
		_ffcc.Value = "r8"
	case ST_VectorBaseTypeLpstr:
		_ffcc.Value = "lpstr"
	case ST_VectorBaseTypeLpwstr:
		_ffcc.Value = "lpwstr"
	case ST_VectorBaseTypeBstr:
		_ffcc.Value = "bstr"
	case ST_VectorBaseTypeDate:
		_ffcc.Value = "date"
	case ST_VectorBaseTypeFiletime:
		_ffcc.Value = "filetime"
	case ST_VectorBaseTypeBool:
		_ffcc.Value = "bool"
	case ST_VectorBaseTypeCy:
		_ffcc.Value = "cy"
	case ST_VectorBaseTypeError:
		_ffcc.Value = "error"
	case ST_VectorBaseTypeClsid:
		_ffcc.Value = "clsid"
	}
	return _ffcc, nil
}
func (_cbe *Variant) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_cbe.CT_Variant = *NewCT_Variant()
_adgg:
	for {
		_cab, _dcc := d.Token()
		if _dcc != nil {
			return _dcc
		}
		switch _aegg := _cab.(type) {
		case _d.StartElement:
			switch _aegg.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "variant"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "variant"}:
				_cbe.Variant = NewVariant()
				if _gdfe := d.DecodeElement(_cbe.Variant, &_aegg); _gdfe != nil {
					return _gdfe
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "vector"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "vector"}:
				_cbe.Vector = NewVector()
				if _cgg := d.DecodeElement(_cbe.Vector, &_aegg); _cgg != nil {
					return _cgg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "array"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "array"}:
				_cbe.Array = NewArray()
				if _dbe := d.DecodeElement(_cbe.Array, &_aegg); _dbe != nil {
					return _dbe
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "blob"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "blob"}:
				_cbe.Blob = new(string)
				if _bgg := d.DecodeElement(_cbe.Blob, &_aegg); _bgg != nil {
					return _bgg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "oblob"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "oblob"}:
				_cbe.Oblob = new(string)
				if _cfb := d.DecodeElement(_cbe.Oblob, &_aegg); _cfb != nil {
					return _cfb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "empty"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "empty"}:
				_cbe.Empty = NewEmpty()
				if _dde := d.DecodeElement(_cbe.Empty, &_aegg); _dde != nil {
					return _dde
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "null"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "null"}:
				_cbe.Null = NewNull()
				if _dcef := d.DecodeElement(_cbe.Null, &_aegg); _dcef != nil {
					return _dcef
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i1"}:
				_cbe.I1 = new(int8)
				if _eccad := d.DecodeElement(_cbe.I1, &_aegg); _eccad != nil {
					return _eccad
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i2"}:
				_cbe.I2 = new(int16)
				if _edfa := d.DecodeElement(_cbe.I2, &_aegg); _edfa != nil {
					return _edfa
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i4"}:
				_cbe.I4 = new(int32)
				if _afdc := d.DecodeElement(_cbe.I4, &_aegg); _afdc != nil {
					return _afdc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i8"}:
				_cbe.I8 = new(int64)
				if _efe := d.DecodeElement(_cbe.I8, &_aegg); _efe != nil {
					return _efe
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "int"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "int"}:
				_cbe.Int = new(int32)
				if _cfaf := d.DecodeElement(_cbe.Int, &_aegg); _cfaf != nil {
					return _cfaf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui1"}:
				_cbe.Ui1 = new(uint8)
				if _fffbb := d.DecodeElement(_cbe.Ui1, &_aegg); _fffbb != nil {
					return _fffbb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui2"}:
				_cbe.Ui2 = new(uint16)
				if _def := d.DecodeElement(_cbe.Ui2, &_aegg); _def != nil {
					return _def
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui4"}:
				_cbe.Ui4 = new(uint32)
				if _edfd := d.DecodeElement(_cbe.Ui4, &_aegg); _edfd != nil {
					return _edfd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui8"}:
				_cbe.Ui8 = new(uint64)
				if _aebd := d.DecodeElement(_cbe.Ui8, &_aegg); _aebd != nil {
					return _aebd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "uint"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "uint"}:
				_cbe.Uint = new(uint32)
				if _gbcdf := d.DecodeElement(_cbe.Uint, &_aegg); _gbcdf != nil {
					return _gbcdf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r4"}:
				_cbe.R4 = new(float32)
				if _bgcc := d.DecodeElement(_cbe.R4, &_aegg); _bgcc != nil {
					return _bgcc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r8"}:
				_cbe.R8 = new(float64)
				if _gege := d.DecodeElement(_cbe.R8, &_aegg); _gege != nil {
					return _gege
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "decimal"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "decimal"}:
				_cbe.Decimal = new(float64)
				if _aecg := d.DecodeElement(_cbe.Decimal, &_aegg); _aecg != nil {
					return _aecg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "lpstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "lpstr"}:
				_cbe.Lpstr = new(string)
				if _ccfg := d.DecodeElement(_cbe.Lpstr, &_aegg); _ccfg != nil {
					return _ccfg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "lpwstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "lpwstr"}:
				_cbe.Lpwstr = new(string)
				if _egdgc := d.DecodeElement(_cbe.Lpwstr, &_aegg); _egdgc != nil {
					return _egdgc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bstr"}:
				_cbe.Bstr = new(string)
				if _gad := d.DecodeElement(_cbe.Bstr, &_aegg); _gad != nil {
					return _gad
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "date"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "date"}:
				_cbe.Date = new(_f.Time)
				if _gdbf := d.DecodeElement(_cbe.Date, &_aegg); _gdbf != nil {
					return _gdbf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "filetime"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "filetime"}:
				_cbe.Filetime = new(_f.Time)
				if _bdaa := d.DecodeElement(_cbe.Filetime, &_aegg); _bdaa != nil {
					return _bdaa
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bool"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bool"}:
				_cbe.Bool = new(bool)
				if _edee := d.DecodeElement(_cbe.Bool, &_aegg); _edee != nil {
					return _edee
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "cy"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "cy"}:
				_cbe.Cy = new(string)
				if _egc := d.DecodeElement(_cbe.Cy, &_aegg); _egc != nil {
					return _egc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "error"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "error"}:
				_cbe.Error = new(string)
				if _ecacg := d.DecodeElement(_cbe.Error, &_aegg); _ecacg != nil {
					return _ecacg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "stream"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "stream"}:
				_cbe.Stream = new(string)
				if _edff := d.DecodeElement(_cbe.Stream, &_aegg); _edff != nil {
					return _edff
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ostream"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ostream"}:
				_cbe.Ostream = new(string)
				if _feag := d.DecodeElement(_cbe.Ostream, &_aegg); _feag != nil {
					return _feag
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "storage"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "storage"}:
				_cbe.Storage = new(string)
				if _aceb := d.DecodeElement(_cbe.Storage, &_aegg); _aceb != nil {
					return _aceb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ostorage"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ostorage"}:
				_cbe.Ostorage = new(string)
				if _ggcb := d.DecodeElement(_cbe.Ostorage, &_aegg); _ggcb != nil {
					return _ggcb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "vstream"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "vstream"}:
				_cbe.Vstream = NewVstream()
				if _fggf := d.DecodeElement(_cbe.Vstream, &_aegg); _fggf != nil {
					return _fggf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "clsid"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "clsid"}:
				_cbe.Clsid = new(string)
				if _dac := d.DecodeElement(_cbe.Clsid, &_aegg); _dac != nil {
					return _dac
				}
			default:
				_ae.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Variant\u0020\u0025v", _aegg.Name)
				if _adede := d.Skip(); _adede != nil {
					return _adede
				}
			}
		case _d.EndElement:
			break _adgg
		case _d.CharData:
		}
	}
	return nil
}

// Validate validates the Vstream and its children
func (_egaf *Vstream) Validate() error { return _egaf.ValidateWithPath("Vstream") }

// Validate validates the Variant and its children
func (_ecdd *Variant) Validate() error { return _ecdd.ValidateWithPath("Variant") }

// Validate validates the CT_Null and its children
func (_aae *CT_Null) Validate() error { return _aae.ValidateWithPath("CT_Null") }

var ST_CyPatternRe = _c.MustCompile(ST_CyPattern)

const (
	ST_VectorBaseTypeUnset    ST_VectorBaseType = 0
	ST_VectorBaseTypeVariant  ST_VectorBaseType = 1
	ST_VectorBaseTypeI1       ST_VectorBaseType = 2
	ST_VectorBaseTypeI2       ST_VectorBaseType = 3
	ST_VectorBaseTypeI4       ST_VectorBaseType = 4
	ST_VectorBaseTypeI8       ST_VectorBaseType = 5
	ST_VectorBaseTypeUi1      ST_VectorBaseType = 6
	ST_VectorBaseTypeUi2      ST_VectorBaseType = 7
	ST_VectorBaseTypeUi4      ST_VectorBaseType = 8
	ST_VectorBaseTypeUi8      ST_VectorBaseType = 9
	ST_VectorBaseTypeR4       ST_VectorBaseType = 10
	ST_VectorBaseTypeR8       ST_VectorBaseType = 11
	ST_VectorBaseTypeLpstr    ST_VectorBaseType = 12
	ST_VectorBaseTypeLpwstr   ST_VectorBaseType = 13
	ST_VectorBaseTypeBstr     ST_VectorBaseType = 14
	ST_VectorBaseTypeDate     ST_VectorBaseType = 15
	ST_VectorBaseTypeFiletime ST_VectorBaseType = 16
	ST_VectorBaseTypeBool     ST_VectorBaseType = 17
	ST_VectorBaseTypeCy       ST_VectorBaseType = 18
	ST_VectorBaseTypeError    ST_VectorBaseType = 19
	ST_VectorBaseTypeClsid    ST_VectorBaseType = 20
)

func NewCT_Empty() *CT_Empty { _agce := &CT_Empty{}; return _agce }
func (_ffa *CT_Array) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ffa.BaseTypeAttr = ST_ArrayBaseType(1)
	for _, _gab := range start.Attr {
		if _gab.Name.Local == "uBounds" {
			_bdf, _fea := _a.ParseInt(_gab.Value, 10, 32)
			if _fea != nil {
				return _fea
			}
			_ffa.UBoundsAttr = int32(_bdf)
			continue
		}
		if _gab.Name.Local == "baseType" {
			_ffa.BaseTypeAttr.UnmarshalXMLAttr(_gab)
			continue
		}
		if _gab.Name.Local == "lBounds" {
			_fb, _dcea := _a.ParseInt(_gab.Value, 10, 32)
			if _dcea != nil {
				return _dcea
			}
			_ffa.LBoundsAttr = int32(_fb)
			continue
		}
	}
_bcb:
	for {
		_aad, _adf := d.Token()
		if _adf != nil {
			return _adf
		}
		switch _egdg := _aad.(type) {
		case _d.StartElement:
			switch _egdg.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "variant"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "variant"}:
				_ge := NewVariant()
				if _gag := d.DecodeElement(_ge, &_egdg); _gag != nil {
					return _gag
				}
				_ffa.Variant = append(_ffa.Variant, _ge)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i1"}:
				var _cba int8
				if _cag := d.DecodeElement(&_cba, &_egdg); _cag != nil {
					return _cag
				}
				_ffa.I1 = append(_ffa.I1, _cba)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i2"}:
				var _beb int16
				if _efb := d.DecodeElement(&_beb, &_egdg); _efb != nil {
					return _efb
				}
				_ffa.I2 = append(_ffa.I2, _beb)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i4"}:
				var _fbb int32
				if _bcf := d.DecodeElement(&_fbb, &_egdg); _bcf != nil {
					return _bcf
				}
				_ffa.I4 = append(_ffa.I4, _fbb)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "int"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "int"}:
				var _ed int32
				if _eeg := d.DecodeElement(&_ed, &_egdg); _eeg != nil {
					return _eeg
				}
				_ffa.Int = append(_ffa.Int, _ed)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui1"}:
				var _cfa uint8
				if _fac := d.DecodeElement(&_cfa, &_egdg); _fac != nil {
					return _fac
				}
				_ffa.Ui1 = append(_ffa.Ui1, _cfa)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui2"}:
				var _dga uint16
				if _fge := d.DecodeElement(&_dga, &_egdg); _fge != nil {
					return _fge
				}
				_ffa.Ui2 = append(_ffa.Ui2, _dga)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui4"}:
				var _ebf uint32
				if _fdf := d.DecodeElement(&_ebf, &_egdg); _fdf != nil {
					return _fdf
				}
				_ffa.Ui4 = append(_ffa.Ui4, _ebf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "uint"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "uint"}:
				var _aedf uint32
				if _fee := d.DecodeElement(&_aedf, &_egdg); _fee != nil {
					return _fee
				}
				_ffa.Uint = append(_ffa.Uint, _aedf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r4"}:
				var _eba float32
				if _ccg := d.DecodeElement(&_eba, &_egdg); _ccg != nil {
					return _ccg
				}
				_ffa.R4 = append(_ffa.R4, _eba)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r8"}:
				var _edd float64
				if _fdg := d.DecodeElement(&_edd, &_egdg); _fdg != nil {
					return _fdg
				}
				_ffa.R8 = append(_ffa.R8, _edd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "decimal"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "decimal"}:
				var _cbag float64
				if _gcf := d.DecodeElement(&_cbag, &_egdg); _gcf != nil {
					return _gcf
				}
				_ffa.Decimal = append(_ffa.Decimal, _cbag)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bstr"}:
				var _aadc string
				if _gdda := d.DecodeElement(&_aadc, &_egdg); _gdda != nil {
					return _gdda
				}
				_ffa.Bstr = append(_ffa.Bstr, _aadc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "date"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "date"}:
				var _gbcd _f.Time
				if _bed := d.DecodeElement(&_gbcd, &_egdg); _bed != nil {
					return _bed
				}
				_ffa.Date = append(_ffa.Date, _gbcd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bool"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bool"}:
				var _gfdf bool
				if _deb := d.DecodeElement(&_gfdf, &_egdg); _deb != nil {
					return _deb
				}
				_ffa.Bool = append(_ffa.Bool, _gfdf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "error"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "error"}:
				var _ebd string
				if _ecc := d.DecodeElement(&_ebd, &_egdg); _ecc != nil {
					return _ecc
				}
				_ffa.Error = append(_ffa.Error, _ebd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "cy"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "cy"}:
				var _aec string
				if _fgd := d.DecodeElement(&_aec, &_egdg); _fgd != nil {
					return _fgd
				}
				_ffa.Cy = append(_ffa.Cy, _aec)
			default:
				_ae.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Array\u0020\u0025v", _egdg.Name)
				if _gaga := d.Skip(); _gaga != nil {
					return _gaga
				}
			}
		case _d.EndElement:
			break _bcb
		case _d.CharData:
		}
	}
	return nil
}
func (_cfba ST_VectorBaseType) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_cfba.String(), start)
}

type Empty struct{ CT_Empty }

// Validate validates the Vector and its children
func (_eef *Vector) Validate() error { return _eef.ValidateWithPath("Vector") }

// Validate validates the CT_Array and its children
func (_ege *CT_Array) Validate() error { return _ege.ValidateWithPath("CT_Array") }

// Validate validates the CT_Variant and its children
func (_dgg *CT_Variant) Validate() error { return _dgg.ValidateWithPath("CT_Variant") }
func (_eafg *Vstream) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return _eafg.CT_Vstream.MarshalXML(e, start)
}
func NewVstream() *Vstream { _cgf := &Vstream{}; _cgf.CT_Vstream = *NewCT_Vstream(); return _cgf }
func (_beg *ST_VectorBaseType) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_beg = 0
	case "variant":
		*_beg = 1
	case "i1":
		*_beg = 2
	case "i2":
		*_beg = 3
	case "i4":
		*_beg = 4
	case "i8":
		*_beg = 5
	case "ui1":
		*_beg = 6
	case "ui2":
		*_beg = 7
	case "ui4":
		*_beg = 8
	case "ui8":
		*_beg = 9
	case "r4":
		*_beg = 10
	case "r8":
		*_beg = 11
	case "lpstr":
		*_beg = 12
	case "lpwstr":
		*_beg = 13
	case "bstr":
		*_beg = 14
	case "date":
		*_beg = 15
	case "filetime":
		*_beg = 16
	case "bool":
		*_beg = 17
	case "cy":
		*_beg = 18
	case "error":
		*_beg = 19
	case "clsid":
		*_beg = 20
	}
	return nil
}
func (_cbfb ST_ArrayBaseType) ValidateWithPath(path string) error {
	switch _cbfb {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17:
	default:
		return _g.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cbfb))
	}
	return nil
}
func (_egf *CT_Vstream) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_egf.VersionAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	for _, _adc := range start.Attr {
		if _adc.Name.Local == "version" {
			_bccf, _acdg := _adc.Value, error(nil)
			if _acdg != nil {
				return _acdg
			}
			_egf.VersionAttr = _bccf
			continue
		}
	}
	for {
		_ebdd, _fgba := d.Token()
		if _fgba != nil {
			return _g.Errorf("parsing\u0020CT_Vstream:\u0020%s", _fgba)
		}
		if _cgbg, _ggbb := _ebdd.(_d.CharData); _ggbb {
			_egf.Content = string(_cgbg)
		}
		if _gfeb, _cbad := _ebdd.(_d.EndElement); _cbad && _gfeb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ggb *CT_Variant) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _ggb.Variant != nil {
		_ceg := _d.StartElement{Name: _d.Name{Local: "vt:variant"}}
		e.EncodeElement(_ggb.Variant, _ceg)
	}
	if _ggb.Vector != nil {
		_afc := _d.StartElement{Name: _d.Name{Local: "vt:vector"}}
		e.EncodeElement(_ggb.Vector, _afc)
	}
	if _ggb.Array != nil {
		_dbd := _d.StartElement{Name: _d.Name{Local: "vt:array"}}
		e.EncodeElement(_ggb.Array, _dbd)
	}
	if _ggb.Blob != nil {
		_bcg := _d.StartElement{Name: _d.Name{Local: "vt:blob"}}
		_ae.AddPreserveSpaceAttr(&_bcg, *_ggb.Blob)
		e.EncodeElement(_ggb.Blob, _bcg)
	}
	if _ggb.Oblob != nil {
		_ede := _d.StartElement{Name: _d.Name{Local: "vt:oblob"}}
		_ae.AddPreserveSpaceAttr(&_ede, *_ggb.Oblob)
		e.EncodeElement(_ggb.Oblob, _ede)
	}
	if _ggb.Empty != nil {
		_eaa := _d.StartElement{Name: _d.Name{Local: "vt:empty"}}
		e.EncodeElement(_ggb.Empty, _eaa)
	}
	if _ggb.Null != nil {
		_gfee := _d.StartElement{Name: _d.Name{Local: "vt:null"}}
		e.EncodeElement(_ggb.Null, _gfee)
	}
	if _ggb.I1 != nil {
		_fdff := _d.StartElement{Name: _d.Name{Local: "vt:i1"}}
		e.EncodeElement(_ggb.I1, _fdff)
	}
	if _ggb.I2 != nil {
		_bebe := _d.StartElement{Name: _d.Name{Local: "vt:i2"}}
		e.EncodeElement(_ggb.I2, _bebe)
	}
	if _ggb.I4 != nil {
		_gdbc := _d.StartElement{Name: _d.Name{Local: "vt:i4"}}
		e.EncodeElement(_ggb.I4, _gdbc)
	}
	if _ggb.I8 != nil {
		_geg := _d.StartElement{Name: _d.Name{Local: "vt:i8"}}
		e.EncodeElement(_ggb.I8, _geg)
	}
	if _ggb.Int != nil {
		_gaa := _d.StartElement{Name: _d.Name{Local: "vt:int"}}
		e.EncodeElement(_ggb.Int, _gaa)
	}
	if _ggb.Ui1 != nil {
		_dgb := _d.StartElement{Name: _d.Name{Local: "vt:ui1"}}
		e.EncodeElement(_ggb.Ui1, _dgb)
	}
	if _ggb.Ui2 != nil {
		_fgcg := _d.StartElement{Name: _d.Name{Local: "vt:ui2"}}
		e.EncodeElement(_ggb.Ui2, _fgcg)
	}
	if _ggb.Ui4 != nil {
		_afe := _d.StartElement{Name: _d.Name{Local: "vt:ui4"}}
		e.EncodeElement(_ggb.Ui4, _afe)
	}
	if _ggb.Ui8 != nil {
		_efd := _d.StartElement{Name: _d.Name{Local: "vt:ui8"}}
		e.EncodeElement(_ggb.Ui8, _efd)
	}
	if _ggb.Uint != nil {
		_dge := _d.StartElement{Name: _d.Name{Local: "vt:uint"}}
		e.EncodeElement(_ggb.Uint, _dge)
	}
	if _ggb.R4 != nil {
		_afde := _d.StartElement{Name: _d.Name{Local: "vt:r4"}}
		e.EncodeElement(_ggb.R4, _afde)
	}
	if _ggb.R8 != nil {
		_fbe := _d.StartElement{Name: _d.Name{Local: "vt:r8"}}
		e.EncodeElement(_ggb.R8, _fbe)
	}
	if _ggb.Decimal != nil {
		_fcf := _d.StartElement{Name: _d.Name{Local: "vt:decimal"}}
		e.EncodeElement(_ggb.Decimal, _fcf)
	}
	if _ggb.Lpstr != nil {
		_ddag := _d.StartElement{Name: _d.Name{Local: "vt:lpstr"}}
		_ae.AddPreserveSpaceAttr(&_ddag, *_ggb.Lpstr)
		e.EncodeElement(_ggb.Lpstr, _ddag)
	}
	if _ggb.Lpwstr != nil {
		_deab := _d.StartElement{Name: _d.Name{Local: "vt:lpwstr"}}
		_ae.AddPreserveSpaceAttr(&_deab, *_ggb.Lpwstr)
		e.EncodeElement(_ggb.Lpwstr, _deab)
	}
	if _ggb.Bstr != nil {
		_fab := _d.StartElement{Name: _d.Name{Local: "vt:bstr"}}
		_ae.AddPreserveSpaceAttr(&_fab, *_ggb.Bstr)
		e.EncodeElement(_ggb.Bstr, _fab)
	}
	if _ggb.Date != nil {
		_cgb := _d.StartElement{Name: _d.Name{Local: "vt:date"}}
		e.EncodeElement(_ggb.Date, _cgb)
	}
	if _ggb.Filetime != nil {
		_ccc := _d.StartElement{Name: _d.Name{Local: "vt:filetime"}}
		e.EncodeElement(_ggb.Filetime, _ccc)
	}
	if _ggb.Bool != nil {
		_fbd := _d.StartElement{Name: _d.Name{Local: "vt:bool"}}
		e.EncodeElement(_ggb.Bool, _fbd)
	}
	if _ggb.Cy != nil {
		_fda := _d.StartElement{Name: _d.Name{Local: "vt:cy"}}
		_ae.AddPreserveSpaceAttr(&_fda, *_ggb.Cy)
		e.EncodeElement(_ggb.Cy, _fda)
	}
	if _ggb.Error != nil {
		_acf := _d.StartElement{Name: _d.Name{Local: "vt:error"}}
		_ae.AddPreserveSpaceAttr(&_acf, *_ggb.Error)
		e.EncodeElement(_ggb.Error, _acf)
	}
	if _ggb.Stream != nil {
		_acd := _d.StartElement{Name: _d.Name{Local: "vt:stream"}}
		_ae.AddPreserveSpaceAttr(&_acd, *_ggb.Stream)
		e.EncodeElement(_ggb.Stream, _acd)
	}
	if _ggb.Ostream != nil {
		_dba := _d.StartElement{Name: _d.Name{Local: "vt:ostream"}}
		_ae.AddPreserveSpaceAttr(&_dba, *_ggb.Ostream)
		e.EncodeElement(_ggb.Ostream, _dba)
	}
	if _ggb.Storage != nil {
		_fce := _d.StartElement{Name: _d.Name{Local: "vt:storage"}}
		_ae.AddPreserveSpaceAttr(&_fce, *_ggb.Storage)
		e.EncodeElement(_ggb.Storage, _fce)
	}
	if _ggb.Ostorage != nil {
		_bdag := _d.StartElement{Name: _d.Name{Local: "vt:ostorage"}}
		_ae.AddPreserveSpaceAttr(&_bdag, *_ggb.Ostorage)
		e.EncodeElement(_ggb.Ostorage, _bdag)
	}
	if _ggb.Vstream != nil {
		_daa := _d.StartElement{Name: _d.Name{Local: "vt:vstream"}}
		e.EncodeElement(_ggb.Vstream, _daa)
	}
	if _ggb.Clsid != nil {
		_bgd := _d.StartElement{Name: _d.Name{Local: "vt:clsid"}}
		_ae.AddPreserveSpaceAttr(&_bgd, *_ggb.Clsid)
		e.EncodeElement(_ggb.Clsid, _bgd)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type ST_VectorBaseType byte

// ValidateWithPath validates the CT_Array and its children, prefixing error messages with path
func (_eab *CT_Array) ValidateWithPath(path string) error {
	if _eab.BaseTypeAttr == ST_ArrayBaseTypeUnset {
		return _g.Errorf("\u0025s/BaseTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _dcecf := _eab.BaseTypeAttr.ValidateWithPath(path + "\u002fBaseTypeAttr"); _dcecf != nil {
		return _dcecf
	}
	for _db, _gce := range _eab.Variant {
		if _cae := _gce.ValidateWithPath(_g.Sprintf("\u0025s\u002fVariant\u005b\u0025d\u005d", path, _db)); _cae != nil {
			return _cae
		}
	}
	for _bbe, _bda := range _eab.Error {
		if !ST_ErrorPatternRe.MatchString(_bda) {
			return _g.Errorf("%s\u002fm\u002eError\u005b\u0025d\u005d\u0020must match\u0020\u0027\u0025s\u0027 (have\u0020%v\u0029", path, _bbe, ST_ErrorPatternRe, _bda)
		}
	}
	for _cff, _aeg := range _eab.Cy {
		if !ST_CyPatternRe.MatchString(_aeg) {
			return _g.Errorf("\u0025s/m\u002eCy[\u0025d]\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _cff, ST_CyPatternRe, _aeg)
		}
	}
	return nil
}

// ValidateWithPath validates the Null and its children, prefixing error messages with path
func (_dcdc *Null) ValidateWithPath(path string) error {
	if _eff := _dcdc.CT_Null.ValidateWithPath(path); _eff != nil {
		return _eff
	}
	return nil
}
func NewCT_Vector() *CT_Vector {
	_gee := &CT_Vector{}
	_gee.BaseTypeAttr = ST_VectorBaseType(1)
	return _gee
}
func (_bag *ST_ArrayBaseType) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_gcdc, _bfc := d.Token()
	if _bfc != nil {
		return _bfc
	}
	if _feeg, _gbaa := _gcdc.(_d.EndElement); _gbaa && _feeg.Name == start.Name {
		*_bag = 1
		return nil
	}
	if _gffa, _eddg := _gcdc.(_d.CharData); !_eddg {
		return _g.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gcdc)
	} else {
		switch string(_gffa) {
		case "":
			*_bag = 0
		case "variant":
			*_bag = 1
		case "i1":
			*_bag = 2
		case "i2":
			*_bag = 3
		case "i4":
			*_bag = 4
		case "int":
			*_bag = 5
		case "ui1":
			*_bag = 6
		case "ui2":
			*_bag = 7
		case "ui4":
			*_bag = 8
		case "uint":
			*_bag = 9
		case "r4":
			*_bag = 10
		case "r8":
			*_bag = 11
		case "decimal":
			*_bag = 12
		case "bstr":
			*_bag = 13
		case "date":
			*_bag = 14
		case "bool":
			*_bag = 15
		case "cy":
			*_bag = 16
		case "error":
			*_bag = 17
		}
	}
	_gcdc, _bfc = d.Token()
	if _bfc != nil {
		return _bfc
	}
	if _gbb, _gdgg := _gcdc.(_d.EndElement); _gdgg && _gbb.Name == start.Name {
		return nil
	}
	return _g.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gcdc)
}

// ValidateWithPath validates the CT_Variant and its children, prefixing error messages with path
func (_gddc *CT_Variant) ValidateWithPath(path string) error {
	if _gddc.Variant != nil {
		if _bfa := _gddc.Variant.ValidateWithPath(path + "\u002fVariant"); _bfa != nil {
			return _bfa
		}
	}
	if _gddc.Vector != nil {
		if _cccc := _gddc.Vector.ValidateWithPath(path + "\u002fVector"); _cccc != nil {
			return _cccc
		}
	}
	if _gddc.Array != nil {
		if _faf := _gddc.Array.ValidateWithPath(path + "\u002fArray"); _faf != nil {
			return _faf
		}
	}
	if _gddc.Empty != nil {
		if _ade := _gddc.Empty.ValidateWithPath(path + "\u002fEmpty"); _ade != nil {
			return _ade
		}
	}
	if _gddc.Null != nil {
		if _fcb := _gddc.Null.ValidateWithPath(path + "\u002fNull"); _fcb != nil {
			return _fcb
		}
	}
	if _gddc.Cy != nil {
		if !ST_CyPatternRe.MatchString(*_gddc.Cy) {
			return _g.Errorf("\u0025s\u002fm\u002eCy\u0020must\u0020match\u0020\u0027%s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, ST_CyPatternRe, *_gddc.Cy)
		}
	}
	if _gddc.Error != nil {
		if !ST_ErrorPatternRe.MatchString(*_gddc.Error) {
			return _g.Errorf("\u0025s/m\u002eError\u0020must\u0020match\u0020\u0027\u0025s' \u0028have\u0020\u0025v\u0029", path, ST_ErrorPatternRe, *_gddc.Error)
		}
	}
	if _gddc.Vstream != nil {
		if _aff := _gddc.Vstream.ValidateWithPath(path + "\u002fVstream"); _aff != nil {
			return _aff
		}
	}
	if _gddc.Clsid != nil {
		if !_ec.ST_GuidPatternRe.MatchString(*_gddc.Clsid) {
			return _g.Errorf("\u0025s/m\u002eClsid\u0020must\u0020match\u0020\u0027\u0025s' \u0028have\u0020\u0025v\u0029", path, _ec.ST_GuidPatternRe, *_gddc.Clsid)
		}
	}
	return nil
}
func (_dfda ST_ArrayBaseType) String() string {
	switch _dfda {
	case 0:
		return ""
	case 1:
		return "variant"
	case 2:
		return "i1"
	case 3:
		return "i2"
	case 4:
		return "i4"
	case 5:
		return "int"
	case 6:
		return "ui1"
	case 7:
		return "ui2"
	case 8:
		return "ui4"
	case 9:
		return "uint"
	case 10:
		return "r4"
	case 11:
		return "r8"
	case 12:
		return "decimal"
	case 13:
		return "bstr"
	case 14:
		return "date"
	case 15:
		return "bool"
	case 16:
		return "cy"
	case 17:
		return "error"
	}
	return ""
}

// ValidateWithPath validates the Vector and its children, prefixing error messages with path
func (_gfdfg *Vector) ValidateWithPath(path string) error {
	if _cfef := _gfdfg.CT_Vector.ValidateWithPath(path); _cfef != nil {
		return _cfef
	}
	return nil
}

// ValidateWithPath validates the Variant and its children, prefixing error messages with path
func (_gea *Variant) ValidateWithPath(path string) error {
	if _fafg := _gea.CT_Variant.ValidateWithPath(path); _fafg != nil {
		return _fafg
	}
	return nil
}
func NewCT_Null() *CT_Null { _aggd := &CT_Null{}; return _aggd }

const (
	ST_ArrayBaseTypeUnset   ST_ArrayBaseType = 0
	ST_ArrayBaseTypeVariant ST_ArrayBaseType = 1
	ST_ArrayBaseTypeI1      ST_ArrayBaseType = 2
	ST_ArrayBaseTypeI2      ST_ArrayBaseType = 3
	ST_ArrayBaseTypeI4      ST_ArrayBaseType = 4
	ST_ArrayBaseTypeInt     ST_ArrayBaseType = 5
	ST_ArrayBaseTypeUi1     ST_ArrayBaseType = 6
	ST_ArrayBaseTypeUi2     ST_ArrayBaseType = 7
	ST_ArrayBaseTypeUi4     ST_ArrayBaseType = 8
	ST_ArrayBaseTypeUint    ST_ArrayBaseType = 9
	ST_ArrayBaseTypeR4      ST_ArrayBaseType = 10
	ST_ArrayBaseTypeR8      ST_ArrayBaseType = 11
	ST_ArrayBaseTypeDecimal ST_ArrayBaseType = 12
	ST_ArrayBaseTypeBstr    ST_ArrayBaseType = 13
	ST_ArrayBaseTypeDate    ST_ArrayBaseType = 14
	ST_ArrayBaseTypeBool    ST_ArrayBaseType = 15
	ST_ArrayBaseTypeCy      ST_ArrayBaseType = 16
	ST_ArrayBaseTypeError   ST_ArrayBaseType = 17
)

type ST_ArrayBaseType byte

func (_cf *Array) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return _cf.CT_Array.MarshalXML(e, start)
}

const ST_ErrorPattern = "\u005cs\u002a0x[0\u002d9A\u002dZa\u002dz\u005d\u007b8\u007d\u005cs\u002a"

func NewCT_Variant() *CT_Variant { _cbf := &CT_Variant{}; return _cbf }

// ValidateWithPath validates the Vstream and its children, prefixing error messages with path
func (_aead *Vstream) ValidateWithPath(path string) error {
	if _bdfc := _aead.CT_Vstream.ValidateWithPath(path); _bdfc != nil {
		return _bdfc
	}
	return nil
}
func (_aabe ST_VectorBaseType) ValidateWithPath(path string) error {
	switch _aabe {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20:
	default:
		return _g.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aabe))
	}
	return nil
}

// ValidateWithPath validates the CT_Vector and its children, prefixing error messages with path
func (_bfbb *CT_Vector) ValidateWithPath(path string) error {
	if _bfbb.BaseTypeAttr == ST_VectorBaseTypeUnset {
		return _g.Errorf("\u0025s/BaseTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _eebb := _bfbb.BaseTypeAttr.ValidateWithPath(path + "\u002fBaseTypeAttr"); _eebb != nil {
		return _eebb
	}
	for _baa, _fecd := range _bfbb.Variant {
		if _egg := _fecd.ValidateWithPath(_g.Sprintf("\u0025s\u002fVariant\u005b\u0025d\u005d", path, _baa)); _egg != nil {
			return _egg
		}
	}
	for _aaeg, _eca := range _bfbb.Cy {
		if !ST_CyPatternRe.MatchString(_eca) {
			return _g.Errorf("\u0025s/m\u002eCy[\u0025d]\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _aaeg, ST_CyPatternRe, _eca)
		}
	}
	for _cadg, _aaa := range _bfbb.Error {
		if !ST_ErrorPatternRe.MatchString(_aaa) {
			return _g.Errorf("%s\u002fm\u002eError\u005b\u0025d\u005d\u0020must match\u0020\u0027\u0025s\u0027 (have\u0020%v\u0029", path, _cadg, ST_ErrorPatternRe, _aaa)
		}
	}
	for _gdfb, _dbc := range _bfbb.Clsid {
		if !_ec.ST_GuidPatternRe.MatchString(_dbc) {
			return _g.Errorf("%s\u002fm\u002eClsid\u005b\u0025d\u005d\u0020must match\u0020\u0027\u0025s\u0027 (have\u0020%v\u0029", path, _gdfb, _ec.ST_GuidPatternRe, _dbc)
		}
	}
	return nil
}

type CT_Array struct {
	LBoundsAttr  int32
	UBoundsAttr  int32
	BaseTypeAttr ST_ArrayBaseType
	Variant      []*Variant
	I1           []int8
	I2           []int16
	I4           []int32
	Int          []int32
	Ui1          []uint8
	Ui2          []uint16
	Ui4          []uint32
	Uint         []uint32
	R4           []float32
	R8           []float64
	Decimal      []float64
	Bstr         []string
	Date         []_f.Time
	Bool         []bool
	Error        []string
	Cy           []string
}

func (_gfe *CT_Array) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "lBounds"}, Value: _g.Sprintf("\u0025v", _gfe.LBoundsAttr)})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "uBounds"}, Value: _g.Sprintf("\u0025v", _gfe.UBoundsAttr)})
	_fa, _afd := _gfe.BaseTypeAttr.MarshalXMLAttr(_d.Name{Local: "baseType"})
	if _afd != nil {
		return _afd
	}
	start.Attr = append(start.Attr, _fa)
	e.EncodeToken(start)
	if _gfe.Variant != nil {
		_bbg := _d.StartElement{Name: _d.Name{Local: "vt:variant"}}
		for _, _gg := range _gfe.Variant {
			e.EncodeElement(_gg, _bbg)
		}
	}
	if _gfe.I1 != nil {
		_bgb := _d.StartElement{Name: _d.Name{Local: "vt:i1"}}
		for _, _dda := range _gfe.I1 {
			e.EncodeElement(_dda, _bgb)
		}
	}
	if _gfe.I2 != nil {
		_agg := _d.StartElement{Name: _d.Name{Local: "vt:i2"}}
		for _, _dc := range _gfe.I2 {
			e.EncodeElement(_dc, _agg)
		}
	}
	if _gfe.I4 != nil {
		_caa := _d.StartElement{Name: _d.Name{Local: "vt:i4"}}
		for _, _be := range _gfe.I4 {
			e.EncodeElement(_be, _caa)
		}
	}
	if _gfe.Int != nil {
		_bgf := _d.StartElement{Name: _d.Name{Local: "vt:int"}}
		for _, _gdc := range _gfe.Int {
			e.EncodeElement(_gdc, _bgf)
		}
	}
	if _gfe.Ui1 != nil {
		_fcc := _d.StartElement{Name: _d.Name{Local: "vt:ui1"}}
		for _, _gba := range _gfe.Ui1 {
			e.EncodeElement(_gba, _fcc)
		}
	}
	if _gfe.Ui2 != nil {
		_bc := _d.StartElement{Name: _d.Name{Local: "vt:ui2"}}
		for _, _bac := range _gfe.Ui2 {
			e.EncodeElement(_bac, _bc)
		}
	}
	if _gfe.Ui4 != nil {
		_aga := _d.StartElement{Name: _d.Name{Local: "vt:ui4"}}
		for _, _bba := range _gfe.Ui4 {
			e.EncodeElement(_bba, _aga)
		}
	}
	if _gfe.Uint != nil {
		_cece := _d.StartElement{Name: _d.Name{Local: "vt:uint"}}
		for _, _da := range _gfe.Uint {
			e.EncodeElement(_da, _cece)
		}
	}
	if _gfe.R4 != nil {
		_fed := _d.StartElement{Name: _d.Name{Local: "vt:r4"}}
		for _, _bdg := range _gfe.R4 {
			e.EncodeElement(_bdg, _fed)
		}
	}
	if _gfe.R8 != nil {
		_fgf := _d.StartElement{Name: _d.Name{Local: "vt:r8"}}
		for _, _ac := range _gfe.R8 {
			e.EncodeElement(_ac, _fgf)
		}
	}
	if _gfe.Decimal != nil {
		_ef := _d.StartElement{Name: _d.Name{Local: "vt:decimal"}}
		for _, _fff := range _gfe.Decimal {
			e.EncodeElement(_fff, _ef)
		}
	}
	if _gfe.Bstr != nil {
		_fcd := _d.StartElement{Name: _d.Name{Local: "vt:bstr"}}
		for _, _gdg := range _gfe.Bstr {
			e.EncodeElement(_gdg, _fcd)
		}
	}
	if _gfe.Date != nil {
		_bde := _d.StartElement{Name: _d.Name{Local: "vt:date"}}
		for _, _dea := range _gfe.Date {
			e.EncodeElement(_dea, _bde)
		}
	}
	if _gfe.Bool != nil {
		_bce := _d.StartElement{Name: _d.Name{Local: "vt:bool"}}
		for _, _dcf := range _gfe.Bool {
			e.EncodeElement(_dcf, _bce)
		}
	}
	if _gfe.Error != nil {
		_aa := _d.StartElement{Name: _d.Name{Local: "vt:error"}}
		for _, _gfde := range _gfe.Error {
			e.EncodeElement(_gfde, _aa)
		}
	}
	if _gfe.Cy != nil {
		_acg := _d.StartElement{Name: _d.Name{Local: "vt:cy"}}
		for _, _fffb := range _gfe.Cy {
			e.EncodeElement(_fffb, _acg)
		}
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type Null struct{ CT_Null }

func (_dcb *Vstream) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_dcb.CT_Vstream = *NewCT_Vstream()
	for _, _cgcd := range start.Attr {
		if _cgcd.Name.Local == "version" {
			_ddaca, _dfgd := _cgcd.Value, error(nil)
			if _dfgd != nil {
				return _dfgd
			}
			_dcb.VersionAttr = _ddaca
			continue
		}
	}
	for {
		_gcfg, _cbcf := d.Token()
		if _cbcf != nil {
			return _g.Errorf("parsing\u0020Vstream:\u0020\u0025s", _cbcf)
		}
		if _ffaa, _afa := _gcfg.(_d.EndElement); _afa && _ffaa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_adba *ST_VectorBaseType) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_gagf, _bdfe := d.Token()
	if _bdfe != nil {
		return _bdfe
	}
	if _cdaa, _cbee := _gagf.(_d.EndElement); _cbee && _cdaa.Name == start.Name {
		*_adba = 1
		return nil
	}
	if _bga, _dbga := _gagf.(_d.CharData); !_dbga {
		return _g.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gagf)
	} else {
		switch string(_bga) {
		case "":
			*_adba = 0
		case "variant":
			*_adba = 1
		case "i1":
			*_adba = 2
		case "i2":
			*_adba = 3
		case "i4":
			*_adba = 4
		case "i8":
			*_adba = 5
		case "ui1":
			*_adba = 6
		case "ui2":
			*_adba = 7
		case "ui4":
			*_adba = 8
		case "ui8":
			*_adba = 9
		case "r4":
			*_adba = 10
		case "r8":
			*_adba = 11
		case "lpstr":
			*_adba = 12
		case "lpwstr":
			*_adba = 13
		case "bstr":
			*_adba = 14
		case "date":
			*_adba = 15
		case "filetime":
			*_adba = 16
		case "bool":
			*_adba = 17
		case "cy":
			*_adba = 18
		case "error":
			*_adba = 19
		case "clsid":
			*_adba = 20
		}
	}
	_gagf, _bdfe = d.Token()
	if _bdfe != nil {
		return _bdfe
	}
	if _cdae, _egce := _gagf.(_d.EndElement); _egce && _cdae.Name == start.Name {
		return nil
	}
	return _g.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gagf)
}

type Array struct{ CT_Array }
type CT_Vstream struct {
	VersionAttr string
	Content     string
}

func (_fef *Variant) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return _fef.CT_Variant.MarshalXML(e, start)
}
func (_bgcf *Vector) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bgcf.CT_Vector = *NewCT_Vector()
	for _, _adb := range start.Attr {
		if _adb.Name.Local == "size" {
			_fafe, _gdaa := _a.ParseUint(_adb.Value, 10, 32)
			if _gdaa != nil {
				return _gdaa
			}
			_bgcf.SizeAttr = uint32(_fafe)
			continue
		}
		if _adb.Name.Local == "baseType" {
			_bgcf.BaseTypeAttr.UnmarshalXMLAttr(_adb)
			continue
		}
	}
_ccgf:
	for {
		_egag, _gged := d.Token()
		if _gged != nil {
			return _gged
		}
		switch _ecbf := _egag.(type) {
		case _d.StartElement:
			switch _ecbf.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "variant"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "variant"}:
				_agbc := NewVariant()
				if _cceb := d.DecodeElement(_agbc, &_ecbf); _cceb != nil {
					return _cceb
				}
				_bgcf.Variant = append(_bgcf.Variant, _agbc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i1"}:
				var _dgdc int8
				if _cbadb := d.DecodeElement(&_dgdc, &_ecbf); _cbadb != nil {
					return _cbadb
				}
				_bgcf.I1 = append(_bgcf.I1, _dgdc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i2"}:
				var _bbed int16
				if _abd := d.DecodeElement(&_bbed, &_ecbf); _abd != nil {
					return _abd
				}
				_bgcf.I2 = append(_bgcf.I2, _bbed)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i4"}:
				var _ccdf int32
				if _fccg := d.DecodeElement(&_ccdf, &_ecbf); _fccg != nil {
					return _fccg
				}
				_bgcf.I4 = append(_bgcf.I4, _ccdf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i8"}:
				var _ecdg int64
				if _gcaf := d.DecodeElement(&_ecdg, &_ecbf); _gcaf != nil {
					return _gcaf
				}
				_bgcf.I8 = append(_bgcf.I8, _ecdg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui1"}:
				var _adda uint8
				if _ffcb := d.DecodeElement(&_adda, &_ecbf); _ffcb != nil {
					return _ffcb
				}
				_bgcf.Ui1 = append(_bgcf.Ui1, _adda)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui2"}:
				var _gef uint16
				if _ffcf := d.DecodeElement(&_gef, &_ecbf); _ffcf != nil {
					return _ffcf
				}
				_bgcf.Ui2 = append(_bgcf.Ui2, _gef)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui4"}:
				var _afec uint32
				if _addd := d.DecodeElement(&_afec, &_ecbf); _addd != nil {
					return _addd
				}
				_bgcf.Ui4 = append(_bgcf.Ui4, _afec)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui8"}:
				var _gefg uint64
				if _ccfdb := d.DecodeElement(&_gefg, &_ecbf); _ccfdb != nil {
					return _ccfdb
				}
				_bgcf.Ui8 = append(_bgcf.Ui8, _gefg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r4"}:
				var _bdda float32
				if _acad := d.DecodeElement(&_bdda, &_ecbf); _acad != nil {
					return _acad
				}
				_bgcf.R4 = append(_bgcf.R4, _bdda)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r8"}:
				var _gbdf float64
				if _dgab := d.DecodeElement(&_gbdf, &_ecbf); _dgab != nil {
					return _dgab
				}
				_bgcf.R8 = append(_bgcf.R8, _gbdf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "lpstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "lpstr"}:
				var _eddd string
				if _cfbc := d.DecodeElement(&_eddd, &_ecbf); _cfbc != nil {
					return _cfbc
				}
				_bgcf.Lpstr = append(_bgcf.Lpstr, _eddd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "lpwstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "lpwstr"}:
				var _eae string
				if _cadf := d.DecodeElement(&_eae, &_ecbf); _cadf != nil {
					return _cadf
				}
				_bgcf.Lpwstr = append(_bgcf.Lpwstr, _eae)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bstr"}:
				var _gdfbe string
				if _bfba := d.DecodeElement(&_gdfbe, &_ecbf); _bfba != nil {
					return _bfba
				}
				_bgcf.Bstr = append(_bgcf.Bstr, _gdfbe)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "date"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "date"}:
				var _fcca _f.Time
				if _bedc := d.DecodeElement(&_fcca, &_ecbf); _bedc != nil {
					return _bedc
				}
				_bgcf.Date = append(_bgcf.Date, _fcca)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "filetime"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "filetime"}:
				var _cafc _f.Time
				if _deg := d.DecodeElement(&_cafc, &_ecbf); _deg != nil {
					return _deg
				}
				_bgcf.Filetime = append(_bgcf.Filetime, _cafc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bool"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bool"}:
				var _ggbg bool
				if _geb := d.DecodeElement(&_ggbg, &_ecbf); _geb != nil {
					return _geb
				}
				_bgcf.Bool = append(_bgcf.Bool, _ggbg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "cy"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "cy"}:
				var _bbd string
				if _bae := d.DecodeElement(&_bbd, &_ecbf); _bae != nil {
					return _bae
				}
				_bgcf.Cy = append(_bgcf.Cy, _bbd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "error"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "error"}:
				var _ddfd string
				if _agac := d.DecodeElement(&_ddfd, &_ecbf); _agac != nil {
					return _agac
				}
				_bgcf.Error = append(_bgcf.Error, _ddfd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "clsid"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "clsid"}:
				var _cfgfc string
				if _gbe := d.DecodeElement(&_cfgfc, &_ecbf); _gbe != nil {
					return _gbe
				}
				_bgcf.Clsid = append(_bgcf.Clsid, _cfgfc)
			default:
				_ae.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Vector\u0020\u0025v", _ecbf.Name)
				if _gcg := d.Skip(); _gcg != nil {
					return _gcg
				}
			}
		case _d.EndElement:
			break _ccgf
		case _d.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Empty and its children
func (_fdfc *CT_Empty) Validate() error { return _fdfc.ValidateWithPath("CT_Empty") }

// Validate validates the CT_Vstream and its children
func (_edcb *CT_Vstream) Validate() error { return _edcb.ValidateWithPath("CT_Vstream") }

const ST_CyPattern = "\u005cs\u002a\u005b0-9\u005d\u002a\u005c\u002e\u005b0\u002d9\u005d\u007b4\u007d\u005cs\u002a"

type Variant struct{ CT_Variant }
type CT_Vector struct {
	BaseTypeAttr ST_VectorBaseType
	SizeAttr     uint32
	Variant      []*Variant
	I1           []int8
	I2           []int16
	I4           []int32
	I8           []int64
	Ui1          []uint8
	Ui2          []uint16
	Ui4          []uint32
	Ui8          []uint64
	R4           []float32
	R8           []float64
	Lpstr        []string
	Lpwstr       []string
	Bstr         []string
	Date         []_f.Time
	Filetime     []_f.Time
	Bool         []bool
	Cy           []string
	Error        []string
	Clsid        []string
}

func (_fbg *CT_Variant) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_dagf:
	for {
		_fbf, _fgb := d.Token()
		if _fgb != nil {
			return _fgb
		}
		switch _fdd := _fbf.(type) {
		case _d.StartElement:
			switch _fdd.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "variant"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "variant"}:
				_fbg.Variant = NewVariant()
				if _ffg := d.DecodeElement(_fbg.Variant, &_fdd); _ffg != nil {
					return _ffg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "vector"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "vector"}:
				_fbg.Vector = NewVector()
				if _dbg := d.DecodeElement(_fbg.Vector, &_fdd); _dbg != nil {
					return _dbg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "array"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "array"}:
				_fbg.Array = NewArray()
				if _eag := d.DecodeElement(_fbg.Array, &_fdd); _eag != nil {
					return _eag
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "blob"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "blob"}:
				_fbg.Blob = new(string)
				if _cegc := d.DecodeElement(_fbg.Blob, &_fdd); _cegc != nil {
					return _cegc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "oblob"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "oblob"}:
				_fbg.Oblob = new(string)
				if _gfc := d.DecodeElement(_fbg.Oblob, &_fdd); _gfc != nil {
					return _gfc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "empty"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "empty"}:
				_fbg.Empty = NewEmpty()
				if _gdeb := d.DecodeElement(_fbg.Empty, &_fdd); _gdeb != nil {
					return _gdeb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "null"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "null"}:
				_fbg.Null = NewNull()
				if _edf := d.DecodeElement(_fbg.Null, &_fdd); _edf != nil {
					return _edf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i1"}:
				_fbg.I1 = new(int8)
				if _eded := d.DecodeElement(_fbg.I1, &_fdd); _eded != nil {
					return _eded
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i2"}:
				_fbg.I2 = new(int16)
				if _fgdc := d.DecodeElement(_fbg.I2, &_fdd); _fgdc != nil {
					return _fgdc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i4"}:
				_fbg.I4 = new(int32)
				if _aca := d.DecodeElement(_fbg.I4, &_fdd); _aca != nil {
					return _aca
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i8"}:
				_fbg.I8 = new(int64)
				if _bdga := d.DecodeElement(_fbg.I8, &_fdd); _bdga != nil {
					return _bdga
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "int"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "int"}:
				_fbg.Int = new(int32)
				if _dfg := d.DecodeElement(_fbg.Int, &_fdd); _dfg != nil {
					return _dfg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui1"}:
				_fbg.Ui1 = new(uint8)
				if _aag := d.DecodeElement(_fbg.Ui1, &_fdd); _aag != nil {
					return _aag
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui2"}:
				_fbg.Ui2 = new(uint16)
				if _ecf := d.DecodeElement(_fbg.Ui2, &_fdd); _ecf != nil {
					return _ecf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui4"}:
				_fbg.Ui4 = new(uint32)
				if _ddf := d.DecodeElement(_fbg.Ui4, &_fdd); _ddf != nil {
					return _ddf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui8"}:
				_fbg.Ui8 = new(uint64)
				if _dad := d.DecodeElement(_fbg.Ui8, &_fdd); _dad != nil {
					return _dad
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "uint"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "uint"}:
				_fbg.Uint = new(uint32)
				if _cde := d.DecodeElement(_fbg.Uint, &_fdd); _cde != nil {
					return _cde
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r4"}:
				_fbg.R4 = new(float32)
				if _aac := d.DecodeElement(_fbg.R4, &_fdd); _aac != nil {
					return _aac
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r8"}:
				_fbg.R8 = new(float64)
				if _agb := d.DecodeElement(_fbg.R8, &_fdd); _agb != nil {
					return _agb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "decimal"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "decimal"}:
				_fbg.Decimal = new(float64)
				if _fgde := d.DecodeElement(_fbg.Decimal, &_fdd); _fgde != nil {
					return _fgde
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "lpstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "lpstr"}:
				_fbg.Lpstr = new(string)
				if _bgfc := d.DecodeElement(_fbg.Lpstr, &_fdd); _bgfc != nil {
					return _bgfc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "lpwstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "lpwstr"}:
				_fbg.Lpwstr = new(string)
				if _edg := d.DecodeElement(_fbg.Lpwstr, &_fdd); _edg != nil {
					return _edg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bstr"}:
				_fbg.Bstr = new(string)
				if _ebc := d.DecodeElement(_fbg.Bstr, &_fdd); _ebc != nil {
					return _ebc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "date"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "date"}:
				_fbg.Date = new(_f.Time)
				if _add := d.DecodeElement(_fbg.Date, &_fdd); _add != nil {
					return _add
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "filetime"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "filetime"}:
				_fbg.Filetime = new(_f.Time)
				if _gced := d.DecodeElement(_fbg.Filetime, &_fdd); _gced != nil {
					return _gced
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bool"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bool"}:
				_fbg.Bool = new(bool)
				if _acfg := d.DecodeElement(_fbg.Bool, &_fdd); _acfg != nil {
					return _acfg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "cy"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "cy"}:
				_fbg.Cy = new(string)
				if _bcd := d.DecodeElement(_fbg.Cy, &_fdd); _bcd != nil {
					return _bcd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "error"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "error"}:
				_fbg.Error = new(string)
				if _dgf := d.DecodeElement(_fbg.Error, &_fdd); _dgf != nil {
					return _dgf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "stream"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "stream"}:
				_fbg.Stream = new(string)
				if _feba := d.DecodeElement(_fbg.Stream, &_fdd); _feba != nil {
					return _feba
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ostream"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ostream"}:
				_fbg.Ostream = new(string)
				if _dcee := d.DecodeElement(_fbg.Ostream, &_fdd); _dcee != nil {
					return _dcee
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "storage"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "storage"}:
				_fbg.Storage = new(string)
				if _bad := d.DecodeElement(_fbg.Storage, &_fdd); _bad != nil {
					return _bad
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ostorage"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ostorage"}:
				_fbg.Ostorage = new(string)
				if _ecb := d.DecodeElement(_fbg.Ostorage, &_fdd); _ecb != nil {
					return _ecb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "vstream"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "vstream"}:
				_fbg.Vstream = NewVstream()
				if _ebae := d.DecodeElement(_fbg.Vstream, &_fdd); _ebae != nil {
					return _ebae
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "clsid"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "clsid"}:
				_fbg.Clsid = new(string)
				if _aeag := d.DecodeElement(_fbg.Clsid, &_fdd); _aeag != nil {
					return _aeag
				}
			default:
				_ae.Log("skipping unsupported\u0020element\u0020on\u0020CT_Variant\u0020\u0025v", _fdd.Name)
				if _cga := d.Skip(); _cga != nil {
					return _cga
				}
			}
		case _d.EndElement:
			break _dagf
		case _d.CharData:
		}
	}
	return nil
}

var ST_ErrorPatternRe = _c.MustCompile(ST_ErrorPattern)

// ValidateWithPath validates the CT_Null and its children, prefixing error messages with path
func (_ddac *CT_Null) ValidateWithPath(path string) error { return nil }

type CT_Variant struct {
	Variant  *Variant
	Vector   *Vector
	Array    *Array
	Blob     *string
	Oblob    *string
	Empty    *Empty
	Null     *Null
	I1       *int8
	I2       *int16
	I4       *int32
	I8       *int64
	Int      *int32
	Ui1      *uint8
	Ui2      *uint16
	Ui4      *uint32
	Ui8      *uint64
	Uint     *uint32
	R4       *float32
	R8       *float64
	Decimal  *float64
	Lpstr    *string
	Lpwstr   *string
	Bstr     *string
	Date     *_f.Time
	Filetime *_f.Time
	Bool     *bool
	Cy       *string
	Error    *string
	Stream   *string
	Ostream  *string
	Storage  *string
	Ostorage *string
	Vstream  *Vstream
	Clsid    *string
}

func (_cbgc *CT_Vstream) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "version"}, Value: _g.Sprintf("\u0025v", _cbgc.VersionAttr)})
	e.EncodeElement(_cbgc.Content, start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewNull() *Null { _eabg := &Null{}; _eabg.CT_Null = *NewCT_Null(); return _eabg }

// ValidateWithPath validates the CT_Vstream and its children, prefixing error messages with path
func (_fad *CT_Vstream) ValidateWithPath(path string) error {
	if !_ec.ST_GuidPatternRe.MatchString(_fad.VersionAttr) {
		return _g.Errorf("\u0025s\u002fm\u002eVersionAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020(have\u0020\u0025v\u0029", path, _ec.ST_GuidPatternRe, _fad.VersionAttr)
	}
	return nil
}
func (_face *Empty) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return _face.CT_Empty.MarshalXML(e, start)
}
func (_cegd ST_ArrayBaseType) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_cegd.String(), start)
}

// ValidateWithPath validates the Empty and its children, prefixing error messages with path
func (_geeca *Empty) ValidateWithPath(path string) error {
	if _gbcf := _geeca.CT_Empty.ValidateWithPath(path); _gbcf != nil {
		return _gbcf
	}
	return nil
}
func (_b *Array) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_b.CT_Array = *NewCT_Array()
	for _, _eg := range start.Attr {
		if _eg.Name.Local == "uBounds" {
			_dd, _fc := _a.ParseInt(_eg.Value, 10, 32)
			if _fc != nil {
				return _fc
			}
			_b.UBoundsAttr = int32(_dd)
			continue
		}
		if _eg.Name.Local == "baseType" {
			_b.BaseTypeAttr.UnmarshalXMLAttr(_eg)
			continue
		}
		if _eg.Name.Local == "lBounds" {
			_aeb, _ad := _a.ParseInt(_eg.Value, 10, 32)
			if _ad != nil {
				return _ad
			}
			_b.LBoundsAttr = int32(_aeb)
			continue
		}
	}
_gd:
	for {
		_fd, _cb := d.Token()
		if _cb != nil {
			return _cb
		}
		switch _af := _fd.(type) {
		case _d.StartElement:
			switch _af.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "variant"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "variant"}:
				_bf := NewVariant()
				if _gf := d.DecodeElement(_bf, &_af); _gf != nil {
					return _gf
				}
				_b.Variant = append(_b.Variant, _bf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i1"}:
				var _fdc int8
				if _cg := d.DecodeElement(&_fdc, &_af); _cg != nil {
					return _cg
				}
				_b.I1 = append(_b.I1, _fdc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i2"}:
				var _cd int16
				if _bg := d.DecodeElement(&_cd, &_af); _bg != nil {
					return _bg
				}
				_b.I2 = append(_b.I2, _cd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "i4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "i4"}:
				var _ce int32
				if _gdd := d.DecodeElement(&_ce, &_af); _gdd != nil {
					return _gdd
				}
				_b.I4 = append(_b.I4, _ce)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "int"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "int"}:
				var _ca int32
				if _cee := d.DecodeElement(&_ca, &_af); _cee != nil {
					return _cee
				}
				_b.Int = append(_b.Int, _ca)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui1"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui1"}:
				var _gb uint8
				if _cec := d.DecodeElement(&_gb, &_af); _cec != nil {
					return _cec
				}
				_b.Ui1 = append(_b.Ui1, _gb)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui2"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui2"}:
				var _cfc uint16
				if _gbc := d.DecodeElement(&_cfc, &_af); _gbc != nil {
					return _gbc
				}
				_b.Ui2 = append(_b.Ui2, _cfc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "ui4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "ui4"}:
				var _ba uint32
				if _aed := d.DecodeElement(&_ba, &_af); _aed != nil {
					return _aed
				}
				_b.Ui4 = append(_b.Ui4, _ba)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "uint"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "uint"}:
				var _cbg uint32
				if _cgc := d.DecodeElement(&_cbg, &_af); _cgc != nil {
					return _cgc
				}
				_b.Uint = append(_b.Uint, _cbg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r4"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r4"}:
				var _cdg float32
				if _ea := d.DecodeElement(&_cdg, &_af); _ea != nil {
					return _ea
				}
				_b.R4 = append(_b.R4, _cdg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "r8"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "r8"}:
				var _ee float64
				if _ecd := d.DecodeElement(&_ee, &_af); _ecd != nil {
					return _ecd
				}
				_b.R8 = append(_b.R8, _ee)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "decimal"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "decimal"}:
				var _df float64
				if _feb := d.DecodeElement(&_df, &_af); _feb != nil {
					return _feb
				}
				_b.Decimal = append(_b.Decimal, _df)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bstr"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bstr"}:
				var _ag string
				if _gdf := d.DecodeElement(&_ag, &_af); _gdf != nil {
					return _gdf
				}
				_b.Bstr = append(_b.Bstr, _ag)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "date"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "date"}:
				var _egd _f.Time
				if _ff := d.DecodeElement(&_egd, &_af); _ff != nil {
					return _ff
				}
				_b.Date = append(_b.Date, _egd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "bool"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "bool"}:
				var _cfd bool
				if _ga := d.DecodeElement(&_cfd, &_af); _ga != nil {
					return _ga
				}
				_b.Bool = append(_b.Bool, _cfd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "error"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "error"}:
				var _gbf string
				if _gbcb := d.DecodeElement(&_gbf, &_af); _gbcb != nil {
					return _gbcb
				}
				_b.Error = append(_b.Error, _gbf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", Local: "cy"}, _d.Name{Space: "http:\u002f/purl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fdocPropsVTypes", Local: "cy"}:
				var _bfd string
				if _bd := d.DecodeElement(&_bfd, &_af); _bd != nil {
					return _bd
				}
				_b.Cy = append(_b.Cy, _bfd)
			default:
				_ae.Log("skipping\u0020unsupported\u0020element\u0020on Array \u0025v", _af.Name)
				if _gfd := d.Skip(); _gfd != nil {
					return _gfd
				}
			}
		case _d.EndElement:
			break _gd
		case _d.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Empty and its children, prefixing error messages with path
func (_caf *CT_Empty) ValidateWithPath(path string) error { return nil }
func init() {
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "CT_Empty", NewCT_Empty)
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "CT_Null", NewCT_Null)
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "CT_Vector", NewCT_Vector)
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "CT_Array", NewCT_Array)
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "CT_Variant", NewCT_Variant)
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "CT_Vstream", NewCT_Vstream)
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "variant", NewVariant)
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "vector", NewVector)
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "array", NewArray)
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "empty", NewEmpty)
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "null", NewNull)
	_ae.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fdocPropsVTypes", "vstream", NewVstream)
}
