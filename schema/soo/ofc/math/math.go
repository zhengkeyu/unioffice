//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package math

import (
	_d "encoding/xml"
	_da "fmt"
	_e "gitee.com/greatmusicians/unioffice"
	_f "gitee.com/greatmusicians/unioffice/schema/soo/ofc/sharedTypes"
	_a "strconv"
)

func NewCT_Phant() *CT_Phant { _bbcga := &CT_Phant{}; _bbcga.E = NewCT_OMathArg(); return _bbcga }
func (_acfd *CT_EqArrPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _acfd.BaseJc != nil {
		_ccfe := _d.StartElement{Name: _d.Name{Local: "m:baseJc"}}
		e.EncodeElement(_acfd.BaseJc, _ccfe)
	}
	if _acfd.MaxDist != nil {
		_eagb := _d.StartElement{Name: _d.Name{Local: "m:maxDist"}}
		e.EncodeElement(_acfd.MaxDist, _eagb)
	}
	if _acfd.ObjDist != nil {
		_efce := _d.StartElement{Name: _d.Name{Local: "m:objDist"}}
		e.EncodeElement(_acfd.ObjDist, _efce)
	}
	if _acfd.RSpRule != nil {
		_egd := _d.StartElement{Name: _d.Name{Local: "m:rSpRule"}}
		e.EncodeElement(_acfd.RSpRule, _egd)
	}
	if _acfd.RSp != nil {
		_eddg := _d.StartElement{Name: _d.Name{Local: "m:rSp"}}
		e.EncodeElement(_acfd.RSp, _eddg)
	}
	if _acfd.CtrlPr != nil {
		_ffbb := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_acfd.CtrlPr, _ffbb)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_agga *CT_Style) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _agga.ValAttr != ST_StyleUnset {
		_abea, _bddf := _agga.ValAttr.MarshalXMLAttr(_d.Name{Local: "m:val"})
		if _bddf != nil {
			return _bddf
		}
		start.Attr = append(start.Attr, _abea)
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_cfef *CT_MCS) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	_eaac := _d.StartElement{Name: _d.Name{Local: "m:mc"}}
	for _, _geba := range _cfef.Mc {
		e.EncodeElement(_geba, _eaac)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_bdced *ST_Style) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_bdced = 0
	case "p":
		*_bdced = 1
	case "b":
		*_bdced = 2
	case "i":
		*_bdced = 3
	case "bi":
		*_bdced = 4
	}
	return nil
}
func (_agbb *CT_BoxPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _agbb.OpEmu != nil {
		_deg := _d.StartElement{Name: _d.Name{Local: "m:opEmu"}}
		e.EncodeElement(_agbb.OpEmu, _deg)
	}
	if _agbb.NoBreak != nil {
		_eec := _d.StartElement{Name: _d.Name{Local: "m:noBreak"}}
		e.EncodeElement(_agbb.NoBreak, _eec)
	}
	if _agbb.Diff != nil {
		_acd := _d.StartElement{Name: _d.Name{Local: "m:diff"}}
		e.EncodeElement(_agbb.Diff, _acd)
	}
	if _agbb.Brk != nil {
		_gda := _d.StartElement{Name: _d.Name{Local: "m:brk"}}
		e.EncodeElement(_agbb.Brk, _gda)
	}
	if _agbb.Aln != nil {
		_gga := _d.StartElement{Name: _d.Name{Local: "m:aln"}}
		e.EncodeElement(_agbb.Aln, _gga)
	}
	if _agbb.CtrlPr != nil {
		_ae := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_agbb.CtrlPr, _ae)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_gfeb *CT_RChoice) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_fdffd:
	for {
		_fbgc, _eafbg := d.Token()
		if _eafbg != nil {
			return _eafbg
		}
		switch _cfcfg := _fbgc.(type) {
		case _d.StartElement:
			switch _cfcfg.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "t"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "t"}:
				_adgce := NewCT_Text()
				if _bfgdb := d.DecodeElement(_adgce, &_cfcfg); _bfgdb != nil {
					return _bfgdb
				}
				_gfeb.T = append(_gfeb.T, _adgce)
			default:
				_e.Log("skipping unsupported\u0020element\u0020on\u0020CT_RChoice\u0020\u0025v", _cfcfg.Name)
				if _ecag := d.Skip(); _ecag != nil {
					return _ecag
				}
			}
		case _d.EndElement:
			break _fdffd
		case _d.CharData:
		}
	}
	return nil
}

type ST_Script byte

func (_afba *CT_OMathArg) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_ccffg:
	for {
		_caea, _fde := d.Token()
		if _fde != nil {
			return _fde
		}
		switch _bfdb := _caea.(type) {
		case _d.StartElement:
			switch _bfdb.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "argPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "argPr"}:
				_afba.ArgPr = NewCT_OMathArgPr()
				if _aafbg := d.DecodeElement(_afba.ArgPr, &_bfdb); _aafbg != nil {
					return _aafbg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "acc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "acc"}:
				_efda := NewEG_OMathMathElements()
				_efda.Acc = NewCT_Acc()
				if _gcfda := d.DecodeElement(_efda.Acc, &_bfdb); _gcfda != nil {
					return _gcfda
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _efda)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "bar"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "bar"}:
				_fbeb := NewEG_OMathMathElements()
				_fbeb.Bar = NewCT_Bar()
				if _cbb := d.DecodeElement(_fbeb.Bar, &_bfdb); _cbb != nil {
					return _cbb
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _fbeb)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "box"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "box"}:
				_beea := NewEG_OMathMathElements()
				_beea.Box = NewCT_Box()
				if _cfca := d.DecodeElement(_beea.Box, &_bfdb); _cfca != nil {
					return _cfca
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _beea)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "borderBox"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "borderBox"}:
				_bfad := NewEG_OMathMathElements()
				_bfad.BorderBox = NewCT_BorderBox()
				if _bdfcd := d.DecodeElement(_bfad.BorderBox, &_bfdb); _bdfcd != nil {
					return _bdfcd
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _bfad)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "d"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "d"}:
				_afa := NewEG_OMathMathElements()
				_afa.D = NewCT_D()
				if _dgda := d.DecodeElement(_afa.D, &_bfdb); _dgda != nil {
					return _dgda
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _afa)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "eqArr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "eqArr"}:
				_ccbc := NewEG_OMathMathElements()
				_ccbc.EqArr = NewCT_EqArr()
				if _gedeaa := d.DecodeElement(_ccbc.EqArr, &_bfdb); _gedeaa != nil {
					return _gedeaa
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _ccbc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "f"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "f"}:
				_ebba := NewEG_OMathMathElements()
				_ebba.F = NewCT_F()
				if _deaa := d.DecodeElement(_ebba.F, &_bfdb); _deaa != nil {
					return _deaa
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _ebba)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "func"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "func"}:
				_ggcfd := NewEG_OMathMathElements()
				_ggcfd.Func = NewCT_Func()
				if _dcdfa := d.DecodeElement(_ggcfd.Func, &_bfdb); _dcdfa != nil {
					return _dcdfa
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _ggcfd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "groupChr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "groupChr"}:
				_afgb := NewEG_OMathMathElements()
				_afgb.GroupChr = NewCT_GroupChr()
				if _ddgcd := d.DecodeElement(_afgb.GroupChr, &_bfdb); _ddgcd != nil {
					return _ddgcd
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _afgb)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limLow"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limLow"}:
				_egge := NewEG_OMathMathElements()
				_egge.LimLow = NewCT_LimLow()
				if _ccaaf := d.DecodeElement(_egge.LimLow, &_bfdb); _ccaaf != nil {
					return _ccaaf
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _egge)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limUpp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limUpp"}:
				_gac := NewEG_OMathMathElements()
				_gac.LimUpp = NewCT_LimUpp()
				if _agdg := d.DecodeElement(_gac.LimUpp, &_bfdb); _agdg != nil {
					return _agdg
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _gac)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "m"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "m"}:
				_dbabf := NewEG_OMathMathElements()
				_dbabf.M = NewCT_M()
				if _dbaae := d.DecodeElement(_dbabf.M, &_bfdb); _dbaae != nil {
					return _dbaae
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _dbabf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "nary"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "nary"}:
				_agbg := NewEG_OMathMathElements()
				_agbg.Nary = NewCT_Nary()
				if _efgc := d.DecodeElement(_agbg.Nary, &_bfdb); _efgc != nil {
					return _efgc
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _agbg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "phant"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "phant"}:
				_daed := NewEG_OMathMathElements()
				_daed.Phant = NewCT_Phant()
				if _cafc := d.DecodeElement(_daed.Phant, &_bfdb); _cafc != nil {
					return _cafc
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _daed)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rad"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rad"}:
				_fcbe := NewEG_OMathMathElements()
				_fcbe.Rad = NewCT_Rad()
				if _ccfb := d.DecodeElement(_fcbe.Rad, &_bfdb); _ccfb != nil {
					return _ccfb
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _fcbe)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sPre"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sPre"}:
				_cabf := NewEG_OMathMathElements()
				_cabf.SPre = NewCT_SPre()
				if _aeb := d.DecodeElement(_cabf.SPre, &_bfdb); _aeb != nil {
					return _aeb
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _cabf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSub"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSub"}:
				_gadc := NewEG_OMathMathElements()
				_gadc.SSub = NewCT_SSub()
				if _cedb := d.DecodeElement(_gadc.SSub, &_bfdb); _cedb != nil {
					return _cedb
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _gadc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSubSup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSubSup"}:
				_dedf := NewEG_OMathMathElements()
				_dedf.SSubSup = NewCT_SSubSup()
				if _agfg := d.DecodeElement(_dedf.SSubSup, &_bfdb); _agfg != nil {
					return _agfg
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _dedf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSup"}:
				_cdcc := NewEG_OMathMathElements()
				_cdcc.SSup = NewCT_SSup()
				if _cdf := d.DecodeElement(_cdcc.SSup, &_bfdb); _cdf != nil {
					return _cdf
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _cdcc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "r"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "r"}:
				_gacf := NewEG_OMathMathElements()
				_gacf.R = NewCT_R()
				if _bgegc := d.DecodeElement(_gacf.R, &_bfdb); _bgegc != nil {
					return _bgegc
				}
				_afba.EG_OMathMathElements = append(_afba.EG_OMathMathElements, _gacf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_afba.CtrlPr = NewCT_CtrlPr()
				if _aag := d.DecodeElement(_afba.CtrlPr, &_bfdb); _aag != nil {
					return _aag
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OMathArg\u0020\u0025v", _bfdb.Name)
				if _gdcg := d.Skip(); _gdcg != nil {
					return _gdcg
				}
			}
		case _d.EndElement:
			break _ccffg
		case _d.CharData:
		}
	}
	return nil
}
func (_bcdg *CT_OnOff) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _bcdg.ValAttr != nil {
		start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "m:val"}, Value: _da.Sprintf("\u0025v", *_bcdg.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewCT_OnOff() *CT_OnOff       { _dceffa := &CT_OnOff{}; return _dceffa }
func NewCT_BreakBin() *CT_BreakBin { _adeg := &CT_BreakBin{}; return _adeg }
func (_bbfb *CT_String) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _gfac := range start.Attr {
		if _gfac.Name.Local == "val" {
			_gfbba, _ebdb := _gfac.Value, error(nil)
			if _ebdb != nil {
				return _ebdb
			}
			_bbfb.ValAttr = &_gfbba
			continue
		}
	}
	for {
		_gcabd, _cdad := d.Token()
		if _cdad != nil {
			return _da.Errorf("parsing\u0020CT_String:\u0020\u0025s", _cdad)
		}
		if _ecfe, _eaaf := _gcabd.(_d.EndElement); _eaaf && _ecfe.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ebfe *CT_SSubSup) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ebfe.E = NewCT_OMathArg()
	_ebfe.Sub = NewCT_OMathArg()
	_ebfe.Sup = NewCT_OMathArg()
_eaedb:
	for {
		_gaeg, _eecbc := d.Token()
		if _eecbc != nil {
			return _eecbc
		}
		switch _bbdd := _gaeg.(type) {
		case _d.StartElement:
			switch _bbdd.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSubSupPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSubSupPr"}:
				_ebfe.SSubSupPr = NewCT_SSubSupPr()
				if _fea := d.DecodeElement(_ebfe.SSubSupPr, &_bbdd); _fea != nil {
					return _fea
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _fbgg := d.DecodeElement(_ebfe.E, &_bbdd); _fbgg != nil {
					return _fbgg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sub"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sub"}:
				if _ccaafg := d.DecodeElement(_ebfe.Sub, &_bbdd); _ccaafg != nil {
					return _ccaafg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sup"}:
				if _bcdac := d.DecodeElement(_ebfe.Sup, &_bbdd); _bcdac != nil {
					return _bcdac
				}
			default:
				_e.Log("skipping unsupported\u0020element\u0020on\u0020CT_SSubSup\u0020\u0025v", _bbdd.Name)
				if _edag := d.Skip(); _edag != nil {
					return _edag
				}
			}
		case _d.EndElement:
			break _eaedb
		case _d.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Acc and its children
func (_ge *CT_Acc) Validate() error     { return _ge.ValidateWithPath("CT_Acc") }
func (_fdaa ST_TopBot) Validate() error { return _fdaa.ValidateWithPath("") }
func (_bdf *CT_BoxPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_fge:
	for {
		_gbc, _aff := d.Token()
		if _aff != nil {
			return _aff
		}
		switch _cca := _gbc.(type) {
		case _d.StartElement:
			switch _cca.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "opEmu"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "opEmu"}:
				_bdf.OpEmu = NewCT_OnOff()
				if _dcfb := d.DecodeElement(_bdf.OpEmu, &_cca); _dcfb != nil {
					return _dcfb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "noBreak"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "noBreak"}:
				_bdf.NoBreak = NewCT_OnOff()
				if _fca := d.DecodeElement(_bdf.NoBreak, &_cca); _fca != nil {
					return _fca
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "diff"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "diff"}:
				_bdf.Diff = NewCT_OnOff()
				if _ced := d.DecodeElement(_bdf.Diff, &_cca); _ced != nil {
					return _ced
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "brk"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "brk"}:
				_bdf.Brk = NewCT_ManualBreak()
				if _aed := d.DecodeElement(_bdf.Brk, &_cca); _aed != nil {
					return _aed
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "aln"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "aln"}:
				_bdf.Aln = NewCT_OnOff()
				if _aef := d.DecodeElement(_bdf.Aln, &_cca); _aef != nil {
					return _aef
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_bdf.CtrlPr = NewCT_CtrlPr()
				if _efd := d.DecodeElement(_bdf.CtrlPr, &_cca); _efd != nil {
					return _efd
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BoxPr\u0020\u0025v", _cca.Name)
				if _ggc := d.Skip(); _ggc != nil {
					return _ggc
				}
			}
		case _d.EndElement:
			break _fge
		case _d.CharData:
		}
	}
	return nil
}
func (_dcee *CT_MathPrChoice) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_defg:
	for {
		_bbggc, _dgad := d.Token()
		if _dgad != nil {
			return _dgad
		}
		switch _adcb := _bbggc.(type) {
		case _d.StartElement:
			switch _adcb.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "wrapIndent"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "wrapIndent"}:
				_dcee.WrapIndent = NewCT_TwipsMeasure()
				if _ffbd := d.DecodeElement(_dcee.WrapIndent, &_adcb); _ffbd != nil {
					return _ffbd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "wrapRight"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "wrapRight"}:
				_dcee.WrapRight = NewCT_OnOff()
				if _fcb := d.DecodeElement(_dcee.WrapRight, &_adcb); _fcb != nil {
					return _fcb
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_MathPrChoice\u0020\u0025v", _adcb.Name)
				if _fac := d.Skip(); _fac != nil {
					return _fac
				}
			}
		case _d.EndElement:
			break _defg
		case _d.CharData:
		}
	}
	return nil
}

// Validate validates the CT_BorderBox and its children
func (_dda *CT_BorderBox) Validate() error { return _dda.ValidateWithPath("CT_BorderBox") }

type ST_BreakBin byte

func (_aee *CT_Integer255) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "m:val"}, Value: _da.Sprintf("\u0025v", _aee.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_aacc *CT_GroupChr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_aacc.E = NewCT_OMathArg()
_gce:
	for {
		_ddad, _eagg := d.Token()
		if _eagg != nil {
			return _eagg
		}
		switch _ggf := _ddad.(type) {
		case _d.StartElement:
			switch _ggf.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "groupChrPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "groupChrPr"}:
				_aacc.GroupChrPr = NewCT_GroupChrPr()
				if _bgeg := d.DecodeElement(_aacc.GroupChrPr, &_ggf); _bgeg != nil {
					return _bgeg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _gebf := d.DecodeElement(_aacc.E, &_ggf); _gebf != nil {
					return _gebf
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GroupChr\u0020\u0025v", _ggf.Name)
				if _cbcc := d.Skip(); _cbcc != nil {
					return _cbcc
				}
			}
		case _d.EndElement:
			break _gce
		case _d.CharData:
		}
	}
	return nil
}
func (_cbf *CT_NaryPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_gcaf:
	for {
		_fbbd, _ddgd := d.Token()
		if _ddgd != nil {
			return _ddgd
		}
		switch _gceb := _fbbd.(type) {
		case _d.StartElement:
			switch _gceb.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "chr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "chr"}:
				_cbf.Chr = NewCT_Char()
				if _ffac := d.DecodeElement(_cbf.Chr, &_gceb); _ffac != nil {
					return _ffac
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limLoc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limLoc"}:
				_cbf.LimLoc = NewCT_LimLoc()
				if _bfge := d.DecodeElement(_cbf.LimLoc, &_gceb); _bfge != nil {
					return _bfge
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "grow"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "grow"}:
				_cbf.Grow = NewCT_OnOff()
				if _adcea := d.DecodeElement(_cbf.Grow, &_gceb); _adcea != nil {
					return _adcea
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "subHide"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "subHide"}:
				_cbf.SubHide = NewCT_OnOff()
				if _bdfc := d.DecodeElement(_cbf.SubHide, &_gceb); _bdfc != nil {
					return _bdfc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "supHide"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "supHide"}:
				_cbf.SupHide = NewCT_OnOff()
				if _fbde := d.DecodeElement(_cbf.SupHide, &_gceb); _fbde != nil {
					return _fbde
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_cbf.CtrlPr = NewCT_CtrlPr()
				if _cegb := d.DecodeElement(_cbf.CtrlPr, &_gceb); _cegb != nil {
					return _cegb
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element on CT_NaryPr \u0025v", _gceb.Name)
				if _gbeg := d.Skip(); _gbeg != nil {
					return _gbeg
				}
			}
		case _d.EndElement:
			break _gcaf
		case _d.CharData:
		}
	}
	return nil
}
func (_bcf *CT_EqArr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _bcf.EqArrPr != nil {
		_fdb := _d.StartElement{Name: _d.Name{Local: "m:eqArrPr"}}
		e.EncodeElement(_bcf.EqArrPr, _fdb)
	}
	_fdg := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	for _, _bfbb := range _bcf.E {
		e.EncodeElement(_bfbb, _fdg)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Script and its children, prefixing error messages with path
func (_cdeg *CT_Script) ValidateWithPath(path string) error {
	if _bdec := _cdeg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bdec != nil {
		return _bdec
	}
	return nil
}
func (_fae *CT_Box) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_fae.E = NewCT_OMathArg()
_ada:
	for {
		_baaa, _aaa := d.Token()
		if _aaa != nil {
			return _aaa
		}
		switch _adf := _baaa.(type) {
		case _d.StartElement:
			switch _adf.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "boxPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "boxPr"}:
				_fae.BoxPr = NewCT_BoxPr()
				if _gd := d.DecodeElement(_fae.BoxPr, &_adf); _gd != nil {
					return _gd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _fe := d.DecodeElement(_fae.E, &_adf); _fe != nil {
					return _fe
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Box\u0020\u0025v", _adf.Name)
				if _gccc := d.Skip(); _gccc != nil {
					return _gccc
				}
			}
		case _d.EndElement:
			break _ada
		case _d.CharData:
		}
	}
	return nil
}
func (_aagb *EG_ScriptStyle) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Name.Local = "m:EG_ScriptStyle"
	if _aagb.Scr != nil {
		_bagcc := _d.StartElement{Name: _d.Name{Local: "m:scr"}}
		e.EncodeElement(_aagb.Scr, _bagcc)
	}
	if _aagb.Sty != nil {
		_feae := _d.StartElement{Name: _d.Name{Local: "m:sty"}}
		e.EncodeElement(_aagb.Sty, _feae)
	}
	return nil
}

// ValidateWithPath validates the CT_SSubSupPr and its children, prefixing error messages with path
func (_dgae *CT_SSubSupPr) ValidateWithPath(path string) error {
	if _dgae.AlnScr != nil {
		if _gebd := _dgae.AlnScr.ValidateWithPath(path + "\u002fAlnScr"); _gebd != nil {
			return _gebd
		}
	}
	if _dgae.CtrlPr != nil {
		if _fgecf := _dgae.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _fgecf != nil {
			return _fgecf
		}
	}
	return nil
}

// ValidateWithPath validates the CT_OMathPara and its children, prefixing error messages with path
func (_baggc *CT_OMathPara) ValidateWithPath(path string) error {
	if _baggc.OMathParaPr != nil {
		if _aaag := _baggc.OMathParaPr.ValidateWithPath(path + "\u002fOMathParaPr"); _aaag != nil {
			return _aaag
		}
	}
	for _cgfb, _gcge := range _baggc.OMath {
		if _eggea := _gcge.ValidateWithPath(_da.Sprintf("\u0025s\u002fOMath\u005b\u0025d\u005d", path, _cgfb)); _eggea != nil {
			return _eggea
		}
	}
	return nil
}
func (_bde *CT_OMathPara) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_bdfb:
	for {
		_eadg, _ddae := d.Token()
		if _ddae != nil {
			return _ddae
		}
		switch _beedf := _eadg.(type) {
		case _d.StartElement:
			switch _beedf.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "oMathParaPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "oMathParaPr"}:
				_bde.OMathParaPr = NewCT_OMathParaPr()
				if _adfc := d.DecodeElement(_bde.OMathParaPr, &_beedf); _adfc != nil {
					return _adfc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "oMath"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "oMath"}:
				_fgcd := NewCT_OMath()
				if _fcfe := d.DecodeElement(_fgcd, &_beedf); _fcfe != nil {
					return _fcfe
				}
				_bde.OMath = append(_bde.OMath, _fgcd)
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OMathPara\u0020\u0025v", _beedf.Name)
				if _ceff := d.Skip(); _ceff != nil {
					return _ceff
				}
			}
		case _d.EndElement:
			break _bdfb
		case _d.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Func and its children
func (_fced *CT_Func) Validate() error { return _fced.ValidateWithPath("CT_Func") }

// ValidateWithPath validates the CT_TopBot and its children, prefixing error messages with path
func (_dbfg *CT_TopBot) ValidateWithPath(path string) error {
	if _dbfg.ValAttr == ST_TopBotUnset {
		return _da.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _cgfc := _dbfg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _cgfc != nil {
		return _cgfc
	}
	return nil
}

// Validate validates the CT_BreakBinSub and its children
func (_dfca *CT_BreakBinSub) Validate() error { return _dfca.ValidateWithPath("CT_BreakBinSub") }
func (_dcfedd *CT_UnSignedInteger) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _cbea := range start.Attr {
		if _cbea.Name.Local == "val" {
			_cgbfc, _ebaf := _a.ParseUint(_cbea.Value, 10, 32)
			if _ebaf != nil {
				return _ebaf
			}
			_dcfedd.ValAttr = uint32(_cgbfc)
			continue
		}
	}
	for {
		_defc, _fag := d.Token()
		if _fag != nil {
			return _da.Errorf("parsing\u0020CT_UnSignedInteger:\u0020\u0025s", _fag)
		}
		if _gcgff, _dffg := _defc.(_d.EndElement); _dffg && _gcgff.Name == start.Name {
			break
		}
	}
	return nil
}
func (_def *CT_ManualBreak) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _def.AlnAtAttr != nil {
		start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "m:alnAt"}, Value: _da.Sprintf("\u0025v", *_def.AlnAtAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewCT_AccPr() *CT_AccPr { _cc := &CT_AccPr{}; return _cc }

type CT_MC struct{ McPr *CT_MCPr }
type CT_LimUpp struct {
	LimUppPr *CT_LimUppPr
	E        *CT_OMathArg
	Lim      *CT_OMathArg
}

func NewCT_SSubSup() *CT_SSubSup {
	_fgg := &CT_SSubSup{}
	_fgg.E = NewCT_OMathArg()
	_fgg.Sub = NewCT_OMathArg()
	_fgg.Sup = NewCT_OMathArg()
	return _fgg
}

// ValidateWithPath validates the CT_EqArr and its children, prefixing error messages with path
func (_dfec *CT_EqArr) ValidateWithPath(path string) error {
	if _dfec.EqArrPr != nil {
		if _gdee := _dfec.EqArrPr.ValidateWithPath(path + "\u002fEqArrPr"); _gdee != nil {
			return _gdee
		}
	}
	for _gfgc, _eeec := range _dfec.E {
		if _gagc := _eeec.ValidateWithPath(_da.Sprintf("\u0025s\u002fE\u005b\u0025d\u005d", path, _gfgc)); _gagc != nil {
			return _gagc
		}
	}
	return nil
}
func NewMathPr() *MathPr { _bcee := &MathPr{}; _bcee.CT_MathPr = *NewCT_MathPr(); return _bcee }
func (_bgdc ST_Shp) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_bgdc.String(), start)
}
func (_eeff *CT_Char) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _gfga := range start.Attr {
		if _gfga.Name.Local == "val" {
			_adaf, _edg := _gfga.Value, error(nil)
			if _edg != nil {
				return _edg
			}
			_eeff.ValAttr = _adaf
			continue
		}
	}
	for {
		_bbc, _fbdf := d.Token()
		if _fbdf != nil {
			return _da.Errorf("parsing\u0020CT_Char:\u0020\u0025s", _fbdf)
		}
		if _bbg, _edd := _bbc.(_d.EndElement); _edd && _bbg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dfdgf *CT_SSubPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _dfdgf.CtrlPr != nil {
		_gggdgd := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_dfdgf.CtrlPr, _gggdgd)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Style and its children, prefixing error messages with path
func (_cbfg *CT_Style) ValidateWithPath(path string) error {
	if _bdgae := _cbfg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bdgae != nil {
		return _bdgae
	}
	return nil
}

type CT_DPr struct {
	BegChr *CT_Char
	SepChr *CT_Char
	EndChr *CT_Char
	Grow   *CT_OnOff
	Shp    *CT_Shp
	CtrlPr *CT_CtrlPr
}

func (_bc *CT_Bar) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _bc.BarPr != nil {
		_fg := _d.StartElement{Name: _d.Name{Local: "m:barPr"}}
		e.EncodeElement(_bc.BarPr, _fg)
	}
	_ac := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_bc.E, _ac)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_FuncPr and its children, prefixing error messages with path
func (_cbde *CT_FuncPr) ValidateWithPath(path string) error {
	if _cbde.CtrlPr != nil {
		if _gedb := _cbde.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _gedb != nil {
			return _gedb
		}
	}
	return nil
}
func (_daga *CT_String) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _daga.ValAttr != nil {
		start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "m:val"}, Value: _da.Sprintf("\u0025v", *_daga.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Char and its children
func (_fbef *CT_Char) Validate() error { return _fbef.ValidateWithPath("CT_Char") }

// Validate validates the CT_M and its children
func (_beef *CT_M) Validate() error { return _beef.ValidateWithPath("CT_M") }

type CT_FuncPr struct{ CtrlPr *CT_CtrlPr }

func (_caca *CT_OMathParaPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _caca.Jc != nil {
		_dcdb := _d.StartElement{Name: _d.Name{Local: "m:jc"}}
		e.EncodeElement(_caca.Jc, _dcdb)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_MPr and its children
func (_fgag *CT_MPr) Validate() error { return _fgag.ValidateWithPath("CT_MPr") }

// Validate validates the CT_MC and its children
func (_faef *CT_MC) Validate() error { return _faef.ValidateWithPath("CT_MC") }
func (_eeab ST_BreakBinSub) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_gedbd := _d.Attr{}
	_gedbd.Name = name
	switch _eeab {
	case ST_BreakBinSubUnset:
		_gedbd.Value = ""
	case ST_BreakBinSub__:
		_gedbd.Value = "\u002d\u002d"
	case ST_BreakBinSub___:
		_gedbd.Value = "\u002d\u002b"
	case ST_BreakBinSub____:
		_gedbd.Value = "\u002b\u002d"
	}
	return _gedbd, nil
}
func (_cfa *CT_D) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _cfa.DPr != nil {
		_dbd := _d.StartElement{Name: _d.Name{Local: "m:dPr"}}
		e.EncodeElement(_cfa.DPr, _dbd)
	}
	_agg := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	for _, _cbc := range _cfa.E {
		e.EncodeElement(_cbc, _agg)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_OMathArg and its children
func (_ebdc *CT_OMathArg) Validate() error { return _ebdc.ValidateWithPath("CT_OMathArg") }

// Validate validates the MathPr and its children
func (_eacd *MathPr) Validate() error { return _eacd.ValidateWithPath("MathPr") }

// ValidateWithPath validates the CT_MathPr and its children, prefixing error messages with path
func (_bgbe *CT_MathPr) ValidateWithPath(path string) error {
	if _bgbe.MathFont != nil {
		if _bdgg := _bgbe.MathFont.ValidateWithPath(path + "\u002fMathFont"); _bdgg != nil {
			return _bdgg
		}
	}
	if _bgbe.BrkBin != nil {
		if _eafa := _bgbe.BrkBin.ValidateWithPath(path + "\u002fBrkBin"); _eafa != nil {
			return _eafa
		}
	}
	if _bgbe.BrkBinSub != nil {
		if _gcgc := _bgbe.BrkBinSub.ValidateWithPath(path + "\u002fBrkBinSub"); _gcgc != nil {
			return _gcgc
		}
	}
	if _bgbe.SmallFrac != nil {
		if _edcd := _bgbe.SmallFrac.ValidateWithPath(path + "\u002fSmallFrac"); _edcd != nil {
			return _edcd
		}
	}
	if _bgbe.DispDef != nil {
		if _edfa := _bgbe.DispDef.ValidateWithPath(path + "\u002fDispDef"); _edfa != nil {
			return _edfa
		}
	}
	if _bgbe.LMargin != nil {
		if _edaf := _bgbe.LMargin.ValidateWithPath(path + "\u002fLMargin"); _edaf != nil {
			return _edaf
		}
	}
	if _bgbe.RMargin != nil {
		if _gfd := _bgbe.RMargin.ValidateWithPath(path + "\u002fRMargin"); _gfd != nil {
			return _gfd
		}
	}
	if _bgbe.DefJc != nil {
		if _cff := _bgbe.DefJc.ValidateWithPath(path + "\u002fDefJc"); _cff != nil {
			return _cff
		}
	}
	if _bgbe.PreSp != nil {
		if _gddf := _bgbe.PreSp.ValidateWithPath(path + "\u002fPreSp"); _gddf != nil {
			return _gddf
		}
	}
	if _bgbe.PostSp != nil {
		if _fcfa := _bgbe.PostSp.ValidateWithPath(path + "\u002fPostSp"); _fcfa != nil {
			return _fcfa
		}
	}
	if _bgbe.InterSp != nil {
		if _ggab := _bgbe.InterSp.ValidateWithPath(path + "\u002fInterSp"); _ggab != nil {
			return _ggab
		}
	}
	if _bgbe.IntraSp != nil {
		if _cfce := _bgbe.IntraSp.ValidateWithPath(path + "\u002fIntraSp"); _cfce != nil {
			return _cfce
		}
	}
	if _bgbe.Choice != nil {
		if _fabd := _bgbe.Choice.ValidateWithPath(path + "\u002fChoice"); _fabd != nil {
			return _fabd
		}
	}
	if _bgbe.IntLim != nil {
		if _ddf := _bgbe.IntLim.ValidateWithPath(path + "\u002fIntLim"); _ddf != nil {
			return _ddf
		}
	}
	if _bgbe.NaryLim != nil {
		if _dcag := _bgbe.NaryLim.ValidateWithPath(path + "\u002fNaryLim"); _dcag != nil {
			return _dcag
		}
	}
	return nil
}
func (_gefa *CT_FType) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	_dcfed, _bgec := _gefa.ValAttr.MarshalXMLAttr(_d.Name{Local: "m:val"})
	if _bgec != nil {
		return _bgec
	}
	start.Attr = append(start.Attr, _dcfed)
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_bbdde *CT_Shp) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	_bcac, _gfaab := _bbdde.ValAttr.MarshalXMLAttr(_d.Name{Local: "m:val"})
	if _gfaab != nil {
		return _gfaab
	}
	start.Attr = append(start.Attr, _bcac)
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_edgeg ST_LimLoc) Validate() error { return _edgeg.ValidateWithPath("") }
func (_ebc *CT_LimUppPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _ebc.CtrlPr != nil {
		_fcga := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_ebc.CtrlPr, _fcga)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Text and its children
func (_gdfff *CT_Text) Validate() error { return _gdfff.ValidateWithPath("CT_Text") }

// Validate validates the EG_ScriptStyle and its children
func (_bgbf *EG_ScriptStyle) Validate() error { return _bgbf.ValidateWithPath("EG_ScriptStyle") }

type OMathPara struct{ CT_OMathPara }

func (_ecfee *ST_Jc) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ddeddb, _dgdaf := d.Token()
	if _dgdaf != nil {
		return _dgdaf
	}
	if _gaab, _egca := _ddeddb.(_d.EndElement); _egca && _gaab.Name == start.Name {
		*_ecfee = 1
		return nil
	}
	if _agcae, _aacf := _ddeddb.(_d.CharData); !_aacf {
		return _da.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ddeddb)
	} else {
		switch string(_agcae) {
		case "":
			*_ecfee = 0
		case "left":
			*_ecfee = 1
		case "right":
			*_ecfee = 2
		case "center":
			*_ecfee = 3
		case "centerGroup":
			*_ecfee = 4
		}
	}
	_ddeddb, _dgdaf = d.Token()
	if _dgdaf != nil {
		return _dgdaf
	}
	if _gaef, _bbba := _ddeddb.(_d.EndElement); _bbba && _gaef.Name == start.Name {
		return nil
	}
	return _da.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ddeddb)
}
func NewCT_OMathArgPr() *CT_OMathArgPr { _eabg := &CT_OMathArgPr{}; return _eabg }
func (_fbag *CT_SSubSupPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _fbag.AlnScr != nil {
		_cbfd := _d.StartElement{Name: _d.Name{Local: "m:alnScr"}}
		e.EncodeElement(_fbag.AlnScr, _cbfd)
	}
	if _fbag.CtrlPr != nil {
		_aafdb := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_fbag.CtrlPr, _aafdb)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type CT_MPr struct {
	BaseJc  *CT_YAlign
	PlcHide *CT_OnOff
	RSpRule *CT_SpacingRule
	CGpRule *CT_SpacingRule
	RSp     *CT_UnSignedInteger
	CSp     *CT_UnSignedInteger
	CGp     *CT_UnSignedInteger
	Mcs     *CT_MCS
	CtrlPr  *CT_CtrlPr
}

func NewCT_BreakBinSub() *CT_BreakBinSub { _dfa := &CT_BreakBinSub{}; return _dfa }
func NewCT_PhantPr() *CT_PhantPr         { _ggdaf := &CT_PhantPr{}; return _ggdaf }
func (_afgbe *CT_TopBot) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_afgbe.ValAttr = ST_TopBot(1)
	for _, _dafc := range start.Attr {
		if _dafc.Name.Local == "val" {
			_afgbe.ValAttr.UnmarshalXMLAttr(_dafc)
			continue
		}
	}
	for {
		_ffgg, _ffcgb := d.Token()
		if _ffcgb != nil {
			return _da.Errorf("parsing\u0020CT_TopBot:\u0020\u0025s", _ffcgb)
		}
		if _gbee, _cece := _ffgg.(_d.EndElement); _cece && _gbee.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_DPr and its children
func (_adfg *CT_DPr) Validate() error { return _adfg.ValidateWithPath("CT_DPr") }

// ValidateWithPath validates the CT_Phant and its children, prefixing error messages with path
func (_fbge *CT_Phant) ValidateWithPath(path string) error {
	if _fbge.PhantPr != nil {
		if _eddf := _fbge.PhantPr.ValidateWithPath(path + "\u002fPhantPr"); _eddf != nil {
			return _eddf
		}
	}
	if _cdef := _fbge.E.ValidateWithPath(path + "\u002fE"); _cdef != nil {
		return _cdef
	}
	return nil
}
func NewCT_BorderBoxPr() *CT_BorderBoxPr { _eeg := &CT_BorderBoxPr{}; return _eeg }

// Validate validates the CT_LimLoc and its children
func (_aaaa *CT_LimLoc) Validate() error { return _aaaa.ValidateWithPath("CT_LimLoc") }
func NewCT_BarPr() *CT_BarPr             { _ccf := &CT_BarPr{}; return _ccf }
func (_bdfed *CT_MCS) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_bgfd:
	for {
		_edec, _gaf := d.Token()
		if _gaf != nil {
			return _gaf
		}
		switch _ceg := _edec.(type) {
		case _d.StartElement:
			switch _ceg.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "mc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "mc"}:
				_cac := NewCT_MC()
				if _caed := d.DecodeElement(_cac, &_ceg); _caed != nil {
					return _caed
				}
				_bdfed.Mc = append(_bdfed.Mc, _cac)
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_MCS\u0020\u0025v", _ceg.Name)
				if _aggb := d.Skip(); _aggb != nil {
					return _aggb
				}
			}
		case _d.EndElement:
			break _bgfd
		case _d.CharData:
		}
	}
	return nil
}
func (_bdfe *CT_LimLowPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_gee:
	for {
		_fgbb, _adad := d.Token()
		if _adad != nil {
			return _adad
		}
		switch _bad := _fgbb.(type) {
		case _d.StartElement:
			switch _bad.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_bdfe.CtrlPr = NewCT_CtrlPr()
				if _ggfg := d.DecodeElement(_bdfe.CtrlPr, &_bad); _ggfg != nil {
					return _ggfg
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_LimLowPr\u0020\u0025v", _bad.Name)
				if _abdb := d.Skip(); _abdb != nil {
					return _abdb
				}
			}
		case _d.EndElement:
			break _gee
		case _d.CharData:
		}
	}
	return nil
}

type EG_OMathMathElements struct {
	Acc       *CT_Acc
	Bar       *CT_Bar
	Box       *CT_Box
	BorderBox *CT_BorderBox
	D         *CT_D
	EqArr     *CT_EqArr
	F         *CT_F
	Func      *CT_Func
	GroupChr  *CT_GroupChr
	LimLow    *CT_LimLow
	LimUpp    *CT_LimUpp
	M         *CT_M
	Nary      *CT_Nary
	Phant     *CT_Phant
	Rad       *CT_Rad
	SPre      *CT_SPre
	SSub      *CT_SSub
	SSubSup   *CT_SSubSup
	SSup      *CT_SSup
	R         *CT_R
}

// ValidateWithPath validates the CT_MCS and its children, prefixing error messages with path
func (_daa *CT_MCS) ValidateWithPath(path string) error {
	for _fcae, _gec := range _daa.Mc {
		if _efgg := _gec.ValidateWithPath(_da.Sprintf("\u0025s\u002fMc\u005b\u0025d]", path, _fcae)); _efgg != nil {
			return _efgg
		}
	}
	return nil
}
func (_fcdb *CT_FPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_faf:
	for {
		_baef, _dce := d.Token()
		if _dce != nil {
			return _dce
		}
		switch _dcfd := _baef.(type) {
		case _d.StartElement:
			switch _dcfd.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "type"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "type"}:
				_fcdb.Type = NewCT_FType()
				if _bbbb := d.DecodeElement(_fcdb.Type, &_dcfd); _bbbb != nil {
					return _bbbb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_fcdb.CtrlPr = NewCT_CtrlPr()
				if _dfab := d.DecodeElement(_fcdb.CtrlPr, &_dcfd); _dfab != nil {
					return _dfab
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_FPr\u0020\u0025v", _dcfd.Name)
				if _cbag := d.Skip(); _cbag != nil {
					return _cbag
				}
			}
		case _d.EndElement:
			break _faf
		case _d.CharData:
		}
	}
	return nil
}
func NewCT_Func() *CT_Func {
	_cadb := &CT_Func{}
	_cadb.FName = NewCT_OMathArg()
	_cadb.E = NewCT_OMathArg()
	return _cadb
}
func (_bdae *CT_OMathParaPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_caeag:
	for {
		_dagef, _bfea := d.Token()
		if _bfea != nil {
			return _bfea
		}
		switch _bbcb := _dagef.(type) {
		case _d.StartElement:
			switch _bbcb.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "jc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "jc"}:
				_bdae.Jc = NewCT_OMathJc()
				if _dcda := d.DecodeElement(_bdae.Jc, &_bbcb); _dcda != nil {
					return _dcda
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OMathParaPr\u0020\u0025v", _bbcb.Name)
				if _dffe := d.Skip(); _dffe != nil {
					return _dffe
				}
			}
		case _d.EndElement:
			break _caeag
		case _d.CharData:
		}
	}
	return nil
}
func (_bgfe *CT_RadPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _bgfe.DegHide != nil {
		_defa := _d.StartElement{Name: _d.Name{Local: "m:degHide"}}
		e.EncodeElement(_bgfe.DegHide, _defa)
	}
	if _bgfe.CtrlPr != nil {
		_eeaa := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_bgfe.CtrlPr, _eeaa)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Nary and its children
func (_aeeb *CT_Nary) Validate() error { return _aeeb.ValidateWithPath("CT_Nary") }

// ValidateWithPath validates the CT_XAlign and its children, prefixing error messages with path
func (_cdecg *CT_XAlign) ValidateWithPath(path string) error {
	if _cdecg.ValAttr == _f.ST_XAlignUnset {
		return _da.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _dfbf := _cdecg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _dfbf != nil {
		return _dfbf
	}
	return nil
}

// ValidateWithPath validates the CT_SPre and its children, prefixing error messages with path
func (_gcag *CT_SPre) ValidateWithPath(path string) error {
	if _gcag.SPrePr != nil {
		if _fdbe := _gcag.SPrePr.ValidateWithPath(path + "\u002fSPrePr"); _fdbe != nil {
			return _fdbe
		}
	}
	if _ceeff := _gcag.Sub.ValidateWithPath(path + "\u002fSub"); _ceeff != nil {
		return _ceeff
	}
	if _cacb := _gcag.Sup.ValidateWithPath(path + "\u002fSup"); _cacb != nil {
		return _cacb
	}
	if _gdab := _gcag.E.ValidateWithPath(path + "\u002fE"); _gdab != nil {
		return _gdab
	}
	return nil
}

type CT_OMathJc struct{ ValAttr ST_Jc }

func (_fadb *CT_MCPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_age:
	for {
		_gbe, _gdae := d.Token()
		if _gdae != nil {
			return _gdae
		}
		switch _fgf := _gbe.(type) {
		case _d.StartElement:
			switch _fgf.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "count"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "count"}:
				_fadb.Count = NewCT_Integer255()
				if _caee := d.DecodeElement(_fadb.Count, &_fgf); _caee != nil {
					return _caee
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "mcJc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "mcJc"}:
				_fadb.McJc = NewCT_XAlign()
				if _cgae := d.DecodeElement(_fadb.McJc, &_fgf); _cgae != nil {
					return _cgae
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_MCPr\u0020\u0025v", _fgf.Name)
				if _fga := d.Skip(); _fga != nil {
					return _fga
				}
			}
		case _d.EndElement:
			break _age
		case _d.CharData:
		}
	}
	return nil
}
func NewCT_LimUppPr() *CT_LimUppPr { _bfc := &CT_LimUppPr{}; return _bfc }

// Validate validates the CT_FuncPr and its children
func (_aae *CT_FuncPr) Validate() error { return _aae.ValidateWithPath("CT_FuncPr") }
func NewCT_MCS() *CT_MCS                { _effa := &CT_MCS{}; return _effa }
func (_bgdb ST_FType) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_bgdb.String(), start)
}
func (_cgfce *MathPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:m"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:w"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fwordprocessingml\u002f2006\u002fmain"})
//	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "m:mathPr"
	return _cgfce.CT_MathPr.MarshalXML(e, start)
}
func (_eegb *CT_MC) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_ebd:
	for {
		_befgf, _dcef := d.Token()
		if _dcef != nil {
			return _dcef
		}
		switch _gccb := _befgf.(type) {
		case _d.StartElement:
			switch _gccb.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "mcPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "mcPr"}:
				_eegb.McPr = NewCT_MCPr()
				if _gdg := d.DecodeElement(_eegb.McPr, &_gccb); _gdg != nil {
					return _gdg
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on CT_MC \u0025v", _gccb.Name)
				if _fbefb := d.Skip(); _fbefb != nil {
					return _fbefb
				}
			}
		case _d.EndElement:
			break _ebd
		case _d.CharData:
		}
	}
	return nil
}

const (
	ST_JcUnset       ST_Jc = 0
	ST_JcLeft        ST_Jc = 1
	ST_JcRight       ST_Jc = 2
	ST_JcCenter      ST_Jc = 3
	ST_JcCenterGroup ST_Jc = 4
)

// ValidateWithPath validates the CT_RPRChoice and its children, prefixing error messages with path
func (_dgfaf *CT_RPRChoice) ValidateWithPath(path string) error {
	if _dgfaf.Nor != nil {
		if _fefd := _dgfaf.Nor.ValidateWithPath(path + "\u002fNor"); _fefd != nil {
			return _fefd
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SpacingRule and its children, prefixing error messages with path
func (_aedf *CT_SpacingRule) ValidateWithPath(path string) error {
	if _aedf.ValAttr < 0 {
		return _da.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _aedf.ValAttr)
	}
	if _aedf.ValAttr > 4 {
		return _da.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003c=\u00204\u0020\u0028have\u0020\u0025v\u0029", path, _aedf.ValAttr)
	}
	return nil
}
func (_eebd *CT_BreakBinSub) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _eaeg := range start.Attr {
		if _eaeg.Name.Local == "val" {
			_eebd.ValAttr.UnmarshalXMLAttr(_eaeg)
			continue
		}
	}
	for {
		_eege, _ggcf := d.Token()
		if _ggcf != nil {
			return _da.Errorf("parsing\u0020CT_BreakBinSub:\u0020\u0025s", _ggcf)
		}
		if _aaf, _babe := _eege.(_d.EndElement); _babe && _aaf.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_OMathJc and its children
func (_ggce *CT_OMathJc) Validate() error { return _ggce.ValidateWithPath("CT_OMathJc") }
func (_bcca *CT_LimUpp) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bcca.E = NewCT_OMathArg()
	_bcca.Lim = NewCT_OMathArg()
_bcaa:
	for {
		_ffcdg, _ccc := d.Token()
		if _ccc != nil {
			return _ccc
		}
		switch _gae := _ffcdg.(type) {
		case _d.StartElement:
			switch _gae.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limUppPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limUppPr"}:
				_bcca.LimUppPr = NewCT_LimUppPr()
				if _dace := d.DecodeElement(_bcca.LimUppPr, &_gae); _dace != nil {
					return _dace
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _gfgg := d.DecodeElement(_bcca.E, &_gae); _gfgg != nil {
					return _gfgg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "lim"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "lim"}:
				if _befe := d.DecodeElement(_bcca.Lim, &_gae); _befe != nil {
					return _befe
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element on CT_LimUpp \u0025v", _gae.Name)
				if _dgb := d.Skip(); _dgb != nil {
					return _dgb
				}
			}
		case _d.EndElement:
			break _bcaa
		case _d.CharData:
		}
	}
	return nil
}
func (_dgadc *CT_PhantPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _dgadc.Show != nil {
		_dagg := _d.StartElement{Name: _d.Name{Local: "m:show"}}
		e.EncodeElement(_dgadc.Show, _dagg)
	}
	if _dgadc.ZeroWid != nil {
		_dbee := _d.StartElement{Name: _d.Name{Local: "m:zeroWid"}}
		e.EncodeElement(_dgadc.ZeroWid, _dbee)
	}
	if _dgadc.ZeroAsc != nil {
		_ffce := _d.StartElement{Name: _d.Name{Local: "m:zeroAsc"}}
		e.EncodeElement(_dgadc.ZeroAsc, _ffce)
	}
	if _dgadc.ZeroDesc != nil {
		_ggbf := _d.StartElement{Name: _d.Name{Local: "m:zeroDesc"}}
		e.EncodeElement(_dgadc.ZeroDesc, _ggbf)
	}
	if _dgadc.Transp != nil {
		_dbdg := _d.StartElement{Name: _d.Name{Local: "m:transp"}}
		e.EncodeElement(_dgadc.Transp, _dbdg)
	}
	if _dgadc.CtrlPr != nil {
		_bebe := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_dgadc.CtrlPr, _bebe)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type CT_TopBot struct{ ValAttr ST_TopBot }

func NewCT_LimLowPr() *CT_LimLowPr { _ecbb := &CT_LimLowPr{}; return _ecbb }

// ValidateWithPath validates the CT_NaryPr and its children, prefixing error messages with path
func (_bdcd *CT_NaryPr) ValidateWithPath(path string) error {
	if _bdcd.Chr != nil {
		if _bcbc := _bdcd.Chr.ValidateWithPath(path + "\u002fChr"); _bcbc != nil {
			return _bcbc
		}
	}
	if _bdcd.LimLoc != nil {
		if _gbec := _bdcd.LimLoc.ValidateWithPath(path + "\u002fLimLoc"); _gbec != nil {
			return _gbec
		}
	}
	if _bdcd.Grow != nil {
		if _cefac := _bdcd.Grow.ValidateWithPath(path + "\u002fGrow"); _cefac != nil {
			return _cefac
		}
	}
	if _bdcd.SubHide != nil {
		if _eade := _bdcd.SubHide.ValidateWithPath(path + "\u002fSubHide"); _eade != nil {
			return _eade
		}
	}
	if _bdcd.SupHide != nil {
		if _gedf := _bdcd.SupHide.ValidateWithPath(path + "\u002fSupHide"); _gedf != nil {
			return _gedf
		}
	}
	if _bdcd.CtrlPr != nil {
		if _ffec := _bdcd.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _ffec != nil {
			return _ffec
		}
	}
	return nil
}
func (_bdbd ST_Jc) ValidateWithPath(path string) error {
	switch _bdbd {
	case 0, 1, 2, 3, 4:
	default:
		return _da.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bdbd))
	}
	return nil
}

// Validate validates the CT_AccPr and its children
func (_bbe *CT_AccPr) Validate() error { return _bbe.ValidateWithPath("CT_AccPr") }

// ValidateWithPath validates the CT_FType and its children, prefixing error messages with path
func (_acg *CT_FType) ValidateWithPath(path string) error {
	if _acg.ValAttr == ST_FTypeUnset {
		return _da.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _deaf := _acg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _deaf != nil {
		return _deaf
	}
	return nil
}

// ValidateWithPath validates the CT_MathPrChoice and its children, prefixing error messages with path
func (_bagg *CT_MathPrChoice) ValidateWithPath(path string) error {
	if _bagg.WrapIndent != nil {
		if _ddcd := _bagg.WrapIndent.ValidateWithPath(path + "/WrapIndent"); _ddcd != nil {
			return _ddcd
		}
	}
	if _bagg.WrapRight != nil {
		if _dgcfb := _bagg.WrapRight.ValidateWithPath(path + "\u002fWrapRight"); _dgcfb != nil {
			return _dgcfb
		}
	}
	return nil
}
func (_gedea *CT_NaryPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _gedea.Chr != nil {
		_dge := _d.StartElement{Name: _d.Name{Local: "m:chr"}}
		e.EncodeElement(_gedea.Chr, _dge)
	}
	if _gedea.LimLoc != nil {
		_agc := _d.StartElement{Name: _d.Name{Local: "m:limLoc"}}
		e.EncodeElement(_gedea.LimLoc, _agc)
	}
	if _gedea.Grow != nil {
		_acaa := _d.StartElement{Name: _d.Name{Local: "m:grow"}}
		e.EncodeElement(_gedea.Grow, _acaa)
	}
	if _gedea.SubHide != nil {
		_abec := _d.StartElement{Name: _d.Name{Local: "m:subHide"}}
		e.EncodeElement(_gedea.SubHide, _abec)
	}
	if _gedea.SupHide != nil {
		_afda := _d.StartElement{Name: _d.Name{Local: "m:supHide"}}
		e.EncodeElement(_gedea.SupHide, _afda)
	}
	if _gedea.CtrlPr != nil {
		_fabg := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_gedea.CtrlPr, _fabg)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewCT_Shp() *CT_Shp { _gcbg := &CT_Shp{}; _gcbg.ValAttr = ST_Shp(1); return _gcbg }

const (
	ST_LimLocUnset  ST_LimLoc = 0
	ST_LimLocUndOvr ST_LimLoc = 1
	ST_LimLocSubSup ST_LimLoc = 2
)

func (_cedg *CT_SSupPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_bcdacb:
	for {
		_cfbfa, _adcd := d.Token()
		if _adcd != nil {
			return _adcd
		}
		switch _fgdfa := _cfbfa.(type) {
		case _d.StartElement:
			switch _fgdfa.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_cedg.CtrlPr = NewCT_CtrlPr()
				if _edcg := d.DecodeElement(_cedg.CtrlPr, &_fgdfa); _edcg != nil {
					return _edcg
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element on CT_SSupPr \u0025v", _fgdfa.Name)
				if _bgcd := d.Skip(); _bgcd != nil {
					return _bgcd
				}
			}
		case _d.EndElement:
			break _bcdacb
		case _d.CharData:
		}
	}
	return nil
}
func NewCT_MR() *CT_MR { _bgcb := &CT_MR{}; return _bgcb }
func (_faeg *CT_TwipsMeasure) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _acbc := range start.Attr {
		if _acbc.Name.Local == "val" {
			_eadf, _bfaac := ParseUnionST_TwipsMeasure(_acbc.Value)
			if _bfaac != nil {
				return _bfaac
			}
			_faeg.ValAttr = _eadf
			continue
		}
	}
	for {
		_dgg, _eeac := d.Token()
		if _eeac != nil {
			return _da.Errorf("parsing CT_TwipsMeasure:\u0020\u0025s", _eeac)
		}
		if _bfbee, _acae := _dgg.(_d.EndElement); _acae && _bfbee.Name == start.Name {
			break
		}
	}
	return nil
}
func (_effga ST_FType) Validate() error { return _effga.ValidateWithPath("") }

type CT_SSubPr struct{ CtrlPr *CT_CtrlPr }

const (
	ST_BreakBinUnset  ST_BreakBin = 0
	ST_BreakBinBefore ST_BreakBin = 1
	ST_BreakBinAfter  ST_BreakBin = 2
	ST_BreakBinRepeat ST_BreakBin = 3
)

func (_cgd *CT_Phant) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_cgd.E = NewCT_OMathArg()
_fcbc:
	for {
		_decb, _dcbca := d.Token()
		if _dcbca != nil {
			return _dcbca
		}
		switch _aegc := _decb.(type) {
		case _d.StartElement:
			switch _aegc.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "phantPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "phantPr"}:
				_cgd.PhantPr = NewCT_PhantPr()
				if _adgc := d.DecodeElement(_cgd.PhantPr, &_aegc); _adgc != nil {
					return _adgc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _cfac := d.DecodeElement(_cgd.E, &_aegc); _cfac != nil {
					return _cfac
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Phant\u0020\u0025v", _aegc.Name)
				if _abca := d.Skip(); _abca != nil {
					return _abca
				}
			}
		case _d.EndElement:
			break _fcbc
		case _d.CharData:
		}
	}
	return nil
}
func NewCT_BorderBox() *CT_BorderBox { _dba := &CT_BorderBox{}; _dba.E = NewCT_OMathArg(); return _dba }
func (_dafg *OMath) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:m"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:w"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fwordprocessingml\u002f2006\u002fmain"})
//	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "m:oMath"
	return _dafg.CT_OMath.MarshalXML(e, start)
}
func (_bce *CT_CtrlPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_ecfc *CT_YAlign) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ecfc.ValAttr = _f.ST_YAlign(1)
	for _, _agdaf := range start.Attr {
		if _agdaf.Name.Local == "val" {
			_ecfc.ValAttr.UnmarshalXMLAttr(_agdaf)
			continue
		}
	}
	for {
		_debeb, _cegcb := d.Token()
		if _cegcb != nil {
			return _da.Errorf("parsing\u0020CT_YAlign:\u0020\u0025s", _cegcb)
		}
		if _baec, _acbg := _debeb.(_d.EndElement); _acbg && _baec.Name == start.Name {
			break
		}
	}
	return nil
}
func (_acb *CT_RPR) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_efad:
	for {
		_ecec, _cecd := d.Token()
		if _cecd != nil {
			return _cecd
		}
		switch _cdfed := _ecec.(type) {
		case _d.StartElement:
			switch _cdfed.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "lit"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "lit"}:
				_acb.Lit = NewCT_OnOff()
				if _cagd := d.DecodeElement(_acb.Lit, &_cdfed); _cagd != nil {
					return _cagd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "nor"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "nor"}:
				_acb.Choice = NewCT_RPRChoice()
				if _bgab := d.DecodeElement(&_acb.Choice.Nor, &_cdfed); _bgab != nil {
					return _bgab
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "brk"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "brk"}:
				_acb.Brk = NewCT_ManualBreak()
				if _cbeff := d.DecodeElement(_acb.Brk, &_cdfed); _cbeff != nil {
					return _cbeff
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "aln"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "aln"}:
				_acb.Aln = NewCT_OnOff()
				if _fcgd := d.DecodeElement(_acb.Aln, &_cdfed); _fcgd != nil {
					return _fcgd
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RPR\u0020\u0025v", _cdfed.Name)
				if _bbde := d.Skip(); _bbde != nil {
					return _bbde
				}
			}
		case _d.EndElement:
			break _efad
		case _d.CharData:
		}
	}
	return nil
}

// Validate validates the CT_RPRChoice and its children
func (_gfgce *CT_RPRChoice) Validate() error { return _gfgce.ValidateWithPath("CT_RPRChoice") }

// Validate validates the CT_MathPr and its children
func (_edc *CT_MathPr) Validate() error { return _edc.ValidateWithPath("CT_MathPr") }
func (_bacg *CT_SSup) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _bacg.SSupPr != nil {
		_bafg := _d.StartElement{Name: _d.Name{Local: "m:sSupPr"}}
		e.EncodeElement(_bacg.SSupPr, _bafg)
	}
	_cdaa := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_bacg.E, _cdaa)
	_gbfc := _d.StartElement{Name: _d.Name{Local: "m:sup"}}
	e.EncodeElement(_bacg.Sup, _gbfc)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_fadcd ST_TopBot) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_dfdd := _d.Attr{}
	_dfdd.Name = name
	switch _fadcd {
	case ST_TopBotUnset:
		_dfdd.Value = ""
	case ST_TopBotTop:
		_dfdd.Value = "top"
	case ST_TopBotBot:
		_dfdd.Value = "bot"
	}
	return _dfdd, nil
}
func NewCT_CtrlPr() *CT_CtrlPr { _cfd := &CT_CtrlPr{}; return _cfd }

// ValidateWithPath validates the EG_OMathElements and its children, prefixing error messages with path
func (_bcdd *EG_OMathElements) ValidateWithPath(path string) error {
	for _aebf, _bgfee := range _bcdd.EG_OMathMathElements {
		if _bdda := _bgfee.ValidateWithPath(_da.Sprintf("%s\u002fEG_OMathMathElements[\u0025d\u005d", path, _aebf)); _bdda != nil {
			return _bdda
		}
	}
	return nil
}
func (_bca *CT_LimLoc) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	_bdd, _efcee := _bca.ValAttr.MarshalXMLAttr(_d.Name{Local: "m:val"})
	if _efcee != nil {
		return _efcee
	}
	start.Attr = append(start.Attr, _bdd)
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SSubSupPr and its children
func (_gccgb *CT_SSubSupPr) Validate() error { return _gccgb.ValidateWithPath("CT_SSubSupPr") }

type CT_MathPr struct {
	MathFont  *CT_String
	BrkBin    *CT_BreakBin
	BrkBinSub *CT_BreakBinSub
	SmallFrac *CT_OnOff
	DispDef   *CT_OnOff
	LMargin   *CT_TwipsMeasure
	RMargin   *CT_TwipsMeasure
	DefJc     *CT_OMathJc
	PreSp     *CT_TwipsMeasure
	PostSp    *CT_TwipsMeasure
	InterSp   *CT_TwipsMeasure
	IntraSp   *CT_TwipsMeasure
	Choice    *CT_MathPrChoice
	IntLim    *CT_LimLoc
	NaryLim   *CT_LimLoc
}

func ParseUnionST_TwipsMeasure(s string) (_f.ST_TwipsMeasure, error) {
	_caaec := _f.ST_TwipsMeasure{}
	if _f.ST_PositiveUniversalMeasurePatternRe.MatchString(s) {
		_caaec.ST_PositiveUniversalMeasure = &s
	} else {
		_eaag, _fbdfe := _a.ParseFloat(s, 64)
		if _fbdfe != nil {
			return _caaec, _da.Errorf("parsing\u0020\u0025s\u0020as\u0020uint:\u0020%s", s, _fbdfe)
		}
		_caaec.ST_UnsignedDecimalNumber = _e.Uint64(uint64(_eaag))
	}
	return _caaec, nil
}

// Validate validates the CT_UnSignedInteger and its children
func (_fbaa *CT_UnSignedInteger) Validate() error {
	return _fbaa.ValidateWithPath("CT_UnSignedInteger")
}
func NewCT_LimLoc() *CT_LimLoc { _ggac := &CT_LimLoc{}; _ggac.ValAttr = ST_LimLoc(1); return _ggac }

type CT_SSub struct {
	SSubPr *CT_SSubPr
	E      *CT_OMathArg
	Sub    *CT_OMathArg
}

// ValidateWithPath validates the EG_ScriptStyle and its children, prefixing error messages with path
func (_ddgcg *EG_ScriptStyle) ValidateWithPath(path string) error {
	if _ddgcg.Scr != nil {
		if _fgfaf := _ddgcg.Scr.ValidateWithPath(path + "\u002fScr"); _fgfaf != nil {
			return _fgfaf
		}
	}
	if _ddgcg.Sty != nil {
		if _fbae := _ddgcg.Sty.ValidateWithPath(path + "\u002fSty"); _fbae != nil {
			return _fbae
		}
	}
	return nil
}

// Validate validates the CT_R and its children
func (_dagga *CT_R) Validate() error { return _dagga.ValidateWithPath("CT_R") }
func (_edfd *CT_Rad) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _edfd.RadPr != nil {
		_acga := _d.StartElement{Name: _d.Name{Local: "m:radPr"}}
		e.EncodeElement(_edfd.RadPr, _acga)
	}
	_bcdf := _d.StartElement{Name: _d.Name{Local: "m:deg"}}
	e.EncodeElement(_edfd.Deg, _bcdf)
	_cfaeg := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_edfd.E, _cfaeg)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_fgge ST_BreakBinSub) String() string {
	switch _fgge {
	case 0:
		return ""
	case 1:
		return "\u002d\u002d"
	case 2:
		return "\u002d\u002b"
	case 3:
		return "\u002b\u002d"
	}
	return ""
}

// ValidateWithPath validates the CT_DPr and its children, prefixing error messages with path
func (_gca *CT_DPr) ValidateWithPath(path string) error {
	if _gca.BegChr != nil {
		if _egbf := _gca.BegChr.ValidateWithPath(path + "\u002fBegChr"); _egbf != nil {
			return _egbf
		}
	}
	if _gca.SepChr != nil {
		if _dfd := _gca.SepChr.ValidateWithPath(path + "\u002fSepChr"); _dfd != nil {
			return _dfd
		}
	}
	if _gca.EndChr != nil {
		if _ffgb := _gca.EndChr.ValidateWithPath(path + "\u002fEndChr"); _ffgb != nil {
			return _ffgb
		}
	}
	if _gca.Grow != nil {
		if _ffef := _gca.Grow.ValidateWithPath(path + "\u002fGrow"); _ffef != nil {
			return _ffef
		}
	}
	if _gca.Shp != nil {
		if _gcab := _gca.Shp.ValidateWithPath(path + "\u002fShp"); _gcab != nil {
			return _gcab
		}
	}
	if _gca.CtrlPr != nil {
		if _debd := _gca.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _debd != nil {
			return _debd
		}
	}
	return nil
}
func (_fdeb *CT_SSub) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _fdeb.SSubPr != nil {
		_dgeb := _d.StartElement{Name: _d.Name{Local: "m:sSubPr"}}
		e.EncodeElement(_fdeb.SSubPr, _dgeb)
	}
	_egcg := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_fdeb.E, _egcg)
	_efbdf := _d.StartElement{Name: _d.Name{Local: "m:sub"}}
	e.EncodeElement(_fdeb.Sub, _efbdf)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

const (
	ST_BreakBinSubUnset ST_BreakBinSub = 0
	ST_BreakBinSub__    ST_BreakBinSub = 1
	ST_BreakBinSub___   ST_BreakBinSub = 2
	ST_BreakBinSub____  ST_BreakBinSub = 3
)

func (_ade *CT_BorderBoxPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_fbc:
	for {
		_dgf, _bcc := d.Token()
		if _bcc != nil {
			return _bcc
		}
		switch _efg := _dgf.(type) {
		case _d.StartElement:
			switch _efg.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "hideTop"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "hideTop"}:
				_ade.HideTop = NewCT_OnOff()
				if _dfc := d.DecodeElement(_ade.HideTop, &_efg); _dfc != nil {
					return _dfc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "hideBot"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "hideBot"}:
				_ade.HideBot = NewCT_OnOff()
				if _adb := d.DecodeElement(_ade.HideBot, &_efg); _adb != nil {
					return _adb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "hideLeft"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "hideLeft"}:
				_ade.HideLeft = NewCT_OnOff()
				if _dfg := d.DecodeElement(_ade.HideLeft, &_efg); _dfg != nil {
					return _dfg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "hideRight"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "hideRight"}:
				_ade.HideRight = NewCT_OnOff()
				if _dbaa := d.DecodeElement(_ade.HideRight, &_efg); _dbaa != nil {
					return _dbaa
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "strikeH"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "strikeH"}:
				_ade.StrikeH = NewCT_OnOff()
				if _dad := d.DecodeElement(_ade.StrikeH, &_efg); _dad != nil {
					return _dad
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "strikeV"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "strikeV"}:
				_ade.StrikeV = NewCT_OnOff()
				if _bec := d.DecodeElement(_ade.StrikeV, &_efg); _bec != nil {
					return _bec
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "strikeBLTR"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "strikeBLTR"}:
				_ade.StrikeBLTR = NewCT_OnOff()
				if _deb := d.DecodeElement(_ade.StrikeBLTR, &_efg); _deb != nil {
					return _deb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "strikeTLBR"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "strikeTLBR"}:
				_ade.StrikeTLBR = NewCT_OnOff()
				if _dea := d.DecodeElement(_ade.StrikeTLBR, &_efg); _dea != nil {
					return _dea
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_ade.CtrlPr = NewCT_CtrlPr()
				if _ca := d.DecodeElement(_ade.CtrlPr, &_efg); _ca != nil {
					return _ca
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BorderBoxPr\u0020\u0025v", _efg.Name)
				if _egg := d.Skip(); _egg != nil {
					return _egg
				}
			}
		case _d.EndElement:
			break _fbc
		case _d.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_LimLoc and its children, prefixing error messages with path
func (_dcaa *CT_LimLoc) ValidateWithPath(path string) error {
	if _dcaa.ValAttr == ST_LimLocUnset {
		return _da.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _ebf := _dcaa.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _ebf != nil {
		return _ebf
	}
	return nil
}

// ValidateWithPath validates the CT_OMathArgPr and its children, prefixing error messages with path
func (_cfcaf *CT_OMathArgPr) ValidateWithPath(path string) error {
	if _cfcaf.ArgSz != nil {
		if _cbcd := _cfcaf.ArgSz.ValidateWithPath(path + "\u002fArgSz"); _cbcd != nil {
			return _cbcd
		}
	}
	return nil
}

type EG_OMathElements struct{ EG_OMathMathElements []*EG_OMathMathElements }

func NewCT_GroupChrPr() *CT_GroupChrPr { _cdg := &CT_GroupChrPr{}; return _cdg }
func (_ffb *CT_EqArr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_eca:
	for {
		_dfe, _aeg := d.Token()
		if _aeg != nil {
			return _aeg
		}
		switch _dcd := _dfe.(type) {
		case _d.StartElement:
			switch _dcd.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "eqArrPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "eqArrPr"}:
				_ffb.EqArrPr = NewCT_EqArrPr()
				if _faeb := d.DecodeElement(_ffb.EqArrPr, &_dcd); _faeb != nil {
					return _faeb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				_aac := NewCT_OMathArg()
				if _ecb := d.DecodeElement(_aac, &_dcd); _ecb != nil {
					return _ecb
				}
				_ffb.E = append(_ffb.E, _aac)
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_EqArr\u0020\u0025v", _dcd.Name)
				if _gad := d.Skip(); _gad != nil {
					return _gad
				}
			}
		case _d.EndElement:
			break _eca
		case _d.CharData:
		}
	}
	return nil
}
func (_bgb *CT_MathPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_dfda:
	for {
		_cfb, _cbe := d.Token()
		if _cbe != nil {
			return _cbe
		}
		switch _cdec := _cfb.(type) {
		case _d.StartElement:
			switch _cdec.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "mathFont"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "mathFont"}:
				_bgb.MathFont = NewCT_String()
				if _bedc := d.DecodeElement(_bgb.MathFont, &_cdec); _bedc != nil {
					return _bedc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "brkBin"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "brkBin"}:
				_bgb.BrkBin = NewCT_BreakBin()
				if _ggcd := d.DecodeElement(_bgb.BrkBin, &_cdec); _ggcd != nil {
					return _ggcd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "brkBinSub"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "brkBinSub"}:
				_bgb.BrkBinSub = NewCT_BreakBinSub()
				if _ffa := d.DecodeElement(_bgb.BrkBinSub, &_cdec); _ffa != nil {
					return _ffa
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "smallFrac"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "smallFrac"}:
				_bgb.SmallFrac = NewCT_OnOff()
				if _ffbe := d.DecodeElement(_bgb.SmallFrac, &_cdec); _ffbe != nil {
					return _ffbe
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "dispDef"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "dispDef"}:
				_bgb.DispDef = NewCT_OnOff()
				if _ggbe := d.DecodeElement(_bgb.DispDef, &_cdec); _ggbe != nil {
					return _ggbe
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "lMargin"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "lMargin"}:
				_bgb.LMargin = NewCT_TwipsMeasure()
				if _fbad := d.DecodeElement(_bgb.LMargin, &_cdec); _fbad != nil {
					return _fbad
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rMargin"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rMargin"}:
				_bgb.RMargin = NewCT_TwipsMeasure()
				if _dbbf := d.DecodeElement(_bgb.RMargin, &_cdec); _dbbf != nil {
					return _dbbf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "defJc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "defJc"}:
				_bgb.DefJc = NewCT_OMathJc()
				if _eac := d.DecodeElement(_bgb.DefJc, &_cdec); _eac != nil {
					return _eac
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "preSp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "preSp"}:
				_bgb.PreSp = NewCT_TwipsMeasure()
				if _bfd := d.DecodeElement(_bgb.PreSp, &_cdec); _bfd != nil {
					return _bfd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "postSp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "postSp"}:
				_bgb.PostSp = NewCT_TwipsMeasure()
				if _cag := d.DecodeElement(_bgb.PostSp, &_cdec); _cag != nil {
					return _cag
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "interSp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "interSp"}:
				_bgb.InterSp = NewCT_TwipsMeasure()
				if _cfbc := d.DecodeElement(_bgb.InterSp, &_cdec); _cfbc != nil {
					return _cfbc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "intraSp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "intraSp"}:
				_bgb.IntraSp = NewCT_TwipsMeasure()
				if _cbagd := d.DecodeElement(_bgb.IntraSp, &_cdec); _cbagd != nil {
					return _cbagd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "wrapIndent"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "wrapIndent"}:
				_bgb.Choice = NewCT_MathPrChoice()
				if _dgcf := d.DecodeElement(&_bgb.Choice.WrapIndent, &_cdec); _dgcf != nil {
					return _dgcf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "wrapRight"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "wrapRight"}:
				_bgb.Choice = NewCT_MathPrChoice()
				if _caag := d.DecodeElement(&_bgb.Choice.WrapRight, &_cdec); _caag != nil {
					return _caag
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "intLim"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "intLim"}:
				_bgb.IntLim = NewCT_LimLoc()
				if _eea := d.DecodeElement(_bgb.IntLim, &_cdec); _eea != nil {
					return _eea
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "naryLim"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "naryLim"}:
				_bgb.NaryLim = NewCT_LimLoc()
				if _bdgb := d.DecodeElement(_bgb.NaryLim, &_cdec); _bdgb != nil {
					return _bdgb
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element on CT_MathPr \u0025v", _cdec.Name)
				if _fbb := d.Skip(); _fbb != nil {
					return _fbb
				}
			}
		case _d.EndElement:
			break _dfda
		case _d.CharData:
		}
	}
	return nil
}
func NewCT_DPr() *CT_DPr { _gcd := &CT_DPr{}; return _gcd }
func (_cede ST_Style) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_cede.String(), start)
}
func (_decf *CT_Shp) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_decf.ValAttr = ST_Shp(1)
	for _, _bbccfc := range start.Attr {
		if _bbccfc.Name.Local == "val" {
			_decf.ValAttr.UnmarshalXMLAttr(_bbccfc)
			continue
		}
	}
	for {
		_abb, _gba := d.Token()
		if _gba != nil {
			return _da.Errorf("parsing\u0020CT_Shp:\u0020\u0025s", _gba)
		}
		if _dgdb, _fcecg := _abb.(_d.EndElement); _fcecg && _dgdb.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_MathPrChoice struct {
	WrapIndent *CT_TwipsMeasure
	WrapRight  *CT_OnOff
}

func (_caaa ST_Jc) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_gcfb := _d.Attr{}
	_gcfb.Name = name
	switch _caaa {
	case ST_JcUnset:
		_gcfb.Value = ""
	case ST_JcLeft:
		_gcfb.Value = "left"
	case ST_JcRight:
		_gcfb.Value = "right"
	case ST_JcCenter:
		_gcfb.Value = "center"
	case ST_JcCenterGroup:
		_gcfb.Value = "centerGroup"
	}
	return _gcfb, nil
}

// ValidateWithPath validates the CT_OMath and its children, prefixing error messages with path
func (_dadc *CT_OMath) ValidateWithPath(path string) error {
	for _ggfb, _gcfad := range _dadc.EG_OMathMathElements {
		if _cfab := _gcfad.ValidateWithPath(_da.Sprintf("%s\u002fEG_OMathMathElements[\u0025d\u005d", path, _ggfb)); _cfab != nil {
			return _cfab
		}
	}
	return nil
}
func NewCT_SpacingRule() *CT_SpacingRule {
	_ggecg := &CT_SpacingRule{}
	_ggecg.ValAttr = 0
	return _ggecg
}
func (_ggcfde ST_BreakBinSub) Validate() error { return _ggcfde.ValidateWithPath("") }

type CT_Integer2 struct{ ValAttr int64 }
type OMath struct{ CT_OMath }

func (_bafc *ST_Script) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_bafc = 0
	case "roman":
		*_bafc = 1
	case "script":
		*_bafc = 2
	case "fraktur":
		*_bafc = 3
	case "double\u002dstruck":
		*_bafc = 4
	case "sans\u002dserif":
		*_bafc = 5
	case "monospace":
		*_bafc = 6
	}
	return nil
}

// ValidateWithPath validates the CT_EqArrPr and its children, prefixing error messages with path
func (_fce *CT_EqArrPr) ValidateWithPath(path string) error {
	if _fce.BaseJc != nil {
		if _gaba := _fce.BaseJc.ValidateWithPath(path + "\u002fBaseJc"); _gaba != nil {
			return _gaba
		}
	}
	if _fce.MaxDist != nil {
		if _bcg := _fce.MaxDist.ValidateWithPath(path + "\u002fMaxDist"); _bcg != nil {
			return _bcg
		}
	}
	if _fce.ObjDist != nil {
		if _aabf := _fce.ObjDist.ValidateWithPath(path + "\u002fObjDist"); _aabf != nil {
			return _aabf
		}
	}
	if _fce.RSpRule != nil {
		if _fgdf := _fce.RSpRule.ValidateWithPath(path + "\u002fRSpRule"); _fgdf != nil {
			return _fgdf
		}
	}
	if _fce.RSp != nil {
		if _bag := _fce.RSp.ValidateWithPath(path + "\u002fRSp"); _bag != nil {
			return _bag
		}
	}
	if _fce.CtrlPr != nil {
		if _abf := _fce.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _abf != nil {
			return _abf
		}
	}
	return nil
}
func (_cagb ST_Shp) Validate() error { return _cagb.ValidateWithPath("") }
func NewCT_M() *CT_M                 { _ddgb := &CT_M{}; return _ddgb }

// ValidateWithPath validates the CT_YAlign and its children, prefixing error messages with path
func (_ccdea *CT_YAlign) ValidateWithPath(path string) error {
	if _ccdea.ValAttr == _f.ST_YAlignUnset {
		return _da.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bbddc := _ccdea.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bbddc != nil {
		return _bbddc
	}
	return nil
}
func (_afcd *CT_M) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_ceed:
	for {
		_eegf, _dcfg := d.Token()
		if _dcfg != nil {
			return _dcfg
		}
		switch _ggbb := _eegf.(type) {
		case _d.StartElement:
			switch _ggbb.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "mPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "mPr"}:
				_afcd.MPr = NewCT_MPr()
				if _aca := d.DecodeElement(_afcd.MPr, &_ggbb); _aca != nil {
					return _aca
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "mr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "mr"}:
				_cefa := NewCT_MR()
				if _fbefd := d.DecodeElement(_cefa, &_ggbb); _fbefd != nil {
					return _fbefd
				}
				_afcd.Mr = append(_afcd.Mr, _cefa)
			default:
				_e.Log("skipping\u0020unsupported element\u0020on\u0020CT_M\u0020\u0025v", _ggbb.Name)
				if _cdcg := d.Skip(); _cdcg != nil {
					return _cdcg
				}
			}
		case _d.EndElement:
			break _ceed
		case _d.CharData:
		}
	}
	return nil
}

type CT_Phant struct {
	PhantPr *CT_PhantPr
	E       *CT_OMathArg
}

func (_bfaa *CT_SSup) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bfaa.E = NewCT_OMathArg()
	_bfaa.Sup = NewCT_OMathArg()
_ccfbf:
	for {
		_efef, _gafe := d.Token()
		if _gafe != nil {
			return _gafe
		}
		switch _bede := _efef.(type) {
		case _d.StartElement:
			switch _bede.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSupPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSupPr"}:
				_bfaa.SSupPr = NewCT_SSupPr()
				if _bfdg := d.DecodeElement(_bfaa.SSupPr, &_bede); _bfdg != nil {
					return _bfdg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _adgf := d.DecodeElement(_bfaa.E, &_bede); _adgf != nil {
					return _adgf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sup"}:
				if _caae := d.DecodeElement(_bfaa.Sup, &_bede); _caae != nil {
					return _caae
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SSup\u0020\u0025v", _bede.Name)
				if _bgga := d.Skip(); _bgga != nil {
					return _bgga
				}
			}
		case _d.EndElement:
			break _ccfbf
		case _d.CharData:
		}
	}
	return nil
}

type CT_SpacingRule struct{ ValAttr int64 }

// ValidateWithPath validates the CT_Char and its children, prefixing error messages with path
func (_gbd *CT_Char) ValidateWithPath(path string) error { return nil }
func (_cbfgg ST_TopBot) String() string {
	switch _cbfgg {
	case 0:
		return ""
	case 1:
		return "top"
	case 2:
		return "bot"
	}
	return ""
}

// ValidateWithPath validates the CT_MC and its children, prefixing error messages with path
func (_efbd *CT_MC) ValidateWithPath(path string) error {
	if _efbd.McPr != nil {
		if _fdgb := _efbd.McPr.ValidateWithPath(path + "\u002fMcPr"); _fdgb != nil {
			return _fdgb
		}
	}
	return nil
}

type CT_SSubSup struct {
	SSubSupPr *CT_SSubSupPr
	E         *CT_OMathArg
	Sub       *CT_OMathArg
	Sup       *CT_OMathArg
}
type CT_GroupChrPr struct {
	Chr    *CT_Char
	Pos    *CT_TopBot
	VertJc *CT_TopBot
	CtrlPr *CT_CtrlPr
}

func (_bfed *CT_SPre) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bfed.Sub = NewCT_OMathArg()
	_bfed.Sup = NewCT_OMathArg()
	_bfed.E = NewCT_OMathArg()
_abef:
	for {
		_dfbc, _fcfdd := d.Token()
		if _fcfdd != nil {
			return _fcfdd
		}
		switch _aaafa := _dfbc.(type) {
		case _d.StartElement:
			switch _aaafa.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sPrePr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sPrePr"}:
				_bfed.SPrePr = NewCT_SPrePr()
				if _cgff := d.DecodeElement(_bfed.SPrePr, &_aaafa); _cgff != nil {
					return _cgff
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sub"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sub"}:
				if _bafd := d.DecodeElement(_bfed.Sub, &_aaafa); _bafd != nil {
					return _bafd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sup"}:
				if _fcda := d.DecodeElement(_bfed.Sup, &_aaafa); _fcda != nil {
					return _fcda
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _effe := d.DecodeElement(_bfed.E, &_aaafa); _effe != nil {
					return _effe
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SPre\u0020\u0025v", _aaafa.Name)
				if _cfbf := d.Skip(); _cfbf != nil {
					return _cfbf
				}
			}
		case _d.EndElement:
			break _abef
		case _d.CharData:
		}
	}
	return nil
}
func (_geff *CT_SSub) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_geff.E = NewCT_OMathArg()
	_geff.Sub = NewCT_OMathArg()
_fcdd:
	for {
		_aefa, _eacc := d.Token()
		if _eacc != nil {
			return _eacc
		}
		switch _efebe := _aefa.(type) {
		case _d.StartElement:
			switch _efebe.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSubPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSubPr"}:
				_geff.SSubPr = NewCT_SSubPr()
				if _egfgb := d.DecodeElement(_geff.SSubPr, &_efebe); _egfgb != nil {
					return _egfgb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _fbgf := d.DecodeElement(_geff.E, &_efebe); _fbgf != nil {
					return _fbgf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sub"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sub"}:
				if _gadag := d.DecodeElement(_geff.Sub, &_efebe); _gadag != nil {
					return _gadag
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SSub\u0020\u0025v", _efebe.Name)
				if _bbae := d.Skip(); _bbae != nil {
					return _bbae
				}
			}
		case _d.EndElement:
			break _fcdd
		case _d.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Box and its children
func (_gb *CT_Box) Validate() error { return _gb.ValidateWithPath("CT_Box") }

// ValidateWithPath validates the CT_Text and its children, prefixing error messages with path
func (_acdd *CT_Text) ValidateWithPath(path string) error { return nil }
func (_egcgd ST_Style) Validate() error                   { return _egcgd.ValidateWithPath("") }
func (_fbggb ST_FType) String() string {
	switch _fbggb {
	case 0:
		return ""
	case 1:
		return "bar"
	case 2:
		return "skw"
	case 3:
		return "lin"
	case 4:
		return "noBar"
	}
	return ""
}
func NewCT_Integer2() *CT_Integer2 { _febb := &CT_Integer2{}; _febb.ValAttr = -2; return _febb }

// ValidateWithPath validates the CT_SSupPr and its children, prefixing error messages with path
func (_cbddd *CT_SSupPr) ValidateWithPath(path string) error {
	if _cbddd.CtrlPr != nil {
		if _gded := _cbddd.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _gded != nil {
			return _gded
		}
	}
	return nil
}
func (_gdfe *CT_RPR) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _gdfe.Lit != nil {
		_fbdg := _d.StartElement{Name: _d.Name{Local: "m:lit"}}
		e.EncodeElement(_gdfe.Lit, _fbdg)
	}
	if _gdfe.Choice != nil {
		_gdfe.Choice.MarshalXML(e, _d.StartElement{})
	}
	if _gdfe.Brk != nil {
		_dfgg := _d.StartElement{Name: _d.Name{Local: "m:brk"}}
		e.EncodeElement(_gdfe.Brk, _dfgg)
	}
	if _gdfe.Aln != nil {
		_bcdc := _d.StartElement{Name: _d.Name{Local: "m:aln"}}
		e.EncodeElement(_gdfe.Aln, _bcdc)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewCT_Acc() *CT_Acc { _fa := &CT_Acc{}; _fa.E = NewCT_OMathArg(); return _fa }

// Validate validates the CT_OnOff and its children
func (_fgbd *CT_OnOff) Validate() error { return _fgbd.ValidateWithPath("CT_OnOff") }
func NewCT_RChoice() *CT_RChoice        { _cgdc := &CT_RChoice{}; return _cgdc }

// ValidateWithPath validates the CT_R and its children, prefixing error messages with path
func (_cdeaf *CT_R) ValidateWithPath(path string) error {
	if _cdeaf.RPr != nil {
		if _egeg := _cdeaf.RPr.ValidateWithPath(path + "\u002fRPr"); _egeg != nil {
			return _egeg
		}
	}
	for _ebgec, _fdd := range _cdeaf.Choice {
		if _fcfd := _fdd.ValidateWithPath(_da.Sprintf("\u0025s\u002fChoice\u005b\u0025d\u005d", path, _ebgec)); _fcfd != nil {
			return _fcfd
		}
	}
	return nil
}
func (_abed *CT_Nary) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_abed.Sub = NewCT_OMathArg()
	_abed.Sup = NewCT_OMathArg()
	_abed.E = NewCT_OMathArg()
_deba:
	for {
		_ddea, _cafd := d.Token()
		if _cafd != nil {
			return _cafd
		}
		switch _ebbc := _ddea.(type) {
		case _d.StartElement:
			switch _ebbc.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "naryPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "naryPr"}:
				_abed.NaryPr = NewCT_NaryPr()
				if _gede := d.DecodeElement(_abed.NaryPr, &_ebbc); _gede != nil {
					return _gede
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sub"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sub"}:
				if _edfb := d.DecodeElement(_abed.Sub, &_ebbc); _edfb != nil {
					return _edfb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sup"}:
				if _deag := d.DecodeElement(_abed.Sup, &_ebbc); _deag != nil {
					return _deag
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _debe := d.DecodeElement(_abed.E, &_ebbc); _debe != nil {
					return _debe
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Nary\u0020\u0025v", _ebbc.Name)
				if _deff := d.Skip(); _deff != nil {
					return _deff
				}
			}
		case _d.EndElement:
			break _deba
		case _d.CharData:
		}
	}
	return nil
}
func (_fcdg *CT_GroupChrPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _fcdg.Chr != nil {
		_egee := _d.StartElement{Name: _d.Name{Local: "m:chr"}}
		e.EncodeElement(_fcdg.Chr, _egee)
	}
	if _fcdg.Pos != nil {
		_afc := _d.StartElement{Name: _d.Name{Local: "m:pos"}}
		e.EncodeElement(_fcdg.Pos, _afc)
	}
	if _fcdg.VertJc != nil {
		_gcfa := _d.StartElement{Name: _d.Name{Local: "m:vertJc"}}
		e.EncodeElement(_fcdg.VertJc, _gcfa)
	}
	if _fcdg.CtrlPr != nil {
		_bgfc := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_fcdg.CtrlPr, _bgfc)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_bage *ST_FType) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_eadga, _bbfg := d.Token()
	if _bbfg != nil {
		return _bbfg
	}
	if _dbeea, _efdfb := _eadga.(_d.EndElement); _efdfb && _dbeea.Name == start.Name {
		*_bage = 1
		return nil
	}
	if _dggc, _fbcg := _eadga.(_d.CharData); !_fbcg {
		return _da.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eadga)
	} else {
		switch string(_dggc) {
		case "":
			*_bage = 0
		case "bar":
			*_bage = 1
		case "skw":
			*_bage = 2
		case "lin":
			*_bage = 3
		case "noBar":
			*_bage = 4
		}
	}
	_eadga, _bbfg = d.Token()
	if _bbfg != nil {
		return _bbfg
	}
	if _gadd, _efcb := _eadga.(_d.EndElement); _efcb && _gadd.Name == start.Name {
		return nil
	}
	return _da.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eadga)
}

type CT_R struct {
	RPr    *CT_RPR
	Choice []*CT_RChoice
}

func (_gadf *EG_OMathElements) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _gadf.EG_OMathMathElements != nil {
		for _, _edgbe := range _gadf.EG_OMathMathElements {
			_edgbe.MarshalXML(e, _d.StartElement{})
		}
	}
	return nil
}

type CT_Char struct{ ValAttr string }

func (_bbac *OMathPara) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bbac.CT_OMathPara = *NewCT_OMathPara()
_acbb:
	for {
		_eagbc, _fdgeb := d.Token()
		if _fdgeb != nil {
			return _fdgeb
		}
		switch _cfbd := _eagbc.(type) {
		case _d.StartElement:
			switch _cfbd.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "oMathParaPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "oMathParaPr"}:
				_bbac.OMathParaPr = NewCT_OMathParaPr()
				if _gaad := d.DecodeElement(_bbac.OMathParaPr, &_cfbd); _gaad != nil {
					return _gaad
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "oMath"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "oMath"}:
				_beaec := NewCT_OMath()
				if _egac := d.DecodeElement(_beaec, &_cfbd); _egac != nil {
					return _egac
				}
				_bbac.OMath = append(_bbac.OMath, _beaec)
			default:
				_e.Log("skipping\u0020unsupported\u0020element on OMathPara \u0025v", _cfbd.Name)
				if _eedg := d.Skip(); _eedg != nil {
					return _eedg
				}
			}
		case _d.EndElement:
			break _acbb
		case _d.CharData:
		}
	}
	return nil
}
func (_dcff *CT_Phant) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _dcff.PhantPr != nil {
		_gfgec := _d.StartElement{Name: _d.Name{Local: "m:phantPr"}}
		e.EncodeElement(_dcff.PhantPr, _gfgec)
	}
	_acdf := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_dcff.E, _acdf)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_dbcg *ST_TopBot) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_dbcg = 0
	case "top":
		*_dbcg = 1
	case "bot":
		*_dbcg = 2
	}
	return nil
}
func NewCT_MPr() *CT_MPr { _acag := &CT_MPr{}; return _acag }
func (_cabd ST_Script) ValidateWithPath(path string) error {
	switch _cabd {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _da.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cabd))
	}
	return nil
}
func NewCT_F() *CT_F {
	_eaa := &CT_F{}
	_eaa.Num = NewCT_OMathArg()
	_eaa.Den = NewCT_OMathArg()
	return _eaa
}

// Validate validates the CT_OMathPara and its children
func (_gfgee *CT_OMathPara) Validate() error { return _gfgee.ValidateWithPath("CT_OMathPara") }
func (_dgdfc ST_Style) ValidateWithPath(path string) error {
	switch _dgdfc {
	case 0, 1, 2, 3, 4:
	default:
		return _da.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dgdfc))
	}
	return nil
}
func (_aabb ST_Script) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_dcgd := _d.Attr{}
	_dcgd.Name = name
	switch _aabb {
	case ST_ScriptUnset:
		_dcgd.Value = ""
	case ST_ScriptRoman:
		_dcgd.Value = "roman"
	case ST_ScriptScript:
		_dcgd.Value = "script"
	case ST_ScriptFraktur:
		_dcgd.Value = "fraktur"
	case ST_ScriptDouble_struck:
		_dcgd.Value = "double\u002dstruck"
	case ST_ScriptSans_serif:
		_dcgd.Value = "sans\u002dserif"
	case ST_ScriptMonospace:
		_dcgd.Value = "monospace"
	}
	return _dcgd, nil
}

// ValidateWithPath validates the CT_OMathArg and its children, prefixing error messages with path
func (_dafa *CT_OMathArg) ValidateWithPath(path string) error {
	if _dafa.ArgPr != nil {
		if _daad := _dafa.ArgPr.ValidateWithPath(path + "\u002fArgPr"); _daad != nil {
			return _daad
		}
	}
	for _eeefd, _dddg := range _dafa.EG_OMathMathElements {
		if _cbef := _dddg.ValidateWithPath(_da.Sprintf("%s\u002fEG_OMathMathElements[\u0025d\u005d", path, _eeefd)); _cbef != nil {
			return _cbef
		}
	}
	if _dafa.CtrlPr != nil {
		if _abacc := _dafa.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _abacc != nil {
			return _abacc
		}
	}
	return nil
}

// ValidateWithPath validates the CT_String and its children, prefixing error messages with path
func (_cdga *CT_String) ValidateWithPath(path string) error { return nil }

type ST_Style byte

func NewEG_OMathElements() *EG_OMathElements           { _dfaad := &EG_OMathElements{}; return _dfaad }
func ParseUnionST_OnOff(s string) (_f.ST_OnOff, error) { return _f.ParseUnionST_OnOff(s) }
func (_agca *CT_SSubSupPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_effc:
	for {
		_cefe, _bgac := d.Token()
		if _bgac != nil {
			return _bgac
		}
		switch _geed := _cefe.(type) {
		case _d.StartElement:
			switch _geed.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "alnScr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "alnScr"}:
				_agca.AlnScr = NewCT_OnOff()
				if _dabe := d.DecodeElement(_agca.AlnScr, &_geed); _dabe != nil {
					return _dabe
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_agca.CtrlPr = NewCT_CtrlPr()
				if _dgfd := d.DecodeElement(_agca.CtrlPr, &_geed); _dgfd != nil {
					return _dgfd
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SSubSupPr\u0020\u0025v", _geed.Name)
				if _fadba := d.Skip(); _fadba != nil {
					return _fadba
				}
			}
		case _d.EndElement:
			break _effc
		case _d.CharData:
		}
	}
	return nil
}

type CT_ManualBreak struct{ AlnAtAttr *int64 }

func (_bef *CT_Func) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bef.FName = NewCT_OMathArg()
	_bef.E = NewCT_OMathArg()
_agbc:
	for {
		_ege, _fgeb := d.Token()
		if _fgeb != nil {
			return _fgeb
		}
		switch _dcdf := _ege.(type) {
		case _d.StartElement:
			switch _dcdf.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "funcPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "funcPr"}:
				_bef.FuncPr = NewCT_FuncPr()
				if _cbae := d.DecodeElement(_bef.FuncPr, &_dcdf); _cbae != nil {
					return _cbae
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "fName"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "fName"}:
				if _dfdf := d.DecodeElement(_bef.FName, &_dcdf); _dfdf != nil {
					return _dfdf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _aacd := d.DecodeElement(_bef.E, &_dcdf); _aacd != nil {
					return _aacd
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Func\u0020\u0025v", _dcdf.Name)
				if _bgea := d.Skip(); _bgea != nil {
					return _bgea
				}
			}
		case _d.EndElement:
			break _agbc
		case _d.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_OnOff and its children, prefixing error messages with path
func (_fcdga *CT_OnOff) ValidateWithPath(path string) error {
	if _fcdga.ValAttr != nil {
		if _aeebg := _fcdga.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _aeebg != nil {
			return _aeebg
		}
	}
	return nil
}

type CT_EqArrPr struct {
	BaseJc  *CT_YAlign
	MaxDist *CT_OnOff
	ObjDist *CT_OnOff
	RSpRule *CT_SpacingRule
	RSp     *CT_UnSignedInteger
	CtrlPr  *CT_CtrlPr
}

// Validate validates the CT_EqArr and its children
func (_gab *CT_EqArr) Validate() error { return _gab.ValidateWithPath("CT_EqArr") }

// Validate validates the CT_FType and its children
func (_geg *CT_FType) Validate() error { return _geg.ValidateWithPath("CT_FType") }

// Validate validates the CT_Style and its children
func (_edcf *CT_Style) Validate() error { return _edcf.ValidateWithPath("CT_Style") }

type CT_XAlign struct{ ValAttr _f.ST_XAlign }
type CT_Style struct{ ValAttr ST_Style }

// Validate validates the CT_F and its children
func (_cefc *CT_F) Validate() error { return _cefc.ValidateWithPath("CT_F") }
func (_dedg ST_BreakBinSub) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_dedg.String(), start)
}
func (_afg *CT_Nary) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _afg.NaryPr != nil {
		_fdge := _d.StartElement{Name: _d.Name{Local: "m:naryPr"}}
		e.EncodeElement(_afg.NaryPr, _fdge)
	}
	_ggeb := _d.StartElement{Name: _d.Name{Local: "m:sub"}}
	e.EncodeElement(_afg.Sub, _ggeb)
	_gdbb := _d.StartElement{Name: _d.Name{Local: "m:sup"}}
	e.EncodeElement(_afg.Sup, _gdbb)
	_dddd := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_afg.E, _dddd)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_eecg *CT_OnOff) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _dcfc := range start.Attr {
		if _dcfc.Name.Local == "val" {
			_fcfeb, _fbfe := ParseUnionST_OnOff(_dcfc.Value)
			if _fbfe != nil {
				return _fbfe
			}
			_eecg.ValAttr = &_fcfeb
			continue
		}
	}
	for {
		_aefb, _fbdfg := d.Token()
		if _fbdfg != nil {
			return _da.Errorf("parsing\u0020CT_OnOff: \u0025s", _fbdfg)
		}
		if _edfe, _cfba := _aefb.(_d.EndElement); _cfba && _edfe.Name == start.Name {
			break
		}
	}
	return nil
}
func (_acde *CT_LimLowPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _acde.CtrlPr != nil {
		_ede := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_acde.CtrlPr, _ede)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type CT_BreakBinSub struct{ ValAttr ST_BreakBinSub }

func NewCT_SPrePr() *CT_SPrePr { _caga := &CT_SPrePr{}; return _caga }

// ValidateWithPath validates the CT_SSubPr and its children, prefixing error messages with path
func (_eaef *CT_SSubPr) ValidateWithPath(path string) error {
	if _eaef.CtrlPr != nil {
		if _fefa := _eaef.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _fefa != nil {
			return _fefa
		}
	}
	return nil
}
func (_cf *CT_Char) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "m:val"}, Value: _da.Sprintf("\u0025v", _cf.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_MR and its children
func (_gdeg *CT_MR) Validate() error { return _gdeg.ValidateWithPath("CT_MR") }
func (_ffebe *CT_OMathJc) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _ffebe.ValAttr != ST_JcUnset {
		_bbcgc, _ccae := _ffebe.ValAttr.MarshalXMLAttr(_d.Name{Local: "m:val"})
		if _ccae != nil {
			return _ccae
		}
		start.Attr = append(start.Attr, _bbcgc)
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_gcg *CT_FPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _gcg.Type != nil {
		_bagc := _d.StartElement{Name: _d.Name{Local: "m:type"}}
		e.EncodeElement(_gcg.Type, _bagc)
	}
	if _gcg.CtrlPr != nil {
		_bbgg := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_gcg.CtrlPr, _bbgg)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_ba *CT_AccPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _ba.Chr != nil {
		_fb := _d.StartElement{Name: _d.Name{Local: "m:chr"}}
		e.EncodeElement(_ba.Chr, _fb)
	}
	if _ba.CtrlPr != nil {
		_ee := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_ba.CtrlPr, _ee)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_fgfb *CT_SpacingRule) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_fgfb.ValAttr = 0
	for _, _bdaea := range start.Attr {
		if _bdaea.Name.Local == "val" {
			_aebe, _fgebgb := _a.ParseInt(_bdaea.Value, 10, 64)
			if _fgebgb != nil {
				return _fgebgb
			}
			_fgfb.ValAttr = _aebe
			continue
		}
	}
	for {
		_adcbf, _gafed := d.Token()
		if _gafed != nil {
			return _da.Errorf("parsing\u0020CT_SpacingRule:\u0020\u0025s", _gafed)
		}
		if _fdcg, _gdga := _adcbf.(_d.EndElement); _gdga && _fdcg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_agcb ST_Shp) ValidateWithPath(path string) error {
	switch _agcb {
	case 0, 1, 2:
	default:
		return _da.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_agcb))
	}
	return nil
}

// Validate validates the CT_RPR and its children
func (_ccad *CT_RPR) Validate() error { return _ccad.ValidateWithPath("CT_RPR") }
func (_cgbge *ST_Jc) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_cgbge = 0
	case "left":
		*_cgbge = 1
	case "right":
		*_cgbge = 2
	case "center":
		*_cgbge = 3
	case "centerGroup":
		*_cgbge = 4
	}
	return nil
}
func NewCT_OMathPara() *CT_OMathPara { _ccbf := &CT_OMathPara{}; return _ccbf }

// ValidateWithPath validates the CT_SPrePr and its children, prefixing error messages with path
func (_fadf *CT_SPrePr) ValidateWithPath(path string) error {
	if _fadf.CtrlPr != nil {
		if _abad := _fadf.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _abad != nil {
			return _abad
		}
	}
	return nil
}
func NewCT_OMathParaPr() *CT_OMathParaPr { _cbdd := &CT_OMathParaPr{}; return _cbdd }
func NewCT_ManualBreak() *CT_ManualBreak { _debg := &CT_ManualBreak{}; return _debg }
func NewCT_R() *CT_R                     { _adge := &CT_R{}; return _adge }
func NewCT_SSupPr() *CT_SSupPr           { _efge := &CT_SSupPr{}; return _efge }
func NewCT_XAlign() *CT_XAlign           { _fdgd := &CT_XAlign{}; _fdgd.ValAttr = _f.ST_XAlign(1); return _fdgd }
func (_gega ST_TopBot) ValidateWithPath(path string) error {
	switch _gega {
	case 0, 1, 2:
	default:
		return _da.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gega))
	}
	return nil
}

// Validate validates the CT_SPrePr and its children
func (_fgea *CT_SPrePr) Validate() error { return _fgea.ValidateWithPath("CT_SPrePr") }
func (_dabd *CT_FuncPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_dfde:
	for {
		_cga, _caa := d.Token()
		if _caa != nil {
			return _caa
		}
		switch _bcfg := _cga.(type) {
		case _d.StartElement:
			switch _bcfg.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_dabd.CtrlPr = NewCT_CtrlPr()
				if _caac := d.DecodeElement(_dabd.CtrlPr, &_bcfg); _caac != nil {
					return _caac
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element on CT_FuncPr \u0025v", _bcfg.Name)
				if _cfe := d.Skip(); _cfe != nil {
					return _cfe
				}
			}
		case _d.EndElement:
			break _dfde
		case _d.CharData:
		}
	}
	return nil
}
func NewCT_Script() *CT_Script                   { _gdef := &CT_Script{}; return _gdef }
func NewCT_UnSignedInteger() *CT_UnSignedInteger { _dbdfa := &CT_UnSignedInteger{}; return _dbdfa }

// Validate validates the CT_BarPr and its children
func (_baa *CT_BarPr) Validate() error { return _baa.ValidateWithPath("CT_BarPr") }

// Validate validates the OMathPara and its children
func (_adegf *OMathPara) Validate() error { return _adegf.ValidateWithPath("OMathPara") }
func (_efca ST_Jc) Validate() error       { return _efca.ValidateWithPath("") }
func (_becg *CT_UnSignedInteger) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "m:val"}, Value: _da.Sprintf("\u0025v", _becg.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_ddedd ST_Script) Validate() error { return _ddedd.ValidateWithPath("") }

// Validate validates the CT_PhantPr and its children
func (_dgaf *CT_PhantPr) Validate() error { return _dgaf.ValidateWithPath("CT_PhantPr") }
func NewCT_BoxPr() *CT_BoxPr              { _eeb := &CT_BoxPr{}; return _eeb }

// Validate validates the CT_ManualBreak and its children
func (_fdc *CT_ManualBreak) Validate() error { return _fdc.ValidateWithPath("CT_ManualBreak") }
func NewCT_MathPrChoice() *CT_MathPrChoice   { _agbf := &CT_MathPrChoice{}; return _agbf }
func (_bdce *CT_OMathArgPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _bdce.ArgSz != nil {
		_dceff := _d.StartElement{Name: _d.Name{Local: "m:argSz"}}
		e.EncodeElement(_bdce.ArgSz, _dceff)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewCT_SSup() *CT_SSup {
	_bcbcd := &CT_SSup{}
	_bcbcd.E = NewCT_OMathArg()
	_bcbcd.Sup = NewCT_OMathArg()
	return _bcbcd
}

// Validate validates the CT_GroupChr and its children
func (_bdad *CT_GroupChr) Validate() error { return _bdad.ValidateWithPath("CT_GroupChr") }

type CT_RadPr struct {
	DegHide *CT_OnOff
	CtrlPr  *CT_CtrlPr
}

func NewCT_Text() *CT_Text { _eggf := &CT_Text{}; return _eggf }
func (_ecacf *CT_LimLow) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ecacf.E = NewCT_OMathArg()
	_ecacf.Lim = NewCT_OMathArg()
_fecg:
	for {
		_dbda, _gcba := d.Token()
		if _gcba != nil {
			return _gcba
		}
		switch _beb := _dbda.(type) {
		case _d.StartElement:
			switch _beb.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limLowPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limLowPr"}:
				_ecacf.LimLowPr = NewCT_LimLowPr()
				if _cfeg := d.DecodeElement(_ecacf.LimLowPr, &_beb); _cfeg != nil {
					return _cfeg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _dcc := d.DecodeElement(_ecacf.E, &_beb); _dcc != nil {
					return _dcc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "lim"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "lim"}:
				if _bdfd := d.DecodeElement(_ecacf.Lim, &_beb); _bdfd != nil {
					return _bdfd
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element on CT_LimLow \u0025v", _beb.Name)
				if _abc := d.Skip(); _abc != nil {
					return _abc
				}
			}
		case _d.EndElement:
			break _fecg
		case _d.CharData:
		}
	}
	return nil
}

type CT_F struct {
	FPr *CT_FPr
	Num *CT_OMathArg
	Den *CT_OMathArg
}

func (_ag *CT_AccPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_baf:
	for {
		_bb, _geb := d.Token()
		if _geb != nil {
			return _geb
		}
		switch _cee := _bb.(type) {
		case _d.StartElement:
			switch _cee.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "chr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "chr"}:
				_ag.Chr = NewCT_Char()
				if _fbd := d.DecodeElement(_ag.Chr, &_cee); _fbd != nil {
					return _fbd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_ag.CtrlPr = NewCT_CtrlPr()
				if _aa := d.DecodeElement(_ag.CtrlPr, &_cee); _aa != nil {
					return _aa
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_AccPr\u0020\u0025v", _cee.Name)
				if _aad := d.Skip(); _aad != nil {
					return _aad
				}
			}
		case _d.EndElement:
			break _baf
		case _d.CharData:
		}
	}
	return nil
}

type CT_LimUppPr struct{ CtrlPr *CT_CtrlPr }

// Validate validates the CT_Integer2 and its children
func (_dgc *CT_Integer2) Validate() error { return _dgc.ValidateWithPath("CT_Integer2") }
func NewCT_NaryPr() *CT_NaryPr            { _egfb := &CT_NaryPr{}; return _egfb }
func (_dddgg *CT_XAlign) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	_aced, _ddafd := _dddgg.ValAttr.MarshalXMLAttr(_d.Name{Local: "m:val"})
	if _ddafd != nil {
		return _ddafd
	}
	start.Attr = append(start.Attr, _aced)
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewEG_ScriptStyle() *EG_ScriptStyle { _ddgbg := &EG_ScriptStyle{}; return _ddgbg }

// ValidateWithPath validates the CT_MCPr and its children, prefixing error messages with path
func (_bdga *CT_MCPr) ValidateWithPath(path string) error {
	if _bdga.Count != nil {
		if _abge := _bdga.Count.ValidateWithPath(path + "\u002fCount"); _abge != nil {
			return _abge
		}
	}
	if _bdga.McJc != nil {
		if _efag := _bdga.McJc.ValidateWithPath(path + "\u002fMcJc"); _efag != nil {
			return _efag
		}
	}
	return nil
}
func (_bbea *CT_Text) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _fada := range start.Attr {
		if _fada.Name.Space == "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace" && _fada.Name.Local == "space" {
			_cecb, _aeae := _fada.Value, error(nil)
			if _aeae != nil {
				return _aeae
			}
			_bbea.SpaceAttr = &_cecb
			continue
		}
	}
	for {
		_aadb, _ecda := d.Token()
		if _ecda != nil {
			return _da.Errorf("parsing\u0020CT_Text:\u0020\u0025s", _ecda)
		}
		if _adba, _debb := _aadb.(_d.CharData); _debb {
			_bbea.Content = string(_adba)
		}
		if _edgb, _daeda := _aadb.(_d.EndElement); _daeda && _edgb.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_String and its children
func (_egbb *CT_String) Validate() error { return _egbb.ValidateWithPath("CT_String") }

// Validate validates the CT_BoxPr and its children
func (_ccaa *CT_BoxPr) Validate() error { return _ccaa.ValidateWithPath("CT_BoxPr") }

// ValidateWithPath validates the CT_ManualBreak and its children, prefixing error messages with path
func (_afe *CT_ManualBreak) ValidateWithPath(path string) error {
	if _afe.AlnAtAttr != nil {
		if *_afe.AlnAtAttr < 1 {
			return _da.Errorf("\u0025s/m\u002eAlnAtAttr\u0020must be\u0020\u003e\u003d\u00201\u0020\u0028have\u0020\u0025v\u0029", path, *_afe.AlnAtAttr)
		}
		if *_afe.AlnAtAttr > 255 {
			return _da.Errorf("\u0025s\u002fm\u002eAlnAtAttr\u0020must\u0020be\u0020\u003c\u003d\u0020255\u0020\u0028have\u0020\u0025v\u0029", path, *_afe.AlnAtAttr)
		}
	}
	return nil
}

type CT_OMathArg struct {
	ArgPr                *CT_OMathArgPr
	EG_OMathMathElements []*EG_OMathMathElements
	CtrlPr               *CT_CtrlPr
}
type ST_BreakBinSub byte

func (_abae *CT_XAlign) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_abae.ValAttr = _f.ST_XAlign(1)
	for _, _beedb := range start.Attr {
		if _beedb.Name.Local == "val" {
			_abae.ValAttr.UnmarshalXMLAttr(_beedb)
			continue
		}
	}
	for {
		_fbcd, _eccd := d.Token()
		if _eccd != nil {
			return _da.Errorf("parsing\u0020CT_XAlign:\u0020\u0025s", _eccd)
		}
		if _baad, _bgba := _fbcd.(_d.EndElement); _bgba && _baad.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_SSup struct {
	SSupPr *CT_SSupPr
	E      *CT_OMathArg
	Sup    *CT_OMathArg
}
type CT_SPrePr struct{ CtrlPr *CT_CtrlPr }

func NewCT_LimLow() *CT_LimLow {
	_gcee := &CT_LimLow{}
	_gcee.E = NewCT_OMathArg()
	_gcee.Lim = NewCT_OMathArg()
	return _gcee
}

type CT_YAlign struct{ ValAttr _f.ST_YAlign }

func (_eabd *CT_SSubPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_dcdbd:
	for {
		_dddf, _fcecf := d.Token()
		if _fcecf != nil {
			return _fcecf
		}
		switch _ggeag := _dddf.(type) {
		case _d.StartElement:
			switch _ggeag.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_eabd.CtrlPr = NewCT_CtrlPr()
				if _begf := d.DecodeElement(_eabd.CtrlPr, &_ggeag); _begf != nil {
					return _begf
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element on CT_SSubPr \u0025v", _ggeag.Name)
				if _aafd := d.Skip(); _aafd != nil {
					return _aafd
				}
			}
		case _d.EndElement:
			break _dcdbd
		case _d.CharData:
		}
	}
	return nil
}
func (_dbabc *CT_PhantPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_ddfd:
	for {
		_egcb, _bbdac := d.Token()
		if _bbdac != nil {
			return _bbdac
		}
		switch _efcg := _egcb.(type) {
		case _d.StartElement:
			switch _efcg.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "show"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "show"}:
				_dbabc.Show = NewCT_OnOff()
				if _effg := d.DecodeElement(_dbabc.Show, &_efcg); _effg != nil {
					return _effg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "zeroWid"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "zeroWid"}:
				_dbabc.ZeroWid = NewCT_OnOff()
				if _agda := d.DecodeElement(_dbabc.ZeroWid, &_efcg); _agda != nil {
					return _agda
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "zeroAsc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "zeroAsc"}:
				_dbabc.ZeroAsc = NewCT_OnOff()
				if _ddfda := d.DecodeElement(_dbabc.ZeroAsc, &_efcg); _ddfda != nil {
					return _ddfda
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "zeroDesc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "zeroDesc"}:
				_dbabc.ZeroDesc = NewCT_OnOff()
				if _eefba := d.DecodeElement(_dbabc.ZeroDesc, &_efcg); _eefba != nil {
					return _eefba
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "transp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "transp"}:
				_dbabc.Transp = NewCT_OnOff()
				if _fcedb := d.DecodeElement(_dbabc.Transp, &_efcg); _fcedb != nil {
					return _fcedb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_dbabc.CtrlPr = NewCT_CtrlPr()
				if _gcda := d.DecodeElement(_dbabc.CtrlPr, &_efcg); _gcda != nil {
					return _gcda
				}
			default:
				_e.Log("skipping unsupported\u0020element\u0020on\u0020CT_PhantPr\u0020\u0025v", _efcg.Name)
				if _gada := d.Skip(); _gada != nil {
					return _gada
				}
			}
		case _d.EndElement:
			break _ddfd
		case _d.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_BreakBin and its children, prefixing error messages with path
func (_adag *CT_BreakBin) ValidateWithPath(path string) error {
	if _bgc := _adag.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bgc != nil {
		return _bgc
	}
	return nil
}
func (_cggg ST_TopBot) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_cggg.String(), start)
}

// ValidateWithPath validates the OMath and its children, prefixing error messages with path
func (_egfe *OMath) ValidateWithPath(path string) error {
	if _ccgb := _egfe.CT_OMath.ValidateWithPath(path); _ccgb != nil {
		return _ccgb
	}
	return nil
}
func NewCT_YAlign() *CT_YAlign { _eeda := &CT_YAlign{}; _eeda.ValAttr = _f.ST_YAlign(1); return _eeda }

// ValidateWithPath validates the CT_SSup and its children, prefixing error messages with path
func (_dcfde *CT_SSup) ValidateWithPath(path string) error {
	if _dcfde.SSupPr != nil {
		if _aadae := _dcfde.SSupPr.ValidateWithPath(path + "\u002fSSupPr"); _aadae != nil {
			return _aadae
		}
	}
	if _affe := _dcfde.E.ValidateWithPath(path + "\u002fE"); _affe != nil {
		return _affe
	}
	if _bcdfe := _dcfde.Sup.ValidateWithPath(path + "\u002fSup"); _bcdfe != nil {
		return _bcdfe
	}
	return nil
}
func (_edfad *CT_TopBot) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	_faac, _afca := _edfad.ValAttr.MarshalXMLAttr(_d.Name{Local: "m:val"})
	if _afca != nil {
		return _afca
	}
	start.Attr = append(start.Attr, _faac)
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewCT_RadPr() *CT_RadPr { _afce := &CT_RadPr{}; return _afce }
func (_geadb ST_BreakBinSub) ValidateWithPath(path string) error {
	switch _geadb {
	case 0, 1, 2, 3:
	default:
		return _da.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_geadb))
	}
	return nil
}

// ValidateWithPath validates the CT_BorderBoxPr and its children, prefixing error messages with path
func (_ccdc *CT_BorderBoxPr) ValidateWithPath(path string) error {
	if _ccdc.HideTop != nil {
		if _eed := _ccdc.HideTop.ValidateWithPath(path + "\u002fHideTop"); _eed != nil {
			return _eed
		}
	}
	if _ccdc.HideBot != nil {
		if _bab := _ccdc.HideBot.ValidateWithPath(path + "\u002fHideBot"); _bab != nil {
			return _bab
		}
	}
	if _ccdc.HideLeft != nil {
		if _ddcg := _ccdc.HideLeft.ValidateWithPath(path + "\u002fHideLeft"); _ddcg != nil {
			return _ddcg
		}
	}
	if _ccdc.HideRight != nil {
		if _eef := _ccdc.HideRight.ValidateWithPath(path + "\u002fHideRight"); _eef != nil {
			return _eef
		}
	}
	if _ccdc.StrikeH != nil {
		if _dcf := _ccdc.StrikeH.ValidateWithPath(path + "\u002fStrikeH"); _dcf != nil {
			return _dcf
		}
	}
	if _ccdc.StrikeV != nil {
		if _fbe := _ccdc.StrikeV.ValidateWithPath(path + "\u002fStrikeV"); _fbe != nil {
			return _fbe
		}
	}
	if _ccdc.StrikeBLTR != nil {
		if _acf := _ccdc.StrikeBLTR.ValidateWithPath(path + "/StrikeBLTR"); _acf != nil {
			return _acf
		}
	}
	if _ccdc.StrikeTLBR != nil {
		if _bee := _ccdc.StrikeTLBR.ValidateWithPath(path + "/StrikeTLBR"); _bee != nil {
			return _bee
		}
	}
	if _ccdc.CtrlPr != nil {
		if _ggg := _ccdc.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _ggg != nil {
			return _ggg
		}
	}
	return nil
}

// Validate validates the CT_EqArrPr and its children
func (_agf *CT_EqArrPr) Validate() error { return _agf.ValidateWithPath("CT_EqArrPr") }
func (_cbba *EG_ScriptStyle) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_fggd:
	for {
		_adca, _bbgf := d.Token()
		if _bbgf != nil {
			return _bbgf
		}
		switch _fegd := _adca.(type) {
		case _d.StartElement:
			switch _fegd.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "scr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "scr"}:
				_cbba.Scr = NewCT_Script()
				if _fdab := d.DecodeElement(_cbba.Scr, &_fegd); _fdab != nil {
					return _fdab
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sty"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sty"}:
				_cbba.Sty = NewCT_Style()
				if _aabe := d.DecodeElement(_cbba.Sty, &_fegd); _aabe != nil {
					return _aabe
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_ScriptStyle\u0020\u0025v", _fegd.Name)
				if _efdaf := d.Skip(); _efdaf != nil {
					return _efdaf
				}
			}
		case _d.EndElement:
			break _fggd
		case _d.CharData:
		}
	}
	return nil
}

// Validate validates the CT_D and its children
func (_cba *CT_D) Validate() error { return _cba.ValidateWithPath("CT_D") }
func (_beee ST_LimLoc) String() string {
	switch _beee {
	case 0:
		return ""
	case 1:
		return "undOvr"
	case 2:
		return "subSup"
	}
	return ""
}
func NewCT_OMath() *CT_OMath { _dabf := &CT_OMath{}; return _dabf }

type CT_CtrlPr struct{}

// ValidateWithPath validates the MathPr and its children, prefixing error messages with path
func (_dged *MathPr) ValidateWithPath(path string) error {
	if _fead := _dged.CT_MathPr.ValidateWithPath(path); _fead != nil {
		return _fead
	}
	return nil
}

type CT_Func struct {
	FuncPr *CT_FuncPr
	FName  *CT_OMathArg
	E      *CT_OMathArg
}

// Validate validates the CT_SSup and its children
func (_dbdad *CT_SSup) Validate() error { return _dbdad.ValidateWithPath("CT_SSup") }
func NewCT_FType() *CT_FType            { _cgfe := &CT_FType{}; _cgfe.ValAttr = ST_FType(1); return _cgfe }

// ValidateWithPath validates the CT_BreakBinSub and its children, prefixing error messages with path
func (_fcd *CT_BreakBinSub) ValidateWithPath(path string) error {
	if _dga := _fcd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _dga != nil {
		return _dga
	}
	return nil
}
func (_baed *CT_Script) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _ggef := range start.Attr {
		if _ggef.Name.Local == "val" {
			_baed.ValAttr.UnmarshalXMLAttr(_ggef)
			continue
		}
	}
	for {
		_eddbb, _edea := d.Token()
		if _edea != nil {
			return _da.Errorf("parsing\u0020CT_Script:\u0020\u0025s", _edea)
		}
		if _ggecd, _gcdac := _eddbb.(_d.EndElement); _gcdac && _ggecd.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_RChoice and its children
func (_dfbg *CT_RChoice) Validate() error { return _dfbg.ValidateWithPath("CT_RChoice") }

type CT_Shp struct{ ValAttr ST_Shp }

func (_gbf *CT_MathPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _gbf.MathFont != nil {
		_dbab := _d.StartElement{Name: _d.Name{Local: "m:mathFont"}}
		e.EncodeElement(_gbf.MathFont, _dbab)
	}
	if _gbf.BrkBin != nil {
		_fecf := _d.StartElement{Name: _d.Name{Local: "m:brkBin"}}
		e.EncodeElement(_gbf.BrkBin, _fecf)
	}
	if _gbf.BrkBinSub != nil {
		_dcbb := _d.StartElement{Name: _d.Name{Local: "m:brkBinSub"}}
		e.EncodeElement(_gbf.BrkBinSub, _dcbb)
	}
	if _gbf.SmallFrac != nil {
		_efdc := _d.StartElement{Name: _d.Name{Local: "m:smallFrac"}}
		e.EncodeElement(_gbf.SmallFrac, _efdc)
	}
	if _gbf.DispDef != nil {
		_gfad := _d.StartElement{Name: _d.Name{Local: "m:dispDef"}}
		e.EncodeElement(_gbf.DispDef, _gfad)
	}
	if _gbf.LMargin != nil {
		_ggdc := _d.StartElement{Name: _d.Name{Local: "m:lMargin"}}
		e.EncodeElement(_gbf.LMargin, _ggdc)
	}
	if _gbf.RMargin != nil {
		_ecf := _d.StartElement{Name: _d.Name{Local: "m:rMargin"}}
		e.EncodeElement(_gbf.RMargin, _ecf)
	}
	if _gbf.DefJc != nil {
		_bgg := _d.StartElement{Name: _d.Name{Local: "m:defJc"}}
		e.EncodeElement(_gbf.DefJc, _bgg)
	}
	if _gbf.PreSp != nil {
		_dgdg := _d.StartElement{Name: _d.Name{Local: "m:preSp"}}
		e.EncodeElement(_gbf.PreSp, _dgdg)
	}
	if _gbf.PostSp != nil {
		_adee := _d.StartElement{Name: _d.Name{Local: "m:postSp"}}
		e.EncodeElement(_gbf.PostSp, _adee)
	}
	if _gbf.InterSp != nil {
		_faagf := _d.StartElement{Name: _d.Name{Local: "m:interSp"}}
		e.EncodeElement(_gbf.InterSp, _faagf)
	}
	if _gbf.IntraSp != nil {
		_bga := _d.StartElement{Name: _d.Name{Local: "m:intraSp"}}
		e.EncodeElement(_gbf.IntraSp, _bga)
	}
	if _gbf.Choice != nil {
		_gbf.Choice.MarshalXML(e, _d.StartElement{})
	}
	if _gbf.IntLim != nil {
		_ceeb := _d.StartElement{Name: _d.Name{Local: "m:intLim"}}
		e.EncodeElement(_gbf.IntLim, _ceeb)
	}
	if _gbf.NaryLim != nil {
		_aaac := _d.StartElement{Name: _d.Name{Local: "m:naryLim"}}
		e.EncodeElement(_gbf.NaryLim, _aaac)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_MR and its children, prefixing error messages with path
func (_bfgf *CT_MR) ValidateWithPath(path string) error {
	for _deac, _dfeg := range _bfgf.E {
		if _eddb := _dfeg.ValidateWithPath(_da.Sprintf("\u0025s\u002fE\u005b\u0025d\u005d", path, _deac)); _eddb != nil {
			return _eddb
		}
	}
	return nil
}
func (_ebedb ST_Jc) String() string {
	switch _ebedb {
	case 0:
		return ""
	case 1:
		return "left"
	case 2:
		return "right"
	case 3:
		return "center"
	case 4:
		return "centerGroup"
	}
	return ""
}
func (_gdcc *CT_CtrlPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for {
		_gfe, _cdc := d.Token()
		if _cdc != nil {
			return _da.Errorf("parsing\u0020CT_CtrlPr:\u0020\u0025s", _cdc)
		}
		if _cfdg, _aadd := _gfe.(_d.EndElement); _aadd && _cfdg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_agab *ST_TopBot) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_facb, _aefd := d.Token()
	if _aefd != nil {
		return _aefd
	}
	if _ceee, _begg := _facb.(_d.EndElement); _begg && _ceee.Name == start.Name {
		*_agab = 1
		return nil
	}
	if _ddba, _ffacd := _facb.(_d.CharData); !_ffacd {
		return _da.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _facb)
	} else {
		switch string(_ddba) {
		case "":
			*_agab = 0
		case "top":
			*_agab = 1
		case "bot":
			*_agab = 2
		}
	}
	_facb, _aefd = d.Token()
	if _aefd != nil {
		return _aefd
	}
	if _ddaec, _dgadb := _facb.(_d.EndElement); _dgadb && _ddaec.Name == start.Name {
		return nil
	}
	return _da.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _facb)
}
func NewCT_Bar() *CT_Bar { _gea := &CT_Bar{}; _gea.E = NewCT_OMathArg(); return _gea }

// ValidateWithPath validates the CT_Acc and its children, prefixing error messages with path
func (_b *CT_Acc) ValidateWithPath(path string) error {
	if _b.AccPr != nil {
		if _ed := _b.AccPr.ValidateWithPath(path + "\u002fAccPr"); _ed != nil {
			return _ed
		}
	}
	if _gc := _b.E.ValidateWithPath(path + "\u002fE"); _gc != nil {
		return _gc
	}
	return nil
}

const (
	ST_ScriptUnset         ST_Script = 0
	ST_ScriptRoman         ST_Script = 1
	ST_ScriptScript        ST_Script = 2
	ST_ScriptFraktur       ST_Script = 3
	ST_ScriptDouble_struck ST_Script = 4
	ST_ScriptSans_serif    ST_Script = 5
	ST_ScriptMonospace     ST_Script = 6
)

type CT_RPR struct {
	Lit    *CT_OnOff
	Choice *CT_RPRChoice
	Brk    *CT_ManualBreak
	Aln    *CT_OnOff
}

func (_acgc *CT_LimUpp) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _acgc.LimUppPr != nil {
		_fcf := _d.StartElement{Name: _d.Name{Local: "m:limUppPr"}}
		e.EncodeElement(_acgc.LimUppPr, _fcf)
	}
	_bbcd := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_acgc.E, _bbcd)
	_ggea := _d.StartElement{Name: _d.Name{Local: "m:lim"}}
	e.EncodeElement(_acgc.Lim, _ggea)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type MathPr struct{ CT_MathPr }

func (_cdfg ST_LimLoc) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_cdfg.String(), start)
}

type ST_FType byte

func (_fgcb *CT_RChoice) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _fgcb.T != nil {
		_dabg := _d.StartElement{Name: _d.Name{Local: "m:t"}}
		for _, _fdfb := range _fgcb.T {
			e.EncodeElement(_fdfb, _dabg)
		}
	}
	return nil
}

type CT_MCS struct{ Mc []*CT_MC }

func (_deffe *CT_RPRChoice) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_addfc:
	for {
		_eeaf, _cddb := d.Token()
		if _cddb != nil {
			return _cddb
		}
		switch _abga := _eeaf.(type) {
		case _d.StartElement:
			switch _abga.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "nor"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "nor"}:
				_deffe.Nor = NewCT_OnOff()
				if _deec := d.DecodeElement(_deffe.Nor, &_abga); _deec != nil {
					return _deec
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RPRChoice\u0020\u0025v", _abga.Name)
				if _afadf := d.Skip(); _afadf != nil {
					return _afadf
				}
			}
		case _d.EndElement:
			break _addfc
		case _d.CharData:
		}
	}
	return nil
}

type CT_BorderBox struct {
	BorderBoxPr *CT_BorderBoxPr
	E           *CT_OMathArg
}

// Validate validates the CT_OMathParaPr and its children
func (_gdff *CT_OMathParaPr) Validate() error { return _gdff.ValidateWithPath("CT_OMathParaPr") }
func (_efcgg *CT_RadPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_gdbf:
	for {
		_daee, _cffa := d.Token()
		if _cffa != nil {
			return _cffa
		}
		switch _caef := _daee.(type) {
		case _d.StartElement:
			switch _caef.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "degHide"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "degHide"}:
				_efcgg.DegHide = NewCT_OnOff()
				if _bdee := d.DecodeElement(_efcgg.DegHide, &_caef); _bdee != nil {
					return _bdee
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_efcgg.CtrlPr = NewCT_CtrlPr()
				if _bba := d.DecodeElement(_efcgg.CtrlPr, &_caef); _bba != nil {
					return _bba
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RadPr\u0020\u0025v", _caef.Name)
				if _gbed := d.Skip(); _gbed != nil {
					return _gbed
				}
			}
		case _d.EndElement:
			break _gdbf
		case _d.CharData:
		}
	}
	return nil
}
func (_addc *CT_BorderBox) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_addc.E = NewCT_OMathArg()
_efb:
	for {
		_gf, _gfg := d.Token()
		if _gfg != nil {
			return _gfg
		}
		switch _ddc := _gf.(type) {
		case _d.StartElement:
			switch _ddc.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "borderBoxPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "borderBoxPr"}:
				_addc.BorderBoxPr = NewCT_BorderBoxPr()
				if _agb := d.DecodeElement(_addc.BorderBoxPr, &_ddc); _agb != nil {
					return _agb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _eb := d.DecodeElement(_addc.E, &_ddc); _eb != nil {
					return _eb
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BorderBox\u0020\u0025v", _ddc.Name)
				if _ga := d.Skip(); _ga != nil {
					return _ga
				}
			}
		case _d.EndElement:
			break _efb
		case _d.CharData:
		}
	}
	return nil
}

type CT_M struct {
	MPr *CT_MPr
	Mr  []*CT_MR
}

func (_dcbe ST_FType) ValidateWithPath(path string) error {
	switch _dcbe {
	case 0, 1, 2, 3, 4:
	default:
		return _da.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dcbe))
	}
	return nil
}
func (_fdce *ST_Style) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_fegdg, _adadf := d.Token()
	if _adadf != nil {
		return _adadf
	}
	if _abgb, _gfea := _fegdg.(_d.EndElement); _gfea && _abgb.Name == start.Name {
		*_fdce = 1
		return nil
	}
	if _adaa, _adbeb := _fegdg.(_d.CharData); !_adbeb {
		return _da.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fegdg)
	} else {
		switch string(_adaa) {
		case "":
			*_fdce = 0
		case "p":
			*_fdce = 1
		case "b":
			*_fdce = 2
		case "i":
			*_fdce = 3
		case "bi":
			*_fdce = 4
		}
	}
	_fegdg, _adadf = d.Token()
	if _adadf != nil {
		return _adadf
	}
	if _dagag, _gbag := _fegdg.(_d.EndElement); _gbag && _dagag.Name == start.Name {
		return nil
	}
	return _da.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fegdg)
}
func NewCT_SPre() *CT_SPre {
	_aagd := &CT_SPre{}
	_aagd.Sub = NewCT_OMathArg()
	_aagd.Sup = NewCT_OMathArg()
	_aagd.E = NewCT_OMathArg()
	return _aagd
}
func (_ffe *CT_BreakBin) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _ffe.ValAttr != ST_BreakBinUnset {
		_dde, _dcfe := _ffe.ValAttr.MarshalXMLAttr(_d.Name{Local: "m:val"})
		if _dcfe != nil {
			return _dcfe
		}
		start.Attr = append(start.Attr, _dde)
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TopBot and its children
func (_dfbdf *CT_TopBot) Validate() error { return _dfbdf.ValidateWithPath("CT_TopBot") }
func (_deef *CT_OMathArgPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_abgf:
	for {
		_ffbbf, _fgeef := d.Token()
		if _fgeef != nil {
			return _fgeef
		}
		switch _gfb := _ffbbf.(type) {
		case _d.StartElement:
			switch _gfb.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "argSz"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "argSz"}:
				_deef.ArgSz = NewCT_Integer2()
				if _ebdg := d.DecodeElement(_deef.ArgSz, &_gfb); _ebdg != nil {
					return _ebdg
				}
			default:
				_e.Log("skipping unsupported element\u0020on\u0020CT_OMathArgPr \u0025v", _gfb.Name)
				if _gebaf := d.Skip(); _gebaf != nil {
					return _gebaf
				}
			}
		case _d.EndElement:
			break _abgf
		case _d.CharData:
		}
	}
	return nil
}
func NewCT_Char() *CT_Char { _bbf := &CT_Char{}; return _bbf }

// Validate validates the CT_MCPr and its children
func (_bcef *CT_MCPr) Validate() error { return _bcef.ValidateWithPath("CT_MCPr") }
func (_daf *CT_Acc) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_daf.E = NewCT_OMathArg()
_ff:
	for {
		_ce, _dg := d.Token()
		if _dg != nil {
			return _dg
		}
		switch _cg := _ce.(type) {
		case _d.StartElement:
			switch _cg.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "accPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "accPr"}:
				_daf.AccPr = NewCT_AccPr()
				if _af := d.DecodeElement(_daf.AccPr, &_cg); _af != nil {
					return _af
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _ffc := d.DecodeElement(_daf.E, &_cg); _ffc != nil {
					return _ffc
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Acc\u0020\u0025v", _cg.Name)
				if _ea := d.Skip(); _ea != nil {
					return _ea
				}
			}
		case _d.EndElement:
			break _ff
		case _d.CharData:
		}
	}
	return nil
}
func (_ffcb *CT_Box) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _ffcb.BoxPr != nil {
		_eae := _d.StartElement{Name: _d.Name{Local: "m:boxPr"}}
		e.EncodeElement(_ffcb.BoxPr, _eae)
	}
	_gcb := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_ffcb.E, _gcb)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TwipsMeasure and its children
func (_ffdea *CT_TwipsMeasure) Validate() error { return _ffdea.ValidateWithPath("CT_TwipsMeasure") }
func NewCT_LimUpp() *CT_LimUpp {
	_egbc := &CT_LimUpp{}
	_egbc.E = NewCT_OMathArg()
	_egbc.Lim = NewCT_OMathArg()
	return _egbc
}

// ValidateWithPath validates the CT_FPr and its children, prefixing error messages with path
func (_gbdgg *CT_FPr) ValidateWithPath(path string) error {
	if _gbdgg.Type != nil {
		if _fec := _gbdgg.Type.ValidateWithPath(path + "\u002fType"); _fec != nil {
			return _fec
		}
	}
	if _gbdgg.CtrlPr != nil {
		if _ebb := _gbdgg.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _ebb != nil {
			return _ebb
		}
	}
	return nil
}
func (_gg *CT_BarPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_cda:
	for {
		_gcf, _ddd := d.Token()
		if _ddd != nil {
			return _ddd
		}
		switch _eda := _gcf.(type) {
		case _d.StartElement:
			switch _eda.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "pos"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "pos"}:
				_gg.Pos = NewCT_TopBot()
				if _fc := d.DecodeElement(_gg.Pos, &_eda); _fc != nil {
					return _fc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_gg.CtrlPr = NewCT_CtrlPr()
				if _bg := d.DecodeElement(_gg.CtrlPr, &_eda); _bg != nil {
					return _bg
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BarPr\u0020\u0025v", _eda.Name)
				if _bafb := d.Skip(); _bafb != nil {
					return _bafb
				}
			}
		case _d.EndElement:
			break _cda
		case _d.CharData:
		}
	}
	return nil
}

type CT_Bar struct {
	BarPr *CT_BarPr
	E     *CT_OMathArg
}

// ValidateWithPath validates the CT_RChoice and its children, prefixing error messages with path
func (_affb *CT_RChoice) ValidateWithPath(path string) error {
	for _gaaf, _ggdaa := range _affb.T {
		if _efcd := _ggdaa.ValidateWithPath(_da.Sprintf("\u0025s\u002fT\u005b\u0025d\u005d", path, _gaaf)); _efcd != nil {
			return _efcd
		}
	}
	return nil
}

// Validate validates the CT_Phant and its children
func (_gagg *CT_Phant) Validate() error { return _gagg.ValidateWithPath("CT_Phant") }
func (_adgcb *EG_OMathMathElements) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _adgcb.Acc != nil {
		_eafc := _d.StartElement{Name: _d.Name{Local: "m:acc"}}
		e.EncodeElement(_adgcb.Acc, _eafc)
	}
	if _adgcb.Bar != nil {
		_bbfee := _d.StartElement{Name: _d.Name{Local: "m:bar"}}
		e.EncodeElement(_adgcb.Bar, _bbfee)
	}
	if _adgcb.Box != nil {
		_cebg := _d.StartElement{Name: _d.Name{Local: "m:box"}}
		e.EncodeElement(_adgcb.Box, _cebg)
	}
	if _adgcb.BorderBox != nil {
		_gacg := _d.StartElement{Name: _d.Name{Local: "m:borderBox"}}
		e.EncodeElement(_adgcb.BorderBox, _gacg)
	}
	if _adgcb.D != nil {
		_gbfd := _d.StartElement{Name: _d.Name{Local: "m:d"}}
		e.EncodeElement(_adgcb.D, _gbfd)
	}
	if _adgcb.EqArr != nil {
		_edgbb := _d.StartElement{Name: _d.Name{Local: "m:eqArr"}}
		e.EncodeElement(_adgcb.EqArr, _edgbb)
	}
	if _adgcb.F != nil {
		_ddfa := _d.StartElement{Name: _d.Name{Local: "m:f"}}
		e.EncodeElement(_adgcb.F, _ddfa)
	}
	if _adgcb.Func != nil {
		_ggabf := _d.StartElement{Name: _d.Name{Local: "m:func"}}
		e.EncodeElement(_adgcb.Func, _ggabf)
	}
	if _adgcb.GroupChr != nil {
		_feg := _d.StartElement{Name: _d.Name{Local: "m:groupChr"}}
		e.EncodeElement(_adgcb.GroupChr, _feg)
	}
	if _adgcb.LimLow != nil {
		_fega := _d.StartElement{Name: _d.Name{Local: "m:limLow"}}
		e.EncodeElement(_adgcb.LimLow, _fega)
	}
	if _adgcb.LimUpp != nil {
		_ffcf := _d.StartElement{Name: _d.Name{Local: "m:limUpp"}}
		e.EncodeElement(_adgcb.LimUpp, _ffcf)
	}
	if _adgcb.M != nil {
		_bcffd := _d.StartElement{Name: _d.Name{Local: "m:m"}}
		e.EncodeElement(_adgcb.M, _bcffd)
	}
	if _adgcb.Nary != nil {
		_gacff := _d.StartElement{Name: _d.Name{Local: "m:nary"}}
		e.EncodeElement(_adgcb.Nary, _gacff)
	}
	if _adgcb.Phant != nil {
		_gcbc := _d.StartElement{Name: _d.Name{Local: "m:phant"}}
		e.EncodeElement(_adgcb.Phant, _gcbc)
	}
	if _adgcb.Rad != nil {
		_bfff := _d.StartElement{Name: _d.Name{Local: "m:rad"}}
		e.EncodeElement(_adgcb.Rad, _bfff)
	}
	if _adgcb.SPre != nil {
		_defb := _d.StartElement{Name: _d.Name{Local: "m:sPre"}}
		e.EncodeElement(_adgcb.SPre, _defb)
	}
	if _adgcb.SSub != nil {
		_eaeae := _d.StartElement{Name: _d.Name{Local: "m:sSub"}}
		e.EncodeElement(_adgcb.SSub, _eaeae)
	}
	if _adgcb.SSubSup != nil {
		_bbab := _d.StartElement{Name: _d.Name{Local: "m:sSubSup"}}
		e.EncodeElement(_adgcb.SSubSup, _bbab)
	}
	if _adgcb.SSup != nil {
		_gbedg := _d.StartElement{Name: _d.Name{Local: "m:sSup"}}
		e.EncodeElement(_adgcb.SSup, _gbedg)
	}
	if _adgcb.R != nil {
		_cgad := _d.StartElement{Name: _d.Name{Local: "m:r"}}
		e.EncodeElement(_adgcb.R, _cgad)
	}
	return nil
}
func NewCT_MC() *CT_MC                     { _gfa := &CT_MC{}; return _gfa }
func NewCT_TwipsMeasure() *CT_TwipsMeasure { _gcccaf := &CT_TwipsMeasure{}; return _gcccaf }

// ValidateWithPath validates the CT_SSubSup and its children, prefixing error messages with path
func (_dfcab *CT_SSubSup) ValidateWithPath(path string) error {
	if _dfcab.SSubSupPr != nil {
		if _aga := _dfcab.SSubSupPr.ValidateWithPath(path + "\u002fSSubSupPr"); _aga != nil {
			return _aga
		}
	}
	if _efff := _dfcab.E.ValidateWithPath(path + "\u002fE"); _efff != nil {
		return _efff
	}
	if _aegg := _dfcab.Sub.ValidateWithPath(path + "\u002fSub"); _aegg != nil {
		return _aegg
	}
	if _dddfc := _dfcab.Sup.ValidateWithPath(path + "\u002fSup"); _dddfc != nil {
		return _dddfc
	}
	return nil
}

type ST_Shp byte

// Validate validates the EG_OMathElements and its children
func (_ffdb *EG_OMathElements) Validate() error { return _ffdb.ValidateWithPath("EG_OMathElements") }

// ValidateWithPath validates the CT_TwipsMeasure and its children, prefixing error messages with path
func (_ffbda *CT_TwipsMeasure) ValidateWithPath(path string) error {
	if _afab := _ffbda.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _afab != nil {
		return _afab
	}
	return nil
}

const (
	ST_ShpUnset    ST_Shp = 0
	ST_ShpCentered ST_Shp = 1
	ST_ShpMatch    ST_Shp = 2
)

func (_gced *CT_Integer255) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_gced.ValAttr = 1
	for _, _eafb := range start.Attr {
		if _eafb.Name.Local == "val" {
			_fbg, _gdea := _a.ParseInt(_eafb.Value, 10, 64)
			if _gdea != nil {
				return _gdea
			}
			_gced.ValAttr = _fbg
			continue
		}
	}
	for {
		_dac, _gdfa := d.Token()
		if _gdfa != nil {
			return _da.Errorf("parsing\u0020CT_Integer255:\u0020\u0025s", _gdfa)
		}
		if _ggfa, _gdeb := _dac.(_d.EndElement); _gdeb && _ggfa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cdd *CT_GroupChr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _cdd.GroupChrPr != nil {
		_adafe := _d.StartElement{Name: _d.Name{Local: "m:groupChrPr"}}
		e.EncodeElement(_cdd.GroupChrPr, _adafe)
	}
	_eecb := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_cdd.E, _eecb)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type CT_SSupPr struct{ CtrlPr *CT_CtrlPr }

func NewCT_SSubPr() *CT_SSubPr { _begd := &CT_SSubPr{}; return _begd }
func (_bbdf *CT_MPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_dcbf:
	for {
		_fgbf, _egae := d.Token()
		if _egae != nil {
			return _egae
		}
		switch _eagf := _fgbf.(type) {
		case _d.StartElement:
			switch _eagf.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "baseJc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "baseJc"}:
				_bbdf.BaseJc = NewCT_YAlign()
				if _cgc := d.DecodeElement(_bbdf.BaseJc, &_eagf); _cgc != nil {
					return _cgc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "plcHide"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "plcHide"}:
				_bbdf.PlcHide = NewCT_OnOff()
				if _gfaf := d.DecodeElement(_bbdf.PlcHide, &_eagf); _gfaf != nil {
					return _gfaf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rSpRule"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rSpRule"}:
				_bbdf.RSpRule = NewCT_SpacingRule()
				if _fdbg := d.DecodeElement(_bbdf.RSpRule, &_eagf); _fdbg != nil {
					return _fdbg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "cGpRule"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "cGpRule"}:
				_bbdf.CGpRule = NewCT_SpacingRule()
				if _acec := d.DecodeElement(_bbdf.CGpRule, &_eagf); _acec != nil {
					return _acec
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rSp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rSp"}:
				_bbdf.RSp = NewCT_UnSignedInteger()
				if _addca := d.DecodeElement(_bbdf.RSp, &_eagf); _addca != nil {
					return _addca
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "cSp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "cSp"}:
				_bbdf.CSp = NewCT_UnSignedInteger()
				if _dage := d.DecodeElement(_bbdf.CSp, &_eagf); _dage != nil {
					return _dage
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "cGp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "cGp"}:
				_bbdf.CGp = NewCT_UnSignedInteger()
				if _ggdd := d.DecodeElement(_bbdf.CGp, &_eagf); _ggdd != nil {
					return _ggdd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "mcs"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "mcs"}:
				_bbdf.Mcs = NewCT_MCS()
				if _gbbf := d.DecodeElement(_bbdf.Mcs, &_eagf); _gbbf != nil {
					return _gbbf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_bbdf.CtrlPr = NewCT_CtrlPr()
				if _bdag := d.DecodeElement(_bbdf.CtrlPr, &_eagf); _bdag != nil {
					return _bdag
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_MPr\u0020\u0025v", _eagf.Name)
				if _adcf := d.Skip(); _adcf != nil {
					return _adcf
				}
			}
		case _d.EndElement:
			break _dcbf
		case _d.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CtrlPr and its children, prefixing error messages with path
func (_fgc *CT_CtrlPr) ValidateWithPath(path string) error { return nil }
func (_ebeda ST_BreakBin) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_bggd := _d.Attr{}
	_bggd.Name = name
	switch _ebeda {
	case ST_BreakBinUnset:
		_bggd.Value = ""
	case ST_BreakBinBefore:
		_bggd.Value = "before"
	case ST_BreakBinAfter:
		_bggd.Value = "after"
	case ST_BreakBinRepeat:
		_bggd.Value = "repeat"
	}
	return _bggd, nil
}

type CT_PhantPr struct {
	Show     *CT_OnOff
	ZeroWid  *CT_OnOff
	ZeroAsc  *CT_OnOff
	ZeroDesc *CT_OnOff
	Transp   *CT_OnOff
	CtrlPr   *CT_CtrlPr
}

func (_cbd *CT_FuncPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _cbd.CtrlPr != nil {
		_fbec := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_cbd.CtrlPr, _fbec)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_ggaed *ST_LimLoc) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_fedff, _bdega := d.Token()
	if _bdega != nil {
		return _bdega
	}
	if _bfce, _cbca := _fedff.(_d.EndElement); _cbca && _bfce.Name == start.Name {
		*_ggaed = 1
		return nil
	}
	if _cgbg, _bfcd := _fedff.(_d.CharData); !_bfcd {
		return _da.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fedff)
	} else {
		switch string(_cgbg) {
		case "":
			*_ggaed = 0
		case "undOvr":
			*_ggaed = 1
		case "subSup":
			*_ggaed = 2
		}
	}
	_fedff, _bdega = d.Token()
	if _bdega != nil {
		return _bdega
	}
	if _ebed, _eecd := _fedff.(_d.EndElement); _eecd && _ebed.Name == start.Name {
		return nil
	}
	return _da.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fedff)
}

// Validate validates the CT_SSub and its children
func (_bgee *CT_SSub) Validate() error { return _bgee.ValidateWithPath("CT_SSub") }

type EG_ScriptStyle struct {
	Scr *CT_Script
	Sty *CT_Style
}

func (_deea *CT_OMath) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_gdaa:
	for {
		_abcf, _cgbe := d.Token()
		if _cgbe != nil {
			return _cgbe
		}
		switch _faagc := _abcf.(type) {
		case _d.StartElement:
			switch _faagc.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "acc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "acc"}:
				_gcafa := NewEG_OMathMathElements()
				_gcafa.Acc = NewCT_Acc()
				if _eefa := d.DecodeElement(_gcafa.Acc, &_faagc); _eefa != nil {
					return _eefa
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _gcafa)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "bar"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "bar"}:
				_faab := NewEG_OMathMathElements()
				_faab.Bar = NewCT_Bar()
				if _bac := d.DecodeElement(_faab.Bar, &_faagc); _bac != nil {
					return _bac
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _faab)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "box"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "box"}:
				_fdae := NewEG_OMathMathElements()
				_fdae.Box = NewCT_Box()
				if _abdbb := d.DecodeElement(_fdae.Box, &_faagc); _abdbb != nil {
					return _abdbb
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _fdae)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "borderBox"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "borderBox"}:
				_fadg := NewEG_OMathMathElements()
				_fadg.BorderBox = NewCT_BorderBox()
				if _gabe := d.DecodeElement(_fadg.BorderBox, &_faagc); _gabe != nil {
					return _gabe
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _fadg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "d"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "d"}:
				_bgfg := NewEG_OMathMathElements()
				_bgfg.D = NewCT_D()
				if _eagc := d.DecodeElement(_bgfg.D, &_faagc); _eagc != nil {
					return _eagc
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _bgfg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "eqArr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "eqArr"}:
				_aba := NewEG_OMathMathElements()
				_aba.EqArr = NewCT_EqArr()
				if _bfgb := d.DecodeElement(_aba.EqArr, &_faagc); _bfgb != nil {
					return _bfgb
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _aba)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "f"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "f"}:
				_ccde := NewEG_OMathMathElements()
				_ccde.F = NewCT_F()
				if _ccff := d.DecodeElement(_ccde.F, &_faagc); _ccff != nil {
					return _ccff
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _ccde)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "func"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "func"}:
				_aggc := NewEG_OMathMathElements()
				_aggc.Func = NewCT_Func()
				if _dbfc := d.DecodeElement(_aggc.Func, &_faagc); _dbfc != nil {
					return _dbfc
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _aggc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "groupChr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "groupChr"}:
				_dbeba := NewEG_OMathMathElements()
				_dbeba.GroupChr = NewCT_GroupChr()
				if _egda := d.DecodeElement(_dbeba.GroupChr, &_faagc); _egda != nil {
					return _egda
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _dbeba)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limLow"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limLow"}:
				_cec := NewEG_OMathMathElements()
				_cec.LimLow = NewCT_LimLow()
				if _cdcd := d.DecodeElement(_cec.LimLow, &_faagc); _cdcd != nil {
					return _cdcd
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _cec)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limUpp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limUpp"}:
				_bdbg := NewEG_OMathMathElements()
				_bdbg.LimUpp = NewCT_LimUpp()
				if _fgdcf := d.DecodeElement(_bdbg.LimUpp, &_faagc); _fgdcf != nil {
					return _fgdcf
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _bdbg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "m"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "m"}:
				_bff := NewEG_OMathMathElements()
				_bff.M = NewCT_M()
				if _abcbb := d.DecodeElement(_bff.M, &_faagc); _abcbb != nil {
					return _abcbb
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _bff)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "nary"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "nary"}:
				_ggddc := NewEG_OMathMathElements()
				_ggddc.Nary = NewCT_Nary()
				if _cdcb := d.DecodeElement(_ggddc.Nary, &_faagc); _cdcb != nil {
					return _cdcb
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _ggddc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "phant"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "phant"}:
				_cbgf := NewEG_OMathMathElements()
				_cbgf.Phant = NewCT_Phant()
				if _eabb := d.DecodeElement(_cbgf.Phant, &_faagc); _eabb != nil {
					return _eabb
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _cbgf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rad"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rad"}:
				_dfdg := NewEG_OMathMathElements()
				_dfdg.Rad = NewCT_Rad()
				if _bgad := d.DecodeElement(_dfdg.Rad, &_faagc); _bgad != nil {
					return _bgad
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _dfdg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sPre"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sPre"}:
				_ebeg := NewEG_OMathMathElements()
				_ebeg.SPre = NewCT_SPre()
				if _daab := d.DecodeElement(_ebeg.SPre, &_faagc); _daab != nil {
					return _daab
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _ebeg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSub"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSub"}:
				_dfaa := NewEG_OMathMathElements()
				_dfaa.SSub = NewCT_SSub()
				if _baggg := d.DecodeElement(_dfaa.SSub, &_faagc); _baggg != nil {
					return _baggg
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _dfaa)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSubSup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSubSup"}:
				_egdg := NewEG_OMathMathElements()
				_egdg.SSubSup = NewCT_SSubSup()
				if _bcae := d.DecodeElement(_egdg.SSubSup, &_faagc); _bcae != nil {
					return _bcae
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _egdg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSup"}:
				_ffefe := NewEG_OMathMathElements()
				_ffefe.SSup = NewCT_SSup()
				if _abac := d.DecodeElement(_ffefe.SSup, &_faagc); _abac != nil {
					return _abac
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _ffefe)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "r"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "r"}:
				_fcba := NewEG_OMathMathElements()
				_fcba.R = NewCT_R()
				if _gdgd := d.DecodeElement(_fcba.R, &_faagc); _gdgd != nil {
					return _gdgd
				}
				_deea.EG_OMathMathElements = append(_deea.EG_OMathMathElements, _fcba)
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OMath\u0020\u0025v", _faagc.Name)
				if _gdfb := d.Skip(); _gdfb != nil {
					return _gdfb
				}
			}
		case _d.EndElement:
			break _gdaa
		case _d.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_D and its children, prefixing error messages with path
func (_feb *CT_D) ValidateWithPath(path string) error {
	if _feb.DPr != nil {
		if _cef := _feb.DPr.ValidateWithPath(path + "\u002fDPr"); _cef != nil {
			return _cef
		}
	}
	for _adc, _ggd := range _feb.E {
		if _faee := _ggd.ValidateWithPath(_da.Sprintf("\u0025s\u002fE\u005b\u0025d\u005d", path, _adc)); _faee != nil {
			return _faee
		}
	}
	return nil
}

type ST_TopBot byte
type CT_AccPr struct {
	Chr    *CT_Char
	CtrlPr *CT_CtrlPr
}

func (_bdb *CT_M) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _bdb.MPr != nil {
		_caba := _d.StartElement{Name: _d.Name{Local: "m:mPr"}}
		e.EncodeElement(_bdb.MPr, _caba)
	}
	_fdba := _d.StartElement{Name: _d.Name{Local: "m:mr"}}
	for _, _gdb := range _bdb.Mr {
		e.EncodeElement(_gdb, _fdba)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_gdd *CT_F) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_gdd.Num = NewCT_OMathArg()
	_gdd.Den = NewCT_OMathArg()
_gef:
	for {
		_bfa, _eegd := d.Token()
		if _eegd != nil {
			return _eegd
		}
		switch _fdf := _bfa.(type) {
		case _d.StartElement:
			switch _fdf.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "fPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "fPr"}:
				_gdd.FPr = NewCT_FPr()
				if _ggda := d.DecodeElement(_gdd.FPr, &_fdf); _ggda != nil {
					return _ggda
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "num"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "num"}:
				if _cgf := d.DecodeElement(_gdd.Num, &_fdf); _cgf != nil {
					return _cgf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "den"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "den"}:
				if _cde := d.DecodeElement(_gdd.Den, &_fdf); _cde != nil {
					return _cde
				}
			default:
				_e.Log("skipping\u0020unsupported element\u0020on\u0020CT_F\u0020\u0025v", _fdf.Name)
				if _eeeeb := d.Skip(); _eeeeb != nil {
					return _eeeeb
				}
			}
		case _d.EndElement:
			break _gef
		case _d.CharData:
		}
	}
	return nil
}
func (_edge *CT_R) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_ggdab:
	for {
		_gfef, _dcdbg := d.Token()
		if _dcdbg != nil {
			return _dcdbg
		}
		switch _ddda := _gfef.(type) {
		case _d.StartElement:
			switch _ddda.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rPr"}:
				_edge.RPr = NewCT_RPR()
				if _dbcba := d.DecodeElement(_edge.RPr, &_ddda); _dbcba != nil {
					return _dbcba
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "t"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "t"}:
				_afad := NewCT_RChoice()
				if _fafc := d.DecodeElement(&_afad.T, &_ddda); _fafc != nil {
					return _fafc
				}
				_edge.Choice = append(_edge.Choice, _afad)
			default:
				_e.Log("skipping\u0020unsupported element\u0020on\u0020CT_R\u0020\u0025v", _ddda.Name)
				if _gfbb := d.Skip(); _gfbb != nil {
					return _gfbb
				}
			}
		case _d.EndElement:
			break _ggdab
		case _d.CharData:
		}
	}
	return nil
}

type CT_OMathArgPr struct{ ArgSz *CT_Integer2 }

// ValidateWithPath validates the CT_BorderBox and its children, prefixing error messages with path
func (_bbd *CT_BorderBox) ValidateWithPath(path string) error {
	if _bbd.BorderBoxPr != nil {
		if _bge := _bbd.BorderBoxPr.ValidateWithPath(path + "\u002fBorderBoxPr"); _bge != nil {
			return _bge
		}
	}
	if _bf := _bbd.E.ValidateWithPath(path + "\u002fE"); _bf != nil {
		return _bf
	}
	return nil
}

const (
	ST_TopBotUnset ST_TopBot = 0
	ST_TopBotTop   ST_TopBot = 1
	ST_TopBotBot   ST_TopBot = 2
)

// ValidateWithPath validates the CT_Shp and its children, prefixing error messages with path
func (_ggfaa *CT_Shp) ValidateWithPath(path string) error {
	if _ggfaa.ValAttr == ST_ShpUnset {
		return _da.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bcag := _ggfaa.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bcag != nil {
		return _bcag
	}
	return nil
}

// Validate validates the CT_Bar and its children
func (_dd *CT_Bar) Validate() error { return _dd.ValidateWithPath("CT_Bar") }

// ValidateWithPath validates the CT_AccPr and its children, prefixing error messages with path
func (_ccb *CT_AccPr) ValidateWithPath(path string) error {
	if _ccb.Chr != nil {
		if _eaf := _ccb.Chr.ValidateWithPath(path + "\u002fChr"); _eaf != nil {
			return _eaf
		}
	}
	if _ccb.CtrlPr != nil {
		if _bd := _ccb.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _bd != nil {
			return _bd
		}
	}
	return nil
}

// ValidateWithPath validates the CT_M and its children, prefixing error messages with path
func (_adfge *CT_M) ValidateWithPath(path string) error {
	if _adfge.MPr != nil {
		if _ded := _adfge.MPr.ValidateWithPath(path + "\u002fMPr"); _ded != nil {
			return _ded
		}
	}
	for _dcbd, _cbg := range _adfge.Mr {
		if _ggca := _cbg.ValidateWithPath(_da.Sprintf("\u0025s\u002fMr\u005b\u0025d]", path, _dcbd)); _ggca != nil {
			return _ggca
		}
	}
	return nil
}

type CT_LimLowPr struct{ CtrlPr *CT_CtrlPr }
type CT_MCPr struct {
	Count *CT_Integer255
	McJc  *CT_XAlign
}

func (_edfdd *CT_SPre) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _edfdd.SPrePr != nil {
		_cccc := _d.StartElement{Name: _d.Name{Local: "m:sPrePr"}}
		e.EncodeElement(_edfdd.SPrePr, _cccc)
	}
	_gdbd := _d.StartElement{Name: _d.Name{Local: "m:sub"}}
	e.EncodeElement(_edfdd.Sub, _gdbd)
	_ebfg := _d.StartElement{Name: _d.Name{Local: "m:sup"}}
	e.EncodeElement(_edfdd.Sup, _ebfg)
	_efeb := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_edfdd.E, _efeb)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_dgfg ST_LimLoc) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_dgba := _d.Attr{}
	_dgba.Name = name
	switch _dgfg {
	case ST_LimLocUnset:
		_dgba.Value = ""
	case ST_LimLocUndOvr:
		_dgba.Value = "undOvr"
	case ST_LimLocSubSup:
		_dgba.Value = "subSup"
	}
	return _dgba, nil
}
func (_fddbd *EG_OMathElements) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_ebged:
	for {
		_gbef, _ffba := d.Token()
		if _ffba != nil {
			return _ffba
		}
		switch _aedfc := _gbef.(type) {
		case _d.StartElement:
			switch _aedfc.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "acc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "acc"}:
				_gdgdg := NewEG_OMathMathElements()
				_gdgdg.Acc = NewCT_Acc()
				if _fbaae := d.DecodeElement(_gdgdg.Acc, &_aedfc); _fbaae != nil {
					return _fbaae
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _gdgdg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "bar"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "bar"}:
				_agcg := NewEG_OMathMathElements()
				_agcg.Bar = NewCT_Bar()
				if _fadc := d.DecodeElement(_agcg.Bar, &_aedfc); _fadc != nil {
					return _fadc
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _agcg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "box"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "box"}:
				_deaga := NewEG_OMathMathElements()
				_deaga.Box = NewCT_Box()
				if _egaec := d.DecodeElement(_deaga.Box, &_aedfc); _egaec != nil {
					return _egaec
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _deaga)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "borderBox"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "borderBox"}:
				_fcdbf := NewEG_OMathMathElements()
				_fcdbf.BorderBox = NewCT_BorderBox()
				if _cead := d.DecodeElement(_fcdbf.BorderBox, &_aedfc); _cead != nil {
					return _cead
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _fcdbf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "d"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "d"}:
				_ebdce := NewEG_OMathMathElements()
				_ebdce.D = NewCT_D()
				if _bffg := d.DecodeElement(_ebdce.D, &_aedfc); _bffg != nil {
					return _bffg
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _ebdce)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "eqArr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "eqArr"}:
				_dcbbb := NewEG_OMathMathElements()
				_dcbbb.EqArr = NewCT_EqArr()
				if _aafda := d.DecodeElement(_dcbbb.EqArr, &_aedfc); _aafda != nil {
					return _aafda
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _dcbbb)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "f"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "f"}:
				_ceeg := NewEG_OMathMathElements()
				_ceeg.F = NewCT_F()
				if _gbbg := d.DecodeElement(_ceeg.F, &_aedfc); _gbbg != nil {
					return _gbbg
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _ceeg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "func"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "func"}:
				_bfcc := NewEG_OMathMathElements()
				_bfcc.Func = NewCT_Func()
				if _gfba := d.DecodeElement(_bfcc.Func, &_aedfc); _gfba != nil {
					return _gfba
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _bfcc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "groupChr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "groupChr"}:
				_cgbcf := NewEG_OMathMathElements()
				_cgbcf.GroupChr = NewCT_GroupChr()
				if _dgag := d.DecodeElement(_cgbcf.GroupChr, &_aedfc); _dgag != nil {
					return _dgag
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _cgbcf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limLow"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limLow"}:
				_cdcdg := NewEG_OMathMathElements()
				_cdcdg.LimLow = NewCT_LimLow()
				if _ggdb := d.DecodeElement(_cdcdg.LimLow, &_aedfc); _ggdb != nil {
					return _ggdb
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _cdcdg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limUpp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limUpp"}:
				_ebgca := NewEG_OMathMathElements()
				_ebgca.LimUpp = NewCT_LimUpp()
				if _gfee := d.DecodeElement(_ebgca.LimUpp, &_aedfc); _gfee != nil {
					return _gfee
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _ebgca)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "m"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "m"}:
				_cgcfg := NewEG_OMathMathElements()
				_cgcfg.M = NewCT_M()
				if _fgeee := d.DecodeElement(_cgcfg.M, &_aedfc); _fgeee != nil {
					return _fgeee
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _cgcfg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "nary"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "nary"}:
				_cecg := NewEG_OMathMathElements()
				_cecg.Nary = NewCT_Nary()
				if _ebdgb := d.DecodeElement(_cecg.Nary, &_aedfc); _ebdgb != nil {
					return _ebdgb
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _cecg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "phant"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "phant"}:
				_fddf := NewEG_OMathMathElements()
				_fddf.Phant = NewCT_Phant()
				if _eeeac := d.DecodeElement(_fddf.Phant, &_aedfc); _eeeac != nil {
					return _eeeac
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _fddf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rad"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rad"}:
				_gbfeaa := NewEG_OMathMathElements()
				_gbfeaa.Rad = NewCT_Rad()
				if _bdeg := d.DecodeElement(_gbfeaa.Rad, &_aedfc); _bdeg != nil {
					return _bdeg
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _gbfeaa)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sPre"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sPre"}:
				_fggf := NewEG_OMathMathElements()
				_fggf.SPre = NewCT_SPre()
				if _egdb := d.DecodeElement(_fggf.SPre, &_aedfc); _egdb != nil {
					return _egdb
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _fggf)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSub"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSub"}:
				_ddcb := NewEG_OMathMathElements()
				_ddcb.SSub = NewCT_SSub()
				if _ggae := d.DecodeElement(_ddcb.SSub, &_aedfc); _ggae != nil {
					return _ggae
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _ddcb)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSubSup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSubSup"}:
				_gfdc := NewEG_OMathMathElements()
				_gfdc.SSubSup = NewCT_SSubSup()
				if _ggge := d.DecodeElement(_gfdc.SSubSup, &_aedfc); _ggge != nil {
					return _ggge
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _gfdc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSup"}:
				_baafg := NewEG_OMathMathElements()
				_baafg.SSup = NewCT_SSup()
				if _cgg := d.DecodeElement(_baafg.SSup, &_aedfc); _cgg != nil {
					return _cgg
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _baafg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "r"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "r"}:
				_cdda := NewEG_OMathMathElements()
				_cdda.R = NewCT_R()
				if _gcac := d.DecodeElement(_cdda.R, &_aedfc); _gcac != nil {
					return _gcac
				}
				_fddbd.EG_OMathMathElements = append(_fddbd.EG_OMathMathElements, _cdda)
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_OMathElements\u0020\u0025v", _aedfc.Name)
				if _ebfa := d.Skip(); _ebfa != nil {
					return _ebfa
				}
			}
		case _d.EndElement:
			break _ebged
		case _d.CharData:
		}
	}
	return nil
}
func (_abefc ST_Shp) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_cdge := _d.Attr{}
	_cdge.Name = name
	switch _abefc {
	case ST_ShpUnset:
		_cdge.Value = ""
	case ST_ShpCentered:
		_cdge.Value = "centered"
	case ST_ShpMatch:
		_cdge.Value = "match"
	}
	return _cdge, nil
}

// ValidateWithPath validates the CT_GroupChrPr and its children, prefixing error messages with path
func (_aea *CT_GroupChrPr) ValidateWithPath(path string) error {
	if _aea.Chr != nil {
		if _bbggf := _aea.Chr.ValidateWithPath(path + "\u002fChr"); _bbggf != nil {
			return _bbggf
		}
	}
	if _aea.Pos != nil {
		if _gcccc := _aea.Pos.ValidateWithPath(path + "\u002fPos"); _gcccc != nil {
			return _gcccc
		}
	}
	if _aea.VertJc != nil {
		if _dfb := _aea.VertJc.ValidateWithPath(path + "\u002fVertJc"); _dfb != nil {
			return _dfb
		}
	}
	if _aea.CtrlPr != nil {
		if _aadf := _aea.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _aadf != nil {
			return _aadf
		}
	}
	return nil
}
func (_adffb ST_FType) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_gegc := _d.Attr{}
	_gegc.Name = name
	switch _adffb {
	case ST_FTypeUnset:
		_gegc.Value = ""
	case ST_FTypeBar:
		_gegc.Value = "bar"
	case ST_FTypeSkw:
		_gegc.Value = "skw"
	case ST_FTypeLin:
		_gegc.Value = "lin"
	case ST_FTypeNoBar:
		_gegc.Value = "noBar"
	}
	return _gegc, nil
}

type CT_Box struct {
	BoxPr *CT_BoxPr
	E     *CT_OMathArg
}

func (_ead *CT_BorderBox) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _ead.BorderBoxPr != nil {
		_bcb := _d.StartElement{Name: _d.Name{Local: "m:borderBoxPr"}}
		e.EncodeElement(_ead.BorderBoxPr, _bcb)
	}
	_eee := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_ead.E, _eee)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type ST_Jc byte

// Validate validates the CT_Shp and its children
func (_cge *CT_Shp) Validate() error { return _cge.ValidateWithPath("CT_Shp") }

// ValidateWithPath validates the CT_LimUppPr and its children, prefixing error messages with path
func (_bfcg *CT_LimUppPr) ValidateWithPath(path string) error {
	if _bfcg.CtrlPr != nil {
		if _fcee := _bfcg.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _fcee != nil {
			return _fcee
		}
	}
	return nil
}

type CT_Acc struct {
	AccPr *CT_AccPr
	E     *CT_OMathArg
}

const (
	ST_FTypeUnset ST_FType = 0
	ST_FTypeBar   ST_FType = 1
	ST_FTypeSkw   ST_FType = 2
	ST_FTypeLin   ST_FType = 3
	ST_FTypeNoBar ST_FType = 4
)

func NewCT_TopBot() *CT_TopBot { _efgf := &CT_TopBot{}; _efgf.ValAttr = ST_TopBot(1); return _efgf }

// ValidateWithPath validates the CT_RPR and its children, prefixing error messages with path
func (_cege *CT_RPR) ValidateWithPath(path string) error {
	if _cege.Lit != nil {
		if _egbfc := _cege.Lit.ValidateWithPath(path + "\u002fLit"); _egbfc != nil {
			return _egbfc
		}
	}
	if _cege.Choice != nil {
		if _aggfc := _cege.Choice.ValidateWithPath(path + "\u002fChoice"); _aggfc != nil {
			return _aggfc
		}
	}
	if _cege.Brk != nil {
		if _bdagc := _cege.Brk.ValidateWithPath(path + "\u002fBrk"); _bdagc != nil {
			return _bdagc
		}
	}
	if _cege.Aln != nil {
		if _abfe := _cege.Aln.ValidateWithPath(path + "\u002fAln"); _abfe != nil {
			return _abfe
		}
	}
	return nil
}

// Validate validates the EG_OMathMathElements and its children
func (_ddeg *EG_OMathMathElements) Validate() error {
	return _ddeg.ValidateWithPath("EG_OMathMathElements")
}

// Validate validates the CT_SSupPr and its children
func (_daef *CT_SSupPr) Validate() error { return _daef.ValidateWithPath("CT_SSupPr") }

// Validate validates the CT_MCS and its children
func (_egcef *CT_MCS) Validate() error { return _egcef.ValidateWithPath("CT_MCS") }
func (_dbce *OMathPara) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:m"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:w"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fwordprocessingml\u002f2006\u002fmain"})
//	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "m:oMathPara"
	return _dbce.CT_OMathPara.MarshalXML(e, start)
}
func NewCT_D() *CT_D { _eefb := &CT_D{}; return _eefb }

type CT_SSubSupPr struct {
	AlnScr *CT_OnOff
	CtrlPr *CT_CtrlPr
}
type CT_RPRChoice struct{ Nor *CT_OnOff }

// ValidateWithPath validates the CT_UnSignedInteger and its children, prefixing error messages with path
func (_aedc *CT_UnSignedInteger) ValidateWithPath(path string) error { return nil }
func (_g *CT_Acc) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _g.AccPr != nil {
		_ad := _d.StartElement{Name: _d.Name{Local: "m:accPr"}}
		e.EncodeElement(_g.AccPr, _ad)
	}
	_db := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_g.E, _db)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SSubSup and its children
func (_fed *CT_SSubSup) Validate() error { return _fed.ValidateWithPath("CT_SSubSup") }

// ValidateWithPath validates the CT_LimLow and its children, prefixing error messages with path
func (_fad *CT_LimLow) ValidateWithPath(path string) error {
	if _fad.LimLowPr != nil {
		if _faag := _fad.LimLowPr.ValidateWithPath(path + "\u002fLimLowPr"); _faag != nil {
			return _faag
		}
	}
	if _dbf := _fad.E.ValidateWithPath(path + "\u002fE"); _dbf != nil {
		return _dbf
	}
	if _abgc := _fad.Lim.ValidateWithPath(path + "\u002fLim"); _abgc != nil {
		return _abgc
	}
	return nil
}

type CT_String struct{ ValAttr *string }

func (_dbeb *CT_ManualBreak) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _ddgc := range start.Attr {
		if _ddgc.Name.Local == "alnAt" {
			_cfae, _ffeb := _a.ParseInt(_ddgc.Value, 10, 64)
			if _ffeb != nil {
				return _ffeb
			}
			_dbeb.AlnAtAttr = &_cfae
			continue
		}
	}
	for {
		_cdea, _gdcca := d.Token()
		if _gdcca != nil {
			return _da.Errorf("parsing\u0020CT_ManualBreak:\u0020\u0025s", _gdcca)
		}
		if _cbdeb, _dfbd := _cdea.(_d.EndElement); _dfbd && _cbdeb.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Box and its children, prefixing error messages with path
func (_eeef *CT_Box) ValidateWithPath(path string) error {
	if _eeef.BoxPr != nil {
		if _caf := _eeef.BoxPr.ValidateWithPath(path + "\u002fBoxPr"); _caf != nil {
			return _caf
		}
	}
	if _bgf := _eeef.E.ValidateWithPath(path + "\u002fE"); _bgf != nil {
		return _bgf
	}
	return nil
}

// ValidateWithPath validates the CT_LimUpp and its children, prefixing error messages with path
func (_cafa *CT_LimUpp) ValidateWithPath(path string) error {
	if _cafa.LimUppPr != nil {
		if _ccgd := _cafa.LimUppPr.ValidateWithPath(path + "\u002fLimUppPr"); _ccgd != nil {
			return _ccgd
		}
	}
	if _dec := _cafa.E.ValidateWithPath(path + "\u002fE"); _dec != nil {
		return _dec
	}
	if _cae := _cafa.Lim.ValidateWithPath(path + "\u002fLim"); _cae != nil {
		return _cae
	}
	return nil
}

// ValidateWithPath validates the CT_LimLowPr and its children, prefixing error messages with path
func (_dabc *CT_LimLowPr) ValidateWithPath(path string) error {
	if _dabc.CtrlPr != nil {
		if _ebgg := _dabc.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _ebgg != nil {
			return _ebgg
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Integer255 and its children, prefixing error messages with path
func (_fgcf *CT_Integer255) ValidateWithPath(path string) error {
	if _fgcf.ValAttr < 1 {
		return _da.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00201\u0020\u0028have\u0020\u0025v\u0029", path, _fgcf.ValAttr)
	}
	if _fgcf.ValAttr > 255 {
		return _da.Errorf("\u0025s/m\u002eValAttr\u0020must\u0020be\u0020\u003c\u003d\u0020255\u0020\u0028have\u0020\u0025v\u0029", path, _fgcf.ValAttr)
	}
	return nil
}

type CT_D struct {
	DPr *CT_DPr
	E   []*CT_OMathArg
}

// ValidateWithPath validates the CT_OMathParaPr and its children, prefixing error messages with path
func (_cdcbc *CT_OMathParaPr) ValidateWithPath(path string) error {
	if _cdcbc.Jc != nil {
		if _degd := _cdcbc.Jc.ValidateWithPath(path + "\u002fJc"); _degd != nil {
			return _degd
		}
	}
	return nil
}
func (_fadd *ST_BreakBinSub) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_fadd = 0
	case "\u002d\u002d":
		*_fadd = 1
	case "\u002d\u002b":
		*_fadd = 2
	case "\u002b\u002d":
		*_fadd = 3
	}
	return nil
}
func (_gdge *CT_Rad) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_gdge.Deg = NewCT_OMathArg()
	_gdge.E = NewCT_OMathArg()
_acef:
	for {
		_fdbgf, _bcaee := d.Token()
		if _bcaee != nil {
			return _bcaee
		}
		switch _gaee := _fdbgf.(type) {
		case _d.StartElement:
			switch _gaee.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "radPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "radPr"}:
				_gdge.RadPr = NewCT_RadPr()
				if _fadgg := d.DecodeElement(_gdge.RadPr, &_gaee); _fadgg != nil {
					return _fadgg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "deg"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "deg"}:
				if _efe := d.DecodeElement(_gdge.Deg, &_gaee); _efe != nil {
					return _efe
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _efbb := d.DecodeElement(_gdge.E, &_gaee); _efbb != nil {
					return _efbb
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Rad\u0020\u0025v", _gaee.Name)
				if _eegc := d.Skip(); _eegc != nil {
					return _eegc
				}
			}
		case _d.EndElement:
			break _acef
		case _d.CharData:
		}
	}
	return nil
}
func (_ef *CT_Bar) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ef.E = NewCT_OMathArg()
_fd:
	for {
		_fgd, _eg := d.Token()
		if _eg != nil {
			return _eg
		}
		switch _df := _fgd.(type) {
		case _d.StartElement:
			switch _df.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "barPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "barPr"}:
				_ef.BarPr = NewCT_BarPr()
				if _egf := d.DecodeElement(_ef.BarPr, &_df); _egf != nil {
					return _egf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				if _eafd := d.DecodeElement(_ef.E, &_df); _eafd != nil {
					return _eafd
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Bar\u0020\u0025v", _df.Name)
				if _fba := d.Skip(); _fba != nil {
					return _fba
				}
			}
		case _d.EndElement:
			break _fd
		case _d.CharData:
		}
	}
	return nil
}

// Validate validates the CT_YAlign and its children
func (_adbe *CT_YAlign) Validate() error { return _adbe.ValidateWithPath("CT_YAlign") }
func (_bfb *CT_BreakBin) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _beed := range start.Attr {
		if _beed.Name.Local == "val" {
			_bfb.ValAttr.UnmarshalXMLAttr(_beed)
			continue
		}
	}
	for {
		_gdc, _gbg := d.Token()
		if _gbg != nil {
			return _da.Errorf("parsing\u0020CT_BreakBin:\u0020\u0025s", _gbg)
		}
		if _bafa, _ab := _gdc.(_d.EndElement); _ab && _bafa.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Nary and its children, prefixing error messages with path
func (_abcb *CT_Nary) ValidateWithPath(path string) error {
	if _abcb.NaryPr != nil {
		if _bbcc := _abcb.NaryPr.ValidateWithPath(path + "\u002fNaryPr"); _bbcc != nil {
			return _bbcc
		}
	}
	if _gfge := _abcb.Sub.ValidateWithPath(path + "\u002fSub"); _gfge != nil {
		return _gfge
	}
	if _efae := _abcb.Sup.ValidateWithPath(path + "\u002fSup"); _efae != nil {
		return _efae
	}
	if _aaaf := _abcb.E.ValidateWithPath(path + "\u002fE"); _aaaf != nil {
		return _aaaf
	}
	return nil
}

// Validate validates the CT_SPre and its children
func (_ecd *CT_SPre) Validate() error { return _ecd.ValidateWithPath("CT_SPre") }
func NewCT_OMathJc() *CT_OMathJc      { _eagef := &CT_OMathJc{}; return _eagef }

// Validate validates the CT_Rad and its children
func (_bceb *CT_Rad) Validate() error { return _bceb.ValidateWithPath("CT_Rad") }
func NewCT_Rad() *CT_Rad {
	_gbeb := &CT_Rad{}
	_gbeb.Deg = NewCT_OMathArg()
	_gbeb.E = NewCT_OMathArg()
	return _gbeb
}
func NewCT_String() *CT_String   { _bgdg := &CT_String{}; return _bgdg }
func NewCT_EqArrPr() *CT_EqArrPr { _cfcf := &CT_EqArrPr{}; return _cfcf }
func (_efeg *CT_Style) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _acaf := range start.Attr {
		if _acaf.Name.Local == "val" {
			_efeg.ValAttr.UnmarshalXMLAttr(_acaf)
			continue
		}
	}
	for {
		_fddb, _dgdd := d.Token()
		if _dgdd != nil {
			return _da.Errorf("parsing\u0020CT_Style: \u0025s", _dgdd)
		}
		if _bcagb, _gefb := _fddb.(_d.EndElement); _gefb && _bcagb.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_MathPr() *CT_MathPr { _abeg := &CT_MathPr{}; return _abeg }
func (_fgdc *CT_MR) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	_badg := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	for _, _cgcf := range _fgdc.E {
		e.EncodeElement(_cgcf, _badg)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_ggaa *CT_YAlign) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	_bbfe, _fcea := _ggaa.ValAttr.MarshalXMLAttr(_d.Name{Local: "m:val"})
	if _fcea != nil {
		return _fcea
	}
	start.Attr = append(start.Attr, _bbfe)
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewCT_GroupChr() *CT_GroupChr { _eage := &CT_GroupChr{}; _eage.E = NewCT_OMathArg(); return _eage }
func (_gdec *CT_LimLoc) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_gdec.ValAttr = ST_LimLoc(1)
	for _, _bfbe := range start.Attr {
		if _bfbe.Name.Local == "val" {
			_gdec.ValAttr.UnmarshalXMLAttr(_bfbe)
			continue
		}
	}
	for {
		_dbag, _aeee := d.Token()
		if _aeee != nil {
			return _da.Errorf("parsing\u0020CT_LimLoc:\u0020\u0025s", _aeee)
		}
		if _dcac, _ace := _dbag.(_d.EndElement); _ace && _dcac.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ddaf *CT_Integer2) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ddaf.ValAttr = -2
	for _, _gefe := range start.Attr {
		if _gefe.Name.Local == "val" {
			_egce, _gcgf := _a.ParseInt(_gefe.Value, 10, 64)
			if _gcgf != nil {
				return _gcgf
			}
			_ddaf.ValAttr = _egce
			continue
		}
	}
	for {
		_gaa, _affc := d.Token()
		if _affc != nil {
			return _da.Errorf("parsing\u0020CT_Integer2:\u0020\u0025s", _affc)
		}
		if _gaae, _dcbcd := _gaa.(_d.EndElement); _dcbcd && _gaae.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_FPr and its children
func (_aefe *CT_FPr) Validate() error { return _aefe.ValidateWithPath("CT_FPr") }

// Validate validates the OMath and its children
func (_gcef *OMath) Validate() error { return _gcef.ValidateWithPath("OMath") }
func (_ceea ST_Jc) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_ceea.String(), start)
}
func NewCT_OMathArg() *CT_OMathArg { _adgd := &CT_OMathArg{}; return _adgd }
func NewOMath() *OMath             { _ebdgf := &OMath{}; _ebdgf.CT_OMath = *NewCT_OMath(); return _ebdgf }

// Validate validates the CT_BorderBoxPr and its children
func (_ffg *CT_BorderBoxPr) Validate() error { return _ffg.ValidateWithPath("CT_BorderBoxPr") }
func (_ece *CT_GroupChrPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_fdff:
	for {
		_fcc, _ega := d.Token()
		if _ega != nil {
			return _ega
		}
		switch _ecac := _fcc.(type) {
		case _d.StartElement:
			switch _ecac.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "chr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "chr"}:
				_ece.Chr = NewCT_Char()
				if _aggf := d.DecodeElement(_ece.Chr, &_ecac); _aggf != nil {
					return _aggf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "pos"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "pos"}:
				_ece.Pos = NewCT_TopBot()
				if _egeec := d.DecodeElement(_ece.Pos, &_ecac); _egeec != nil {
					return _egeec
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "vertJc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "vertJc"}:
				_ece.VertJc = NewCT_TopBot()
				if _afb := d.DecodeElement(_ece.VertJc, &_ecac); _afb != nil {
					return _afb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_ece.CtrlPr = NewCT_CtrlPr()
				if _eeea := d.DecodeElement(_ece.CtrlPr, &_ecac); _eeea != nil {
					return _eeea
				}
			default:
				_e.Log("skipping unsupported element\u0020on\u0020CT_GroupChrPr \u0025v", _ecac.Name)
				if _bdca := d.Skip(); _bdca != nil {
					return _bdca
				}
			}
		case _d.EndElement:
			break _fdff
		case _d.CharData:
		}
	}
	return nil
}
func NewCT_RPRChoice() *CT_RPRChoice { _ebbd := &CT_RPRChoice{}; return _ebbd }

// Validate validates the CT_SSubPr and its children
func (_bedfb *CT_SSubPr) Validate() error { return _bedfb.ValidateWithPath("CT_SSubPr") }

type CT_UnSignedInteger struct{ ValAttr uint32 }

func (_addf *CT_MCPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _addf.Count != nil {
		_ffd := _d.StartElement{Name: _d.Name{Local: "m:count"}}
		e.EncodeElement(_addf.Count, _ffd)
	}
	if _addf.McJc != nil {
		_egbd := _d.StartElement{Name: _d.Name{Local: "m:mcJc"}}
		e.EncodeElement(_addf.McJc, _egbd)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_LimLow and its children
func (_fda *CT_LimLow) Validate() error { return _fda.ValidateWithPath("CT_LimLow") }

type CT_EqArr struct {
	EqArrPr *CT_EqArrPr
	E       []*CT_OMathArg
}

func (_dee *CT_MPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _dee.BaseJc != nil {
		_bcd := _d.StartElement{Name: _d.Name{Local: "m:baseJc"}}
		e.EncodeElement(_dee.BaseJc, _bcd)
	}
	if _dee.PlcHide != nil {
		_aacde := _d.StartElement{Name: _d.Name{Local: "m:plcHide"}}
		e.EncodeElement(_dee.PlcHide, _aacde)
	}
	if _dee.RSpRule != nil {
		_faeed := _d.StartElement{Name: _d.Name{Local: "m:rSpRule"}}
		e.EncodeElement(_dee.RSpRule, _faeed)
	}
	if _dee.CGpRule != nil {
		_fafa := _d.StartElement{Name: _d.Name{Local: "m:cGpRule"}}
		e.EncodeElement(_dee.CGpRule, _fafa)
	}
	if _dee.RSp != nil {
		_gafb := _d.StartElement{Name: _d.Name{Local: "m:rSp"}}
		e.EncodeElement(_dee.RSp, _gafb)
	}
	if _dee.CSp != nil {
		_agd := _d.StartElement{Name: _d.Name{Local: "m:cSp"}}
		e.EncodeElement(_dee.CSp, _agd)
	}
	if _dee.CGp != nil {
		_dbb := _d.StartElement{Name: _d.Name{Local: "m:cGp"}}
		e.EncodeElement(_dee.CGp, _dbb)
	}
	if _dee.Mcs != nil {
		_fgab := _d.StartElement{Name: _d.Name{Local: "m:mcs"}}
		e.EncodeElement(_dee.Mcs, _fgab)
	}
	if _dee.CtrlPr != nil {
		_beae := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_dee.CtrlPr, _beae)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type CT_LimLoc struct{ ValAttr ST_LimLoc }

// ValidateWithPath validates the OMathPara and its children, prefixing error messages with path
func (_ggbea *OMathPara) ValidateWithPath(path string) error {
	if _afdf := _ggbea.CT_OMathPara.ValidateWithPath(path); _afdf != nil {
		return _afdf
	}
	return nil
}
func (_ebbcb ST_BreakBin) String() string {
	switch _ebbcb {
	case 0:
		return ""
	case 1:
		return "before"
	case 2:
		return "after"
	case 3:
		return "repeat"
	}
	return ""
}
func (_eebf *CT_EqArrPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_bdg:
	for {
		_bbdc, _gge := d.Token()
		if _gge != nil {
			return _gge
		}
		switch _edfc := _bbdc.(type) {
		case _d.StartElement:
			switch _edfc.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "baseJc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "baseJc"}:
				_eebf.BaseJc = NewCT_YAlign()
				if _dca := d.DecodeElement(_eebf.BaseJc, &_edfc); _dca != nil {
					return _dca
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "maxDist"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "maxDist"}:
				_eebf.MaxDist = NewCT_OnOff()
				if _fgee := d.DecodeElement(_eebf.MaxDist, &_edfc); _fgee != nil {
					return _fgee
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "objDist"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "objDist"}:
				_eebf.ObjDist = NewCT_OnOff()
				if _gccf := d.DecodeElement(_eebf.ObjDist, &_edfc); _gccf != nil {
					return _gccf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rSpRule"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rSpRule"}:
				_eebf.RSpRule = NewCT_SpacingRule()
				if _bed := d.DecodeElement(_eebf.RSpRule, &_edfc); _bed != nil {
					return _bed
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rSp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rSp"}:
				_eebf.RSp = NewCT_UnSignedInteger()
				if _bfg := d.DecodeElement(_eebf.RSp, &_edfc); _bfg != nil {
					return _bfg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_eebf.CtrlPr = NewCT_CtrlPr()
				if _bfe := d.DecodeElement(_eebf.CtrlPr, &_edfc); _bfe != nil {
					return _bfe
				}
			default:
				_e.Log("skipping unsupported\u0020element\u0020on\u0020CT_EqArrPr\u0020\u0025v", _edfc.Name)
				if _bcff := d.Skip(); _bcff != nil {
					return _bcff
				}
			}
		case _d.EndElement:
			break _bdg
		case _d.CharData:
		}
	}
	return nil
}

type CT_Nary struct {
	NaryPr *CT_NaryPr
	Sub    *CT_OMathArg
	Sup    *CT_OMathArg
	E      *CT_OMathArg
}
type CT_Text struct {
	SpaceAttr *string
	Content   string
}

func (_cab *CT_LimUppPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_ebe:
	for {
		_egad, _dfac := d.Token()
		if _dfac != nil {
			return _dfac
		}
		switch _aaeg := _egad.(type) {
		case _d.StartElement:
			switch _aaeg.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_cab.CtrlPr = NewCT_CtrlPr()
				if _bddc := d.DecodeElement(_cab.CtrlPr, &_aaeg); _bddc != nil {
					return _bddc
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_LimUppPr\u0020\u0025v", _aaeg.Name)
				if _eedb := d.Skip(); _eedb != nil {
					return _eedb
				}
			}
		case _d.EndElement:
			break _ebe
		case _d.CharData:
		}
	}
	return nil
}

type CT_TwipsMeasure struct{ ValAttr _f.ST_TwipsMeasure }

func (_abee *ST_Shp) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_fbade, _ddede := d.Token()
	if _ddede != nil {
		return _ddede
	}
	if _ebff, _aabc := _fbade.(_d.EndElement); _aabc && _ebff.Name == start.Name {
		*_abee = 1
		return nil
	}
	if _abacf, _dbabb := _fbade.(_d.CharData); !_dbabb {
		return _da.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fbade)
	} else {
		switch string(_abacf) {
		case "":
			*_abee = 0
		case "centered":
			*_abee = 1
		case "match":
			*_abee = 2
		}
	}
	_fbade, _ddede = d.Token()
	if _ddede != nil {
		return _ddede
	}
	if _edgg, _deafb := _fbade.(_d.EndElement); _deafb && _edgg.Name == start.Name {
		return nil
	}
	return _da.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fbade)
}
func (_faba *EG_OMathMathElements) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_bfag:
	for {
		_faca, _efga := d.Token()
		if _efga != nil {
			return _efga
		}
		switch _ddeb := _faca.(type) {
		case _d.StartElement:
			switch _ddeb.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "acc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "acc"}:
				_faba.Acc = NewCT_Acc()
				if _facd := d.DecodeElement(_faba.Acc, &_ddeb); _facd != nil {
					return _facd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "bar"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "bar"}:
				_faba.Bar = NewCT_Bar()
				if _faagb := d.DecodeElement(_faba.Bar, &_ddeb); _faagb != nil {
					return _faagb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "box"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "box"}:
				_faba.Box = NewCT_Box()
				if _fbcc := d.DecodeElement(_faba.Box, &_ddeb); _fbcc != nil {
					return _fbcc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "borderBox"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "borderBox"}:
				_faba.BorderBox = NewCT_BorderBox()
				if _gcff := d.DecodeElement(_faba.BorderBox, &_ddeb); _gcff != nil {
					return _gcff
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "d"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "d"}:
				_faba.D = NewCT_D()
				if _eadeg := d.DecodeElement(_faba.D, &_ddeb); _eadeg != nil {
					return _eadeg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "eqArr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "eqArr"}:
				_faba.EqArr = NewCT_EqArr()
				if _dbg := d.DecodeElement(_faba.EqArr, &_ddeb); _dbg != nil {
					return _dbg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "f"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "f"}:
				_faba.F = NewCT_F()
				if _bbcf := d.DecodeElement(_faba.F, &_ddeb); _bbcf != nil {
					return _bbcf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "func"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "func"}:
				_faba.Func = NewCT_Func()
				if _eefe := d.DecodeElement(_faba.Func, &_ddeb); _eefe != nil {
					return _eefe
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "groupChr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "groupChr"}:
				_faba.GroupChr = NewCT_GroupChr()
				if _cged := d.DecodeElement(_faba.GroupChr, &_ddeb); _cged != nil {
					return _cged
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limLow"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limLow"}:
				_faba.LimLow = NewCT_LimLow()
				if _efadg := d.DecodeElement(_faba.LimLow, &_ddeb); _efadg != nil {
					return _efadg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limUpp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limUpp"}:
				_faba.LimUpp = NewCT_LimUpp()
				if _cgbfd := d.DecodeElement(_faba.LimUpp, &_ddeb); _cgbfd != nil {
					return _cgbfd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "m"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "m"}:
				_faba.M = NewCT_M()
				if _cbddf := d.DecodeElement(_faba.M, &_ddeb); _cbddf != nil {
					return _cbddf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "nary"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "nary"}:
				_faba.Nary = NewCT_Nary()
				if _adff := d.DecodeElement(_faba.Nary, &_ddeb); _adff != nil {
					return _adff
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "phant"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "phant"}:
				_faba.Phant = NewCT_Phant()
				if _bgcg := d.DecodeElement(_faba.Phant, &_ddeb); _bgcg != nil {
					return _bgcg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rad"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rad"}:
				_faba.Rad = NewCT_Rad()
				if _dbef := d.DecodeElement(_faba.Rad, &_ddeb); _dbef != nil {
					return _dbef
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sPre"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sPre"}:
				_faba.SPre = NewCT_SPre()
				if _adgg := d.DecodeElement(_faba.SPre, &_ddeb); _adgg != nil {
					return _adgg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSub"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSub"}:
				_faba.SSub = NewCT_SSub()
				if _ecfcf := d.DecodeElement(_faba.SSub, &_ddeb); _ecfcf != nil {
					return _ecfcf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSubSup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSubSup"}:
				_faba.SSubSup = NewCT_SSubSup()
				if _edgf := d.DecodeElement(_faba.SSubSup, &_ddeb); _edgf != nil {
					return _edgf
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSup"}:
				_faba.SSup = NewCT_SSup()
				if _egff := d.DecodeElement(_faba.SSup, &_ddeb); _egff != nil {
					return _egff
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "r"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "r"}:
				_faba.R = NewCT_R()
				if _ecee := d.DecodeElement(_faba.R, &_ddeb); _ecee != nil {
					return _ecee
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element on\u0020EG_OMathMathElements\u0020\u0025v", _ddeb.Name)
				if _eeecg := d.Skip(); _eeecg != nil {
					return _eeecg
				}
			}
		case _d.EndElement:
			break _bfag
		case _d.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_MPr and its children, prefixing error messages with path
func (_dff *CT_MPr) ValidateWithPath(path string) error {
	if _dff.BaseJc != nil {
		if _fgef := _dff.BaseJc.ValidateWithPath(path + "\u002fBaseJc"); _fgef != nil {
			return _fgef
		}
	}
	if _dff.PlcHide != nil {
		if _bbcg := _dff.PlcHide.ValidateWithPath(path + "\u002fPlcHide"); _bbcg != nil {
			return _bbcg
		}
	}
	if _dff.RSpRule != nil {
		if _cdde := _dff.RSpRule.ValidateWithPath(path + "\u002fRSpRule"); _cdde != nil {
			return _cdde
		}
	}
	if _dff.CGpRule != nil {
		if _afbe := _dff.CGpRule.ValidateWithPath(path + "\u002fCGpRule"); _afbe != nil {
			return _afbe
		}
	}
	if _dff.RSp != nil {
		if _adce := _dff.RSp.ValidateWithPath(path + "\u002fRSp"); _adce != nil {
			return _adce
		}
	}
	if _dff.CSp != nil {
		if _fffe := _dff.CSp.ValidateWithPath(path + "\u002fCSp"); _fffe != nil {
			return _fffe
		}
	}
	if _dff.CGp != nil {
		if _dfdb := _dff.CGp.ValidateWithPath(path + "\u002fCGp"); _dfdb != nil {
			return _dfdb
		}
	}
	if _dff.Mcs != nil {
		if _ffde := _dff.Mcs.ValidateWithPath(path + "\u002fMcs"); _ffde != nil {
			return _ffde
		}
	}
	if _dff.CtrlPr != nil {
		if _eba := _dff.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _eba != nil {
			return _eba
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SSub and its children, prefixing error messages with path
func (_bffa *CT_SSub) ValidateWithPath(path string) error {
	if _bffa.SSubPr != nil {
		if _gbfea := _bffa.SSubPr.ValidateWithPath(path + "\u002fSSubPr"); _gbfea != nil {
			return _gbfea
		}
	}
	if _cce := _bffa.E.ValidateWithPath(path + "\u002fE"); _cce != nil {
		return _cce
	}
	if _aagc := _bffa.Sub.ValidateWithPath(path + "\u002fSub"); _aagc != nil {
		return _aagc
	}
	return nil
}

// Validate validates the CT_XAlign and its children
func (_dabgf *CT_XAlign) Validate() error { return _dabgf.ValidateWithPath("CT_XAlign") }

// Validate validates the CT_NaryPr and its children
func (_cacg *CT_NaryPr) Validate() error { return _cacg.ValidateWithPath("CT_NaryPr") }
func (_eaefe *ST_Script) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_aacg, _dfbge := d.Token()
	if _dfbge != nil {
		return _dfbge
	}
	if _caeagc, _cebf := _aacg.(_d.EndElement); _cebf && _caeagc.Name == start.Name {
		*_eaefe = 1
		return nil
	}
	if _cgaebe, _cbddfe := _aacg.(_d.CharData); !_cbddfe {
		return _da.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aacg)
	} else {
		switch string(_cgaebe) {
		case "":
			*_eaefe = 0
		case "roman":
			*_eaefe = 1
		case "script":
			*_eaefe = 2
		case "fraktur":
			*_eaefe = 3
		case "double\u002dstruck":
			*_eaefe = 4
		case "sans\u002dserif":
			*_eaefe = 5
		case "monospace":
			*_eaefe = 6
		}
	}
	_aacg, _dfbge = d.Token()
	if _dfbge != nil {
		return _dfbge
	}
	if _acdg, _agee := _aacg.(_d.EndElement); _agee && _acdg.Name == start.Name {
		return nil
	}
	return _da.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aacg)
}

// Validate validates the CT_Script and its children
func (_ecdf *CT_Script) Validate() error { return _ecdf.ValidateWithPath("CT_Script") }

type CT_BreakBin struct{ ValAttr ST_BreakBin }

// Validate validates the CT_OMath and its children
func (_adbfd *CT_OMath) Validate() error { return _adbfd.ValidateWithPath("CT_OMath") }
func (_dadf ST_Style) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_cebc := _d.Attr{}
	_cebc.Name = name
	switch _dadf {
	case ST_StyleUnset:
		_cebc.Value = ""
	case ST_StyleP:
		_cebc.Value = "p"
	case ST_StyleB:
		_cebc.Value = "b"
	case ST_StyleI:
		_cebc.Value = "i"
	case ST_StyleBi:
		_cebc.Value = "bi"
	}
	return _cebc, nil
}
func NewCT_MCPr() *CT_MCPr { _bddb := &CT_MCPr{}; return _bddb }

// Validate validates the CT_LimLowPr and its children
func (_fbgd *CT_LimLowPr) Validate() error { return _fbgd.ValidateWithPath("CT_LimLowPr") }

// ValidateWithPath validates the CT_PhantPr and its children, prefixing error messages with path
func (_ffdg *CT_PhantPr) ValidateWithPath(path string) error {
	if _ffdg.Show != nil {
		if _cdcba := _ffdg.Show.ValidateWithPath(path + "\u002fShow"); _cdcba != nil {
			return _cdcba
		}
	}
	if _ffdg.ZeroWid != nil {
		if _bfgd := _ffdg.ZeroWid.ValidateWithPath(path + "\u002fZeroWid"); _bfgd != nil {
			return _bfgd
		}
	}
	if _ffdg.ZeroAsc != nil {
		if _fbea := _ffdg.ZeroAsc.ValidateWithPath(path + "\u002fZeroAsc"); _fbea != nil {
			return _fbea
		}
	}
	if _ffdg.ZeroDesc != nil {
		if _bbee := _ffdg.ZeroDesc.ValidateWithPath(path + "\u002fZeroDesc"); _bbee != nil {
			return _bbee
		}
	}
	if _ffdg.Transp != nil {
		if _gade := _ffdg.Transp.ValidateWithPath(path + "\u002fTransp"); _gade != nil {
			return _gade
		}
	}
	if _ffdg.CtrlPr != nil {
		if _acc := _ffdg.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _acc != nil {
			return _acc
		}
	}
	return nil
}
func (_ccbg *ST_LimLoc) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_ccbg = 0
	case "undOvr":
		*_ccbg = 1
	case "subSup":
		*_ccbg = 2
	}
	return nil
}

// ValidateWithPath validates the CT_Integer2 and its children, prefixing error messages with path
func (_fgec *CT_Integer2) ValidateWithPath(path string) error {
	if _fgec.ValAttr < -2 {
		return _da.Errorf("\u0025s/m\u002eValAttr must be\u0020\u003e\u003d\u0020\u002d2 \u0028have\u0020\u0025v\u0029", path, _fgec.ValAttr)
	}
	if _fgec.ValAttr > 2 {
		return _da.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003c=\u00202\u0020\u0028have\u0020\u0025v\u0029", path, _fgec.ValAttr)
	}
	return nil
}

// ValidateWithPath validates the CT_RadPr and its children, prefixing error messages with path
func (_dabga *CT_RadPr) ValidateWithPath(path string) error {
	if _dabga.DegHide != nil {
		if _ggfac := _dabga.DegHide.ValidateWithPath(path + "\u002fDegHide"); _ggfac != nil {
			return _ggfac
		}
	}
	if _dabga.CtrlPr != nil {
		if _bgda := _dabga.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _bgda != nil {
			return _bgda
		}
	}
	return nil
}
func (_ccfa *CT_FType) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ccfa.ValAttr = ST_FType(1)
	for _, _gccca := range start.Attr {
		if _gccca.Name.Local == "val" {
			_ccfa.ValAttr.UnmarshalXMLAttr(_gccca)
			continue
		}
	}
	for {
		_ffcd, _aece := d.Token()
		if _aece != nil {
			return _da.Errorf("parsing\u0020CT_FType: \u0025s", _aece)
		}
		if _dag, _bdc := _ffcd.(_d.EndElement); _bdc && _dag.Name == start.Name {
			break
		}
	}
	return nil
}
func (_eefd *CT_Integer2) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "m:val"}, Value: _da.Sprintf("\u0025v", _eefd.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type CT_BarPr struct {
	Pos    *CT_TopBot
	CtrlPr *CT_CtrlPr
}

// Validate validates the CT_CtrlPr and its children
func (_afd *CT_CtrlPr) Validate() error { return _afd.ValidateWithPath("CT_CtrlPr") }
func (_egb *CT_BorderBoxPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _egb.HideTop != nil {
		_ddg := _d.StartElement{Name: _d.Name{Local: "m:hideTop"}}
		e.EncodeElement(_egb.HideTop, _ddg)
	}
	if _egb.HideBot != nil {
		_dc := _d.StartElement{Name: _d.Name{Local: "m:hideBot"}}
		e.EncodeElement(_egb.HideBot, _dc)
	}
	if _egb.HideLeft != nil {
		_eff := _d.StartElement{Name: _d.Name{Local: "m:hideLeft"}}
		e.EncodeElement(_egb.HideLeft, _eff)
	}
	if _egb.HideRight != nil {
		_bbda := _d.StartElement{Name: _d.Name{Local: "m:hideRight"}}
		e.EncodeElement(_egb.HideRight, _bbda)
	}
	if _egb.StrikeH != nil {
		_gff := _d.StartElement{Name: _d.Name{Local: "m:strikeH"}}
		e.EncodeElement(_egb.StrikeH, _gff)
	}
	if _egb.StrikeV != nil {
		_beg := _d.StartElement{Name: _d.Name{Local: "m:strikeV"}}
		e.EncodeElement(_egb.StrikeV, _beg)
	}
	if _egb.StrikeBLTR != nil {
		_aab := _d.StartElement{Name: _d.Name{Local: "m:strikeBLTR"}}
		e.EncodeElement(_egb.StrikeBLTR, _aab)
	}
	if _egb.StrikeTLBR != nil {
		_ccd := _d.StartElement{Name: _d.Name{Local: "m:strikeTLBR"}}
		e.EncodeElement(_egb.StrikeTLBR, _ccd)
	}
	if _egb.CtrlPr != nil {
		_gcc := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_egb.CtrlPr, _gcc)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type CT_Script struct{ ValAttr ST_Script }

func (_beac *CT_DPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_egfg:
	for {
		_dfae, _cad := d.Token()
		if _cad != nil {
			return _cad
		}
		switch _ec := _dfae.(type) {
		case _d.StartElement:
			switch _ec.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "begChr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "begChr"}:
				_beac.BegChr = NewCT_Char()
				if _dgd := d.DecodeElement(_beac.BegChr, &_ec); _dgd != nil {
					return _dgd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sepChr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sepChr"}:
				_beac.SepChr = NewCT_Char()
				if _abd := d.DecodeElement(_beac.SepChr, &_ec); _abd != nil {
					return _abd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "endChr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "endChr"}:
				_beac.EndChr = NewCT_Char()
				if _cadg := d.DecodeElement(_beac.EndChr, &_ec); _cadg != nil {
					return _cadg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "grow"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "grow"}:
				_beac.Grow = NewCT_OnOff()
				if _bbga := d.DecodeElement(_beac.Grow, &_ec); _bbga != nil {
					return _bbga
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "shp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "shp"}:
				_beac.Shp = NewCT_Shp()
				if _ebge := d.DecodeElement(_beac.Shp, &_ec); _ebge != nil {
					return _ebge
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_beac.CtrlPr = NewCT_CtrlPr()
				if _bbb := d.DecodeElement(_beac.CtrlPr, &_ec); _bbb != nil {
					return _bbb
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DPr\u0020\u0025v", _ec.Name)
				if _eag := d.Skip(); _eag != nil {
					return _eag
				}
			}
		case _d.EndElement:
			break _egfg
		case _d.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Bar and its children, prefixing error messages with path
func (_fab *CT_Bar) ValidateWithPath(path string) error {
	if _fab.BarPr != nil {
		if _cd := _fab.BarPr.ValidateWithPath(path + "\u002fBarPr"); _cd != nil {
			return _cd
		}
	}
	if _cb := _fab.E.ValidateWithPath(path + "\u002fE"); _cb != nil {
		return _cb
	}
	return nil
}

type CT_SPre struct {
	SPrePr *CT_SPrePr
	Sub    *CT_OMathArg
	Sup    *CT_OMathArg
	E      *CT_OMathArg
}

func (_gggd *CT_MC) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _gggd.McPr != nil {
		_befg := _d.StartElement{Name: _d.Name{Local: "m:mcPr"}}
		e.EncodeElement(_gggd.McPr, _befg)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_gbfg *CT_Script) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _gbfg.ValAttr != ST_ScriptUnset {
		_bebd, _dgab := _gbfg.ValAttr.MarshalXMLAttr(_d.Name{Local: "m:val"})
		if _dgab != nil {
			return _dgab
		}
		start.Attr = append(start.Attr, _bebd)
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type ST_LimLoc byte

func (_gdcgb *ST_FType) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_gdcgb = 0
	case "bar":
		*_gdcgb = 1
	case "skw":
		*_gdcgb = 2
	case "lin":
		*_gdcgb = 3
	case "noBar":
		*_gdcgb = 4
	}
	return nil
}

type CT_MR struct{ E []*CT_OMathArg }
type CT_OMathPara struct {
	OMathParaPr *CT_OMathParaPr
	OMath       []*CT_OMath
}

func NewCT_Style() *CT_Style { _cegc := &CT_Style{}; return _cegc }

// Validate validates the CT_LimUppPr and its children
func (_ggde *CT_LimUppPr) Validate() error { return _ggde.ValidateWithPath("CT_LimUppPr") }
func (_ecc *CT_MR) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_gdac:
	for {
		_bfbg, _gccba := d.Token()
		if _gccba != nil {
			return _gccba
		}
		switch _bgff := _bfbg.(type) {
		case _d.StartElement:
			switch _bgff.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				_bedf := NewCT_OMathArg()
				if _gece := d.DecodeElement(_bedf, &_bgff); _gece != nil {
					return _gece
				}
				_ecc.E = append(_ecc.E, _bedf)
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on CT_MR \u0025v", _bgff.Name)
				if _beeda := d.Skip(); _beeda != nil {
					return _beeda
				}
			}
		case _d.EndElement:
			break _gdac
		case _d.CharData:
		}
	}
	return nil
}

// Validate validates the CT_RadPr and its children
func (_ffgbb *CT_RadPr) Validate() error { return _ffgbb.ValidateWithPath("CT_RadPr") }
func NewCT_SSub() *CT_SSub {
	_bcdge := &CT_SSub{}
	_bcdge.E = NewCT_OMathArg()
	_bcdge.Sub = NewCT_OMathArg()
	return _bcdge
}

type CT_GroupChr struct {
	GroupChrPr *CT_GroupChrPr
	E          *CT_OMathArg
}

func (_gfec *ST_BreakBin) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_dfcd, _eedaf := d.Token()
	if _eedaf != nil {
		return _eedaf
	}
	if _fagd, _cadbc := _dfcd.(_d.EndElement); _cadbc && _fagd.Name == start.Name {
		*_gfec = 1
		return nil
	}
	if _acdc, _ebffb := _dfcd.(_d.CharData); !_ebffb {
		return _da.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dfcd)
	} else {
		switch string(_acdc) {
		case "":
			*_gfec = 0
		case "before":
			*_gfec = 1
		case "after":
			*_gfec = 2
		case "repeat":
			*_gfec = 3
		}
	}
	_dfcd, _eedaf = d.Token()
	if _eedaf != nil {
		return _eedaf
	}
	if _decbc, _fegae := _dfcd.(_d.EndElement); _fegae && _decbc.Name == start.Name {
		return nil
	}
	return _da.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dfcd)
}

type CT_Integer255 struct{ ValAttr int64 }

// Validate validates the CT_SpacingRule and its children
func (_ccgde *CT_SpacingRule) Validate() error { return _ccgde.ValidateWithPath("CT_SpacingRule") }
func NewCT_EqArr() *CT_EqArr                   { _faa := &CT_EqArr{}; return _faa }

// Validate validates the CT_GroupChrPr and its children
func (_gccg *CT_GroupChrPr) Validate() error { return _gccg.ValidateWithPath("CT_GroupChrPr") }

type CT_Rad struct {
	RadPr *CT_RadPr
	Deg   *CT_OMathArg
	E     *CT_OMathArg
}

func (_cea *CT_BarPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _cea.Pos != nil {
		_dbc := _d.StartElement{Name: _d.Name{Local: "m:pos"}}
		e.EncodeElement(_cea.Pos, _dbc)
	}
	if _cea.CtrlPr != nil {
		_be := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_cea.CtrlPr, _be)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type CT_OnOff struct{ ValAttr *_f.ST_OnOff }

// ValidateWithPath validates the CT_F and its children, prefixing error messages with path
func (_aec *CT_F) ValidateWithPath(path string) error {
	if _aec.FPr != nil {
		if _gdcd := _aec.FPr.ValidateWithPath(path + "\u002fFPr"); _gdcd != nil {
			return _gdcd
		}
	}
	if _aacb := _aec.Num.ValidateWithPath(path + "\u002fNum"); _aacb != nil {
		return _aacb
	}
	if _gdf := _aec.Den.ValidateWithPath(path + "\u002fDen"); _gdf != nil {
		return _gdf
	}
	return nil
}
func (_gddd ST_BreakBin) Validate() error { return _gddd.ValidateWithPath("") }
func (_ebg *CT_D) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_abg:
	for {
		_fcg, _ccg := d.Token()
		if _ccg != nil {
			return _ccg
		}
		switch _ccfd := _fcg.(type) {
		case _d.StartElement:
			switch _ccfd.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "dPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "dPr"}:
				_ebg.DPr = NewCT_DPr()
				if _gcfd := d.DecodeElement(_ebg.DPr, &_ccfd); _gcfd != nil {
					return _gcfd
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "e"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "e"}:
				_fbf := NewCT_OMathArg()
				if _dgfa := d.DecodeElement(_fbf, &_ccfd); _dgfa != nil {
					return _dgfa
				}
				_ebg.E = append(_ebg.E, _fbf)
			default:
				_e.Log("skipping\u0020unsupported element\u0020on\u0020CT_D\u0020\u0025v", _ccfd.Name)
				if _fef := d.Skip(); _fef != nil {
					return _fef
				}
			}
		case _d.EndElement:
			break _abg
		case _d.CharData:
		}
	}
	return nil
}
func (_acfe *CT_R) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _acfe.RPr != nil {
		_gfc := _d.StartElement{Name: _d.Name{Local: "m:rPr"}}
		e.EncodeElement(_acfe.RPr, _gfc)
	}
	if _acfe.Choice != nil {
		for _, _dbcb := range _acfe.Choice {
			_dbcb.MarshalXML(e, _d.StartElement{})
		}
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_fdbc ST_Style) String() string {
	switch _fdbc {
	case 0:
		return ""
	case 1:
		return "p"
	case 2:
		return "b"
	case 3:
		return "i"
	case 4:
		return "bi"
	}
	return ""
}
func (_bbcaa *CT_Text) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _bbcaa.SpaceAttr != nil {
		start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xml:space"}, Value: _da.Sprintf("\u0025v", *_bbcaa.SpaceAttr)})
	}
	e.EncodeElement(_bbcaa.Content, start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type CT_BoxPr struct {
	OpEmu   *CT_OnOff
	NoBreak *CT_OnOff
	Diff    *CT_OnOff
	Brk     *CT_ManualBreak
	Aln     *CT_OnOff
	CtrlPr  *CT_CtrlPr
}
type CT_OMath struct{ EG_OMathMathElements []*EG_OMathMathElements }

func (_bcge *CT_TwipsMeasure) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "m:val"}, Value: _da.Sprintf("\u0025v", _bcge.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type CT_BorderBoxPr struct {
	HideTop    *CT_OnOff
	HideBot    *CT_OnOff
	HideLeft   *CT_OnOff
	HideRight  *CT_OnOff
	StrikeH    *CT_OnOff
	StrikeV    *CT_OnOff
	StrikeBLTR *CT_OnOff
	StrikeTLBR *CT_OnOff
	CtrlPr     *CT_CtrlPr
}

func (_edga *CT_OMathPara) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _edga.OMathParaPr != nil {
		_dbdf := _d.StartElement{Name: _d.Name{Local: "m:oMathParaPr"}}
		e.EncodeElement(_edga.OMathParaPr, _dbdf)
	}
	_ddada := _d.StartElement{Name: _d.Name{Local: "m:oMath"}}
	for _, _gcgg := range _edga.OMath {
		e.EncodeElement(_gcgg, _ddada)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_dabcb ST_Script) String() string {
	switch _dabcb {
	case 0:
		return ""
	case 1:
		return "roman"
	case 2:
		return "script"
	case 3:
		return "fraktur"
	case 4:
		return "double\u002dstruck"
	case 5:
		return "sans\u002dserif"
	case 6:
		return "monospace"
	}
	return ""
}
func (_dbde *CT_SSubSup) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _dbde.SSubSupPr != nil {
		_dbbe := _d.StartElement{Name: _d.Name{Local: "m:sSubSupPr"}}
		e.EncodeElement(_dbde.SSubSupPr, _dbbe)
	}
	_cade := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_dbde.E, _cade)
	_fbff := _d.StartElement{Name: _d.Name{Local: "m:sub"}}
	e.EncodeElement(_dbde.Sub, _fbff)
	_cbcg := _d.StartElement{Name: _d.Name{Local: "m:sup"}}
	e.EncodeElement(_dbde.Sup, _cbcg)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

type CT_OMathParaPr struct{ Jc *CT_OMathJc }

// Validate validates the CT_BreakBin and its children
func (_gag *CT_BreakBin) Validate() error { return _gag.ValidateWithPath("CT_BreakBin") }

// ValidateWithPath validates the CT_Func and its children, prefixing error messages with path
func (_cgb *CT_Func) ValidateWithPath(path string) error {
	if _cgb.FuncPr != nil {
		if _ceef := _cgb.FuncPr.ValidateWithPath(path + "\u002fFuncPr"); _ceef != nil {
			return _ceef
		}
	}
	if _abe := _cgb.FName.ValidateWithPath(path + "\u002fFName"); _abe != nil {
		return _abe
	}
	if _dcbc := _cgb.E.ValidateWithPath(path + "\u002fE"); _dcbc != nil {
		return _dcbc
	}
	return nil
}

// ValidateWithPath validates the CT_BoxPr and its children, prefixing error messages with path
func (_bafe *CT_BoxPr) ValidateWithPath(path string) error {
	if _bafe.OpEmu != nil {
		if _ged := _bafe.OpEmu.ValidateWithPath(path + "\u002fOpEmu"); _ged != nil {
			return _ged
		}
	}
	if _bafe.NoBreak != nil {
		if _egc := _bafe.NoBreak.ValidateWithPath(path + "\u002fNoBreak"); _egc != nil {
			return _egc
		}
	}
	if _bafe.Diff != nil {
		if _fgb := _bafe.Diff.ValidateWithPath(path + "\u002fDiff"); _fgb != nil {
			return _fgb
		}
	}
	if _bafe.Brk != nil {
		if _gde := _bafe.Brk.ValidateWithPath(path + "\u002fBrk"); _gde != nil {
			return _gde
		}
	}
	if _bafe.Aln != nil {
		if _dcg := _bafe.Aln.ValidateWithPath(path + "\u002fAln"); _dcg != nil {
			return _dcg
		}
	}
	if _bafe.CtrlPr != nil {
		if _bea := _bafe.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _bea != nil {
			return _bea
		}
	}
	return nil
}
func (_gcbf *CT_BreakBinSub) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _gcbf.ValAttr != ST_BreakBinSubUnset {
		_efa, _ffcg := _gcbf.ValAttr.MarshalXMLAttr(_d.Name{Local: "m:val"})
		if _ffcg != nil {
			return _ffcg
		}
		start.Attr = append(start.Attr, _efa)
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_fcdbe *CT_RPRChoice) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _fcdbe.Nor != nil {
		_adac := _d.StartElement{Name: _d.Name{Local: "m:nor"}}
		e.EncodeElement(_fcdbe.Nor, _adac)
	}
	return nil
}
func (_gbfe *CT_OMath) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _gbfe.EG_OMathMathElements != nil {
		for _, _ffca := range _gbfe.EG_OMathMathElements {
			_ffca.MarshalXML(e, _d.StartElement{})
		}
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_eaea *CT_DPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _eaea.BegChr != nil {
		_ceb := _d.StartElement{Name: _d.Name{Local: "m:begChr"}}
		e.EncodeElement(_eaea.BegChr, _ceb)
	}
	if _eaea.SepChr != nil {
		_fff := _d.StartElement{Name: _d.Name{Local: "m:sepChr"}}
		e.EncodeElement(_eaea.SepChr, _fff)
	}
	if _eaea.EndChr != nil {
		_fgce := _d.StartElement{Name: _d.Name{Local: "m:endChr"}}
		e.EncodeElement(_eaea.EndChr, _fgce)
	}
	if _eaea.Grow != nil {
		_dab := _d.StartElement{Name: _d.Name{Local: "m:grow"}}
		e.EncodeElement(_eaea.Grow, _dab)
	}
	if _eaea.Shp != nil {
		_dcb := _d.StartElement{Name: _d.Name{Local: "m:shp"}}
		e.EncodeElement(_eaea.Shp, _dcb)
	}
	if _eaea.CtrlPr != nil {
		_dega := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_eaea.CtrlPr, _dega)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_dae *CT_LimLow) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _dae.LimLowPr != nil {
		_eeccb := _d.StartElement{Name: _d.Name{Local: "m:limLowPr"}}
		e.EncodeElement(_dae.LimLowPr, _eeccb)
	}
	_eggd := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_dae.E, _eggd)
	_cafe := _d.StartElement{Name: _d.Name{Local: "m:lim"}}
	e.EncodeElement(_dae.Lim, _cafe)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_MathPrChoice and its children
func (_gffe *CT_MathPrChoice) Validate() error { return _gffe.ValidateWithPath("CT_MathPrChoice") }
func (_eedf ST_Shp) String() string {
	switch _eedf {
	case 0:
		return ""
	case 1:
		return "centered"
	case 2:
		return "match"
	}
	return ""
}
func (_eeee *CT_F) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _eeee.FPr != nil {
		_gcdd := _d.StartElement{Name: _d.Name{Local: "m:fPr"}}
		e.EncodeElement(_eeee.FPr, _gcdd)
	}
	_gbb := _d.StartElement{Name: _d.Name{Local: "m:num"}}
	e.EncodeElement(_eeee.Num, _gbb)
	_gbdg := _d.StartElement{Name: _d.Name{Local: "m:den"}}
	e.EncodeElement(_eeee.Den, _gbdg)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_OMathJc and its children, prefixing error messages with path
func (_ddgf *CT_OMathJc) ValidateWithPath(path string) error {
	if _eeae := _ddgf.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _eeae != nil {
		return _eeae
	}
	return nil
}
func (_eebe *CT_Func) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _eebe.FuncPr != nil {
		_eab := _d.StartElement{Name: _d.Name{Local: "m:funcPr"}}
		e.EncodeElement(_eebe.FuncPr, _eab)
	}
	_bda := _d.StartElement{Name: _d.Name{Local: "m:fName"}}
	e.EncodeElement(_eebe.FName, _bda)
	_cadbd := _d.StartElement{Name: _d.Name{Local: "m:e"}}
	e.EncodeElement(_eebe.E, _cadbd)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewCT_FPr() *CT_FPr { _gggc := &CT_FPr{}; return _gggc }

// ValidateWithPath validates the CT_Rad and its children, prefixing error messages with path
func (_ccadc *CT_Rad) ValidateWithPath(path string) error {
	if _ccadc.RadPr != nil {
		if _dcaga := _ccadc.RadPr.ValidateWithPath(path + "\u002fRadPr"); _dcaga != nil {
			return _dcaga
		}
	}
	if _bbca := _ccadc.Deg.ValidateWithPath(path + "\u002fDeg"); _bbca != nil {
		return _bbca
	}
	if _ffaf := _ccadc.E.ValidateWithPath(path + "\u002fE"); _ffaf != nil {
		return _ffaf
	}
	return nil
}

// Validate validates the CT_LimUpp and its children
func (_eaed *CT_LimUpp) Validate() error { return _eaed.ValidateWithPath("CT_LimUpp") }

type CT_FPr struct {
	Type   *CT_FType
	CtrlPr *CT_CtrlPr
}

// Validate validates the CT_OMathArgPr and its children
func (_cabfc *CT_OMathArgPr) Validate() error { return _cabfc.ValidateWithPath("CT_OMathArgPr") }
func (_gagcc *MathPr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_gagcc.CT_MathPr = *NewCT_MathPr()
_efggb:
	for {
		_deedf, _dgdf := d.Token()
		if _dgdf != nil {
			return _dgdf
		}
		switch _ecdad := _deedf.(type) {
		case _d.StartElement:
			switch _ecdad.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "mathFont"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "mathFont"}:
				_gagcc.MathFont = NewCT_String()
				if _gbcg := d.DecodeElement(_gagcc.MathFont, &_ecdad); _gbcg != nil {
					return _gbcg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "brkBin"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "brkBin"}:
				_gagcc.BrkBin = NewCT_BreakBin()
				if _eecce := d.DecodeElement(_gagcc.BrkBin, &_ecdad); _eecce != nil {
					return _eecce
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "brkBinSub"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "brkBinSub"}:
				_gagcc.BrkBinSub = NewCT_BreakBinSub()
				if _cfeb := d.DecodeElement(_gagcc.BrkBinSub, &_ecdad); _cfeb != nil {
					return _cfeb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "smallFrac"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "smallFrac"}:
				_gagcc.SmallFrac = NewCT_OnOff()
				if _bbdae := d.DecodeElement(_gagcc.SmallFrac, &_ecdad); _bbdae != nil {
					return _bbdae
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "dispDef"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "dispDef"}:
				_gagcc.DispDef = NewCT_OnOff()
				if _aebc := d.DecodeElement(_gagcc.DispDef, &_ecdad); _aebc != nil {
					return _aebc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "lMargin"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "lMargin"}:
				_gagcc.LMargin = NewCT_TwipsMeasure()
				if _edecc := d.DecodeElement(_gagcc.LMargin, &_ecdad); _edecc != nil {
					return _edecc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rMargin"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rMargin"}:
				_gagcc.RMargin = NewCT_TwipsMeasure()
				if _ggbfa := d.DecodeElement(_gagcc.RMargin, &_ecdad); _ggbfa != nil {
					return _ggbfa
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "defJc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "defJc"}:
				_gagcc.DefJc = NewCT_OMathJc()
				if _eeafg := d.DecodeElement(_gagcc.DefJc, &_ecdad); _eeafg != nil {
					return _eeafg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "preSp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "preSp"}:
				_gagcc.PreSp = NewCT_TwipsMeasure()
				if _fefg := d.DecodeElement(_gagcc.PreSp, &_ecdad); _fefg != nil {
					return _fefg
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "postSp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "postSp"}:
				_gagcc.PostSp = NewCT_TwipsMeasure()
				if _bbeed := d.DecodeElement(_gagcc.PostSp, &_ecdad); _bbeed != nil {
					return _bbeed
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "interSp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "interSp"}:
				_gagcc.InterSp = NewCT_TwipsMeasure()
				if _bfbbc := d.DecodeElement(_gagcc.InterSp, &_ecdad); _bfbbc != nil {
					return _bfbbc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "intraSp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "intraSp"}:
				_gagcc.IntraSp = NewCT_TwipsMeasure()
				if _caaeb := d.DecodeElement(_gagcc.IntraSp, &_ecdad); _caaeb != nil {
					return _caaeb
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "wrapIndent"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "wrapIndent"}:
				_gagcc.Choice = NewCT_MathPrChoice()
				if _gbac := d.DecodeElement(&_gagcc.Choice.WrapIndent, &_ecdad); _gbac != nil {
					return _gbac
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "wrapRight"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "wrapRight"}:
				_gagcc.Choice = NewCT_MathPrChoice()
				if _bgega := d.DecodeElement(&_gagcc.Choice.WrapRight, &_ecdad); _bgega != nil {
					return _bgega
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "intLim"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "intLim"}:
				_gagcc.IntLim = NewCT_LimLoc()
				if _ffbc := d.DecodeElement(_gagcc.IntLim, &_ecdad); _ffbc != nil {
					return _ffbc
				}
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "naryLim"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "naryLim"}:
				_gagcc.NaryLim = NewCT_LimLoc()
				if _fddd := d.DecodeElement(_gagcc.NaryLim, &_ecdad); _fddd != nil {
					return _fddd
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on\u0020MathPr\u0020\u0025v", _ecdad.Name)
				if _fedf := d.Skip(); _fedf != nil {
					return _fedf
				}
			}
		case _d.EndElement:
			break _efggb
		case _d.CharData:
		}
	}
	return nil
}

type CT_NaryPr struct {
	Chr     *CT_Char
	LimLoc  *CT_LimLoc
	Grow    *CT_OnOff
	SubHide *CT_OnOff
	SupHide *CT_OnOff
	CtrlPr  *CT_CtrlPr
}
type CT_RChoice struct{ T []*CT_Text }

func (_fgefd ST_LimLoc) ValidateWithPath(path string) error {
	switch _fgefd {
	case 0, 1, 2:
	default:
		return _da.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fgefd))
	}
	return nil
}
func (_feab *ST_Shp) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_feab = 0
	case "centered":
		*_feab = 1
	case "match":
		*_feab = 2
	}
	return nil
}

// ValidateWithPath validates the EG_OMathMathElements and its children, prefixing error messages with path
func (_gfaca *EG_OMathMathElements) ValidateWithPath(path string) error {
	if _gfaca.Acc != nil {
		if _ccbe := _gfaca.Acc.ValidateWithPath(path + "\u002fAcc"); _ccbe != nil {
			return _ccbe
		}
	}
	if _gfaca.Bar != nil {
		if _eebed := _gfaca.Bar.ValidateWithPath(path + "\u002fBar"); _eebed != nil {
			return _eebed
		}
	}
	if _gfaca.Box != nil {
		if _fee := _gfaca.Box.ValidateWithPath(path + "\u002fBox"); _fee != nil {
			return _fee
		}
	}
	if _gfaca.BorderBox != nil {
		if _accb := _gfaca.BorderBox.ValidateWithPath(path + "\u002fBorderBox"); _accb != nil {
			return _accb
		}
	}
	if _gfaca.D != nil {
		if _aggg := _gfaca.D.ValidateWithPath(path + "\u002fD"); _aggg != nil {
			return _aggg
		}
	}
	if _gfaca.EqArr != nil {
		if _aedfe := _gfaca.EqArr.ValidateWithPath(path + "\u002fEqArr"); _aedfe != nil {
			return _aedfe
		}
	}
	if _gfaca.F != nil {
		if _ggaee := _gfaca.F.ValidateWithPath(path + "\u002fF"); _ggaee != nil {
			return _ggaee
		}
	}
	if _gfaca.Func != nil {
		if _eeeab := _gfaca.Func.ValidateWithPath(path + "\u002fFunc"); _eeeab != nil {
			return _eeeab
		}
	}
	if _gfaca.GroupChr != nil {
		if _daba := _gfaca.GroupChr.ValidateWithPath(path + "\u002fGroupChr"); _daba != nil {
			return _daba
		}
	}
	if _gfaca.LimLow != nil {
		if _afdd := _gfaca.LimLow.ValidateWithPath(path + "\u002fLimLow"); _afdd != nil {
			return _afdd
		}
	}
	if _gfaca.LimUpp != nil {
		if _afgg := _gfaca.LimUpp.ValidateWithPath(path + "\u002fLimUpp"); _afgg != nil {
			return _afgg
		}
	}
	if _gfaca.M != nil {
		if _bbaa := _gfaca.M.ValidateWithPath(path + "\u002fM"); _bbaa != nil {
			return _bbaa
		}
	}
	if _gfaca.Nary != nil {
		if _aeeg := _gfaca.Nary.ValidateWithPath(path + "\u002fNary"); _aeeg != nil {
			return _aeeg
		}
	}
	if _gfaca.Phant != nil {
		if _ffbbd := _gfaca.Phant.ValidateWithPath(path + "\u002fPhant"); _ffbbd != nil {
			return _ffbbd
		}
	}
	if _gfaca.Rad != nil {
		if _gcbb := _gfaca.Rad.ValidateWithPath(path + "\u002fRad"); _gcbb != nil {
			return _gcbb
		}
	}
	if _gfaca.SPre != nil {
		if _gbba := _gfaca.SPre.ValidateWithPath(path + "\u002fSPre"); _gbba != nil {
			return _gbba
		}
	}
	if _gfaca.SSub != nil {
		if _ecaa := _gfaca.SSub.ValidateWithPath(path + "\u002fSSub"); _ecaa != nil {
			return _ecaa
		}
	}
	if _gfaca.SSubSup != nil {
		if _bagcg := _gfaca.SSubSup.ValidateWithPath(path + "\u002fSSubSup"); _bagcg != nil {
			return _bagcg
		}
	}
	if _gfaca.SSup != nil {
		if _cadd := _gfaca.SSup.ValidateWithPath(path + "\u002fSSup"); _cadd != nil {
			return _cadd
		}
	}
	if _gfaca.R != nil {
		if _cdgad := _gfaca.R.ValidateWithPath(path + "\u002fR"); _cdgad != nil {
			return _cdgad
		}
	}
	return nil
}
func (_gfaa *CT_OMathJc) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _cdfe := range start.Attr {
		if _cdfe.Name.Local == "val" {
			_gfaa.ValAttr.UnmarshalXMLAttr(_cdfe)
			continue
		}
	}
	for {
		_aeceb, _cafg := d.Token()
		if _cafg != nil {
			return _da.Errorf("parsing\u0020CT_OMathJc:\u0020%s", _cafg)
		}
		if _ggdcd, _ebag := _aeceb.(_d.EndElement); _ebag && _ggdcd.Name == start.Name {
			break
		}
	}
	return nil
}
func NewEG_OMathMathElements() *EG_OMathMathElements {
	_ddgfg := &EG_OMathMathElements{}
	return _ddgfg
}
func (_caage ST_Script) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_caage.String(), start)
}

// ValidateWithPath validates the CT_BarPr and its children, prefixing error messages with path
func (_add *CT_BarPr) ValidateWithPath(path string) error {
	if _add.Pos != nil {
		if _geac := _add.Pos.ValidateWithPath(path + "\u002fPos"); _geac != nil {
			return _geac
		}
	}
	if _add.CtrlPr != nil {
		if _de := _add.CtrlPr.ValidateWithPath(path + "\u002fCtrlPr"); _de != nil {
			return _de
		}
	}
	return nil
}
func NewCT_FuncPr() *CT_FuncPr         { _eecc := &CT_FuncPr{}; return _eecc }
func NewCT_Integer255() *CT_Integer255 { _adbf := &CT_Integer255{}; _adbf.ValAttr = 1; return _adbf }
func (_cgbc *CT_SPrePr) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
_eeecc:
	for {
		_aada, _ebgf := d.Token()
		if _ebgf != nil {
			return _ebgf
		}
		switch _bcda := _aada.(type) {
		case _d.StartElement:
			switch _bcda.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "ctrlPr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "ctrlPr"}:
				_cgbc.CtrlPr = NewCT_CtrlPr()
				if _gefc := d.DecodeElement(_cgbc.CtrlPr, &_bcda); _gefc != nil {
					return _gefc
				}
			default:
				_e.Log("skipping\u0020unsupported\u0020element on CT_SPrePr \u0025v", _bcda.Name)
				if _geec := d.Skip(); _geec != nil {
					return _geec
				}
			}
		case _d.EndElement:
			break _eeecc
		case _d.CharData:
		}
	}
	return nil
}

type CT_FType struct{ ValAttr ST_FType }

func (_agcag *CT_SpacingRule) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "m:val"}, Value: _da.Sprintf("\u0025v", _agcag.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewCT_Box() *CT_Box { _ggb := &CT_Box{}; _ggb.E = NewCT_OMathArg(); return _ggb }

type CT_LimLow struct {
	LimLowPr *CT_LimLowPr
	E        *CT_OMathArg
	Lim      *CT_OMathArg
}

// ValidateWithPath validates the CT_GroupChr and its children, prefixing error messages with path
func (_adg *CT_GroupChr) ValidateWithPath(path string) error {
	if _adg.GroupChrPr != nil {
		if _ggec := _adg.GroupChrPr.ValidateWithPath(path + "/GroupChrPr"); _ggec != nil {
			return _ggec
		}
	}
	if _ceec := _adg.E.ValidateWithPath(path + "\u002fE"); _ceec != nil {
		return _ceec
	}
	return nil
}
func (_bffe *ST_BreakBin) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_bffe = 0
	case "before":
		*_bffe = 1
	case "after":
		*_bffe = 2
	case "repeat":
		*_bffe = 3
	}
	return nil
}
func (_efgb *CT_MathPrChoice) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _efgb.WrapIndent != nil {
		_edaa := _d.StartElement{Name: _d.Name{Local: "m:wrapIndent"}}
		e.EncodeElement(_efgb.WrapIndent, _edaa)
	}
	if _efgb.WrapRight != nil {
		_fbce := _d.StartElement{Name: _d.Name{Local: "m:wrapRight"}}
		e.EncodeElement(_efgb.WrapRight, _fbce)
	}
	return nil
}
func NewCT_Nary() *CT_Nary {
	_eede := &CT_Nary{}
	_eede.Sub = NewCT_OMathArg()
	_eede.Sup = NewCT_OMathArg()
	_eede.E = NewCT_OMathArg()
	return _eede
}
func (_afge *CT_SPrePr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _afge.CtrlPr != nil {
		_bbccf := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_afge.CtrlPr, _bbccf)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_cceg ST_BreakBin) ValidateWithPath(path string) error {
	switch _cceg {
	case 0, 1, 2, 3:
	default:
		return _da.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cceg))
	}
	return nil
}
func NewOMathPara() *OMathPara {
	_fafb := &OMathPara{}
	_fafb.CT_OMathPara = *NewCT_OMathPara()
	return _fafb
}
func (_aaea *OMath) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_aaea.CT_OMath = *NewCT_OMath()
_ggdf:
	for {
		_cabab, _gcfdg := d.Token()
		if _gcfdg != nil {
			return _gcfdg
		}
		switch _dafd := _cabab.(type) {
		case _d.StartElement:
			switch _dafd.Name {
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "acc"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "acc"}:
				_bcdff := NewEG_OMathMathElements()
				_bcdff.Acc = NewCT_Acc()
				if _agba := d.DecodeElement(_bcdff.Acc, &_dafd); _agba != nil {
					return _agba
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _bcdff)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "bar"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "bar"}:
				_efee := NewEG_OMathMathElements()
				_efee.Bar = NewCT_Bar()
				if _bfgea := d.DecodeElement(_efee.Bar, &_dafd); _bfgea != nil {
					return _bfgea
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _efee)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "box"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "box"}:
				_dded := NewEG_OMathMathElements()
				_dded.Box = NewCT_Box()
				if _fdcd := d.DecodeElement(_dded.Box, &_dafd); _fdcd != nil {
					return _fdcd
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _dded)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "borderBox"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "borderBox"}:
				_ddead := NewEG_OMathMathElements()
				_ddead.BorderBox = NewCT_BorderBox()
				if _bgde := d.DecodeElement(_ddead.BorderBox, &_dafd); _bgde != nil {
					return _bgde
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _ddead)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "d"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "d"}:
				_effd := NewEG_OMathMathElements()
				_effd.D = NewCT_D()
				if _egeeb := d.DecodeElement(_effd.D, &_dafd); _egeeb != nil {
					return _egeeb
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _effd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "eqArr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "eqArr"}:
				_dbbc := NewEG_OMathMathElements()
				_dbbc.EqArr = NewCT_EqArr()
				if _cadef := d.DecodeElement(_dbbc.EqArr, &_dafd); _cadef != nil {
					return _cadef
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _dbbc)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "f"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "f"}:
				_acea := NewEG_OMathMathElements()
				_acea.F = NewCT_F()
				if _bged := d.DecodeElement(_acea.F, &_dafd); _bged != nil {
					return _bged
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _acea)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "func"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "func"}:
				_eaba := NewEG_OMathMathElements()
				_eaba.Func = NewCT_Func()
				if _beag := d.DecodeElement(_eaba.Func, &_dafd); _beag != nil {
					return _beag
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _eaba)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "groupChr"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "groupChr"}:
				_dcacg := NewEG_OMathMathElements()
				_dcacg.GroupChr = NewCT_GroupChr()
				if _dfdfa := d.DecodeElement(_dcacg.GroupChr, &_dafd); _dfdfa != nil {
					return _dfdfa
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _dcacg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limLow"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limLow"}:
				_eacdg := NewEG_OMathMathElements()
				_eacdg.LimLow = NewCT_LimLow()
				if _bgbea := d.DecodeElement(_eacdg.LimLow, &_dafd); _bgbea != nil {
					return _bgbea
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _eacdg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "limUpp"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "limUpp"}:
				_effb := NewEG_OMathMathElements()
				_effb.LimUpp = NewCT_LimUpp()
				if _gfgcf := d.DecodeElement(_effb.LimUpp, &_dafd); _gfgcf != nil {
					return _gfgcf
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _effb)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "m"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "m"}:
				_efdd := NewEG_OMathMathElements()
				_efdd.M = NewCT_M()
				if _eadec := d.DecodeElement(_efdd.M, &_dafd); _eadec != nil {
					return _eadec
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _efdd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "nary"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "nary"}:
				_dafgd := NewEG_OMathMathElements()
				_dafgd.Nary = NewCT_Nary()
				if _adcc := d.DecodeElement(_dafgd.Nary, &_dafd); _adcc != nil {
					return _adcc
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _dafgd)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "phant"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "phant"}:
				_cbbe := NewEG_OMathMathElements()
				_cbbe.Phant = NewCT_Phant()
				if _deafg := d.DecodeElement(_cbbe.Phant, &_dafd); _deafg != nil {
					return _deafg
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _cbbe)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "rad"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "rad"}:
				_ffea := NewEG_OMathMathElements()
				_ffea.Rad = NewCT_Rad()
				if _eegfa := d.DecodeElement(_ffea.Rad, &_dafd); _eegfa != nil {
					return _eegfa
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _ffea)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sPre"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sPre"}:
				_cdee := NewEG_OMathMathElements()
				_cdee.SPre = NewCT_SPre()
				if _ebdgg := d.DecodeElement(_cdee.SPre, &_dafd); _ebdgg != nil {
					return _ebdgg
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _cdee)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSub"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSub"}:
				_dgfe := NewEG_OMathMathElements()
				_dgfe.SSub = NewCT_SSub()
				if _adaca := d.DecodeElement(_dgfe.SSub, &_dafd); _adaca != nil {
					return _adaca
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _dgfe)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSubSup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSubSup"}:
				_cgbff := NewEG_OMathMathElements()
				_cgbff.SSubSup = NewCT_SSubSup()
				if _dggb := d.DecodeElement(_cgbff.SSubSup, &_dafd); _dggb != nil {
					return _dggb
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _cgbff)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "sSup"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "sSup"}:
				_eefg := NewEG_OMathMathElements()
				_eefg.SSup = NewCT_SSup()
				if _cgaeb := d.DecodeElement(_eefg.SSup, &_dafd); _cgaeb != nil {
					return _cgaeb
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _eefg)
			case _d.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", Local: "r"}, _d.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fofficeDocument\u002fmath", Local: "r"}:
				_ffefg := NewEG_OMathMathElements()
				_ffefg.R = NewCT_R()
				if _becd := d.DecodeElement(_ffefg.R, &_dafd); _becd != nil {
					return _becd
				}
				_aaea.EG_OMathMathElements = append(_aaea.EG_OMathMathElements, _ffefg)
			default:
				_e.Log("skipping\u0020unsupported\u0020element\u0020on OMath \u0025v", _dafd.Name)
				if _gdfad := d.Skip(); _gdfad != nil {
					return _gdfad
				}
			}
		case _d.EndElement:
			break _ggdf
		case _d.CharData:
		}
	}
	return nil
}
func NewCT_RPR() *CT_RPR { _gecea := &CT_RPR{}; return _gecea }
func (_bcfe ST_BreakBin) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_bcfe.String(), start)
}

const (
	ST_StyleUnset ST_Style = 0
	ST_StyleP     ST_Style = 1
	ST_StyleB     ST_Style = 2
	ST_StyleI     ST_Style = 3
	ST_StyleBi    ST_Style = 4
)

// Validate validates the CT_Integer255 and its children
func (_cbdb *CT_Integer255) Validate() error { return _cbdb.ValidateWithPath("CT_Integer255") }
func (_adadb *ST_BreakBinSub) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_acdef, _facbc := d.Token()
	if _facbc != nil {
		return _facbc
	}
	if _cbab, _gbgg := _acdef.(_d.EndElement); _gbgg && _cbab.Name == start.Name {
		*_adadb = 1
		return nil
	}
	if _cgede, _gead := _acdef.(_d.CharData); !_gead {
		return _da.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _acdef)
	} else {
		switch string(_cgede) {
		case "":
			*_adadb = 0
		case "\u002d\u002d":
			*_adadb = 1
		case "\u002d\u002b":
			*_adadb = 2
		case "\u002b\u002d":
			*_adadb = 3
		}
	}
	_acdef, _facbc = d.Token()
	if _facbc != nil {
		return _facbc
	}
	if _bebee, _bafab := _acdef.(_d.EndElement); _bafab && _bebee.Name == start.Name {
		return nil
	}
	return _da.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _acdef)
}
func (_dagf *CT_SSupPr) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _dagf.CtrlPr != nil {
		_gggca := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_dagf.CtrlPr, _gggca)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func NewCT_SSubSupPr() *CT_SSubSupPr { _ddb := &CT_SSubSupPr{}; return _ddb }
func (_cgbf *CT_OMathArg) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	if _cgbf.ArgPr != nil {
		_gfae := _d.StartElement{Name: _d.Name{Local: "m:argPr"}}
		e.EncodeElement(_cgbf.ArgPr, _gfae)
	}
	if _cgbf.EG_OMathMathElements != nil {
		for _, _deed := range _cgbf.EG_OMathMathElements {
			_deed.MarshalXML(e, _d.StartElement{})
		}
	}
	if _cgbf.CtrlPr != nil {
		_dagb := _d.StartElement{Name: _d.Name{Local: "m:ctrlPr"}}
		e.EncodeElement(_cgbf.CtrlPr, _dagb)
	}
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func init() {
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Integer255", NewCT_Integer255)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Integer2", NewCT_Integer2)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_SpacingRule", NewCT_SpacingRule)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_UnSignedInteger", NewCT_UnSignedInteger)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Char", NewCT_Char)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_OnOff", NewCT_OnOff)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_String", NewCT_String)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_XAlign", NewCT_XAlign)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_YAlign", NewCT_YAlign)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Shp", NewCT_Shp)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_FType", NewCT_FType)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_LimLoc", NewCT_LimLoc)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_TopBot", NewCT_TopBot)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Script", NewCT_Script)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Style", NewCT_Style)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_ManualBreak", NewCT_ManualBreak)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_RPR", NewCT_RPR)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Text", NewCT_Text)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_R", NewCT_R)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_CtrlPr", NewCT_CtrlPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_AccPr", NewCT_AccPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Acc", NewCT_Acc)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_BarPr", NewCT_BarPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Bar", NewCT_Bar)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_BoxPr", NewCT_BoxPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Box", NewCT_Box)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_BorderBoxPr", NewCT_BorderBoxPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_BorderBox", NewCT_BorderBox)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_DPr", NewCT_DPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_D", NewCT_D)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_EqArrPr", NewCT_EqArrPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_EqArr", NewCT_EqArr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_FPr", NewCT_FPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_F", NewCT_F)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_FuncPr", NewCT_FuncPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Func", NewCT_Func)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_GroupChrPr", NewCT_GroupChrPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_GroupChr", NewCT_GroupChr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_LimLowPr", NewCT_LimLowPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_LimLow", NewCT_LimLow)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_LimUppPr", NewCT_LimUppPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_LimUpp", NewCT_LimUpp)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_MCPr", NewCT_MCPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_MC", NewCT_MC)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_MCS", NewCT_MCS)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_MPr", NewCT_MPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_MR", NewCT_MR)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_M", NewCT_M)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_NaryPr", NewCT_NaryPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Nary", NewCT_Nary)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_PhantPr", NewCT_PhantPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Phant", NewCT_Phant)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_RadPr", NewCT_RadPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_Rad", NewCT_Rad)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_SPrePr", NewCT_SPrePr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_SPre", NewCT_SPre)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_SSubPr", NewCT_SSubPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_SSub", NewCT_SSub)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_SSubSupPr", NewCT_SSubSupPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_SSubSup", NewCT_SSubSup)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_SSupPr", NewCT_SSupPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_SSup", NewCT_SSup)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_OMathArgPr", NewCT_OMathArgPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_OMathArg", NewCT_OMathArg)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_OMathJc", NewCT_OMathJc)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_OMathParaPr", NewCT_OMathParaPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_TwipsMeasure", NewCT_TwipsMeasure)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_BreakBin", NewCT_BreakBin)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_BreakBinSub", NewCT_BreakBinSub)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_MathPr", NewCT_MathPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_OMathPara", NewCT_OMathPara)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "CT_OMath", NewCT_OMath)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "mathPr", NewMathPr)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "oMathPara", NewOMathPara)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "oMath", NewOMath)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "EG_ScriptStyle", NewEG_ScriptStyle)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "EG_OMathMathElements", NewEG_OMathMathElements)
	_e.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002fmath", "EG_OMathElements", NewEG_OMathElements)
}
