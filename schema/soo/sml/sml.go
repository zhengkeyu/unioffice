//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sml

import (
	_f "encoding/xml"
	_bg "fmt"
	_cb "gitee.com/greatmusicians/unioffice"
	_d "gitee.com/greatmusicians/unioffice/schema/soo/dml/spreadsheetDrawing"
	_e "gitee.com/greatmusicians/unioffice/schema/soo/ofc/sharedTypes"
	_g "strconv"
	_fd "strings"
	_b "time"
)

type CT_Font struct {

	// Font Name
	Name []*CT_FontName

	// Character Set
	Charset []*CT_IntProperty

	// Font Family
	Family []*CT_FontFamily

	// Bold
	B []*CT_BooleanProperty

	// Italic
	I []*CT_BooleanProperty

	// Strike Through
	Strike []*CT_BooleanProperty

	// Outline
	Outline []*CT_BooleanProperty

	// Shadow
	Shadow []*CT_BooleanProperty

	// Condense
	Condense []*CT_BooleanProperty

	// Extend
	Extend []*CT_BooleanProperty

	// Text Color
	Color []*CT_Color

	// Font Size
	Sz []*CT_FontSize

	// Underline
	U []*CT_UnderlineProperty

	// Text Vertical Alignment
	VertAlign []*CT_VerticalAlignFontProperty

	// Scheme
	Scheme []*CT_FontScheme
}

func NewCT_FontSize() *CT_FontSize { _ffebga := &CT_FontSize{}; return _ffebga }

// Validate validates the CT_DataRef and its children
func (_gfbe *CT_DataRef) Validate() error { return _gfbe.ValidateWithPath("CT_DataRef") }
func (_cebc *CT_DateGroupItem) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cebc.DateTimeGroupingAttr = ST_DateTimeGrouping(1)
	for _, _fafa := range start.Attr {
		if _fafa.Name.Local == "year" {
			_dgecb, _gcbea := _g.ParseUint(_fafa.Value, 10, 16)
			if _gcbea != nil {
				return _gcbea
			}
			_cebc.YearAttr = uint16(_dgecb)
			continue
		}
		if _fafa.Name.Local == "month" {
			_abeae, _abbc := _g.ParseUint(_fafa.Value, 10, 16)
			if _abbc != nil {
				return _abbc
			}
			_aedc := uint16(_abeae)
			_cebc.MonthAttr = &_aedc
			continue
		}
		if _fafa.Name.Local == "day" {
			_ebebe, _cabbd := _g.ParseUint(_fafa.Value, 10, 16)
			if _cabbd != nil {
				return _cabbd
			}
			_ddbaa := uint16(_ebebe)
			_cebc.DayAttr = &_ddbaa
			continue
		}
		if _fafa.Name.Local == "hour" {
			_cgfcd, _cgcff := _g.ParseUint(_fafa.Value, 10, 16)
			if _cgcff != nil {
				return _cgcff
			}
			_fcab := uint16(_cgfcd)
			_cebc.HourAttr = &_fcab
			continue
		}
		if _fafa.Name.Local == "minute" {
			_bcfaf, _gdec := _g.ParseUint(_fafa.Value, 10, 16)
			if _gdec != nil {
				return _gdec
			}
			_fbcec := uint16(_bcfaf)
			_cebc.MinuteAttr = &_fbcec
			continue
		}
		if _fafa.Name.Local == "second" {
			_gfbaed, _afddg := _g.ParseUint(_fafa.Value, 10, 16)
			if _afddg != nil {
				return _afddg
			}
			_ggcee := uint16(_gfbaed)
			_cebc.SecondAttr = &_ggcee
			continue
		}
		if _fafa.Name.Local == "dateTimeGrouping" {
			_cebc.DateTimeGroupingAttr.UnmarshalXMLAttr(_fafa)
			continue
		}
	}
	for {
		_fcaag, _ecbf := d.Token()
		if _ecbf != nil {
			return _bg.Errorf("parsing\u0020CT_DateGroupItem: \u0025s", _ecbf)
		}
		if _bggg, _bebgf := _fcaag.(_f.EndElement); _bebgf && _bggg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_eddea *CT_CustomFilter) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fcegc := range start.Attr {
		if _fcegc.Name.Local == "operator" {
			_eddea.OperatorAttr.UnmarshalXMLAttr(_fcegc)
			continue
		}
		if _fcegc.Name.Local == "val" {
			_fdgag, _beccd := _fcegc.Value, error(nil)
			if _beccd != nil {
				return _beccd
			}
			_eddea.ValAttr = &_fdgag
			continue
		}
	}
	for {
		_beda, _bbbg := d.Token()
		if _bbbg != nil {
			return _bg.Errorf("parsing CT_CustomFilter:\u0020\u0025s", _bbbg)
		}
		if _baegg, _gedcg := _beda.(_f.EndElement); _gedcg && _baegg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_eece *CT_Hyperlinks) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_eabce := _f.StartElement{Name: _f.Name{Local: "ma:hyperlink"}}
	for _, _fgfdd := range _eece.Hyperlink {
		e.EncodeElement(_fgfdd, _eabce)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dfgg *CT_CustomWorkbookViews) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_fdffd:
	for {
		_dfdd, _aegce := d.Token()
		if _aegce != nil {
			return _aegce
		}
		switch _gdddf := _dfdd.(type) {
		case _f.StartElement:
			switch _gdddf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customWorkbookView"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customWorkbookView"}:
				_bfgg := NewCT_CustomWorkbookView()
				if _affcf := d.DecodeElement(_bfgg, &_gdddf); _affcf != nil {
					return _affcf
				}
				_dfgg.CustomWorkbookView = append(_dfgg.CustomWorkbookView, _bfgg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CustomWorkbookViews\u0020\u0025v", _gdddf.Name)
				if _ebbc := d.Skip(); _ebbc != nil {
					return _ebbc
				}
			}
		case _f.EndElement:
			break _fdffd
		case _f.CharData:
		}
	}
	return nil
}
func (_cgcbc ST_RefMode) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_dggac := _f.Attr{}
	_dggac.Name = name
	switch _cgcbc {
	case ST_RefModeUnset:
		_dggac.Value = ""
	case ST_RefModeA1:
		_dggac.Value = "A1"
	case ST_RefModeR1C1:
		_dggac.Value = "R1C1"
	}
	return _dggac, nil
}
func (_gaab *CT_FileRecoveryPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gaab.AutoRecoverAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoRecover"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gaab.AutoRecoverAttr))})
	}
	if _gaab.CrashSaveAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "crashSave"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gaab.CrashSaveAttr))})
	}
	if _gaab.DataExtractLoadAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataExtractLoad"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gaab.DataExtractLoadAttr))})
	}
	if _gaab.RepairLoadAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "repairLoad"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gaab.RepairLoadAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_CellProtection() *CT_CellProtection { _efad := &CT_CellProtection{}; return _efad }

// ValidateWithPath validates the CT_Set and its children, prefixing error messages with path
func (_dfgcg *CT_Set) ValidateWithPath(path string) error {
	if _eacbe := _dfgcg.SortTypeAttr.ValidateWithPath(path + "\u002fSortTypeAttr"); _eacbe != nil {
		return _eacbe
	}
	for _degae, _bdffc := range _dfgcg.Tpls {
		if _gaafg := _bdffc.ValidateWithPath(_bg.Sprintf("%s\u002fTpls\u005b\u0025d\u005d", path, _degae)); _gaafg != nil {
			return _gaafg
		}
	}
	if _dfgcg.SortByTuple != nil {
		if _fedccc := _dfgcg.SortByTuple.ValidateWithPath(path + "\u002fSortByTuple"); _fedccc != nil {
			return _fedccc
		}
	}
	return nil
}
func NewCT_FutureMetadataBlock() *CT_FutureMetadataBlock {
	_cgdee := &CT_FutureMetadataBlock{}
	return _cgdee
}
func NewCT_TableStyleInfo() *CT_TableStyleInfo     { _afefab := &CT_TableStyleInfo{}; return _afefab }
func NewCT_CustomSheetViews() *CT_CustomSheetViews { _dbcc := &CT_CustomSheetViews{}; return _dbcc }
func (_eebce *CT_PivotFilters) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gbeac := range start.Attr {
		if _gbeac.Name.Local == "count" {
			_cgdfe, _dgfeg := _g.ParseUint(_gbeac.Value, 10, 32)
			if _dgfeg != nil {
				return _dgfeg
			}
			_agbega := uint32(_cgdfe)
			_eebce.CountAttr = &_agbega
			continue
		}
	}
_geeac:
	for {
		_bcaac, _efgfe := d.Token()
		if _efgfe != nil {
			return _efgfe
		}
		switch _ddgde := _bcaac.(type) {
		case _f.StartElement:
			switch _ddgde.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "filter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "filter"}:
				_eacgd := NewCT_PivotFilter()
				if _bbegd := d.DecodeElement(_eacgd, &_ddgde); _bbegd != nil {
					return _bbegd
				}
				_eebce.Filter = append(_eebce.Filter, _eacgd)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PivotFilters\u0020\u0025v", _ddgde.Name)
				if _ggbca := d.Skip(); _ggbca != nil {
					return _ggbca
				}
			}
		case _f.EndElement:
			break _geeac
		case _f.CharData:
		}
	}
	return nil
}
func (_efffdf *ST_DataValidationOperator) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_efffdf = 0
	case "between":
		*_efffdf = 1
	case "notBetween":
		*_efffdf = 2
	case "equal":
		*_efffdf = 3
	case "notEqual":
		*_efffdf = 4
	case "lessThan":
		*_efffdf = 5
	case "lessThanOrEqual":
		*_efffdf = 6
	case "greaterThan":
		*_efffdf = 7
	case "greaterThanOrEqual":
		*_efffdf = 8
	}
	return nil
}

// ValidateWithPath validates the CT_Connection and its children, prefixing error messages with path
func (_bgedd *CT_Connection) ValidateWithPath(path string) error {
	if _febag := _bgedd.CredentialsAttr.ValidateWithPath(path + "\u002fCredentialsAttr"); _febag != nil {
		return _febag
	}
	if _bgedd.DbPr != nil {
		if _dcff := _bgedd.DbPr.ValidateWithPath(path + "\u002fDbPr"); _dcff != nil {
			return _dcff
		}
	}
	if _bgedd.OlapPr != nil {
		if _cfag := _bgedd.OlapPr.ValidateWithPath(path + "\u002fOlapPr"); _cfag != nil {
			return _cfag
		}
	}
	if _bgedd.WebPr != nil {
		if _aeabe := _bgedd.WebPr.ValidateWithPath(path + "\u002fWebPr"); _aeabe != nil {
			return _aeabe
		}
	}
	if _bgedd.TextPr != nil {
		if _dfdba := _bgedd.TextPr.ValidateWithPath(path + "\u002fTextPr"); _dfdba != nil {
			return _dfdba
		}
	}
	if _bgedd.Parameters != nil {
		if _ccfc := _bgedd.Parameters.ValidateWithPath(path + "/Parameters"); _ccfc != nil {
			return _ccfc
		}
	}
	if _bgedd.ExtLst != nil {
		if _afcae := _bgedd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _afcae != nil {
			return _afcae
		}
	}
	return nil
}
func (_eeegf ST_TextHAlign) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_fcbge := _f.Attr{}
	_fcbge.Name = name
	switch _eeegf {
	case ST_TextHAlignUnset:
		_fcbge.Value = ""
	case ST_TextHAlignLeft:
		_fcbge.Value = "left"
	case ST_TextHAlignCenter:
		_fcbge.Value = "center"
	case ST_TextHAlignRight:
		_fcbge.Value = "right"
	case ST_TextHAlignJustify:
		_fcbge.Value = "justify"
	case ST_TextHAlignDistributed:
		_fcbge.Value = "distributed"
	}
	return _fcbge, nil
}
func (_bdbbdf ST_FileType) Validate() error { return _bdbbdf.ValidateWithPath("") }

type CT_CommentList struct {

	// Comment
	Comment []*CT_Comment
}

func (_eddb *CT_DiscretePr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _eddb.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_eddb.CountAttr)})
	}
	e.EncodeToken(start)
	_egcb := _f.StartElement{Name: _f.Name{Local: "ma:x"}}
	for _, _fceddc := range _eddb.X {
		e.EncodeElement(_fceddc, _egcb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bbgg *CT_CacheHierarchy) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dcdg := range start.Attr {
		if _dcdg.Name.Local == "dimensionUniqueName" {
			_dffe, _ggc := _dcdg.Value, error(nil)
			if _ggc != nil {
				return _ggc
			}
			_bbgg.DimensionUniqueNameAttr = &_dffe
			continue
		}
		if _dcdg.Name.Local == "displayFolder" {
			_ggeca, _faaf := _dcdg.Value, error(nil)
			if _faaf != nil {
				return _faaf
			}
			_bbgg.DisplayFolderAttr = &_ggeca
			continue
		}
		if _dcdg.Name.Local == "caption" {
			_ade, _ccab := _dcdg.Value, error(nil)
			if _ccab != nil {
				return _ccab
			}
			_bbgg.CaptionAttr = &_ade
			continue
		}
		if _dcdg.Name.Local == "measureGroup" {
			_gae, _bddee := _dcdg.Value, error(nil)
			if _bddee != nil {
				return _bddee
			}
			_bbgg.MeasureGroupAttr = &_gae
			continue
		}
		if _dcdg.Name.Local == "set" {
			_bcf, _gafd := _g.ParseBool(_dcdg.Value)
			if _gafd != nil {
				return _gafd
			}
			_bbgg.SetAttr = &_bcf
			continue
		}
		if _dcdg.Name.Local == "measures" {
			_dcde, _ecg := _g.ParseBool(_dcdg.Value)
			if _ecg != nil {
				return _ecg
			}
			_bbgg.MeasuresAttr = &_dcde
			continue
		}
		if _dcdg.Name.Local == "iconSet" {
			_abec, _gadb := _g.ParseInt(_dcdg.Value, 10, 32)
			if _gadb != nil {
				return _gadb
			}
			_gfb := int32(_abec)
			_bbgg.IconSetAttr = &_gfb
			continue
		}
		if _dcdg.Name.Local == "count" {
			_cbed, _gcf := _g.ParseUint(_dcdg.Value, 10, 32)
			if _gcf != nil {
				return _gcf
			}
			_bbgg.CountAttr = uint32(_cbed)
			continue
		}
		if _dcdg.Name.Local == "time" {
			_eceg, _adfd := _g.ParseBool(_dcdg.Value)
			if _adfd != nil {
				return _adfd
			}
			_bbgg.TimeAttr = &_eceg
			continue
		}
		if _dcdg.Name.Local == "oneField" {
			_bdca, _ggeg := _g.ParseBool(_dcdg.Value)
			if _ggeg != nil {
				return _ggeg
			}
			_bbgg.OneFieldAttr = &_bdca
			continue
		}
		if _dcdg.Name.Local == "memberValueDatatype" {
			_gacf, _cfgf := _g.ParseUint(_dcdg.Value, 10, 16)
			if _cfgf != nil {
				return _cfgf
			}
			_eacf := uint16(_gacf)
			_bbgg.MemberValueDatatypeAttr = &_eacf
			continue
		}
		if _dcdg.Name.Local == "unbalancedGroup" {
			_edc, _bece := _g.ParseBool(_dcdg.Value)
			if _bece != nil {
				return _bece
			}
			_bbgg.UnbalancedGroupAttr = &_edc
			continue
		}
		if _dcdg.Name.Local == "parentSet" {
			_eabf, _ffg := _g.ParseUint(_dcdg.Value, 10, 32)
			if _ffg != nil {
				return _ffg
			}
			_fad := uint32(_eabf)
			_bbgg.ParentSetAttr = &_fad
			continue
		}
		if _dcdg.Name.Local == "defaultMemberUniqueName" {
			_beef, _bge := _dcdg.Value, error(nil)
			if _bge != nil {
				return _bge
			}
			_bbgg.DefaultMemberUniqueNameAttr = &_beef
			continue
		}
		if _dcdg.Name.Local == "measure" {
			_fdcb, _eaa := _g.ParseBool(_dcdg.Value)
			if _eaa != nil {
				return _eaa
			}
			_bbgg.MeasureAttr = &_fdcb
			continue
		}
		if _dcdg.Name.Local == "unbalanced" {
			_aaef, _fage := _g.ParseBool(_dcdg.Value)
			if _fage != nil {
				return _fage
			}
			_bbgg.UnbalancedAttr = &_aaef
			continue
		}
		if _dcdg.Name.Local == "allCaption" {
			_abf, _cee := _dcdg.Value, error(nil)
			if _cee != nil {
				return _cee
			}
			_bbgg.AllCaptionAttr = &_abf
			continue
		}
		if _dcdg.Name.Local == "hidden" {
			_edgea, _cbdda := _g.ParseBool(_dcdg.Value)
			if _cbdda != nil {
				return _cbdda
			}
			_bbgg.HiddenAttr = &_edgea
			continue
		}
		if _dcdg.Name.Local == "attribute" {
			_cgd, _dbfe := _g.ParseBool(_dcdg.Value)
			if _dbfe != nil {
				return _dbfe
			}
			_bbgg.AttributeAttr = &_cgd
			continue
		}
		if _dcdg.Name.Local == "allUniqueName" {
			_dadd, _ddaa := _dcdg.Value, error(nil)
			if _ddaa != nil {
				return _ddaa
			}
			_bbgg.AllUniqueNameAttr = &_dadd
			continue
		}
		if _dcdg.Name.Local == "uniqueName" {
			_gbge, _gaggg := _dcdg.Value, error(nil)
			if _gaggg != nil {
				return _gaggg
			}
			_bbgg.UniqueNameAttr = _gbge
			continue
		}
		if _dcdg.Name.Local == "keyAttribute" {
			_daa, _ceff := _g.ParseBool(_dcdg.Value)
			if _ceff != nil {
				return _ceff
			}
			_bbgg.KeyAttributeAttr = &_daa
			continue
		}
	}
_gdeg:
	for {
		_afbaa, _ccadd := d.Token()
		if _ccadd != nil {
			return _ccadd
		}
		switch _badb := _afbaa.(type) {
		case _f.StartElement:
			switch _badb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fieldsUsage"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fieldsUsage"}:
				_bbgg.FieldsUsage = NewCT_FieldsUsage()
				if _egbg := d.DecodeElement(_bbgg.FieldsUsage, &_badb); _egbg != nil {
					return _egbg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "groupLevels"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "groupLevels"}:
				_bbgg.GroupLevels = NewCT_GroupLevels()
				if _bdce := d.DecodeElement(_bbgg.GroupLevels, &_badb); _bdce != nil {
					return _bdce
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bbgg.ExtLst = NewCT_ExtensionList()
				if _efgg := d.DecodeElement(_bbgg.ExtLst, &_badb); _efgg != nil {
					return _efgg
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_CacheHierarchy\u0020\u0025v", _badb.Name)
				if _ebbe := d.Skip(); _ebbe != nil {
					return _ebbe
				}
			}
		case _f.EndElement:
			break _gdeg
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_QueryTable and its children
func (_dfdaa *CT_QueryTable) Validate() error { return _dfdaa.ValidateWithPath("CT_QueryTable") }
func NewCT_MeasureDimensionMaps() *CT_MeasureDimensionMaps {
	_cdadg := &CT_MeasureDimensionMaps{}
	return _cdadg
}
func (_aac *CT_CalculatedMember) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _aac.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "mdx"}, Value: _bg.Sprintf("\u0025v", _aac.MdxAttr)})
	if _aac.MemberNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "memberName"}, Value: _bg.Sprintf("\u0025v", *_aac.MemberNameAttr)})
	}
	if _aac.HierarchyAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hierarchy"}, Value: _bg.Sprintf("\u0025v", *_aac.HierarchyAttr)})
	}
	if _aac.ParentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "parent"}, Value: _bg.Sprintf("\u0025v", *_aac.ParentAttr)})
	}
	if _aac.SolveOrderAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "solveOrder"}, Value: _bg.Sprintf("\u0025v", *_aac.SolveOrderAttr)})
	}
	if _aac.SetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "set"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aac.SetAttr))})
	}
	e.EncodeToken(start)
	if _aac.ExtLst != nil {
		_fcaa := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_aac.ExtLst, _fcaa)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_PageField and its children, prefixing error messages with path
func (_fedcc *CT_PageField) ValidateWithPath(path string) error {
	if _fedcc.ExtLst != nil {
		if _aeed := _fedcc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _aeed != nil {
			return _aeed
		}
	}
	return nil
}
func (_bdccfc ST_VolValueType) ValidateWithPath(path string) error {
	switch _bdccfc {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bdccfc))
	}
	return nil
}

// Validate validates the CT_Connection and its children
func (_baeef *CT_Connection) Validate() error { return _baeef.ValidateWithPath("CT_Connection") }

// ValidateWithPath validates the CT_IntProperty and its children, prefixing error messages with path
func (_faefg *CT_IntProperty) ValidateWithPath(path string) error { return nil }
func NewCT_QueryTableField() *CT_QueryTableField                  { _bdafc := &CT_QueryTableField{}; return _bdafc }

// ValidateWithPath validates the CT_ServerFormats and its children, prefixing error messages with path
func (_deadgf *CT_ServerFormats) ValidateWithPath(path string) error {
	for _fdbbgc, _eaaeff := range _deadgf.ServerFormat {
		if _dcbgae := _eaaeff.ValidateWithPath(_bg.Sprintf("\u0025s\u002fServerFormat\u005b\u0025d\u005d", path, _fdbbgc)); _dcbgae != nil {
			return _dcbgae
		}
	}
	return nil
}
func NewCT_DataValidations() *CT_DataValidations { _adbcc := &CT_DataValidations{}; return _adbcc }
func (_bedfgb *CT_WebPublishItems) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bbgac := range start.Attr {
		if _bbgac.Name.Local == "count" {
			_egacga, _ebbcce := _g.ParseUint(_bbgac.Value, 10, 32)
			if _ebbcce != nil {
				return _ebbcce
			}
			_fcbadbb := uint32(_egacga)
			_bedfgb.CountAttr = &_fcbadbb
			continue
		}
	}
_eddc:
	for {
		_bdfggf, _cabde := d.Token()
		if _cabde != nil {
			return _cabde
		}
		switch _fbdfd := _bdfggf.(type) {
		case _f.StartElement:
			switch _fbdfd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "webPublishItem"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "webPublishItem"}:
				_egdgfa := NewCT_WebPublishItem()
				if _dcda := d.DecodeElement(_egdgfa, &_fbdfd); _dcda != nil {
					return _dcda
				}
				_bedfgb.WebPublishItem = append(_bedfgb.WebPublishItem, _egdgfa)
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_WebPublishItems\u0020\u0025v", _fbdfd.Name)
				if _fgdfd := d.Skip(); _fgdfd != nil {
					return _fgdfd
				}
			}
		case _f.EndElement:
			break _eddc
		case _f.CharData:
		}
	}
	return nil
}
func (_bagdc *CT_Pane) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cggdgd := range start.Attr {
		if _cggdgd.Name.Local == "xSplit" {
			_efabe, _dfdbad := _g.ParseFloat(_cggdgd.Value, 64)
			if _dfdbad != nil {
				return _dfdbad
			}
			_bagdc.XSplitAttr = &_efabe
			continue
		}
		if _cggdgd.Name.Local == "ySplit" {
			_ceede, _dbccg := _g.ParseFloat(_cggdgd.Value, 64)
			if _dbccg != nil {
				return _dbccg
			}
			_bagdc.YSplitAttr = &_ceede
			continue
		}
		if _cggdgd.Name.Local == "topLeftCell" {
			_fedaab, _gadg := _cggdgd.Value, error(nil)
			if _gadg != nil {
				return _gadg
			}
			_bagdc.TopLeftCellAttr = &_fedaab
			continue
		}
		if _cggdgd.Name.Local == "activePane" {
			_bagdc.ActivePaneAttr.UnmarshalXMLAttr(_cggdgd)
			continue
		}
		if _cggdgd.Name.Local == "state" {
			_bagdc.StateAttr.UnmarshalXMLAttr(_cggdgd)
			continue
		}
	}
	for {
		_dffcf, _dcgeb := d.Token()
		if _dcgeb != nil {
			return _bg.Errorf("parsing\u0020CT_Pane:\u0020\u0025s", _dcgeb)
		}
		if _cebdb, _adfec := _dffcf.(_f.EndElement); _adfec && _cebdb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_daede *CT_FontScheme) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	_efgef, _eede := _daede.ValAttr.MarshalXMLAttr(_f.Name{Local: "val"})
	if _eede != nil {
		return _eede
	}
	start.Attr = append(start.Attr, _efgef)
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_MapInfo and its children, prefixing error messages with path
func (_egbdb *CT_MapInfo) ValidateWithPath(path string) error {
	for _cafea, _cdfad := range _egbdb.Schema {
		if _fgeecc := _cdfad.ValidateWithPath(_bg.Sprintf("\u0025s\u002fSchema\u005b\u0025d\u005d", path, _cafea)); _fgeecc != nil {
			return _fgeecc
		}
	}
	for _fcdeb, _fgdb := range _egbdb.Map {
		if _dgaeb := _fgdb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fMap\u005b\u0025d\u005d", path, _fcdeb)); _dgaeb != nil {
			return _dgaeb
		}
	}
	return nil
}
func (_eggdge *CT_PivotTableStyle) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _eggdge.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_eggdge.NameAttr)})
	}
	if _eggdge.ShowRowHeadersAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showRowHeaders"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eggdge.ShowRowHeadersAttr))})
	}
	if _eggdge.ShowColHeadersAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showColHeaders"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eggdge.ShowColHeadersAttr))})
	}
	if _eggdge.ShowRowStripesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showRowStripes"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eggdge.ShowRowStripesAttr))})
	}
	if _eggdge.ShowColStripesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showColStripes"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eggdge.ShowColStripesAttr))})
	}
	if _eggdge.ShowLastColumnAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showLastColumn"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eggdge.ShowLastColumnAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bfdbb *CT_Filters) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bfdbb.BlankAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "blank"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bfdbb.BlankAttr))})
	}
	if _bfdbb.CalendarTypeAttr != _e.ST_CalendarTypeUnset {
		_ebeab, _fgdeb := _bfdbb.CalendarTypeAttr.MarshalXMLAttr(_f.Name{Local: "calendarType"})
		if _fgdeb != nil {
			return _fgdeb
		}
		start.Attr = append(start.Attr, _ebeab)
	}
	e.EncodeToken(start)
	if _bfdbb.Filter != nil {
		_debba := _f.StartElement{Name: _f.Name{Local: "ma:filter"}}
		for _, _bbfba := range _bfdbb.Filter {
			e.EncodeElement(_bbfba, _debba)
		}
	}
	if _bfdbb.DateGroupItem != nil {
		_aaedc := _f.StartElement{Name: _f.Name{Local: "ma:dateGroupItem"}}
		for _, _afbcfd := range _bfdbb.DateGroupItem {
			e.EncodeElement(_afbcfd, _aaedc)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_PivotCaches struct {

	// PivotCache
	PivotCache []*CT_PivotCache
}

func (_eadc *CT_ExternalLinkChoice) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_egcaa:
	for {
		_cddac, _ccee := d.Token()
		if _ccee != nil {
			return _ccee
		}
		switch _dgbfe := _cddac.(type) {
		case _f.StartElement:
			switch _dgbfe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "externalBook"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "externalBook"}:
				_eadc.ExternalBook = NewCT_ExternalBook()
				if _cgde := d.DecodeElement(_eadc.ExternalBook, &_dgbfe); _cgde != nil {
					return _cgde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ddeLink"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ddeLink"}:
				_eadc.DdeLink = NewCT_DdeLink()
				if _bcbgg := d.DecodeElement(_eadc.DdeLink, &_dgbfe); _bcbgg != nil {
					return _bcbgg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleLink"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleLink"}:
				_eadc.OleLink = NewCT_OleLink()
				if _bfebd := d.DecodeElement(_eadc.OleLink, &_dgbfe); _bfebd != nil {
					return _bfebd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on CT_ExternalLinkChoice\u0020\u0025v", _dgbfe.Name)
				if _fgffa := d.Skip(); _fgffa != nil {
					return _fgffa
				}
			}
		case _f.EndElement:
			break _egcaa
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Tables and its children, prefixing error messages with path
func (_cgbceb *CT_Tables) ValidateWithPath(path string) error {
	for _ggacb, _ffffe := range _cgbceb.M {
		if _gafgdf := _ffffe.ValidateWithPath(_bg.Sprintf("\u0025s\u002fM\u005b\u0025d\u005d", path, _ggacb)); _gafgdf != nil {
			return _gafgdf
		}
	}
	for _fegeag, _dffecg := range _cgbceb.S {
		if _feddf := _dffecg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fS\u005b\u0025d\u005d", path, _fegeag)); _feddf != nil {
			return _feddf
		}
	}
	for _efacg, _fbge := range _cgbceb.X {
		if _dfbedf := _fbge.ValidateWithPath(_bg.Sprintf("\u0025s\u002fX\u005b\u0025d\u005d", path, _efacg)); _dfbedf != nil {
			return _dfbedf
		}
	}
	return nil
}

// Validate validates the AG_RevData and its children
func (_dce *AG_RevData) Validate() error { return _dce.ValidateWithPath("AG_RevData") }

type CT_VolTopicRef struct {

	// Reference
	RAttr string

	// Sheet Id
	SAttr uint32
}

// ValidateWithPath validates the CT_Parameter and its children, prefixing error messages with path
func (_gebeb *CT_Parameter) ValidateWithPath(path string) error {
	if _geebg := _gebeb.ParameterTypeAttr.ValidateWithPath(path + "\u002fParameterTypeAttr"); _geebg != nil {
		return _geebg
	}
	return nil
}
func (_agfde *CT_WebPublishObjects) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ccbgf := range start.Attr {
		if _ccbgf.Name.Local == "count" {
			_fccgd, _ccaaf := _g.ParseUint(_ccbgf.Value, 10, 32)
			if _ccaaf != nil {
				return _ccaaf
			}
			_egadc := uint32(_fccgd)
			_agfde.CountAttr = &_egadc
			continue
		}
	}
_adeea:
	for {
		_ffgfc, _egadd := d.Token()
		if _egadd != nil {
			return _egadd
		}
		switch _ddgffa := _ffgfc.(type) {
		case _f.StartElement:
			switch _ddgffa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "webPublishObject"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "webPublishObject"}:
				_cadbdb := NewCT_WebPublishObject()
				if _eaefef := d.DecodeElement(_cadbdb, &_ddgffa); _eaefef != nil {
					return _eaefef
				}
				_agfde.WebPublishObject = append(_agfde.WebPublishObject, _cadbdb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on\u0020CT_WebPublishObjects\u0020\u0025v", _ddgffa.Name)
				if _aggfb := d.Skip(); _aggfb != nil {
					return _aggfb
				}
			}
		case _f.EndElement:
			break _adeea
		case _f.CharData:
		}
	}
	return nil
}

type CT_DataConsolidate struct {

	// Function Index
	FunctionAttr ST_DataConsolidateFunction

	// Use Starting Column Labels
	StartLabelsAttr *bool

	// Starting Column Labels
	LeftLabelsAttr *bool

	// Labels In Top Row
	TopLabelsAttr *bool

	// Link
	LinkAttr *bool

	// Data Consolidation References
	DataRefs *CT_DataRefs
}
type CT_DataField struct {

	// Data Field Name
	NameAttr *string

	// Field
	FldAttr uint32

	// Subtotal
	SubtotalAttr ST_DataConsolidateFunction

	// Show Data As Display Format
	ShowDataAsAttr ST_ShowDataAs

	// 'Show Data As' Base Field
	BaseFieldAttr *int32

	// 'Show Data As' Base Setting
	BaseItemAttr *uint32

	// Number Format Id
	NumFmtIdAttr *uint32

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}
type CT_ColHierarchiesUsage struct {

	// Items Count
	CountAttr *uint32

	// Column OLAP Hierarchies
	ColHierarchyUsage []*CT_HierarchyUsage
}
type CT_PivotArea struct {

	// Field Index
	FieldAttr *int32

	// Rule Type
	TypeAttr ST_PivotAreaType

	// Data Only
	DataOnlyAttr *bool

	// Labels Only
	LabelOnlyAttr *bool

	// Include Row Grand Total
	GrandRowAttr *bool

	// Include Column Grand Total
	GrandColAttr *bool

	// Cache Index
	CacheIndexAttr *bool

	// Outline
	OutlineAttr *bool

	// Offset Reference
	OffsetAttr *string

	// Collapsed Levels Are Subtotals
	CollapsedLevelsAreSubtotalsAttr *bool

	// Axis
	AxisAttr ST_Axis

	// Field Position
	FieldPositionAttr *uint32

	// References
	References *CT_PivotAreaReferences

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

// Validate validates the CT_OleLink and its children
func (_fdbbb *CT_OleLink) Validate() error { return _fdbbb.ValidateWithPath("CT_OleLink") }
func (_gfgb *CT_PageItem) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _gfgb.NameAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bfdfd ST_VolDepType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_cccbac := _f.Attr{}
	_cccbac.Name = name
	switch _bfdfd {
	case ST_VolDepTypeUnset:
		_cccbac.Value = ""
	case ST_VolDepTypeRealTimeData:
		_cccbac.Value = "realTimeData"
	case ST_VolDepTypeOlapFunctions:
		_cccbac.Value = "olapFunctions"
	}
	return _cccbac, nil
}

// ValidateWithPath validates the CT_QueryTableRefresh and its children, prefixing error messages with path
func (_cdabg *CT_QueryTableRefresh) ValidateWithPath(path string) error {
	if _gbecc := _cdabg.QueryTableFields.ValidateWithPath(path + "\u002fQueryTableFields"); _gbecc != nil {
		return _gbecc
	}
	if _cdabg.QueryTableDeletedFields != nil {
		if _fegac := _cdabg.QueryTableDeletedFields.ValidateWithPath(path + "\u002fQueryTableDeletedFields"); _fegac != nil {
			return _fegac
		}
	}
	if _cdabg.SortState != nil {
		if _aegfb := _cdabg.SortState.ValidateWithPath(path + "\u002fSortState"); _aegfb != nil {
			return _aegfb
		}
	}
	if _cdabg.ExtLst != nil {
		if _fafcg := _cdabg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fafcg != nil {
			return _fafcg
		}
	}
	return nil
}
func (_adeff *CT_RevisionConflict) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fgggdb := range start.Attr {
		if _fgggdb.Name.Local == "sheetId" {
			_bebcbe, _dfccff := _g.ParseUint(_fgggdb.Value, 10, 32)
			if _dfccff != nil {
				return _dfccff
			}
			_dbca := uint32(_bebcbe)
			_adeff.SheetIdAttr = &_dbca
			continue
		}
		if _fgggdb.Name.Local == "rId" {
			_fcbadb, _gbddb := _g.ParseUint(_fgggdb.Value, 10, 32)
			if _gbddb != nil {
				return _gbddb
			}
			_dbegga := uint32(_fcbadb)
			_adeff.RIdAttr = &_dbegga
			continue
		}
		if _fgggdb.Name.Local == "ua" {
			_fgabb, _dagcec := _g.ParseBool(_fgggdb.Value)
			if _dagcec != nil {
				return _dagcec
			}
			_adeff.UaAttr = &_fgabb
			continue
		}
		if _fgggdb.Name.Local == "ra" {
			_gbbge, _ffgbc := _g.ParseBool(_fgggdb.Value)
			if _ffgbc != nil {
				return _ffgbc
			}
			_adeff.RaAttr = &_gbbge
			continue
		}
	}
	for {
		_eacad, _cabafbf := d.Token()
		if _cabafbf != nil {
			return _bg.Errorf("parsing\u0020CT_RevisionConflict:\u0020\u0025s", _cabafbf)
		}
		if _acaba, _fdfeb := _eacad.(_f.EndElement); _fdfeb && _acaba.Name == start.Name {
			break
		}
	}
	return nil
}
func (_adfbfd *CT_ProtectedRanges) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_adfeg:
	for {
		_gaddc, _gffff := d.Token()
		if _gffff != nil {
			return _gffff
		}
		switch _aada := _gaddc.(type) {
		case _f.StartElement:
			switch _aada.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "protectedRange"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "protectedRange"}:
				_bfadb := NewCT_ProtectedRange()
				if _dffba := d.DecodeElement(_bfadb, &_aada); _dffba != nil {
					return _dffba
				}
				_adfbfd.ProtectedRange = append(_adfbfd.ProtectedRange, _bfadb)
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_ProtectedRanges\u0020\u0025v", _aada.Name)
				if _eecdg := d.Skip(); _eecdg != nil {
					return _eecdg
				}
			}
		case _f.EndElement:
			break _adfeg
		case _f.CharData:
		}
	}
	return nil
}
func (_bbdbgb ST_GradientType) ValidateWithPath(path string) error {
	switch _bbdbgb {
	case 0, 1, 2:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bbdbgb))
	}
	return nil
}

// ValidateWithPath validates the CT_CfRule and its children, prefixing error messages with path
func (_cceg *CT_CfRule) ValidateWithPath(path string) error {
	if _ggge := _cceg.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _ggge != nil {
		return _ggge
	}
	if _bffg := _cceg.OperatorAttr.ValidateWithPath(path + "\u002fOperatorAttr"); _bffg != nil {
		return _bffg
	}
	if _eagbb := _cceg.TimePeriodAttr.ValidateWithPath(path + "\u002fTimePeriodAttr"); _eagbb != nil {
		return _eagbb
	}
	if _cceg.ColorScale != nil {
		if _ffga := _cceg.ColorScale.ValidateWithPath(path + "/ColorScale"); _ffga != nil {
			return _ffga
		}
	}
	if _cceg.DataBar != nil {
		if _fcbg := _cceg.DataBar.ValidateWithPath(path + "\u002fDataBar"); _fcbg != nil {
			return _fcbg
		}
	}
	if _cceg.IconSet != nil {
		if _eaba := _cceg.IconSet.ValidateWithPath(path + "\u002fIconSet"); _eaba != nil {
			return _eaba
		}
	}
	if _cceg.ExtLst != nil {
		if _feef := _cceg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _feef != nil {
			return _feef
		}
	}
	return nil
}
func NewCT_DataFields() *CT_DataFields { _dcfgd := &CT_DataFields{}; return _dcfgd }

// ValidateWithPath validates the Dialogsheet and its children, prefixing error messages with path
func (_aaffad *Dialogsheet) ValidateWithPath(path string) error {
	if _fdddff := _aaffad.CT_Dialogsheet.ValidateWithPath(path); _fdddff != nil {
		return _fdddff
	}
	return nil
}
func (_gabcag ST_IconSetType) String() string {
	switch _gabcag {
	case 0:
		return ""
	case 1:
		return "3Arrows"
	case 2:
		return "3ArrowsGray"
	case 3:
		return "3Flags"
	case 4:
		return "3TrafficLights1"
	case 5:
		return "3TrafficLights2"
	case 6:
		return "3Signs"
	case 7:
		return "3Symbols"
	case 8:
		return "3Symbols2"
	case 9:
		return "4Arrows"
	case 10:
		return "4ArrowsGray"
	case 11:
		return "4RedToBlack"
	case 12:
		return "4Rating"
	case 13:
		return "4TrafficLights"
	case 14:
		return "5Arrows"
	case 15:
		return "5ArrowsGray"
	case 16:
		return "5Rating"
	case 17:
		return "5Quarters"
	}
	return ""
}

type CT_Chartsheet struct {

	// Chart Sheet Properties
	SheetPr *CT_ChartsheetPr

	// Chart Sheet Views
	SheetViews *CT_ChartsheetViews

	// Chart Sheet Protection
	SheetProtection *CT_ChartsheetProtection

	// Custom Chart Sheet Views
	CustomSheetViews *CT_CustomChartsheetViews
	PageMargins      *CT_PageMargins
	PageSetup        *CT_CsPageSetup
	HeaderFooter     *CT_HeaderFooter

	// Drawing
	Drawing       *CT_Drawing
	LegacyDrawing *CT_LegacyDrawing

	// Legacy Drawing Reference in Header Footer
	LegacyDrawingHF *CT_LegacyDrawing

	// Drawing Reference in Header Footer
	DrawingHF       *CT_DrawingHF
	Picture         *CT_SheetBackgroundPicture
	WebPublishItems *CT_WebPublishItems
	ExtLst          *CT_ExtensionList
}

func NewCT_AutoFilter() *CT_AutoFilter { _ee := &CT_AutoFilter{}; return _ee }
func (_gfg *CT_Borders) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gfg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_gfg.CountAttr)})
	}
	e.EncodeToken(start)
	if _gfg.Border != nil {
		_dccf := _f.StartElement{Name: _f.Name{Local: "ma:border"}}
		for _, _ced := range _gfg.Border {
			e.EncodeElement(_ced, _dccf)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_Reviewed() *CT_Reviewed { _ecffa := &CT_Reviewed{}; return _ecffa }
func (_eeada ST_DvAspect) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_eeada.String(), start)
}

type CT_CommentPr struct {

	// Locked Flag
	LockedAttr *bool

	// Default Size Flag
	DefaultSizeAttr *bool

	// Print Flag
	PrintAttr *bool

	// Disabled Flag
	DisabledAttr *bool

	// Automatic Fill Flag
	AutoFillAttr *bool

	// Automatic Line Flag
	AutoLineAttr *bool

	// Alternative Text
	AltTextAttr *string

	// Text Horizontal Alignment
	TextHAlignAttr ST_TextHAlign

	// ext Vertical Alignment
	TextVAlignAttr ST_TextVAlign

	// Text Lock Flag
	LockTextAttr *bool

	// Far East Alignment Flag
	JustLastXAttr *bool

	// Automatic Text Scaling Flag
	AutoScaleAttr *bool
	Anchor        *CT_ObjectAnchor
}
type ST_GroupBy byte

func NewCT_TextFields() *CT_TextFields { _deced := &CT_TextFields{}; return _deced }

type CT_CalculatedMember struct {

	// Calculated Member Name
	NameAttr string

	// Calculated Member MDX Formula
	MdxAttr string

	// OLAP Calculated Member Name
	MemberNameAttr *string

	// Hierarchy Name
	HierarchyAttr *string

	// Parent Name
	ParentAttr *string

	// Calculated Members Solve Order
	SolveOrderAttr *int32

	// Set
	SetAttr *bool

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

// ValidateWithPath validates the CT_pivotTableDefinition and its children, prefixing error messages with path
func (_eegdd *CT_pivotTableDefinition) ValidateWithPath(path string) error {
	if _deacf := _eegdd.Location.ValidateWithPath(path + "\u002fLocation"); _deacf != nil {
		return _deacf
	}
	if _eegdd.PivotFields != nil {
		if _eaffce := _eegdd.PivotFields.ValidateWithPath(path + "\u002fPivotFields"); _eaffce != nil {
			return _eaffce
		}
	}
	if _eegdd.RowFields != nil {
		if _agaad := _eegdd.RowFields.ValidateWithPath(path + "\u002fRowFields"); _agaad != nil {
			return _agaad
		}
	}
	if _eegdd.RowItems != nil {
		if _fcdefc := _eegdd.RowItems.ValidateWithPath(path + "\u002fRowItems"); _fcdefc != nil {
			return _fcdefc
		}
	}
	if _eegdd.ColFields != nil {
		if _gcaae := _eegdd.ColFields.ValidateWithPath(path + "\u002fColFields"); _gcaae != nil {
			return _gcaae
		}
	}
	if _eegdd.ColItems != nil {
		if _ebfgg := _eegdd.ColItems.ValidateWithPath(path + "\u002fColItems"); _ebfgg != nil {
			return _ebfgg
		}
	}
	if _eegdd.PageFields != nil {
		if _adbf := _eegdd.PageFields.ValidateWithPath(path + "/PageFields"); _adbf != nil {
			return _adbf
		}
	}
	if _eegdd.DataFields != nil {
		if _feabe := _eegdd.DataFields.ValidateWithPath(path + "/DataFields"); _feabe != nil {
			return _feabe
		}
	}
	if _eegdd.Formats != nil {
		if _ddacaa := _eegdd.Formats.ValidateWithPath(path + "\u002fFormats"); _ddacaa != nil {
			return _ddacaa
		}
	}
	if _eegdd.ConditionalFormats != nil {
		if _ccdefa := _eegdd.ConditionalFormats.ValidateWithPath(path + "\u002fConditionalFormats"); _ccdefa != nil {
			return _ccdefa
		}
	}
	if _eegdd.ChartFormats != nil {
		if _gadbac := _eegdd.ChartFormats.ValidateWithPath(path + "\u002fChartFormats"); _gadbac != nil {
			return _gadbac
		}
	}
	if _eegdd.PivotHierarchies != nil {
		if _cbcagb := _eegdd.PivotHierarchies.ValidateWithPath(path + "\u002fPivotHierarchies"); _cbcagb != nil {
			return _cbcagb
		}
	}
	if _eegdd.PivotTableStyleInfo != nil {
		if _ffddg := _eegdd.PivotTableStyleInfo.ValidateWithPath(path + "/PivotTableStyleInfo"); _ffddg != nil {
			return _ffddg
		}
	}
	if _eegdd.Filters != nil {
		if _cfcab := _eegdd.Filters.ValidateWithPath(path + "\u002fFilters"); _cfcab != nil {
			return _cfcab
		}
	}
	if _eegdd.RowHierarchiesUsage != nil {
		if _fccba := _eegdd.RowHierarchiesUsage.ValidateWithPath(path + "/RowHierarchiesUsage"); _fccba != nil {
			return _fccba
		}
	}
	if _eegdd.ColHierarchiesUsage != nil {
		if _fgaabb := _eegdd.ColHierarchiesUsage.ValidateWithPath(path + "/ColHierarchiesUsage"); _fgaabb != nil {
			return _fgaabb
		}
	}
	if _eegdd.ExtLst != nil {
		if _beccg := _eegdd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _beccg != nil {
			return _beccg
		}
	}
	return nil
}
func (_cbbec ST_DvAspect) String() string {
	switch _cbbec {
	case 0:
		return ""
	case 1:
		return "DVASPECT_CONTENT"
	case 2:
		return "DVASPECT_ICON"
	}
	return ""
}

type CT_FontName struct {

	// String Value
	ValAttr string
}

// ValidateWithPath validates the CT_TableParts and its children, prefixing error messages with path
func (_fbaga *CT_TableParts) ValidateWithPath(path string) error {
	for _gegcc, _efdaa := range _fbaga.TablePart {
		if _gccdf := _efdaa.ValidateWithPath(_bg.Sprintf("\u0025s/TablePart\u005b\u0025d\u005d", path, _gegcc)); _gccdf != nil {
			return _gccdf
		}
	}
	return nil
}
func (_gegb *CT_PivotDimension) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gegb.MeasureAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "measure"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gegb.MeasureAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _gegb.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueName"}, Value: _bg.Sprintf("\u0025v", _gegb.UniqueNameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "caption"}, Value: _bg.Sprintf("\u0025v", _gegb.CaptionAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

const (
	ST_ExternalConnectionTypeUnset   ST_ExternalConnectionType = 0
	ST_ExternalConnectionTypeGeneral ST_ExternalConnectionType = 1
	ST_ExternalConnectionTypeText    ST_ExternalConnectionType = 2
	ST_ExternalConnectionTypeMDY     ST_ExternalConnectionType = 3
	ST_ExternalConnectionTypeDMY     ST_ExternalConnectionType = 4
	ST_ExternalConnectionTypeYMD     ST_ExternalConnectionType = 5
	ST_ExternalConnectionTypeMYD     ST_ExternalConnectionType = 6
	ST_ExternalConnectionTypeDYM     ST_ExternalConnectionType = 7
	ST_ExternalConnectionTypeYDM     ST_ExternalConnectionType = 8
	ST_ExternalConnectionTypeSkip    ST_ExternalConnectionType = 9
	ST_ExternalConnectionTypeEMD     ST_ExternalConnectionType = 10
)

type CT_MeasureDimensionMaps struct {

	// Measure Group Count
	CountAttr *uint32

	// OLAP Measure Group
	Map []*CT_MeasureDimensionMap
}

func (_ccefd *CT_ReviewedRevisions) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ccefd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_ccefd.CountAttr)})
	}
	e.EncodeToken(start)
	_fbgcc := _f.StartElement{Name: _f.Name{Local: "ma:reviewed"}}
	for _, _fbebe := range _ccefd.Reviewed {
		e.EncodeElement(_fbebe, _fbgcc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type EG_ExtensionList struct {

	// Extension
	Ext []*CT_Extension
}

func NewChartsheet() *Chartsheet {
	_bfbdb := &Chartsheet{}
	_bfbdb.CT_Chartsheet = *NewCT_Chartsheet()
	return _bfbdb
}

type CT_Connection struct {

	// Connection Id
	IdAttr uint32

	// Source Database File
	SourceFileAttr *string

	// Connection File
	OdcFileAttr *string

	// Keep Connection Open
	KeepAliveAttr *bool

	// Automatic Refresh Interval
	IntervalAttr *uint32

	// Connection Name
	NameAttr *string

	// Connection Description
	DescriptionAttr *string

	// Database Source Type
	TypeAttr *uint32

	// Reconnection Method
	ReconnectionMethodAttr *uint32

	// Last Refresh Version
	RefreshedVersionAttr uint8

	// Minimum Version Required for Refresh
	MinRefreshableVersionAttr *uint8

	// Save Password
	SavePasswordAttr *bool

	// New Connection
	NewAttr *bool

	// Deleted Connection
	DeletedAttr *bool

	// Only Use Connection File
	OnlyUseConnectionFileAttr *bool

	// Background Refresh
	BackgroundAttr *bool

	// Refresh on Open
	RefreshOnLoadAttr *bool

	// Save Data
	SaveDataAttr *bool

	// Reconnection Method
	CredentialsAttr ST_CredMethod

	// SSO Id
	SingleSignOnIdAttr *string

	// Database Properties
	DbPr *CT_DbPr

	// OLAP Properties
	OlapPr *CT_OlapPr

	// Web Query Properties
	WebPr *CT_WebPr

	// Text Import Settings
	TextPr *CT_TextPr

	// Query Parameters
	Parameters *CT_Parameters

	// Future Feature Data Storage
	ExtLst *CT_ExtensionList
}

func (_cfbgd *CT_Stylesheet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_bcebgf:
	for {
		_fabdb, _bfgcg := d.Token()
		if _bfgcg != nil {
			return _bfgcg
		}
		switch _aegdea := _fabdb.(type) {
		case _f.StartElement:
			switch _aegdea.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "numFmts"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "numFmts"}:
				_cfbgd.NumFmts = NewCT_NumFmts()
				if _cbdba := d.DecodeElement(_cfbgd.NumFmts, &_aegdea); _cbdba != nil {
					return _cbdba
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fonts"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fonts"}:
				_cfbgd.Fonts = NewCT_Fonts()
				if _ddcaee := d.DecodeElement(_cfbgd.Fonts, &_aegdea); _ddcaee != nil {
					return _ddcaee
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fills"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fills"}:
				_cfbgd.Fills = NewCT_Fills()
				if _cfebf := d.DecodeElement(_cfbgd.Fills, &_aegdea); _cfebf != nil {
					return _cfebf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "borders"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "borders"}:
				_cfbgd.Borders = NewCT_Borders()
				if _fdedd := d.DecodeElement(_cfbgd.Borders, &_aegdea); _fdedd != nil {
					return _fdedd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellStyleXfs"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellStyleXfs"}:
				_cfbgd.CellStyleXfs = NewCT_CellStyleXfs()
				if _effbdb := d.DecodeElement(_cfbgd.CellStyleXfs, &_aegdea); _effbdb != nil {
					return _effbdb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellXfs"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellXfs"}:
				_cfbgd.CellXfs = NewCT_CellXfs()
				if _aefd := d.DecodeElement(_cfbgd.CellXfs, &_aegdea); _aefd != nil {
					return _aefd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellStyles"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellStyles"}:
				_cfbgd.CellStyles = NewCT_CellStyles()
				if _defgg := d.DecodeElement(_cfbgd.CellStyles, &_aegdea); _defgg != nil {
					return _defgg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dxfs"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dxfs"}:
				_cfbgd.Dxfs = NewCT_Dxfs()
				if _agaef := d.DecodeElement(_cfbgd.Dxfs, &_aegdea); _agaef != nil {
					return _agaef
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tableStyles"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tableStyles"}:
				_cfbgd.TableStyles = NewCT_TableStyles()
				if _bbedb := d.DecodeElement(_cfbgd.TableStyles, &_aegdea); _bbedb != nil {
					return _bbedb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colors"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colors"}:
				_cfbgd.Colors = NewCT_Colors()
				if _gdfec := d.DecodeElement(_cfbgd.Colors, &_aegdea); _gdfec != nil {
					return _gdfec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_cfbgd.ExtLst = NewCT_ExtensionList()
				if _ecbfb := d.DecodeElement(_cfbgd.ExtLst, &_aegdea); _ecbfb != nil {
					return _ecbfb
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_Stylesheet \u0025v", _aegdea.Name)
				if _dfegg := d.Skip(); _dfegg != nil {
					return _dfegg
				}
			}
		case _f.EndElement:
			break _bcebgf
		case _f.CharData:
		}
	}
	return nil
}

type CT_CellFormula struct {
	TAttr    ST_CellFormulaType
	AcaAttr  *bool
	RefAttr  *string
	Dt2DAttr *bool
	DtrAttr  *bool
	Del1Attr *bool
	Del2Attr *bool
	R1Attr   *string
	R2Attr   *string
	CaAttr   *bool
	SiAttr   *uint32
	BxAttr   *bool
	Content  string
}

// Validate validates the CT_MemberProperties and its children
func (_gfcfa *CT_MemberProperties) Validate() error {
	return _gfcfa.ValidateWithPath("CT_MemberProperties")
}

// ValidateWithPath validates the CT_ChartsheetProtection and its children, prefixing error messages with path
func (_ddbb *CT_ChartsheetProtection) ValidateWithPath(path string) error { return nil }
func NewCT_Mdx() *CT_Mdx                                                  { _ddgbb := &CT_Mdx{}; _ddgbb.FAttr = ST_MdxFunctionType(1); return _ddgbb }

// ValidateWithPath validates the CT_ServerFormat and its children, prefixing error messages with path
func (_fbgaga *CT_ServerFormat) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_PCDKPI and its children
func (_efbacf *CT_PCDKPI) Validate() error { return _efbacf.ValidateWithPath("CT_PCDKPI") }

// ValidateWithPath validates the CT_ConditionalFormats and its children, prefixing error messages with path
func (_abad *CT_ConditionalFormats) ValidateWithPath(path string) error {
	for _eecg, _egbc := range _abad.ConditionalFormat {
		if _caba := _egbc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fConditionalFormat\u005b\u0025d\u005d", path, _eecg)); _caba != nil {
			return _caba
		}
	}
	return nil
}

// Validate validates the CT_ExternalBook and its children
func (_ffgcf *CT_ExternalBook) Validate() error { return _ffgcf.ValidateWithPath("CT_ExternalBook") }
func (_cgcgac *ST_Type) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_abdcg, _dgaab := d.Token()
	if _dgaab != nil {
		return _dgaab
	}
	if _agbea, _cbcgd := _abdcg.(_f.EndElement); _cbcgd && _agbea.Name == start.Name {
		*_cgcgac = 1
		return nil
	}
	if _gfbece, _abafb := _abdcg.(_f.CharData); !_abafb {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _abdcg)
	} else {
		switch string(_gfbece) {
		case "":
			*_cgcgac = 0
		case "none":
			*_cgcgac = 1
		case "all":
			*_cgcgac = 2
		case "row":
			*_cgcgac = 3
		case "column":
			*_cgcgac = 4
		}
	}
	_abdcg, _dgaab = d.Token()
	if _dgaab != nil {
		return _dgaab
	}
	if _gcccd, _gabda := _abdcg.(_f.EndElement); _gabda && _gcccd.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _abdcg)
}

// ValidateWithPath validates the CT_CellWatches and its children, prefixing error messages with path
func (_bddg *CT_CellWatches) ValidateWithPath(path string) error {
	for _ebbec, _gdcg := range _bddg.CellWatch {
		if _affea := _gdcg.ValidateWithPath(_bg.Sprintf("\u0025s/CellWatch\u005b\u0025d\u005d", path, _ebbec)); _affea != nil {
			return _affea
		}
	}
	return nil
}
func NewCT_HierarchyUsage() *CT_HierarchyUsage { _gbcgc := &CT_HierarchyUsage{}; return _gbcgc }

// ValidateWithPath validates the CT_MdxMetadata and its children, prefixing error messages with path
func (_fgdf *CT_MdxMetadata) ValidateWithPath(path string) error {
	for _fgdag, _ceeac := range _fgdf.Mdx {
		if _cbded := _ceeac.ValidateWithPath(_bg.Sprintf("\u0025s\u002fMdx\u005b\u0025d\u005d", path, _fgdag)); _cbded != nil {
			return _cbded
		}
	}
	return nil
}
func (_eafffd *ST_DdeValueType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_eafffd = 0
	case "nil":
		*_eafffd = 1
	case "b":
		*_eafffd = 2
	case "n":
		*_eafffd = 3
	case "e":
		*_eafffd = 4
	case "str":
		*_eafffd = 5
	}
	return nil
}

type CT_ChartsheetView struct {

	// Sheet Tab Selected
	TabSelectedAttr *bool

	// Window Zoom Scale
	ZoomScaleAttr *uint32

	// Workbook View Id
	WorkbookViewIdAttr uint32

	// Zoom To Fit
	ZoomToFitAttr *bool
	ExtLst        *CT_ExtensionList
}

func (_gcdf *CT_ColorFilter) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gcdf.DxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dxfId"}, Value: _bg.Sprintf("\u0025v", *_gcdf.DxfIdAttr)})
	}
	if _gcdf.CellColorAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cellColor"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdf.CellColorAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_addbef ST_VerticalAlignment) String() string {
	switch _addbef {
	case 0:
		return ""
	case 1:
		return "top"
	case 2:
		return "center"
	case 3:
		return "bottom"
	case 4:
		return "justify"
	case 5:
		return "distributed"
	}
	return ""
}
func (_eagb *CT_CellAlignment) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _eagb.HorizontalAttr != ST_HorizontalAlignmentUnset {
		_bfae, _bfca := _eagb.HorizontalAttr.MarshalXMLAttr(_f.Name{Local: "horizontal"})
		if _bfca != nil {
			return _bfca
		}
		start.Attr = append(start.Attr, _bfae)
	}
	if _eagb.VerticalAttr != ST_VerticalAlignmentUnset {
		_bffc, _fbeb := _eagb.VerticalAttr.MarshalXMLAttr(_f.Name{Local: "vertical"})
		if _fbeb != nil {
			return _fbeb
		}
		start.Attr = append(start.Attr, _bffc)
	}
	if _eagb.TextRotationAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "textRotation"}, Value: _bg.Sprintf("\u0025v", *_eagb.TextRotationAttr)})
	}
	if _eagb.WrapTextAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "wrapText"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eagb.WrapTextAttr))})
	}
	if _eagb.IndentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "indent"}, Value: _bg.Sprintf("\u0025v", *_eagb.IndentAttr)})
	}
	if _eagb.RelativeIndentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "relativeIndent"}, Value: _bg.Sprintf("\u0025v", *_eagb.RelativeIndentAttr)})
	}
	if _eagb.JustifyLastLineAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "justifyLastLine"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eagb.JustifyLastLineAttr))})
	}
	if _eagb.ShrinkToFitAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "shrinkToFit"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eagb.ShrinkToFitAttr))})
	}
	if _eagb.ReadingOrderAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "readingOrder"}, Value: _bg.Sprintf("\u0025v", *_eagb.ReadingOrderAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type ST_MdxFunctionType byte

// ValidateWithPath validates the CT_RevisionSheetRename and its children, prefixing error messages with path
func (_cbcbf *CT_RevisionSheetRename) ValidateWithPath(path string) error {
	if _cbcbf.ExtLst != nil {
		if _gecfa := _cbcbf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gecfa != nil {
			return _gecfa
		}
	}
	return nil
}
func NewCT_PivotAreaReferences() *CT_PivotAreaReferences {
	_dbdcg := &CT_PivotAreaReferences{}
	return _dbdcg
}
func (_egdb *CT_CalculatedItem) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_egdb.PivotArea = NewCT_PivotArea()
	for _, _dbbd := range start.Attr {
		if _dbbd.Name.Local == "field" {
			_gbcg, _gaae := _g.ParseUint(_dbbd.Value, 10, 32)
			if _gaae != nil {
				return _gaae
			}
			_gdbf := uint32(_gbcg)
			_egdb.FieldAttr = &_gdbf
			continue
		}
		if _dbbd.Name.Local == "formula" {
			_edcb, _fcbbg := _dbbd.Value, error(nil)
			if _fcbbg != nil {
				return _fcbbg
			}
			_egdb.FormulaAttr = &_edcb
			continue
		}
	}
_daadd:
	for {
		_aaaeg, _dggg := d.Token()
		if _dggg != nil {
			return _dggg
		}
		switch _bbac := _aaaeg.(type) {
		case _f.StartElement:
			switch _bbac.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotArea"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotArea"}:
				if _ggdf := d.DecodeElement(_egdb.PivotArea, &_bbac); _ggdf != nil {
					return _ggdf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_egdb.ExtLst = NewCT_ExtensionList()
				if _gfbd := d.DecodeElement(_egdb.ExtLst, &_bbac); _gfbd != nil {
					return _gfbd
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_CalculatedItem\u0020\u0025v", _bbac.Name)
				if _cbda := d.Skip(); _cbda != nil {
					return _cbda
				}
			}
		case _f.EndElement:
			break _daadd
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ColHierarchiesUsage and its children, prefixing error messages with path
func (_daea *CT_ColHierarchiesUsage) ValidateWithPath(path string) error {
	for _bcfgf, _dabb := range _daea.ColHierarchyUsage {
		if _gafda := _dabb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fColHierarchyUsage\u005b\u0025d\u005d", path, _bcfgf)); _gafda != nil {
			return _gafda
		}
	}
	return nil
}
func (_cggef *CT_ExternalRow) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _daadf := range start.Attr {
		if _daadf.Name.Local == "r" {
			_ecgbg, _cabaf := _g.ParseUint(_daadf.Value, 10, 32)
			if _cabaf != nil {
				return _cabaf
			}
			_cggef.RAttr = uint32(_ecgbg)
			continue
		}
	}
_fecgb:
	for {
		_ccggf, _agfba := d.Token()
		if _agfba != nil {
			return _agfba
		}
		switch _ccgb := _ccggf.(type) {
		case _f.StartElement:
			switch _ccgb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cell"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cell"}:
				_cbbdd := NewCT_ExternalCell()
				if _ccfde := d.DecodeElement(_cbbdd, &_ccgb); _ccfde != nil {
					return _ccfde
				}
				_cggef.Cell = append(_cggef.Cell, _cbbdd)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ExternalRow\u0020\u0025v", _ccgb.Name)
				if _cgbbc := d.Skip(); _cgbbc != nil {
					return _cgbbc
				}
			}
		case _f.EndElement:
			break _fecgb
		case _f.CharData:
		}
	}
	return nil
}
func (_egggcc ST_Scope) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_egggcc.String(), start)
}
func NewCT_FileVersion() *CT_FileVersion { _adfce := &CT_FileVersion{}; return _adfce }
func (_dbgab *CT_WebPublishing) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _debaa := range start.Attr {
		if _debaa.Name.Local == "css" {
			_cefbf, _daabe := _g.ParseBool(_debaa.Value)
			if _daabe != nil {
				return _daabe
			}
			_dbgab.CssAttr = &_cefbf
			continue
		}
		if _debaa.Name.Local == "thicket" {
			_bbfaa, _fedcg := _g.ParseBool(_debaa.Value)
			if _fedcg != nil {
				return _fedcg
			}
			_dbgab.ThicketAttr = &_bbfaa
			continue
		}
		if _debaa.Name.Local == "longFileNames" {
			_gbeaad, _gceab := _g.ParseBool(_debaa.Value)
			if _gceab != nil {
				return _gceab
			}
			_dbgab.LongFileNamesAttr = &_gbeaad
			continue
		}
		if _debaa.Name.Local == "vml" {
			_gcfdd, _ggeec := _g.ParseBool(_debaa.Value)
			if _ggeec != nil {
				return _ggeec
			}
			_dbgab.VmlAttr = &_gcfdd
			continue
		}
		if _debaa.Name.Local == "allowPng" {
			_ffaag, _adecc := _g.ParseBool(_debaa.Value)
			if _adecc != nil {
				return _adecc
			}
			_dbgab.AllowPngAttr = &_ffaag
			continue
		}
		if _debaa.Name.Local == "targetScreenSize" {
			_dbgab.TargetScreenSizeAttr.UnmarshalXMLAttr(_debaa)
			continue
		}
		if _debaa.Name.Local == "dpi" {
			_cfaac, _gbecgc := _g.ParseUint(_debaa.Value, 10, 32)
			if _gbecgc != nil {
				return _gbecgc
			}
			_cgadcg := uint32(_cfaac)
			_dbgab.DpiAttr = &_cgadcg
			continue
		}
		if _debaa.Name.Local == "codePage" {
			_egdaed, _ecfdg := _g.ParseUint(_debaa.Value, 10, 32)
			if _ecfdg != nil {
				return _ecfdg
			}
			_ccgce := uint32(_egdaed)
			_dbgab.CodePageAttr = &_ccgce
			continue
		}
		if _debaa.Name.Local == "characterSet" {
			_ebfaea, _gebac := _debaa.Value, error(nil)
			if _gebac != nil {
				return _gebac
			}
			_dbgab.CharacterSetAttr = &_ebfaea
			continue
		}
	}
	for {
		_dgabef, _cgdbec := d.Token()
		if _cgdbec != nil {
			return _bg.Errorf("parsing\u0020CT_WebPublishing: \u0025s", _cgdbec)
		}
		if _becadb, _cfeae := _dgabef.(_f.EndElement); _cfeae && _becadb.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Tables() *CT_Tables { _defaf := &CT_Tables{}; return _defaf }
func (_dagff *CT_Worksheet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _dagff.SheetPr != nil {
		_dfcda := _f.StartElement{Name: _f.Name{Local: "ma:sheetPr"}}
		e.EncodeElement(_dagff.SheetPr, _dfcda)
	}
	if _dagff.Dimension != nil {
		_cfdde := _f.StartElement{Name: _f.Name{Local: "ma:dimension"}}
		e.EncodeElement(_dagff.Dimension, _cfdde)
	}
	if _dagff.SheetViews != nil {
		_ddeea := _f.StartElement{Name: _f.Name{Local: "ma:sheetViews"}}
		e.EncodeElement(_dagff.SheetViews, _ddeea)
	}
	if _dagff.SheetFormatPr != nil {
		_ecccgd := _f.StartElement{Name: _f.Name{Local: "ma:sheetFormatPr"}}
		e.EncodeElement(_dagff.SheetFormatPr, _ecccgd)
	}
	if _dagff.Cols != nil {
		_gfgfe := _f.StartElement{Name: _f.Name{Local: "ma:cols"}}
		for _, _caeef := range _dagff.Cols {
			e.EncodeElement(_caeef, _gfgfe)
		}
	}
	_aafba := _f.StartElement{Name: _f.Name{Local: "ma:sheetData"}}
	e.EncodeElement(_dagff.SheetData, _aafba)
	if _dagff.SheetCalcPr != nil {
		_gffcd := _f.StartElement{Name: _f.Name{Local: "ma:sheetCalcPr"}}
		e.EncodeElement(_dagff.SheetCalcPr, _gffcd)
	}
	if _dagff.SheetProtection != nil {
		_bdeff := _f.StartElement{Name: _f.Name{Local: "ma:sheetProtection"}}
		e.EncodeElement(_dagff.SheetProtection, _bdeff)
	}
	if _dagff.ProtectedRanges != nil {
		_eegba := _f.StartElement{Name: _f.Name{Local: "ma:protectedRanges"}}
		e.EncodeElement(_dagff.ProtectedRanges, _eegba)
	}
	if _dagff.Scenarios != nil {
		_dbeff := _f.StartElement{Name: _f.Name{Local: "ma:scenarios"}}
		e.EncodeElement(_dagff.Scenarios, _dbeff)
	}
	if _dagff.AutoFilter != nil {
		_gegdd := _f.StartElement{Name: _f.Name{Local: "ma:autoFilter"}}
		e.EncodeElement(_dagff.AutoFilter, _gegdd)
	}
	if _dagff.SortState != nil {
		_eegfc := _f.StartElement{Name: _f.Name{Local: "ma:sortState"}}
		e.EncodeElement(_dagff.SortState, _eegfc)
	}
	if _dagff.DataConsolidate != nil {
		_ggfgd := _f.StartElement{Name: _f.Name{Local: "ma:dataConsolidate"}}
		e.EncodeElement(_dagff.DataConsolidate, _ggfgd)
	}
	if _dagff.CustomSheetViews != nil {
		_ebcbe := _f.StartElement{Name: _f.Name{Local: "ma:customSheetViews"}}
		e.EncodeElement(_dagff.CustomSheetViews, _ebcbe)
	}
	if _dagff.MergeCells != nil {
		_ddege := _f.StartElement{Name: _f.Name{Local: "ma:mergeCells"}}
		e.EncodeElement(_dagff.MergeCells, _ddege)
	}
	if _dagff.PhoneticPr != nil {
		_edcdd := _f.StartElement{Name: _f.Name{Local: "ma:phoneticPr"}}
		e.EncodeElement(_dagff.PhoneticPr, _edcdd)
	}
	if _dagff.ConditionalFormatting != nil {
		_bddfa := _f.StartElement{Name: _f.Name{Local: "ma:conditionalFormatting"}}
		for _, _gadega := range _dagff.ConditionalFormatting {
			e.EncodeElement(_gadega, _bddfa)
		}
	}
	if _dagff.DataValidations != nil {
		_dfffg := _f.StartElement{Name: _f.Name{Local: "ma:dataValidations"}}
		e.EncodeElement(_dagff.DataValidations, _dfffg)
	}
	if _dagff.Hyperlinks != nil {
		_faefe := _f.StartElement{Name: _f.Name{Local: "ma:hyperlinks"}}
		e.EncodeElement(_dagff.Hyperlinks, _faefe)
	}
	if _dagff.PrintOptions != nil {
		_cgbef := _f.StartElement{Name: _f.Name{Local: "ma:printOptions"}}
		e.EncodeElement(_dagff.PrintOptions, _cgbef)
	}
	if _dagff.PageMargins != nil {
		_gcfba := _f.StartElement{Name: _f.Name{Local: "ma:pageMargins"}}
		e.EncodeElement(_dagff.PageMargins, _gcfba)
	}
	if _dagff.PageSetup != nil {
		_fbfga := _f.StartElement{Name: _f.Name{Local: "ma:pageSetup"}}
		e.EncodeElement(_dagff.PageSetup, _fbfga)
	}
	if _dagff.HeaderFooter != nil {
		_dfdca := _f.StartElement{Name: _f.Name{Local: "ma:headerFooter"}}
		e.EncodeElement(_dagff.HeaderFooter, _dfdca)
	}
	if _dagff.RowBreaks != nil {
		_fcfgb := _f.StartElement{Name: _f.Name{Local: "ma:rowBreaks"}}
		e.EncodeElement(_dagff.RowBreaks, _fcfgb)
	}
	if _dagff.ColBreaks != nil {
		_cbedc := _f.StartElement{Name: _f.Name{Local: "ma:colBreaks"}}
		e.EncodeElement(_dagff.ColBreaks, _cbedc)
	}
	if _dagff.CustomProperties != nil {
		_bbced := _f.StartElement{Name: _f.Name{Local: "ma:customProperties"}}
		e.EncodeElement(_dagff.CustomProperties, _bbced)
	}
	if _dagff.CellWatches != nil {
		_afaec := _f.StartElement{Name: _f.Name{Local: "ma:cellWatches"}}
		e.EncodeElement(_dagff.CellWatches, _afaec)
	}
	if _dagff.IgnoredErrors != nil {
		_cbdbff := _f.StartElement{Name: _f.Name{Local: "ma:ignoredErrors"}}
		e.EncodeElement(_dagff.IgnoredErrors, _cbdbff)
	}
	if _dagff.SmartTags != nil {
		_ggage := _f.StartElement{Name: _f.Name{Local: "ma:smartTags"}}
		e.EncodeElement(_dagff.SmartTags, _ggage)
	}
	if _dagff.Drawing != nil {
		_gffde := _f.StartElement{Name: _f.Name{Local: "ma:drawing"}}
		e.EncodeElement(_dagff.Drawing, _gffde)
	}
	if _dagff.LegacyDrawing != nil {
		_fdeff := _f.StartElement{Name: _f.Name{Local: "ma:legacyDrawing"}}
		e.EncodeElement(_dagff.LegacyDrawing, _fdeff)
	}
	if _dagff.LegacyDrawingHF != nil {
		_geefe := _f.StartElement{Name: _f.Name{Local: "ma:legacyDrawingHF"}}
		e.EncodeElement(_dagff.LegacyDrawingHF, _geefe)
	}
	if _dagff.DrawingHF != nil {
		_faebfgb := _f.StartElement{Name: _f.Name{Local: "ma:drawingHF"}}
		e.EncodeElement(_dagff.DrawingHF, _faebfgb)
	}
	if _dagff.Picture != nil {
		_bccab := _f.StartElement{Name: _f.Name{Local: "ma:picture"}}
		e.EncodeElement(_dagff.Picture, _bccab)
	}
	if _dagff.OleObjects != nil {
		_acfaf := _f.StartElement{Name: _f.Name{Local: "ma:oleObjects"}}
		e.EncodeElement(_dagff.OleObjects, _acfaf)
	}
	if _dagff.Controls != nil {
		_abafcb := _f.StartElement{Name: _f.Name{Local: "ma:controls"}}
		e.EncodeElement(_dagff.Controls, _abafcb)
	}
	if _dagff.WebPublishItems != nil {
		_fgccbe := _f.StartElement{Name: _f.Name{Local: "ma:webPublishItems"}}
		e.EncodeElement(_dagff.WebPublishItems, _fgccbe)
	}
	if _dagff.TableParts != nil {
		_aefdb := _f.StartElement{Name: _f.Name{Local: "ma:tableParts"}}
		e.EncodeElement(_dagff.TableParts, _aefdb)
	}
	if _dagff.ExtLst != nil {
		_ebfde := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_dagff.ExtLst, _ebfde)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Extension and its children, prefixing error messages with path
func (_geff *CT_Extension) ValidateWithPath(path string) error { return nil }
func NewCT_Revisions() *CT_Revisions                           { _bbdeg := &CT_Revisions{}; return _bbdeg }
func NewCT_TableFormula() *CT_TableFormula                     { _gdfce := &CT_TableFormula{}; return _gdfce }

// Validate validates the VolTypes and its children
func (_cfefgb *VolTypes) Validate() error { return _cfefgb.ValidateWithPath("VolTypes") }

type ST_RevisionAction byte

func (_gcebf *CT_Tables) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gcebf.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_gcebf.CountAttr)})
	}
	e.EncodeToken(start)
	if _gcebf.M != nil {
		_bceeb := _f.StartElement{Name: _f.Name{Local: "ma:m"}}
		for _, _bddgacf := range _gcebf.M {
			e.EncodeElement(_bddgacf, _bceeb)
		}
	}
	if _gcebf.S != nil {
		_gdgbd := _f.StartElement{Name: _f.Name{Local: "ma:s"}}
		for _, _acgeg := range _gcebf.S {
			e.EncodeElement(_acgeg, _gdgbd)
		}
	}
	if _gcebf.X != nil {
		_gdagb := _f.StartElement{Name: _f.Name{Local: "ma:x"}}
		for _, _fcddg := range _gcebf.X {
			e.EncodeElement(_fcddg, _gdagb)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_BookView and its children, prefixing error messages with path
func (_cbfae *CT_BookView) ValidateWithPath(path string) error {
	if _eae := _cbfae.VisibilityAttr.ValidateWithPath(path + "\u002fVisibilityAttr"); _eae != nil {
		return _eae
	}
	if _cbfae.ExtLst != nil {
		if _bbe := _cbfae.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bbe != nil {
			return _bbe
		}
	}
	return nil
}
func (_fbbaa *ST_Pane) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_fbbaa = 0
	case "bottomRight":
		*_fbbaa = 1
	case "topRight":
		*_fbbaa = 2
	case "bottomLeft":
		*_fbbaa = 3
	case "topLeft":
		*_fbbaa = 4
	}
	return nil
}

// Validate validates the CT_DrawingHF and its children
func (_cdba *CT_DrawingHF) Validate() error { return _cdba.ValidateWithPath("CT_DrawingHF") }
func (_febbc *ST_CellFormulaType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_febbc = 0
	case "normal":
		*_febbc = 1
	case "array":
		*_febbc = 2
	case "dataTable":
		*_febbc = 3
	case "shared":
		*_febbc = 4
	}
	return nil
}
func (_gbcbe ST_Axis) String() string {
	switch _gbcbe {
	case 0:
		return ""
	case 1:
		return "axisRow"
	case 2:
		return "axisCol"
	case 3:
		return "axisPage"
	case 4:
		return "axisValues"
	}
	return ""
}

// ValidateWithPath validates the CT_SheetViews and its children, prefixing error messages with path
func (_ccdff *CT_SheetViews) ValidateWithPath(path string) error {
	for _dccdg, _aaafd := range _ccdff.SheetView {
		if _ggcce := _aaafd.ValidateWithPath(_bg.Sprintf("\u0025s/SheetView\u005b\u0025d\u005d", path, _dccdg)); _ggcce != nil {
			return _ggcce
		}
	}
	if _ccdff.ExtLst != nil {
		if _gdbda := _ccdff.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gdbda != nil {
			return _gdbda
		}
	}
	return nil
}

type CT_MeasureGroups struct {

	// Measure Group Count
	CountAttr *uint32

	// OLAP Measure Group
	MeasureGroup []*CT_MeasureGroup
}

func NewCT_Tuples() *CT_Tuples { _gdbdd := &CT_Tuples{}; return _gdbdd }
func (_bgaebg *CT_Pages) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _edcacc := range start.Attr {
		if _edcacc.Name.Local == "count" {
			_agebef, _fcggba := _g.ParseUint(_edcacc.Value, 10, 32)
			if _fcggba != nil {
				return _fcggba
			}
			_fdag := uint32(_agebef)
			_bgaebg.CountAttr = &_fdag
			continue
		}
	}
_bbge:
	for {
		_cbeba, _fefeg := d.Token()
		if _fefeg != nil {
			return _fefeg
		}
		switch _ecadgb := _cbeba.(type) {
		case _f.StartElement:
			switch _ecadgb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "page"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "page"}:
				_cefb := NewCT_PCDSCPage()
				if _caacc := d.DecodeElement(_cefb, &_ecadgb); _caacc != nil {
					return _caacc
				}
				_bgaebg.Page = append(_bgaebg.Page, _cefb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Pages\u0020\u0025v", _ecadgb.Name)
				if _fagcc := d.Skip(); _fagcc != nil {
					return _fagcc
				}
			}
		case _f.EndElement:
			break _bbge
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_Col() *CT_Col { _fegea := &CT_Col{}; return _fegea }
func (_eaed *CT_Borders) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _feea := range start.Attr {
		if _feea.Name.Local == "count" {
			_fdgd, _ddd := _g.ParseUint(_feea.Value, 10, 32)
			if _ddd != nil {
				return _ddd
			}
			_dgce := uint32(_fdgd)
			_eaed.CountAttr = &_dgce
			continue
		}
	}
_bdda:
	for {
		_dba, _eefb := d.Token()
		if _eefb != nil {
			return _eefb
		}
		switch _gdcc := _dba.(type) {
		case _f.StartElement:
			switch _gdcc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "border"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "border"}:
				_dcca := NewCT_Border()
				if _eba := d.DecodeElement(_dcca, &_gdcc); _eba != nil {
					return _eba
				}
				_eaed.Border = append(_eaed.Border, _dcca)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_Borders\u0020\u0025v", _gdcc.Name)
				if _bfe := d.Skip(); _bfe != nil {
					return _bfe
				}
			}
		case _f.EndElement:
			break _bdda
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CellSmartTagPr and its children, prefixing error messages with path
func (_acfa *CT_CellSmartTagPr) ValidateWithPath(path string) error { return nil }
func NewCT_PCDSCPage() *CT_PCDSCPage                                { _ecedbb := &CT_PCDSCPage{}; return _ecedbb }
func (_fbfb *CT_Cols) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_ebfa := _f.StartElement{Name: _f.Name{Local: "ma:col"}}
	for _, _fefec := range _fbfb.Col {
		e.EncodeElement(_fefec, _ebfa)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_DefinedNames and its children, prefixing error messages with path
func (_dcga *CT_DefinedNames) ValidateWithPath(path string) error {
	for _bdaga, _edcgg := range _dcga.DefinedName {
		if _ccfbg := _edcgg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fDefinedName\u005b\u0025d\u005d", path, _bdaga)); _ccfbg != nil {
			return _ccfbg
		}
	}
	return nil
}
func (_acbbfb ST_MdxKPIProperty) String() string {
	switch _acbbfb {
	case 0:
		return ""
	case 1:
		return "v"
	case 2:
		return "g"
	case 3:
		return "s"
	case 4:
		return "t"
	case 5:
		return "w"
	case 6:
		return "m"
	}
	return ""
}

// ValidateWithPath validates the CT_FunctionGroups and its children, prefixing error messages with path
func (_ecadaf *CT_FunctionGroups) ValidateWithPath(path string) error {
	for _bageb, _deeac := range _ecadaf.FunctionGroup {
		if _cgaba := _deeac.ValidateWithPath(_bg.Sprintf("%s/FunctionGroup[%d\u005d", path, _bageb)); _cgaba != nil {
			return _cgaba
		}
	}
	return nil
}
func (_badff *CT_HierarchyUsage) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abfbe := range start.Attr {
		if _abfbe.Name.Local == "hierarchyUsage" {
			_gcbgg, _dcebb := _g.ParseInt(_abfbe.Value, 10, 32)
			if _dcebb != nil {
				return _dcebb
			}
			_badff.HierarchyUsageAttr = int32(_gcbgg)
			continue
		}
	}
	for {
		_beead, _bcdf := d.Token()
		if _bcdf != nil {
			return _bg.Errorf("parsing\u0020CT_HierarchyUsage: \u0025s", _bcdf)
		}
		if _dfaag, _adce := _beead.(_f.EndElement); _adce && _dfaag.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CalculatedMembers and its children, prefixing error messages with path
func (_cgab *CT_CalculatedMembers) ValidateWithPath(path string) error {
	for _egbb, _abce := range _cgab.CalculatedMember {
		if _abbb := _abce.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCalculatedMember\u005b\u0025d\u005d", path, _egbb)); _abbb != nil {
			return _abbb
		}
	}
	return nil
}
func (_cgbad *CT_Scenario) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _edebc := range start.Attr {
		if _edebc.Name.Local == "name" {
			_cgdadg, _fdebfc := _edebc.Value, error(nil)
			if _fdebfc != nil {
				return _fdebfc
			}
			_cgbad.NameAttr = _cgdadg
			continue
		}
		if _edebc.Name.Local == "locked" {
			_bcabc, _bdbed := _g.ParseBool(_edebc.Value)
			if _bdbed != nil {
				return _bdbed
			}
			_cgbad.LockedAttr = &_bcabc
			continue
		}
		if _edebc.Name.Local == "hidden" {
			_egeg, _dbbcb := _g.ParseBool(_edebc.Value)
			if _dbbcb != nil {
				return _dbbcb
			}
			_cgbad.HiddenAttr = &_egeg
			continue
		}
		if _edebc.Name.Local == "count" {
			_gcddde, _bgbgd := _g.ParseUint(_edebc.Value, 10, 32)
			if _bgbgd != nil {
				return _bgbgd
			}
			_bcbgc := uint32(_gcddde)
			_cgbad.CountAttr = &_bcbgc
			continue
		}
		if _edebc.Name.Local == "user" {
			_edfga, _bedff := _edebc.Value, error(nil)
			if _bedff != nil {
				return _bedff
			}
			_cgbad.UserAttr = &_edfga
			continue
		}
		if _edebc.Name.Local == "comment" {
			_acfdfa, _fgfgb := _edebc.Value, error(nil)
			if _fgfgb != nil {
				return _fgfgb
			}
			_cgbad.CommentAttr = &_acfdfa
			continue
		}
	}
_effbdg:
	for {
		_degegb, _abdfe := d.Token()
		if _abdfe != nil {
			return _abdfe
		}
		switch _aaade := _degegb.(type) {
		case _f.StartElement:
			switch _aaade.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "inputCells"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "inputCells"}:
				_gcdff := NewCT_InputCells()
				if _accd := d.DecodeElement(_gcdff, &_aaade); _accd != nil {
					return _accd
				}
				_cgbad.InputCells = append(_cgbad.InputCells, _gcdff)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Scenario\u0020\u0025v", _aaade.Name)
				if _cdccb := d.Skip(); _cdccb != nil {
					return _cdccb
				}
			}
		case _f.EndElement:
			break _effbdg
		case _f.CharData:
		}
	}
	return nil
}
func (_degab *CT_RangeSet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aggcdg := range start.Attr {
		if _aggcdg.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _aggcdg.Name.Local == "id" || _aggcdg.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _aggcdg.Name.Local == "id" {
			_bagfe, _abgfc := _aggcdg.Value, error(nil)
			if _abgfc != nil {
				return _abgfc
			}
			_degab.IdAttr = &_bagfe
			continue
		}
		if _aggcdg.Name.Local == "i1" {
			_gfeffa, _caga := _g.ParseUint(_aggcdg.Value, 10, 32)
			if _caga != nil {
				return _caga
			}
			_cgeab := uint32(_gfeffa)
			_degab.I1Attr = &_cgeab
			continue
		}
		if _aggcdg.Name.Local == "i3" {
			_bageg, _deddbg := _g.ParseUint(_aggcdg.Value, 10, 32)
			if _deddbg != nil {
				return _deddbg
			}
			_bdgbf := uint32(_bageg)
			_degab.I3Attr = &_bdgbf
			continue
		}
		if _aggcdg.Name.Local == "i4" {
			_adgba, _affeg := _g.ParseUint(_aggcdg.Value, 10, 32)
			if _affeg != nil {
				return _affeg
			}
			_dagcea := uint32(_adgba)
			_degab.I4Attr = &_dagcea
			continue
		}
		if _aggcdg.Name.Local == "ref" {
			_gfecb, _eecddd := _aggcdg.Value, error(nil)
			if _eecddd != nil {
				return _eecddd
			}
			_degab.RefAttr = &_gfecb
			continue
		}
		if _aggcdg.Name.Local == "name" {
			_beegc, _ffbedc := _aggcdg.Value, error(nil)
			if _ffbedc != nil {
				return _ffbedc
			}
			_degab.NameAttr = &_beegc
			continue
		}
		if _aggcdg.Name.Local == "sheet" {
			_gcdgc, _cgede := _aggcdg.Value, error(nil)
			if _cgede != nil {
				return _cgede
			}
			_degab.SheetAttr = &_gcdgc
			continue
		}
		if _aggcdg.Name.Local == "i2" {
			_gcdef, _ebdfg := _g.ParseUint(_aggcdg.Value, 10, 32)
			if _ebdfg != nil {
				return _ebdfg
			}
			_ecfca := uint32(_gcdef)
			_degab.I2Attr = &_ecfca
			continue
		}
	}
	for {
		_ffgae, _cafgc := d.Token()
		if _cafgc != nil {
			return _bg.Errorf("parsing\u0020CT_RangeSet:\u0020\u0025s", _cafgc)
		}
		if _ebfcff, _aagea := _ffgae.(_f.EndElement); _aagea && _ebfcff.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cadd *CT_DataBar) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cadd.Color = NewCT_Color()
	for _, _bdbfd := range start.Attr {
		if _bdbfd.Name.Local == "minLength" {
			_eebfb, _ccdc := _g.ParseUint(_bdbfd.Value, 10, 32)
			if _ccdc != nil {
				return _ccdc
			}
			_bbagb := uint32(_eebfb)
			_cadd.MinLengthAttr = &_bbagb
			continue
		}
		if _bdbfd.Name.Local == "maxLength" {
			_edfg, _efge := _g.ParseUint(_bdbfd.Value, 10, 32)
			if _efge != nil {
				return _efge
			}
			_ccdgdd := uint32(_edfg)
			_cadd.MaxLengthAttr = &_ccdgdd
			continue
		}
		if _bdbfd.Name.Local == "showValue" {
			_gfceb, _ebdee := _g.ParseBool(_bdbfd.Value)
			if _ebdee != nil {
				return _ebdee
			}
			_cadd.ShowValueAttr = &_gfceb
			continue
		}
	}
_ecbce:
	for {
		_badfa, _efggc := d.Token()
		if _efggc != nil {
			return _efggc
		}
		switch _gffd := _badfa.(type) {
		case _f.StartElement:
			switch _gffd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cfvo"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cfvo"}:
				_cgcc := NewCT_Cfvo()
				if _fgebb := d.DecodeElement(_cgcc, &_gffd); _fgebb != nil {
					return _fgebb
				}
				_cadd.Cfvo = append(_cadd.Cfvo, _cgcc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "color"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "color"}:
				if _aafcf := d.DecodeElement(_cadd.Color, &_gffd); _aafcf != nil {
					return _aafcf
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_DataBar\u0020\u0025v", _gffd.Name)
				if _fafe := d.Skip(); _fafe != nil {
					return _fafe
				}
			}
		case _f.EndElement:
			break _ecbce
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_GroupLevels and its children, prefixing error messages with path
func (_abfba *CT_GroupLevels) ValidateWithPath(path string) error {
	for _aebe, _facacc := range _abfba.GroupLevel {
		if _eeedd := _facacc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fGroupLevel\u005b\u0025d\u005d", path, _aebe)); _eeedd != nil {
			return _eeedd
		}
	}
	return nil
}
func (_fgbda ST_VerticalAlignment) Validate() error { return _fgbda.ValidateWithPath("") }

// ValidateWithPath validates the CT_GradientFill and its children, prefixing error messages with path
func (_bbega *CT_GradientFill) ValidateWithPath(path string) error {
	if _ecfbe := _bbega.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _ecfbe != nil {
		return _ecfbe
	}
	for _babdc, _ceab := range _bbega.Stop {
		if _dcad := _ceab.ValidateWithPath(_bg.Sprintf("%s\u002fStop\u005b\u0025d\u005d", path, _babdc)); _dcad != nil {
			return _dcad
		}
	}
	return nil
}

// Validate validates the CT_PivotField and its children
func (_aeebf *CT_PivotField) Validate() error { return _aeebf.ValidateWithPath("CT_PivotField") }
func (_egfab *CT_DateTime) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gfgga := range start.Attr {
		if _gfgga.Name.Local == "v" {
			_aafdga, _efcc := ParseStdlibTime(_gfgga.Value)
			if _efcc != nil {
				return _efcc
			}
			_egfab.VAttr = _aafdga
			continue
		}
		if _gfgga.Name.Local == "u" {
			_fdfd, _fbed := _g.ParseBool(_gfgga.Value)
			if _fbed != nil {
				return _fbed
			}
			_egfab.UAttr = &_fdfd
			continue
		}
		if _gfgga.Name.Local == "f" {
			_fbfag, _fbcb := _g.ParseBool(_gfgga.Value)
			if _fbcb != nil {
				return _fbcb
			}
			_egfab.FAttr = &_fbfag
			continue
		}
		if _gfgga.Name.Local == "c" {
			_ecce, _cbfab := _gfgga.Value, error(nil)
			if _cbfab != nil {
				return _cbfab
			}
			_egfab.CAttr = &_ecce
			continue
		}
		if _gfgga.Name.Local == "cp" {
			_ffbef, _gefdgf := _g.ParseUint(_gfgga.Value, 10, 32)
			if _gefdgf != nil {
				return _gefdgf
			}
			_degcg := uint32(_ffbef)
			_egfab.CpAttr = &_degcg
			continue
		}
	}
_ddega:
	for {
		_cdbe, _cdag := d.Token()
		if _cdag != nil {
			return _cdag
		}
		switch _gged := _cdbe.(type) {
		case _f.StartElement:
			switch _gged.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "x"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "x"}:
				_eddec := NewCT_X()
				if _aggca := d.DecodeElement(_eddec, &_gged); _aggca != nil {
					return _aggca
				}
				_egfab.X = append(_egfab.X, _eddec)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DateTime\u0020\u0025v", _gged.Name)
				if _cfcbd := d.Skip(); _cfcbd != nil {
					return _cfcbd
				}
			}
		case _f.EndElement:
			break _ddega
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_ColorFilter() *CT_ColorFilter { _bbdbf := &CT_ColorFilter{}; return _bbdbf }
func (_cfdcba ST_PrintError) String() string {
	switch _cfdcba {
	case 0:
		return ""
	case 1:
		return "displayed"
	case 2:
		return "blank"
	case 3:
		return "dash"
	case 4:
		return "NA"
	}
	return ""
}

type CT_DateTime struct {

	// Value
	VAttr _b.Time

	// Unused Item
	UAttr *bool

	// Calculated Item Value
	FAttr *bool

	// Caption
	CAttr *string

	// Member Property Count
	CpAttr *uint32

	// Member Property Index
	X []*CT_X
}

// Validate validates the CT_Sets and its children
func (_bgggda *CT_Sets) Validate() error { return _bgggda.ValidateWithPath("CT_Sets") }

// ValidateWithPath validates the CT_OleItem and its children, prefixing error messages with path
func (_eagba *CT_OleItem) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the AG_AutoFormat and its children, prefixing error messages with path
func (_bd *AG_AutoFormat) ValidateWithPath(path string) error { return nil }
func NewCT_VerticalAlignFontProperty() *CT_VerticalAlignFontProperty {
	_cdege := &CT_VerticalAlignFontProperty{}
	_cdege.ValAttr = _e.ST_VerticalAlignRun(1)
	return _cdege
}
func (_bfabg ST_UnderlineValues) String() string {
	switch _bfabg {
	case 0:
		return ""
	case 1:
		return "single"
	case 2:
		return "double"
	case 3:
		return "singleAccounting"
	case 4:
		return "doubleAccounting"
	case 5:
		return "none"
	}
	return ""
}
func (_dffcb ST_VolDepType) Validate() error { return _dffcb.ValidateWithPath("") }
func (_gdddaee *CT_TableColumns) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gdddaee.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_gdddaee.CountAttr)})
	}
	e.EncodeToken(start)
	_edcga := _f.StartElement{Name: _f.Name{Local: "ma:tableColumn"}}
	for _, _aebba := range _gdddaee.TableColumn {
		e.EncodeElement(_aebba, _edcga)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type ST_CellType byte

// ValidateWithPath validates the PivotCacheDefinition and its children, prefixing error messages with path
func (_fabdd *PivotCacheDefinition) ValidateWithPath(path string) error {
	if _bgdfbd := _fabdd.CT_PivotCacheDefinition.ValidateWithPath(path); _bgdfbd != nil {
		return _bgdfbd
	}
	return nil
}
func (_cgddcf ST_FilterOperator) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_cgddcf.String(), start)
}

// Validate validates the CT_FutureMetadataBlock and its children
func (_agdgcc *CT_FutureMetadataBlock) Validate() error {
	return _agdgcc.ValidateWithPath("CT_FutureMetadataBlock")
}
func (_gaabd *CT_GroupMembers) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dfgbc := range start.Attr {
		if _dfgbc.Name.Local == "count" {
			_eaadf, _bbfd := _g.ParseUint(_dfgbc.Value, 10, 32)
			if _bbfd != nil {
				return _bbfd
			}
			_gfbcb := uint32(_eaadf)
			_gaabd.CountAttr = &_gfbcb
			continue
		}
	}
_bafce:
	for {
		_abecda, _fgee := d.Token()
		if _fgee != nil {
			return _fgee
		}
		switch _ccabf := _abecda.(type) {
		case _f.StartElement:
			switch _ccabf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "groupMember"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "groupMember"}:
				_ecccf := NewCT_GroupMember()
				if _gdge := d.DecodeElement(_ecccf, &_ccabf); _gdge != nil {
					return _gdge
				}
				_gaabd.GroupMember = append(_gaabd.GroupMember, _ecccf)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GroupMembers\u0020\u0025v", _ccabf.Name)
				if _geag := d.Skip(); _geag != nil {
					return _geag
				}
			}
		case _f.EndElement:
			break _bafce
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_RevisionDefinedName and its children
func (_ddgab *CT_RevisionDefinedName) Validate() error {
	return _ddgab.ValidateWithPath("CT_RevisionDefinedName")
}
func (_beedd ST_ParameterType) Validate() error { return _beedd.ValidateWithPath("") }
func NewCT_ObjectAnchor() *CT_ObjectAnchor {
	_aggdfg := &CT_ObjectAnchor{}
	_aggdfg.From = _d.NewFrom()
	_aggdfg.To = _d.NewTo()
	return _aggdfg
}
func (_dfgab *CT_FileVersion) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fdcfa := range start.Attr {
		if _fdcfa.Name.Local == "appName" {
			_ddfa, _dgfga := _fdcfa.Value, error(nil)
			if _dgfga != nil {
				return _dgfga
			}
			_dfgab.AppNameAttr = &_ddfa
			continue
		}
		if _fdcfa.Name.Local == "lastEdited" {
			_bbbbf, _bcbca := _fdcfa.Value, error(nil)
			if _bcbca != nil {
				return _bcbca
			}
			_dfgab.LastEditedAttr = &_bbbbf
			continue
		}
		if _fdcfa.Name.Local == "lowestEdited" {
			_cddfe, _gafgd := _fdcfa.Value, error(nil)
			if _gafgd != nil {
				return _gafgd
			}
			_dfgab.LowestEditedAttr = &_cddfe
			continue
		}
		if _fdcfa.Name.Local == "rupBuild" {
			_agffcb, _bdgb := _fdcfa.Value, error(nil)
			if _bdgb != nil {
				return _bdgb
			}
			_dfgab.RupBuildAttr = &_agffcb
			continue
		}
		if _fdcfa.Name.Local == "codeName" {
			_dgddg, _fcegb := _fdcfa.Value, error(nil)
			if _fcegb != nil {
				return _fcegb
			}
			_dfgab.CodeNameAttr = &_dgddg
			continue
		}
	}
	for {
		_ecfb, _bebfg := d.Token()
		if _bebfg != nil {
			return _bg.Errorf("parsing\u0020CT_FileVersion:\u0020\u0025s", _bebfg)
		}
		if _dgcf, _edfeb := _ecfb.(_f.EndElement); _edfeb && _dgcf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_eadf *CT_Color) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _eadf.AutoAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "auto"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eadf.AutoAttr))})
	}
	if _eadf.IndexedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "indexed"}, Value: _bg.Sprintf("\u0025v", *_eadf.IndexedAttr)})
	}
	if _eadf.RgbAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rgb"}, Value: _bg.Sprintf("\u0025v", *_eadf.RgbAttr)})
	}
	if _eadf.ThemeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "theme"}, Value: _bg.Sprintf("\u0025v", *_eadf.ThemeAttr)})
	}
	if _eadf.TintAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "tint"}, Value: _bg.Sprintf("\u0025v", *_eadf.TintAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_Top10() *CT_Top10 { _gdcdg := &CT_Top10{}; return _gdcdg }
func (_ddcce *CT_ConditionalFormats) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ddcce.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_ddcce.CountAttr)})
	}
	e.EncodeToken(start)
	_gfgc := _f.StartElement{Name: _f.Name{Local: "ma:conditionalFormat"}}
	for _, _cded := range _ddcce.ConditionalFormat {
		e.EncodeElement(_cded, _gfgc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type ST_DataConsolidateFunction byte

// Validate validates the CT_LegacyDrawing and its children
func (_agdcf *CT_LegacyDrawing) Validate() error { return _agdcf.ValidateWithPath("CT_LegacyDrawing") }

// ValidateWithPath validates the Headers and its children, prefixing error messages with path
func (_fedcde *Headers) ValidateWithPath(path string) error {
	if _bcfaec := _fedcde.CT_RevisionHeaders.ValidateWithPath(path); _bcfaec != nil {
		return _bcfaec
	}
	return nil
}
func (_daggg *CT_Reviewed) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rId"}, Value: _bg.Sprintf("\u0025v", _daggg.RIdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_Hyperlink struct {

	// Reference
	RefAttr string
	IdAttr  *string

	// Location
	LocationAttr *string

	// Tool Tip
	TooltipAttr *string

	// Display String
	DisplayAttr *string
}

func (_gacca ST_DataValidationType) String() string {
	switch _gacca {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "whole"
	case 3:
		return "decimal"
	case 4:
		return "list"
	case 5:
		return "date"
	case 6:
		return "time"
	case 7:
		return "textLength"
	case 8:
		return "custom"
	}
	return ""
}
func (_gaac *CT_Control) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "shapeId"}, Value: _bg.Sprintf("\u0025v", _gaac.ShapeIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _gaac.IdAttr)})
	if _gaac.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_gaac.NameAttr)})
	}
	e.EncodeToken(start)
	if _gaac.ControlPr != nil {
		_gcbe := _f.StartElement{Name: _f.Name{Local: "ma:controlPr"}}
		e.EncodeElement(_gaac.ControlPr, _gcbe)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_faceee *CT_I) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _faceee.TAttr != ST_ItemTypeUnset {
		_cgfca, _fcae := _faceee.TAttr.MarshalXMLAttr(_f.Name{Local: "t"})
		if _fcae != nil {
			return _fcae
		}
		start.Attr = append(start.Attr, _cgfca)
	}
	if _faceee.RAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", *_faceee.RAttr)})
	}
	if _faceee.IAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "i"}, Value: _bg.Sprintf("\u0025v", *_faceee.IAttr)})
	}
	e.EncodeToken(start)
	if _faceee.X != nil {
		_fffeb := _f.StartElement{Name: _f.Name{Local: "ma:x"}}
		for _, _deadfc := range _faceee.X {
			e.EncodeElement(_deadfc, _fffeb)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_adfga *CT_PrintOptions) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aaaedf := range start.Attr {
		if _aaaedf.Name.Local == "horizontalCentered" {
			_dffcd, _cbab := _g.ParseBool(_aaaedf.Value)
			if _cbab != nil {
				return _cbab
			}
			_adfga.HorizontalCenteredAttr = &_dffcd
			continue
		}
		if _aaaedf.Name.Local == "verticalCentered" {
			_dgaaa, _eabbca := _g.ParseBool(_aaaedf.Value)
			if _eabbca != nil {
				return _eabbca
			}
			_adfga.VerticalCenteredAttr = &_dgaaa
			continue
		}
		if _aaaedf.Name.Local == "headings" {
			_ebaaf, _cfdda := _g.ParseBool(_aaaedf.Value)
			if _cfdda != nil {
				return _cfdda
			}
			_adfga.HeadingsAttr = &_ebaaf
			continue
		}
		if _aaaedf.Name.Local == "gridLines" {
			_gdgfac, _fgdga := _g.ParseBool(_aaaedf.Value)
			if _fgdga != nil {
				return _fgdga
			}
			_adfga.GridLinesAttr = &_gdgfac
			continue
		}
		if _aaaedf.Name.Local == "gridLinesSet" {
			_dffgb, _bgaafb := _g.ParseBool(_aaaedf.Value)
			if _bgaafb != nil {
				return _bgaafb
			}
			_adfga.GridLinesSetAttr = &_dffgb
			continue
		}
	}
	for {
		_ccbac, _fcfcad := d.Token()
		if _fcfcad != nil {
			return _bg.Errorf("parsing CT_PrintOptions:\u0020\u0025s", _fcfcad)
		}
		if _geaff, _gaecf := _ccbac.(_f.EndElement); _gaecf && _geaff.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_BookViews struct {

	// Workbook View
	WorkbookView []*CT_BookView
}

func (_ceceed ST_SortMethod) ValidateWithPath(path string) error {
	switch _ceceed {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ceceed))
	}
	return nil
}

// Validate validates the CT_TableStyles and its children
func (_cbfgd *CT_TableStyles) Validate() error { return _cbfgd.ValidateWithPath("CT_TableStyles") }

// Validate validates the CT_CellStyle and its children
func (_afgb *CT_CellStyle) Validate() error { return _afgb.ValidateWithPath("CT_CellStyle") }
func (_gbbeda ST_rwColActionType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_gbbeda.String(), start)
}

type CT_Controls struct {

	// Embedded Control
	Control []*CT_Control
}

func (_fdegc ST_Orientation) ValidateWithPath(path string) error {
	switch _fdegc {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fdegc))
	}
	return nil
}

// ValidateWithPath validates the CT_RevisionQueryTableField and its children, prefixing error messages with path
func (_bgbcc *CT_RevisionQueryTableField) ValidateWithPath(path string) error { return nil }
func (_cebcd ST_PatternType) Validate() error                                 { return _cebcd.ValidateWithPath("") }

type CT_FilterColumn struct {

	// Filter Column Data
	ColIdAttr uint32

	// Hidden AutoFilter Button
	HiddenButtonAttr *bool

	// Show Filter Button
	ShowButtonAttr *bool

	// Filter Criteria
	Filters *CT_Filters

	// Top 10
	Top10 *CT_Top10

	// Custom Filters
	CustomFilters *CT_CustomFilters

	// Dynamic Filter
	DynamicFilter *CT_DynamicFilter

	// Color Filter Criteria
	ColorFilter *CT_ColorFilter

	// Icon Filter
	IconFilter *CT_IconFilter
	ExtLst     *CT_ExtensionList
}

func (_agbb *CT_FutureMetadataBlock) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _agbb.ExtLst != nil {
		_gcedb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_agbb.ExtLst, _gcedb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dcfbf *CT_PCDKPIs) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dcfbf.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_dcfbf.CountAttr)})
	}
	e.EncodeToken(start)
	if _dcfbf.Kpi != nil {
		_agfed := _f.StartElement{Name: _f.Name{Local: "ma:kpi"}}
		for _, _gbffg := range _dcfbf.Kpi {
			e.EncodeElement(_gbffg, _agfed)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_addfgb ST_TableType) Validate() error { return _addfgb.ValidateWithPath("") }
func (_gbcdf *CT_CellFormula) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _eebf := range start.Attr {
		if _eebf.Name.Local == "t" {
			_gbcdf.TAttr.UnmarshalXMLAttr(_eebf)
			continue
		}
		if _eebf.Name.Local == "aca" {
			_cbedf, _aece := _g.ParseBool(_eebf.Value)
			if _aece != nil {
				return _aece
			}
			_gbcdf.AcaAttr = &_cbedf
			continue
		}
		if _eebf.Name.Local == "ref" {
			_agcb, _bdab := _eebf.Value, error(nil)
			if _bdab != nil {
				return _bdab
			}
			_gbcdf.RefAttr = &_agcb
			continue
		}
		if _eebf.Name.Local == "dt2D" {
			_feaa, _ebdc := _g.ParseBool(_eebf.Value)
			if _ebdc != nil {
				return _ebdc
			}
			_gbcdf.Dt2DAttr = &_feaa
			continue
		}
		if _eebf.Name.Local == "dtr" {
			_aace, _aacf := _g.ParseBool(_eebf.Value)
			if _aacf != nil {
				return _aacf
			}
			_gbcdf.DtrAttr = &_aace
			continue
		}
		if _eebf.Name.Local == "del1" {
			_fcdf, _efda := _g.ParseBool(_eebf.Value)
			if _efda != nil {
				return _efda
			}
			_gbcdf.Del1Attr = &_fcdf
			continue
		}
		if _eebf.Name.Local == "del2" {
			_bgadb, _baga := _g.ParseBool(_eebf.Value)
			if _baga != nil {
				return _baga
			}
			_gbcdf.Del2Attr = &_bgadb
			continue
		}
		if _eebf.Name.Local == "r1" {
			_fcfg, _dgfca := _eebf.Value, error(nil)
			if _dgfca != nil {
				return _dgfca
			}
			_gbcdf.R1Attr = &_fcfg
			continue
		}
		if _eebf.Name.Local == "r2" {
			_defb, _dcg := _eebf.Value, error(nil)
			if _dcg != nil {
				return _dcg
			}
			_gbcdf.R2Attr = &_defb
			continue
		}
		if _eebf.Name.Local == "ca" {
			_bedf, _dfaa := _g.ParseBool(_eebf.Value)
			if _dfaa != nil {
				return _dfaa
			}
			_gbcdf.CaAttr = &_bedf
			continue
		}
		if _eebf.Name.Local == "si" {
			_gfbc, _feacd := _g.ParseUint(_eebf.Value, 10, 32)
			if _feacd != nil {
				return _feacd
			}
			_dfdbg := uint32(_gfbc)
			_gbcdf.SiAttr = &_dfdbg
			continue
		}
		if _eebf.Name.Local == "bx" {
			_fgce, _deag := _g.ParseBool(_eebf.Value)
			if _deag != nil {
				return _deag
			}
			_gbcdf.BxAttr = &_fgce
			continue
		}
	}
	for {
		_decf, _adac := d.Token()
		if _adac != nil {
			return _bg.Errorf("parsing\u0020CT_CellFormula:\u0020\u0025s", _adac)
		}
		if _deaef, _bged := _decf.(_f.CharData); _bged {
			_gbcdf.Content = string(_deaef)
		}
		if _gdca, _effeg := _decf.(_f.EndElement); _effeg && _gdca.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gdeec ST_rwColActionType) ValidateWithPath(path string) error {
	switch _gdeec {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gdeec))
	}
	return nil
}
func (_ggacc *Workbook) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:workbook"
	return _ggacc.CT_Workbook.MarshalXML(e, start)
}
func NewCT_Connections() *CT_Connections { _ecdga := &CT_Connections{}; return _ecdga }

// Validate validates the CT_DataValidation and its children
func (_gebfc *CT_DataValidation) Validate() error {
	return _gebfc.ValidateWithPath("CT_DataValidation")
}

type Headers struct{ CT_RevisionHeaders }

// Validate validates the CT_PivotCacheRecords and its children
func (_abcge *CT_PivotCacheRecords) Validate() error {
	return _abcge.ValidateWithPath("CT_PivotCacheRecords")
}
func (_ebgbb *ST_BorderStyle) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_ebgbb = 0
	case "none":
		*_ebgbb = 1
	case "thin":
		*_ebgbb = 2
	case "medium":
		*_ebgbb = 3
	case "dashed":
		*_ebgbb = 4
	case "dotted":
		*_ebgbb = 5
	case "thick":
		*_ebgbb = 6
	case "double":
		*_ebgbb = 7
	case "hair":
		*_ebgbb = 8
	case "mediumDashed":
		*_ebgbb = 9
	case "dashDot":
		*_ebgbb = 10
	case "mediumDashDot":
		*_ebgbb = 11
	case "dashDotDot":
		*_ebgbb = 12
	case "mediumDashDotDot":
		*_ebgbb = 13
	case "slantDashDot":
		*_ebgbb = 14
	}
	return nil
}

const (
	ST_RefModeUnset ST_RefMode = 0
	ST_RefModeA1    ST_RefMode = 1
	ST_RefModeR1C1  ST_RefMode = 2
)

func (_agegc ST_MdxKPIProperty) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_agegc.String(), start)
}
func (_acafeb *CT_SmartTagType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ffadb := range start.Attr {
		if _ffadb.Name.Local == "namespaceUri" {
			_dfefcd, _cddafgf := _ffadb.Value, error(nil)
			if _cddafgf != nil {
				return _cddafgf
			}
			_acafeb.NamespaceUriAttr = &_dfefcd
			continue
		}
		if _ffadb.Name.Local == "name" {
			_accec, _ddgad := _ffadb.Value, error(nil)
			if _ddgad != nil {
				return _ddgad
			}
			_acafeb.NameAttr = &_accec
			continue
		}
		if _ffadb.Name.Local == "url" {
			_dgebc, _gacaa := _ffadb.Value, error(nil)
			if _gacaa != nil {
				return _gacaa
			}
			_acafeb.UrlAttr = &_dgebc
			continue
		}
	}
	for {
		_feeab, _gdfcg := d.Token()
		if _gdfcg != nil {
			return _bg.Errorf("parsing CT_SmartTagType:\u0020\u0025s", _gdfcg)
		}
		if _deade, _efce := _feeab.(_f.EndElement); _efce && _deade.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_CellSmartTagPr and its children
func (_bgge *CT_CellSmartTagPr) Validate() error { return _bgge.ValidateWithPath("CT_CellSmartTagPr") }

// ValidateWithPath validates the CT_DateGroupItem and its children, prefixing error messages with path
func (_eecc *CT_DateGroupItem) ValidateWithPath(path string) error {
	if _eecc.DateTimeGroupingAttr == ST_DateTimeGroupingUnset {
		return _bg.Errorf("\u0025s\u002fDateTimeGroupingAttr is\u0020a mandatory field", path)
	}
	if _efgfd := _eecc.DateTimeGroupingAttr.ValidateWithPath(path + "/DateTimeGroupingAttr"); _efgfd != nil {
		return _efgfd
	}
	return nil
}

// ValidateWithPath validates the CT_FontSize and its children, prefixing error messages with path
func (_bbegg *CT_FontSize) ValidateWithPath(path string) error { return nil }
func (_bcegb *CT_Hyperlinks) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_caed:
	for {
		_ccafa, _cdgac := d.Token()
		if _cdgac != nil {
			return _cdgac
		}
		switch _dbfed := _ccafa.(type) {
		case _f.StartElement:
			switch _dbfed.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "hyperlink"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "hyperlink"}:
				_eadgb := NewCT_Hyperlink()
				if _acffd := d.DecodeElement(_eadgb, &_dbfed); _acffd != nil {
					return _acffd
				}
				_bcegb.Hyperlink = append(_bcegb.Hyperlink, _eadgb)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_Hyperlinks \u0025v", _dbfed.Name)
				if _aagff := d.Skip(); _aagff != nil {
					return _aagff
				}
			}
		case _f.EndElement:
			break _caed
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_ConditionalFormat and its children
func (_aebg *CT_ConditionalFormat) Validate() error {
	return _aebg.ValidateWithPath("CT_ConditionalFormat")
}

// ValidateWithPath validates the CT_VolTopic and its children, prefixing error messages with path
func (_bedcf *CT_VolTopic) ValidateWithPath(path string) error {
	if _acebe := _bedcf.TAttr.ValidateWithPath(path + "\u002fTAttr"); _acebe != nil {
		return _acebe
	}
	for _gfgee, _gaabba := range _bedcf.Tr {
		if _fegeg := _gaabba.ValidateWithPath(_bg.Sprintf("\u0025s\u002fTr\u005b\u0025d]", path, _gfgee)); _fegeg != nil {
			return _fegeg
		}
	}
	return nil
}

// ValidateWithPath validates the CT_RevisionRowColumn and its children, prefixing error messages with path
func (_gfdee *CT_RevisionRowColumn) ValidateWithPath(path string) error {
	if _gfdee.ActionAttr == ST_rwColActionTypeUnset {
		return _bg.Errorf("\u0025s\u002fActionAttr\u0020is a mandatory\u0020field", path)
	}
	if _bgfda := _gfdee.ActionAttr.ValidateWithPath(path + "/ActionAttr"); _bgfda != nil {
		return _bgfda
	}
	for _dadbb, _badga := range _gfdee.Undo {
		if _cbbef := _badga.ValidateWithPath(_bg.Sprintf("%s\u002fUndo\u005b\u0025d\u005d", path, _dadbb)); _cbbef != nil {
			return _cbbef
		}
	}
	for _fcddf, _cfgaf := range _gfdee.Rcc {
		if _dbfc := _cfgaf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRcc\u005b\u0025d\u005d", path, _fcddf)); _dbfc != nil {
			return _dbfc
		}
	}
	for _cbfec, _ebaccc := range _gfdee.Rfmt {
		if _bafaa := _ebaccc.ValidateWithPath(_bg.Sprintf("%s\u002fRfmt\u005b\u0025d\u005d", path, _cbfec)); _bafaa != nil {
			return _bafaa
		}
	}
	return nil
}

// Validate validates the CT_Groups and its children
func (_bdfdc *CT_Groups) Validate() error { return _bdfdc.ValidateWithPath("CT_Groups") }
func (_deeb *CT_OutlinePr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _deeb.ApplyStylesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyStyles"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deeb.ApplyStylesAttr))})
	}
	if _deeb.SummaryBelowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "summaryBelow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deeb.SummaryBelowAttr))})
	}
	if _deeb.SummaryRightAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "summaryRight"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deeb.SummaryRightAttr))})
	}
	if _deeb.ShowOutlineSymbolsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showOutlineSymbols"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deeb.ShowOutlineSymbolsAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_CustomProperties() *CT_CustomProperties { _fagf := &CT_CustomProperties{}; return _fagf }
func (_dcagb *CT_FieldUsage) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ccceb := range start.Attr {
		if _ccceb.Name.Local == "x" {
			_bbdde, _bfega := _g.ParseInt(_ccceb.Value, 10, 32)
			if _bfega != nil {
				return _bfega
			}
			_dcagb.XAttr = int32(_bbdde)
			continue
		}
	}
	for {
		_cbge, _dafcc := d.Token()
		if _dafcc != nil {
			return _bg.Errorf("parsing\u0020CT_FieldUsage:\u0020\u0025s", _dafcc)
		}
		if _fcac, _bggcg := _cbge.(_f.EndElement); _bggcg && _fcac.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_PhoneticPr struct {

	// Font Id
	FontIdAttr uint32

	// Character Type
	TypeAttr ST_PhoneticType

	// Alignment
	AlignmentAttr ST_PhoneticAlignment
}
type ST_Visibility byte

func NewCT_Sst() *CT_Sst { _eeged := &CT_Sst{}; return _eeged }
func (_gafe *CT_DataField) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gafe.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_gafe.NameAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fld"}, Value: _bg.Sprintf("\u0025v", _gafe.FldAttr)})
	if _gafe.SubtotalAttr != ST_DataConsolidateFunctionUnset {
		_afdfb, _fccef := _gafe.SubtotalAttr.MarshalXMLAttr(_f.Name{Local: "subtotal"})
		if _fccef != nil {
			return _fccef
		}
		start.Attr = append(start.Attr, _afdfb)
	}
	if _gafe.ShowDataAsAttr != ST_ShowDataAsUnset {
		_cbbd, _gbbe := _gafe.ShowDataAsAttr.MarshalXMLAttr(_f.Name{Local: "showDataAs"})
		if _gbbe != nil {
			return _gbbe
		}
		start.Attr = append(start.Attr, _cbbd)
	}
	if _gafe.BaseFieldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "baseField"}, Value: _bg.Sprintf("\u0025v", *_gafe.BaseFieldAttr)})
	}
	if _gafe.BaseItemAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "baseItem"}, Value: _bg.Sprintf("\u0025v", *_gafe.BaseItemAttr)})
	}
	if _gafe.NumFmtIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "numFmtId"}, Value: _bg.Sprintf("\u0025v", *_gafe.NumFmtIdAttr)})
	}
	e.EncodeToken(start)
	if _gafe.ExtLst != nil {
		_cgfaf := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_gafe.ExtLst, _cgfaf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ExternalLinkChoice and its children, prefixing error messages with path
func (_fedg *CT_ExternalLinkChoice) ValidateWithPath(path string) error {
	if _fedg.ExternalBook != nil {
		if _eecdd := _fedg.ExternalBook.ValidateWithPath(path + "\u002fExternalBook"); _eecdd != nil {
			return _eecdd
		}
	}
	if _fedg.DdeLink != nil {
		if _cdagd := _fedg.DdeLink.ValidateWithPath(path + "\u002fDdeLink"); _cdagd != nil {
			return _cdagd
		}
	}
	if _fedg.OleLink != nil {
		if _dccac := _fedg.OleLink.ValidateWithPath(path + "\u002fOleLink"); _dccac != nil {
			return _dccac
		}
	}
	return nil
}
func (_gccfc *CT_ObjectPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gccfc.Anchor = NewCT_ObjectAnchor()
	for _, _caada := range start.Attr {
		if _caada.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _caada.Name.Local == "id" || _caada.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _caada.Name.Local == "id" {
			_eccdcc, _acbbf := _caada.Value, error(nil)
			if _acbbf != nil {
				return _acbbf
			}
			_gccfc.IdAttr = &_eccdcc
			continue
		}
		if _caada.Name.Local == "autoLine" {
			_eeegg, _bccdfe := _g.ParseBool(_caada.Value)
			if _bccdfe != nil {
				return _bccdfe
			}
			_gccfc.AutoLineAttr = &_eeegg
			continue
		}
		if _caada.Name.Local == "print" {
			_gbfdg, _fgeg := _g.ParseBool(_caada.Value)
			if _fgeg != nil {
				return _fgeg
			}
			_gccfc.PrintAttr = &_gbfdg
			continue
		}
		if _caada.Name.Local == "disabled" {
			_adbef, _eggce := _g.ParseBool(_caada.Value)
			if _eggce != nil {
				return _eggce
			}
			_gccfc.DisabledAttr = &_adbef
			continue
		}
		if _caada.Name.Local == "uiObject" {
			_ceggf, _geebe := _g.ParseBool(_caada.Value)
			if _geebe != nil {
				return _geebe
			}
			_gccfc.UiObjectAttr = &_ceggf
			continue
		}
		if _caada.Name.Local == "autoFill" {
			_efeec, _dbaab := _g.ParseBool(_caada.Value)
			if _dbaab != nil {
				return _dbaab
			}
			_gccfc.AutoFillAttr = &_efeec
			continue
		}
		if _caada.Name.Local == "locked" {
			_bbgae, _geacd := _g.ParseBool(_caada.Value)
			if _geacd != nil {
				return _geacd
			}
			_gccfc.LockedAttr = &_bbgae
			continue
		}
		if _caada.Name.Local == "autoPict" {
			_fcedc, _ffada := _g.ParseBool(_caada.Value)
			if _ffada != nil {
				return _ffada
			}
			_gccfc.AutoPictAttr = &_fcedc
			continue
		}
		if _caada.Name.Local == "macro" {
			_ccegf, _bddefb := _caada.Value, error(nil)
			if _bddefb != nil {
				return _bddefb
			}
			_gccfc.MacroAttr = &_ccegf
			continue
		}
		if _caada.Name.Local == "altText" {
			_eebgf, _gefbf := _caada.Value, error(nil)
			if _gefbf != nil {
				return _gefbf
			}
			_gccfc.AltTextAttr = &_eebgf
			continue
		}
		if _caada.Name.Local == "dde" {
			_fccfg, _cbacdg := _g.ParseBool(_caada.Value)
			if _cbacdg != nil {
				return _cbacdg
			}
			_gccfc.DdeAttr = &_fccfg
			continue
		}
		if _caada.Name.Local == "defaultSize" {
			_befcfe, _eddfe := _g.ParseBool(_caada.Value)
			if _eddfe != nil {
				return _eddfe
			}
			_gccfc.DefaultSizeAttr = &_befcfe
			continue
		}
	}
_bcffgf:
	for {
		_fgcbg, _fcbeg := d.Token()
		if _fcbeg != nil {
			return _fcbeg
		}
		switch _gdccg := _fgcbg.(type) {
		case _f.StartElement:
			switch _gdccg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "anchor"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "anchor"}:
				if _deded := d.DecodeElement(_gccfc.Anchor, &_gdccg); _deded != nil {
					return _deded
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ObjectPr\u0020\u0025v", _gdccg.Name)
				if _dggee := d.Skip(); _dggee != nil {
					return _dggee
				}
			}
		case _f.EndElement:
			break _bcffgf
		case _f.CharData:
		}
	}
	return nil
}
func (_bced *CT_Dxfs) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _agffe := range start.Attr {
		if _agffe.Name.Local == "count" {
			_cefg, _acege := _g.ParseUint(_agffe.Value, 10, 32)
			if _acege != nil {
				return _acege
			}
			_defca := uint32(_cefg)
			_bced.CountAttr = &_defca
			continue
		}
	}
_dfecg:
	for {
		_ccead, _geee := d.Token()
		if _geee != nil {
			return _geee
		}
		switch _fgage := _ccead.(type) {
		case _f.StartElement:
			switch _fgage.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dxf"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dxf"}:
				_gcbfeb := NewCT_Dxf()
				if _cedb := d.DecodeElement(_gcbfeb, &_fgage); _cedb != nil {
					return _cedb
				}
				_bced.Dxf = append(_bced.Dxf, _gcbfeb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Dxfs\u0020\u0025v", _fgage.Name)
				if _acaegb := d.Skip(); _acaegb != nil {
					return _acaegb
				}
			}
		case _f.EndElement:
			break _dfecg
		case _f.CharData:
		}
	}
	return nil
}
func (_dbbafe ST_HtmlFmt) Validate() error { return _dbbafe.ValidateWithPath("") }
func NewCT_Color() *CT_Color               { _befe := &CT_Color{}; return _befe }
func NewCT_SheetViews() *CT_SheetViews     { _dbfg := &CT_SheetViews{}; return _dbfg }
func (_cdcceg *ST_TextVAlign) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_cdcceg = 0
	case "top":
		*_cdcceg = 1
	case "center":
		*_cdcceg = 2
	case "bottom":
		*_cdcceg = 3
	case "justify":
		*_cdcceg = 4
	case "distributed":
		*_cdcceg = 5
	}
	return nil
}

// Validate validates the CT_NumFmt and its children
func (_fddbg *CT_NumFmt) Validate() error { return _fddbg.ValidateWithPath("CT_NumFmt") }

type CT_MetadataBlocks struct {

	// Metadata Block Count
	CountAttr *uint32

	// Metadata Block
	Bk []*CT_MetadataBlock
}

func NewCT_I() *CT_I { _bfea := &CT_I{}; return _bfea }
func (_dffgad ST_ItemType) ValidateWithPath(path string) error {
	switch _dffgad {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dffgad))
	}
	return nil
}

type CT_MetadataStringIndex struct {

	// Index Value
	XAttr uint32

	// String is a Set
	SAttr *bool
}

// Validate validates the CT_RgbColor and its children
func (_begbd *CT_RgbColor) Validate() error { return _begbd.ValidateWithPath("CT_RgbColor") }
func (_dfcbf *ST_SortBy) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cgfcg, _dbdcfc := d.Token()
	if _dbdcfc != nil {
		return _dbdcfc
	}
	if _ebfbc, _dcgab := _cgfcg.(_f.EndElement); _dcgab && _ebfbc.Name == start.Name {
		*_dfcbf = 1
		return nil
	}
	if _aecef, _bggag := _cgfcg.(_f.CharData); !_bggag {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cgfcg)
	} else {
		switch string(_aecef) {
		case "":
			*_dfcbf = 0
		case "value":
			*_dfcbf = 1
		case "cellColor":
			*_dfcbf = 2
		case "fontColor":
			*_dfcbf = 3
		case "icon":
			*_dfcbf = 4
		}
	}
	_cgfcg, _dbdcfc = d.Token()
	if _dbdcfc != nil {
		return _dbdcfc
	}
	if _ccdce, _fdcead := _cgfcg.(_f.EndElement); _fdcead && _ccdce.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cgfcg)
}

// Validate validates the CT_FieldsUsage and its children
func (_dagd *CT_FieldsUsage) Validate() error { return _dagd.ValidateWithPath("CT_FieldsUsage") }

// Validate validates the CT_CustomWorkbookView and its children
func (_dbgc *CT_CustomWorkbookView) Validate() error {
	return _dbgc.ValidateWithPath("CT_CustomWorkbookView")
}
func (_bbedc *CT_ExternalDefinedName) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aecb := range start.Attr {
		if _aecb.Name.Local == "name" {
			_gcgaf, _faae := _aecb.Value, error(nil)
			if _faae != nil {
				return _faae
			}
			_bbedc.NameAttr = _gcgaf
			continue
		}
		if _aecb.Name.Local == "refersTo" {
			_baeefa, _ddfce := _aecb.Value, error(nil)
			if _ddfce != nil {
				return _ddfce
			}
			_bbedc.RefersToAttr = &_baeefa
			continue
		}
		if _aecb.Name.Local == "sheetId" {
			_cbfdgd, _acbe := _g.ParseUint(_aecb.Value, 10, 32)
			if _acbe != nil {
				return _acbe
			}
			_cdeae := uint32(_cbfdgd)
			_bbedc.SheetIdAttr = &_cdeae
			continue
		}
	}
	for {
		_gccdc, _cdace := d.Token()
		if _cdace != nil {
			return _bg.Errorf("parsing\u0020CT_ExternalDefinedName:\u0020\u0025s", _cdace)
		}
		if _eggg, _babe := _gccdc.(_f.EndElement); _babe && _eggg.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_GroupItems() *CT_GroupItems { _febde := &CT_GroupItems{}; return _febde }

// ValidateWithPath validates the CT_ExternalSheetNames and its children, prefixing error messages with path
func (_cafdg *CT_ExternalSheetNames) ValidateWithPath(path string) error {
	for _faadgf, _fbadf := range _cafdg.SheetName {
		if _dagbe := _fbadf.ValidateWithPath(_bg.Sprintf("\u0025s/SheetName\u005b\u0025d\u005d", path, _faadgf)); _dagbe != nil {
			return _dagbe
		}
	}
	return nil
}
func NewCT_WebPublishObjects() *CT_WebPublishObjects {
	_gbgcce := &CT_WebPublishObjects{}
	return _gbgcce
}

type ST_DataValidationErrorStyle byte

// Validate validates the CT_DeletedField and its children
func (_baba *CT_DeletedField) Validate() error { return _baba.ValidateWithPath("CT_DeletedField") }
func (_dbcef ST_PrintError) ValidateWithPath(path string) error {
	switch _dbcef {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dbcef))
	}
	return nil
}
func (_fbfaf *CT_PCDKPI) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ccbbe := range start.Attr {
		if _ccbbe.Name.Local == "uniqueName" {
			_eggfg, _cefad := _ccbbe.Value, error(nil)
			if _cefad != nil {
				return _cefad
			}
			_fbfaf.UniqueNameAttr = _eggfg
			continue
		}
		if _ccbbe.Name.Local == "caption" {
			_cdbae, _fedgc := _ccbbe.Value, error(nil)
			if _fedgc != nil {
				return _fedgc
			}
			_fbfaf.CaptionAttr = &_cdbae
			continue
		}
		if _ccbbe.Name.Local == "displayFolder" {
			_fgaae, _dadfe := _ccbbe.Value, error(nil)
			if _dadfe != nil {
				return _dadfe
			}
			_fbfaf.DisplayFolderAttr = &_fgaae
			continue
		}
		if _ccbbe.Name.Local == "measureGroup" {
			_fbacg, _cbefa := _ccbbe.Value, error(nil)
			if _cbefa != nil {
				return _cbefa
			}
			_fbfaf.MeasureGroupAttr = &_fbacg
			continue
		}
		if _ccbbe.Name.Local == "parent" {
			_edbef, _gegeff := _ccbbe.Value, error(nil)
			if _gegeff != nil {
				return _gegeff
			}
			_fbfaf.ParentAttr = &_edbef
			continue
		}
		if _ccbbe.Name.Local == "value" {
			_ebfbe, _bgcgd := _ccbbe.Value, error(nil)
			if _bgcgd != nil {
				return _bgcgd
			}
			_fbfaf.ValueAttr = _ebfbe
			continue
		}
		if _ccbbe.Name.Local == "goal" {
			_gdggb, _abedac := _ccbbe.Value, error(nil)
			if _abedac != nil {
				return _abedac
			}
			_fbfaf.GoalAttr = &_gdggb
			continue
		}
		if _ccbbe.Name.Local == "status" {
			_adaaa, _ccccc := _ccbbe.Value, error(nil)
			if _ccccc != nil {
				return _ccccc
			}
			_fbfaf.StatusAttr = &_adaaa
			continue
		}
		if _ccbbe.Name.Local == "trend" {
			_ccegfc, _eccbga := _ccbbe.Value, error(nil)
			if _eccbga != nil {
				return _eccbga
			}
			_fbfaf.TrendAttr = &_ccegfc
			continue
		}
		if _ccbbe.Name.Local == "weight" {
			_begba, _ffbcd := _ccbbe.Value, error(nil)
			if _ffbcd != nil {
				return _ffbcd
			}
			_fbfaf.WeightAttr = &_begba
			continue
		}
		if _ccbbe.Name.Local == "time" {
			_degbga, _aeddcc := _ccbbe.Value, error(nil)
			if _aeddcc != nil {
				return _aeddcc
			}
			_fbfaf.TimeAttr = &_degbga
			continue
		}
	}
	for {
		_beffcb, _dfggg := d.Token()
		if _dfggg != nil {
			return _bg.Errorf("parsing\u0020CT_PCDKPI:\u0020\u0025s", _dfggg)
		}
		if _ffccg, _cbddad := _beffcb.(_f.EndElement); _cbddad && _ffccg.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_PageSetup and its children
func (_gfdba *CT_PageSetup) Validate() error { return _gfdba.ValidateWithPath("CT_PageSetup") }

// Validate validates the CT_RevisionCustomView and its children
func (_gfaaa *CT_RevisionCustomView) Validate() error {
	return _gfaaa.ValidateWithPath("CT_RevisionCustomView")
}

// Validate validates the CT_XmlPr and its children
func (_fgcgc *CT_XmlPr) Validate() error { return _fgcgc.ValidateWithPath("CT_XmlPr") }

// Validate validates the CT_ExtensionList and its children
func (_bccd *CT_ExtensionList) Validate() error { return _bccd.ValidateWithPath("CT_ExtensionList") }
func NewCT_Dxf() *CT_Dxf                        { _adeec := &CT_Dxf{}; return _adeec }
func (_bgcgba *CT_Parameters) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gcccg := range start.Attr {
		if _gcccg.Name.Local == "count" {
			_fgefc, _aacdb := _g.ParseUint(_gcccg.Value, 10, 32)
			if _aacdb != nil {
				return _aacdb
			}
			_gcgda := uint32(_fgefc)
			_bgcgba.CountAttr = &_gcgda
			continue
		}
	}
_egfb:
	for {
		_fdage, _abcd := d.Token()
		if _abcd != nil {
			return _abcd
		}
		switch _faace := _fdage.(type) {
		case _f.StartElement:
			switch _faace.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "parameter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "parameter"}:
				_bdddf := NewCT_Parameter()
				if _cbeda := d.DecodeElement(_bdddf, &_faace); _cbeda != nil {
					return _cbeda
				}
				_bgcgba.Parameter = append(_bgcgba.Parameter, _bdddf)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_Parameters \u0025v", _faace.Name)
				if _adcbg := d.Skip(); _adcbg != nil {
					return _adcbg
				}
			}
		case _f.EndElement:
			break _egfb
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_BookView and its children
func (_cda *CT_BookView) Validate() error { return _cda.ValidateWithPath("CT_BookView") }

type CT_RevisionDefinedName struct {

	// Local Name Sheet Id
	LocalSheetIdAttr *uint32

	// Custom View
	CustomViewAttr *bool

	// Name
	NameAttr string

	// Function
	FunctionAttr *bool

	// Old Function
	OldFunctionAttr *bool

	// Function Group Id
	FunctionGroupIdAttr *uint8

	// Old Function Group Id
	OldFunctionGroupIdAttr *uint8

	// Shortcut Key
	ShortcutKeyAttr *uint8

	// Old Short Cut Key
	OldShortcutKeyAttr *uint8

	// Named Range Hidden
	HiddenAttr *bool

	// Old Hidden
	OldHiddenAttr *bool

	// New Custom Menu
	CustomMenuAttr *string

	// Old Custom Menu Text
	OldCustomMenuAttr *string

	// Description
	DescriptionAttr *string

	// Old Description
	OldDescriptionAttr *string

	// New Help Topic
	HelpAttr *string

	// Old Help Topic
	OldHelpAttr *string

	// Status Bar
	StatusBarAttr *string

	// Old Status Bar
	OldStatusBarAttr *string

	// Name Comment
	CommentAttr *string

	// Old Name Comment
	OldCommentAttr *string

	// Formula
	Formula *string

	// Old Formula
	OldFormula *string
	ExtLst     *CT_ExtensionList
	RIdAttr    *uint32
	UaAttr     *bool
	RaAttr     *bool
}

func (_affdb *ST_Comments) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cefdba, _ddbeba := d.Token()
	if _ddbeba != nil {
		return _ddbeba
	}
	if _cbfecd, _bdcged := _cefdba.(_f.EndElement); _bdcged && _cbfecd.Name == start.Name {
		*_affdb = 1
		return nil
	}
	if _bacaeb, _adgaed := _cefdba.(_f.CharData); !_adgaed {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cefdba)
	} else {
		switch string(_bacaeb) {
		case "":
			*_affdb = 0
		case "commNone":
			*_affdb = 1
		case "commIndicator":
			*_affdb = 2
		case "commIndAndComment":
			*_affdb = 3
		}
	}
	_cefdba, _ddbeba = d.Token()
	if _ddbeba != nil {
		return _ddbeba
	}
	if _babadf, _cdgec := _cefdba.(_f.EndElement); _cdgec && _babadf.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cefdba)
}

type CT_DataBar struct {

	// Minimum Length
	MinLengthAttr *uint32

	// Maximum Length
	MaxLengthAttr *uint32

	// Show Values
	ShowValueAttr *bool

	// Conditional Format Value Object
	Cfvo []*CT_Cfvo

	// Data Bar Color
	Color *CT_Color
}

func (_beaag *CT_Row) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bfbbf := range start.Attr {
		if _bfbbf.Name.Local == "outlineLevel" {
			_bfdde, _gdfef := _g.ParseUint(_bfbbf.Value, 10, 8)
			if _gdfef != nil {
				return _gdfef
			}
			_bfgac := uint8(_bfdde)
			_beaag.OutlineLevelAttr = &_bfgac
			continue
		}
		if _bfbbf.Name.Local == "r" {
			_eegea, _affgf := _g.ParseUint(_bfbbf.Value, 10, 32)
			if _affgf != nil {
				return _affgf
			}
			_begbb := uint32(_eegea)
			_beaag.RAttr = &_begbb
			continue
		}
		if _bfbbf.Name.Local == "s" {
			_egfgg, _baaca := _g.ParseUint(_bfbbf.Value, 10, 32)
			if _baaca != nil {
				return _baaca
			}
			_fcffa := uint32(_egfgg)
			_beaag.SAttr = &_fcffa
			continue
		}
		if _bfbbf.Name.Local == "customFormat" {
			_dddgb, _gbffce := _g.ParseBool(_bfbbf.Value)
			if _gbffce != nil {
				return _gbffce
			}
			_beaag.CustomFormatAttr = &_dddgb
			continue
		}
		if _bfbbf.Name.Local == "ht" {
			_fdcce, _dfadef := _g.ParseFloat(_bfbbf.Value, 64)
			if _dfadef != nil {
				return _dfadef
			}
			_beaag.HtAttr = &_fdcce
			continue
		}
		if _bfbbf.Name.Local == "hidden" {
			_aadbe, _ddddd := _g.ParseBool(_bfbbf.Value)
			if _ddddd != nil {
				return _ddddd
			}
			_beaag.HiddenAttr = &_aadbe
			continue
		}
		if _bfbbf.Name.Local == "customHeight" {
			_adfffg, _gcddd := _g.ParseBool(_bfbbf.Value)
			if _gcddd != nil {
				return _gcddd
			}
			_beaag.CustomHeightAttr = &_adfffg
			continue
		}
		if _bfbbf.Name.Local == "spans" {
			_fgagec, _cefcf := ParseSliceST_CellSpans(_bfbbf.Value)
			if _cefcf != nil {
				return _cefcf
			}
			_beaag.SpansAttr = &_fgagec
			continue
		}
		if _bfbbf.Name.Local == "collapsed" {
			_cccdb, _afabc := _g.ParseBool(_bfbbf.Value)
			if _afabc != nil {
				return _afabc
			}
			_beaag.CollapsedAttr = &_cccdb
			continue
		}
		if _bfbbf.Name.Local == "thickTop" {
			_ecfbg, _bbcad := _g.ParseBool(_bfbbf.Value)
			if _bbcad != nil {
				return _bbcad
			}
			_beaag.ThickTopAttr = &_ecfbg
			continue
		}
		if _bfbbf.Name.Local == "thickBot" {
			_egcacca, _ababf := _g.ParseBool(_bfbbf.Value)
			if _ababf != nil {
				return _ababf
			}
			_beaag.ThickBotAttr = &_egcacca
			continue
		}
		if _bfbbf.Name.Local == "ph" {
			_ccbeg, _fdbg := _g.ParseBool(_bfbbf.Value)
			if _fdbg != nil {
				return _fdbg
			}
			_beaag.PhAttr = &_ccbeg
			continue
		}
	}
_fcaaa:
	for {
		_dedgac, _bcbbeb := d.Token()
		if _bcbbeb != nil {
			return _bcbbeb
		}
		switch _cdbde := _dedgac.(type) {
		case _f.StartElement:
			switch _cdbde.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "c"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "c"}:
				_aefcg := NewCT_Cell()
				if _dacca := d.DecodeElement(_aefcg, &_cdbde); _dacca != nil {
					return _dacca
				}
				_beaag.C = append(_beaag.C, _aefcg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_beaag.ExtLst = NewCT_ExtensionList()
				if _gdggd := d.DecodeElement(_beaag.ExtLst, &_cdbde); _gdggd != nil {
					return _gdggd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Row\u0020\u0025v", _cdbde.Name)
				if _dgbabd := d.Skip(); _dgbabd != nil {
					return _dgbabd
				}
			}
		case _f.EndElement:
			break _fcaaa
		case _f.CharData:
		}
	}
	return nil
}
func (_ebcea *CT_Col) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "min"}, Value: _bg.Sprintf("\u0025v", _ebcea.MinAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "max"}, Value: _bg.Sprintf("\u0025v", _ebcea.MaxAttr)})
	if _ebcea.WidthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "width"}, Value: _bg.Sprintf("\u0025v", *_ebcea.WidthAttr)})
	}
	if _ebcea.StyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "style"}, Value: _bg.Sprintf("\u0025v", *_ebcea.StyleAttr)})
	}
	if _ebcea.HiddenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hidden"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebcea.HiddenAttr))})
	}
	if _ebcea.BestFitAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "bestFit"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebcea.BestFitAttr))})
	}
	if _ebcea.CustomWidthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "customWidth"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebcea.CustomWidthAttr))})
	}
	if _ebcea.PhoneticAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "phonetic"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebcea.PhoneticAttr))})
	}
	if _ebcea.OutlineLevelAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "outlineLevel"}, Value: _bg.Sprintf("\u0025v", *_ebcea.OutlineLevelAttr)})
	}
	if _ebcea.CollapsedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "collapsed"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebcea.CollapsedAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Items and its children, prefixing error messages with path
func (_efcdf *CT_Items) ValidateWithPath(path string) error {
	for _fdbfg, _eegdc := range _efcdf.Item {
		if _bfgag := _eegdc.ValidateWithPath(_bg.Sprintf("%s\u002fItem\u005b\u0025d\u005d", path, _fdbfg)); _bfgag != nil {
			return _bfgag
		}
	}
	return nil
}

type PivotCacheDefinition struct{ CT_PivotCacheDefinition }

// ValidateWithPath validates the CT_CacheHierarchy and its children, prefixing error messages with path
func (_fdfgg *CT_CacheHierarchy) ValidateWithPath(path string) error {
	if _fdfgg.FieldsUsage != nil {
		if _acac := _fdfgg.FieldsUsage.ValidateWithPath(path + "\u002fFieldsUsage"); _acac != nil {
			return _acac
		}
	}
	if _fdfgg.GroupLevels != nil {
		if _ggege := _fdfgg.GroupLevels.ValidateWithPath(path + "\u002fGroupLevels"); _ggege != nil {
			return _ggege
		}
	}
	if _fdfgg.ExtLst != nil {
		if _fede := _fdfgg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fede != nil {
			return _fede
		}
	}
	return nil
}
func NewCT_ExternalDefinedName() *CT_ExternalDefinedName {
	_fdbdf := &CT_ExternalDefinedName{}
	return _fdbdf
}

// ValidateWithPath validates the CT_OleObjects and its children, prefixing error messages with path
func (_dcaga *CT_OleObjects) ValidateWithPath(path string) error {
	for _dagg, _beebg := range _dcaga.OleObject {
		if _egaac := _beebg.ValidateWithPath(_bg.Sprintf("\u0025s/OleObject\u005b\u0025d\u005d", path, _dagg)); _egaac != nil {
			return _egaac
		}
	}
	return nil
}
func (_eebag *CT_FunctionGroup) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dbeab := range start.Attr {
		if _dbeab.Name.Local == "name" {
			_dfddf, _bdbebce := _dbeab.Value, error(nil)
			if _bdbebce != nil {
				return _bdbebce
			}
			_eebag.NameAttr = &_dfddf
			continue
		}
	}
	for {
		_cbcdee, _ggffe := d.Token()
		if _ggffe != nil {
			return _bg.Errorf("parsing\u0020CT_FunctionGroup: \u0025s", _ggffe)
		}
		if _ecbg, _bffaf := _cbcdee.(_f.EndElement); _bffaf && _ecbg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_aedad *CT_ProtectedRange) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aedad.PasswordAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "password"}, Value: _bg.Sprintf("\u0025v", *_aedad.PasswordAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sqref"}, Value: _bg.Sprintf("\u0025v", _aedad.SqrefAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _aedad.NameAttr)})
	if _aedad.SecurityDescriptorAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "securityDescriptor"}, Value: _bg.Sprintf("\u0025v", *_aedad.SecurityDescriptorAttr)})
	}
	if _aedad.AlgorithmNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "algorithmName"}, Value: _bg.Sprintf("\u0025v", *_aedad.AlgorithmNameAttr)})
	}
	if _aedad.HashValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hashValue"}, Value: _bg.Sprintf("\u0025v", *_aedad.HashValueAttr)})
	}
	if _aedad.SaltValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "saltValue"}, Value: _bg.Sprintf("\u0025v", *_aedad.SaltValueAttr)})
	}
	if _aedad.SpinCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "spinCount"}, Value: _bg.Sprintf("\u0025v", *_aedad.SpinCountAttr)})
	}
	e.EncodeToken(start)
	if _aedad.SecurityDescriptor != nil {
		_eecfe := _f.StartElement{Name: _f.Name{Local: "ma:securityDescriptor"}}
		for _, _dgbccg := range _aedad.SecurityDescriptor {
			e.EncodeElement(_dgbccg, _eecfe)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_MetadataRecord and its children, prefixing error messages with path
func (_egaee *CT_MetadataRecord) ValidateWithPath(path string) error { return nil }
func (_aegbf *CT_LevelGroup) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _aegbf.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueName"}, Value: _bg.Sprintf("\u0025v", _aegbf.UniqueNameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "caption"}, Value: _bg.Sprintf("\u0025v", _aegbf.CaptionAttr)})
	if _aegbf.UniqueParentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueParent"}, Value: _bg.Sprintf("\u0025v", *_aegbf.UniqueParentAttr)})
	}
	if _aegbf.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", *_aegbf.IdAttr)})
	}
	e.EncodeToken(start)
	_cage := _f.StartElement{Name: _f.Name{Local: "ma:groupMembers"}}
	e.EncodeElement(_aegbf.GroupMembers, _cage)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_CacheSource() *CT_CacheSource {
	_dedg := &CT_CacheSource{}
	_dedg.TypeAttr = ST_SourceType(1)
	return _dedg
}

// ValidateWithPath validates the CT_CellProtection and its children, prefixing error messages with path
func (_dbad *CT_CellProtection) ValidateWithPath(path string) error { return nil }

type ST_DateTimeGrouping byte

const (
	ST_FontSchemeUnset ST_FontScheme = 0
	ST_FontSchemeNone  ST_FontScheme = 1
	ST_FontSchemeMajor ST_FontScheme = 2
	ST_FontSchemeMinor ST_FontScheme = 3
)

func (_bcfbd *CT_LegacyDrawing) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _bcfbd.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Number and its children, prefixing error messages with path
func (_cdcfb *CT_Number) ValidateWithPath(path string) error {
	for _edaa, _dede := range _cdcfb.Tpls {
		if _geaced := _dede.ValidateWithPath(_bg.Sprintf("%s\u002fTpls\u005b\u0025d\u005d", path, _edaa)); _geaced != nil {
			return _geaced
		}
	}
	for _cffeg, _fggbf := range _cdcfb.X {
		if _fbcda := _fggbf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fX\u005b\u0025d\u005d", path, _cffeg)); _fbcda != nil {
			return _fbcda
		}
	}
	return nil
}
func NewCT_DefinedNames() *CT_DefinedNames { _caaaeb := &CT_DefinedNames{}; return _caaaeb }

// Validate validates the CT_PivotFilter and its children
func (_bbgba *CT_PivotFilter) Validate() error { return _bbgba.ValidateWithPath("CT_PivotFilter") }

type CT_DataRefs struct {

	// Data Consolidation Reference Count
	CountAttr *uint32

	// Data Consolidation Reference
	DataRef []*CT_DataRef
}

func (_facafg *CT_PivotAreaReference) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _facafg.FieldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "field"}, Value: _bg.Sprintf("\u0025v", *_facafg.FieldAttr)})
	}
	if _facafg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_facafg.CountAttr)})
	}
	if _facafg.SelectedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "selected"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.SelectedAttr))})
	}
	if _facafg.ByPositionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "byPosition"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.ByPositionAttr))})
	}
	if _facafg.RelativeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "relative"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.RelativeAttr))})
	}
	if _facafg.DefaultSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.DefaultSubtotalAttr))})
	}
	if _facafg.SumSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sumSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.SumSubtotalAttr))})
	}
	if _facafg.CountASubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "countASubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.CountASubtotalAttr))})
	}
	if _facafg.AvgSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "avgSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.AvgSubtotalAttr))})
	}
	if _facafg.MaxSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "maxSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.MaxSubtotalAttr))})
	}
	if _facafg.MinSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.MinSubtotalAttr))})
	}
	if _facafg.ProductSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "productSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.ProductSubtotalAttr))})
	}
	if _facafg.CountSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "countSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.CountSubtotalAttr))})
	}
	if _facafg.StdDevSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "stdDevSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.StdDevSubtotalAttr))})
	}
	if _facafg.StdDevPSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "stdDevPSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.StdDevPSubtotalAttr))})
	}
	if _facafg.VarSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "varSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.VarSubtotalAttr))})
	}
	if _facafg.VarPSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "varPSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_facafg.VarPSubtotalAttr))})
	}
	e.EncodeToken(start)
	if _facafg.X != nil {
		_cgfgc := _f.StartElement{Name: _f.Name{Local: "ma:x"}}
		for _, _gcegb := range _facafg.X {
			e.EncodeElement(_gcegb, _cgfgc)
		}
	}
	if _facafg.ExtLst != nil {
		_eacdg := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_facafg.ExtLst, _eacdg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dfaee ST_MdxSetOrder) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_dfaee.String(), start)
}
func (_egab *CT_PageFields) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _egab.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_egab.CountAttr)})
	}
	e.EncodeToken(start)
	_gaba := _f.StartElement{Name: _f.Name{Local: "ma:pageField"}}
	for _, _aaedg := range _egab.PageField {
		e.EncodeElement(_aaedg, _gaba)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_FontFamily struct{ ValAttr int64 }

const (
	ST_PaneUnset       ST_Pane = 0
	ST_PaneBottomRight ST_Pane = 1
	ST_PaneTopRight    ST_Pane = 2
	ST_PaneBottomLeft  ST_Pane = 3
	ST_PaneTopLeft     ST_Pane = 4
)

type CT_RevisionCellChange struct {

	// Sheet Id
	SIdAttr uint32

	// Old Formatting Information
	OdxfAttr *bool

	// Row Column Formatting Change
	XfDxfAttr *bool

	// Style Revision
	SAttr *bool

	// Formatting
	DxfAttr *bool

	// Number Format Id
	NumFmtIdAttr *uint32

	// Quote Prefix
	QuotePrefixAttr *bool

	// Old Quote Prefix
	OldQuotePrefixAttr *bool

	// Phonetic Text
	PhAttr *bool

	// Old Phonetic Text
	OldPhAttr *bool

	// End of List Formula Update
	EndOfListFormulaUpdateAttr *bool

	// Old Cell Data
	Oc *CT_Cell

	// New Cell Data
	Nc *CT_Cell

	// Old Formatting Information
	Odxf *CT_Dxf

	// New Formatting Information
	Ndxf    *CT_Dxf
	ExtLst  *CT_ExtensionList
	RIdAttr *uint32
	UaAttr  *bool
	RaAttr  *bool
}

// Validate validates the CT_Table and its children
func (_cffgcg *CT_Table) Validate() error { return _cffgcg.ValidateWithPath("CT_Table") }

type CT_WorkbookPr struct {

	// Date 1904
	Date1904Attr *bool

	// Show Objects
	ShowObjectsAttr ST_Objects

	// Show Border Unselected Table
	ShowBorderUnselectedTablesAttr *bool

	// Filter Privacy
	FilterPrivacyAttr *bool

	// Prompted Solutions
	PromptedSolutionsAttr *bool

	// Show Ink Annotations
	ShowInkAnnotationAttr *bool

	// Create Backup File
	BackupFileAttr *bool

	// Save External Link Values
	SaveExternalLinkValuesAttr *bool

	// Update Links Behavior
	UpdateLinksAttr ST_UpdateLinks

	// Code Name
	CodeNameAttr *string

	// Hide Pivot Field List
	HidePivotFieldListAttr *bool

	// Show Pivot Chart Filter
	ShowPivotChartFilterAttr *bool

	// Allow Refresh Query
	AllowRefreshQueryAttr *bool

	// Publish Items
	PublishItemsAttr *bool

	// Check Compatibility On Save
	CheckCompatibilityAttr *bool

	// Auto Compress Pictures
	AutoCompressPicturesAttr *bool

	// Refresh all Connections on Open
	RefreshAllConnectionsAttr *bool

	// Default Theme Version
	DefaultThemeVersionAttr *uint32
}
type CT_PivotCacheRecords struct {

	// PivotCache Records Count
	CountAttr *uint32

	// PivotCache Record
	R []*CT_Record

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}
type ST_DataValidationImeMode byte

// ValidateWithPath validates the CT_Dimensions and its children, prefixing error messages with path
func (_gdef *CT_Dimensions) ValidateWithPath(path string) error {
	for _edffd, _fegdfd := range _gdef.Dimension {
		if _abfb := _fegdfd.ValidateWithPath(_bg.Sprintf("\u0025s/Dimension\u005b\u0025d\u005d", path, _edffd)); _abfb != nil {
			return _abfb
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CommentList and its children, prefixing error messages with path
func (_dgef *CT_CommentList) ValidateWithPath(path string) error {
	for _edcac, _bbcc := range _dgef.Comment {
		if _cdcaa := _bbcc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fComment\u005b\u0025d\u005d", path, _edcac)); _cdcaa != nil {
			return _cdcaa
		}
	}
	return nil
}

// Validate validates the CT_RevisionRowColumn and its children
func (_edada *CT_RevisionRowColumn) Validate() error {
	return _edada.ValidateWithPath("CT_RevisionRowColumn")
}
func (_dabbc *CT_SheetCalcPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _afadaa := range start.Attr {
		if _afadaa.Name.Local == "fullCalcOnLoad" {
			_fgaeb, _cbdbf := _g.ParseBool(_afadaa.Value)
			if _cbdbf != nil {
				return _cbdbf
			}
			_dabbc.FullCalcOnLoadAttr = &_fgaeb
			continue
		}
	}
	for {
		_cbabc, _fgbgf := d.Token()
		if _fgbgf != nil {
			return _bg.Errorf("parsing\u0020CT_SheetCalcPr:\u0020\u0025s", _fgbgf)
		}
		if _geabd, _cefaf := _cbabc.(_f.EndElement); _cefaf && _geabd.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_RevisionInsertSheet and its children, prefixing error messages with path
func (_aeafe *CT_RevisionInsertSheet) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_Fills and its children
func (_ggccd *CT_Fills) Validate() error { return _ggccd.ValidateWithPath("CT_Fills") }
func (_gcb *CT_CalcPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gcb.CalcIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "calcId"}, Value: _bg.Sprintf("\u0025v", *_gcb.CalcIdAttr)})
	}
	if _gcb.CalcModeAttr != ST_CalcModeUnset {
		_bba, _dgff := _gcb.CalcModeAttr.MarshalXMLAttr(_f.Name{Local: "calcMode"})
		if _dgff != nil {
			return _dgff
		}
		start.Attr = append(start.Attr, _bba)
	}
	if _gcb.FullCalcOnLoadAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fullCalcOnLoad"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcb.FullCalcOnLoadAttr))})
	}
	if _gcb.RefModeAttr != ST_RefModeUnset {
		_effc, _ccddd := _gcb.RefModeAttr.MarshalXMLAttr(_f.Name{Local: "refMode"})
		if _ccddd != nil {
			return _ccddd
		}
		start.Attr = append(start.Attr, _effc)
	}
	if _gcb.IterateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "iterate"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcb.IterateAttr))})
	}
	if _gcb.IterateCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "iterateCount"}, Value: _bg.Sprintf("\u0025v", *_gcb.IterateCountAttr)})
	}
	if _gcb.IterateDeltaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "iterateDelta"}, Value: _bg.Sprintf("\u0025v", *_gcb.IterateDeltaAttr)})
	}
	if _gcb.FullPrecisionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fullPrecision"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcb.FullPrecisionAttr))})
	}
	if _gcb.CalcCompletedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "calcCompleted"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcb.CalcCompletedAttr))})
	}
	if _gcb.CalcOnSaveAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "calcOnSave"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcb.CalcOnSaveAttr))})
	}
	if _gcb.ConcurrentCalcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "concurrentCalc"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcb.ConcurrentCalcAttr))})
	}
	if _gcb.ConcurrentManualCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "concurrentManualCount"}, Value: _bg.Sprintf("\u0025v", *_gcb.ConcurrentManualCountAttr)})
	}
	if _gcb.ForceFullCalcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "forceFullCalc"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcb.ForceFullCalcAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_SheetView and its children, prefixing error messages with path
func (_debeg *CT_SheetView) ValidateWithPath(path string) error {
	if _gbgdd := _debeg.ViewAttr.ValidateWithPath(path + "\u002fViewAttr"); _gbgdd != nil {
		return _gbgdd
	}
	if _debeg.Pane != nil {
		if _agefbc := _debeg.Pane.ValidateWithPath(path + "\u002fPane"); _agefbc != nil {
			return _agefbc
		}
	}
	for _fagbaa, _dgggca := range _debeg.Selection {
		if _gffga := _dgggca.ValidateWithPath(_bg.Sprintf("\u0025s/Selection\u005b\u0025d\u005d", path, _fagbaa)); _gffga != nil {
			return _gffga
		}
	}
	for _gfgbc, _dcbabf := range _debeg.PivotSelection {
		if _bgbaff := _dcbabf.ValidateWithPath(_bg.Sprintf("%s\u002fPivotSelection\u005b\u0025d\u005d", path, _gfgbc)); _bgbaff != nil {
			return _bgbaff
		}
	}
	if _debeg.ExtLst != nil {
		if _aabad := _debeg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _aabad != nil {
			return _aabad
		}
	}
	return nil
}
func (_gecbdd *CT_QueryTableField) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _facbf := range start.Attr {
		if _facbf.Name.Local == "id" {
			_dabda, _ebeae := _g.ParseUint(_facbf.Value, 10, 32)
			if _ebeae != nil {
				return _ebeae
			}
			_gecbdd.IdAttr = uint32(_dabda)
			continue
		}
		if _facbf.Name.Local == "name" {
			_gfdae, _gcbga := _facbf.Value, error(nil)
			if _gcbga != nil {
				return _gcbga
			}
			_gecbdd.NameAttr = &_gfdae
			continue
		}
		if _facbf.Name.Local == "dataBound" {
			_dagee, _dbcgf := _g.ParseBool(_facbf.Value)
			if _dbcgf != nil {
				return _dbcgf
			}
			_gecbdd.DataBoundAttr = &_dagee
			continue
		}
		if _facbf.Name.Local == "rowNumbers" {
			_ffdfg, _dcedc := _g.ParseBool(_facbf.Value)
			if _dcedc != nil {
				return _dcedc
			}
			_gecbdd.RowNumbersAttr = &_ffdfg
			continue
		}
		if _facbf.Name.Local == "fillFormulas" {
			_fedef, _edbcg := _g.ParseBool(_facbf.Value)
			if _edbcg != nil {
				return _edbcg
			}
			_gecbdd.FillFormulasAttr = &_fedef
			continue
		}
		if _facbf.Name.Local == "clipped" {
			_eggdd, _cgacfc := _g.ParseBool(_facbf.Value)
			if _cgacfc != nil {
				return _cgacfc
			}
			_gecbdd.ClippedAttr = &_eggdd
			continue
		}
		if _facbf.Name.Local == "tableColumnId" {
			_bfbbbb, _dbcdd := _g.ParseUint(_facbf.Value, 10, 32)
			if _dbcdd != nil {
				return _dbcdd
			}
			_cedaa := uint32(_bfbbbb)
			_gecbdd.TableColumnIdAttr = &_cedaa
			continue
		}
	}
_bcfddf:
	for {
		_cefge, _ebgbf := d.Token()
		if _ebgbf != nil {
			return _ebgbf
		}
		switch _bcfae := _cefge.(type) {
		case _f.StartElement:
			switch _bcfae.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gecbdd.ExtLst = NewCT_ExtensionList()
				if _geggb := d.DecodeElement(_gecbdd.ExtLst, &_bcfae); _geggb != nil {
					return _geggb
				}
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_QueryTableField\u0020\u0025v", _bcfae.Name)
				if _caffe := d.Skip(); _caffe != nil {
					return _caffe
				}
			}
		case _f.EndElement:
			break _bcfddf
		case _f.CharData:
		}
	}
	return nil
}
func (_fdbdb *MapInfo) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:MapInfo"
	return _fdbdb.CT_MapInfo.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_IgnoredError and its children, prefixing error messages with path
func (_edceg *CT_IgnoredError) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_Members and its children, prefixing error messages with path
func (_ecgab *CT_Members) ValidateWithPath(path string) error {
	for _gagfc, _gbafd := range _ecgab.Member {
		if _ggdgga := _gbafd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fMember\u005b\u0025d\u005d", path, _gagfc)); _ggdgga != nil {
			return _ggdgga
		}
	}
	return nil
}

type CT_MetadataType struct {

	// Metadata Type Name
	NameAttr string

	// Minimum Supported Version
	MinSupportedVersionAttr uint32

	// Metadata Ghost Row
	GhostRowAttr *bool

	// Metadata Ghost Column
	GhostColAttr *bool

	// Metadata Edit
	EditAttr *bool

	// Metadata Cell Value Delete
	DeleteAttr *bool

	// Metadata Copy
	CopyAttr *bool

	// Metadata Paste All
	PasteAllAttr *bool

	// Metadata Paste Formulas
	PasteFormulasAttr *bool

	// Metadata Paste Special Values
	PasteValuesAttr *bool

	// Metadata Paste Formats
	PasteFormatsAttr *bool

	// Metadata Paste Comments
	PasteCommentsAttr *bool

	// Metadata Paste Data Validation
	PasteDataValidationAttr *bool

	// Metadata Paste Borders
	PasteBordersAttr *bool

	// Metadata Paste Column Widths
	PasteColWidthsAttr *bool

	// Metadata Paste Number Formats
	PasteNumberFormatsAttr *bool

	// Metadata Merge
	MergeAttr *bool

	// Meatadata Split First
	SplitFirstAttr *bool

	// Metadata Split All
	SplitAllAttr *bool

	// Metadata Insert Delete
	RowColShiftAttr *bool

	// Metadata Clear All
	ClearAllAttr *bool

	// Metadata Clear Formats
	ClearFormatsAttr *bool

	// Metadata Clear Contents
	ClearContentsAttr *bool

	// Metadata Clear Comments
	ClearCommentsAttr *bool

	// Metadata Formula Assignment
	AssignAttr *bool

	// Metadata Coercion
	CoerceAttr *bool

	// Adjust Metadata
	AdjustAttr *bool

	// Cell Metadata
	CellMetaAttr *bool
}

func (_ggcf *CT_DataRef) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cgccc := range start.Attr {
		if _cgccc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _cgccc.Name.Local == "id" || _cgccc.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _cgccc.Name.Local == "id" {
			_dgeed, _gdbfgd := _cgccc.Value, error(nil)
			if _gdbfgd != nil {
				return _gdbfgd
			}
			_ggcf.IdAttr = &_dgeed
			continue
		}
		if _cgccc.Name.Local == "ref" {
			_aegg, _bcfge := _cgccc.Value, error(nil)
			if _bcfge != nil {
				return _bcfge
			}
			_ggcf.RefAttr = &_aegg
			continue
		}
		if _cgccc.Name.Local == "name" {
			_bada, _afdcc := _cgccc.Value, error(nil)
			if _afdcc != nil {
				return _afdcc
			}
			_ggcf.NameAttr = &_bada
			continue
		}
		if _cgccc.Name.Local == "sheet" {
			_ffefg, _egbec := _cgccc.Value, error(nil)
			if _egbec != nil {
				return _egbec
			}
			_ggcf.SheetAttr = &_ffefg
			continue
		}
	}
	for {
		_gcae, _fbgcf := d.Token()
		if _fbgcf != nil {
			return _bg.Errorf("parsing\u0020CT_DataRef:\u0020%s", _fbgcf)
		}
		if _fbaf, _egdc := _gcae.(_f.EndElement); _egdc && _fbaf.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_DdeLink and its children
func (_agea *CT_DdeLink) Validate() error { return _agea.ValidateWithPath("CT_DdeLink") }
func (_acade *CT_DataRefs) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _acade.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_acade.CountAttr)})
	}
	e.EncodeToken(start)
	if _acade.DataRef != nil {
		_fcgc := _f.StartElement{Name: _f.Name{Local: "ma:dataRef"}}
		for _, _edcec := range _acade.DataRef {
			e.EncodeElement(_edcec, _fcgc)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dbbad *CT_UnderlineProperty) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ebdacf := range start.Attr {
		if _ebdacf.Name.Local == "val" {
			_dbbad.ValAttr.UnmarshalXMLAttr(_ebdacf)
			continue
		}
	}
	for {
		_dbaaf, _dcddc := d.Token()
		if _dcddc != nil {
			return _bg.Errorf("parsing\u0020CT_UnderlineProperty:\u0020\u0025s", _dcddc)
		}
		if _abaea, _cgeabg := _dbaaf.(_f.EndElement); _cgeabg && _abaea.Name == start.Name {
			break
		}
	}
	return nil
}
func (_baf *CT_Break) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _baf.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", *_baf.IdAttr)})
	}
	if _baf.MinAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "min"}, Value: _bg.Sprintf("\u0025v", *_baf.MinAttr)})
	}
	if _baf.MaxAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "max"}, Value: _bg.Sprintf("\u0025v", *_baf.MaxAttr)})
	}
	if _baf.ManAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "man"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_baf.ManAttr))})
	}
	if _baf.PtAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pt"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_baf.PtAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Set and its children
func (_faggb *CT_Set) Validate() error { return _faggb.ValidateWithPath("CT_Set") }

// ValidateWithPath validates the CT_TableColumns and its children, prefixing error messages with path
func (_ffbdfg *CT_TableColumns) ValidateWithPath(path string) error {
	for _dcaeg, _baddee := range _ffbdfg.TableColumn {
		if _bggga := _baddee.ValidateWithPath(_bg.Sprintf("\u0025s\u002fTableColumn\u005b\u0025d\u005d", path, _dcaeg)); _bggga != nil {
			return _bggga
		}
	}
	return nil
}

// Validate validates the CT_CustomProperties and its children
func (_fccf *CT_CustomProperties) Validate() error {
	return _fccf.ValidateWithPath("CT_CustomProperties")
}

// Validate validates the CT_MemberProperty and its children
func (_gcbeb *CT_MemberProperty) Validate() error {
	return _gcbeb.ValidateWithPath("CT_MemberProperty")
}

// Validate validates the CT_FontName and its children
func (_baabd *CT_FontName) Validate() error { return _baabd.ValidateWithPath("CT_FontName") }
func (_cagdef *CT_OleObject) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cagdef.ProgIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "progId"}, Value: _bg.Sprintf("\u0025v", *_cagdef.ProgIdAttr)})
	}
	if _cagdef.DvAspectAttr != ST_DvAspectUnset {
		_ecccc, _ececgg := _cagdef.DvAspectAttr.MarshalXMLAttr(_f.Name{Local: "dvAspect"})
		if _ececgg != nil {
			return _ececgg
		}
		start.Attr = append(start.Attr, _ecccc)
	}
	if _cagdef.LinkAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "link"}, Value: _bg.Sprintf("\u0025v", *_cagdef.LinkAttr)})
	}
	if _cagdef.OleUpdateAttr != ST_OleUpdateUnset {
		_bebbe, _gbgde := _cagdef.OleUpdateAttr.MarshalXMLAttr(_f.Name{Local: "oleUpdate"})
		if _gbgde != nil {
			return _gbgde
		}
		start.Attr = append(start.Attr, _bebbe)
	}
	if _cagdef.AutoLoadAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoLoad"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cagdef.AutoLoadAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "shapeId"}, Value: _bg.Sprintf("\u0025v", _cagdef.ShapeIdAttr)})
	if _cagdef.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", *_cagdef.IdAttr)})
	}
	e.EncodeToken(start)
	if _cagdef.ObjectPr != nil {
		_acaeee := _f.StartElement{Name: _f.Name{Local: "ma:objectPr"}}
		e.EncodeElement(_cagdef.ObjectPr, _acaeee)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_CellXfs and its children
func (_ccdf *CT_CellXfs) Validate() error { return _ccdf.ValidateWithPath("CT_CellXfs") }

// ValidateWithPath validates the CT_rowItems and its children, prefixing error messages with path
func (_dgdfb *CT_rowItems) ValidateWithPath(path string) error {
	for _agdgcb, _fbbag := range _dgdfb.I {
		if _cfbed := _fbbag.ValidateWithPath(_bg.Sprintf("\u0025s\u002fI\u005b\u0025d\u005d", path, _agdgcb)); _cfbed != nil {
			return _cfbed
		}
	}
	return nil
}

// Validate validates the CT_ExternalLink and its children
func (_acgea *CT_ExternalLink) Validate() error { return _acgea.ValidateWithPath("CT_ExternalLink") }

type CT_Break struct {

	// Id
	IdAttr *uint32

	// Minimum
	MinAttr *uint32

	// Maximum
	MaxAttr *uint32

	// Manual Page Break
	ManAttr *bool

	// Pivot-Created Page Break
	PtAttr *bool
}
type ST_SmartTagShow byte

// ValidateWithPath validates the CT_DateTime and its children, prefixing error messages with path
func (_ecgg *CT_DateTime) ValidateWithPath(path string) error {
	for _cffbb, _babg := range _ecgg.X {
		if _cebge := _babg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fX\u005b\u0025d\u005d", path, _cffbb)); _cebge != nil {
			return _cebge
		}
	}
	return nil
}

type CT_QueryTableFields struct {

	// Column Count
	CountAttr *uint32

	// QueryTable Field
	QueryTableField []*CT_QueryTableField
}
type CT_RPrElt struct {

	// Font
	RFont *CT_FontName

	// Character Set
	Charset *CT_IntProperty

	// Font Family
	Family *CT_IntProperty

	// Bold
	B *CT_BooleanProperty

	// Italic
	I *CT_BooleanProperty

	// Strike Through
	Strike *CT_BooleanProperty

	// Outline
	Outline *CT_BooleanProperty

	// Shadow
	Shadow *CT_BooleanProperty

	// Condense
	Condense *CT_BooleanProperty

	// Extend
	Extend *CT_BooleanProperty

	// Text Color
	Color *CT_Color

	// Font Size
	Sz *CT_FontSize

	// Underline
	U *CT_UnderlineProperty

	// Vertical Alignment
	VertAlign *CT_VerticalAlignFontProperty

	// Font Scheme
	Scheme *CT_FontScheme
}

func (_bdbbae *CT_RangeSets) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bdbbae.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bdbbae.CountAttr)})
	}
	e.EncodeToken(start)
	_dafba := _f.StartElement{Name: _f.Name{Local: "ma:rangeSet"}}
	for _, _ffabf := range _bdbbae.RangeSet {
		e.EncodeElement(_ffabf, _dafba)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_eccacg *CT_SmartTagPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _eccacg.EmbedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "embed"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eccacg.EmbedAttr))})
	}
	if _eccacg.ShowAttr != ST_SmartTagShowUnset {
		_dccacf, _gdcdc := _eccacg.ShowAttr.MarshalXMLAttr(_f.Name{Local: "show"})
		if _gdcdc != nil {
			return _gdcdc
		}
		start.Attr = append(start.Attr, _dccacf)
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_eccd *CT_CustomWorkbookView) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_eccd.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	for _, _fegf := range start.Attr {
		if _fegf.Name.Local == "showVerticalScroll" {
			_bcef, _cgagg := _g.ParseBool(_fegf.Value)
			if _cgagg != nil {
				return _cgagg
			}
			_eccd.ShowVerticalScrollAttr = &_bcef
			continue
		}
		if _fegf.Name.Local == "showSheetTabs" {
			_afdb, _agac := _g.ParseBool(_fegf.Value)
			if _agac != nil {
				return _agac
			}
			_eccd.ShowSheetTabsAttr = &_afdb
			continue
		}
		if _fegf.Name.Local == "guid" {
			_effdd, _bbbc := _fegf.Value, error(nil)
			if _bbbc != nil {
				return _bbbc
			}
			_eccd.GuidAttr = _effdd
			continue
		}
		if _fegf.Name.Local == "xWindow" {
			_daba, _fdcbb := _g.ParseInt(_fegf.Value, 10, 32)
			if _fdcbb != nil {
				return _fdcbb
			}
			_bafb := int32(_daba)
			_eccd.XWindowAttr = &_bafb
			continue
		}
		if _fegf.Name.Local == "mergeInterval" {
			_fbbac, _dacb := _g.ParseUint(_fegf.Value, 10, 32)
			if _dacb != nil {
				return _dacb
			}
			_dfbg := uint32(_fbbac)
			_eccd.MergeIntervalAttr = &_dfbg
			continue
		}
		if _fegf.Name.Local == "yWindow" {
			_dabab, _gbeaa := _g.ParseInt(_fegf.Value, 10, 32)
			if _gbeaa != nil {
				return _gbeaa
			}
			_baffd := int32(_dabab)
			_eccd.YWindowAttr = &_baffd
			continue
		}
		if _fegf.Name.Local == "onlySync" {
			_eabcb, _bbag := _g.ParseBool(_fegf.Value)
			if _bbag != nil {
				return _bbag
			}
			_eccd.OnlySyncAttr = &_eabcb
			continue
		}
		if _fegf.Name.Local == "windowWidth" {
			_bebeae, _dfdg := _g.ParseUint(_fegf.Value, 10, 32)
			if _dfdg != nil {
				return _dfdg
			}
			_eccd.WindowWidthAttr = uint32(_bebeae)
			continue
		}
		if _fegf.Name.Local == "includePrintSettings" {
			_fdgcb, _ddba := _g.ParseBool(_fegf.Value)
			if _ddba != nil {
				return _ddba
			}
			_eccd.IncludePrintSettingsAttr = &_fdgcb
			continue
		}
		if _fegf.Name.Local == "windowHeight" {
			_dfde, _ecddc := _g.ParseUint(_fegf.Value, 10, 32)
			if _ecddc != nil {
				return _ecddc
			}
			_eccd.WindowHeightAttr = uint32(_dfde)
			continue
		}
		if _fegf.Name.Local == "tabRatio" {
			_cecab, _fggbb := _g.ParseUint(_fegf.Value, 10, 32)
			if _fggbb != nil {
				return _fggbb
			}
			_eabab := uint32(_cecab)
			_eccd.TabRatioAttr = &_eabab
			continue
		}
		if _fegf.Name.Local == "showFormulaBar" {
			_acfg, _aebc := _g.ParseBool(_fegf.Value)
			if _aebc != nil {
				return _aebc
			}
			_eccd.ShowFormulaBarAttr = &_acfg
			continue
		}
		if _fegf.Name.Local == "changesSavedWin" {
			_aagb, _agaec := _g.ParseBool(_fegf.Value)
			if _agaec != nil {
				return _agaec
			}
			_eccd.ChangesSavedWinAttr = &_aagb
			continue
		}
		if _fegf.Name.Local == "maximized" {
			_debg, _ffce := _g.ParseBool(_fegf.Value)
			if _ffce != nil {
				return _ffce
			}
			_eccd.MaximizedAttr = &_debg
			continue
		}
		if _fegf.Name.Local == "showComments" {
			_eccd.ShowCommentsAttr.UnmarshalXMLAttr(_fegf)
			continue
		}
		if _fegf.Name.Local == "autoUpdate" {
			_fgda, _ccce := _g.ParseBool(_fegf.Value)
			if _ccce != nil {
				return _ccce
			}
			_eccd.AutoUpdateAttr = &_fgda
			continue
		}
		if _fegf.Name.Local == "activeSheetId" {
			_edega, _fcba := _g.ParseUint(_fegf.Value, 10, 32)
			if _fcba != nil {
				return _fcba
			}
			_eccd.ActiveSheetIdAttr = uint32(_edega)
			continue
		}
		if _fegf.Name.Local == "showHorizontalScroll" {
			_afbga, _fbda := _g.ParseBool(_fegf.Value)
			if _fbda != nil {
				return _fbda
			}
			_eccd.ShowHorizontalScrollAttr = &_afbga
			continue
		}
		if _fegf.Name.Local == "showStatusbar" {
			_bcbg, _cffaa := _g.ParseBool(_fegf.Value)
			if _cffaa != nil {
				return _cffaa
			}
			_eccd.ShowStatusbarAttr = &_bcbg
			continue
		}
		if _fegf.Name.Local == "personalView" {
			_ggfgb, _cfafc := _g.ParseBool(_fegf.Value)
			if _cfafc != nil {
				return _cfafc
			}
			_eccd.PersonalViewAttr = &_ggfgb
			continue
		}
		if _fegf.Name.Local == "minimized" {
			_fdcc, _cagc := _g.ParseBool(_fegf.Value)
			if _cagc != nil {
				return _cagc
			}
			_eccd.MinimizedAttr = &_fdcc
			continue
		}
		if _fegf.Name.Local == "showObjects" {
			_eccd.ShowObjectsAttr.UnmarshalXMLAttr(_fegf)
			continue
		}
		if _fegf.Name.Local == "name" {
			_gbafe, _beebb := _fegf.Value, error(nil)
			if _beebb != nil {
				return _beebb
			}
			_eccd.NameAttr = _gbafe
			continue
		}
		if _fegf.Name.Local == "includeHiddenRowCol" {
			_ccddb, _acacg := _g.ParseBool(_fegf.Value)
			if _acacg != nil {
				return _acacg
			}
			_eccd.IncludeHiddenRowColAttr = &_ccddb
			continue
		}
	}
_eccce:
	for {
		_adef, _acgb := d.Token()
		if _acgb != nil {
			return _acgb
		}
		switch _gefdg := _adef.(type) {
		case _f.StartElement:
			switch _gefdg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_eccd.ExtLst = NewCT_ExtensionList()
				if _bdcd := d.DecodeElement(_eccd.ExtLst, &_gefdg); _bdcd != nil {
					return _bdcd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on CT_CustomWorkbookView\u0020\u0025v", _gefdg.Name)
				if _fagfg := d.Skip(); _fagfg != nil {
					return _fagfg
				}
			}
		case _f.EndElement:
			break _eccce
		case _f.CharData:
		}
	}
	return nil
}
func (_feafg ST_HorizontalAlignment) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_feafg.String(), start)
}
func (_acbdf *CT_RevisionRowColumn) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sId"}, Value: _bg.Sprintf("\u0025v", _acbdf.SIdAttr)})
	if _acbdf.EolAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "eol"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbdf.EolAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _acbdf.RefAttr)})
	_eacee, _dfafg := _acbdf.ActionAttr.MarshalXMLAttr(_f.Name{Local: "action"})
	if _dfafg != nil {
		return _dfafg
	}
	start.Attr = append(start.Attr, _eacee)
	if _acbdf.EdgeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "edge"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbdf.EdgeAttr))})
	}
	if _acbdf.RIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rId"}, Value: _bg.Sprintf("\u0025v", *_acbdf.RIdAttr)})
	}
	if _acbdf.UaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ua"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbdf.UaAttr))})
	}
	if _acbdf.RaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ra"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbdf.RaAttr))})
	}
	e.EncodeToken(start)
	if _acbdf.Undo != nil {
		_cdfbb := _f.StartElement{Name: _f.Name{Local: "ma:undo"}}
		for _, _bgdad := range _acbdf.Undo {
			e.EncodeElement(_bgdad, _cdfbb)
		}
	}
	if _acbdf.Rcc != nil {
		_bdcee := _f.StartElement{Name: _f.Name{Local: "ma:rcc"}}
		for _, _cegde := range _acbdf.Rcc {
			e.EncodeElement(_cegde, _bdcee)
		}
	}
	if _acbdf.Rfmt != nil {
		_gfgabf := _f.StartElement{Name: _f.Name{Local: "ma:rfmt"}}
		for _, _agfee := range _acbdf.Rfmt {
			e.EncodeElement(_agfee, _gfgabf)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_PivotHierarchy and its children
func (_aggb *CT_PivotHierarchy) Validate() error { return _aggb.ValidateWithPath("CT_PivotHierarchy") }
func (_fde *AG_RevData) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bdf := range start.Attr {
		if _bdf.Name.Local == "rId" {
			_ab, _aeb := _g.ParseUint(_bdf.Value, 10, 32)
			if _aeb != nil {
				return _aeb
			}
			_bef := uint32(_ab)
			_fde.RIdAttr = &_bef
			continue
		}
		if _bdf.Name.Local == "ua" {
			_cg, _dc := _g.ParseBool(_bdf.Value)
			if _dc != nil {
				return _dc
			}
			_fde.UaAttr = &_cg
			continue
		}
		if _bdf.Name.Local == "ra" {
			_dd, _cdf := _g.ParseBool(_bdf.Value)
			if _cdf != nil {
				return _cdf
			}
			_fde.RaAttr = &_dd
			continue
		}
	}
	for {
		_fg, _da := d.Token()
		if _da != nil {
			return _bg.Errorf("parsing\u0020AG_RevData:\u0020%s", _da)
		}
		if _fc, _bb := _fg.(_f.EndElement); _bb && _fc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_caa *AG_RevData) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _caa.RIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rId"}, Value: _bg.Sprintf("\u0025v", *_caa.RIdAttr)})
	}
	if _caa.UaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ua"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caa.UaAttr))})
	}
	if _caa.RaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ra"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caa.RaAttr))})
	}
	return nil
}

type CT_DbPr struct {

	// Connection String
	ConnectionAttr string

	// Command Text
	CommandAttr *string

	// Command Text
	ServerCommandAttr *string

	// OLE DB Command Type
	CommandTypeAttr *uint32
}

func (_fabag ST_DynamicFilterType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_gffggf := _f.Attr{}
	_gffggf.Name = name
	switch _fabag {
	case ST_DynamicFilterTypeUnset:
		_gffggf.Value = ""
	case ST_DynamicFilterTypeNull:
		_gffggf.Value = "null"
	case ST_DynamicFilterTypeAboveAverage:
		_gffggf.Value = "aboveAverage"
	case ST_DynamicFilterTypeBelowAverage:
		_gffggf.Value = "belowAverage"
	case ST_DynamicFilterTypeTomorrow:
		_gffggf.Value = "tomorrow"
	case ST_DynamicFilterTypeToday:
		_gffggf.Value = "today"
	case ST_DynamicFilterTypeYesterday:
		_gffggf.Value = "yesterday"
	case ST_DynamicFilterTypeNextWeek:
		_gffggf.Value = "nextWeek"
	case ST_DynamicFilterTypeThisWeek:
		_gffggf.Value = "thisWeek"
	case ST_DynamicFilterTypeLastWeek:
		_gffggf.Value = "lastWeek"
	case ST_DynamicFilterTypeNextMonth:
		_gffggf.Value = "nextMonth"
	case ST_DynamicFilterTypeThisMonth:
		_gffggf.Value = "thisMonth"
	case ST_DynamicFilterTypeLastMonth:
		_gffggf.Value = "lastMonth"
	case ST_DynamicFilterTypeNextQuarter:
		_gffggf.Value = "nextQuarter"
	case ST_DynamicFilterTypeThisQuarter:
		_gffggf.Value = "thisQuarter"
	case ST_DynamicFilterTypeLastQuarter:
		_gffggf.Value = "lastQuarter"
	case ST_DynamicFilterTypeNextYear:
		_gffggf.Value = "nextYear"
	case ST_DynamicFilterTypeThisYear:
		_gffggf.Value = "thisYear"
	case ST_DynamicFilterTypeLastYear:
		_gffggf.Value = "lastYear"
	case ST_DynamicFilterTypeYearToDate:
		_gffggf.Value = "yearToDate"
	case ST_DynamicFilterTypeQ1:
		_gffggf.Value = "Q1"
	case ST_DynamicFilterTypeQ2:
		_gffggf.Value = "Q2"
	case ST_DynamicFilterTypeQ3:
		_gffggf.Value = "Q3"
	case ST_DynamicFilterTypeQ4:
		_gffggf.Value = "Q4"
	case ST_DynamicFilterTypeM1:
		_gffggf.Value = "M1"
	case ST_DynamicFilterTypeM2:
		_gffggf.Value = "M2"
	case ST_DynamicFilterTypeM3:
		_gffggf.Value = "M3"
	case ST_DynamicFilterTypeM4:
		_gffggf.Value = "M4"
	case ST_DynamicFilterTypeM5:
		_gffggf.Value = "M5"
	case ST_DynamicFilterTypeM6:
		_gffggf.Value = "M6"
	case ST_DynamicFilterTypeM7:
		_gffggf.Value = "M7"
	case ST_DynamicFilterTypeM8:
		_gffggf.Value = "M8"
	case ST_DynamicFilterTypeM9:
		_gffggf.Value = "M9"
	case ST_DynamicFilterTypeM10:
		_gffggf.Value = "M10"
	case ST_DynamicFilterTypeM11:
		_gffggf.Value = "M11"
	case ST_DynamicFilterTypeM12:
		_gffggf.Value = "M12"
	}
	return _gffggf, nil
}

type CT_Tuple struct {

	// Field Index
	FldAttr *uint32

	// Hierarchy Index
	HierAttr *uint32

	// Item Index
	ItemAttr uint32
}

func NewCT_XStringElement() *CT_XStringElement { _caaegg := &CT_XStringElement{}; return _caaegg }

// Validate validates the CT_CellFormula and its children
func (_fddg *CT_CellFormula) Validate() error { return _fddg.ValidateWithPath("CT_CellFormula") }
func (_agebd *CT_QueryTableRefresh) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_agebd.QueryTableFields = NewCT_QueryTableFields()
	for _, _fcfcd := range start.Attr {
		if _fcfcd.Name.Local == "preserveSortFilterLayout" {
			_abeed, _dgacd := _g.ParseBool(_fcfcd.Value)
			if _dgacd != nil {
				return _dgacd
			}
			_agebd.PreserveSortFilterLayoutAttr = &_abeed
			continue
		}
		if _fcfcd.Name.Local == "fieldIdWrapped" {
			_afeg, _ebfdab := _g.ParseBool(_fcfcd.Value)
			if _ebfdab != nil {
				return _ebfdab
			}
			_agebd.FieldIdWrappedAttr = &_afeg
			continue
		}
		if _fcfcd.Name.Local == "headersInLastRefresh" {
			_fdfdg, _ebfcg := _g.ParseBool(_fcfcd.Value)
			if _ebfcg != nil {
				return _ebfcg
			}
			_agebd.HeadersInLastRefreshAttr = &_fdfdg
			continue
		}
		if _fcfcd.Name.Local == "minimumVersion" {
			_gfcdcg, _eacge := _g.ParseUint(_fcfcd.Value, 10, 8)
			if _eacge != nil {
				return _eacge
			}
			_cgbgf := uint8(_gfcdcg)
			_agebd.MinimumVersionAttr = &_cgbgf
			continue
		}
		if _fcfcd.Name.Local == "nextId" {
			_fbgcg, _gedecg := _g.ParseUint(_fcfcd.Value, 10, 32)
			if _gedecg != nil {
				return _gedecg
			}
			_eceac := uint32(_fbgcg)
			_agebd.NextIdAttr = &_eceac
			continue
		}
		if _fcfcd.Name.Local == "unboundColumnsLeft" {
			_fabbe, _ffgcbf := _g.ParseUint(_fcfcd.Value, 10, 32)
			if _ffgcbf != nil {
				return _ffgcbf
			}
			_adadf := uint32(_fabbe)
			_agebd.UnboundColumnsLeftAttr = &_adadf
			continue
		}
		if _fcfcd.Name.Local == "unboundColumnsRight" {
			_fbbfe, _ebcdc := _g.ParseUint(_fcfcd.Value, 10, 32)
			if _ebcdc != nil {
				return _ebcdc
			}
			_acfgf := uint32(_fbbfe)
			_agebd.UnboundColumnsRightAttr = &_acfgf
			continue
		}
	}
_adabd:
	for {
		_aefgd, _egcdg := d.Token()
		if _egcdg != nil {
			return _egcdg
		}
		switch _cagcf := _aefgd.(type) {
		case _f.StartElement:
			switch _cagcf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "queryTableFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "queryTableFields"}:
				if _fbfbec := d.DecodeElement(_agebd.QueryTableFields, &_cagcf); _fbfbec != nil {
					return _fbfbec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "queryTableDeletedFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "queryTableDeletedFields"}:
				_agebd.QueryTableDeletedFields = NewCT_QueryTableDeletedFields()
				if _feccde := d.DecodeElement(_agebd.QueryTableDeletedFields, &_cagcf); _feccde != nil {
					return _feccde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sortState"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sortState"}:
				_agebd.SortState = NewCT_SortState()
				if _aadac := d.DecodeElement(_agebd.SortState, &_cagcf); _aadac != nil {
					return _aadac
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_agebd.ExtLst = NewCT_ExtensionList()
				if _afggf := d.DecodeElement(_agebd.ExtLst, &_cagcf); _afggf != nil {
					return _afggf
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on\u0020CT_QueryTableRefresh\u0020\u0025v", _cagcf.Name)
				if _acbdc := d.Skip(); _acbdc != nil {
					return _acbdc
				}
			}
		case _f.EndElement:
			break _adabd
		case _f.CharData:
		}
	}
	return nil
}

type CT_Members struct {

	// Item Count
	CountAttr *uint32

	// Hierarchy Level
	LevelAttr *uint32

	// Member
	Member []*CT_Member
}

func (_aafebb *ST_PatternType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bfedd, _ffagf := d.Token()
	if _ffagf != nil {
		return _ffagf
	}
	if _eaggf, _gdgbb := _bfedd.(_f.EndElement); _gdgbb && _eaggf.Name == start.Name {
		*_aafebb = 1
		return nil
	}
	if _bebdc, _gddaff := _bfedd.(_f.CharData); !_gddaff {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bfedd)
	} else {
		switch string(_bebdc) {
		case "":
			*_aafebb = 0
		case "none":
			*_aafebb = 1
		case "solid":
			*_aafebb = 2
		case "mediumGray":
			*_aafebb = 3
		case "darkGray":
			*_aafebb = 4
		case "lightGray":
			*_aafebb = 5
		case "darkHorizontal":
			*_aafebb = 6
		case "darkVertical":
			*_aafebb = 7
		case "darkDown":
			*_aafebb = 8
		case "darkUp":
			*_aafebb = 9
		case "darkGrid":
			*_aafebb = 10
		case "darkTrellis":
			*_aafebb = 11
		case "lightHorizontal":
			*_aafebb = 12
		case "lightVertical":
			*_aafebb = 13
		case "lightDown":
			*_aafebb = 14
		case "lightUp":
			*_aafebb = 15
		case "lightGrid":
			*_aafebb = 16
		case "lightTrellis":
			*_aafebb = 17
		case "gray125":
			*_aafebb = 18
		case "gray0625":
			*_aafebb = 19
		}
	}
	_bfedd, _ffagf = d.Token()
	if _ffagf != nil {
		return _ffagf
	}
	if _efgae, _caecc := _bfedd.(_f.EndElement); _caecc && _efgae.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bfedd)
}
func NewCT_CellXfs() *CT_CellXfs { _cabbc := &CT_CellXfs{}; return _cabbc }

// Validate validates the CT_DataField and its children
func (_gdaae *CT_DataField) Validate() error { return _gdaae.ValidateWithPath("CT_DataField") }

// Validate validates the CT_ColorFilter and its children
func (_dgcef *CT_ColorFilter) Validate() error { return _dgcef.ValidateWithPath("CT_ColorFilter") }
func (_fdccae *ST_Scope) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_fdccae = 0
	case "selection":
		*_fdccae = 1
	case "data":
		*_fdccae = 2
	case "field":
		*_fdccae = 3
	}
	return nil
}
func (_cggb *CT_FutureMetadata) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aadg := range start.Attr {
		if _aadg.Name.Local == "name" {
			_bgbe, _bgeef := _aadg.Value, error(nil)
			if _bgeef != nil {
				return _bgeef
			}
			_cggb.NameAttr = _bgbe
			continue
		}
		if _aadg.Name.Local == "count" {
			_ffced, _bbdcf := _g.ParseUint(_aadg.Value, 10, 32)
			if _bbdcf != nil {
				return _bbdcf
			}
			_dbed := uint32(_ffced)
			_cggb.CountAttr = &_dbed
			continue
		}
	}
_agfdf:
	for {
		_deaca, _deeg := d.Token()
		if _deeg != nil {
			return _deeg
		}
		switch _bggdd := _deaca.(type) {
		case _f.StartElement:
			switch _bggdd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "bk"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "bk"}:
				_eabgb := NewCT_FutureMetadataBlock()
				if _agebb := d.DecodeElement(_eabgb, &_bggdd); _agebb != nil {
					return _agebb
				}
				_cggb.Bk = append(_cggb.Bk, _eabgb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_cggb.ExtLst = NewCT_ExtensionList()
				if _cffg := d.DecodeElement(_cggb.ExtLst, &_bggdd); _cffg != nil {
					return _cffg
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_FutureMetadata\u0020\u0025v", _bggdd.Name)
				if _ebaee := d.Skip(); _ebaee != nil {
					return _ebaee
				}
			}
		case _f.EndElement:
			break _agfdf
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_Sets() *CT_Sets { _geege := &CT_Sets{}; return _geege }
func (_abebg *CT_pivotTableDefinition) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _abebg.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cacheId"}, Value: _bg.Sprintf("\u0025v", _abebg.CacheIdAttr)})
	if _abebg.DataOnRowsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataOnRows"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.DataOnRowsAttr))})
	}
	if _abebg.DataPositionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataPosition"}, Value: _bg.Sprintf("\u0025v", *_abebg.DataPositionAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataCaption"}, Value: _bg.Sprintf("\u0025v", _abebg.DataCaptionAttr)})
	if _abebg.GrandTotalCaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "grandTotalCaption"}, Value: _bg.Sprintf("\u0025v", *_abebg.GrandTotalCaptionAttr)})
	}
	if _abebg.ErrorCaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "errorCaption"}, Value: _bg.Sprintf("\u0025v", *_abebg.ErrorCaptionAttr)})
	}
	if _abebg.ShowErrorAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showError"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowErrorAttr))})
	}
	if _abebg.MissingCaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "missingCaption"}, Value: _bg.Sprintf("\u0025v", *_abebg.MissingCaptionAttr)})
	}
	if _abebg.ShowMissingAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showMissing"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowMissingAttr))})
	}
	if _abebg.PageStyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pageStyle"}, Value: _bg.Sprintf("\u0025v", *_abebg.PageStyleAttr)})
	}
	if _abebg.PivotTableStyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pivotTableStyle"}, Value: _bg.Sprintf("\u0025v", *_abebg.PivotTableStyleAttr)})
	}
	if _abebg.VacatedStyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "vacatedStyle"}, Value: _bg.Sprintf("\u0025v", *_abebg.VacatedStyleAttr)})
	}
	if _abebg.TagAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "tag"}, Value: _bg.Sprintf("\u0025v", *_abebg.TagAttr)})
	}
	if _abebg.UpdatedVersionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "updatedVersion"}, Value: _bg.Sprintf("\u0025v", *_abebg.UpdatedVersionAttr)})
	}
	if _abebg.MinRefreshableVersionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minRefreshableVersion"}, Value: _bg.Sprintf("\u0025v", *_abebg.MinRefreshableVersionAttr)})
	}
	if _abebg.AsteriskTotalsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "asteriskTotals"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.AsteriskTotalsAttr))})
	}
	if _abebg.ShowItemsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showItems"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowItemsAttr))})
	}
	if _abebg.EditDataAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "editData"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.EditDataAttr))})
	}
	if _abebg.DisableFieldListAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "disableFieldList"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.DisableFieldListAttr))})
	}
	if _abebg.ShowCalcMbrsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showCalcMbrs"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowCalcMbrsAttr))})
	}
	if _abebg.VisualTotalsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "visualTotals"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.VisualTotalsAttr))})
	}
	if _abebg.ShowMultipleLabelAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showMultipleLabel"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowMultipleLabelAttr))})
	}
	if _abebg.ShowDataDropDownAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showDataDropDown"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowDataDropDownAttr))})
	}
	if _abebg.ShowDrillAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showDrill"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowDrillAttr))})
	}
	if _abebg.PrintDrillAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "printDrill"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.PrintDrillAttr))})
	}
	if _abebg.ShowMemberPropertyTipsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showMemberPropertyTips"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowMemberPropertyTipsAttr))})
	}
	if _abebg.ShowDataTipsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showDataTips"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowDataTipsAttr))})
	}
	if _abebg.EnableWizardAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "enableWizard"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.EnableWizardAttr))})
	}
	if _abebg.EnableDrillAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "enableDrill"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.EnableDrillAttr))})
	}
	if _abebg.EnableFieldPropertiesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "enableFieldProperties"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.EnableFieldPropertiesAttr))})
	}
	if _abebg.PreserveFormattingAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "preserveFormatting"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.PreserveFormattingAttr))})
	}
	if _abebg.UseAutoFormattingAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "useAutoFormatting"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.UseAutoFormattingAttr))})
	}
	if _abebg.PageWrapAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pageWrap"}, Value: _bg.Sprintf("\u0025v", *_abebg.PageWrapAttr)})
	}
	if _abebg.PageOverThenDownAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pageOverThenDown"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.PageOverThenDownAttr))})
	}
	if _abebg.SubtotalHiddenItemsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "subtotalHiddenItems"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.SubtotalHiddenItemsAttr))})
	}
	if _abebg.RowGrandTotalsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rowGrandTotals"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.RowGrandTotalsAttr))})
	}
	if _abebg.ColGrandTotalsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "colGrandTotals"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ColGrandTotalsAttr))})
	}
	if _abebg.FieldPrintTitlesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fieldPrintTitles"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.FieldPrintTitlesAttr))})
	}
	if _abebg.ItemPrintTitlesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "itemPrintTitles"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ItemPrintTitlesAttr))})
	}
	if _abebg.MergeItemAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "mergeItem"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.MergeItemAttr))})
	}
	if _abebg.ShowDropZonesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showDropZones"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowDropZonesAttr))})
	}
	if _abebg.CreatedVersionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "createdVersion"}, Value: _bg.Sprintf("\u0025v", *_abebg.CreatedVersionAttr)})
	}
	if _abebg.IndentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "indent"}, Value: _bg.Sprintf("\u0025v", *_abebg.IndentAttr)})
	}
	if _abebg.ShowEmptyRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showEmptyRow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowEmptyRowAttr))})
	}
	if _abebg.ShowEmptyColAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showEmptyCol"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowEmptyColAttr))})
	}
	if _abebg.ShowHeadersAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showHeaders"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ShowHeadersAttr))})
	}
	if _abebg.CompactAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "compact"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.CompactAttr))})
	}
	if _abebg.OutlineAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "outline"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.OutlineAttr))})
	}
	if _abebg.OutlineDataAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "outlineData"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.OutlineDataAttr))})
	}
	if _abebg.CompactDataAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "compactData"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.CompactDataAttr))})
	}
	if _abebg.PublishedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "published"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.PublishedAttr))})
	}
	if _abebg.GridDropZonesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "gridDropZones"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.GridDropZonesAttr))})
	}
	if _abebg.ImmersiveAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "immersive"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ImmersiveAttr))})
	}
	if _abebg.MultipleFieldFiltersAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "multipleFieldFilters"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.MultipleFieldFiltersAttr))})
	}
	if _abebg.ChartFormatAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "chartFormat"}, Value: _bg.Sprintf("\u0025v", *_abebg.ChartFormatAttr)})
	}
	if _abebg.RowHeaderCaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rowHeaderCaption"}, Value: _bg.Sprintf("\u0025v", *_abebg.RowHeaderCaptionAttr)})
	}
	if _abebg.ColHeaderCaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "colHeaderCaption"}, Value: _bg.Sprintf("\u0025v", *_abebg.ColHeaderCaptionAttr)})
	}
	if _abebg.FieldListSortAscendingAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fieldListSortAscending"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.FieldListSortAscendingAttr))})
	}
	if _abebg.MdxSubqueriesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "mdxSubqueries"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.MdxSubqueriesAttr))})
	}
	if _abebg.CustomListSortAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "customListSort"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.CustomListSortAttr))})
	}
	if _abebg.AutoFormatIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoFormatId"}, Value: _bg.Sprintf("\u0025v", *_abebg.AutoFormatIdAttr)})
	}
	if _abebg.ApplyNumberFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyNumberFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ApplyNumberFormatsAttr))})
	}
	if _abebg.ApplyBorderFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyBorderFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ApplyBorderFormatsAttr))})
	}
	if _abebg.ApplyFontFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyFontFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ApplyFontFormatsAttr))})
	}
	if _abebg.ApplyPatternFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyPatternFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ApplyPatternFormatsAttr))})
	}
	if _abebg.ApplyAlignmentFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyAlignmentFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ApplyAlignmentFormatsAttr))})
	}
	if _abebg.ApplyWidthHeightFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyWidthHeightFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abebg.ApplyWidthHeightFormatsAttr))})
	}
	e.EncodeToken(start)
	_dceba := _f.StartElement{Name: _f.Name{Local: "ma:location"}}
	e.EncodeElement(_abebg.Location, _dceba)
	if _abebg.PivotFields != nil {
		_edbddc := _f.StartElement{Name: _f.Name{Local: "ma:pivotFields"}}
		e.EncodeElement(_abebg.PivotFields, _edbddc)
	}
	if _abebg.RowFields != nil {
		_ecdfaf := _f.StartElement{Name: _f.Name{Local: "ma:rowFields"}}
		e.EncodeElement(_abebg.RowFields, _ecdfaf)
	}
	if _abebg.RowItems != nil {
		_fagfb := _f.StartElement{Name: _f.Name{Local: "ma:rowItems"}}
		e.EncodeElement(_abebg.RowItems, _fagfb)
	}
	if _abebg.ColFields != nil {
		_ecbgd := _f.StartElement{Name: _f.Name{Local: "ma:colFields"}}
		e.EncodeElement(_abebg.ColFields, _ecbgd)
	}
	if _abebg.ColItems != nil {
		_ggeaa := _f.StartElement{Name: _f.Name{Local: "ma:colItems"}}
		e.EncodeElement(_abebg.ColItems, _ggeaa)
	}
	if _abebg.PageFields != nil {
		_egbgcf := _f.StartElement{Name: _f.Name{Local: "ma:pageFields"}}
		e.EncodeElement(_abebg.PageFields, _egbgcf)
	}
	if _abebg.DataFields != nil {
		_fbadab := _f.StartElement{Name: _f.Name{Local: "ma:dataFields"}}
		e.EncodeElement(_abebg.DataFields, _fbadab)
	}
	if _abebg.Formats != nil {
		_baecfc := _f.StartElement{Name: _f.Name{Local: "ma:formats"}}
		e.EncodeElement(_abebg.Formats, _baecfc)
	}
	if _abebg.ConditionalFormats != nil {
		_ccdddg := _f.StartElement{Name: _f.Name{Local: "ma:conditionalFormats"}}
		e.EncodeElement(_abebg.ConditionalFormats, _ccdddg)
	}
	if _abebg.ChartFormats != nil {
		_bfbfge := _f.StartElement{Name: _f.Name{Local: "ma:chartFormats"}}
		e.EncodeElement(_abebg.ChartFormats, _bfbfge)
	}
	if _abebg.PivotHierarchies != nil {
		_dbeaa := _f.StartElement{Name: _f.Name{Local: "ma:pivotHierarchies"}}
		e.EncodeElement(_abebg.PivotHierarchies, _dbeaa)
	}
	if _abebg.PivotTableStyleInfo != nil {
		_edcbee := _f.StartElement{Name: _f.Name{Local: "ma:pivotTableStyleInfo"}}
		e.EncodeElement(_abebg.PivotTableStyleInfo, _edcbee)
	}
	if _abebg.Filters != nil {
		_cegfc := _f.StartElement{Name: _f.Name{Local: "ma:filters"}}
		e.EncodeElement(_abebg.Filters, _cegfc)
	}
	if _abebg.RowHierarchiesUsage != nil {
		_beabb := _f.StartElement{Name: _f.Name{Local: "ma:rowHierarchiesUsage"}}
		e.EncodeElement(_abebg.RowHierarchiesUsage, _beabb)
	}
	if _abebg.ColHierarchiesUsage != nil {
		_adeaeb := _f.StartElement{Name: _f.Name{Local: "ma:colHierarchiesUsage"}}
		e.EncodeElement(_abebg.ColHierarchiesUsage, _adeaeb)
	}
	if _abebg.ExtLst != nil {
		_efbbfb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_abebg.ExtLst, _efbbfb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ddebag *CT_XmlPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "mapId"}, Value: _bg.Sprintf("\u0025v", _ddebag.MapIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xpath"}, Value: _bg.Sprintf("\u0025v", _ddebag.XpathAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlDataType"}, Value: _bg.Sprintf("\u0025v", _ddebag.XmlDataTypeAttr)})
	e.EncodeToken(start)
	if _ddebag.ExtLst != nil {
		_bgcgc := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_ddebag.ExtLst, _bgcgc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the PivotTableDefinition and its children, prefixing error messages with path
func (_gbgec *PivotTableDefinition) ValidateWithPath(path string) error {
	if _cageab := _gbgec.CT_pivotTableDefinition.ValidateWithPath(path); _cageab != nil {
		return _cageab
	}
	return nil
}
func NewCT_MeasureDimensionMap() *CT_MeasureDimensionMap {
	_eaccc := &CT_MeasureDimensionMap{}
	return _eaccc
}
func NewCT_MemberProperty() *CT_MemberProperty { _cgaab := &CT_MemberProperty{}; return _cgaab }

// Validate validates the CT_PageFields and its children
func (_bgagb *CT_PageFields) Validate() error { return _bgagb.ValidateWithPath("CT_PageFields") }

// Validate validates the CT_DefinedName and its children
func (_agbac *CT_DefinedName) Validate() error { return _agbac.ValidateWithPath("CT_DefinedName") }
func NewCT_VolMain() *CT_VolMain               { _fgdab := &CT_VolMain{}; return _fgdab }

// ValidateWithPath validates the CT_RevisionConflict and its children, prefixing error messages with path
func (_cbfda *CT_RevisionConflict) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_LevelGroup and its children, prefixing error messages with path
func (_gcea *CT_LevelGroup) ValidateWithPath(path string) error {
	if _bcda := _gcea.GroupMembers.ValidateWithPath(path + "\u002fGroupMembers"); _bcda != nil {
		return _bcda
	}
	return nil
}
func (_ebbecb *CT_Cfvo) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ebbecb.TypeAttr = ST_CfvoType(1)
	for _, _dccc := range start.Attr {
		if _dccc.Name.Local == "type" {
			_ebbecb.TypeAttr.UnmarshalXMLAttr(_dccc)
			continue
		}
		if _dccc.Name.Local == "val" {
			_gfcf, _caaef := _dccc.Value, error(nil)
			if _caaef != nil {
				return _caaef
			}
			_ebbecb.ValAttr = &_gfcf
			continue
		}
		if _dccc.Name.Local == "gte" {
			_feab, _adaf := _g.ParseBool(_dccc.Value)
			if _adaf != nil {
				return _adaf
			}
			_ebbecb.GteAttr = &_feab
			continue
		}
	}
_aedg:
	for {
		_cdgda, _dfaf := d.Token()
		if _dfaf != nil {
			return _dfaf
		}
		switch _ggda := _cdgda.(type) {
		case _f.StartElement:
			switch _ggda.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ebbecb.ExtLst = NewCT_ExtensionList()
				if _cebg := d.DecodeElement(_ebbecb.ExtLst, &_ggda); _cebg != nil {
					return _cebg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Cfvo\u0020\u0025v", _ggda.Name)
				if _dgbcf := d.Skip(); _dgbcf != nil {
					return _dgbcf
				}
			}
		case _f.EndElement:
			break _aedg
		case _f.CharData:
		}
	}
	return nil
}
func (_fdecde ST_WebSourceType) Validate() error { return _fdecde.ValidateWithPath("") }

type CT_MRUColors struct {

	// Color
	Color []*CT_Color
}

func (_acfga *CT_GradientStop) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "position"}, Value: _bg.Sprintf("\u0025v", _acfga.PositionAttr)})
	e.EncodeToken(start)
	_ffbg := _f.StartElement{Name: _f.Name{Local: "ma:color"}}
	e.EncodeElement(_acfga.Color, _ffbg)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_RangePr struct {

	// Source Data Set Beginning Range
	AutoStartAttr *bool

	// Source Data Ending Range
	AutoEndAttr *bool

	// Group By
	GroupByAttr ST_GroupBy

	// Numeric Grouping Start Value
	StartNumAttr *float64

	// Numeric Grouping End Value
	EndNumAttr *float64

	// Date Grouping Start Value
	StartDateAttr *_b.Time

	// Date Grouping End Value
	EndDateAttr *_b.Time

	// Grouping Interval
	GroupIntervalAttr *float64
}

func (_eacggf *ST_ShowDataAs) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_eacggf = 0
	case "normal":
		*_eacggf = 1
	case "difference":
		*_eacggf = 2
	case "percent":
		*_eacggf = 3
	case "percentDiff":
		*_eacggf = 4
	case "runTotal":
		*_eacggf = 5
	case "percentOfRow":
		*_eacggf = 6
	case "percentOfCol":
		*_eacggf = 7
	case "percentOfTotal":
		*_eacggf = 8
	case "index":
		*_eacggf = 9
	}
	return nil
}
func (_bafa *CT_ExternalLink) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_dfaef:
	for {
		_geef, _ebfb := d.Token()
		if _ebfb != nil {
			return _ebfb
		}
		switch _fdgda := _geef.(type) {
		case _f.StartElement:
			switch _fdgda.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "externalBook"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "externalBook"}:
				_bafa.Choice = NewCT_ExternalLinkChoice()
				if _aabf := d.DecodeElement(&_bafa.Choice.ExternalBook, &_fdgda); _aabf != nil {
					return _aabf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ddeLink"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ddeLink"}:
				_bafa.Choice = NewCT_ExternalLinkChoice()
				if _bafag := d.DecodeElement(&_bafa.Choice.DdeLink, &_fdgda); _bafag != nil {
					return _bafag
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleLink"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleLink"}:
				_bafa.Choice = NewCT_ExternalLinkChoice()
				if _ecggc := d.DecodeElement(&_bafa.Choice.OleLink, &_fdgda); _ecggc != nil {
					return _ecggc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bafa.ExtLst = NewCT_ExtensionList()
				if _bbgff := d.DecodeElement(_bafa.ExtLst, &_fdgda); _bbgff != nil {
					return _bbgff
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ExternalLink\u0020\u0025v", _fdgda.Name)
				if _bfdgb := d.Skip(); _bfdgb != nil {
					return _bfdgb
				}
			}
		case _f.EndElement:
			break _dfaef
		case _f.CharData:
		}
	}
	return nil
}
func (_dadccb *CT_QueryTableFields) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dadccb.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_dadccb.CountAttr)})
	}
	e.EncodeToken(start)
	if _dadccb.QueryTableField != nil {
		_ageab := _f.StartElement{Name: _f.Name{Local: "ma:queryTableField"}}
		for _, _ggdcbf := range _dadccb.QueryTableField {
			e.EncodeElement(_ggdcbf, _ageab)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_CustomProperties struct {

	// Custom Property
	CustomPr []*CT_CustomProperty
}

func (_acggf *CT_CustomProperties) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_cdgaa:
	for {
		_fdae, _eafeg := d.Token()
		if _eafeg != nil {
			return _eafeg
		}
		switch _aabe := _fdae.(type) {
		case _f.StartElement:
			switch _aabe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customPr"}:
				_ccafe := NewCT_CustomProperty()
				if _acdf := d.DecodeElement(_ccafe, &_aabe); _acdf != nil {
					return _acdf
				}
				_acggf.CustomPr = append(_acggf.CustomPr, _ccafe)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CustomProperties\u0020\u0025v", _aabe.Name)
				if _dfgb := d.Skip(); _dfgb != nil {
					return _dfgb
				}
			}
		case _f.EndElement:
			break _cdgaa
		case _f.CharData:
		}
	}
	return nil
}

type CT_MemberProperties struct {

	// OLAP Member Properties Count
	CountAttr *uint32

	// OLAP Member Property
	Mp []*CT_MemberProperty
}

const (
	ST_ConditionalFormattingOperatorUnset              ST_ConditionalFormattingOperator = 0
	ST_ConditionalFormattingOperatorLessThan           ST_ConditionalFormattingOperator = 1
	ST_ConditionalFormattingOperatorLessThanOrEqual    ST_ConditionalFormattingOperator = 2
	ST_ConditionalFormattingOperatorEqual              ST_ConditionalFormattingOperator = 3
	ST_ConditionalFormattingOperatorNotEqual           ST_ConditionalFormattingOperator = 4
	ST_ConditionalFormattingOperatorGreaterThanOrEqual ST_ConditionalFormattingOperator = 5
	ST_ConditionalFormattingOperatorGreaterThan        ST_ConditionalFormattingOperator = 6
	ST_ConditionalFormattingOperatorBetween            ST_ConditionalFormattingOperator = 7
	ST_ConditionalFormattingOperatorNotBetween         ST_ConditionalFormattingOperator = 8
	ST_ConditionalFormattingOperatorContainsText       ST_ConditionalFormattingOperator = 9
	ST_ConditionalFormattingOperatorNotContains        ST_ConditionalFormattingOperator = 10
	ST_ConditionalFormattingOperatorBeginsWith         ST_ConditionalFormattingOperator = 11
	ST_ConditionalFormattingOperatorEndsWith           ST_ConditionalFormattingOperator = 12
)

func (_abacc *CT_GradientFill) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _abacc.TypeAttr != ST_GradientTypeUnset {
		_eebfec, _gaeba := _abacc.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
		if _gaeba != nil {
			return _gaeba
		}
		start.Attr = append(start.Attr, _eebfec)
	}
	if _abacc.DegreeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "degree"}, Value: _bg.Sprintf("\u0025v", *_abacc.DegreeAttr)})
	}
	if _abacc.LeftAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "left"}, Value: _bg.Sprintf("\u0025v", *_abacc.LeftAttr)})
	}
	if _abacc.RightAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "right"}, Value: _bg.Sprintf("\u0025v", *_abacc.RightAttr)})
	}
	if _abacc.TopAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "top"}, Value: _bg.Sprintf("\u0025v", *_abacc.TopAttr)})
	}
	if _abacc.BottomAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "bottom"}, Value: _bg.Sprintf("\u0025v", *_abacc.BottomAttr)})
	}
	e.EncodeToken(start)
	if _abacc.Stop != nil {
		_fecgd := _f.StartElement{Name: _f.Name{Local: "ma:stop"}}
		for _, _efee := range _abacc.Stop {
			e.EncodeElement(_efee, _fecgd)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_I and its children
func (_gbfea *CT_I) Validate() error { return _gbfea.ValidateWithPath("CT_I") }

type CT_Scenarios struct {

	// Current Scenario
	CurrentAttr *uint32

	// Last Shown Scenario
	ShowAttr *uint32

	// Sequence of References
	SqrefAttr *ST_Sqref

	// Scenario
	Scenario []*CT_Scenario
}

// Validate validates the CT_Dimensions and its children
func (_accf *CT_Dimensions) Validate() error { return _accf.ValidateWithPath("CT_Dimensions") }
func (_dafgd *CT_FontFamily) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", _dafgd.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Pane and its children, prefixing error messages with path
func (_ecdea *CT_Pane) ValidateWithPath(path string) error {
	if _dbbdc := _ecdea.ActivePaneAttr.ValidateWithPath(path + "\u002fActivePaneAttr"); _dbbdc != nil {
		return _dbbdc
	}
	if _eddga := _ecdea.StateAttr.ValidateWithPath(path + "\u002fStateAttr"); _eddga != nil {
		return _eddga
	}
	return nil
}
func (_gfdca ST_PhoneticAlignment) ValidateWithPath(path string) error {
	switch _gfdca {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gfdca))
	}
	return nil
}
func (_cgfbc *SingleXmlCells) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cgfbc.CT_SingleXmlCells = *NewCT_SingleXmlCells()
_ebaafa:
	for {
		_ffcfe, _geceab := d.Token()
		if _geceab != nil {
			return _geceab
		}
		switch _dfffa := _ffcfe.(type) {
		case _f.StartElement:
			switch _dfffa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "singleXmlCell"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "singleXmlCell"}:
				_fcgaad := NewCT_SingleXmlCell()
				if _dcgbc := d.DecodeElement(_fcgaad, &_dfffa); _dcgbc != nil {
					return _dcgbc
				}
				_cgfbc.SingleXmlCell = append(_cgfbc.SingleXmlCell, _fcgaad)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020SingleXmlCells\u0020\u0025v", _dfffa.Name)
				if _ggaag := d.Skip(); _ggaag != nil {
					return _ggaag
				}
			}
		case _f.EndElement:
			break _ebaafa
		case _f.CharData:
		}
	}
	return nil
}

type CT_ProtectedRange struct {

	// Legacy Password
	PasswordAttr *string

	// Sequence of References
	SqrefAttr ST_Sqref

	// Name
	NameAttr string

	// Security Descriptor
	SecurityDescriptorAttr *string

	// Cryptographic Algorithm Name
	AlgorithmNameAttr *string

	// Password Hash Value
	HashValueAttr *string

	// Salt Value for Password Verifier
	SaltValueAttr *string

	// Iterations to Run Hashing Algorithm
	SpinCountAttr *uint32

	// Security Descriptor
	SecurityDescriptor []string
}

func (_eeegc ST_VolDepType) ValidateWithPath(path string) error {
	switch _eeegc {
	case 0, 1, 2:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eeegc))
	}
	return nil
}
func (_bcga *CT_IndexedColors) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_dcgcc := _f.StartElement{Name: _f.Name{Local: "ma:rgbColor"}}
	for _, _fbdece := range _bcga.RgbColor {
		e.EncodeElement(_fbdece, _dcgcc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Sheets and its children
func (_abbead *CT_Sheets) Validate() error { return _abbead.ValidateWithPath("CT_Sheets") }

// ValidateWithPath validates the CT_CalculatedItems and its children, prefixing error messages with path
func (_egfe *CT_CalculatedItems) ValidateWithPath(path string) error {
	for _dbc, _fcga := range _egfe.CalculatedItem {
		if _fddc := _fcga.ValidateWithPath(_bg.Sprintf("%s\u002fCalculatedItem\u005b\u0025d\u005d", path, _dbc)); _fddc != nil {
			return _fddc
		}
	}
	return nil
}
func (_fcefa *CT_TablePart) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _fcefa.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_ExternalLink struct {
	Choice *CT_ExternalLinkChoice
	ExtLst *CT_ExtensionList
}

func NewMapInfo() *MapInfo { _acabb := &MapInfo{}; _acabb.CT_MapInfo = *NewCT_MapInfo(); return _acabb }

// Validate validates the CT_SheetPr and its children
func (_fgeaa *CT_SheetPr) Validate() error { return _fgeaa.ValidateWithPath("CT_SheetPr") }
func (_bgcg *CT_DataBinding) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dffec := range start.Attr {
		if _dffec.Name.Local == "DataBindingName" {
			_acdd, _ccgd := _dffec.Value, error(nil)
			if _ccgd != nil {
				return _ccgd
			}
			_bgcg.DataBindingNameAttr = &_acdd
			continue
		}
		if _dffec.Name.Local == "FileBinding" {
			_dgbcd, _edef := _g.ParseBool(_dffec.Value)
			if _edef != nil {
				return _edef
			}
			_bgcg.FileBindingAttr = &_dgbcd
			continue
		}
		if _dffec.Name.Local == "ConnectionID" {
			_afbad, _eeeg := _g.ParseUint(_dffec.Value, 10, 32)
			if _eeeg != nil {
				return _eeeg
			}
			_cddgd := uint32(_afbad)
			_bgcg.ConnectionIDAttr = &_cddgd
			continue
		}
		if _dffec.Name.Local == "FileBindingName" {
			_dfbe, _daaa := _dffec.Value, error(nil)
			if _daaa != nil {
				return _daaa
			}
			_bgcg.FileBindingNameAttr = &_dfbe
			continue
		}
		if _dffec.Name.Local == "DataBindingLoadMode" {
			_gfff, _acfed := _g.ParseUint(_dffec.Value, 10, 32)
			if _acfed != nil {
				return _acfed
			}
			_bgcg.DataBindingLoadModeAttr = uint32(_gfff)
			continue
		}
	}
_eeddf:
	for {
		_effb, _cfdgc := d.Token()
		if _cfdgc != nil {
			return _cfdgc
		}
		switch _cfeff := _effb.(type) {
		case _f.StartElement:
			switch _cfeff.Name {
			default:
				if _eaafc, _ggbge := _cb.CreateElement(_cfeff); _ggbge != nil {
					return _ggbge
				} else {
					if _gcbaeb := d.DecodeElement(_eaafc, &_cfeff); _gcbaeb != nil {
						return _gcbaeb
					}
					_bgcg.Any = _eaafc
				}
			}
		case _f.EndElement:
			break _eeddf
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_Pages() *CT_Pages { _agdba := &CT_Pages{}; return _agdba }

type CT_FontSize struct {

	// Value
	ValAttr float64
}
type CT_SortCondition struct {

	// Descending
	DescendingAttr *bool

	// Sort By
	SortByAttr ST_SortBy

	// Reference
	RefAttr string

	// Custom List
	CustomListAttr *string

	// Format Id
	DxfIdAttr *uint32

	// Icon Set
	IconSetAttr ST_IconSetType

	// Icon Id
	IconIdAttr *uint32
}

func (_feded *CT_ExternalDefinedNames) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_eedcg:
	for {
		_cafeg, _fcbd := d.Token()
		if _fcbd != nil {
			return _fcbd
		}
		switch _egafa := _cafeg.(type) {
		case _f.StartElement:
			switch _egafa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "definedName"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "definedName"}:
				_gbdae := NewCT_ExternalDefinedName()
				if _cafbe := d.DecodeElement(_gbdae, &_egafa); _cafbe != nil {
					return _cafbe
				}
				_feded.DefinedName = append(_feded.DefinedName, _gbdae)
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_ExternalDefinedNames \u0025v", _egafa.Name)
				if _gege := d.Skip(); _gege != nil {
					return _gege
				}
			}
		case _f.EndElement:
			break _eedcg
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_RevisionMove and its children, prefixing error messages with path
func (_fcaef *CT_RevisionMove) ValidateWithPath(path string) error {
	for _bgdbe, _aggac := range _fcaef.Undo {
		if _fabac := _aggac.ValidateWithPath(_bg.Sprintf("%s\u002fUndo\u005b\u0025d\u005d", path, _bgdbe)); _fabac != nil {
			return _fabac
		}
	}
	for _gdabc, _edeed := range _fcaef.Rcc {
		if _bdcgc := _edeed.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRcc\u005b\u0025d\u005d", path, _gdabc)); _bdcgc != nil {
			return _bdcgc
		}
	}
	for _febdbd, _fabbeg := range _fcaef.Rfmt {
		if _gbbbe := _fabbeg.ValidateWithPath(_bg.Sprintf("%s\u002fRfmt\u005b\u0025d\u005d", path, _febdbd)); _gbbbe != nil {
			return _gbbbe
		}
	}
	return nil
}

// Validate validates the CT_ColHierarchiesUsage and its children
func (_ggbga *CT_ColHierarchiesUsage) Validate() error {
	return _ggbga.ValidateWithPath("CT_ColHierarchiesUsage")
}

const (
	ST_DdeValueTypeUnset ST_DdeValueType = 0
	ST_DdeValueTypeNil   ST_DdeValueType = 1
	ST_DdeValueTypeB     ST_DdeValueType = 2
	ST_DdeValueTypeN     ST_DdeValueType = 3
	ST_DdeValueTypeE     ST_DdeValueType = 4
	ST_DdeValueTypeStr   ST_DdeValueType = 5
)

func (_bfacdd ST_BorderStyle) ValidateWithPath(path string) error {
	switch _bfacdd {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bfacdd))
	}
	return nil
}
func (_dfefd *ST_GradientType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bcdae, _bfddg := d.Token()
	if _bfddg != nil {
		return _bfddg
	}
	if _bacag, _eaeda := _bcdae.(_f.EndElement); _eaeda && _bacag.Name == start.Name {
		*_dfefd = 1
		return nil
	}
	if _gaabf, _bcgaa := _bcdae.(_f.CharData); !_bcgaa {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bcdae)
	} else {
		switch string(_gaabf) {
		case "":
			*_dfefd = 0
		case "linear":
			*_dfefd = 1
		case "path":
			*_dfefd = 2
		}
	}
	_bcdae, _bfddg = d.Token()
	if _bfddg != nil {
		return _bfddg
	}
	if _bccgca, _bbdecd := _bcdae.(_f.EndElement); _bbdecd && _bccgca.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bcdae)
}

// ValidateWithPath validates the CT_PivotCache and its children, prefixing error messages with path
func (_cdgga *CT_PivotCache) ValidateWithPath(path string) error { return nil }

const (
	ST_ItemTypeUnset   ST_ItemType = 0
	ST_ItemTypeData    ST_ItemType = 1
	ST_ItemTypeDefault ST_ItemType = 2
	ST_ItemTypeSum     ST_ItemType = 3
	ST_ItemTypeCountA  ST_ItemType = 4
	ST_ItemTypeAvg     ST_ItemType = 5
	ST_ItemTypeMax     ST_ItemType = 6
	ST_ItemTypeMin     ST_ItemType = 7
	ST_ItemTypeProduct ST_ItemType = 8
	ST_ItemTypeCount   ST_ItemType = 9
	ST_ItemTypeStdDev  ST_ItemType = 10
	ST_ItemTypeStdDevP ST_ItemType = 11
	ST_ItemTypeVar     ST_ItemType = 12
	ST_ItemTypeVarP    ST_ItemType = 13
	ST_ItemTypeGrand   ST_ItemType = 14
	ST_ItemTypeBlank   ST_ItemType = 15
)

// Validate validates the CT_pivotTableDefinition and its children
func (_fcegg *CT_pivotTableDefinition) Validate() error {
	return _fcegg.ValidateWithPath("CT_pivotTableDefinition")
}

// ValidateWithPath validates the CT_PivotAreaReferences and its children, prefixing error messages with path
func (_afddb *CT_PivotAreaReferences) ValidateWithPath(path string) error {
	for _babaa, _ddaag := range _afddb.Reference {
		if _dbbfe := _ddaag.ValidateWithPath(_bg.Sprintf("\u0025s/Reference\u005b\u0025d\u005d", path, _babaa)); _dbbfe != nil {
			return _dbbfe
		}
	}
	return nil
}

type CT_PivotFilter struct {

	// Field Index
	FldAttr uint32

	// Member Property Field Id
	MpFldAttr *uint32

	// Pivot Filter Type
	TypeAttr ST_PivotFilterType

	// Evaluation Order
	EvalOrderAttr *int32

	// Pivot Filter Id
	IdAttr uint32

	// Measure Index
	IMeasureHierAttr *uint32

	// Measure Field Index
	IMeasureFldAttr *uint32

	// Pivot Filter Name
	NameAttr *string

	// Pivot Filter Description
	DescriptionAttr *string

	// Label Pivot
	StringValue1Attr *string

	// Label Pivot Filter String Value 2
	StringValue2Attr *string

	// Auto Filter
	AutoFilter *CT_AutoFilter
	ExtLst     *CT_ExtensionList
}

// Validate validates the CT_Chartsheet and its children
func (_gcag *CT_Chartsheet) Validate() error { return _gcag.ValidateWithPath("CT_Chartsheet") }
func NewExternalLink() *ExternalLink {
	_bagaaa := &ExternalLink{}
	_bagaaa.CT_ExternalLink = *NewCT_ExternalLink()
	return _bagaaa
}
func (_babge ST_DataValidationImeMode) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_babge.String(), start)
}
func (_cagbc *CT_PCDSDTCEntries) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bdbab := range start.Attr {
		if _bdbab.Name.Local == "count" {
			_agbbe, _defdf := _g.ParseUint(_bdbab.Value, 10, 32)
			if _defdf != nil {
				return _defdf
			}
			_cfbab := uint32(_agbbe)
			_cagbc.CountAttr = &_cfbab
			continue
		}
	}
_cedaf:
	for {
		_facgg, _bddgac := d.Token()
		if _bddgac != nil {
			return _bddgac
		}
		switch _fabea := _facgg.(type) {
		case _f.StartElement:
			switch _fabea.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "m"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "m"}:
				_eafdfb := NewCT_Missing()
				if _agde := d.DecodeElement(_eafdfb, &_fabea); _agde != nil {
					return _agde
				}
				_cagbc.M = append(_cagbc.M, _eafdfb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "n"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "n"}:
				_eaafbg := NewCT_Number()
				if _bagce := d.DecodeElement(_eaafbg, &_fabea); _bagce != nil {
					return _bagce
				}
				_cagbc.N = append(_cagbc.N, _eaafbg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "e"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "e"}:
				_fcaeg := NewCT_Error()
				if _gbgdc := d.DecodeElement(_fcaeg, &_fabea); _gbgdc != nil {
					return _gbgdc
				}
				_cagbc.E = append(_cagbc.E, _fcaeg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "s"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "s"}:
				_baadb := NewCT_String()
				if _cgbge := d.DecodeElement(_baadb, &_fabea); _cgbge != nil {
					return _cgbge
				}
				_cagbc.S = append(_cagbc.S, _baadb)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_PCDSDTCEntries\u0020\u0025v", _fabea.Name)
				if _ecggd := d.Skip(); _ecggd != nil {
					return _ecggd
				}
			}
		case _f.EndElement:
			break _cedaf
		case _f.CharData:
		}
	}
	return nil
}
func (_defa *CT_HierarchyUsage) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hierarchyUsage"}, Value: _bg.Sprintf("\u0025v", _defa.HierarchyUsageAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bbfgd *ST_PrintError) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bbfgd = 0
	case "displayed":
		*_bbfgd = 1
	case "blank":
		*_bbfgd = 2
	case "dash":
		*_bbfgd = 3
	case "NA":
		*_bbfgd = 4
	}
	return nil
}

// ValidateWithPath validates the CT_BooleanProperty and its children, prefixing error messages with path
func (_cbgg *CT_BooleanProperty) ValidateWithPath(path string) error { return nil }

type CT_Dxfs struct {

	// Format Count
	CountAttr *uint32

	// Formatting
	Dxf []*CT_Dxf
}

// ValidateWithPath validates the CT_CacheFields and its children, prefixing error messages with path
func (_cfg *CT_CacheFields) ValidateWithPath(path string) error {
	for _fefc, _cce := range _cfg.CacheField {
		if _dgfa := _cce.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCacheField\u005b\u0025d\u005d", path, _fefc)); _dgfa != nil {
			return _dgfa
		}
	}
	return nil
}
func (_ffcefgg *Worksheet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:worksheet"
	return _ffcefgg.CT_Worksheet.MarshalXML(e, start)
}

// Validate validates the CT_Map and its children
func (_agcef *CT_Map) Validate() error { return _agcef.ValidateWithPath("CT_Map") }

// Validate validates the CT_CellSmartTags and its children
func (_ebdb *CT_CellSmartTags) Validate() error { return _ebdb.ValidateWithPath("CT_CellSmartTags") }
func (_egdab *CT_SingleXmlCells) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_aacfc:
	for {
		_bebbed, _bfced := d.Token()
		if _bfced != nil {
			return _bfced
		}
		switch _bdecg := _bebbed.(type) {
		case _f.StartElement:
			switch _bdecg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "singleXmlCell"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "singleXmlCell"}:
				_cedab := NewCT_SingleXmlCell()
				if _bfbfb := d.DecodeElement(_cedab, &_bdecg); _bfbfb != nil {
					return _bfbfb
				}
				_egdab.SingleXmlCell = append(_egdab.SingleXmlCell, _cedab)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_SingleXmlCells\u0020\u0025v", _bdecg.Name)
				if _gbfdgb := d.Skip(); _gbfdgb != nil {
					return _gbfdgb
				}
			}
		case _f.EndElement:
			break _aacfc
		case _f.CharData:
		}
	}
	return nil
}
func (_ddfdbf *CT_Revisions) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _ddfdbf.Rrc != nil {
		_cedaaa := _f.StartElement{Name: _f.Name{Local: "ma:rrc"}}
		for _, _affg := range _ddfdbf.Rrc {
			e.EncodeElement(_affg, _cedaaa)
		}
	}
	if _ddfdbf.Rm != nil {
		_aaced := _f.StartElement{Name: _f.Name{Local: "ma:rm"}}
		for _, _cccbe := range _ddfdbf.Rm {
			e.EncodeElement(_cccbe, _aaced)
		}
	}
	if _ddfdbf.Rcv != nil {
		_gddaa := _f.StartElement{Name: _f.Name{Local: "ma:rcv"}}
		for _, _gface := range _ddfdbf.Rcv {
			e.EncodeElement(_gface, _gddaa)
		}
	}
	if _ddfdbf.Rsnm != nil {
		_gbaab := _f.StartElement{Name: _f.Name{Local: "ma:rsnm"}}
		for _, _abegc := range _ddfdbf.Rsnm {
			e.EncodeElement(_abegc, _gbaab)
		}
	}
	if _ddfdbf.Ris != nil {
		_dbbca := _f.StartElement{Name: _f.Name{Local: "ma:ris"}}
		for _, _cbeff := range _ddfdbf.Ris {
			e.EncodeElement(_cbeff, _dbbca)
		}
	}
	if _ddfdbf.Rcc != nil {
		_baeed := _f.StartElement{Name: _f.Name{Local: "ma:rcc"}}
		for _, _ffgfe := range _ddfdbf.Rcc {
			e.EncodeElement(_ffgfe, _baeed)
		}
	}
	if _ddfdbf.Rfmt != nil {
		_fdgbf := _f.StartElement{Name: _f.Name{Local: "ma:rfmt"}}
		for _, _gfccd := range _ddfdbf.Rfmt {
			e.EncodeElement(_gfccd, _fdgbf)
		}
	}
	if _ddfdbf.Raf != nil {
		_ccgba := _f.StartElement{Name: _f.Name{Local: "ma:raf"}}
		for _, _debef := range _ddfdbf.Raf {
			e.EncodeElement(_debef, _ccgba)
		}
	}
	if _ddfdbf.Rdn != nil {
		_gfaacd := _f.StartElement{Name: _f.Name{Local: "ma:rdn"}}
		for _, _cdeacd := range _ddfdbf.Rdn {
			e.EncodeElement(_cdeacd, _gfaacd)
		}
	}
	if _ddfdbf.Rcmt != nil {
		_addab := _f.StartElement{Name: _f.Name{Local: "ma:rcmt"}}
		for _, _feadf := range _ddfdbf.Rcmt {
			e.EncodeElement(_feadf, _addab)
		}
	}
	if _ddfdbf.Rqt != nil {
		_acdfbe := _f.StartElement{Name: _f.Name{Local: "ma:rqt"}}
		for _, _aacfa := range _ddfdbf.Rqt {
			e.EncodeElement(_aacfa, _acdfbe)
		}
	}
	if _ddfdbf.Rcft != nil {
		_cbgfd := _f.StartElement{Name: _f.Name{Local: "ma:rcft"}}
		for _, _dcceg := range _ddfdbf.Rcft {
			e.EncodeElement(_dcceg, _cbgfd)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_PivotArea() *CT_PivotArea { _aaabe := &CT_PivotArea{}; return _aaabe }
func NewCT_IconSet() *CT_IconSet     { _abfbag := &CT_IconSet{}; return _abfbag }

type ST_FormatAction byte

func NewCT_SortState() *CT_SortState             { _bcaacd := &CT_SortState{}; return _bcaacd }
func NewCT_WebPublishItems() *CT_WebPublishItems { _fdddgc := &CT_WebPublishItems{}; return _fdddgc }

// Validate validates the CT_Cell and its children
func (_fdef *CT_Cell) Validate() error { return _fdef.ValidateWithPath("CT_Cell") }
func (_gbfcf *CT_PhoneticPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fontId"}, Value: _bg.Sprintf("\u0025v", _gbfcf.FontIdAttr)})
	if _gbfcf.TypeAttr != ST_PhoneticTypeUnset {
		_ecefe, _afbec := _gbfcf.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
		if _afbec != nil {
			return _afbec
		}
		start.Attr = append(start.Attr, _ecefe)
	}
	if _gbfcf.AlignmentAttr != ST_PhoneticAlignmentUnset {
		_efged, _beefcd := _gbfcf.AlignmentAttr.MarshalXMLAttr(_f.Name{Local: "alignment"})
		if _beefcd != nil {
			return _beefcd
		}
		start.Attr = append(start.Attr, _efged)
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SheetIdMap and its children
func (_cccga *CT_SheetIdMap) Validate() error { return _cccga.ValidateWithPath("CT_SheetIdMap") }

// Validate validates the PivotTableDefinition and its children
func (_ffdgbg *PivotTableDefinition) Validate() error {
	return _ffdgbg.ValidateWithPath("PivotTableDefinition")
}
func (_baddad *CT_VolTopicRef) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _egbff := range start.Attr {
		if _egbff.Name.Local == "r" {
			_bdfafd, _aaec := _egbff.Value, error(nil)
			if _aaec != nil {
				return _aaec
			}
			_baddad.RAttr = _bdfafd
			continue
		}
		if _egbff.Name.Local == "s" {
			_aeaga, _ddffag := _g.ParseUint(_egbff.Value, 10, 32)
			if _ddffag != nil {
				return _ddffag
			}
			_baddad.SAttr = uint32(_aeaga)
			continue
		}
	}
	for {
		_gefeg, _abegb := d.Token()
		if _abegb != nil {
			return _bg.Errorf("parsing\u0020CT_VolTopicRef:\u0020\u0025s", _abegb)
		}
		if _cfaged, _fffgf := _gefeg.(_f.EndElement); _fffgf && _cfaged.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cdgdca *CT_TableFormula) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abcca := range start.Attr {
		if _abcca.Name.Local == "array" {
			_dfbee, _edbaf := _g.ParseBool(_abcca.Value)
			if _edbaf != nil {
				return _edbaf
			}
			_cdgdca.ArrayAttr = _dfbee
			continue
		}
	}
	for {
		_gaacf, _gffcbf := d.Token()
		if _gffcbf != nil {
			return _bg.Errorf("parsing CT_TableFormula:\u0020\u0025s", _gffcbf)
		}
		if _fgcbb, _edadf := _gaacf.(_f.CharData); _edadf {
			_cdgdca.Content = string(_fgcbb)
		}
		if _fbegc, _fbcedg := _gaacf.(_f.EndElement); _fbcedg && _fbegc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dffag *CT_Groups) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bcbbe := range start.Attr {
		if _bcbbe.Name.Local == "count" {
			_ebbda, _cddfa := _g.ParseUint(_bcbbe.Value, 10, 32)
			if _cddfa != nil {
				return _cddfa
			}
			_fbgfc := uint32(_ebbda)
			_dffag.CountAttr = &_fbgfc
			continue
		}
	}
_gbag:
	for {
		_gagf, _gcfbf := d.Token()
		if _gcfbf != nil {
			return _gcfbf
		}
		switch _cfafee := _gagf.(type) {
		case _f.StartElement:
			switch _cfafee.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "group"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "group"}:
				_eeaad := NewCT_LevelGroup()
				if _cbcg := d.DecodeElement(_eeaad, &_cfafee); _cbcg != nil {
					return _cbcg
				}
				_dffag.Group = append(_dffag.Group, _eeaad)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_Groups \u0025v", _cfafee.Name)
				if _cebdg := d.Skip(); _cebdg != nil {
					return _cebdg
				}
			}
		case _f.EndElement:
			break _gbag
		case _f.CharData:
		}
	}
	return nil
}
func (_gcbfce *CT_FieldGroup) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gcbfce.ParAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "par"}, Value: _bg.Sprintf("\u0025v", *_gcbfce.ParAttr)})
	}
	if _gcbfce.BaseAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "base"}, Value: _bg.Sprintf("\u0025v", *_gcbfce.BaseAttr)})
	}
	e.EncodeToken(start)
	if _gcbfce.RangePr != nil {
		_gfbdc := _f.StartElement{Name: _f.Name{Local: "ma:rangePr"}}
		e.EncodeElement(_gcbfce.RangePr, _gfbdc)
	}
	if _gcbfce.DiscretePr != nil {
		_gbbccc := _f.StartElement{Name: _f.Name{Local: "ma:discretePr"}}
		e.EncodeElement(_gcbfce.DiscretePr, _gbbccc)
	}
	if _gcbfce.GroupItems != nil {
		_fcged := _f.StartElement{Name: _f.Name{Local: "ma:groupItems"}}
		e.EncodeElement(_gcbfce.GroupItems, _fcged)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_CustomProperties and its children, prefixing error messages with path
func (_egdf *CT_CustomProperties) ValidateWithPath(path string) error {
	for _becfe, _eddf := range _egdf.CustomPr {
		if _cfgb := _eddf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCustomPr\u005b\u0025d\u005d", path, _becfe)); _cfgb != nil {
			return _cfgb
		}
	}
	return nil
}

type CT_RevisionRowColumn struct {

	// Sheet Id
	SIdAttr uint32

	// End Of List
	EolAttr *bool

	// Reference
	RefAttr string

	// User Action
	ActionAttr ST_rwColActionType

	// Edge Deleted
	EdgeAttr *bool

	// Undo
	Undo []*CT_UndoInfo

	// Revised Row Column
	Rcc []*CT_RevisionCellChange

	// Revision Format
	Rfmt    []*CT_RevisionFormatting
	RIdAttr *uint32
	UaAttr  *bool
	RaAttr  *bool
}

// Validate validates the CT_CustomSheetView and its children
func (_cgbg *CT_CustomSheetView) Validate() error {
	return _cgbg.ValidateWithPath("CT_CustomSheetView")
}

type VolTypes struct{ CT_VolTypes }

// Validate validates the CT_SheetViews and its children
func (_dafbag *CT_SheetViews) Validate() error { return _dafbag.ValidateWithPath("CT_SheetViews") }
func NewCT_FunctionGroup() *CT_FunctionGroup   { _dgbca := &CT_FunctionGroup{}; return _dgbca }

// ValidateWithPath validates the CT_Borders and its children, prefixing error messages with path
func (_dge *CT_Borders) ValidateWithPath(path string) error {
	for _gc, _fed := range _dge.Border {
		if _bff := _fed.ValidateWithPath(_bg.Sprintf("\u0025s\u002fBorder\u005b\u0025d\u005d", path, _gc)); _bff != nil {
			return _bff
		}
	}
	return nil
}
func (_geagc *CT_PivotArea) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _geagc.FieldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "field"}, Value: _bg.Sprintf("\u0025v", *_geagc.FieldAttr)})
	}
	if _geagc.TypeAttr != ST_PivotAreaTypeUnset {
		_fffca, _afffg := _geagc.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
		if _afffg != nil {
			return _afffg
		}
		start.Attr = append(start.Attr, _fffca)
	}
	if _geagc.DataOnlyAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataOnly"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_geagc.DataOnlyAttr))})
	}
	if _geagc.LabelOnlyAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "labelOnly"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_geagc.LabelOnlyAttr))})
	}
	if _geagc.GrandRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "grandRow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_geagc.GrandRowAttr))})
	}
	if _geagc.GrandColAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "grandCol"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_geagc.GrandColAttr))})
	}
	if _geagc.CacheIndexAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cacheIndex"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_geagc.CacheIndexAttr))})
	}
	if _geagc.OutlineAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "outline"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_geagc.OutlineAttr))})
	}
	if _geagc.OffsetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "offset"}, Value: _bg.Sprintf("\u0025v", *_geagc.OffsetAttr)})
	}
	if _geagc.CollapsedLevelsAreSubtotalsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "collapsedLevelsAreSubtotals"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_geagc.CollapsedLevelsAreSubtotalsAttr))})
	}
	if _geagc.AxisAttr != ST_AxisUnset {
		_daaeb, _afbgb := _geagc.AxisAttr.MarshalXMLAttr(_f.Name{Local: "axis"})
		if _afbgb != nil {
			return _afbgb
		}
		start.Attr = append(start.Attr, _daaeb)
	}
	if _geagc.FieldPositionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fieldPosition"}, Value: _bg.Sprintf("\u0025v", *_geagc.FieldPositionAttr)})
	}
	e.EncodeToken(start)
	if _geagc.References != nil {
		_bbgde := _f.StartElement{Name: _f.Name{Local: "ma:references"}}
		e.EncodeElement(_geagc.References, _bbgde)
	}
	if _geagc.ExtLst != nil {
		_gbcdaf := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_geagc.ExtLst, _gbcdaf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_MeasureGroups and its children, prefixing error messages with path
func (_gbbebe *CT_MeasureGroups) ValidateWithPath(path string) error {
	for _gffgg, _cbadg := range _gbbebe.MeasureGroup {
		if _cgggfa := _cbadg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fMeasureGroup\u005b\u0025d\u005d", path, _gffgg)); _cgggfa != nil {
			return _cgggfa
		}
	}
	return nil
}

// Validate validates the CT_BooleanProperty and its children
func (_dfd *CT_BooleanProperty) Validate() error { return _dfd.ValidateWithPath("CT_BooleanProperty") }

type ST_FormulaExpression byte
type CT_Comments struct {

	// Authors
	Authors *CT_Authors

	// List of Comments
	CommentList *CT_CommentList
	ExtLst      *CT_ExtensionList
}

func (_bagfg *CT_QueryTableField) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", _bagfg.IdAttr)})
	if _bagfg.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_bagfg.NameAttr)})
	}
	if _bagfg.DataBoundAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataBound"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bagfg.DataBoundAttr))})
	}
	if _bagfg.RowNumbersAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rowNumbers"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bagfg.RowNumbersAttr))})
	}
	if _bagfg.FillFormulasAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fillFormulas"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bagfg.FillFormulasAttr))})
	}
	if _bagfg.ClippedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "clipped"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bagfg.ClippedAttr))})
	}
	if _bagfg.TableColumnIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "tableColumnId"}, Value: _bg.Sprintf("\u0025v", *_bagfg.TableColumnIdAttr)})
	}
	e.EncodeToken(start)
	if _bagfg.ExtLst != nil {
		_dgcbb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_bagfg.ExtLst, _dgcbb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_CellStyleXfs() *CT_CellStyleXfs { _baff := &CT_CellStyleXfs{}; return _baff }

type CT_ExternalLinkChoice struct {
	ExternalBook *CT_ExternalBook
	DdeLink      *CT_DdeLink
	OleLink      *CT_OleLink
}

func (_edfae *ST_PivotFilterType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_aebfag, _fcfgga := d.Token()
	if _fcfgga != nil {
		return _fcfgga
	}
	if _abcfbg, _fbfac := _aebfag.(_f.EndElement); _fbfac && _abcfbg.Name == start.Name {
		*_edfae = 1
		return nil
	}
	if _gdbef, _dgacg := _aebfag.(_f.CharData); !_dgacg {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aebfag)
	} else {
		switch string(_gdbef) {
		case "":
			*_edfae = 0
		case "unknown":
			*_edfae = 1
		case "count":
			*_edfae = 2
		case "percent":
			*_edfae = 3
		case "sum":
			*_edfae = 4
		case "captionEqual":
			*_edfae = 5
		case "captionNotEqual":
			*_edfae = 6
		case "captionBeginsWith":
			*_edfae = 7
		case "captionNotBeginsWith":
			*_edfae = 8
		case "captionEndsWith":
			*_edfae = 9
		case "captionNotEndsWith":
			*_edfae = 10
		case "captionContains":
			*_edfae = 11
		case "captionNotContains":
			*_edfae = 12
		case "captionGreaterThan":
			*_edfae = 13
		case "captionGreaterThanOrEqual":
			*_edfae = 14
		case "captionLessThan":
			*_edfae = 15
		case "captionLessThanOrEqual":
			*_edfae = 16
		case "captionBetween":
			*_edfae = 17
		case "captionNotBetween":
			*_edfae = 18
		case "valueEqual":
			*_edfae = 19
		case "valueNotEqual":
			*_edfae = 20
		case "valueGreaterThan":
			*_edfae = 21
		case "valueGreaterThanOrEqual":
			*_edfae = 22
		case "valueLessThan":
			*_edfae = 23
		case "valueLessThanOrEqual":
			*_edfae = 24
		case "valueBetween":
			*_edfae = 25
		case "valueNotBetween":
			*_edfae = 26
		case "dateEqual":
			*_edfae = 27
		case "dateNotEqual":
			*_edfae = 28
		case "dateOlderThan":
			*_edfae = 29
		case "dateOlderThanOrEqual":
			*_edfae = 30
		case "dateNewerThan":
			*_edfae = 31
		case "dateNewerThanOrEqual":
			*_edfae = 32
		case "dateBetween":
			*_edfae = 33
		case "dateNotBetween":
			*_edfae = 34
		case "tomorrow":
			*_edfae = 35
		case "today":
			*_edfae = 36
		case "yesterday":
			*_edfae = 37
		case "nextWeek":
			*_edfae = 38
		case "thisWeek":
			*_edfae = 39
		case "lastWeek":
			*_edfae = 40
		case "nextMonth":
			*_edfae = 41
		case "thisMonth":
			*_edfae = 42
		case "lastMonth":
			*_edfae = 43
		case "nextQuarter":
			*_edfae = 44
		case "thisQuarter":
			*_edfae = 45
		case "lastQuarter":
			*_edfae = 46
		case "nextYear":
			*_edfae = 47
		case "thisYear":
			*_edfae = 48
		case "lastYear":
			*_edfae = 49
		case "yearToDate":
			*_edfae = 50
		case "Q1":
			*_edfae = 51
		case "Q2":
			*_edfae = 52
		case "Q3":
			*_edfae = 53
		case "Q4":
			*_edfae = 54
		case "M1":
			*_edfae = 55
		case "M2":
			*_edfae = 56
		case "M3":
			*_edfae = 57
		case "M4":
			*_edfae = 58
		case "M5":
			*_edfae = 59
		case "M6":
			*_edfae = 60
		case "M7":
			*_edfae = 61
		case "M8":
			*_edfae = 62
		case "M9":
			*_edfae = 63
		case "M10":
			*_edfae = 64
		case "M11":
			*_edfae = 65
		case "M12":
			*_edfae = 66
		}
	}
	_aebfag, _fcfgga = d.Token()
	if _fcfgga != nil {
		return _fcfgga
	}
	if _dadee, _faebdb := _aebfag.(_f.EndElement); _faebdb && _dadee.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aebfag)
}
func (_gegaa ST_PatternType) String() string {
	switch _gegaa {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "solid"
	case 3:
		return "mediumGray"
	case 4:
		return "darkGray"
	case 5:
		return "lightGray"
	case 6:
		return "darkHorizontal"
	case 7:
		return "darkVertical"
	case 8:
		return "darkDown"
	case 9:
		return "darkUp"
	case 10:
		return "darkGrid"
	case 11:
		return "darkTrellis"
	case 12:
		return "lightHorizontal"
	case 13:
		return "lightVertical"
	case 14:
		return "lightDown"
	case 15:
		return "lightUp"
	case 16:
		return "lightGrid"
	case 17:
		return "lightTrellis"
	case 18:
		return "gray125"
	case 19:
		return "gray0625"
	}
	return ""
}
func (_gfec *CT_ChartFormats) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gfec.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_gfec.CountAttr)})
	}
	e.EncodeToken(start)
	_beffa := _f.StartElement{Name: _f.Name{Local: "ma:chartFormat"}}
	for _, _eecf := range _gfec.ChartFormat {
		e.EncodeElement(_eecf, _beffa)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_accda *ST_FormulaExpression) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_accda = 0
	case "ref":
		*_accda = 1
	case "refError":
		*_accda = 2
	case "area":
		*_accda = 3
	case "areaError":
		*_accda = 4
	case "computedArea":
		*_accda = 5
	}
	return nil
}
func (_edgdb *CT_Items) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _edgdb.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_edgdb.CountAttr)})
	}
	e.EncodeToken(start)
	_dedga := _f.StartElement{Name: _f.Name{Local: "ma:item"}}
	for _, _gggadd := range _edgdb.Item {
		e.EncodeElement(_gggadd, _dedga)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dgdeef *ST_TableType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bafgcc, _eebfaf := d.Token()
	if _eebfaf != nil {
		return _eebfaf
	}
	if _gagcg, _eegbd := _bafgcc.(_f.EndElement); _eegbd && _gagcg.Name == start.Name {
		*_dgdeef = 1
		return nil
	}
	if _adecd, _cbbbbf := _bafgcc.(_f.CharData); !_cbbbbf {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bafgcc)
	} else {
		switch string(_adecd) {
		case "":
			*_dgdeef = 0
		case "worksheet":
			*_dgdeef = 1
		case "xml":
			*_dgdeef = 2
		case "queryTable":
			*_dgdeef = 3
		}
	}
	_bafgcc, _eebfaf = d.Token()
	if _eebfaf != nil {
		return _eebfaf
	}
	if _bagca, _fdacb := _bafgcc.(_f.EndElement); _fdacb && _bagca.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bafgcc)
}
func (_gfefgb ST_GrowShrinkType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_gfefgb.String(), start)
}

type CT_Items struct {

	// Field Count
	CountAttr *uint32

	// PivotTable Field Item
	Item []*CT_Item
}

func (_efbc *CT_MergeCell) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dacd := range start.Attr {
		if _dacd.Name.Local == "ref" {
			_acage, _gdddae := _dacd.Value, error(nil)
			if _gdddae != nil {
				return _gdddae
			}
			_efbc.RefAttr = _acage
			continue
		}
	}
	for {
		_gcfgb, _gbcbafg := d.Token()
		if _gbcbafg != nil {
			return _bg.Errorf("parsing\u0020CT_MergeCell:\u0020\u0025s", _gbcbafg)
		}
		if _cdgfb, _bfcad := _gcfgb.(_f.EndElement); _bfcad && _cdgfb.Name == start.Name {
			break
		}
	}
	return nil
}

type ST_PivotAreaType byte
type CT_SheetPr struct {

	// Synch Horizontal
	SyncHorizontalAttr *bool

	// Synch Vertical
	SyncVerticalAttr *bool

	// Synch Reference
	SyncRefAttr *string

	// Transition Formula Evaluation
	TransitionEvaluationAttr *bool

	// Transition Formula Entry
	TransitionEntryAttr *bool

	// Published
	PublishedAttr *bool

	// Code Name
	CodeNameAttr *string

	// Filter Mode
	FilterModeAttr *bool

	// Enable Conditional Formatting Calculations
	EnableFormatConditionsCalculationAttr *bool

	// Sheet Tab Color
	TabColor *CT_Color

	// Outline Properties
	OutlinePr *CT_OutlinePr

	// Page Setup Properties
	PageSetUpPr *CT_PageSetUpPr
}
type CT_TableColumn struct {

	// Table Field Id
	IdAttr uint32

	// Unique Name
	UniqueNameAttr *string

	// Column name
	NameAttr string

	// Totals Row Function
	TotalsRowFunctionAttr ST_TotalsRowFunction

	// Totals Row Label
	TotalsRowLabelAttr *string

	// Query Table Field Id
	QueryTableFieldIdAttr *uint32

	// Header Row Cell Format Id
	HeaderRowDxfIdAttr *uint32

	// Data & Insert Row Format Id
	DataDxfIdAttr *uint32

	// Totals Row Format Id
	TotalsRowDxfIdAttr *uint32

	// Header Row Cell Style
	HeaderRowCellStyleAttr *string

	// Data Area Style Name
	DataCellStyleAttr *string

	// Totals Row Style Name
	TotalsRowCellStyleAttr *string

	// Calculated Column Formula
	CalculatedColumnFormula *CT_TableFormula

	// Totals Row Formula
	TotalsRowFormula *CT_TableFormula

	// XML Column Properties
	XmlColumnPr *CT_XmlColumnPr

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_gbcd *CT_Cell) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gbcd.RAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", *_gbcd.RAttr)})
	}
	if _gbcd.SAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "s"}, Value: _bg.Sprintf("\u0025v", *_gbcd.SAttr)})
	}
	if _gbcd.TAttr != ST_CellTypeUnset {
		_fege, _aead := _gbcd.TAttr.MarshalXMLAttr(_f.Name{Local: "t"})
		if _aead != nil {
			return _aead
		}
		start.Attr = append(start.Attr, _fege)
	}
	if _gbcd.CmAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cm"}, Value: _bg.Sprintf("\u0025v", *_gbcd.CmAttr)})
	}
	if _gbcd.VmAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "vm"}, Value: _bg.Sprintf("\u0025v", *_gbcd.VmAttr)})
	}
	if _gbcd.PhAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ph"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbcd.PhAttr))})
	}
	e.EncodeToken(start)
	if _gbcd.F != nil {
		_dgaf := _f.StartElement{Name: _f.Name{Local: "ma:f"}}
		e.EncodeElement(_gbcd.F, _dgaf)
	}
	if _gbcd.V != nil {
		_adeb := _f.StartElement{Name: _f.Name{Local: "ma:v"}}
		_cb.AddPreserveSpaceAttr(&_adeb, *_gbcd.V)
		e.EncodeElement(_gbcd.V, _adeb)
	}
	if _gbcd.Is != nil {
		_abgb := _f.StartElement{Name: _f.Name{Local: "ma:is"}}
		e.EncodeElement(_gbcd.Is, _abgb)
	}
	if _gbcd.ExtLst != nil {
		_abac := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_gbcd.ExtLst, _abac)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_daacc *Sst) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_daacc.CT_Sst = *NewCT_Sst()
	for _, _dafcdg := range start.Attr {
		if _dafcdg.Name.Local == "count" {
			_gdddba, _dgfbb := _g.ParseUint(_dafcdg.Value, 10, 32)
			if _dgfbb != nil {
				return _dgfbb
			}
			_baeb := uint32(_gdddba)
			_daacc.CountAttr = &_baeb
			continue
		}
		if _dafcdg.Name.Local == "uniqueCount" {
			_cgcga, _fbceacf := _g.ParseUint(_dafcdg.Value, 10, 32)
			if _fbceacf != nil {
				return _fbceacf
			}
			_eaggd := uint32(_cgcga)
			_daacc.UniqueCountAttr = &_eaggd
			continue
		}
	}
_fbfgb:
	for {
		_cfdfd, _fegeb := d.Token()
		if _fegeb != nil {
			return _fegeb
		}
		switch _cggfd := _cfdfd.(type) {
		case _f.StartElement:
			switch _cggfd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "si"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "si"}:
				_ccdae := NewCT_Rst()
				if _bbbfc := d.DecodeElement(_ccdae, &_cggfd); _bbbfc != nil {
					return _bbbfc
				}
				_daacc.Si = append(_daacc.Si, _ccdae)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_daacc.ExtLst = NewCT_ExtensionList()
				if _ffggaf := d.DecodeElement(_daacc.ExtLst, &_cggfd); _ffggaf != nil {
					return _ffggaf
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Sst\u0020\u0025v", _cggfd.Name)
				if _dgdagf := d.Skip(); _dgdagf != nil {
					return _dgdagf
				}
			}
		case _f.EndElement:
			break _fbfgb
		case _f.CharData:
		}
	}
	return nil
}
func (_gdafg ST_MdxFunctionType) ValidateWithPath(path string) error {
	switch _gdafg {
	case 0, 1, 2, 3, 4, 5, 6, 7:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gdafg))
	}
	return nil
}
func (_febe *CT_DefinedName) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _daddb := range start.Attr {
		if _daddb.Name.Local == "hidden" {
			_aggcd, _affde := _g.ParseBool(_daddb.Value)
			if _affde != nil {
				return _affde
			}
			_febe.HiddenAttr = &_aggcd
			continue
		}
		if _daddb.Name.Local == "function" {
			_dfba, _cccce := _g.ParseBool(_daddb.Value)
			if _cccce != nil {
				return _cccce
			}
			_febe.FunctionAttr = &_dfba
			continue
		}
		if _daddb.Name.Local == "comment" {
			_ggeae, _gfda := _daddb.Value, error(nil)
			if _gfda != nil {
				return _gfda
			}
			_febe.CommentAttr = &_ggeae
			continue
		}
		if _daddb.Name.Local == "description" {
			_ffecf, _aeadf := _daddb.Value, error(nil)
			if _aeadf != nil {
				return _aeadf
			}
			_febe.DescriptionAttr = &_ffecf
			continue
		}
		if _daddb.Name.Local == "help" {
			_bgdda, _gfde := _daddb.Value, error(nil)
			if _gfde != nil {
				return _gfde
			}
			_febe.HelpAttr = &_bgdda
			continue
		}
		if _daddb.Name.Local == "statusBar" {
			_aagcg, _gafee := _daddb.Value, error(nil)
			if _gafee != nil {
				return _gafee
			}
			_febe.StatusBarAttr = &_aagcg
			continue
		}
		if _daddb.Name.Local == "localSheetId" {
			_eada, _cgdc := _g.ParseUint(_daddb.Value, 10, 32)
			if _cgdc != nil {
				return _cgdc
			}
			_ggeb := uint32(_eada)
			_febe.LocalSheetIdAttr = &_ggeb
			continue
		}
		if _daddb.Name.Local == "name" {
			_ebced, _fffd := _daddb.Value, error(nil)
			if _fffd != nil {
				return _fffd
			}
			_febe.NameAttr = _ebced
			continue
		}
		if _daddb.Name.Local == "customMenu" {
			_efegac, _fegdc := _daddb.Value, error(nil)
			if _fegdc != nil {
				return _fegdc
			}
			_febe.CustomMenuAttr = &_efegac
			continue
		}
		if _daddb.Name.Local == "vbProcedure" {
			_dfaae, _cafcf := _g.ParseBool(_daddb.Value)
			if _cafcf != nil {
				return _cafcf
			}
			_febe.VbProcedureAttr = &_dfaae
			continue
		}
		if _daddb.Name.Local == "xlm" {
			_cgfb, _cadfe := _g.ParseBool(_daddb.Value)
			if _cadfe != nil {
				return _cadfe
			}
			_febe.XlmAttr = &_cgfb
			continue
		}
		if _daddb.Name.Local == "functionGroupId" {
			_fdggf, _dgdef := _g.ParseUint(_daddb.Value, 10, 32)
			if _dgdef != nil {
				return _dgdef
			}
			_edgfd := uint32(_fdggf)
			_febe.FunctionGroupIdAttr = &_edgfd
			continue
		}
		if _daddb.Name.Local == "shortcutKey" {
			_cdea, _aeea := _daddb.Value, error(nil)
			if _aeea != nil {
				return _aeea
			}
			_febe.ShortcutKeyAttr = &_cdea
			continue
		}
		if _daddb.Name.Local == "publishToServer" {
			_cfefa, _deeec := _g.ParseBool(_daddb.Value)
			if _deeec != nil {
				return _deeec
			}
			_febe.PublishToServerAttr = &_cfefa
			continue
		}
		if _daddb.Name.Local == "workbookParameter" {
			_edegf, _cbfdg := _g.ParseBool(_daddb.Value)
			if _cbfdg != nil {
				return _cbfdg
			}
			_febe.WorkbookParameterAttr = &_edegf
			continue
		}
	}
	for {
		_gceccg, _dadb := d.Token()
		if _dadb != nil {
			return _bg.Errorf("parsing\u0020CT_DefinedName:\u0020\u0025s", _dadb)
		}
		if _bddaf, _gedd := _gceccg.(_f.CharData); _gedd {
			_febe.Content = string(_bddaf)
		}
		if _ccfgc, _gdac := _gceccg.(_f.EndElement); _gdac && _ccfgc.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_RangeSets struct {

	// Reference and Page Item Count
	CountAttr *uint32

	// Range Set
	RangeSet []*CT_RangeSet
}

// ValidateWithPath validates the CT_WebPublishing and its children, prefixing error messages with path
func (_gccg *CT_WebPublishing) ValidateWithPath(path string) error {
	if _ecafc := _gccg.TargetScreenSizeAttr.ValidateWithPath(path + "/TargetScreenSizeAttr"); _ecafc != nil {
		return _ecafc
	}
	return nil
}
func NewCT_Xf() *CT_Xf { _bgecd := &CT_Xf{}; return _bgecd }

type CT_Extension struct {

	// URI
	UriAttr *string
	Any     _cb.Any
}

func (_begfe *PivotCacheDefinition) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_begfe.CT_PivotCacheDefinition = *NewCT_PivotCacheDefinition()
	for _, _dfcfe := range start.Attr {
		if _dfcfe.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _dfcfe.Name.Local == "id" || _dfcfe.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _dfcfe.Name.Local == "id" {
			_ecbag, _aacfge := _dfcfe.Value, error(nil)
			if _aacfge != nil {
				return _aacfge
			}
			_begfe.IdAttr = &_ecbag
			continue
		}
		if _dfcfe.Name.Local == "upgradeOnRefresh" {
			_dcgbe, _cdbaf := _g.ParseBool(_dfcfe.Value)
			if _cdbaf != nil {
				return _cdbaf
			}
			_begfe.UpgradeOnRefreshAttr = &_dcgbe
			continue
		}
		if _dfcfe.Name.Local == "tupleCache" {
			_ffecae, _bcfbef := _g.ParseBool(_dfcfe.Value)
			if _bcfbef != nil {
				return _bcfbef
			}
			_begfe.TupleCacheAttr = &_ffecae
			continue
		}
		if _dfcfe.Name.Local == "saveData" {
			_daeca, _gcagae := _g.ParseBool(_dfcfe.Value)
			if _gcagae != nil {
				return _gcagae
			}
			_begfe.SaveDataAttr = &_daeca
			continue
		}
		if _dfcfe.Name.Local == "supportSubquery" {
			_fgefdf, _ceeaf := _g.ParseBool(_dfcfe.Value)
			if _ceeaf != nil {
				return _ceeaf
			}
			_begfe.SupportSubqueryAttr = &_fgefdf
			continue
		}
		if _dfcfe.Name.Local == "optimizeMemory" {
			_fgaef, _efaae := _g.ParseBool(_dfcfe.Value)
			if _efaae != nil {
				return _efaae
			}
			_begfe.OptimizeMemoryAttr = &_fgaef
			continue
		}
		if _dfcfe.Name.Local == "supportAdvancedDrill" {
			_dbdab, _efdcbe := _g.ParseBool(_dfcfe.Value)
			if _efdcbe != nil {
				return _efdcbe
			}
			_begfe.SupportAdvancedDrillAttr = &_dbdab
			continue
		}
		if _dfcfe.Name.Local == "refreshedBy" {
			_aagdab, _afcea := _dfcfe.Value, error(nil)
			if _afcea != nil {
				return _afcea
			}
			_begfe.RefreshedByAttr = &_aagdab
			continue
		}
		if _dfcfe.Name.Local == "refreshedDateIso" {
			_fafad, _acdac := ParseStdlibTime(_dfcfe.Value)
			if _acdac != nil {
				return _acdac
			}
			_begfe.RefreshedDateIsoAttr = &_fafad
			continue
		}
		if _dfcfe.Name.Local == "invalid" {
			_gfbbb, _efabf := _g.ParseBool(_dfcfe.Value)
			if _efabf != nil {
				return _efabf
			}
			_begfe.InvalidAttr = &_gfbbb
			continue
		}
		if _dfcfe.Name.Local == "backgroundQuery" {
			_fbgcae, _gfdde := _g.ParseBool(_dfcfe.Value)
			if _gfdde != nil {
				return _gfdde
			}
			_begfe.BackgroundQueryAttr = &_fbgcae
			continue
		}
		if _dfcfe.Name.Local == "missingItemsLimit" {
			_cfgeg, _gfffgb := _g.ParseUint(_dfcfe.Value, 10, 32)
			if _gfffgb != nil {
				return _gfffgb
			}
			_fddga := uint32(_cfgeg)
			_begfe.MissingItemsLimitAttr = &_fddga
			continue
		}
		if _dfcfe.Name.Local == "refreshedVersion" {
			_dgebg, _efcfe := _g.ParseUint(_dfcfe.Value, 10, 8)
			if _efcfe != nil {
				return _efcfe
			}
			_agcaf := uint8(_dgebg)
			_begfe.RefreshedVersionAttr = &_agcaf
			continue
		}
		if _dfcfe.Name.Local == "refreshOnLoad" {
			_bdebb, _fefab := _g.ParseBool(_dfcfe.Value)
			if _fefab != nil {
				return _fefab
			}
			_begfe.RefreshOnLoadAttr = &_bdebb
			continue
		}
		if _dfcfe.Name.Local == "refreshedDate" {
			_ddfcc, _efcdgg := _g.ParseFloat(_dfcfe.Value, 64)
			if _efcdgg != nil {
				return _efcdgg
			}
			_begfe.RefreshedDateAttr = &_ddfcc
			continue
		}
		if _dfcfe.Name.Local == "recordCount" {
			_edbeed, _cdcedb := _g.ParseUint(_dfcfe.Value, 10, 32)
			if _cdcedb != nil {
				return _cdcedb
			}
			_dbgcb := uint32(_edbeed)
			_begfe.RecordCountAttr = &_dbgcb
			continue
		}
		if _dfcfe.Name.Local == "createdVersion" {
			_ffcea, _aecdb := _g.ParseUint(_dfcfe.Value, 10, 8)
			if _aecdb != nil {
				return _aecdb
			}
			_abcgg := uint8(_ffcea)
			_begfe.CreatedVersionAttr = &_abcgg
			continue
		}
		if _dfcfe.Name.Local == "minRefreshableVersion" {
			_eaadgd, _aaaecg := _g.ParseUint(_dfcfe.Value, 10, 8)
			if _aaaecg != nil {
				return _aaaecg
			}
			_gdgeff := uint8(_eaadgd)
			_begfe.MinRefreshableVersionAttr = &_gdgeff
			continue
		}
		if _dfcfe.Name.Local == "enableRefresh" {
			_defad, _cacea := _g.ParseBool(_dfcfe.Value)
			if _cacea != nil {
				return _cacea
			}
			_begfe.EnableRefreshAttr = &_defad
			continue
		}
	}
_gbdf:
	for {
		_agdaf, _afacc := d.Token()
		if _afacc != nil {
			return _afacc
		}
		switch _bccbac := _agdaf.(type) {
		case _f.StartElement:
			switch _bccbac.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cacheSource"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cacheSource"}:
				if _becec := d.DecodeElement(_begfe.CacheSource, &_bccbac); _becec != nil {
					return _becec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cacheFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cacheFields"}:
				if _ffbea := d.DecodeElement(_begfe.CacheFields, &_bccbac); _ffbea != nil {
					return _ffbea
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cacheHierarchies"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cacheHierarchies"}:
				_begfe.CacheHierarchies = NewCT_CacheHierarchies()
				if _bbafb := d.DecodeElement(_begfe.CacheHierarchies, &_bccbac); _bbafb != nil {
					return _bbafb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "kpis"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "kpis"}:
				_begfe.Kpis = NewCT_PCDKPIs()
				if _ffdgb := d.DecodeElement(_begfe.Kpis, &_bccbac); _ffdgb != nil {
					return _ffdgb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tupleCache"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tupleCache"}:
				_begfe.TupleCache = NewCT_TupleCache()
				if _aacgd := d.DecodeElement(_begfe.TupleCache, &_bccbac); _aacgd != nil {
					return _aacgd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "calculatedItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "calculatedItems"}:
				_begfe.CalculatedItems = NewCT_CalculatedItems()
				if _fabbcg := d.DecodeElement(_begfe.CalculatedItems, &_bccbac); _fabbcg != nil {
					return _fabbcg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "calculatedMembers"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "calculatedMembers"}:
				_begfe.CalculatedMembers = NewCT_CalculatedMembers()
				if _cfbbd := d.DecodeElement(_begfe.CalculatedMembers, &_bccbac); _cfbbd != nil {
					return _cfbbd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dimensions"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dimensions"}:
				_begfe.Dimensions = NewCT_Dimensions()
				if _ggffa := d.DecodeElement(_begfe.Dimensions, &_bccbac); _ggffa != nil {
					return _ggffa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "measureGroups"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "measureGroups"}:
				_begfe.MeasureGroups = NewCT_MeasureGroups()
				if _cfgcdcc := d.DecodeElement(_begfe.MeasureGroups, &_bccbac); _cfgcdcc != nil {
					return _cfgcdcc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "maps"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "maps"}:
				_begfe.Maps = NewCT_MeasureDimensionMaps()
				if _eccee := d.DecodeElement(_begfe.Maps, &_bccbac); _eccee != nil {
					return _eccee
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_begfe.ExtLst = NewCT_ExtensionList()
				if _eggb := d.DecodeElement(_begfe.ExtLst, &_bccbac); _eggb != nil {
					return _eggb
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on\u0020PivotCacheDefinition\u0020\u0025v", _bccbac.Name)
				if _bedfc := d.Skip(); _bedfc != nil {
					return _bedfc
				}
			}
		case _f.EndElement:
			break _gbdf
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_IgnoredError() *CT_IgnoredError { _gcadb := &CT_IgnoredError{}; return _gcadb }
func (_bacggd ST_DateTimeGrouping) String() string {
	switch _bacggd {
	case 0:
		return ""
	case 1:
		return "year"
	case 2:
		return "month"
	case 3:
		return "day"
	case 4:
		return "hour"
	case 5:
		return "minute"
	case 6:
		return "second"
	}
	return ""
}

// ValidateWithPath validates the CT_CalcPr and its children, prefixing error messages with path
func (_edbf *CT_CalcPr) ValidateWithPath(path string) error {
	if _deb := _edbf.CalcModeAttr.ValidateWithPath(path + "\u002fCalcModeAttr"); _deb != nil {
		return _deb
	}
	if _abee := _edbf.RefModeAttr.ValidateWithPath(path + "\u002fRefModeAttr"); _abee != nil {
		return _abee
	}
	return nil
}

// Validate validates the CT_MRUColors and its children
func (_gfbcde *CT_MRUColors) Validate() error { return _gfbcde.ValidateWithPath("CT_MRUColors") }
func (_fcdcg *CT_IgnoredError) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aggd := range start.Attr {
		if _aggd.Name.Local == "sqref" {
			_dfaba, _dffee := ParseSliceST_Sqref(_aggd.Value)
			if _dffee != nil {
				return _dffee
			}
			_fcdcg.SqrefAttr = _dfaba
			continue
		}
		if _aggd.Name.Local == "evalError" {
			_gbcbaf, _fdgagg := _g.ParseBool(_aggd.Value)
			if _fdgagg != nil {
				return _fdgagg
			}
			_fcdcg.EvalErrorAttr = &_gbcbaf
			continue
		}
		if _aggd.Name.Local == "twoDigitTextYear" {
			_cggeg, _edbb := _g.ParseBool(_aggd.Value)
			if _edbb != nil {
				return _edbb
			}
			_fcdcg.TwoDigitTextYearAttr = &_cggeg
			continue
		}
		if _aggd.Name.Local == "numberStoredAsText" {
			_gfadg, _degeg := _g.ParseBool(_aggd.Value)
			if _degeg != nil {
				return _degeg
			}
			_fcdcg.NumberStoredAsTextAttr = &_gfadg
			continue
		}
		if _aggd.Name.Local == "formula" {
			_acfdg, _aefbg := _g.ParseBool(_aggd.Value)
			if _aefbg != nil {
				return _aefbg
			}
			_fcdcg.FormulaAttr = &_acfdg
			continue
		}
		if _aggd.Name.Local == "formulaRange" {
			_dfgbcg, _gbdbc := _g.ParseBool(_aggd.Value)
			if _gbdbc != nil {
				return _gbdbc
			}
			_fcdcg.FormulaRangeAttr = &_dfgbcg
			continue
		}
		if _aggd.Name.Local == "unlockedFormula" {
			_eeabg, _fgebe := _g.ParseBool(_aggd.Value)
			if _fgebe != nil {
				return _fgebe
			}
			_fcdcg.UnlockedFormulaAttr = &_eeabg
			continue
		}
		if _aggd.Name.Local == "emptyCellReference" {
			_gfed, _gagdfd := _g.ParseBool(_aggd.Value)
			if _gagdfd != nil {
				return _gagdfd
			}
			_fcdcg.EmptyCellReferenceAttr = &_gfed
			continue
		}
		if _aggd.Name.Local == "listDataValidation" {
			_edbdae, _cbacd := _g.ParseBool(_aggd.Value)
			if _cbacd != nil {
				return _cbacd
			}
			_fcdcg.ListDataValidationAttr = &_edbdae
			continue
		}
		if _aggd.Name.Local == "calculatedColumn" {
			_gagggb, _eagcf := _g.ParseBool(_aggd.Value)
			if _eagcf != nil {
				return _eagcf
			}
			_fcdcg.CalculatedColumnAttr = &_gagggb
			continue
		}
	}
	for {
		_dgba, _dadcc := d.Token()
		if _dadcc != nil {
			return _bg.Errorf("parsing CT_IgnoredError:\u0020\u0025s", _dadcc)
		}
		if _fffee, _fcede := _dgba.(_f.EndElement); _fcede && _fffee.Name == start.Name {
			break
		}
	}
	return nil
}
func (_efc *CT_CalculatedMembers) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _efc.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_efc.CountAttr)})
	}
	e.EncodeToken(start)
	_eagc := _f.StartElement{Name: _f.Name{Local: "ma:calculatedMember"}}
	for _, _gfgab := range _efc.CalculatedMember {
		e.EncodeElement(_gfgab, _eagc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Item and its children, prefixing error messages with path
func (_agdce *CT_Item) ValidateWithPath(path string) error {
	if _fadfe := _agdce.TAttr.ValidateWithPath(path + "\u002fTAttr"); _fadfe != nil {
		return _fadfe
	}
	return nil
}

type CT_MergeCells struct {

	// Count
	CountAttr *uint32

	// Merged Cell
	MergeCell []*CT_MergeCell
}

// ValidateWithPath validates the CT_Xf and its children, prefixing error messages with path
func (_gbacgb *CT_Xf) ValidateWithPath(path string) error {
	if _gbacgb.Alignment != nil {
		if _efbbfg := _gbacgb.Alignment.ValidateWithPath(path + "\u002fAlignment"); _efbbfg != nil {
			return _efbbfg
		}
	}
	if _gbacgb.Protection != nil {
		if _ecggcg := _gbacgb.Protection.ValidateWithPath(path + "/Protection"); _ecggcg != nil {
			return _ecggcg
		}
	}
	if _gbacgb.ExtLst != nil {
		if _eadfag := _gbacgb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eadfag != nil {
			return _eadfag
		}
	}
	return nil
}

// Validate validates the CT_MetadataType and its children
func (_afgfc *CT_MetadataType) Validate() error { return _afgfc.ValidateWithPath("CT_MetadataType") }
func (_ebbegbe *CT_SortCondition) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ebbegbe.DescendingAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "descending"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebbegbe.DescendingAttr))})
	}
	if _ebbegbe.SortByAttr != ST_SortByUnset {
		_gfcac, _gdgcf := _ebbegbe.SortByAttr.MarshalXMLAttr(_f.Name{Local: "sortBy"})
		if _gdgcf != nil {
			return _gdgcf
		}
		start.Attr = append(start.Attr, _gfcac)
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _ebbegbe.RefAttr)})
	if _ebbegbe.CustomListAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "customList"}, Value: _bg.Sprintf("\u0025v", *_ebbegbe.CustomListAttr)})
	}
	if _ebbegbe.DxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dxfId"}, Value: _bg.Sprintf("\u0025v", *_ebbegbe.DxfIdAttr)})
	}
	if _ebbegbe.IconSetAttr != ST_IconSetTypeUnset {
		_cgaaf, _efdcb := _ebbegbe.IconSetAttr.MarshalXMLAttr(_f.Name{Local: "iconSet"})
		if _efdcb != nil {
			return _efdcb
		}
		start.Attr = append(start.Attr, _cgaaf)
	}
	if _ebbegbe.IconIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "iconId"}, Value: _bg.Sprintf("\u0025v", *_ebbegbe.IconIdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bceed *CT_PivotAreaReferences) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bceed.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bceed.CountAttr)})
	}
	e.EncodeToken(start)
	_dfebd := _f.StartElement{Name: _f.Name{Local: "ma:reference"}}
	for _, _aebdb := range _bceed.Reference {
		e.EncodeElement(_aebdb, _dfebd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_MdxTuple struct {

	// Member Index Count
	CAttr *uint32

	// Server Formatting Culture Currency
	CtAttr *string

	// Server Formatting String Index
	SiAttr *uint32

	// Server Formatting Built-In Number Format Index
	FiAttr *uint32

	// Server Formatting Background Color
	BcAttr *string

	// Server Formatting Foreground Color
	FcAttr *string

	// Server Formatting Italic Font
	IAttr *bool

	// Server Formatting Underline Font
	UAttr *bool

	// Server Formatting Strikethrough Font
	StAttr *bool

	// Server Formatting Bold Font
	BAttr *bool

	// Member Unique Name Index
	N []*CT_MetadataStringIndex
}

func (_bfcda *CT_String) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cddeb := range start.Attr {
		if _cddeb.Name.Local == "fc" {
			_aecba, _ffcfd := _cddeb.Value, error(nil)
			if _ffcfd != nil {
				return _ffcfd
			}
			_bfcda.FcAttr = &_aecba
			continue
		}
		if _cddeb.Name.Local == "v" {
			_bgceb, _fegcg := _cddeb.Value, error(nil)
			if _fegcg != nil {
				return _fegcg
			}
			_bfcda.VAttr = _bgceb
			continue
		}
		if _cddeb.Name.Local == "f" {
			_eaagbc, _fgcdb := _g.ParseBool(_cddeb.Value)
			if _fgcdb != nil {
				return _fgcdb
			}
			_bfcda.FAttr = &_eaagbc
			continue
		}
		if _cddeb.Name.Local == "c" {
			_gegca, _bfagg := _cddeb.Value, error(nil)
			if _bfagg != nil {
				return _bfagg
			}
			_bfcda.CAttr = &_gegca
			continue
		}
		if _cddeb.Name.Local == "cp" {
			_acfff, _ebgbff := _g.ParseUint(_cddeb.Value, 10, 32)
			if _ebgbff != nil {
				return _ebgbff
			}
			_gadagb := uint32(_acfff)
			_bfcda.CpAttr = &_gadagb
			continue
		}
		if _cddeb.Name.Local == "in" {
			_ddebf, _dfagd := _g.ParseUint(_cddeb.Value, 10, 32)
			if _dfagd != nil {
				return _dfagd
			}
			_gdcaa := uint32(_ddebf)
			_bfcda.InAttr = &_gdcaa
			continue
		}
		if _cddeb.Name.Local == "bc" {
			_bbfae, _bgagce := _cddeb.Value, error(nil)
			if _bgagce != nil {
				return _bgagce
			}
			_bfcda.BcAttr = &_bbfae
			continue
		}
		if _cddeb.Name.Local == "u" {
			_aegbe, _bccebg := _g.ParseBool(_cddeb.Value)
			if _bccebg != nil {
				return _bccebg
			}
			_bfcda.UAttr = &_aegbe
			continue
		}
		if _cddeb.Name.Local == "i" {
			_bcfbe, _cdfbbg := _g.ParseBool(_cddeb.Value)
			if _cdfbbg != nil {
				return _cdfbbg
			}
			_bfcda.IAttr = &_bcfbe
			continue
		}
		if _cddeb.Name.Local == "un" {
			_cefdee, _egebde := _g.ParseBool(_cddeb.Value)
			if _egebde != nil {
				return _egebde
			}
			_bfcda.UnAttr = &_cefdee
			continue
		}
		if _cddeb.Name.Local == "st" {
			_cbcbc, _ddggd := _g.ParseBool(_cddeb.Value)
			if _ddggd != nil {
				return _ddggd
			}
			_bfcda.StAttr = &_cbcbc
			continue
		}
		if _cddeb.Name.Local == "b" {
			_dgafcf, _agfeec := _g.ParseBool(_cddeb.Value)
			if _agfeec != nil {
				return _agfeec
			}
			_bfcda.BAttr = &_dgafcf
			continue
		}
	}
_fbgfb:
	for {
		_dddfd, _dbbedc := d.Token()
		if _dbbedc != nil {
			return _dbbedc
		}
		switch _fadfc := _dddfd.(type) {
		case _f.StartElement:
			switch _fadfc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tpls"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tpls"}:
				_gafbac := NewCT_Tuples()
				if _aegbb := d.DecodeElement(_gafbac, &_fadfc); _aegbb != nil {
					return _aegbb
				}
				_bfcda.Tpls = append(_bfcda.Tpls, _gafbac)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "x"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "x"}:
				_beabc := NewCT_X()
				if _febfc := d.DecodeElement(_beabc, &_fadfc); _febfc != nil {
					return _febfc
				}
				_bfcda.X = append(_bfcda.X, _beabc)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_String \u0025v", _fadfc.Name)
				if _ebeefd := d.Skip(); _ebeefd != nil {
					return _ebeefd
				}
			}
		case _f.EndElement:
			break _fbgfb
		case _f.CharData:
		}
	}
	return nil
}

type CT_DataValidation struct {

	// Data Validation Type
	TypeAttr ST_DataValidationType

	// Data Validation Error Style
	ErrorStyleAttr ST_DataValidationErrorStyle

	// IME Mode Enforced
	ImeModeAttr ST_DataValidationImeMode

	// Operator
	OperatorAttr ST_DataValidationOperator

	// Allow Blank
	AllowBlankAttr *bool

	// Show Drop Down
	ShowDropDownAttr *bool

	// Show Input Message
	ShowInputMessageAttr *bool

	// Show Error Message
	ShowErrorMessageAttr *bool

	// Error Alert Text
	ErrorTitleAttr *string

	// Error Message
	ErrorAttr *string

	// Prompt Title
	PromptTitleAttr *string

	// Input Prompt
	PromptAttr *string

	// Sequence of References
	SqrefAttr ST_Sqref

	// Formula 1
	Formula1 *string

	// Formula 2
	Formula2 *string
}

// ValidateWithPath validates the CT_ProtectedRanges and its children, prefixing error messages with path
func (_bdcf *CT_ProtectedRanges) ValidateWithPath(path string) error {
	for _gabbf, _gaebd := range _bdcf.ProtectedRange {
		if _abbefd := _gaebd.ValidateWithPath(_bg.Sprintf("%s\u002fProtectedRange\u005b\u0025d\u005d", path, _gabbf)); _abbefd != nil {
			return _abbefd
		}
	}
	return nil
}
func (_aeaa *CT_Border) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bfbf := range start.Attr {
		if _bfbf.Name.Local == "diagonalUp" {
			_bbec, _bdfa := _g.ParseBool(_bfbf.Value)
			if _bdfa != nil {
				return _bdfa
			}
			_aeaa.DiagonalUpAttr = &_bbec
			continue
		}
		if _bfbf.Name.Local == "diagonalDown" {
			_ccdd, _cdfd := _g.ParseBool(_bfbf.Value)
			if _cdfd != nil {
				return _cdfd
			}
			_aeaa.DiagonalDownAttr = &_ccdd
			continue
		}
		if _bfbf.Name.Local == "outline" {
			_gbg, _bae := _g.ParseBool(_bfbf.Value)
			if _bae != nil {
				return _bae
			}
			_aeaa.OutlineAttr = &_gbg
			continue
		}
	}
_gagg:
	for {
		_aba, _fagc := d.Token()
		if _fagc != nil {
			return _fagc
		}
		switch _ead := _aba.(type) {
		case _f.StartElement:
			switch _ead.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "start"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "start"}:
				_aeaa.Start = NewCT_BorderPr()
				if _acf := d.DecodeElement(_aeaa.Start, &_ead); _acf != nil {
					return _acf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "end"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "end"}:
				_aeaa.End = NewCT_BorderPr()
				if _adde := d.DecodeElement(_aeaa.End, &_ead); _adde != nil {
					return _adde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "left"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "left"}:
				_aeaa.Left = NewCT_BorderPr()
				if _fbba := d.DecodeElement(_aeaa.Left, &_ead); _fbba != nil {
					return _fbba
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "right"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "right"}:
				_aeaa.Right = NewCT_BorderPr()
				if _efa := d.DecodeElement(_aeaa.Right, &_ead); _efa != nil {
					return _efa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "top"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "top"}:
				_aeaa.Top = NewCT_BorderPr()
				if _dgg := d.DecodeElement(_aeaa.Top, &_ead); _dgg != nil {
					return _dgg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "bottom"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "bottom"}:
				_aeaa.Bottom = NewCT_BorderPr()
				if _cbe := d.DecodeElement(_aeaa.Bottom, &_ead); _cbe != nil {
					return _cbe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "diagonal"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "diagonal"}:
				_aeaa.Diagonal = NewCT_BorderPr()
				if _beae := d.DecodeElement(_aeaa.Diagonal, &_ead); _beae != nil {
					return _beae
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "vertical"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "vertical"}:
				_aeaa.Vertical = NewCT_BorderPr()
				if _ggec := d.DecodeElement(_aeaa.Vertical, &_ead); _ggec != nil {
					return _ggec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "horizontal"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "horizontal"}:
				_aeaa.Horizontal = NewCT_BorderPr()
				if _feb := d.DecodeElement(_aeaa.Horizontal, &_ead); _feb != nil {
					return _feb
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_Border \u0025v", _ead.Name)
				if _dea := d.Skip(); _dea != nil {
					return _dea
				}
			}
		case _f.EndElement:
			break _gagg
		case _f.CharData:
		}
	}
	return nil
}

type CT_ConditionalFormat struct {

	// Conditional Formatting Scope
	ScopeAttr ST_Scope

	// Conditional Formatting Rule Type
	TypeAttr ST_Type

	// Priority
	PriorityAttr uint32

	// Pivot Areas
	PivotAreas *CT_PivotAreas
	ExtLst     *CT_ExtensionList
}

func NewCT_DateGroupItem() *CT_DateGroupItem {
	_ddgb := &CT_DateGroupItem{}
	_ddgb.DateTimeGroupingAttr = ST_DateTimeGrouping(1)
	return _ddgb
}

type CT_ExternalSheetData struct {

	// Sheet Id
	SheetIdAttr uint32

	// Last Refresh Resulted in Error
	RefreshErrorAttr *bool

	// Row
	Row []*CT_ExternalRow
}
type CT_VerticalAlignFontProperty struct {

	// Value
	ValAttr _e.ST_VerticalAlignRun
}
type CT_DrawingHF struct {
	IdAttr string

	// Left Header for Odd Pages
	LhoAttr *uint32

	// Left Header for Even Pages
	LheAttr *uint32

	// Left Header for First Page
	LhfAttr *uint32

	// Center Header for Odd Pages
	ChoAttr *uint32

	// Center Header for Even Pages
	CheAttr *uint32

	// Center Header for First Page
	ChfAttr *uint32

	// Right Header for Odd Pages
	RhoAttr *uint32

	// Right Header for Even Pages
	RheAttr *uint32

	// Right Header for First Page
	RhfAttr *uint32

	// Left Footer for Odd Pages
	LfoAttr *uint32

	// Left Footer for Even Pages
	LfeAttr *uint32

	// Left Footer for First Page
	LffAttr *uint32

	// Center Footer for Odd Pages
	CfoAttr *uint32

	// Center Footer for Even Pages
	CfeAttr *uint32

	// Center Footer for First Page
	CffAttr *uint32

	// Right Footer for Odd Pages
	RfoAttr *uint32

	// Right Footer for Even Pages
	RfeAttr *uint32

	// Right Footer for First Page
	RffAttr *uint32
}

func NewCT_DataField() *CT_DataField { _dadac := &CT_DataField{}; return _dadac }
func NewCT_FontScheme() *CT_FontScheme {
	_gfefb := &CT_FontScheme{}
	_gfefb.ValAttr = ST_FontScheme(1)
	return _gfefb
}
func NewCT_RevisionAutoFormatting() *CT_RevisionAutoFormatting {
	_gdfdd := &CT_RevisionAutoFormatting{}
	return _gdfdd
}
func NewCT_Boolean() *CT_Boolean { _aca := &CT_Boolean{}; return _aca }

// ValidateWithPath validates the CT_ChartsheetViews and its children, prefixing error messages with path
func (_eaedc *CT_ChartsheetViews) ValidateWithPath(path string) error {
	for _fgd, _bcc := range _eaedc.SheetView {
		if _bcbff := _bcc.ValidateWithPath(_bg.Sprintf("\u0025s/SheetView\u005b\u0025d\u005d", path, _fgd)); _bcbff != nil {
			return _bcbff
		}
	}
	if _eaedc.ExtLst != nil {
		if _gfeg := _eaedc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gfeg != nil {
			return _gfeg
		}
	}
	return nil
}

type CT_RevisionCustomView struct {

	// GUID
	GuidAttr string

	// User Action
	ActionAttr ST_RevisionAction
}

// ValidateWithPath validates the CT_MdxMemeberProp and its children, prefixing error messages with path
func (_ebfda *CT_MdxMemeberProp) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_CalculatedMember and its children, prefixing error messages with path
func (_fegd *CT_CalculatedMember) ValidateWithPath(path string) error {
	if _fegd.ExtLst != nil {
		if _bbed := _fegd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bbed != nil {
			return _bbed
		}
	}
	return nil
}

// ValidateWithPath validates the CT_HierarchyUsage and its children, prefixing error messages with path
func (_bdabbc *CT_HierarchyUsage) ValidateWithPath(path string) error { return nil }
func (_cebba *ST_PatternType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_cebba = 0
	case "none":
		*_cebba = 1
	case "solid":
		*_cebba = 2
	case "mediumGray":
		*_cebba = 3
	case "darkGray":
		*_cebba = 4
	case "lightGray":
		*_cebba = 5
	case "darkHorizontal":
		*_cebba = 6
	case "darkVertical":
		*_cebba = 7
	case "darkDown":
		*_cebba = 8
	case "darkUp":
		*_cebba = 9
	case "darkGrid":
		*_cebba = 10
	case "darkTrellis":
		*_cebba = 11
	case "lightHorizontal":
		*_cebba = 12
	case "lightVertical":
		*_cebba = 13
	case "lightDown":
		*_cebba = 14
	case "lightUp":
		*_cebba = 15
	case "lightGrid":
		*_cebba = 16
	case "lightTrellis":
		*_cebba = 17
	case "gray125":
		*_cebba = 18
	case "gray0625":
		*_cebba = 19
	}
	return nil
}
func (_fbceg *CT_Users) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fbceg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_fbceg.CountAttr)})
	}
	e.EncodeToken(start)
	if _fbceg.UserInfo != nil {
		_dedce := _f.StartElement{Name: _f.Name{Local: "ma:userInfo"}}
		for _, _egdbf := range _fbceg.UserInfo {
			e.EncodeElement(_egdbf, _dedce)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_TupleCache() *CT_TupleCache { _dcgb := &CT_TupleCache{}; return _dcgb }
func (_fdcf *CT_CellStyle) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fdcf.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_fdcf.NameAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xfId"}, Value: _bg.Sprintf("\u0025v", _fdcf.XfIdAttr)})
	if _fdcf.BuiltinIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "builtinId"}, Value: _bg.Sprintf("\u0025v", *_fdcf.BuiltinIdAttr)})
	}
	if _fdcf.ILevelAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "iLevel"}, Value: _bg.Sprintf("\u0025v", *_fdcf.ILevelAttr)})
	}
	if _fdcf.HiddenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hidden"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fdcf.HiddenAttr))})
	}
	if _fdcf.CustomBuiltinAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "customBuiltin"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fdcf.CustomBuiltinAttr))})
	}
	e.EncodeToken(start)
	if _fdcf.ExtLst != nil {
		_gcd := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_fdcf.ExtLst, _gcd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gcaf *CT_SheetId) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fecdc := range start.Attr {
		if _fecdc.Name.Local == "val" {
			_gdaag, _eeece := _g.ParseUint(_fecdc.Value, 10, 32)
			if _eeece != nil {
				return _eeece
			}
			_gcaf.ValAttr = uint32(_gdaag)
			continue
		}
	}
	for {
		_cgffab, _bcefc := d.Token()
		if _bcefc != nil {
			return _bg.Errorf("parsing\u0020CT_SheetId:\u0020%s", _bcefc)
		}
		if _gaggfc, _bbegf := _cgffab.(_f.EndElement); _bbegf && _gaggfc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gfbdg ST_ConditionalFormattingOperator) String() string {
	switch _gfbdg {
	case 0:
		return ""
	case 1:
		return "lessThan"
	case 2:
		return "lessThanOrEqual"
	case 3:
		return "equal"
	case 4:
		return "notEqual"
	case 5:
		return "greaterThanOrEqual"
	case 6:
		return "greaterThan"
	case 7:
		return "between"
	case 8:
		return "notBetween"
	case 9:
		return "containsText"
	case 10:
		return "notContains"
	case 11:
		return "beginsWith"
	case 12:
		return "endsWith"
	}
	return ""
}

const (
	ST_ParameterTypeUnset  ST_ParameterType = 0
	ST_ParameterTypePrompt ST_ParameterType = 1
	ST_ParameterTypeValue  ST_ParameterType = 2
	ST_ParameterTypeCell   ST_ParameterType = 3
)

func (_edede ST_PrintError) Validate() error { return _edede.ValidateWithPath("") }

type CT_MetadataRecord struct {

	// Metadata Record Type Index
	TAttr uint32

	// Metadata Record Value Index
	VAttr uint32
}

// ValidateWithPath validates the CT_FunctionGroup and its children, prefixing error messages with path
func (_faee *CT_FunctionGroup) ValidateWithPath(path string) error { return nil }
func NewCT_IndexedColors() *CT_IndexedColors                       { _bcaff := &CT_IndexedColors{}; return _bcaff }
func (_fcdgb *CT_TableParts) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cbedgd := range start.Attr {
		if _cbedgd.Name.Local == "count" {
			_dbeec, _ffggb := _g.ParseUint(_cbedgd.Value, 10, 32)
			if _ffggb != nil {
				return _ffggb
			}
			_cbcff := uint32(_dbeec)
			_fcdgb.CountAttr = &_cbcff
			continue
		}
	}
_acfeg:
	for {
		_dfedc, _gcdag := d.Token()
		if _gcdag != nil {
			return _gcdag
		}
		switch _cdegga := _dfedc.(type) {
		case _f.StartElement:
			switch _cdegga.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tablePart"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tablePart"}:
				_gggecf := NewCT_TablePart()
				if _bccdgb := d.DecodeElement(_gggecf, &_cdegga); _bccdgb != nil {
					return _bccdgb
				}
				_fcdgb.TablePart = append(_fcdgb.TablePart, _gggecf)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_TableParts \u0025v", _cdegga.Name)
				if _gafec := d.Skip(); _gafec != nil {
					return _gafec
				}
			}
		case _f.EndElement:
			break _acfeg
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Tuples and its children, prefixing error messages with path
func (_fdcefe *CT_Tuples) ValidateWithPath(path string) error {
	for _affccg, _fggbbg := range _fdcefe.Tpl {
		if _ccbae := _fggbbg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fTpl\u005b\u0025d\u005d", path, _affccg)); _ccbae != nil {
			return _ccbae
		}
	}
	return nil
}

// ValidateWithPath validates the CT_OleLink and its children, prefixing error messages with path
func (_cfadb *CT_OleLink) ValidateWithPath(path string) error {
	if _cfadb.OleItems != nil {
		if _bdgdbb := _cfadb.OleItems.ValidateWithPath(path + "\u002fOleItems"); _bdgdbb != nil {
			return _bdgdbb
		}
	}
	return nil
}
func (_caceg *CT_CustomWorkbookView) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _caceg.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "guid"}, Value: _bg.Sprintf("\u0025v", _caceg.GuidAttr)})
	if _caceg.AutoUpdateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoUpdate"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.AutoUpdateAttr))})
	}
	if _caceg.MergeIntervalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "mergeInterval"}, Value: _bg.Sprintf("\u0025v", *_caceg.MergeIntervalAttr)})
	}
	if _caceg.ChangesSavedWinAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "changesSavedWin"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.ChangesSavedWinAttr))})
	}
	if _caceg.OnlySyncAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "onlySync"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.OnlySyncAttr))})
	}
	if _caceg.PersonalViewAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "personalView"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.PersonalViewAttr))})
	}
	if _caceg.IncludePrintSettingsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "includePrintSettings"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.IncludePrintSettingsAttr))})
	}
	if _caceg.IncludeHiddenRowColAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "includeHiddenRowCol"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.IncludeHiddenRowColAttr))})
	}
	if _caceg.MaximizedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "maximized"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.MaximizedAttr))})
	}
	if _caceg.MinimizedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minimized"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.MinimizedAttr))})
	}
	if _caceg.ShowHorizontalScrollAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showHorizontalScroll"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.ShowHorizontalScrollAttr))})
	}
	if _caceg.ShowVerticalScrollAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showVerticalScroll"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.ShowVerticalScrollAttr))})
	}
	if _caceg.ShowSheetTabsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showSheetTabs"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.ShowSheetTabsAttr))})
	}
	if _caceg.XWindowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xWindow"}, Value: _bg.Sprintf("\u0025v", *_caceg.XWindowAttr)})
	}
	if _caceg.YWindowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "yWindow"}, Value: _bg.Sprintf("\u0025v", *_caceg.YWindowAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "windowWidth"}, Value: _bg.Sprintf("\u0025v", _caceg.WindowWidthAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "windowHeight"}, Value: _bg.Sprintf("\u0025v", _caceg.WindowHeightAttr)})
	if _caceg.TabRatioAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "tabRatio"}, Value: _bg.Sprintf("\u0025v", *_caceg.TabRatioAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "activeSheetId"}, Value: _bg.Sprintf("\u0025v", _caceg.ActiveSheetIdAttr)})
	if _caceg.ShowFormulaBarAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showFormulaBar"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.ShowFormulaBarAttr))})
	}
	if _caceg.ShowStatusbarAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showStatusbar"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caceg.ShowStatusbarAttr))})
	}
	if _caceg.ShowCommentsAttr != ST_CommentsUnset {
		_bceee, _gcab := _caceg.ShowCommentsAttr.MarshalXMLAttr(_f.Name{Local: "showComments"})
		if _gcab != nil {
			return _gcab
		}
		start.Attr = append(start.Attr, _bceee)
	}
	if _caceg.ShowObjectsAttr != ST_ObjectsUnset {
		_ddda, _cbbc := _caceg.ShowObjectsAttr.MarshalXMLAttr(_f.Name{Local: "showObjects"})
		if _cbbc != nil {
			return _cbbc
		}
		start.Attr = append(start.Attr, _ddda)
	}
	e.EncodeToken(start)
	if _caceg.ExtLst != nil {
		_gadbc := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_caceg.ExtLst, _gadbc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_MdxMetadata struct {

	// MDX Metadata Record Count
	CountAttr *uint32

	// MDX Metadata Record
	Mdx []*CT_Mdx
}

func NewCT_DdeItems() *CT_DdeItems           { _cegff := &CT_DdeItems{}; return _cegff }
func NewCT_MeasureGroups() *CT_MeasureGroups { _fdfdb := &CT_MeasureGroups{}; return _fdfdb }

// ValidateWithPath validates the CT_DbPr and its children, prefixing error messages with path
func (_cdcgd *CT_DbPr) ValidateWithPath(path string) error { return nil }
func (_cgffd *CT_Map) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bccb := range start.Attr {
		if _bccb.Name.Local == "ID" {
			_degdg, _aaceg := _g.ParseUint(_bccb.Value, 10, 32)
			if _aaceg != nil {
				return _aaceg
			}
			_cgffd.IDAttr = uint32(_degdg)
			continue
		}
		if _bccb.Name.Local == "Name" {
			_cdcga, _bfdda := _bccb.Value, error(nil)
			if _bfdda != nil {
				return _bfdda
			}
			_cgffd.NameAttr = _cdcga
			continue
		}
		if _bccb.Name.Local == "RootElement" {
			_dbddba, _adaba := _bccb.Value, error(nil)
			if _adaba != nil {
				return _adaba
			}
			_cgffd.RootElementAttr = _dbddba
			continue
		}
		if _bccb.Name.Local == "SchemaID" {
			_cfcaf, _afdff := _bccb.Value, error(nil)
			if _afdff != nil {
				return _afdff
			}
			_cgffd.SchemaIDAttr = _cfcaf
			continue
		}
		if _bccb.Name.Local == "ShowImportExportValidationErrors" {
			_fegfb, _adgd := _g.ParseBool(_bccb.Value)
			if _adgd != nil {
				return _adgd
			}
			_cgffd.ShowImportExportValidationErrorsAttr = _fegfb
			continue
		}
		if _bccb.Name.Local == "AutoFit" {
			_befd, _bdaac := _g.ParseBool(_bccb.Value)
			if _bdaac != nil {
				return _bdaac
			}
			_cgffd.AutoFitAttr = _befd
			continue
		}
		if _bccb.Name.Local == "Append" {
			_gafga, _cgdbg := _g.ParseBool(_bccb.Value)
			if _cgdbg != nil {
				return _cgdbg
			}
			_cgffd.AppendAttr = _gafga
			continue
		}
		if _bccb.Name.Local == "PreserveSortAFLayout" {
			_aage, _gcdfga := _g.ParseBool(_bccb.Value)
			if _gcdfga != nil {
				return _gcdfga
			}
			_cgffd.PreserveSortAFLayoutAttr = _aage
			continue
		}
		if _bccb.Name.Local == "PreserveFormat" {
			_bacea, _dcaac := _g.ParseBool(_bccb.Value)
			if _dcaac != nil {
				return _dcaac
			}
			_cgffd.PreserveFormatAttr = _bacea
			continue
		}
	}
_gbagd:
	for {
		_caedb, _gegc := d.Token()
		if _gegc != nil {
			return _gegc
		}
		switch _ddag := _caedb.(type) {
		case _f.StartElement:
			switch _ddag.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "DataBinding"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "DataBinding"}:
				_cgffd.DataBinding = NewCT_DataBinding()
				if _cfbd := d.DecodeElement(_cgffd.DataBinding, &_ddag); _cfbd != nil {
					return _cfbd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Map\u0020\u0025v", _ddag.Name)
				if _baeaa := d.Skip(); _baeaa != nil {
					return _baeaa
				}
			}
		case _f.EndElement:
			break _gbagd
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_FutureMetadata and its children, prefixing error messages with path
func (_cdaaf *CT_FutureMetadata) ValidateWithPath(path string) error {
	for _dacaa, _eafb := range _cdaaf.Bk {
		if _bdacb := _eafb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fBk\u005b\u0025d]", path, _dacaa)); _bdacb != nil {
			return _bdacb
		}
	}
	if _cdaaf.ExtLst != nil {
		if _cebfcf := _cdaaf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cebfcf != nil {
			return _cebfcf
		}
	}
	return nil
}
func (_acbaeg ST_FileType) ValidateWithPath(path string) error {
	switch _acbaeg {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_acbaeg))
	}
	return nil
}

type ST_CredMethod byte

func (_begge ST_ShowDataAs) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_begge.String(), start)
}

// ValidateWithPath validates the CT_PageFields and its children, prefixing error messages with path
func (_ccddg *CT_PageFields) ValidateWithPath(path string) error {
	for _bgaf, _gbfegc := range _ccddg.PageField {
		if _egafb := _gbfegc.ValidateWithPath(_bg.Sprintf("\u0025s/PageField\u005b\u0025d\u005d", path, _bgaf)); _egafb != nil {
			return _egafb
		}
	}
	return nil
}
func (_ddfbg ST_HtmlFmt) String() string {
	switch _ddfbg {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "rtf"
	case 3:
		return "all"
	}
	return ""
}
func (_gefc *CT_ChartsheetPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fbdc := range start.Attr {
		if _fbdc.Name.Local == "published" {
			_fdacc, _bcbbg := _g.ParseBool(_fbdc.Value)
			if _bcbbg != nil {
				return _bcbbg
			}
			_gefc.PublishedAttr = &_fdacc
			continue
		}
		if _fbdc.Name.Local == "codeName" {
			_cbee, _ececg := _fbdc.Value, error(nil)
			if _ececg != nil {
				return _ececg
			}
			_gefc.CodeNameAttr = &_cbee
			continue
		}
	}
_dbbgg:
	for {
		_bcdg, _dca := d.Token()
		if _dca != nil {
			return _dca
		}
		switch _beced := _bcdg.(type) {
		case _f.StartElement:
			switch _beced.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tabColor"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tabColor"}:
				_gefc.TabColor = NewCT_Color()
				if _fdcae := d.DecodeElement(_gefc.TabColor, &_beced); _fdcae != nil {
					return _fdcae
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ChartsheetPr\u0020\u0025v", _beced.Name)
				if _badde := d.Skip(); _badde != nil {
					return _badde
				}
			}
		case _f.EndElement:
			break _dbbgg
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_CacheHierarchies() *CT_CacheHierarchies { _ebcd := &CT_CacheHierarchies{}; return _ebcd }

// Validate validates the CT_DbPr and its children
func (_acfaa *CT_DbPr) Validate() error { return _acfaa.ValidateWithPath("CT_DbPr") }

const (
	ST_DataValidationErrorStyleUnset       ST_DataValidationErrorStyle = 0
	ST_DataValidationErrorStyleStop        ST_DataValidationErrorStyle = 1
	ST_DataValidationErrorStyleWarning     ST_DataValidationErrorStyle = 2
	ST_DataValidationErrorStyleInformation ST_DataValidationErrorStyle = 3
)

func (_becced *CT_PivotFilter) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fld"}, Value: _bg.Sprintf("\u0025v", _becced.FldAttr)})
	if _becced.MpFldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "mpFld"}, Value: _bg.Sprintf("\u0025v", *_becced.MpFldAttr)})
	}
	_aeffa, _cafggb := _becced.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
	if _cafggb != nil {
		return _cafggb
	}
	start.Attr = append(start.Attr, _aeffa)
	if _becced.EvalOrderAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "evalOrder"}, Value: _bg.Sprintf("\u0025v", *_becced.EvalOrderAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", _becced.IdAttr)})
	if _becced.IMeasureHierAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "iMeasureHier"}, Value: _bg.Sprintf("\u0025v", *_becced.IMeasureHierAttr)})
	}
	if _becced.IMeasureFldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "iMeasureFld"}, Value: _bg.Sprintf("\u0025v", *_becced.IMeasureFldAttr)})
	}
	if _becced.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_becced.NameAttr)})
	}
	if _becced.DescriptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "description"}, Value: _bg.Sprintf("\u0025v", *_becced.DescriptionAttr)})
	}
	if _becced.StringValue1Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "stringValue1"}, Value: _bg.Sprintf("\u0025v", *_becced.StringValue1Attr)})
	}
	if _becced.StringValue2Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "stringValue2"}, Value: _bg.Sprintf("\u0025v", *_becced.StringValue2Attr)})
	}
	e.EncodeToken(start)
	_ceeef := _f.StartElement{Name: _f.Name{Local: "ma:autoFilter"}}
	e.EncodeElement(_becced.AutoFilter, _ceeef)
	if _becced.ExtLst != nil {
		_dffgc := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_becced.ExtLst, _dffgc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Error and its children, prefixing error messages with path
func (_fegb *CT_Error) ValidateWithPath(path string) error {
	if _fegb.Tpls != nil {
		if _abdgd := _fegb.Tpls.ValidateWithPath(path + "\u002fTpls"); _abdgd != nil {
			return _abdgd
		}
	}
	for _baad, _gbce := range _fegb.X {
		if _bgec := _gbce.ValidateWithPath(_bg.Sprintf("\u0025s\u002fX\u005b\u0025d\u005d", path, _baad)); _bgec != nil {
			return _bgec
		}
	}
	return nil
}

// ValidateWithPath validates the CT_DataField and its children, prefixing error messages with path
func (_fbea *CT_DataField) ValidateWithPath(path string) error {
	if _fefg := _fbea.SubtotalAttr.ValidateWithPath(path + "\u002fSubtotalAttr"); _fefg != nil {
		return _fefg
	}
	if _gfffg := _fbea.ShowDataAsAttr.ValidateWithPath(path + "\u002fShowDataAsAttr"); _gfffg != nil {
		return _gfffg
	}
	if _fbea.ExtLst != nil {
		if _egdg := _fbea.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _egdg != nil {
			return _egdg
		}
	}
	return nil
}
func (_cdced *CT_SheetViews) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_gbdea := _f.StartElement{Name: _f.Name{Local: "ma:sheetView"}}
	for _, _gcegf := range _cdced.SheetView {
		e.EncodeElement(_gcegf, _gbdea)
	}
	if _cdced.ExtLst != nil {
		_cacge := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_cdced.ExtLst, _cacge)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ffagb *CT_OleItem) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bcega := range start.Attr {
		if _bcega.Name.Local == "name" {
			_efegd, _bgede := _bcega.Value, error(nil)
			if _bgede != nil {
				return _bgede
			}
			_ffagb.NameAttr = _efegd
			continue
		}
		if _bcega.Name.Local == "icon" {
			_gcfc, _afcge := _g.ParseBool(_bcega.Value)
			if _afcge != nil {
				return _afcge
			}
			_ffagb.IconAttr = &_gcfc
			continue
		}
		if _bcega.Name.Local == "advise" {
			_abbbf, _beddb := _g.ParseBool(_bcega.Value)
			if _beddb != nil {
				return _beddb
			}
			_ffagb.AdviseAttr = &_abbbf
			continue
		}
		if _bcega.Name.Local == "preferPic" {
			_eeafae, _gceed := _g.ParseBool(_bcega.Value)
			if _gceed != nil {
				return _gceed
			}
			_ffagb.PreferPicAttr = &_eeafae
			continue
		}
	}
	for {
		_eggf, _gcaea := d.Token()
		if _gcaea != nil {
			return _bg.Errorf("parsing\u0020CT_OleItem:\u0020%s", _gcaea)
		}
		if _gbaef, _agadc := _eggf.(_f.EndElement); _agadc && _gbaef.Name == start.Name {
			break
		}
	}
	return nil
}

type Workbook struct{ CT_Workbook }

func (_cgddb *CT_Parameters) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cgddb.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_cgddb.CountAttr)})
	}
	e.EncodeToken(start)
	_gefag := _f.StartElement{Name: _f.Name{Local: "ma:parameter"}}
	for _, _cggege := range _cgddb.Parameter {
		e.EncodeElement(_cggege, _gefag)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ffadd ST_FilterOperator) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_addafd := _f.Attr{}
	_addafd.Name = name
	switch _ffadd {
	case ST_FilterOperatorUnset:
		_addafd.Value = ""
	case ST_FilterOperatorEqual:
		_addafd.Value = "equal"
	case ST_FilterOperatorLessThan:
		_addafd.Value = "lessThan"
	case ST_FilterOperatorLessThanOrEqual:
		_addafd.Value = "lessThanOrEqual"
	case ST_FilterOperatorNotEqual:
		_addafd.Value = "notEqual"
	case ST_FilterOperatorGreaterThanOrEqual:
		_addafd.Value = "greaterThanOrEqual"
	case ST_FilterOperatorGreaterThan:
		_addafd.Value = "greaterThan"
	}
	return _addafd, nil
}
func (_adfe *CT_IndexedColors) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_gfdgg:
	for {
		_fbgfcb, _cfeaa := d.Token()
		if _cfeaa != nil {
			return _cfeaa
		}
		switch _bcaba := _fbgfcb.(type) {
		case _f.StartElement:
			switch _bcaba.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rgbColor"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rgbColor"}:
				_bfgcc := NewCT_RgbColor()
				if _gcbfa := d.DecodeElement(_bfgcc, &_bcaba); _gcbfa != nil {
					return _gcbfa
				}
				_adfe.RgbColor = append(_adfe.RgbColor, _bfgcc)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_IndexedColors\u0020\u0025v", _bcaba.Name)
				if _egae := d.Skip(); _egae != nil {
					return _egae
				}
			}
		case _f.EndElement:
			break _gfdgg
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_CustomProperty and its children
func (_adda *CT_CustomProperty) Validate() error { return _adda.ValidateWithPath("CT_CustomProperty") }

type ST_SourceType byte

func (_egagf *CT_QueryTableRefresh) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _egagf.PreserveSortFilterLayoutAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "preserveSortFilterLayout"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_egagf.PreserveSortFilterLayoutAttr))})
	}
	if _egagf.FieldIdWrappedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fieldIdWrapped"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_egagf.FieldIdWrappedAttr))})
	}
	if _egagf.HeadersInLastRefreshAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "headersInLastRefresh"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_egagf.HeadersInLastRefreshAttr))})
	}
	if _egagf.MinimumVersionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minimumVersion"}, Value: _bg.Sprintf("\u0025v", *_egagf.MinimumVersionAttr)})
	}
	if _egagf.NextIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "nextId"}, Value: _bg.Sprintf("\u0025v", *_egagf.NextIdAttr)})
	}
	if _egagf.UnboundColumnsLeftAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "unboundColumnsLeft"}, Value: _bg.Sprintf("\u0025v", *_egagf.UnboundColumnsLeftAttr)})
	}
	if _egagf.UnboundColumnsRightAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "unboundColumnsRight"}, Value: _bg.Sprintf("\u0025v", *_egagf.UnboundColumnsRightAttr)})
	}
	e.EncodeToken(start)
	_gceba := _f.StartElement{Name: _f.Name{Local: "ma:queryTableFields"}}
	e.EncodeElement(_egagf.QueryTableFields, _gceba)
	if _egagf.QueryTableDeletedFields != nil {
		_gcfge := _f.StartElement{Name: _f.Name{Local: "ma:queryTableDeletedFields"}}
		e.EncodeElement(_egagf.QueryTableDeletedFields, _gcfge)
	}
	if _egagf.SortState != nil {
		_faccb := _f.StartElement{Name: _f.Name{Local: "ma:sortState"}}
		e.EncodeElement(_egagf.SortState, _faccb)
	}
	if _egagf.ExtLst != nil {
		_cfed := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_egagf.ExtLst, _cfed)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_ChartFormat struct {

	// Chart Index
	ChartAttr uint32

	// Pivot Format Id
	FormatAttr uint32

	// Series Format
	SeriesAttr *bool

	// Pivot Table Location Rule
	PivotArea *CT_PivotArea
}
type CT_MetadataBlock struct {

	// Metadata Record
	Rc []*CT_MetadataRecord
}
type CT_WorkbookProtection struct {

	// Legacy Workbook Password
	WorkbookPasswordAttr *string

	// Workbook Password Character Set
	WorkbookPasswordCharacterSetAttr *string

	// Legacy Revisions Password
	RevisionsPasswordAttr *string

	// Revisions Password Character Set
	RevisionsPasswordCharacterSetAttr *string

	// Lock Structure
	LockStructureAttr *bool

	// Lock Windows
	LockWindowsAttr *bool

	// Lock Revisions
	LockRevisionAttr *bool

	// Cryptographic Algorithm Name
	RevisionsAlgorithmNameAttr *string

	// Password Hash Value
	RevisionsHashValueAttr *string

	// Salt Value for Password Verifier
	RevisionsSaltValueAttr *string

	// Iterations to Run Hashing Algorithm
	RevisionsSpinCountAttr *uint32

	// Cryptographic Algorithm Name
	WorkbookAlgorithmNameAttr *string

	// Password Hash Value
	WorkbookHashValueAttr *string

	// Salt Value for Password Verifier
	WorkbookSaltValueAttr *string

	// Iterations to Run Hashing Algorithm
	WorkbookSpinCountAttr *uint32
}

func NewCT_XmlPr() *CT_XmlPr { _ecebdb := &CT_XmlPr{}; return _ecebdb }

type CT_PCDKPIs struct {

	// KPI Count
	CountAttr *uint32

	// OLAP KPI
	Kpi []*CT_PCDKPI
}
type CT_Mdx struct {

	// Connection Name Index
	NAttr uint32

	// Cube Function Tag
	FAttr ST_MdxFunctionType

	// Tuple MDX Metadata
	T *CT_MdxTuple

	// Set MDX Metadata
	Ms *CT_MdxSet

	// Member Property MDX Metadata
	P *CT_MdxMemeberProp

	// KPI MDX Metadata
	K *CT_MdxKPI
}

// Validate validates the CT_SmartTags and its children
func (_ccgdf *CT_SmartTags) Validate() error { return _ccgdf.ValidateWithPath("CT_SmartTags") }

// ValidateWithPath validates the CT_DdeLink and its children, prefixing error messages with path
func (_eefad *CT_DdeLink) ValidateWithPath(path string) error {
	if _eefad.DdeItems != nil {
		if _bede := _eefad.DdeItems.ValidateWithPath(path + "\u002fDdeItems"); _bede != nil {
			return _bede
		}
	}
	return nil
}
func (_eeafa *CT_Missing) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _agfbc := range start.Attr {
		if _agfbc.Name.Local == "fc" {
			_facgc, _gbace := _agfbc.Value, error(nil)
			if _gbace != nil {
				return _gbace
			}
			_eeafa.FcAttr = &_facgc
			continue
		}
		if _agfbc.Name.Local == "f" {
			_fbcdc, _feecg := _g.ParseBool(_agfbc.Value)
			if _feecg != nil {
				return _feecg
			}
			_eeafa.FAttr = &_fbcdc
			continue
		}
		if _agfbc.Name.Local == "c" {
			_feacf, _aabfb := _agfbc.Value, error(nil)
			if _aabfb != nil {
				return _aabfb
			}
			_eeafa.CAttr = &_feacf
			continue
		}
		if _agfbc.Name.Local == "cp" {
			_afgea, _gbdec := _g.ParseUint(_agfbc.Value, 10, 32)
			if _gbdec != nil {
				return _gbdec
			}
			_abeab := uint32(_afgea)
			_eeafa.CpAttr = &_abeab
			continue
		}
		if _agfbc.Name.Local == "in" {
			_bcdbf, _egdac := _g.ParseUint(_agfbc.Value, 10, 32)
			if _egdac != nil {
				return _egdac
			}
			_ecdfcc := uint32(_bcdbf)
			_eeafa.InAttr = &_ecdfcc
			continue
		}
		if _agfbc.Name.Local == "bc" {
			_egccb, _fecac := _agfbc.Value, error(nil)
			if _fecac != nil {
				return _fecac
			}
			_eeafa.BcAttr = &_egccb
			continue
		}
		if _agfbc.Name.Local == "u" {
			_cegaea, _gcdce := _g.ParseBool(_agfbc.Value)
			if _gcdce != nil {
				return _gcdce
			}
			_eeafa.UAttr = &_cegaea
			continue
		}
		if _agfbc.Name.Local == "i" {
			_cffdb, _cgcfb := _g.ParseBool(_agfbc.Value)
			if _cgcfb != nil {
				return _cgcfb
			}
			_eeafa.IAttr = &_cffdb
			continue
		}
		if _agfbc.Name.Local == "un" {
			_acefg, _dfacb := _g.ParseBool(_agfbc.Value)
			if _dfacb != nil {
				return _dfacb
			}
			_eeafa.UnAttr = &_acefg
			continue
		}
		if _agfbc.Name.Local == "st" {
			_bbegegb, _abdcf := _g.ParseBool(_agfbc.Value)
			if _abdcf != nil {
				return _abdcf
			}
			_eeafa.StAttr = &_bbegegb
			continue
		}
		if _agfbc.Name.Local == "b" {
			_fbgag, _caaf := _g.ParseBool(_agfbc.Value)
			if _caaf != nil {
				return _caaf
			}
			_eeafa.BAttr = &_fbgag
			continue
		}
	}
_cbdc:
	for {
		_degff, _faegg := d.Token()
		if _faegg != nil {
			return _faegg
		}
		switch _eaab := _degff.(type) {
		case _f.StartElement:
			switch _eaab.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tpls"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tpls"}:
				_gbad := NewCT_Tuples()
				if _cgeg := d.DecodeElement(_gbad, &_eaab); _cgeg != nil {
					return _cgeg
				}
				_eeafa.Tpls = append(_eeafa.Tpls, _gbad)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "x"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "x"}:
				_deaee := NewCT_X()
				if _befdg := d.DecodeElement(_deaee, &_eaab); _befdg != nil {
					return _befdg
				}
				_eeafa.X = append(_eeafa.X, _deaee)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_Missing\u0020\u0025v", _eaab.Name)
				if _caecf := d.Skip(); _caecf != nil {
					return _caecf
				}
			}
		case _f.EndElement:
			break _cbdc
		case _f.CharData:
		}
	}
	return nil
}

type CT_PivotFields struct {

	// Field Count
	CountAttr *uint32

	// PivotTable Field
	PivotField []*CT_PivotField
}

func (_aecgba ST_Scope) Validate() error { return _aecgba.ValidateWithPath("") }

// ValidateWithPath validates the CT_RangePr and its children, prefixing error messages with path
func (_aegae *CT_RangePr) ValidateWithPath(path string) error {
	if _bdbcg := _aegae.GroupByAttr.ValidateWithPath(path + "\u002fGroupByAttr"); _bdbcg != nil {
		return _bdbcg
	}
	return nil
}
func (_eebbc *CT_VerticalAlignFontProperty) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	_bbgdf, _fccfe := _eebbc.ValAttr.MarshalXMLAttr(_f.Name{Local: "val"})
	if _fccfe != nil {
		return _fccfe
	}
	start.Attr = append(start.Attr, _bbgdf)
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_CalcPr() *CT_CalcPr { _fgca := &CT_CalcPr{}; return _fgca }
func (_ceaef *CT_QueryTableDeletedFields) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abadf := range start.Attr {
		if _abadf.Name.Local == "count" {
			_aafgg, _bagab := _g.ParseUint(_abadf.Value, 10, 32)
			if _bagab != nil {
				return _bagab
			}
			_caaca := uint32(_aafgg)
			_ceaef.CountAttr = &_caaca
			continue
		}
	}
_eecae:
	for {
		_efgefe, _afedg := d.Token()
		if _afedg != nil {
			return _afedg
		}
		switch _bcgfb := _efgefe.(type) {
		case _f.StartElement:
			switch _bcgfb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "deletedField"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "deletedField"}:
				_gedgg := NewCT_DeletedField()
				if _ffge := d.DecodeElement(_gedgg, &_bcgfb); _ffge != nil {
					return _ffge
				}
				_ceaef.DeletedField = append(_ceaef.DeletedField, _gedgg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_QueryTableDeletedFields\u0020\u0025v", _bcgfb.Name)
				if _fbgcff := d.Skip(); _fbgcff != nil {
					return _fbgcff
				}
			}
		case _f.EndElement:
			break _eecae
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CalcCell and its children, prefixing error messages with path
func (_cced *CT_CalcCell) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_SheetIdMap and its children, prefixing error messages with path
func (_gfadcg *CT_SheetIdMap) ValidateWithPath(path string) error {
	for _gbcge, _aebabd := range _gfadcg.SheetId {
		if _bgafa := _aebabd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fSheetId\u005b\u0025d\u005d", path, _gbcge)); _bgafa != nil {
			return _bgafa
		}
	}
	return nil
}

type CT_rowItems struct {

	// Items in a Row Count
	CountAttr *uint32

	// Row Items
	I []*CT_I
}

func (_gbdgf *CT_QueryTable) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _gbdgf.NameAttr)})
	if _gbdgf.HeadersAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "headers"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.HeadersAttr))})
	}
	if _gbdgf.RowNumbersAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rowNumbers"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.RowNumbersAttr))})
	}
	if _gbdgf.DisableRefreshAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "disableRefresh"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.DisableRefreshAttr))})
	}
	if _gbdgf.BackgroundRefreshAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "backgroundRefresh"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.BackgroundRefreshAttr))})
	}
	if _gbdgf.FirstBackgroundRefreshAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "firstBackgroundRefresh"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.FirstBackgroundRefreshAttr))})
	}
	if _gbdgf.RefreshOnLoadAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refreshOnLoad"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.RefreshOnLoadAttr))})
	}
	if _gbdgf.GrowShrinkTypeAttr != ST_GrowShrinkTypeUnset {
		_gaeac, _cbaeb := _gbdgf.GrowShrinkTypeAttr.MarshalXMLAttr(_f.Name{Local: "growShrinkType"})
		if _cbaeb != nil {
			return _cbaeb
		}
		start.Attr = append(start.Attr, _gaeac)
	}
	if _gbdgf.FillFormulasAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fillFormulas"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.FillFormulasAttr))})
	}
	if _gbdgf.RemoveDataOnSaveAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "removeDataOnSave"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.RemoveDataOnSaveAttr))})
	}
	if _gbdgf.DisableEditAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "disableEdit"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.DisableEditAttr))})
	}
	if _gbdgf.PreserveFormattingAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "preserveFormatting"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.PreserveFormattingAttr))})
	}
	if _gbdgf.AdjustColumnWidthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "adjustColumnWidth"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.AdjustColumnWidthAttr))})
	}
	if _gbdgf.IntermediateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "intermediate"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.IntermediateAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "connectionId"}, Value: _bg.Sprintf("\u0025v", _gbdgf.ConnectionIdAttr)})
	if _gbdgf.AutoFormatIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoFormatId"}, Value: _bg.Sprintf("\u0025v", *_gbdgf.AutoFormatIdAttr)})
	}
	if _gbdgf.ApplyNumberFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyNumberFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.ApplyNumberFormatsAttr))})
	}
	if _gbdgf.ApplyBorderFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyBorderFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.ApplyBorderFormatsAttr))})
	}
	if _gbdgf.ApplyFontFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyFontFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.ApplyFontFormatsAttr))})
	}
	if _gbdgf.ApplyPatternFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyPatternFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.ApplyPatternFormatsAttr))})
	}
	if _gbdgf.ApplyAlignmentFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyAlignmentFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.ApplyAlignmentFormatsAttr))})
	}
	if _gbdgf.ApplyWidthHeightFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyWidthHeightFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbdgf.ApplyWidthHeightFormatsAttr))})
	}
	e.EncodeToken(start)
	if _gbdgf.QueryTableRefresh != nil {
		_aafbb := _f.StartElement{Name: _f.Name{Local: "ma:queryTableRefresh"}}
		e.EncodeElement(_gbdgf.QueryTableRefresh, _aafbb)
	}
	if _gbdgf.ExtLst != nil {
		_egbbd := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_gbdgf.ExtLst, _egbbd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_egeaa *CT_PivotSelection) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _egeaa.PaneAttr != ST_PaneUnset {
		_faaec, _fgdaf := _egeaa.PaneAttr.MarshalXMLAttr(_f.Name{Local: "pane"})
		if _fgdaf != nil {
			return _fgdaf
		}
		start.Attr = append(start.Attr, _faaec)
	}
	if _egeaa.ShowHeaderAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showHeader"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_egeaa.ShowHeaderAttr))})
	}
	if _egeaa.LabelAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "label"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_egeaa.LabelAttr))})
	}
	if _egeaa.DataAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "data"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_egeaa.DataAttr))})
	}
	if _egeaa.ExtendableAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "extendable"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_egeaa.ExtendableAttr))})
	}
	if _egeaa.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_egeaa.CountAttr)})
	}
	if _egeaa.AxisAttr != ST_AxisUnset {
		_efaff, _ceaeb := _egeaa.AxisAttr.MarshalXMLAttr(_f.Name{Local: "axis"})
		if _ceaeb != nil {
			return _ceaeb
		}
		start.Attr = append(start.Attr, _efaff)
	}
	if _egeaa.DimensionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dimension"}, Value: _bg.Sprintf("\u0025v", *_egeaa.DimensionAttr)})
	}
	if _egeaa.StartAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "start"}, Value: _bg.Sprintf("\u0025v", *_egeaa.StartAttr)})
	}
	if _egeaa.MinAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "min"}, Value: _bg.Sprintf("\u0025v", *_egeaa.MinAttr)})
	}
	if _egeaa.MaxAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "max"}, Value: _bg.Sprintf("\u0025v", *_egeaa.MaxAttr)})
	}
	if _egeaa.ActiveRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "activeRow"}, Value: _bg.Sprintf("\u0025v", *_egeaa.ActiveRowAttr)})
	}
	if _egeaa.ActiveColAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "activeCol"}, Value: _bg.Sprintf("\u0025v", *_egeaa.ActiveColAttr)})
	}
	if _egeaa.PreviousRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "previousRow"}, Value: _bg.Sprintf("\u0025v", *_egeaa.PreviousRowAttr)})
	}
	if _egeaa.PreviousColAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "previousCol"}, Value: _bg.Sprintf("\u0025v", *_egeaa.PreviousColAttr)})
	}
	if _egeaa.ClickAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "click"}, Value: _bg.Sprintf("\u0025v", *_egeaa.ClickAttr)})
	}
	if _egeaa.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", *_egeaa.IdAttr)})
	}
	e.EncodeToken(start)
	_cdefa := _f.StartElement{Name: _f.Name{Local: "ma:pivotArea"}}
	e.EncodeElement(_egeaa.PivotArea, _cdefa)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_LevelGroup and its children
func (_fdfgaf *CT_LevelGroup) Validate() error { return _fdfgaf.ValidateWithPath("CT_LevelGroup") }
func (_cfafb *CT_TextField) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bbcgc := range start.Attr {
		if _bbcgc.Name.Local == "type" {
			_cfafb.TypeAttr.UnmarshalXMLAttr(_bbcgc)
			continue
		}
		if _bbcgc.Name.Local == "position" {
			_dfccc, _ccbgc := _g.ParseUint(_bbcgc.Value, 10, 32)
			if _ccbgc != nil {
				return _ccbgc
			}
			_dagcbb := uint32(_dfccc)
			_cfafb.PositionAttr = &_dagcbb
			continue
		}
	}
	for {
		_cgccdb, _bdgg := d.Token()
		if _bdgg != nil {
			return _bg.Errorf("parsing\u0020CT_TextField:\u0020\u0025s", _bdgg)
		}
		if _abgfce, _bfefeb := _cgccdb.(_f.EndElement); _bfefeb && _abgfce.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_TextPr struct {

	// Prompt for File Name
	PromptAttr *bool

	// File Type
	FileTypeAttr ST_FileType

	// Code Page
	CodePageAttr *uint32

	// Character Set
	CharacterSetAttr *string

	// First Row
	FirstRowAttr *uint32

	// Source File Name
	SourceFileAttr *string

	// Delimited File
	DelimitedAttr *bool

	// Decimal Separator
	DecimalAttr *string

	// Thousands Separator
	ThousandsAttr *string

	// Tab as Delimiter
	TabAttr *bool

	// Space is Delimiter
	SpaceAttr *bool

	// Comma is Delimiter
	CommaAttr *bool

	// Semicolon is Delimiter
	SemicolonAttr *bool

	// Consecutive Delimiters
	ConsecutiveAttr *bool

	// Qualifier
	QualifierAttr ST_Qualifier

	// Custom Delimiter
	DelimiterAttr *string

	// Fields
	TextFields *CT_TextFields
}
type CT_ChartsheetPr struct {

	// Published
	PublishedAttr *bool

	// Code Name
	CodeNameAttr *string
	TabColor     *CT_Color
}

func (_gfcgdb *ST_WebSourceType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_adfefd, _bfcbd := d.Token()
	if _bfcbd != nil {
		return _bfcbd
	}
	if _gegdc, _ffdcda := _adfefd.(_f.EndElement); _ffdcda && _gegdc.Name == start.Name {
		*_gfcgdb = 1
		return nil
	}
	if _ddaadfg, _cffed := _adfefd.(_f.CharData); !_cffed {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _adfefd)
	} else {
		switch string(_ddaadfg) {
		case "":
			*_gfcgdb = 0
		case "sheet":
			*_gfcgdb = 1
		case "printArea":
			*_gfcgdb = 2
		case "autoFilter":
			*_gfcgdb = 3
		case "range":
			*_gfcgdb = 4
		case "chart":
			*_gfcgdb = 5
		case "pivotTable":
			*_gfcgdb = 6
		case "query":
			*_gfcgdb = 7
		case "label":
			*_gfcgdb = 8
		}
	}
	_adfefd, _bfcbd = d.Token()
	if _bfcbd != nil {
		return _bfcbd
	}
	if _fdfda, _bbagf := _adfefd.(_f.EndElement); _bbagf && _fdfda.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _adfefd)
}

// ValidateWithPath validates the CT_DdeValue and its children, prefixing error messages with path
func (_bcaa *CT_DdeValue) ValidateWithPath(path string) error {
	if _aega := _bcaa.TAttr.ValidateWithPath(path + "\u002fTAttr"); _aega != nil {
		return _aega
	}
	return nil
}

type ST_Qualifier byte

func (_dbbgee *CT_Query) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "mdx"}, Value: _bg.Sprintf("\u0025v", _dbbgee.MdxAttr)})
	e.EncodeToken(start)
	if _dbbgee.Tpls != nil {
		_ccdfc := _f.StartElement{Name: _f.Name{Local: "ma:tpls"}}
		e.EncodeElement(_dbbgee.Tpls, _ccdfc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_Chartsheet() *CT_Chartsheet {
	_gabd := &CT_Chartsheet{}
	_gabd.SheetViews = NewCT_ChartsheetViews()
	_gabd.Drawing = NewCT_Drawing()
	return _gabd
}

type CT_ProtectedRanges struct {

	// Protected Range
	ProtectedRange []*CT_ProtectedRange
}

func (_gcefaf *CT_HeaderFooter) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abfd := range start.Attr {
		if _abfd.Name.Local == "differentOddEven" {
			_eeeea, _becfed := _g.ParseBool(_abfd.Value)
			if _becfed != nil {
				return _becfed
			}
			_gcefaf.DifferentOddEvenAttr = &_eeeea
			continue
		}
		if _abfd.Name.Local == "differentFirst" {
			_adfag, _eecce := _g.ParseBool(_abfd.Value)
			if _eecce != nil {
				return _eecce
			}
			_gcefaf.DifferentFirstAttr = &_adfag
			continue
		}
		if _abfd.Name.Local == "scaleWithDoc" {
			_aafbf, _feaga := _g.ParseBool(_abfd.Value)
			if _feaga != nil {
				return _feaga
			}
			_gcefaf.ScaleWithDocAttr = &_aafbf
			continue
		}
		if _abfd.Name.Local == "alignWithMargins" {
			_daeee, _ccgde := _g.ParseBool(_abfd.Value)
			if _ccgde != nil {
				return _ccgde
			}
			_gcefaf.AlignWithMarginsAttr = &_daeee
			continue
		}
	}
_dgedb:
	for {
		_efec, _edgbea := d.Token()
		if _edgbea != nil {
			return _edgbea
		}
		switch _fdcea := _efec.(type) {
		case _f.StartElement:
			switch _fdcea.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oddHeader"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oddHeader"}:
				_gcefaf.OddHeader = new(string)
				if _cfba := d.DecodeElement(_gcefaf.OddHeader, &_fdcea); _cfba != nil {
					return _cfba
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oddFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oddFooter"}:
				_gcefaf.OddFooter = new(string)
				if _gebdc := d.DecodeElement(_gcefaf.OddFooter, &_fdcea); _gebdc != nil {
					return _gebdc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "evenHeader"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "evenHeader"}:
				_gcefaf.EvenHeader = new(string)
				if _fgbgc := d.DecodeElement(_gcefaf.EvenHeader, &_fdcea); _fgbgc != nil {
					return _fgbgc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "evenFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "evenFooter"}:
				_gcefaf.EvenFooter = new(string)
				if _bbfge := d.DecodeElement(_gcefaf.EvenFooter, &_fdcea); _bbfge != nil {
					return _bbfge
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "firstHeader"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "firstHeader"}:
				_gcefaf.FirstHeader = new(string)
				if _baagcb := d.DecodeElement(_gcefaf.FirstHeader, &_fdcea); _baagcb != nil {
					return _baagcb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "firstFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "firstFooter"}:
				_gcefaf.FirstFooter = new(string)
				if _aeca := d.DecodeElement(_gcefaf.FirstFooter, &_fdcea); _aeca != nil {
					return _aeca
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_HeaderFooter\u0020\u0025v", _fdcea.Name)
				if _bffbc := d.Skip(); _bffbc != nil {
					return _bffbc
				}
			}
		case _f.EndElement:
			break _dgedb
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ExternalBook and its children, prefixing error messages with path
func (_gaafa *CT_ExternalBook) ValidateWithPath(path string) error {
	if _gaafa.SheetNames != nil {
		if _babab := _gaafa.SheetNames.ValidateWithPath(path + "/SheetNames"); _babab != nil {
			return _babab
		}
	}
	if _gaafa.DefinedNames != nil {
		if _bbff := _gaafa.DefinedNames.ValidateWithPath(path + "\u002fDefinedNames"); _bbff != nil {
			return _bbff
		}
	}
	if _gaafa.SheetDataSet != nil {
		if _dbcbg := _gaafa.SheetDataSet.ValidateWithPath(path + "\u002fSheetDataSet"); _dbcbg != nil {
			return _dbcbg
		}
	}
	return nil
}

type CT_DiscretePr struct {

	// Mapping Index Count
	CountAttr *uint32

	// Element Group
	X []*CT_Index
}

func (_ggcdgd ST_ParameterType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_ggcdgd.String(), start)
}
func (_baac *CT_Drawing) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _baac.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_WebPublishObjects struct {

	// Count
	CountAttr *uint32

	// Web Publishing Object
	WebPublishObject []*CT_WebPublishObject
}

// Validate validates the CT_CalculatedItems and its children
func (_dbeg *CT_CalculatedItems) Validate() error {
	return _dbeg.ValidateWithPath("CT_CalculatedItems")
}
func (_gbdcc *CT_Workbook) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gbdcc.Sheets = NewCT_Sheets()
	for _, _fgege := range start.Attr {
		if _fgege.Name.Local == "conformance" {
			_gbdcc.ConformanceAttr.UnmarshalXMLAttr(_fgege)
			continue
		}
	}
_dceab:
	for {
		_fbbgd, _bddgg := d.Token()
		if _bddgg != nil {
			return _bddgg
		}
		switch _ebdcbf := _fbbgd.(type) {
		case _f.StartElement:
			switch _ebdcbf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fileVersion"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fileVersion"}:
				_gbdcc.FileVersion = NewCT_FileVersion()
				if _bfbda := d.DecodeElement(_gbdcc.FileVersion, &_ebdcbf); _bfbda != nil {
					return _bfbda
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fileSharing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fileSharing"}:
				_gbdcc.FileSharing = NewCT_FileSharing()
				if _fdeedg := d.DecodeElement(_gbdcc.FileSharing, &_ebdcbf); _fdeedg != nil {
					return _fdeedg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "workbookPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "workbookPr"}:
				_gbdcc.WorkbookPr = NewCT_WorkbookPr()
				if _gcbebb := d.DecodeElement(_gbdcc.WorkbookPr, &_ebdcbf); _gcbebb != nil {
					return _gcbebb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "workbookProtection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "workbookProtection"}:
				_gbdcc.WorkbookProtection = NewCT_WorkbookProtection()
				if _bgbde := d.DecodeElement(_gbdcc.WorkbookProtection, &_ebdcbf); _bgbde != nil {
					return _bgbde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "bookViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "bookViews"}:
				_gbdcc.BookViews = NewCT_BookViews()
				if _deacac := d.DecodeElement(_gbdcc.BookViews, &_ebdcbf); _deacac != nil {
					return _deacac
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheets"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheets"}:
				if _agbce := d.DecodeElement(_gbdcc.Sheets, &_ebdcbf); _agbce != nil {
					return _agbce
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "functionGroups"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "functionGroups"}:
				_gbdcc.FunctionGroups = NewCT_FunctionGroups()
				if _egefb := d.DecodeElement(_gbdcc.FunctionGroups, &_ebdcbf); _egefb != nil {
					return _egefb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "externalReferences"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "externalReferences"}:
				_gbdcc.ExternalReferences = NewCT_ExternalReferences()
				if _ecaeg := d.DecodeElement(_gbdcc.ExternalReferences, &_ebdcbf); _ecaeg != nil {
					return _ecaeg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "definedNames"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "definedNames"}:
				_gbdcc.DefinedNames = NewCT_DefinedNames()
				if _debec := d.DecodeElement(_gbdcc.DefinedNames, &_ebdcbf); _debec != nil {
					return _debec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "calcPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "calcPr"}:
				_gbdcc.CalcPr = NewCT_CalcPr()
				if _dbeed := d.DecodeElement(_gbdcc.CalcPr, &_ebdcbf); _dbeed != nil {
					return _dbeed
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleSize"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleSize"}:
				_gbdcc.OleSize = NewCT_OleSize()
				if _bfddd := d.DecodeElement(_gbdcc.OleSize, &_ebdcbf); _bfddd != nil {
					return _bfddd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customWorkbookViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customWorkbookViews"}:
				_gbdcc.CustomWorkbookViews = NewCT_CustomWorkbookViews()
				if _eeecaf := d.DecodeElement(_gbdcc.CustomWorkbookViews, &_ebdcbf); _eeecaf != nil {
					return _eeecaf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotCaches"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotCaches"}:
				_gbdcc.PivotCaches = NewCT_PivotCaches()
				if _agdeg := d.DecodeElement(_gbdcc.PivotCaches, &_ebdcbf); _agdeg != nil {
					return _agdeg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "smartTagPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "smartTagPr"}:
				_gbdcc.SmartTagPr = NewCT_SmartTagPr()
				if _aecab := d.DecodeElement(_gbdcc.SmartTagPr, &_ebdcbf); _aecab != nil {
					return _aecab
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "smartTagTypes"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "smartTagTypes"}:
				_gbdcc.SmartTagTypes = NewCT_SmartTagTypes()
				if _cdgeb := d.DecodeElement(_gbdcc.SmartTagTypes, &_ebdcbf); _cdgeb != nil {
					return _cdgeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "webPublishing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "webPublishing"}:
				_gbdcc.WebPublishing = NewCT_WebPublishing()
				if _ebgde := d.DecodeElement(_gbdcc.WebPublishing, &_ebdcbf); _ebgde != nil {
					return _ebgde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fileRecoveryPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fileRecoveryPr"}:
				_ebcee := NewCT_FileRecoveryPr()
				if _abeca := d.DecodeElement(_ebcee, &_ebdcbf); _abeca != nil {
					return _abeca
				}
				_gbdcc.FileRecoveryPr = append(_gbdcc.FileRecoveryPr, _ebcee)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "webPublishObjects"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "webPublishObjects"}:
				_gbdcc.WebPublishObjects = NewCT_WebPublishObjects()
				if _dabcb := d.DecodeElement(_gbdcc.WebPublishObjects, &_ebdcbf); _dabcb != nil {
					return _dabcb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gbdcc.ExtLst = NewCT_ExtensionList()
				if _aaebg := d.DecodeElement(_gbdcc.ExtLst, &_ebdcbf); _aaebg != nil {
					return _aaebg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Workbook\u0020\u0025v", _ebdcbf.Name)
				if _bgafba := d.Skip(); _bgafba != nil {
					return _bgafba
				}
			}
		case _f.EndElement:
			break _dceab
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PivotCaches and its children, prefixing error messages with path
func (_ebbefd *CT_PivotCaches) ValidateWithPath(path string) error {
	for _dbege, _faaaf := range _ebbefd.PivotCache {
		if _bcdbe := _faaaf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fPivotCache\u005b\u0025d\u005d", path, _dbege)); _bcdbe != nil {
			return _bcdbe
		}
	}
	return nil
}
func (_cfgbe *Headers) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:headers"
	return _cfgbe.CT_RevisionHeaders.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_DataValidation and its children, prefixing error messages with path
func (_ecbb *CT_DataValidation) ValidateWithPath(path string) error {
	if _aagc := _ecbb.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _aagc != nil {
		return _aagc
	}
	if _cadfc := _ecbb.ErrorStyleAttr.ValidateWithPath(path + "\u002fErrorStyleAttr"); _cadfc != nil {
		return _cadfc
	}
	if _cadc := _ecbb.ImeModeAttr.ValidateWithPath(path + "\u002fImeModeAttr"); _cadc != nil {
		return _cadc
	}
	if _dbgg := _ecbb.OperatorAttr.ValidateWithPath(path + "\u002fOperatorAttr"); _dbgg != nil {
		return _dbgg
	}
	return nil
}
func (_dbfb *CT_Rst) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_agfac:
	for {
		_ccfba, _edfgcc := d.Token()
		if _edfgcc != nil {
			return _edfgcc
		}
		switch _dcbbg := _ccfba.(type) {
		case _f.StartElement:
			switch _dcbbg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "t"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "t"}:
				_dbfb.T = new(string)
				if _afabge := d.DecodeElement(_dbfb.T, &_dcbbg); _afabge != nil {
					return _afabge
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "r"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "r"}:
				_ggdgcb := NewCT_RElt()
				if _aebab := d.DecodeElement(_ggdgcb, &_dcbbg); _aebab != nil {
					return _aebab
				}
				_dbfb.R = append(_dbfb.R, _ggdgcb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rPh"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rPh"}:
				_fccga := NewCT_PhoneticRun()
				if _cdcgag := d.DecodeElement(_fccga, &_dcbbg); _cdcgag != nil {
					return _cdcgag
				}
				_dbfb.RPh = append(_dbfb.RPh, _fccga)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "phoneticPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "phoneticPr"}:
				_dbfb.PhoneticPr = NewCT_PhoneticPr()
				if _cdegg := d.DecodeElement(_dbfb.PhoneticPr, &_dcbbg); _cdegg != nil {
					return _cdegg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Rst\u0020\u0025v", _dcbbg.Name)
				if _badbf := d.Skip(); _badbf != nil {
					return _badbf
				}
			}
		case _f.EndElement:
			break _agfac
		case _f.CharData:
		}
	}
	return nil
}
func (_fbbd *CT_CellStyleXfs) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gbec := range start.Attr {
		if _gbec.Name.Local == "count" {
			_gede, _dcbe := _g.ParseUint(_gbec.Value, 10, 32)
			if _dcbe != nil {
				return _dcbe
			}
			_eabc := uint32(_gede)
			_fbbd.CountAttr = &_eabc
			continue
		}
	}
_acbd:
	for {
		_ccec, _gddd := d.Token()
		if _gddd != nil {
			return _gddd
		}
		switch _dgeag := _ccec.(type) {
		case _f.StartElement:
			switch _dgeag.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "xf"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "xf"}:
				_gcbb := NewCT_Xf()
				if _bbgc := d.DecodeElement(_gcbb, &_dgeag); _bbgc != nil {
					return _bbgc
				}
				_fbbd.Xf = append(_fbbd.Xf, _gcbb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CellStyleXfs\u0020\u0025v", _dgeag.Name)
				if _dcbd := d.Skip(); _dcbd != nil {
					return _dcbd
				}
			}
		case _f.EndElement:
			break _acbd
		case _f.CharData:
		}
	}
	return nil
}
func (_bgbbc *CT_Metadata) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_fdcdd:
	for {
		_gfceg, _bcadf := d.Token()
		if _bcadf != nil {
			return _bcadf
		}
		switch _daded := _gfceg.(type) {
		case _f.StartElement:
			switch _daded.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "metadataTypes"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "metadataTypes"}:
				_bgbbc.MetadataTypes = NewCT_MetadataTypes()
				if _bggdbf := d.DecodeElement(_bgbbc.MetadataTypes, &_daded); _bggdbf != nil {
					return _bggdbf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "metadataStrings"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "metadataStrings"}:
				_bgbbc.MetadataStrings = NewCT_MetadataStrings()
				if _bacgee := d.DecodeElement(_bgbbc.MetadataStrings, &_daded); _bacgee != nil {
					return _bacgee
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "mdxMetadata"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "mdxMetadata"}:
				_bgbbc.MdxMetadata = NewCT_MdxMetadata()
				if _dfbfb := d.DecodeElement(_bgbbc.MdxMetadata, &_daded); _dfbfb != nil {
					return _dfbfb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "futureMetadata"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "futureMetadata"}:
				_cggba := NewCT_FutureMetadata()
				if _gcgadd := d.DecodeElement(_cggba, &_daded); _gcgadd != nil {
					return _gcgadd
				}
				_bgbbc.FutureMetadata = append(_bgbbc.FutureMetadata, _cggba)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellMetadata"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellMetadata"}:
				_bgbbc.CellMetadata = NewCT_MetadataBlocks()
				if _edad := d.DecodeElement(_bgbbc.CellMetadata, &_daded); _edad != nil {
					return _edad
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "valueMetadata"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "valueMetadata"}:
				_bgbbc.ValueMetadata = NewCT_MetadataBlocks()
				if _dgbddd := d.DecodeElement(_bgbbc.ValueMetadata, &_daded); _dgbddd != nil {
					return _dgbddd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bgbbc.ExtLst = NewCT_ExtensionList()
				if _ccfga := d.DecodeElement(_bgbbc.ExtLst, &_daded); _ccfga != nil {
					return _ccfga
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Metadata\u0020\u0025v", _daded.Name)
				if _gdggfb := d.Skip(); _gdggfb != nil {
					return _gdggfb
				}
			}
		case _f.EndElement:
			break _fdcdd
		case _f.CharData:
		}
	}
	return nil
}
func (_fcecc *CT_SheetIdMap) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _feacgb := range start.Attr {
		if _feacgb.Name.Local == "count" {
			_ddebaa, _eaead := _g.ParseUint(_feacgb.Value, 10, 32)
			if _eaead != nil {
				return _eaead
			}
			_cbedeb := uint32(_ddebaa)
			_fcecc.CountAttr = &_cbedeb
			continue
		}
	}
_bedfe:
	for {
		_bdfgd, _gegge := d.Token()
		if _gegge != nil {
			return _gegge
		}
		switch _agaea := _bdfgd.(type) {
		case _f.StartElement:
			switch _agaea.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetId"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetId"}:
				_ecced := NewCT_SheetId()
				if _egacb := d.DecodeElement(_ecced, &_agaea); _egacb != nil {
					return _egacb
				}
				_fcecc.SheetId = append(_fcecc.SheetId, _ecced)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_SheetIdMap \u0025v", _agaea.Name)
				if _afbgf := d.Skip(); _afbgf != nil {
					return _afbgf
				}
			}
		case _f.EndElement:
			break _bedfe
		case _f.CharData:
		}
	}
	return nil
}

type CT_Color struct {

	// Automatic
	AutoAttr *bool

	// Index
	IndexedAttr *uint32

	// Alpha Red Green Blue Color Value
	RgbAttr *string

	// Theme Color
	ThemeAttr *uint32

	// Tint
	TintAttr *float64
}

func (_gaagaf ST_WebSourceType) ValidateWithPath(path string) error {
	switch _gaagaf {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gaagaf))
	}
	return nil
}
func (_fgcebdg ST_SourceType) String() string {
	switch _fgcebdg {
	case 0:
		return ""
	case 1:
		return "worksheet"
	case 2:
		return "external"
	case 3:
		return "consolidation"
	case 4:
		return "scenario"
	}
	return ""
}

// ValidateWithPath validates the CT_VolMain and its children, prefixing error messages with path
func (_bbfcb *CT_VolMain) ValidateWithPath(path string) error {
	for _dbggd, _cgeafe := range _bbfcb.Tp {
		if _fadbed := _cgeafe.ValidateWithPath(_bg.Sprintf("\u0025s\u002fTp\u005b\u0025d]", path, _dbggd)); _fadbed != nil {
			return _fadbed
		}
	}
	return nil
}

// Validate validates the CT_CustomFilter and its children
func (_fgfg *CT_CustomFilter) Validate() error { return _fgfg.ValidateWithPath("CT_CustomFilter") }

// Validate validates the CT_Hyperlinks and its children
func (_abddg *CT_Hyperlinks) Validate() error { return _abddg.ValidateWithPath("CT_Hyperlinks") }

type CT_Pane struct {

	// Horizontal Split Position
	XSplitAttr *float64

	// Vertical Split Position
	YSplitAttr *float64

	// Top Left Visible Cell
	TopLeftCellAttr *string

	// Active Pane
	ActivePaneAttr ST_Pane

	// Split State
	StateAttr ST_PaneState
}

func (_ddcfbb *ST_SheetViewType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_ddcfbb = 0
	case "normal":
		*_ddcfbb = 1
	case "pageBreakPreview":
		*_ddcfbb = 2
	case "pageLayout":
		*_ddcfbb = 3
	}
	return nil
}

// ValidateWithPath validates the CT_GradientStop and its children, prefixing error messages with path
func (_cdggf *CT_GradientStop) ValidateWithPath(path string) error {
	if _gbgeac := _cdggf.Color.ValidateWithPath(path + "\u002fColor"); _gbgeac != nil {
		return _gbgeac
	}
	return nil
}

type CT_TableColumns struct {

	// Column Count
	CountAttr *uint32

	// Table Column
	TableColumn []*CT_TableColumn
}

func (_cfffe *CT_PageFields) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _eefdcd := range start.Attr {
		if _eefdcd.Name.Local == "count" {
			_dgfbc, _afgbfd := _g.ParseUint(_eefdcd.Value, 10, 32)
			if _afgbfd != nil {
				return _afgbfd
			}
			_eaef := uint32(_dgfbc)
			_cfffe.CountAttr = &_eaef
			continue
		}
	}
_ggfe:
	for {
		_aaddca, _becfd := d.Token()
		if _becfd != nil {
			return _becfd
		}
		switch _deffc := _aaddca.(type) {
		case _f.StartElement:
			switch _deffc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageField"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageField"}:
				_bcace := NewCT_PageField()
				if _dbgf := d.DecodeElement(_bcace, &_deffc); _dbgf != nil {
					return _dbgf
				}
				_cfffe.PageField = append(_cfffe.PageField, _bcace)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_PageFields \u0025v", _deffc.Name)
				if _bcea := d.Skip(); _bcea != nil {
					return _bcea
				}
			}
		case _f.EndElement:
			break _ggfe
		case _f.CharData:
		}
	}
	return nil
}
func (_dfefb *CT_FileRecoveryPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gdfdf := range start.Attr {
		if _gdfdf.Name.Local == "autoRecover" {
			_bfafg, _bcbcd := _g.ParseBool(_gdfdf.Value)
			if _bcbcd != nil {
				return _bcbcd
			}
			_dfefb.AutoRecoverAttr = &_bfafg
			continue
		}
		if _gdfdf.Name.Local == "crashSave" {
			_baded, _gcgddb := _g.ParseBool(_gdfdf.Value)
			if _gcgddb != nil {
				return _gcgddb
			}
			_dfefb.CrashSaveAttr = &_baded
			continue
		}
		if _gdfdf.Name.Local == "dataExtractLoad" {
			_gabfd, _fagee := _g.ParseBool(_gdfdf.Value)
			if _fagee != nil {
				return _fagee
			}
			_dfefb.DataExtractLoadAttr = &_gabfd
			continue
		}
		if _gdfdf.Name.Local == "repairLoad" {
			_cafga, _cbbde := _g.ParseBool(_gdfdf.Value)
			if _cbbde != nil {
				return _cbbde
			}
			_dfefb.RepairLoadAttr = &_cafga
			continue
		}
	}
	for {
		_bdabb, _cfddb := d.Token()
		if _cfddb != nil {
			return _bg.Errorf("parsing\u0020CT_FileRecoveryPr: \u0025s", _cfddb)
		}
		if _ebaff, _edfgg := _bdabb.(_f.EndElement); _edfgg && _ebaff.Name == start.Name {
			break
		}
	}
	return nil
}
func (_daafg *CT_X) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _daafg.VAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "v"}, Value: _bg.Sprintf("\u0025v", *_daafg.VAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Missing and its children, prefixing error messages with path
func (_dbcfa *CT_Missing) ValidateWithPath(path string) error {
	for _fbbce, _ggdeb := range _dbcfa.Tpls {
		if _fedaa := _ggdeb.ValidateWithPath(_bg.Sprintf("%s\u002fTpls\u005b\u0025d\u005d", path, _fbbce)); _fedaa != nil {
			return _fedaa
		}
	}
	for _bdded, _acagc := range _dbcfa.X {
		if _feeedg := _acagc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fX\u005b\u0025d\u005d", path, _bdded)); _feeedg != nil {
			return _feeedg
		}
	}
	return nil
}

// Validate validates the CT_QueryTableDeletedFields and its children
func (_becaa *CT_QueryTableDeletedFields) Validate() error {
	return _becaa.ValidateWithPath("CT_QueryTableDeletedFields")
}

// Validate validates the CT_RElt and its children
func (_bfcd *CT_RElt) Validate() error { return _bfcd.ValidateWithPath("CT_RElt") }

type CT_RangeSet struct {

	// Field Item Index Page 1
	I1Attr *uint32

	// Field Item Index Page 2
	I2Attr *uint32

	// Field Item index Page 3
	I3Attr *uint32

	// Field Item Index Page 4
	I4Attr *uint32

	// Reference
	RefAttr *string

	// Named Range
	NameAttr *string

	// Sheet Name
	SheetAttr *string
	IdAttr    *string
}

// ValidateWithPath validates the CT_PCDKPIs and its children, prefixing error messages with path
func (_gdccb *CT_PCDKPIs) ValidateWithPath(path string) error {
	for _bdaaf, _ffbca := range _gdccb.Kpi {
		if _dcafe := _ffbca.ValidateWithPath(_bg.Sprintf("\u0025s\u002fKpi\u005b\u0025d\u005d", path, _bdaaf)); _dcafe != nil {
			return _dcafe
		}
	}
	return nil
}
func (_ddfeg *CT_PageSetUpPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bbcab := range start.Attr {
		if _bbcab.Name.Local == "autoPageBreaks" {
			_aeafg, _dgbbc := _g.ParseBool(_bbcab.Value)
			if _dgbbc != nil {
				return _dgbbc
			}
			_ddfeg.AutoPageBreaksAttr = &_aeafg
			continue
		}
		if _bbcab.Name.Local == "fitToPage" {
			_gbgdb, _ebbdd := _g.ParseBool(_bbcab.Value)
			if _ebbdd != nil {
				return _ebbdd
			}
			_ddfeg.FitToPageAttr = &_gbgdb
			continue
		}
	}
	for {
		_cegd, _gdffb := d.Token()
		if _gdffb != nil {
			return _bg.Errorf("parsing\u0020CT_PageSetUpPr:\u0020\u0025s", _gdffb)
		}
		if _gcdfgd, _caaeb := _cegd.(_f.EndElement); _caaeb && _gcdfgd.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Fill() *CT_Fill                      { _aeegf := &CT_Fill{}; return _aeegf }
func (_aafabd ST_CellComments) Validate() error { return _aafabd.ValidateWithPath("") }

// Validate validates the CT_colItems and its children
func (_agebf *CT_colItems) Validate() error  { return _agebf.ValidateWithPath("CT_colItems") }
func NewCT_CellAlignment() *CT_CellAlignment { _bdcc := &CT_CellAlignment{}; return _bdcc }

type CT_Users struct {

	// Active User Count
	CountAttr *uint32

	// User Information
	UserInfo []*CT_SharedUser
}

func (_adcbd *ST_UnderlineValues) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bbcgcd, _aagba := d.Token()
	if _aagba != nil {
		return _aagba
	}
	if _gfeab, _egbbfg := _bbcgcd.(_f.EndElement); _egbbfg && _gfeab.Name == start.Name {
		*_adcbd = 1
		return nil
	}
	if _dggeag, _daafa := _bbcgcd.(_f.CharData); !_daafa {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bbcgcd)
	} else {
		switch string(_dggeag) {
		case "":
			*_adcbd = 0
		case "single":
			*_adcbd = 1
		case "double":
			*_adcbd = 2
		case "singleAccounting":
			*_adcbd = 3
		case "doubleAccounting":
			*_adcbd = 4
		case "none":
			*_adcbd = 5
		}
	}
	_bbcgcd, _aagba = d.Token()
	if _aagba != nil {
		return _aagba
	}
	if _efgga, _gfbcdf := _bbcgcd.(_f.EndElement); _gfbcdf && _efgga.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bbcgcd)
}
func (_aeabc *CT_DynamicFilter) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	_eegbb, _gecbd := _aeabc.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
	if _gecbd != nil {
		return _gecbd
	}
	start.Attr = append(start.Attr, _eegbb)
	if _aeabc.ValAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", *_aeabc.ValAttr)})
	}
	if _aeabc.ValIsoAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "valIso"}, Value: _bg.Sprintf("\u0025v", *_aeabc.ValIsoAttr)})
	}
	if _aeabc.MaxValAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "maxVal"}, Value: _bg.Sprintf("\u0025v", *_aeabc.MaxValAttr)})
	}
	if _aeabc.MaxValIsoAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "maxValIso"}, Value: _bg.Sprintf("\u0025v", *_aeabc.MaxValIsoAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Chartsheet and its children, prefixing error messages with path
func (_ecaaea *Chartsheet) ValidateWithPath(path string) error {
	if _bdgef := _ecaaea.CT_Chartsheet.ValidateWithPath(path); _bdgef != nil {
		return _bdgef
	}
	return nil
}

// Validate validates the CT_CacheSource and its children
func (_agcc *CT_CacheSource) Validate() error { return _agcc.ValidateWithPath("CT_CacheSource") }
func (_cfggd ST_VerticalAlignment) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_eaaee := _f.Attr{}
	_eaaee.Name = name
	switch _cfggd {
	case ST_VerticalAlignmentUnset:
		_eaaee.Value = ""
	case ST_VerticalAlignmentTop:
		_eaaee.Value = "top"
	case ST_VerticalAlignmentCenter:
		_eaaee.Value = "center"
	case ST_VerticalAlignmentBottom:
		_eaaee.Value = "bottom"
	case ST_VerticalAlignmentJustify:
		_eaaee.Value = "justify"
	case ST_VerticalAlignmentDistributed:
		_eaaee.Value = "distributed"
	}
	return _eaaee, nil
}
func (_fgedd *CT_MdxMemeberProp) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "n"}, Value: _bg.Sprintf("\u0025v", _fgedd.NAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "np"}, Value: _bg.Sprintf("\u0025v", _fgedd.NpAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_SingleXmlCell() *CT_SingleXmlCell {
	_aeffaa := &CT_SingleXmlCell{}
	_aeffaa.XmlCellPr = NewCT_XmlCellPr()
	return _aeffaa
}
func NewStyleSheet() *StyleSheet {
	_fafcf := &StyleSheet{}
	_fafcf.CT_Stylesheet = *NewCT_Stylesheet()
	return _fafcf
}
func (_egeaf *CT_CustomFilters) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _egeaf.AndAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "and"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_egeaf.AndAttr))})
	}
	e.EncodeToken(start)
	_ccdgde := _f.StartElement{Name: _f.Name{Local: "ma:customFilter"}}
	for _, _eafe := range _egeaf.CustomFilter {
		e.EncodeElement(_eafe, _ccdgde)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_ExternalRow() *CT_ExternalRow { _agdfe := &CT_ExternalRow{}; return _agdfe }

type CT_IgnoredErrors struct {

	// Ignored Error
	IgnoredError []*CT_IgnoredError
	ExtLst       *CT_ExtensionList
}

// Validate validates the CT_SheetBackgroundPicture and its children
func (_aeeac *CT_SheetBackgroundPicture) Validate() error {
	return _aeeac.ValidateWithPath("CT_SheetBackgroundPicture")
}
func (_cfgfe *CT_CustomProperty) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _eddg := range start.Attr {
		if _eddg.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _eddg.Name.Local == "id" || _eddg.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _eddg.Name.Local == "id" {
			_dfbf, _eadg := _eddg.Value, error(nil)
			if _eadg != nil {
				return _eadg
			}
			_cfgfe.IdAttr = _dfbf
			continue
		}
		if _eddg.Name.Local == "name" {
			_gagaa, _dgda := _eddg.Value, error(nil)
			if _dgda != nil {
				return _dgda
			}
			_cfgfe.NameAttr = _gagaa
			continue
		}
	}
	for {
		_fegde, _bgfeb := d.Token()
		if _bgfeb != nil {
			return _bg.Errorf("parsing\u0020CT_CustomProperty: \u0025s", _bgfeb)
		}
		if _ddcb, _cadea := _fegde.(_f.EndElement); _cadea && _ddcb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ebbddd ST_TableType) String() string {
	switch _ebbddd {
	case 0:
		return ""
	case 1:
		return "worksheet"
	case 2:
		return "xml"
	case 3:
		return "queryTable"
	}
	return ""
}
func (_gadff *MapInfo) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gadff.CT_MapInfo = *NewCT_MapInfo()
	for _, _gaaaac := range start.Attr {
		if _gaaaac.Name.Local == "SelectionNamespaces" {
			_gacba, _gdafe := _gaaaac.Value, error(nil)
			if _gdafe != nil {
				return _gdafe
			}
			_gadff.SelectionNamespacesAttr = _gacba
			continue
		}
	}
_ffffb:
	for {
		_becee, _fdcbfe := d.Token()
		if _fdcbfe != nil {
			return _fdcbfe
		}
		switch _dbbfd := _becee.(type) {
		case _f.StartElement:
			switch _dbbfd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "Schema"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "Schema"}:
				_aacedg := NewCT_Schema()
				if _abfgb := d.DecodeElement(_aacedg, &_dbbfd); _abfgb != nil {
					return _abfgb
				}
				_gadff.Schema = append(_gadff.Schema, _aacedg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "Map"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "Map"}:
				_fcagf := NewCT_Map()
				if _edfcd := d.DecodeElement(_fcagf, &_dbbfd); _edfcd != nil {
					return _edfcd
				}
				_gadff.Map = append(_gadff.Map, _fcagf)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020MapInfo\u0020\u0025v", _dbbfd.Name)
				if _bbeac := d.Skip(); _bbeac != nil {
					return _bbeac
				}
			}
		case _f.EndElement:
			break _ffffb
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_Controls() *CT_Controls { _cabd := &CT_Controls{}; return _cabd }

// Validate validates the CT_Location and its children
func (_bfdcf *CT_Location) Validate() error { return _bfdcf.ValidateWithPath("CT_Location") }
func (_fddcbd ST_ConditionalFormattingOperator) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_fddcbd.String(), start)
}

type CT_CellSmartTags struct {

	// Reference
	RAttr string

	// Cell Smart Tag
	CellSmartTag []*CT_CellSmartTag
}

// ValidateWithPath validates the CT_CalculatedItem and its children, prefixing error messages with path
func (_egbe *CT_CalculatedItem) ValidateWithPath(path string) error {
	if _dbaea := _egbe.PivotArea.ValidateWithPath(path + "\u002fPivotArea"); _dbaea != nil {
		return _dbaea
	}
	if _egbe.ExtLst != nil {
		if _cea := _egbe.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cea != nil {
			return _cea
		}
	}
	return nil
}
func (_dfea *CT_DbPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "connection"}, Value: _bg.Sprintf("\u0025v", _dfea.ConnectionAttr)})
	if _dfea.CommandAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "command"}, Value: _bg.Sprintf("\u0025v", *_dfea.CommandAttr)})
	}
	if _dfea.ServerCommandAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "serverCommand"}, Value: _bg.Sprintf("\u0025v", *_dfea.ServerCommandAttr)})
	}
	if _dfea.CommandTypeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "commandType"}, Value: _bg.Sprintf("\u0025v", *_dfea.CommandTypeAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_Map() *CT_Map { _fccfd := &CT_Map{}; return _fccfd }
func (_acdbdf *ST_DataValidationType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_geadef, _aaage := d.Token()
	if _aaage != nil {
		return _aaage
	}
	if _bedaa, _ddgda := _geadef.(_f.EndElement); _ddgda && _bedaa.Name == start.Name {
		*_acdbdf = 1
		return nil
	}
	if _gffef, _cbaac := _geadef.(_f.CharData); !_cbaac {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _geadef)
	} else {
		switch string(_gffef) {
		case "":
			*_acdbdf = 0
		case "none":
			*_acdbdf = 1
		case "whole":
			*_acdbdf = 2
		case "decimal":
			*_acdbdf = 3
		case "list":
			*_acdbdf = 4
		case "date":
			*_acdbdf = 5
		case "time":
			*_acdbdf = 6
		case "textLength":
			*_acdbdf = 7
		case "custom":
			*_acdbdf = 8
		}
	}
	_geadef, _aaage = d.Token()
	if _aaage != nil {
		return _aaage
	}
	if _dbfegb, _fbecd := _geadef.(_f.EndElement); _fbecd && _dbfegb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _geadef)
}
func (_gccdaa *Comments) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gccdaa.CT_Comments = *NewCT_Comments()
_edfcb:
	for {
		_efdfdd, _efefg := d.Token()
		if _efefg != nil {
			return _efefg
		}
		switch _ccfbe := _efdfdd.(type) {
		case _f.StartElement:
			switch _ccfbe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "authors"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "authors"}:
				if _ggacf := d.DecodeElement(_gccdaa.Authors, &_ccfbe); _ggacf != nil {
					return _ggacf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "commentList"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "commentList"}:
				if _bddged := d.DecodeElement(_gccdaa.CommentList, &_ccfbe); _bddged != nil {
					return _bddged
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gccdaa.ExtLst = NewCT_ExtensionList()
				if _fbefb := d.DecodeElement(_gccdaa.ExtLst, &_ccfbe); _fbefb != nil {
					return _fbefb
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Comments\u0020\u0025v", _ccfbe.Name)
				if _fcbfa := d.Skip(); _fcbfa != nil {
					return _fcbfa
				}
			}
		case _f.EndElement:
			break _edfcb
		case _f.CharData:
		}
	}
	return nil
}

const (
	ST_PageOrderUnset        ST_PageOrder = 0
	ST_PageOrderDownThenOver ST_PageOrder = 1
	ST_PageOrderOverThenDown ST_PageOrder = 2
)

// Validate validates the CT_CellStyleXfs and its children
func (_gef *CT_CellStyleXfs) Validate() error { return _gef.ValidateWithPath("CT_CellStyleXfs") }
func (_bafga *CT_Query) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bdcba := range start.Attr {
		if _bdcba.Name.Local == "mdx" {
			_dggff, _dagbde := _bdcba.Value, error(nil)
			if _dagbde != nil {
				return _dagbde
			}
			_bafga.MdxAttr = _dggff
			continue
		}
	}
_gcagb:
	for {
		_gcaga, _eaeefb := d.Token()
		if _eaeefb != nil {
			return _eaeefb
		}
		switch _dffgg := _gcaga.(type) {
		case _f.StartElement:
			switch _dffgg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tpls"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tpls"}:
				_bafga.Tpls = NewCT_Tuples()
				if _gcabba := d.DecodeElement(_bafga.Tpls, &_dffgg); _gcabba != nil {
					return _gcabba
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Query\u0020\u0025v", _dffgg.Name)
				if _gbbf := d.Skip(); _gbbf != nil {
					return _gbbf
				}
			}
		case _f.EndElement:
			break _gcagb
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_Query() *CT_Query { _fedb := &CT_Query{}; return _fedb }
func (_defde *CT_PivotCacheDefinition) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_defde.CacheSource = NewCT_CacheSource()
	_defde.CacheFields = NewCT_CacheFields()
	for _, _agcfb := range start.Attr {
		if _agcfb.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _agcfb.Name.Local == "id" || _agcfb.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _agcfb.Name.Local == "id" {
			_bbaeb, _cbbaf := _agcfb.Value, error(nil)
			if _cbbaf != nil {
				return _cbbaf
			}
			_defde.IdAttr = &_bbaeb
			continue
		}
		if _agcfb.Name.Local == "upgradeOnRefresh" {
			_bdgbe, _acdbe := _g.ParseBool(_agcfb.Value)
			if _acdbe != nil {
				return _acdbe
			}
			_defde.UpgradeOnRefreshAttr = &_bdgbe
			continue
		}
		if _agcfb.Name.Local == "tupleCache" {
			_gbfbg, _egfad := _g.ParseBool(_agcfb.Value)
			if _egfad != nil {
				return _egfad
			}
			_defde.TupleCacheAttr = &_gbfbg
			continue
		}
		if _agcfb.Name.Local == "saveData" {
			_gadbe, _gfdgf := _g.ParseBool(_agcfb.Value)
			if _gfdgf != nil {
				return _gfdgf
			}
			_defde.SaveDataAttr = &_gadbe
			continue
		}
		if _agcfb.Name.Local == "supportSubquery" {
			_ffded, _cabdd := _g.ParseBool(_agcfb.Value)
			if _cabdd != nil {
				return _cabdd
			}
			_defde.SupportSubqueryAttr = &_ffded
			continue
		}
		if _agcfb.Name.Local == "optimizeMemory" {
			_dfdda, _dgecg := _g.ParseBool(_agcfb.Value)
			if _dgecg != nil {
				return _dgecg
			}
			_defde.OptimizeMemoryAttr = &_dfdda
			continue
		}
		if _agcfb.Name.Local == "supportAdvancedDrill" {
			_aaeeb, _ecbdb := _g.ParseBool(_agcfb.Value)
			if _ecbdb != nil {
				return _ecbdb
			}
			_defde.SupportAdvancedDrillAttr = &_aaeeb
			continue
		}
		if _agcfb.Name.Local == "refreshedBy" {
			_fefdc, _aacdac := _agcfb.Value, error(nil)
			if _aacdac != nil {
				return _aacdac
			}
			_defde.RefreshedByAttr = &_fefdc
			continue
		}
		if _agcfb.Name.Local == "refreshedDateIso" {
			_bacdf, _ddegad := ParseStdlibTime(_agcfb.Value)
			if _ddegad != nil {
				return _ddegad
			}
			_defde.RefreshedDateIsoAttr = &_bacdf
			continue
		}
		if _agcfb.Name.Local == "invalid" {
			_dgdff, _caggc := _g.ParseBool(_agcfb.Value)
			if _caggc != nil {
				return _caggc
			}
			_defde.InvalidAttr = &_dgdff
			continue
		}
		if _agcfb.Name.Local == "backgroundQuery" {
			_fcddc, _dcdfb := _g.ParseBool(_agcfb.Value)
			if _dcdfb != nil {
				return _dcdfb
			}
			_defde.BackgroundQueryAttr = &_fcddc
			continue
		}
		if _agcfb.Name.Local == "missingItemsLimit" {
			_befggc, _efgfc := _g.ParseUint(_agcfb.Value, 10, 32)
			if _efgfc != nil {
				return _efgfc
			}
			_ccdfd := uint32(_befggc)
			_defde.MissingItemsLimitAttr = &_ccdfd
			continue
		}
		if _agcfb.Name.Local == "refreshedVersion" {
			_egdff, _cdcce := _g.ParseUint(_agcfb.Value, 10, 8)
			if _cdcce != nil {
				return _cdcce
			}
			_dbdba := uint8(_egdff)
			_defde.RefreshedVersionAttr = &_dbdba
			continue
		}
		if _agcfb.Name.Local == "refreshOnLoad" {
			_cfdbd, _gacbfa := _g.ParseBool(_agcfb.Value)
			if _gacbfa != nil {
				return _gacbfa
			}
			_defde.RefreshOnLoadAttr = &_cfdbd
			continue
		}
		if _agcfb.Name.Local == "refreshedDate" {
			_fcaabd, _befga := _g.ParseFloat(_agcfb.Value, 64)
			if _befga != nil {
				return _befga
			}
			_defde.RefreshedDateAttr = &_fcaabd
			continue
		}
		if _agcfb.Name.Local == "recordCount" {
			_cgeef, _gggge := _g.ParseUint(_agcfb.Value, 10, 32)
			if _gggge != nil {
				return _gggge
			}
			_dbeba := uint32(_cgeef)
			_defde.RecordCountAttr = &_dbeba
			continue
		}
		if _agcfb.Name.Local == "createdVersion" {
			_gfefd, _bcccb := _g.ParseUint(_agcfb.Value, 10, 8)
			if _bcccb != nil {
				return _bcccb
			}
			_dcbbc := uint8(_gfefd)
			_defde.CreatedVersionAttr = &_dcbbc
			continue
		}
		if _agcfb.Name.Local == "minRefreshableVersion" {
			_eeegge, _cdagf := _g.ParseUint(_agcfb.Value, 10, 8)
			if _cdagf != nil {
				return _cdagf
			}
			_ceabb := uint8(_eeegge)
			_defde.MinRefreshableVersionAttr = &_ceabb
			continue
		}
		if _agcfb.Name.Local == "enableRefresh" {
			_bccbgc, _babeg := _g.ParseBool(_agcfb.Value)
			if _babeg != nil {
				return _babeg
			}
			_defde.EnableRefreshAttr = &_bccbgc
			continue
		}
	}
_cbbb:
	for {
		_bagdgc, _bbacf := d.Token()
		if _bbacf != nil {
			return _bbacf
		}
		switch _ffbba := _bagdgc.(type) {
		case _f.StartElement:
			switch _ffbba.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cacheSource"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cacheSource"}:
				if _gedge := d.DecodeElement(_defde.CacheSource, &_ffbba); _gedge != nil {
					return _gedge
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cacheFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cacheFields"}:
				if _ceaed := d.DecodeElement(_defde.CacheFields, &_ffbba); _ceaed != nil {
					return _ceaed
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cacheHierarchies"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cacheHierarchies"}:
				_defde.CacheHierarchies = NewCT_CacheHierarchies()
				if _cbbe := d.DecodeElement(_defde.CacheHierarchies, &_ffbba); _cbbe != nil {
					return _cbbe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "kpis"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "kpis"}:
				_defde.Kpis = NewCT_PCDKPIs()
				if _dabcd := d.DecodeElement(_defde.Kpis, &_ffbba); _dabcd != nil {
					return _dabcd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tupleCache"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tupleCache"}:
				_defde.TupleCache = NewCT_TupleCache()
				if _edccc := d.DecodeElement(_defde.TupleCache, &_ffbba); _edccc != nil {
					return _edccc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "calculatedItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "calculatedItems"}:
				_defde.CalculatedItems = NewCT_CalculatedItems()
				if _cdbdc := d.DecodeElement(_defde.CalculatedItems, &_ffbba); _cdbdc != nil {
					return _cdbdc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "calculatedMembers"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "calculatedMembers"}:
				_defde.CalculatedMembers = NewCT_CalculatedMembers()
				if _ccgdc := d.DecodeElement(_defde.CalculatedMembers, &_ffbba); _ccgdc != nil {
					return _ccgdc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dimensions"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dimensions"}:
				_defde.Dimensions = NewCT_Dimensions()
				if _cegfbg := d.DecodeElement(_defde.Dimensions, &_ffbba); _cegfbg != nil {
					return _cegfbg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "measureGroups"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "measureGroups"}:
				_defde.MeasureGroups = NewCT_MeasureGroups()
				if _badgf := d.DecodeElement(_defde.MeasureGroups, &_ffbba); _badgf != nil {
					return _badgf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "maps"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "maps"}:
				_defde.Maps = NewCT_MeasureDimensionMaps()
				if _cabebe := d.DecodeElement(_defde.Maps, &_ffbba); _cabebe != nil {
					return _cabebe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_defde.ExtLst = NewCT_ExtensionList()
				if _fceab := d.DecodeElement(_defde.ExtLst, &_ffbba); _fceab != nil {
					return _fceab
				}
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_PivotCacheDefinition \u0025v", _ffbba.Name)
				if _ggfbc := d.Skip(); _ggfbc != nil {
					return _ggfbc
				}
			}
		case _f.EndElement:
			break _cbbb
		case _f.CharData:
		}
	}
	return nil
}
func (_effcc *CT_LegacyDrawing) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bggacg := range start.Attr {
		if _bggacg.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bggacg.Name.Local == "id" || _bggacg.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bggacg.Name.Local == "id" {
			_caebe, _deaddf := _bggacg.Value, error(nil)
			if _deaddf != nil {
				return _deaddf
			}
			_effcc.IdAttr = _caebe
			continue
		}
	}
	for {
		_ecac, _adge := d.Token()
		if _adge != nil {
			return _bg.Errorf("parsing\u0020CT_LegacyDrawing: \u0025s", _adge)
		}
		if _ccefa, _cafgg := _ecac.(_f.EndElement); _cafgg && _ccefa.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_OlapPr and its children, prefixing error messages with path
func (_dgdf *CT_OlapPr) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_Chartsheet and its children, prefixing error messages with path
func (_daeb *CT_Chartsheet) ValidateWithPath(path string) error {
	if _daeb.SheetPr != nil {
		if _edgf := _daeb.SheetPr.ValidateWithPath(path + "\u002fSheetPr"); _edgf != nil {
			return _edgf
		}
	}
	if _dfecf := _daeb.SheetViews.ValidateWithPath(path + "/SheetViews"); _dfecf != nil {
		return _dfecf
	}
	if _daeb.SheetProtection != nil {
		if _eccc := _daeb.SheetProtection.ValidateWithPath(path + "\u002fSheetProtection"); _eccc != nil {
			return _eccc
		}
	}
	if _daeb.CustomSheetViews != nil {
		if _eeba := _daeb.CustomSheetViews.ValidateWithPath(path + "\u002fCustomSheetViews"); _eeba != nil {
			return _eeba
		}
	}
	if _daeb.PageMargins != nil {
		if _aggc := _daeb.PageMargins.ValidateWithPath(path + "\u002fPageMargins"); _aggc != nil {
			return _aggc
		}
	}
	if _daeb.PageSetup != nil {
		if _ecda := _daeb.PageSetup.ValidateWithPath(path + "\u002fPageSetup"); _ecda != nil {
			return _ecda
		}
	}
	if _daeb.HeaderFooter != nil {
		if _cebdf := _daeb.HeaderFooter.ValidateWithPath(path + "\u002fHeaderFooter"); _cebdf != nil {
			return _cebdf
		}
	}
	if _cffd := _daeb.Drawing.ValidateWithPath(path + "\u002fDrawing"); _cffd != nil {
		return _cffd
	}
	if _daeb.LegacyDrawing != nil {
		if _gccd := _daeb.LegacyDrawing.ValidateWithPath(path + "\u002fLegacyDrawing"); _gccd != nil {
			return _gccd
		}
	}
	if _daeb.LegacyDrawingHF != nil {
		if _cabg := _daeb.LegacyDrawingHF.ValidateWithPath(path + "\u002fLegacyDrawingHF"); _cabg != nil {
			return _cabg
		}
	}
	if _daeb.DrawingHF != nil {
		if _gbee := _daeb.DrawingHF.ValidateWithPath(path + "\u002fDrawingHF"); _gbee != nil {
			return _gbee
		}
	}
	if _daeb.Picture != nil {
		if _aaag := _daeb.Picture.ValidateWithPath(path + "\u002fPicture"); _aaag != nil {
			return _aaag
		}
	}
	if _daeb.WebPublishItems != nil {
		if _edcc := _daeb.WebPublishItems.ValidateWithPath(path + "\u002fWebPublishItems"); _edcc != nil {
			return _edcc
		}
	}
	if _daeb.ExtLst != nil {
		if _daed := _daeb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _daed != nil {
			return _daed
		}
	}
	return nil
}

type CT_CellStyles struct {

	// Style Count
	CountAttr *uint32

	// Cell Style
	CellStyle []*CT_CellStyle
}

func (_acedga *PivotCacheRecords) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_acedga.CT_PivotCacheRecords = *NewCT_PivotCacheRecords()
	for _, _cgbbce := range start.Attr {
		if _cgbbce.Name.Local == "count" {
			_bfcfa, _cbdffb := _g.ParseUint(_cgbbce.Value, 10, 32)
			if _cbdffb != nil {
				return _cbdffb
			}
			_bcdad := uint32(_bfcfa)
			_acedga.CountAttr = &_bcdad
			continue
		}
	}
_cfccag:
	for {
		_fdcbfc, _ebeac := d.Token()
		if _ebeac != nil {
			return _ebeac
		}
		switch _bgbdac := _fdcbfc.(type) {
		case _f.StartElement:
			switch _bgbdac.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "r"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "r"}:
				_cffgf := NewCT_Record()
				if _cdgbg := d.DecodeElement(_cffgf, &_bgbdac); _cdgbg != nil {
					return _cdgbg
				}
				_acedga.R = append(_acedga.R, _cffgf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_acedga.ExtLst = NewCT_ExtensionList()
				if _bfadf := d.DecodeElement(_acedga.ExtLst, &_bgbdac); _bfadf != nil {
					return _bfadf
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020PivotCacheRecords\u0020\u0025v", _bgbdac.Name)
				if _addfd := d.Skip(); _addfd != nil {
					return _addfd
				}
			}
		case _f.EndElement:
			break _cfccag
		case _f.CharData:
		}
	}
	return nil
}
func (_bbabfb *ST_PhoneticAlignment) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bbabfb = 0
	case "noControl":
		*_bbabfb = 1
	case "left":
		*_bbabfb = 2
	case "center":
		*_bbabfb = 3
	case "distributed":
		*_bbabfb = 4
	}
	return nil
}

const (
	ST_TableStyleTypeUnset                  ST_TableStyleType = 0
	ST_TableStyleTypeWholeTable             ST_TableStyleType = 1
	ST_TableStyleTypeHeaderRow              ST_TableStyleType = 2
	ST_TableStyleTypeTotalRow               ST_TableStyleType = 3
	ST_TableStyleTypeFirstColumn            ST_TableStyleType = 4
	ST_TableStyleTypeLastColumn             ST_TableStyleType = 5
	ST_TableStyleTypeFirstRowStripe         ST_TableStyleType = 6
	ST_TableStyleTypeSecondRowStripe        ST_TableStyleType = 7
	ST_TableStyleTypeFirstColumnStripe      ST_TableStyleType = 8
	ST_TableStyleTypeSecondColumnStripe     ST_TableStyleType = 9
	ST_TableStyleTypeFirstHeaderCell        ST_TableStyleType = 10
	ST_TableStyleTypeLastHeaderCell         ST_TableStyleType = 11
	ST_TableStyleTypeFirstTotalCell         ST_TableStyleType = 12
	ST_TableStyleTypeLastTotalCell          ST_TableStyleType = 13
	ST_TableStyleTypeFirstSubtotalColumn    ST_TableStyleType = 14
	ST_TableStyleTypeSecondSubtotalColumn   ST_TableStyleType = 15
	ST_TableStyleTypeThirdSubtotalColumn    ST_TableStyleType = 16
	ST_TableStyleTypeFirstSubtotalRow       ST_TableStyleType = 17
	ST_TableStyleTypeSecondSubtotalRow      ST_TableStyleType = 18
	ST_TableStyleTypeThirdSubtotalRow       ST_TableStyleType = 19
	ST_TableStyleTypeBlankRow               ST_TableStyleType = 20
	ST_TableStyleTypeFirstColumnSubheading  ST_TableStyleType = 21
	ST_TableStyleTypeSecondColumnSubheading ST_TableStyleType = 22
	ST_TableStyleTypeThirdColumnSubheading  ST_TableStyleType = 23
	ST_TableStyleTypeFirstRowSubheading     ST_TableStyleType = 24
	ST_TableStyleTypeSecondRowSubheading    ST_TableStyleType = 25
	ST_TableStyleTypeThirdRowSubheading     ST_TableStyleType = 26
	ST_TableStyleTypePageFieldLabels        ST_TableStyleType = 27
	ST_TableStyleTypePageFieldValues        ST_TableStyleType = 28
)

type CT_IntProperty struct {

	// Value
	ValAttr int32
}
type CT_CustomFilter struct {

	// Filter Comparison Operator
	OperatorAttr ST_FilterOperator

	// Top or Bottom Value
	ValAttr *string
}

func (_abgdge *CT_WorkbookProtection) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gbfgc := range start.Attr {
		if _gbfgc.Name.Local == "revisionsAlgorithmName" {
			_dcfcbb, _fdgae := _gbfgc.Value, error(nil)
			if _fdgae != nil {
				return _fdgae
			}
			_abgdge.RevisionsAlgorithmNameAttr = &_dcfcbb
			continue
		}
		if _gbfgc.Name.Local == "revisionsHashValue" {
			_gdafc, _cgddc := _gbfgc.Value, error(nil)
			if _cgddc != nil {
				return _cgddc
			}
			_abgdge.RevisionsHashValueAttr = &_gdafc
			continue
		}
		if _gbfgc.Name.Local == "workbookPasswordCharacterSet" {
			_aebaa, _fbcga := _gbfgc.Value, error(nil)
			if _fbcga != nil {
				return _fbcga
			}
			_abgdge.WorkbookPasswordCharacterSetAttr = &_aebaa
			continue
		}
		if _gbfgc.Name.Local == "revisionsPasswordCharacterSet" {
			_gfbab, _afcaag := _gbfgc.Value, error(nil)
			if _afcaag != nil {
				return _afcaag
			}
			_abgdge.RevisionsPasswordCharacterSetAttr = &_gfbab
			continue
		}
		if _gbfgc.Name.Local == "lockStructure" {
			_ggdcc, _gfcbfc := _g.ParseBool(_gbfgc.Value)
			if _gfcbfc != nil {
				return _gfcbfc
			}
			_abgdge.LockStructureAttr = &_ggdcc
			continue
		}
		if _gbfgc.Name.Local == "lockWindows" {
			_edadd, _bdefe := _g.ParseBool(_gbfgc.Value)
			if _bdefe != nil {
				return _bdefe
			}
			_abgdge.LockWindowsAttr = &_edadd
			continue
		}
		if _gbfgc.Name.Local == "lockRevision" {
			_gafgab, _bebegd := _g.ParseBool(_gbfgc.Value)
			if _bebegd != nil {
				return _bebegd
			}
			_abgdge.LockRevisionAttr = &_gafgab
			continue
		}
		if _gbfgc.Name.Local == "workbookPassword" {
			_cfgdcc, _cgcbbf := _gbfgc.Value, error(nil)
			if _cgcbbf != nil {
				return _cgcbbf
			}
			_abgdge.WorkbookPasswordAttr = &_cfgdcc
			continue
		}
		if _gbfgc.Name.Local == "revisionsPassword" {
			_ffdaf, _aefbc := _gbfgc.Value, error(nil)
			if _aefbc != nil {
				return _aefbc
			}
			_abgdge.RevisionsPasswordAttr = &_ffdaf
			continue
		}
		if _gbfgc.Name.Local == "revisionsSaltValue" {
			_gfbdf, _egcfe := _gbfgc.Value, error(nil)
			if _egcfe != nil {
				return _egcfe
			}
			_abgdge.RevisionsSaltValueAttr = &_gfbdf
			continue
		}
		if _gbfgc.Name.Local == "revisionsSpinCount" {
			_ageccd, _cfdgga := _g.ParseUint(_gbfgc.Value, 10, 32)
			if _cfdgga != nil {
				return _cfdgga
			}
			_fecafb := uint32(_ageccd)
			_abgdge.RevisionsSpinCountAttr = &_fecafb
			continue
		}
		if _gbfgc.Name.Local == "workbookAlgorithmName" {
			_gccace, _cbafe := _gbfgc.Value, error(nil)
			if _cbafe != nil {
				return _cbafe
			}
			_abgdge.WorkbookAlgorithmNameAttr = &_gccace
			continue
		}
		if _gbfgc.Name.Local == "workbookHashValue" {
			_cafbgb, _bccdc := _gbfgc.Value, error(nil)
			if _bccdc != nil {
				return _bccdc
			}
			_abgdge.WorkbookHashValueAttr = &_cafbgb
			continue
		}
		if _gbfgc.Name.Local == "workbookSaltValue" {
			_deeff, _fecbg := _gbfgc.Value, error(nil)
			if _fecbg != nil {
				return _fecbg
			}
			_abgdge.WorkbookSaltValueAttr = &_deeff
			continue
		}
		if _gbfgc.Name.Local == "workbookSpinCount" {
			_bcfad, _cacbgf := _g.ParseUint(_gbfgc.Value, 10, 32)
			if _cacbgf != nil {
				return _cacbgf
			}
			_aagbea := uint32(_bcfad)
			_abgdge.WorkbookSpinCountAttr = &_aagbea
			continue
		}
	}
	for {
		_efdec, _decfe := d.Token()
		if _decfe != nil {
			return _bg.Errorf("parsing\u0020CT_WorkbookProtection:\u0020\u0025s", _decfe)
		}
		if _egcaed, _fcacgd := _efdec.(_f.EndElement); _fcacgd && _egcaed.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_colItems() *CT_colItems { _aeegg := &CT_colItems{}; return _aeegg }
func NewCT_Filters() *CT_Filters   { _bage := &CT_Filters{}; return _bage }

type Chartsheet struct{ CT_Chartsheet }

func (_eeddc *CT_FontFamily) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_eeddc.ValAttr = 0
	for _, _gaadg := range start.Attr {
		if _gaadg.Name.Local == "val" {
			_efcdc, _fedga := _g.ParseInt(_gaadg.Value, 10, 64)
			if _fedga != nil {
				return _fedga
			}
			_eeddc.ValAttr = _efcdc
			continue
		}
	}
	for {
		_gcefe, _effdg := d.Token()
		if _effdg != nil {
			return _bg.Errorf("parsing\u0020CT_FontFamily:\u0020\u0025s", _effdg)
		}
		if _dgbdd, _ddcff := _gcefe.(_f.EndElement); _ddcff && _dgbdd.Name == start.Name {
			break
		}
	}
	return nil
}
func NewComments() *Comments {
	_fdbdg := &Comments{}
	_fdbdg.CT_Comments = *NewCT_Comments()
	return _fdbdg
}

// Validate validates the ExternalLink and its children
func (_aabdb *ExternalLink) Validate() error { return _aabdb.ValidateWithPath("ExternalLink") }

type ST_Pane byte

// Validate validates the CT_MeasureGroup and its children
func (_gddfdd *CT_MeasureGroup) Validate() error { return _gddfdd.ValidateWithPath("CT_MeasureGroup") }
func (_fcdca *CT_ChartsheetView) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fcdca.TabSelectedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "tabSelected"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fcdca.TabSelectedAttr))})
	}
	if _fcdca.ZoomScaleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "zoomScale"}, Value: _bg.Sprintf("\u0025v", *_fcdca.ZoomScaleAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "workbookViewId"}, Value: _bg.Sprintf("\u0025v", _fcdca.WorkbookViewIdAttr)})
	if _fcdca.ZoomToFitAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "zoomToFit"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fcdca.ZoomToFitAttr))})
	}
	e.EncodeToken(start)
	if _fcdca.ExtLst != nil {
		_bdbf := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_fcdca.ExtLst, _bdbf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_RevisionHeader() *CT_RevisionHeader {
	_badaf := &CT_RevisionHeader{}
	_badaf.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	_badaf.SheetIdMap = NewCT_SheetIdMap()
	return _badaf
}

// Validate validates the CT_SheetFormatPr and its children
func (_aagae *CT_SheetFormatPr) Validate() error { return _aagae.ValidateWithPath("CT_SheetFormatPr") }
func (_ebddb *CT_Dimensions) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aefcb := range start.Attr {
		if _aefcb.Name.Local == "count" {
			_ggcb, _degbd := _g.ParseUint(_aefcb.Value, 10, 32)
			if _degbd != nil {
				return _degbd
			}
			_ddae := uint32(_ggcb)
			_ebddb.CountAttr = &_ddae
			continue
		}
	}
_dagb:
	for {
		_afde, _fbcc := d.Token()
		if _fbcc != nil {
			return _fbcc
		}
		switch _badg := _afde.(type) {
		case _f.StartElement:
			switch _badg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dimension"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dimension"}:
				_adfab := NewCT_PivotDimension()
				if _gcabe := d.DecodeElement(_adfab, &_badg); _gcabe != nil {
					return _gcabe
				}
				_ebddb.Dimension = append(_ebddb.Dimension, _adfab)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_Dimensions \u0025v", _badg.Name)
				if _eeda := d.Skip(); _eeda != nil {
					return _eeda
				}
			}
		case _f.EndElement:
			break _dagb
		case _f.CharData:
		}
	}
	return nil
}
func (_cbgd *CT_ConditionalFormats) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bfgd := range start.Attr {
		if _bfgd.Name.Local == "count" {
			_fefcef, _cgggc := _g.ParseUint(_bfgd.Value, 10, 32)
			if _cgggc != nil {
				return _cgggc
			}
			_fggb := uint32(_fefcef)
			_cbgd.CountAttr = &_fggb
			continue
		}
	}
_dceff:
	for {
		_dcbee, _ggea := d.Token()
		if _ggea != nil {
			return _ggea
		}
		switch _bgfe := _dcbee.(type) {
		case _f.StartElement:
			switch _bgfe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "conditionalFormat"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "conditionalFormat"}:
				_afbc := NewCT_ConditionalFormat()
				if _fcbe := d.DecodeElement(_afbc, &_bgfe); _fcbe != nil {
					return _fcbe
				}
				_cbgd.ConditionalFormat = append(_cbgd.ConditionalFormat, _afbc)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on CT_ConditionalFormats\u0020\u0025v", _bgfe.Name)
				if _cegcb := d.Skip(); _cegcb != nil {
					return _cegcb
				}
			}
		case _f.EndElement:
			break _dceff
		case _f.CharData:
		}
	}
	return nil
}
func (_fgdfg ST_Pane) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_gdebc := _f.Attr{}
	_gdebc.Name = name
	switch _fgdfg {
	case ST_PaneUnset:
		_gdebc.Value = ""
	case ST_PaneBottomRight:
		_gdebc.Value = "bottomRight"
	case ST_PaneTopRight:
		_gdebc.Value = "topRight"
	case ST_PaneBottomLeft:
		_gdebc.Value = "bottomLeft"
	case ST_PaneTopLeft:
		_gdebc.Value = "topLeft"
	}
	return _gdebc, nil
}

// Validate validates the CT_Revisions and its children
func (_becac *CT_Revisions) Validate() error { return _becac.ValidateWithPath("CT_Revisions") }
func (_ccgaddb *CT_Scenarios) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _efgge := range start.Attr {
		if _efgge.Name.Local == "current" {
			_eggag, _adacf := _g.ParseUint(_efgge.Value, 10, 32)
			if _adacf != nil {
				return _adacf
			}
			_gcdfe := uint32(_eggag)
			_ccgaddb.CurrentAttr = &_gcdfe
			continue
		}
		if _efgge.Name.Local == "show" {
			_gfdbdg, _abaga := _g.ParseUint(_efgge.Value, 10, 32)
			if _abaga != nil {
				return _abaga
			}
			_edgae := uint32(_gfdbdg)
			_ccgaddb.ShowAttr = &_edgae
			continue
		}
		if _efgge.Name.Local == "sqref" {
			_ageba, _fgaabc := ParseSliceST_Sqref(_efgge.Value)
			if _fgaabc != nil {
				return _fgaabc
			}
			_ccgaddb.SqrefAttr = &_ageba
			continue
		}
	}
_ggfgeb:
	for {
		_ggedg, _fgeeg := d.Token()
		if _fgeeg != nil {
			return _fgeeg
		}
		switch _dadce := _ggedg.(type) {
		case _f.StartElement:
			switch _dadce.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "scenario"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "scenario"}:
				_fdaccb := NewCT_Scenario()
				if _bggcbg := d.DecodeElement(_fdaccb, &_dadce); _bggcbg != nil {
					return _bggcbg
				}
				_ccgaddb.Scenario = append(_ccgaddb.Scenario, _fdaccb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Scenarios\u0020\u0025v", _dadce.Name)
				if _bdade := d.Skip(); _bdade != nil {
					return _bdade
				}
			}
		case _f.EndElement:
			break _ggfgeb
		case _f.CharData:
		}
	}
	return nil
}
func (_gfcef *CT_DdeItems) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_eaedb:
	for {
		_agfad, _affd := d.Token()
		if _affd != nil {
			return _affd
		}
		switch _fdede := _agfad.(type) {
		case _f.StartElement:
			switch _fdede.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ddeItem"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ddeItem"}:
				_gbde := NewCT_DdeItem()
				if _gfaa := d.DecodeElement(_gbde, &_fdede); _gfaa != nil {
					return _gfaa
				}
				_gfcef.DdeItem = append(_gfcef.DdeItem, _gbde)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DdeItems\u0020\u0025v", _fdede.Name)
				if _adbg := d.Skip(); _adbg != nil {
					return _adbg
				}
			}
		case _f.EndElement:
			break _eaedb
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_MeasureGroup and its children, prefixing error messages with path
func (_aaga *CT_MeasureGroup) ValidateWithPath(path string) error { return nil }
func (_ececea *CT_Tuples) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ececea.CAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "c"}, Value: _bg.Sprintf("\u0025v", *_ececea.CAttr)})
	}
	e.EncodeToken(start)
	_agegdb := _f.StartElement{Name: _f.Name{Local: "ma:tpl"}}
	for _, _gdcfbe := range _ececea.Tpl {
		e.EncodeElement(_gdcfbe, _agegdb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_LevelGroup struct {

	// Group Name
	NameAttr string

	// Unique Group Name
	UniqueNameAttr string

	// Group Caption
	CaptionAttr string

	// Parent Unique Name
	UniqueParentAttr *string

	// Group Id
	IdAttr *int32

	// OLAP Group Members
	GroupMembers *CT_GroupMembers
}

func (_fcbgcd *CT_ExternalSheetDataSet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_dbdfc:
	for {
		_cbfe, _agaeb := d.Token()
		if _agaeb != nil {
			return _agaeb
		}
		switch _cgedf := _cbfe.(type) {
		case _f.StartElement:
			switch _cgedf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetData"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetData"}:
				_agbc := NewCT_ExternalSheetData()
				if _dcfdg := d.DecodeElement(_agbc, &_cgedf); _dcfdg != nil {
					return _dcfdg
				}
				_fcbgcd.SheetData = append(_fcbgcd.SheetData, _agbc)
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_ExternalSheetDataSet \u0025v", _cgedf.Name)
				if _ebba := d.Skip(); _ebba != nil {
					return _ebba
				}
			}
		case _f.EndElement:
			break _dbdfc
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_AutoFilter and its children
func (_ccfb *CT_AutoFilter) Validate() error { return _ccfb.ValidateWithPath("CT_AutoFilter") }
func NewCT_Font() *CT_Font                   { _ecffb := &CT_Font{}; return _ecffb }

// ValidateWithPath validates the CT_PageBreak and its children, prefixing error messages with path
func (_bgcgde *CT_PageBreak) ValidateWithPath(path string) error {
	for _fegbcb, _bgdfb := range _bgcgde.Brk {
		if _gfafb := _bgdfb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fBrk\u005b\u0025d\u005d", path, _fegbcb)); _gfafb != nil {
			return _gfafb
		}
	}
	return nil
}
func (_bedea *CT_ObjectAnchor) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bedea.From = _d.NewFrom()
	_bedea.To = _d.NewTo()
	for _, _agbec := range start.Attr {
		if _agbec.Name.Local == "moveWithCells" {
			_aegbfc, _dadgc := _g.ParseBool(_agbec.Value)
			if _dadgc != nil {
				return _dadgc
			}
			_bedea.MoveWithCellsAttr = &_aegbfc
			continue
		}
		if _agbec.Name.Local == "sizeWithCells" {
			_cfbdd, _abefdc := _g.ParseBool(_agbec.Value)
			if _abefdc != nil {
				return _abefdc
			}
			_bedea.SizeWithCellsAttr = &_cfbdd
			continue
		}
	}
_ccdga:
	for {
		_cegec, _gacfca := d.Token()
		if _gacfca != nil {
			return _gacfca
		}
		switch _efcac := _cegec.(type) {
		case _f.StartElement:
			switch _efcac.Name {
			case _f.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "from"}, _f.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "from"}:
				if _afade := d.DecodeElement(_bedea.From, &_efcac); _afade != nil {
					return _afade
				}
			case _f.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "to"}, _f.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "to"}:
				if _gffdc := d.DecodeElement(_bedea.To, &_efcac); _gffdc != nil {
					return _gffdc
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ObjectAnchor\u0020\u0025v", _efcac.Name)
				if _aaaga := d.Skip(); _aaaga != nil {
					return _aaaga
				}
			}
		case _f.EndElement:
			break _ccdga
		case _f.CharData:
		}
	}
	return nil
}
func (_gbeb *CT_PageMargins) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _afbbd := range start.Attr {
		if _afbbd.Name.Local == "left" {
			_aacc, _cgca := _g.ParseFloat(_afbbd.Value, 64)
			if _cgca != nil {
				return _cgca
			}
			_gbeb.LeftAttr = _aacc
			continue
		}
		if _afbbd.Name.Local == "right" {
			_ccaaa, _gddc := _g.ParseFloat(_afbbd.Value, 64)
			if _gddc != nil {
				return _gddc
			}
			_gbeb.RightAttr = _ccaaa
			continue
		}
		if _afbbd.Name.Local == "top" {
			_ecdcb, _eecff := _g.ParseFloat(_afbbd.Value, 64)
			if _eecff != nil {
				return _eecff
			}
			_gbeb.TopAttr = _ecdcb
			continue
		}
		if _afbbd.Name.Local == "bottom" {
			_ebfcd, _fafc := _g.ParseFloat(_afbbd.Value, 64)
			if _fafc != nil {
				return _fafc
			}
			_gbeb.BottomAttr = _ebfcd
			continue
		}
		if _afbbd.Name.Local == "header" {
			_aacefa, _egcfd := _g.ParseFloat(_afbbd.Value, 64)
			if _egcfd != nil {
				return _egcfd
			}
			_gbeb.HeaderAttr = _aacefa
			continue
		}
		if _afbbd.Name.Local == "footer" {
			_efdfd, _cdfee := _g.ParseFloat(_afbbd.Value, 64)
			if _cdfee != nil {
				return _cdfee
			}
			_gbeb.FooterAttr = _efdfd
			continue
		}
	}
	for {
		_eggeb, _dgbff := d.Token()
		if _dgbff != nil {
			return _bg.Errorf("parsing\u0020CT_PageMargins:\u0020\u0025s", _dgbff)
		}
		if _fdbec, _bgbdf := _eggeb.(_f.EndElement); _bgbdf && _fdbec.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_PivotAreas() *CT_PivotAreas { _cbce := &CT_PivotAreas{}; return _cbce }

// Validate validates the CT_OleObjects and its children
func (_bdcdb *CT_OleObjects) Validate() error { return _bdcdb.ValidateWithPath("CT_OleObjects") }
func (_gedddf ST_DataValidationType) ValidateWithPath(path string) error {
	switch _gedddf {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gedddf))
	}
	return nil
}

// ValidateWithPath validates the CT_Tuple and its children, prefixing error messages with path
func (_afgec *CT_Tuple) ValidateWithPath(path string) error { return nil }
func (_dafcb *CT_Pages) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dafcb.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_dafcb.CountAttr)})
	}
	e.EncodeToken(start)
	_gbdeca := _f.StartElement{Name: _f.Name{Local: "ma:page"}}
	for _, _fggaf := range _dafcb.Page {
		e.EncodeElement(_fggaf, _gbdeca)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dgeac *CT_SortCondition) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fffed := range start.Attr {
		if _fffed.Name.Local == "descending" {
			_bbadff, _daffg := _g.ParseBool(_fffed.Value)
			if _daffg != nil {
				return _daffg
			}
			_dgeac.DescendingAttr = &_bbadff
			continue
		}
		if _fffed.Name.Local == "sortBy" {
			_dgeac.SortByAttr.UnmarshalXMLAttr(_fffed)
			continue
		}
		if _fffed.Name.Local == "ref" {
			_cffce, _bebcf := _fffed.Value, error(nil)
			if _bebcf != nil {
				return _bebcf
			}
			_dgeac.RefAttr = _cffce
			continue
		}
		if _fffed.Name.Local == "customList" {
			_dcega, _afdab := _fffed.Value, error(nil)
			if _afdab != nil {
				return _afdab
			}
			_dgeac.CustomListAttr = &_dcega
			continue
		}
		if _fffed.Name.Local == "dxfId" {
			_abaeg, _fcadc := _g.ParseUint(_fffed.Value, 10, 32)
			if _fcadc != nil {
				return _fcadc
			}
			_acgbed := uint32(_abaeg)
			_dgeac.DxfIdAttr = &_acgbed
			continue
		}
		if _fffed.Name.Local == "iconSet" {
			_dgeac.IconSetAttr.UnmarshalXMLAttr(_fffed)
			continue
		}
		if _fffed.Name.Local == "iconId" {
			_adbbb, _bbecgdb := _g.ParseUint(_fffed.Value, 10, 32)
			if _bbecgdb != nil {
				return _bbecgdb
			}
			_eadde := uint32(_adbbb)
			_dgeac.IconIdAttr = &_eadde
			continue
		}
	}
	for {
		_cebce, _cbgdab := d.Token()
		if _cbgdab != nil {
			return _bg.Errorf("parsing\u0020CT_SortCondition: \u0025s", _cbgdab)
		}
		if _fdgebc, _aaffac := _cebce.(_f.EndElement); _aaffac && _fdgebc.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CommentPr and its children, prefixing error messages with path
func (_abdc *CT_CommentPr) ValidateWithPath(path string) error {
	if _dead := _abdc.TextHAlignAttr.ValidateWithPath(path + "\u002fTextHAlignAttr"); _dead != nil {
		return _dead
	}
	if _bbabg := _abdc.TextVAlignAttr.ValidateWithPath(path + "\u002fTextVAlignAttr"); _bbabg != nil {
		return _bbabg
	}
	if _gdbfg := _abdc.Anchor.ValidateWithPath(path + "\u002fAnchor"); _gdbfg != nil {
		return _gdbfg
	}
	return nil
}

type ST_CellFormulaType byte

func (_gbffd *CT_SheetBackgroundPicture) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _gbffd.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cfeegd *CT_X) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dadad := range start.Attr {
		if _dadad.Name.Local == "v" {
			_gaeaaf, _dedcad := _g.ParseInt(_dadad.Value, 10, 32)
			if _dedcad != nil {
				return _dedcad
			}
			_fdgba := int32(_gaeaaf)
			_cfeegd.VAttr = &_fdgba
			continue
		}
	}
	for {
		_aeaef, _cbgcg := d.Token()
		if _cbgcg != nil {
			return _bg.Errorf("parsing\u0020CT_X:\u0020\u0025s", _cbgcg)
		}
		if _cbgff, _cbefcd := _aeaef.(_f.EndElement); _cbefcd && _cbgff.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Sheets struct {

	// Sheet Information
	Sheet []*CT_Sheet
}

// ValidateWithPath validates the CT_Authors and its children, prefixing error messages with path
func (_df *CT_Authors) ValidateWithPath(path string) error { return nil }
func (_gcead *PivotTableDefinition) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:pivotTableDefinition"
	return _gcead.CT_pivotTableDefinition.MarshalXML(e, start)
}
func NewCT_MetadataStrings() *CT_MetadataStrings { _bggaf := &CT_MetadataStrings{}; return _bggaf }

// ValidateWithPath validates the CT_SingleXmlCell and its children, prefixing error messages with path
func (_ecedba *CT_SingleXmlCell) ValidateWithPath(path string) error {
	if _afagg := _ecedba.XmlCellPr.ValidateWithPath(path + "\u002fXmlCellPr"); _afagg != nil {
		return _afagg
	}
	if _ecedba.ExtLst != nil {
		if _afeed := _ecedba.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _afeed != nil {
			return _afeed
		}
	}
	return nil
}
func NewCT_RevisionSheetRename() *CT_RevisionSheetRename {
	_deadgg := &CT_RevisionSheetRename{}
	return _deadgg
}
func (_fbbaed ST_TargetScreenSize) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_eagcd := _f.Attr{}
	_eagcd.Name = name
	switch _fbbaed {
	case ST_TargetScreenSizeUnset:
		_eagcd.Value = ""
	case ST_TargetScreenSize544x376:
		_eagcd.Value = "544x376"
	case ST_TargetScreenSize640x480:
		_eagcd.Value = "640x480"
	case ST_TargetScreenSize720x512:
		_eagcd.Value = "720x512"
	case ST_TargetScreenSize800x600:
		_eagcd.Value = "800x600"
	case ST_TargetScreenSize1024x768:
		_eagcd.Value = "1024x768"
	case ST_TargetScreenSize1152x882:
		_eagcd.Value = "1152x882"
	case ST_TargetScreenSize1152x900:
		_eagcd.Value = "1152x900"
	case ST_TargetScreenSize1280x1024:
		_eagcd.Value = "1280x1024"
	case ST_TargetScreenSize1600x1200:
		_eagcd.Value = "1600x1200"
	case ST_TargetScreenSize1800x1440:
		_eagcd.Value = "1800x1440"
	case ST_TargetScreenSize1920x1200:
		_eagcd.Value = "1920x1200"
	}
	return _eagcd, nil
}
func (_bdcec *ST_FileType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cfbbdd, _agaag := d.Token()
	if _agaag != nil {
		return _agaag
	}
	if _eebfeb, _gdgefg := _cfbbdd.(_f.EndElement); _gdgefg && _eebfeb.Name == start.Name {
		*_bdcec = 1
		return nil
	}
	if _affab, _cdagfd := _cfbbdd.(_f.CharData); !_cdagfd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cfbbdd)
	} else {
		switch string(_affab) {
		case "":
			*_bdcec = 0
		case "mac":
			*_bdcec = 1
		case "win":
			*_bdcec = 2
		case "dos":
			*_bdcec = 3
		case "lin":
			*_bdcec = 4
		case "other":
			*_bdcec = 5
		}
	}
	_cfbbdd, _agaag = d.Token()
	if _agaag != nil {
		return _agaag
	}
	if _badgb, _eedggc := _cfbbdd.(_f.EndElement); _eedggc && _badgb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cfbbdd)
}

// ValidateWithPath validates the CT_RevisionComment and its children, prefixing error messages with path
func (_dacge *CT_RevisionComment) ValidateWithPath(path string) error {
	if !_e.ST_GuidPatternRe.MatchString(_dacge.GuidAttr) {
		return _bg.Errorf("\u0025s\u002fm\u002eGuidAttr must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_GuidPatternRe, _dacge.GuidAttr)
	}
	if _geagg := _dacge.ActionAttr.ValidateWithPath(path + "/ActionAttr"); _geagg != nil {
		return _geagg
	}
	return nil
}
func NewCT_Fonts() *CT_Fonts { _gefef := &CT_Fonts{}; return _gefef }

type ST_CellSpans []string
type CT_Macrosheet struct {

	// Sheet Properties
	SheetPr *CT_SheetPr

	// Macro Sheet Dimensions
	Dimension *CT_SheetDimension

	// Macro Sheet Views
	SheetViews *CT_SheetViews

	// Sheet Format Properties
	SheetFormatPr *CT_SheetFormatPr

	// Column Information
	Cols []*CT_Cols

	// Sheet Data
	SheetData *CT_SheetData

	// Sheet Protection Options
	SheetProtection *CT_SheetProtection

	// AutoFilter
	AutoFilter *CT_AutoFilter

	// Sort State
	SortState *CT_SortState

	// Data Consolidation
	DataConsolidate *CT_DataConsolidate

	// Custom Sheet Views
	CustomSheetViews *CT_CustomSheetViews

	// Phonetic Properties
	PhoneticPr *CT_PhoneticPr

	// Conditional Formatting
	ConditionalFormatting []*CT_ConditionalFormatting

	// Print Options
	PrintOptions *CT_PrintOptions

	// Page Margins
	PageMargins *CT_PageMargins

	// Page Setup Settings
	PageSetup *CT_PageSetup

	// Header Footer Settings
	HeaderFooter *CT_HeaderFooter

	// Horizontal Page Breaks (Row)
	RowBreaks *CT_PageBreak

	// Vertical Page Breaks
	ColBreaks *CT_PageBreak

	// Custom Properties
	CustomProperties *CT_CustomProperties

	// Drawing
	Drawing *CT_Drawing

	// Legacy Drawing Reference
	LegacyDrawing *CT_LegacyDrawing

	// Legacy Drawing Header Footer
	LegacyDrawingHF *CT_LegacyDrawing
	DrawingHF       *CT_DrawingHF

	// Background Image
	Picture *CT_SheetBackgroundPicture

	// Embedded Objects
	OleObjects *CT_OleObjects

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_agda *CT_Format) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _agda.ActionAttr != ST_FormatActionUnset {
		_bgagc, _fefggb := _agda.ActionAttr.MarshalXMLAttr(_f.Name{Local: "action"})
		if _fefggb != nil {
			return _fefggb
		}
		start.Attr = append(start.Attr, _bgagc)
	}
	if _agda.DxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dxfId"}, Value: _bg.Sprintf("\u0025v", *_agda.DxfIdAttr)})
	}
	e.EncodeToken(start)
	_bacge := _f.StartElement{Name: _f.Name{Local: "ma:pivotArea"}}
	e.EncodeElement(_agda.PivotArea, _bacge)
	if _agda.ExtLst != nil {
		_aeaeg := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_agda.ExtLst, _aeaeg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_CalculatedMember() *CT_CalculatedMember { _gbfg := &CT_CalculatedMember{}; return _gbfg }
func (_ffdda *CT_Number) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "v"}, Value: _bg.Sprintf("\u0025v", _ffdda.VAttr)})
	if _ffdda.UAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "u"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffdda.UAttr))})
	}
	if _ffdda.FAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "f"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffdda.FAttr))})
	}
	if _ffdda.CAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "c"}, Value: _bg.Sprintf("\u0025v", *_ffdda.CAttr)})
	}
	if _ffdda.CpAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cp"}, Value: _bg.Sprintf("\u0025v", *_ffdda.CpAttr)})
	}
	if _ffdda.InAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "in"}, Value: _bg.Sprintf("\u0025v", *_ffdda.InAttr)})
	}
	if _ffdda.BcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "bc"}, Value: _bg.Sprintf("\u0025v", *_ffdda.BcAttr)})
	}
	if _ffdda.FcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fc"}, Value: _bg.Sprintf("\u0025v", *_ffdda.FcAttr)})
	}
	if _ffdda.IAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "i"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffdda.IAttr))})
	}
	if _ffdda.UnAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "un"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffdda.UnAttr))})
	}
	if _ffdda.StAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "st"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffdda.StAttr))})
	}
	if _ffdda.BAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "b"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffdda.BAttr))})
	}
	e.EncodeToken(start)
	if _ffdda.Tpls != nil {
		_dcffbb := _f.StartElement{Name: _f.Name{Local: "ma:tpls"}}
		for _, _baabf := range _ffdda.Tpls {
			e.EncodeElement(_baabf, _dcffbb)
		}
	}
	if _ffdda.X != nil {
		_deacb := _f.StartElement{Name: _f.Name{Local: "ma:x"}}
		for _, _ddbadb := range _ffdda.X {
			e.EncodeElement(_ddbadb, _deacb)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_PivotCache() *CT_PivotCache { _fddfe := &CT_PivotCache{}; return _fddfe }
func (_fagdf *CT_MetadataBlock) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_ecaga := _f.StartElement{Name: _f.Name{Local: "ma:rc"}}
	for _, _dddea := range _fagdf.Rc {
		e.EncodeElement(_dddea, _ecaga)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bfbced ST_Visibility) String() string {
	switch _bfbced {
	case 0:
		return ""
	case 1:
		return "visible"
	case 2:
		return "hidden"
	case 3:
		return "veryHidden"
	}
	return ""
}

// Validate validates the CT_Tuple and its children
func (_bdeae *CT_Tuple) Validate() error { return _bdeae.ValidateWithPath("CT_Tuple") }

type CT_Fonts struct {

	// Font Count
	CountAttr *uint32

	// Font
	Font []*CT_Font
}
type CT_Formats struct {

	// Formats Count
	CountAttr *uint32

	// PivotTable Format
	Format []*CT_Format
}

// ValidateWithPath validates the CT_Fill and its children, prefixing error messages with path
func (_eabbcf *CT_Fill) ValidateWithPath(path string) error {
	if _eabbcf.PatternFill != nil {
		if _agfbg := _eabbcf.PatternFill.ValidateWithPath(path + "\u002fPatternFill"); _agfbg != nil {
			return _agfbg
		}
	}
	if _eabbcf.GradientFill != nil {
		if _cegef := _eabbcf.GradientFill.ValidateWithPath(path + "\u002fGradientFill"); _cegef != nil {
			return _cegef
		}
	}
	return nil
}

const (
	ST_DateTimeGroupingUnset  ST_DateTimeGrouping = 0
	ST_DateTimeGroupingYear   ST_DateTimeGrouping = 1
	ST_DateTimeGroupingMonth  ST_DateTimeGrouping = 2
	ST_DateTimeGroupingDay    ST_DateTimeGrouping = 3
	ST_DateTimeGroupingHour   ST_DateTimeGrouping = 4
	ST_DateTimeGroupingMinute ST_DateTimeGrouping = 5
	ST_DateTimeGroupingSecond ST_DateTimeGrouping = 6
)

func NewCT_RevisionConflict() *CT_RevisionConflict { _ddgec := &CT_RevisionConflict{}; return _ddgec }

type CT_DefinedName struct {
	NameAttr              string
	CommentAttr           *string
	CustomMenuAttr        *string
	DescriptionAttr       *string
	HelpAttr              *string
	StatusBarAttr         *string
	LocalSheetIdAttr      *uint32
	HiddenAttr            *bool
	FunctionAttr          *bool
	VbProcedureAttr       *bool
	XlmAttr               *bool
	FunctionGroupIdAttr   *uint32
	ShortcutKeyAttr       *string
	PublishToServerAttr   *bool
	WorkbookParameterAttr *bool
	Content               string
}

func NewCT_XmlColumnPr() *CT_XmlColumnPr { _ceefb := &CT_XmlColumnPr{}; return _ceefb }

type CT_ExternalSheetNames struct {

	// Sheet Name
	SheetName []*CT_ExternalSheetName
}

func NewCT_Cell() *CT_Cell { _dafa := &CT_Cell{}; return _dafa }
func (_ebae *CT_Comment) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ebae.Text = NewCT_Rst()
	for _, _gfdg := range start.Attr {
		if _gfdg.Name.Local == "ref" {
			_acaa, _edde := _gfdg.Value, error(nil)
			if _edde != nil {
				return _edde
			}
			_ebae.RefAttr = _acaa
			continue
		}
		if _gfdg.Name.Local == "authorId" {
			_bcaf, _fdbb := _g.ParseUint(_gfdg.Value, 10, 32)
			if _fdbb != nil {
				return _fdbb
			}
			_ebae.AuthorIdAttr = uint32(_bcaf)
			continue
		}
		if _gfdg.Name.Local == "guid" {
			_fdedf, _bceg := _gfdg.Value, error(nil)
			if _bceg != nil {
				return _bceg
			}
			_ebae.GuidAttr = &_fdedf
			continue
		}
		if _gfdg.Name.Local == "shapeId" {
			_eebaf, _bace := _g.ParseUint(_gfdg.Value, 10, 32)
			if _bace != nil {
				return _bace
			}
			_dddf := uint32(_eebaf)
			_ebae.ShapeIdAttr = &_dddf
			continue
		}
	}
_cbcdd:
	for {
		_aeagc, _ecdg := d.Token()
		if _ecdg != nil {
			return _ecdg
		}
		switch _bebea := _aeagc.(type) {
		case _f.StartElement:
			switch _bebea.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "text"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "text"}:
				if _bacf := d.DecodeElement(_ebae.Text, &_bebea); _bacf != nil {
					return _bacf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "commentPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "commentPr"}:
				_ebae.CommentPr = NewCT_CommentPr()
				if _gdgf := d.DecodeElement(_ebae.CommentPr, &_bebea); _gdgf != nil {
					return _gdgf
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_Comment\u0020\u0025v", _bebea.Name)
				if _gbed := d.Skip(); _gbed != nil {
					return _gbed
				}
			}
		case _f.EndElement:
			break _cbcdd
		case _f.CharData:
		}
	}
	return nil
}
func (_edggc ST_OleUpdate) Validate() error { return _edggc.ValidateWithPath("") }

type CT_Col struct {

	// Minimum Column
	MinAttr uint32

	// Maximum Column
	MaxAttr uint32

	// Column Width
	WidthAttr *float64

	// Style
	StyleAttr *uint32

	// Hidden Columns
	HiddenAttr *bool

	// Best Fit Column Width
	BestFitAttr *bool

	// Custom Width
	CustomWidthAttr *bool

	// Show Phonetic Information
	PhoneticAttr *bool

	// Outline Level
	OutlineLevelAttr *uint8

	// Collapsed
	CollapsedAttr *bool
}

func (_bccbg *CT_NumFmts) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bccbg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bccbg.CountAttr)})
	}
	e.EncodeToken(start)
	if _bccbg.NumFmt != nil {
		_cceadf := _f.StartElement{Name: _f.Name{Local: "ma:numFmt"}}
		for _, _daaac := range _bccbg.NumFmt {
			e.EncodeElement(_daaac, _cceadf)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Member and its children, prefixing error messages with path
func (_bedeg *CT_Member) ValidateWithPath(path string) error { return nil }
func (_cdeef *ST_IconSetType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gbfdecg, _agcaca := d.Token()
	if _agcaca != nil {
		return _agcaca
	}
	if _fafee, _ceeacd := _gbfdecg.(_f.EndElement); _ceeacd && _fafee.Name == start.Name {
		*_cdeef = 1
		return nil
	}
	if _cadbf, _edbbac := _gbfdecg.(_f.CharData); !_edbbac {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gbfdecg)
	} else {
		switch string(_cadbf) {
		case "":
			*_cdeef = 0
		case "3Arrows":
			*_cdeef = 1
		case "3ArrowsGray":
			*_cdeef = 2
		case "3Flags":
			*_cdeef = 3
		case "3TrafficLights1":
			*_cdeef = 4
		case "3TrafficLights2":
			*_cdeef = 5
		case "3Signs":
			*_cdeef = 6
		case "3Symbols":
			*_cdeef = 7
		case "3Symbols2":
			*_cdeef = 8
		case "4Arrows":
			*_cdeef = 9
		case "4ArrowsGray":
			*_cdeef = 10
		case "4RedToBlack":
			*_cdeef = 11
		case "4Rating":
			*_cdeef = 12
		case "4TrafficLights":
			*_cdeef = 13
		case "5Arrows":
			*_cdeef = 14
		case "5ArrowsGray":
			*_cdeef = 15
		case "5Rating":
			*_cdeef = 16
		case "5Quarters":
			*_cdeef = 17
		}
	}
	_gbfdecg, _agcaca = d.Token()
	if _agcaca != nil {
		return _agcaca
	}
	if _gfcbagb, _dfeda := _gbfdecg.(_f.EndElement); _dfeda && _gfcbagb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gbfdecg)
}
func (_dadeg *CT_PageBreak) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dadeg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_dadeg.CountAttr)})
	}
	if _dadeg.ManualBreakCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "manualBreakCount"}, Value: _bg.Sprintf("\u0025v", *_dadeg.ManualBreakCountAttr)})
	}
	e.EncodeToken(start)
	if _dadeg.Brk != nil {
		_cfdbf := _f.StartElement{Name: _f.Name{Local: "ma:brk"}}
		for _, _gegdb := range _dadeg.Brk {
			e.EncodeElement(_gegdb, _cfdbf)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_afgda *CT_Font) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_faafe:
	for {
		_aaddc, _ddbef := d.Token()
		if _ddbef != nil {
			return _ddbef
		}
		switch _afabg := _aaddc.(type) {
		case _f.StartElement:
			switch _afabg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "name"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "name"}:
				_gefaad := NewCT_FontName()
				if _badcb := d.DecodeElement(_gefaad, &_afabg); _badcb != nil {
					return _badcb
				}
				_afgda.Name = append(_afgda.Name, _gefaad)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "charset"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "charset"}:
				_aeeca := NewCT_IntProperty()
				if _cgagc := d.DecodeElement(_aeeca, &_afabg); _cgagc != nil {
					return _cgagc
				}
				_afgda.Charset = append(_afgda.Charset, _aeeca)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "family"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "family"}:
				_afeaf := NewCT_FontFamily()
				if _cdcac := d.DecodeElement(_afeaf, &_afabg); _cdcac != nil {
					return _cdcac
				}
				_afgda.Family = append(_afgda.Family, _afeaf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "b"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "b"}:
				_afee := NewCT_BooleanProperty()
				if _abgbc := d.DecodeElement(_afee, &_afabg); _abgbc != nil {
					return _abgbc
				}
				_afgda.B = append(_afgda.B, _afee)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "i"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "i"}:
				_dafgc := NewCT_BooleanProperty()
				if _debee := d.DecodeElement(_dafgc, &_afabg); _debee != nil {
					return _debee
				}
				_afgda.I = append(_afgda.I, _dafgc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "strike"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "strike"}:
				_edcbd := NewCT_BooleanProperty()
				if _dedb := d.DecodeElement(_edcbd, &_afabg); _dedb != nil {
					return _dedb
				}
				_afgda.Strike = append(_afgda.Strike, _edcbd)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "outline"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "outline"}:
				_cebcga := NewCT_BooleanProperty()
				if _gebee := d.DecodeElement(_cebcga, &_afabg); _gebee != nil {
					return _gebee
				}
				_afgda.Outline = append(_afgda.Outline, _cebcga)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "shadow"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "shadow"}:
				_ccbfe := NewCT_BooleanProperty()
				if _gebff := d.DecodeElement(_ccbfe, &_afabg); _gebff != nil {
					return _gebff
				}
				_afgda.Shadow = append(_afgda.Shadow, _ccbfe)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "condense"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "condense"}:
				_egcd := NewCT_BooleanProperty()
				if _fbega := d.DecodeElement(_egcd, &_afabg); _fbega != nil {
					return _fbega
				}
				_afgda.Condense = append(_afgda.Condense, _egcd)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extend"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extend"}:
				_fcfa := NewCT_BooleanProperty()
				if _cfdf := d.DecodeElement(_fcfa, &_afabg); _cfdf != nil {
					return _cfdf
				}
				_afgda.Extend = append(_afgda.Extend, _fcfa)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "color"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "color"}:
				_acefa := NewCT_Color()
				if _eaff := d.DecodeElement(_acefa, &_afabg); _eaff != nil {
					return _eaff
				}
				_afgda.Color = append(_afgda.Color, _acefa)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sz"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sz"}:
				_fabfb := NewCT_FontSize()
				if _dgeef := d.DecodeElement(_fabfb, &_afabg); _dgeef != nil {
					return _dgeef
				}
				_afgda.Sz = append(_afgda.Sz, _fabfb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "u"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "u"}:
				_bfbfe := NewCT_UnderlineProperty()
				if _eafa := d.DecodeElement(_bfbfe, &_afabg); _eafa != nil {
					return _eafa
				}
				_afgda.U = append(_afgda.U, _bfbfe)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "vertAlign"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "vertAlign"}:
				_ffbdf := NewCT_VerticalAlignFontProperty()
				if _debfa := d.DecodeElement(_ffbdf, &_afabg); _debfa != nil {
					return _debfa
				}
				_afgda.VertAlign = append(_afgda.VertAlign, _ffbdf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "scheme"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "scheme"}:
				_abafc := NewCT_FontScheme()
				if _ccggc := d.DecodeElement(_abafc, &_afabg); _ccggc != nil {
					return _ccggc
				}
				_afgda.Scheme = append(_afgda.Scheme, _abafc)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Font\u0020\u0025v", _afabg.Name)
				if _gafa := d.Skip(); _gafa != nil {
					return _gafa
				}
			}
		case _f.EndElement:
			break _faafe
		case _f.CharData:
		}
	}
	return nil
}

type ST_Type byte

func (_bdecda ST_TimePeriod) String() string {
	switch _bdecda {
	case 0:
		return ""
	case 1:
		return "today"
	case 2:
		return "yesterday"
	case 3:
		return "tomorrow"
	case 4:
		return "last7Days"
	case 5:
		return "thisMonth"
	case 6:
		return "lastMonth"
	case 7:
		return "nextMonth"
	case 8:
		return "thisWeek"
	case 9:
		return "lastWeek"
	case 10:
		return "nextWeek"
	}
	return ""
}
func (_feacec ST_DataValidationErrorStyle) ValidateWithPath(path string) error {
	switch _feacec {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_feacec))
	}
	return nil
}

// ValidateWithPath validates the CT_RgbColor and its children, prefixing error messages with path
func (_afaeg *CT_RgbColor) ValidateWithPath(path string) error { return nil }
func NewCT_DiscretePr() *CT_DiscretePr                         { _fccbf := &CT_DiscretePr{}; return _fccbf }
func (_efdbg *ST_CellFormulaType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dbcba, _eagedc := d.Token()
	if _eagedc != nil {
		return _eagedc
	}
	if _gacbfb, _dcaae := _dbcba.(_f.EndElement); _dcaae && _gacbfb.Name == start.Name {
		*_efdbg = 1
		return nil
	}
	if _adgfe, _dagga := _dbcba.(_f.CharData); !_dagga {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dbcba)
	} else {
		switch string(_adgfe) {
		case "":
			*_efdbg = 0
		case "normal":
			*_efdbg = 1
		case "array":
			*_efdbg = 2
		case "dataTable":
			*_efdbg = 3
		case "shared":
			*_efdbg = 4
		}
	}
	_dbcba, _eagedc = d.Token()
	if _eagedc != nil {
		return _eagedc
	}
	if _cbefg, _cfafad := _dbcba.(_f.EndElement); _cfafad && _cbefg.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dbcba)
}
func (_adfcg *CT_DiscretePr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gcdc := range start.Attr {
		if _gcdc.Name.Local == "count" {
			_eedda, _bbgaa := _g.ParseUint(_gcdc.Value, 10, 32)
			if _bbgaa != nil {
				return _bbgaa
			}
			_aaffe := uint32(_eedda)
			_adfcg.CountAttr = &_aaffe
			continue
		}
	}
_gedcb:
	for {
		_dgac, _aafg := d.Token()
		if _aafg != nil {
			return _aafg
		}
		switch _cdae := _dgac.(type) {
		case _f.StartElement:
			switch _cdae.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "x"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "x"}:
				_cbfagc := NewCT_Index()
				if _ddgf := d.DecodeElement(_cbfagc, &_cdae); _ddgf != nil {
					return _ddgf
				}
				_adfcg.X = append(_adfcg.X, _cbfagc)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_DiscretePr \u0025v", _cdae.Name)
				if _ddfg := d.Skip(); _ddfg != nil {
					return _ddfg
				}
			}
		case _f.EndElement:
			break _gedcb
		case _f.CharData:
		}
	}
	return nil
}

type CT_ExternalReferences struct {

	// External Reference
	ExternalReference []*CT_ExternalReference
}

func (_efccdc *CT_MergeCells) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _efccdc.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_efccdc.CountAttr)})
	}
	e.EncodeToken(start)
	_cacegc := _f.StartElement{Name: _f.Name{Local: "ma:mergeCell"}}
	for _, _ebdcd := range _efccdc.MergeCell {
		e.EncodeElement(_ebdcd, _cacegc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_FieldGroup and its children
func (_eebca *CT_FieldGroup) Validate() error { return _eebca.ValidateWithPath("CT_FieldGroup") }
func (_ffaagb ST_RevisionAction) ValidateWithPath(path string) error {
	switch _ffaagb {
	case 0, 1, 2:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ffaagb))
	}
	return nil
}
func (_dgafdc ST_DdeValueType) ValidateWithPath(path string) error {
	switch _dgafdc {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dgafdc))
	}
	return nil
}
func (_efcgdg *ST_GroupBy) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ddegc, _fdcaa := d.Token()
	if _fdcaa != nil {
		return _fdcaa
	}
	if _fecaa, _faaae := _ddegc.(_f.EndElement); _faaae && _fecaa.Name == start.Name {
		*_efcgdg = 1
		return nil
	}
	if _debde, _aegbd := _ddegc.(_f.CharData); !_aegbd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ddegc)
	} else {
		switch string(_debde) {
		case "":
			*_efcgdg = 0
		case "range":
			*_efcgdg = 1
		case "seconds":
			*_efcgdg = 2
		case "minutes":
			*_efcgdg = 3
		case "hours":
			*_efcgdg = 4
		case "days":
			*_efcgdg = 5
		case "months":
			*_efcgdg = 6
		case "quarters":
			*_efcgdg = 7
		case "years":
			*_efcgdg = 8
		}
	}
	_ddegc, _fdcaa = d.Token()
	if _fdcaa != nil {
		return _fdcaa
	}
	if _aeagac, _ecfda := _ddegc.(_f.EndElement); _ecfda && _aeagac.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ddegc)
}
func (_dedfg *CT_MRUColors) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_egbgf:
	for {
		_egcagb, _ccbb := d.Token()
		if _ccbb != nil {
			return _ccbb
		}
		switch _bbead := _egcagb.(type) {
		case _f.StartElement:
			switch _bbead.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "color"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "color"}:
				_afga := NewCT_Color()
				if _fegda := d.DecodeElement(_afga, &_bbead); _fegda != nil {
					return _fegda
				}
				_dedfg.Color = append(_dedfg.Color, _afga)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_MRUColors\u0020\u0025v", _bbead.Name)
				if _fcegf := d.Skip(); _fcegf != nil {
					return _fcegf
				}
			}
		case _f.EndElement:
			break _egbgf
		case _f.CharData:
		}
	}
	return nil
}
func (_acagead ST_WebSourceType) String() string {
	switch _acagead {
	case 0:
		return ""
	case 1:
		return "sheet"
	case 2:
		return "printArea"
	case 3:
		return "autoFilter"
	case 4:
		return "range"
	case 5:
		return "chart"
	case 6:
		return "pivotTable"
	case 7:
		return "query"
	case 8:
		return "label"
	}
	return ""
}
func (_dcdag ST_Comments) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_dcdag.String(), start)
}
func NewCT_MdxMetadata() *CT_MdxMetadata { _cggea := &CT_MdxMetadata{}; return _cggea }
func (_fcfae ST_Orientation) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_fcfae.String(), start)
}
func (_caffc *CT_VerticalAlignFontProperty) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_caffc.ValAttr = _e.ST_VerticalAlignRun(1)
	for _, _cacegd := range start.Attr {
		if _cacegd.Name.Local == "val" {
			_caffc.ValAttr.UnmarshalXMLAttr(_cacegd)
			continue
		}
	}
	for {
		_eaabfc, _ecccfca := d.Token()
		if _ecccfca != nil {
			return _bg.Errorf("parsing\u0020CT_VerticalAlignFontProperty: \u0025s", _ecccfca)
		}
		if _adabda, _fgefd := _eaabfc.(_f.EndElement); _fgefd && _adabda.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_GradientTypeUnset  ST_GradientType = 0
	ST_GradientTypeLinear ST_GradientType = 1
	ST_GradientTypePath   ST_GradientType = 2
)

func (_bababf *CT_Members) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gggce := range start.Attr {
		if _gggce.Name.Local == "count" {
			_fcgea, _fggca := _g.ParseUint(_gggce.Value, 10, 32)
			if _fggca != nil {
				return _fggca
			}
			_gacec := uint32(_fcgea)
			_bababf.CountAttr = &_gacec
			continue
		}
		if _gggce.Name.Local == "level" {
			_aeaba, _ebebd := _g.ParseUint(_gggce.Value, 10, 32)
			if _ebebd != nil {
				return _ebebd
			}
			_dbbafa := uint32(_aeaba)
			_bababf.LevelAttr = &_dbbafa
			continue
		}
	}
_fdee:
	for {
		_bbaf, _dcbce := d.Token()
		if _dcbce != nil {
			return _dcbce
		}
		switch _cbfde := _bbaf.(type) {
		case _f.StartElement:
			switch _cbfde.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "member"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "member"}:
				_egdae := NewCT_Member()
				if _cfgbde := d.DecodeElement(_egdae, &_cbfde); _cfgbde != nil {
					return _cfgbde
				}
				_bababf.Member = append(_bababf.Member, _egdae)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_Members\u0020\u0025v", _cbfde.Name)
				if _dfgbb := d.Skip(); _dfgbb != nil {
					return _dfgbb
				}
			}
		case _f.EndElement:
			break _fdee
		case _f.CharData:
		}
	}
	return nil
}
func (_ecdcbg ST_ItemType) String() string {
	switch _ecdcbg {
	case 0:
		return ""
	case 1:
		return "data"
	case 2:
		return "default"
	case 3:
		return "sum"
	case 4:
		return "countA"
	case 5:
		return "avg"
	case 6:
		return "max"
	case 7:
		return "min"
	case 8:
		return "product"
	case 9:
		return "count"
	case 10:
		return "stdDev"
	case 11:
		return "stdDevP"
	case 12:
		return "var"
	case 13:
		return "varP"
	case 14:
		return "grand"
	case 15:
		return "blank"
	}
	return ""
}

// ValidateWithPath validates the CT_PhoneticPr and its children, prefixing error messages with path
func (_ggfdc *CT_PhoneticPr) ValidateWithPath(path string) error {
	if _feacff := _ggfdc.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _feacff != nil {
		return _feacff
	}
	if _ggfaf := _ggfdc.AlignmentAttr.ValidateWithPath(path + "\u002fAlignmentAttr"); _ggfaf != nil {
		return _ggfaf
	}
	return nil
}

// Validate validates the CT_DataBar and its children
func (_gffe *CT_DataBar) Validate() error { return _gffe.ValidateWithPath("CT_DataBar") }
func (_fbdab ST_DataValidationOperator) String() string {
	switch _fbdab {
	case 0:
		return ""
	case 1:
		return "between"
	case 2:
		return "notBetween"
	case 3:
		return "equal"
	case 4:
		return "notEqual"
	case 5:
		return "lessThan"
	case 6:
		return "lessThanOrEqual"
	case 7:
		return "greaterThan"
	case 8:
		return "greaterThanOrEqual"
	}
	return ""
}
func (_gcede *Users) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:users"
	return _gcede.CT_Users.MarshalXML(e, start)
}

type CT_DdeLink struct {

	// Service name
	DdeServiceAttr string

	// Topic for DDE server
	DdeTopicAttr string

	// DDE Items Collection
	DdeItems *CT_DdeItems
}

func (_ebfc *CT_CustomSheetView) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "guid"}, Value: _bg.Sprintf("\u0025v", _ebfc.GuidAttr)})
	if _ebfc.ScaleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "scale"}, Value: _bg.Sprintf("\u0025v", *_ebfc.ScaleAttr)})
	}
	if _ebfc.ColorIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "colorId"}, Value: _bg.Sprintf("\u0025v", *_ebfc.ColorIdAttr)})
	}
	if _ebfc.ShowPageBreaksAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showPageBreaks"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.ShowPageBreaksAttr))})
	}
	if _ebfc.ShowFormulasAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showFormulas"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.ShowFormulasAttr))})
	}
	if _ebfc.ShowGridLinesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showGridLines"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.ShowGridLinesAttr))})
	}
	if _ebfc.ShowRowColAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showRowCol"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.ShowRowColAttr))})
	}
	if _ebfc.OutlineSymbolsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "outlineSymbols"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.OutlineSymbolsAttr))})
	}
	if _ebfc.ZeroValuesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "zeroValues"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.ZeroValuesAttr))})
	}
	if _ebfc.FitToPageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fitToPage"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.FitToPageAttr))})
	}
	if _ebfc.PrintAreaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "printArea"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.PrintAreaAttr))})
	}
	if _ebfc.FilterAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "filter"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.FilterAttr))})
	}
	if _ebfc.ShowAutoFilterAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showAutoFilter"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.ShowAutoFilterAttr))})
	}
	if _ebfc.HiddenRowsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hiddenRows"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.HiddenRowsAttr))})
	}
	if _ebfc.HiddenColumnsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hiddenColumns"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.HiddenColumnsAttr))})
	}
	if _ebfc.StateAttr != ST_SheetStateUnset {
		_cdbd, _fecc := _ebfc.StateAttr.MarshalXMLAttr(_f.Name{Local: "state"})
		if _fecc != nil {
			return _fecc
		}
		start.Attr = append(start.Attr, _cdbd)
	}
	if _ebfc.FilterUniqueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "filterUnique"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.FilterUniqueAttr))})
	}
	if _ebfc.ViewAttr != ST_SheetViewTypeUnset {
		_cgfag, _ebde := _ebfc.ViewAttr.MarshalXMLAttr(_f.Name{Local: "view"})
		if _ebde != nil {
			return _ebde
		}
		start.Attr = append(start.Attr, _cgfag)
	}
	if _ebfc.ShowRulerAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showRuler"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ebfc.ShowRulerAttr))})
	}
	if _ebfc.TopLeftCellAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "topLeftCell"}, Value: _bg.Sprintf("\u0025v", *_ebfc.TopLeftCellAttr)})
	}
	e.EncodeToken(start)
	if _ebfc.Pane != nil {
		_bega := _f.StartElement{Name: _f.Name{Local: "ma:pane"}}
		e.EncodeElement(_ebfc.Pane, _bega)
	}
	if _ebfc.Selection != nil {
		_ccbcd := _f.StartElement{Name: _f.Name{Local: "ma:selection"}}
		e.EncodeElement(_ebfc.Selection, _ccbcd)
	}
	if _ebfc.RowBreaks != nil {
		_fbfa := _f.StartElement{Name: _f.Name{Local: "ma:rowBreaks"}}
		e.EncodeElement(_ebfc.RowBreaks, _fbfa)
	}
	if _ebfc.ColBreaks != nil {
		_adaee := _f.StartElement{Name: _f.Name{Local: "ma:colBreaks"}}
		e.EncodeElement(_ebfc.ColBreaks, _adaee)
	}
	if _ebfc.PageMargins != nil {
		_bfbb := _f.StartElement{Name: _f.Name{Local: "ma:pageMargins"}}
		e.EncodeElement(_ebfc.PageMargins, _bfbb)
	}
	if _ebfc.PrintOptions != nil {
		_ccfg := _f.StartElement{Name: _f.Name{Local: "ma:printOptions"}}
		e.EncodeElement(_ebfc.PrintOptions, _ccfg)
	}
	if _ebfc.PageSetup != nil {
		_fegc := _f.StartElement{Name: _f.Name{Local: "ma:pageSetup"}}
		e.EncodeElement(_ebfc.PageSetup, _fegc)
	}
	if _ebfc.HeaderFooter != nil {
		_gbbcc := _f.StartElement{Name: _f.Name{Local: "ma:headerFooter"}}
		e.EncodeElement(_ebfc.HeaderFooter, _gbbcc)
	}
	if _ebfc.AutoFilter != nil {
		_gcbba := _f.StartElement{Name: _f.Name{Local: "ma:autoFilter"}}
		e.EncodeElement(_ebfc.AutoFilter, _gcbba)
	}
	if _ebfc.ExtLst != nil {
		_feec := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_ebfc.ExtLst, _feec)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

const (
	ST_WebSourceTypeUnset      ST_WebSourceType = 0
	ST_WebSourceTypeSheet      ST_WebSourceType = 1
	ST_WebSourceTypePrintArea  ST_WebSourceType = 2
	ST_WebSourceTypeAutoFilter ST_WebSourceType = 3
	ST_WebSourceTypeRange      ST_WebSourceType = 4
	ST_WebSourceTypeChart      ST_WebSourceType = 5
	ST_WebSourceTypePivotTable ST_WebSourceType = 6
	ST_WebSourceTypeQuery      ST_WebSourceType = 7
	ST_WebSourceTypeLabel      ST_WebSourceType = 8
)

// ValidateWithPath validates the CT_CustomWorkbookViews and its children, prefixing error messages with path
func (_ffee *CT_CustomWorkbookViews) ValidateWithPath(path string) error {
	for _gdcd, _badeg := range _ffee.CustomWorkbookView {
		if _edgde := _badeg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCustomWorkbookView\u005b\u0025d]", path, _gdcd)); _edgde != nil {
			return _edgde
		}
	}
	return nil
}

type CT_TextFields struct {

	// Count of Fields
	CountAttr *uint32

	// Text Import Field Settings
	TextField []*CT_TextField
}

func NewCT_Formats() *CT_Formats { _caeca := &CT_Formats{}; return _caeca }

// ValidateWithPath validates the CT_SheetId and its children, prefixing error messages with path
func (_bbcf *CT_SheetId) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_ExternalRow and its children
func (_dged *CT_ExternalRow) Validate() error { return _dged.ValidateWithPath("CT_ExternalRow") }
func (_aafe *CT_Colors) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_egbbc:
	for {
		_gebb, _efbe := d.Token()
		if _efbe != nil {
			return _efbe
		}
		switch _cddf := _gebb.(type) {
		case _f.StartElement:
			switch _cddf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "indexedColors"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "indexedColors"}:
				_aafe.IndexedColors = NewCT_IndexedColors()
				if _eafg := d.DecodeElement(_aafe.IndexedColors, &_cddf); _eafg != nil {
					return _eafg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "mruColors"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "mruColors"}:
				_aafe.MruColors = NewCT_MRUColors()
				if _fgcef := d.DecodeElement(_aafe.MruColors, &_cddf); _fgcef != nil {
					return _fgcef
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_Colors \u0025v", _cddf.Name)
				if _gcdd := d.Skip(); _gcdd != nil {
					return _gcdd
				}
			}
		case _f.EndElement:
			break _egbbc
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_PageBreak and its children
func (_cddaf *CT_PageBreak) Validate() error { return _cddaf.ValidateWithPath("CT_PageBreak") }

type CT_PageBreak struct {

	// Page Break Count
	CountAttr *uint32

	// Manual Break Count
	ManualBreakCountAttr *uint32

	// Break
	Brk []*CT_Break
}

func (_feddfg ST_PhoneticType) String() string {
	switch _feddfg {
	case 0:
		return ""
	case 1:
		return "halfwidthKatakana"
	case 2:
		return "fullwidthKatakana"
	case 3:
		return "Hiragana"
	case 4:
		return "noConversion"
	}
	return ""
}

// Validate validates the CT_PatternFill and its children
func (_gcbdeg *CT_PatternFill) Validate() error { return _gcbdeg.ValidateWithPath("CT_PatternFill") }

// Validate validates the CT_IndexedColors and its children
func (_eacfgd *CT_IndexedColors) Validate() error {
	return _eacfgd.ValidateWithPath("CT_IndexedColors")
}
func NewCT_Table() *CT_Table {
	_eebfee := &CT_Table{}
	_eebfee.TableColumns = NewCT_TableColumns()
	return _eebfee
}
func (_gcga *CT_Connections) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_fcbgf:
	for {
		_cedc, _aefe := d.Token()
		if _aefe != nil {
			return _aefe
		}
		switch _ddab := _cedc.(type) {
		case _f.StartElement:
			switch _ddab.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "connection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "connection"}:
				_eedd := NewCT_Connection()
				if _abdb := d.DecodeElement(_eedd, &_ddab); _abdb != nil {
					return _abdb
				}
				_gcga.Connection = append(_gcga.Connection, _eedd)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Connections\u0020\u0025v", _ddab.Name)
				if _eedf := d.Skip(); _eedf != nil {
					return _eedf
				}
			}
		case _f.EndElement:
			break _fcbgf
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_MeasureDimensionMaps and its children, prefixing error messages with path
func (_ddea *CT_MeasureDimensionMaps) ValidateWithPath(path string) error {
	for _fbebf, _fccc := range _ddea.Map {
		if _abfag := _fccc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fMap\u005b\u0025d\u005d", path, _fbebf)); _abfag != nil {
			return _abfag
		}
	}
	return nil
}

const (
	ST_CalcModeUnset       ST_CalcMode = 0
	ST_CalcModeManual      ST_CalcMode = 1
	ST_CalcModeAuto        ST_CalcMode = 2
	ST_CalcModeAutoNoTable ST_CalcMode = 3
)

func (_aaedf *CT_GradientFill) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bfgee := range start.Attr {
		if _bfgee.Name.Local == "type" {
			_aaedf.TypeAttr.UnmarshalXMLAttr(_bfgee)
			continue
		}
		if _bfgee.Name.Local == "degree" {
			_afdg, _cegb := _g.ParseFloat(_bfgee.Value, 64)
			if _cegb != nil {
				return _cegb
			}
			_aaedf.DegreeAttr = &_afdg
			continue
		}
		if _bfgee.Name.Local == "left" {
			_bacbe, _deeeb := _g.ParseFloat(_bfgee.Value, 64)
			if _deeeb != nil {
				return _deeeb
			}
			_aaedf.LeftAttr = &_bacbe
			continue
		}
		if _bfgee.Name.Local == "right" {
			_beefc, _ggfce := _g.ParseFloat(_bfgee.Value, 64)
			if _ggfce != nil {
				return _ggfce
			}
			_aaedf.RightAttr = &_beefc
			continue
		}
		if _bfgee.Name.Local == "top" {
			_fdcab, _bbgb := _g.ParseFloat(_bfgee.Value, 64)
			if _bbgb != nil {
				return _bbgb
			}
			_aaedf.TopAttr = &_fdcab
			continue
		}
		if _bfgee.Name.Local == "bottom" {
			_dccdd, _aacgb := _g.ParseFloat(_bfgee.Value, 64)
			if _aacgb != nil {
				return _aacgb
			}
			_aaedf.BottomAttr = &_dccdd
			continue
		}
	}
_ffbf:
	for {
		_cfbfg, _aegdf := d.Token()
		if _aegdf != nil {
			return _aegdf
		}
		switch _ddec := _cfbfg.(type) {
		case _f.StartElement:
			switch _ddec.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "stop"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "stop"}:
				_bcaee := NewCT_GradientStop()
				if _abbbb := d.DecodeElement(_bcaee, &_ddec); _abbbb != nil {
					return _abbbb
				}
				_aaedf.Stop = append(_aaedf.Stop, _bcaee)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GradientFill\u0020\u0025v", _ddec.Name)
				if _dbece := d.Skip(); _dbece != nil {
					return _dbece
				}
			}
		case _f.EndElement:
			break _ffbf
		case _f.CharData:
		}
	}
	return nil
}
func (_febea ST_DvAspect) Validate() error { return _febea.ValidateWithPath("") }

type CT_CalcPr struct {

	// Calculation Id
	CalcIdAttr *uint32

	// Calculation Mode
	CalcModeAttr ST_CalcMode

	// Full Calculation On Load
	FullCalcOnLoadAttr *bool

	// Reference Mode
	RefModeAttr ST_RefMode

	// Calculation Iteration
	IterateAttr *bool

	// Iteration Count
	IterateCountAttr *uint32

	// Iterative Calculation Delta
	IterateDeltaAttr *float64

	// Full Precision Calculation
	FullPrecisionAttr *bool

	// Calc Completed
	CalcCompletedAttr *bool

	// Calculate On Save
	CalcOnSaveAttr *bool

	// Concurrent Calculations
	ConcurrentCalcAttr *bool

	// Concurrent Thread Manual Count
	ConcurrentManualCountAttr *uint32

	// Force Full Calculation
	ForceFullCalcAttr *bool
}
type CT_Borders struct {

	// Border Count
	CountAttr *uint32

	// Border
	Border []*CT_Border
}

// Validate validates the QueryTable and its children
func (_aeded *QueryTable) Validate() error { return _aeded.ValidateWithPath("QueryTable") }
func (_dadde *CT_Worksheet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dadde.SheetData = NewCT_SheetData()
_fbbcbg:
	for {
		_aaafg, _fcaff := d.Token()
		if _fcaff != nil {
			return _fcaff
		}
		switch _fdcede := _aaafg.(type) {
		case _f.StartElement:
			switch _fdcede.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetPr"}:
				_dadde.SheetPr = NewCT_SheetPr()
				if _ebgdf := d.DecodeElement(_dadde.SheetPr, &_fdcede); _ebgdf != nil {
					return _ebgdf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dimension"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dimension"}:
				_dadde.Dimension = NewCT_SheetDimension()
				if _gfecbe := d.DecodeElement(_dadde.Dimension, &_fdcede); _gfecbe != nil {
					return _gfecbe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetViews"}:
				_dadde.SheetViews = NewCT_SheetViews()
				if _ecabfg := d.DecodeElement(_dadde.SheetViews, &_fdcede); _ecabfg != nil {
					return _ecabfg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetFormatPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetFormatPr"}:
				_dadde.SheetFormatPr = NewCT_SheetFormatPr()
				if _abcbce := d.DecodeElement(_dadde.SheetFormatPr, &_fdcede); _abcbce != nil {
					return _abcbce
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cols"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cols"}:
				_ffdae := NewCT_Cols()
				if _gdcca := d.DecodeElement(_ffdae, &_fdcede); _gdcca != nil {
					return _gdcca
				}
				_dadde.Cols = append(_dadde.Cols, _ffdae)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetData"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetData"}:
				if _eegdb := d.DecodeElement(_dadde.SheetData, &_fdcede); _eegdb != nil {
					return _eegdb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetCalcPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetCalcPr"}:
				_dadde.SheetCalcPr = NewCT_SheetCalcPr()
				if _eegdfd := d.DecodeElement(_dadde.SheetCalcPr, &_fdcede); _eegdfd != nil {
					return _eegdfd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetProtection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetProtection"}:
				_dadde.SheetProtection = NewCT_SheetProtection()
				if _ccbee := d.DecodeElement(_dadde.SheetProtection, &_fdcede); _ccbee != nil {
					return _ccbee
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "protectedRanges"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "protectedRanges"}:
				_dadde.ProtectedRanges = NewCT_ProtectedRanges()
				if _efcagf := d.DecodeElement(_dadde.ProtectedRanges, &_fdcede); _efcagf != nil {
					return _efcagf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "scenarios"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "scenarios"}:
				_dadde.Scenarios = NewCT_Scenarios()
				if _gcdcc := d.DecodeElement(_dadde.Scenarios, &_fdcede); _gcdcc != nil {
					return _gcdcc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "autoFilter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "autoFilter"}:
				_dadde.AutoFilter = NewCT_AutoFilter()
				if _gbagg := d.DecodeElement(_dadde.AutoFilter, &_fdcede); _gbagg != nil {
					return _gbagg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sortState"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sortState"}:
				_dadde.SortState = NewCT_SortState()
				if _abeeg := d.DecodeElement(_dadde.SortState, &_fdcede); _abeeg != nil {
					return _abeeg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataConsolidate"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataConsolidate"}:
				_dadde.DataConsolidate = NewCT_DataConsolidate()
				if _adgfg := d.DecodeElement(_dadde.DataConsolidate, &_fdcede); _adgfg != nil {
					return _adgfg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customSheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customSheetViews"}:
				_dadde.CustomSheetViews = NewCT_CustomSheetViews()
				if _dbag := d.DecodeElement(_dadde.CustomSheetViews, &_fdcede); _dbag != nil {
					return _dbag
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "mergeCells"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "mergeCells"}:
				_dadde.MergeCells = NewCT_MergeCells()
				if _fdgfd := d.DecodeElement(_dadde.MergeCells, &_fdcede); _fdgfd != nil {
					return _fdgfd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "phoneticPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "phoneticPr"}:
				_dadde.PhoneticPr = NewCT_PhoneticPr()
				if _aggag := d.DecodeElement(_dadde.PhoneticPr, &_fdcede); _aggag != nil {
					return _aggag
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "conditionalFormatting"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "conditionalFormatting"}:
				_bdbca := NewCT_ConditionalFormatting()
				if _dbcddf := d.DecodeElement(_bdbca, &_fdcede); _dbcddf != nil {
					return _dbcddf
				}
				_dadde.ConditionalFormatting = append(_dadde.ConditionalFormatting, _bdbca)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataValidations"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataValidations"}:
				_dadde.DataValidations = NewCT_DataValidations()
				if _egbgce := d.DecodeElement(_dadde.DataValidations, &_fdcede); _egbgce != nil {
					return _egbgce
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "hyperlinks"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "hyperlinks"}:
				_dadde.Hyperlinks = NewCT_Hyperlinks()
				if _aeaff := d.DecodeElement(_dadde.Hyperlinks, &_fdcede); _aeaff != nil {
					return _aeaff
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "printOptions"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "printOptions"}:
				_dadde.PrintOptions = NewCT_PrintOptions()
				if _ceafg := d.DecodeElement(_dadde.PrintOptions, &_fdcede); _ceafg != nil {
					return _ceafg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageMargins"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageMargins"}:
				_dadde.PageMargins = NewCT_PageMargins()
				if _bbafg := d.DecodeElement(_dadde.PageMargins, &_fdcede); _bbafg != nil {
					return _bbafg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageSetup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageSetup"}:
				_dadde.PageSetup = NewCT_PageSetup()
				if _fgeegb := d.DecodeElement(_dadde.PageSetup, &_fdcede); _fgeegb != nil {
					return _fgeegb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "headerFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "headerFooter"}:
				_dadde.HeaderFooter = NewCT_HeaderFooter()
				if _aggfd := d.DecodeElement(_dadde.HeaderFooter, &_fdcede); _aggfd != nil {
					return _aggfd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rowBreaks"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rowBreaks"}:
				_dadde.RowBreaks = NewCT_PageBreak()
				if _dgdddc := d.DecodeElement(_dadde.RowBreaks, &_fdcede); _dgdddc != nil {
					return _dgdddc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colBreaks"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colBreaks"}:
				_dadde.ColBreaks = NewCT_PageBreak()
				if _cdafb := d.DecodeElement(_dadde.ColBreaks, &_fdcede); _cdafb != nil {
					return _cdafb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customProperties"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customProperties"}:
				_dadde.CustomProperties = NewCT_CustomProperties()
				if _eefag := d.DecodeElement(_dadde.CustomProperties, &_fdcede); _eefag != nil {
					return _eefag
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellWatches"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellWatches"}:
				_dadde.CellWatches = NewCT_CellWatches()
				if _caadg := d.DecodeElement(_dadde.CellWatches, &_fdcede); _caadg != nil {
					return _caadg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ignoredErrors"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ignoredErrors"}:
				_dadde.IgnoredErrors = NewCT_IgnoredErrors()
				if _affga := d.DecodeElement(_dadde.IgnoredErrors, &_fdcede); _affga != nil {
					return _affga
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "smartTags"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "smartTags"}:
				_dadde.SmartTags = NewCT_SmartTags()
				if _bdcga := d.DecodeElement(_dadde.SmartTags, &_fdcede); _bdcga != nil {
					return _bdcga
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawing"}:
				_dadde.Drawing = NewCT_Drawing()
				if _cbcage := d.DecodeElement(_dadde.Drawing, &_fdcede); _cbcage != nil {
					return _cbcage
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawing"}:
				_dadde.LegacyDrawing = NewCT_LegacyDrawing()
				if _ecabff := d.DecodeElement(_dadde.LegacyDrawing, &_fdcede); _ecabff != nil {
					return _ecabff
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawingHF"}:
				_dadde.LegacyDrawingHF = NewCT_LegacyDrawing()
				if _eaffg := d.DecodeElement(_dadde.LegacyDrawingHF, &_fdcede); _eaffg != nil {
					return _eaffg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawingHF"}:
				_dadde.DrawingHF = NewCT_DrawingHF()
				if _dcbabg := d.DecodeElement(_dadde.DrawingHF, &_fdcede); _dcbabg != nil {
					return _dcbabg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "picture"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "picture"}:
				_dadde.Picture = NewCT_SheetBackgroundPicture()
				if _abegg := d.DecodeElement(_dadde.Picture, &_fdcede); _abegg != nil {
					return _abegg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleObjects"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleObjects"}:
				_dadde.OleObjects = NewCT_OleObjects()
				if _dcfag := d.DecodeElement(_dadde.OleObjects, &_fdcede); _dcfag != nil {
					return _dcfag
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "controls"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "controls"}:
				_dadde.Controls = NewCT_Controls()
				if _egggb := d.DecodeElement(_dadde.Controls, &_fdcede); _egggb != nil {
					return _egggb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "webPublishItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "webPublishItems"}:
				_dadde.WebPublishItems = NewCT_WebPublishItems()
				if _aecdd := d.DecodeElement(_dadde.WebPublishItems, &_fdcede); _aecdd != nil {
					return _aecdd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tableParts"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tableParts"}:
				_dadde.TableParts = NewCT_TableParts()
				if _cdgfa := d.DecodeElement(_dadde.TableParts, &_fdcede); _cdgfa != nil {
					return _cdgfa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_dadde.ExtLst = NewCT_ExtensionList()
				if _cggagf := d.DecodeElement(_dadde.ExtLst, &_fdcede); _cggagf != nil {
					return _cggagf
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Worksheet\u0020\u0025v", _fdcede.Name)
				if _dgeca := d.Skip(); _dgeca != nil {
					return _dgeca
				}
			}
		case _f.EndElement:
			break _fbbcbg
		case _f.CharData:
		}
	}
	return nil
}
func (_fedcfc *ST_TargetScreenSize) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_egbeb, _adfcag := d.Token()
	if _adfcag != nil {
		return _adfcag
	}
	if _eggada, _gebeeb := _egbeb.(_f.EndElement); _gebeeb && _eggada.Name == start.Name {
		*_fedcfc = 1
		return nil
	}
	if _fcggd, _agfdb := _egbeb.(_f.CharData); !_agfdb {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _egbeb)
	} else {
		switch string(_fcggd) {
		case "":
			*_fedcfc = 0
		case "544x376":
			*_fedcfc = 1
		case "640x480":
			*_fedcfc = 2
		case "720x512":
			*_fedcfc = 3
		case "800x600":
			*_fedcfc = 4
		case "1024x768":
			*_fedcfc = 5
		case "1152x882":
			*_fedcfc = 6
		case "1152x900":
			*_fedcfc = 7
		case "1280x1024":
			*_fedcfc = 8
		case "1600x1200":
			*_fedcfc = 9
		case "1800x1440":
			*_fedcfc = 10
		case "1920x1200":
			*_fedcfc = 11
		}
	}
	_egbeb, _adfcag = d.Token()
	if _adfcag != nil {
		return _adfcag
	}
	if _dafbbc, _ecedf := _egbeb.(_f.EndElement); _ecedf && _dafbbc.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _egbeb)
}
func (_gbdcea ST_GroupBy) ValidateWithPath(path string) error {
	switch _gbdcea {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gbdcea))
	}
	return nil
}
func NewCT_RevisionHeaders() *CT_RevisionHeaders {
	_bafde := &CT_RevisionHeaders{}
	_bafde.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	return _bafde
}
func (_ccgbb *CT_OleItem) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _ccgbb.NameAttr)})
	if _ccgbb.IconAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "icon"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ccgbb.IconAttr))})
	}
	if _ccgbb.AdviseAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "advise"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ccgbb.AdviseAttr))})
	}
	if _ccgbb.PreferPicAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "preferPic"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ccgbb.PreferPicAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_CustomWorkbookViews struct {

	// Custom Workbook View
	CustomWorkbookView []*CT_CustomWorkbookView
}

func (_bgcbbc *ST_Objects) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bgcbbc = 0
	case "all":
		*_bgcbbc = 1
	case "placeholders":
		*_bgcbbc = 2
	case "none":
		*_bgcbbc = 3
	}
	return nil
}
func NewCT_DataRef() *CT_DataRef { _dagaf := &CT_DataRef{}; return _dagaf }

type CT_WebPublishing struct {

	// Use CSS
	CssAttr *bool

	// Thicket
	ThicketAttr *bool

	// Enable Long File Names
	LongFileNamesAttr *bool

	// VML in Browsers
	VmlAttr *bool

	// Allow PNG
	AllowPngAttr *bool

	// Target Screen Size
	TargetScreenSizeAttr ST_TargetScreenSize

	// DPI
	DpiAttr *uint32

	// Code Page
	CodePageAttr *uint32

	// Character Set
	CharacterSetAttr *string
}

func (_eegde ST_RevisionAction) Validate() error { return _eegde.ValidateWithPath("") }

// ValidateWithPath validates the CT_XmlCellPr and its children, prefixing error messages with path
func (_eeedc *CT_XmlCellPr) ValidateWithPath(path string) error {
	if _bfgcde := _eeedc.XmlPr.ValidateWithPath(path + "\u002fXmlPr"); _bfgcde != nil {
		return _bfgcde
	}
	if _eeedc.ExtLst != nil {
		if _ecfga := _eeedc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ecfga != nil {
			return _ecfga
		}
	}
	return nil
}
func (_cgegc *CT_RevisionInsertSheet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetId"}, Value: _bg.Sprintf("\u0025v", _cgegc.SheetIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _cgegc.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetPosition"}, Value: _bg.Sprintf("\u0025v", _cgegc.SheetPositionAttr)})
	if _cgegc.RIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rId"}, Value: _bg.Sprintf("\u0025v", *_cgegc.RIdAttr)})
	}
	if _cgegc.UaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ua"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cgegc.UaAttr))})
	}
	if _cgegc.RaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ra"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cgegc.RaAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_eageg *CT_QueryCache) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _edbff := range start.Attr {
		if _edbff.Name.Local == "count" {
			_fdcec, _edffa := _g.ParseUint(_edbff.Value, 10, 32)
			if _edffa != nil {
				return _edffa
			}
			_deabe := uint32(_fdcec)
			_eageg.CountAttr = &_deabe
			continue
		}
	}
_facec:
	for {
		_cedgc, _dgegf := d.Token()
		if _dgegf != nil {
			return _dgegf
		}
		switch _defag := _cedgc.(type) {
		case _f.StartElement:
			switch _defag.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "query"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "query"}:
				_cedgd := NewCT_Query()
				if _fcaegd := d.DecodeElement(_cedgd, &_defag); _fcaegd != nil {
					return _fcaegd
				}
				_eageg.Query = append(_eageg.Query, _cedgd)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_QueryCache \u0025v", _defag.Name)
				if _abceg := d.Skip(); _abceg != nil {
					return _abceg
				}
			}
		case _f.EndElement:
			break _facec
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_VolTypes() *CT_VolTypes { _bdfea := &CT_VolTypes{}; return _bdfea }
func NewCT_TextPr() *CT_TextPr     { _fcceag := &CT_TextPr{}; return _fcceag }

// ValidateWithPath validates the CT_DataFields and its children, prefixing error messages with path
func (_gdaac *CT_DataFields) ValidateWithPath(path string) error {
	for _ffdcf, _abfgg := range _gdaac.DataField {
		if _bdcdg := _abfgg.ValidateWithPath(_bg.Sprintf("\u0025s/DataField\u005b\u0025d\u005d", path, _ffdcf)); _bdcdg != nil {
			return _bdcdg
		}
	}
	return nil
}
func (_dbafdf ST_Qualifier) ValidateWithPath(path string) error {
	switch _dbafdf {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dbafdf))
	}
	return nil
}

// ValidateWithPath validates the CT_PCDSCPage and its children, prefixing error messages with path
func (_daagg *CT_PCDSCPage) ValidateWithPath(path string) error {
	for _bfgff, _gdfee := range _daagg.PageItem {
		if _eccdcf := _gdfee.ValidateWithPath(_bg.Sprintf("\u0025s\u002fPageItem\u005b\u0025d\u005d", path, _bfgff)); _eccdcf != nil {
			return _eccdcf
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SingleXmlCells and its children, prefixing error messages with path
func (_dgecdf *CT_SingleXmlCells) ValidateWithPath(path string) error {
	for _cbcfec, _gcbc := range _dgecdf.SingleXmlCell {
		if _eaefd := _gcbc.ValidateWithPath(_bg.Sprintf("%s/SingleXmlCell[%d\u005d", path, _cbcfec)); _eaefd != nil {
			return _eaefd
		}
	}
	return nil
}
func (_deacd *CT_PhoneticPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _edegc := range start.Attr {
		if _edegc.Name.Local == "fontId" {
			_abcc, _agdac := _g.ParseUint(_edegc.Value, 10, 32)
			if _agdac != nil {
				return _agdac
			}
			_deacd.FontIdAttr = uint32(_abcc)
			continue
		}
		if _edegc.Name.Local == "type" {
			_deacd.TypeAttr.UnmarshalXMLAttr(_edegc)
			continue
		}
		if _edegc.Name.Local == "alignment" {
			_deacd.AlignmentAttr.UnmarshalXMLAttr(_edegc)
			continue
		}
	}
	for {
		_afcdb, _gdabg := d.Token()
		if _gdabg != nil {
			return _bg.Errorf("parsing\u0020CT_PhoneticPr:\u0020\u0025s", _gdabg)
		}
		if _aaagab, _ggdbb := _afcdb.(_f.EndElement); _ggdbb && _aaagab.Name == start.Name {
			break
		}
	}
	return nil
}

type Sst struct{ CT_Sst }

func NewCT_Dimensions() *CT_Dimensions { _acbga := &CT_Dimensions{}; return _acbga }

// ValidateWithPath validates the CT_Cfvo and its children, prefixing error messages with path
func (_bagaa *CT_Cfvo) ValidateWithPath(path string) error {
	if _bagaa.TypeAttr == ST_CfvoTypeUnset {
		return _bg.Errorf("\u0025s\u002fTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _dbegg := _bagaa.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _dbegg != nil {
		return _dbegg
	}
	if _bagaa.ExtLst != nil {
		if _fdfa := _bagaa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fdfa != nil {
			return _fdfa
		}
	}
	return nil
}
func NewCT_PageMargins() *CT_PageMargins { _ceaca := &CT_PageMargins{}; return _ceaca }
func (_dbfdgg *CT_RevisionCustomView) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dbfdgg.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	_dbfdgg.ActionAttr = ST_RevisionAction(1)
	for _, _ggagaf := range start.Attr {
		if _ggagaf.Name.Local == "guid" {
			_adafca, _abdda := _ggagaf.Value, error(nil)
			if _abdda != nil {
				return _abdda
			}
			_dbfdgg.GuidAttr = _adafca
			continue
		}
		if _ggagaf.Name.Local == "action" {
			_dbfdgg.ActionAttr.UnmarshalXMLAttr(_ggagaf)
			continue
		}
	}
	for {
		_agbfe, _dcdcf := d.Token()
		if _dcdcf != nil {
			return _bg.Errorf("parsing\u0020CT_RevisionCustomView:\u0020\u0025s", _dcdcf)
		}
		if _dfaedd, _dcgd := _agbfe.(_f.EndElement); _dcgd && _dfaedd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fagbd *CT_Item) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fagbd.NAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "n"}, Value: _bg.Sprintf("\u0025v", *_fagbd.NAttr)})
	}
	if _fagbd.TAttr != ST_ItemTypeUnset {
		_egfefb, _bcbbgf := _fagbd.TAttr.MarshalXMLAttr(_f.Name{Local: "t"})
		if _bcbbgf != nil {
			return _bcbbgf
		}
		start.Attr = append(start.Attr, _egfefb)
	}
	if _fagbd.HAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "h"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fagbd.HAttr))})
	}
	if _fagbd.SAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "s"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fagbd.SAttr))})
	}
	if _fagbd.SdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sd"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fagbd.SdAttr))})
	}
	if _fagbd.FAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "f"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fagbd.FAttr))})
	}
	if _fagbd.MAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "m"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fagbd.MAttr))})
	}
	if _fagbd.CAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "c"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fagbd.CAttr))})
	}
	if _fagbd.XAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "x"}, Value: _bg.Sprintf("\u0025v", *_fagbd.XAttr)})
	}
	if _fagbd.DAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "d"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fagbd.DAttr))})
	}
	if _fagbd.EAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "e"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fagbd.EAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the MapInfo and its children, prefixing error messages with path
func (_aedeef *MapInfo) ValidateWithPath(path string) error {
	if _afbfg := _aedeef.CT_MapInfo.ValidateWithPath(path); _afbfg != nil {
		return _afbfg
	}
	return nil
}
func NewCT_MetadataStringIndex() *CT_MetadataStringIndex {
	_bdegb := &CT_MetadataStringIndex{}
	return _bdegb
}

type CT_ExternalDefinedName struct {

	// Defined Name
	NameAttr string

	// Refers To
	RefersToAttr *string

	// Sheet Id
	SheetIdAttr *uint32
}

func (_defff *ST_FormatAction) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_defff = 0
	case "blank":
		*_defff = 1
	case "formatting":
		*_defff = 2
	case "drill":
		*_defff = 3
	case "formula":
		*_defff = 4
	}
	return nil
}
func NewCT_HeaderFooter() *CT_HeaderFooter { _agbcf := &CT_HeaderFooter{}; return _agbcf }
func NewCT_Sheets() *CT_Sheets             { _aaaef := &CT_Sheets{}; return _aaaef }
func (_cedee *CT_FileSharing) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _efaaf := range start.Attr {
		if _efaaf.Name.Local == "readOnlyRecommended" {
			_cebfe, _bbad := _g.ParseBool(_efaaf.Value)
			if _bbad != nil {
				return _bbad
			}
			_cedee.ReadOnlyRecommendedAttr = &_cebfe
			continue
		}
		if _efaaf.Name.Local == "userName" {
			_bcada, _cdab := _efaaf.Value, error(nil)
			if _cdab != nil {
				return _cdab
			}
			_cedee.UserNameAttr = &_bcada
			continue
		}
		if _efaaf.Name.Local == "reservationPassword" {
			_bagb, _gddegd := _efaaf.Value, error(nil)
			if _gddegd != nil {
				return _gddegd
			}
			_cedee.ReservationPasswordAttr = &_bagb
			continue
		}
		if _efaaf.Name.Local == "algorithmName" {
			_ddaea, _dced := _efaaf.Value, error(nil)
			if _dced != nil {
				return _dced
			}
			_cedee.AlgorithmNameAttr = &_ddaea
			continue
		}
		if _efaaf.Name.Local == "hashValue" {
			_efaf, _fedcff := _efaaf.Value, error(nil)
			if _fedcff != nil {
				return _fedcff
			}
			_cedee.HashValueAttr = &_efaf
			continue
		}
		if _efaaf.Name.Local == "saltValue" {
			_fegcc, _bfbea := _efaaf.Value, error(nil)
			if _bfbea != nil {
				return _bfbea
			}
			_cedee.SaltValueAttr = &_fegcc
			continue
		}
		if _efaaf.Name.Local == "spinCount" {
			_cgbcfg, _eacfg := _g.ParseUint(_efaaf.Value, 10, 32)
			if _eacfg != nil {
				return _eacfg
			}
			_aebfe := uint32(_cgbcfg)
			_cedee.SpinCountAttr = &_aebfe
			continue
		}
	}
	for {
		_egebe, _dbec := d.Token()
		if _dbec != nil {
			return _bg.Errorf("parsing\u0020CT_FileSharing:\u0020\u0025s", _dbec)
		}
		if _ccdb, _efbgb := _egebe.(_f.EndElement); _efbgb && _ccdb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bcggb ST_DataValidationErrorStyle) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_geffge := _f.Attr{}
	_geffge.Name = name
	switch _bcggb {
	case ST_DataValidationErrorStyleUnset:
		_geffge.Value = ""
	case ST_DataValidationErrorStyleStop:
		_geffge.Value = "stop"
	case ST_DataValidationErrorStyleWarning:
		_geffge.Value = "warning"
	case ST_DataValidationErrorStyleInformation:
		_geffge.Value = "information"
	}
	return _geffge, nil
}

// ValidateWithPath validates the CT_PivotAreas and its children, prefixing error messages with path
func (_efef *CT_PivotAreas) ValidateWithPath(path string) error {
	for _eaggc, _dbbga := range _efef.PivotArea {
		if _eaabf := _dbbga.ValidateWithPath(_bg.Sprintf("\u0025s/PivotArea\u005b\u0025d\u005d", path, _eaggc)); _eaabf != nil {
			return _eaabf
		}
	}
	return nil
}
func (_dgbaa ST_SourceType) ValidateWithPath(path string) error {
	switch _dgbaa {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dgbaa))
	}
	return nil
}

const (
	ST_DvAspectUnset            ST_DvAspect = 0
	ST_DvAspectDVASPECT_CONTENT ST_DvAspect = 1
	ST_DvAspectDVASPECT_ICON    ST_DvAspect = 2
)

func NewUsers() *Users { _bdbfag := &Users{}; _bdbfag.CT_Users = *NewCT_Users(); return _bdbfag }

type ST_GrowShrinkType byte

// Validate validates the CT_DdeItems and its children
func (_babbc *CT_DdeItems) Validate() error { return _babbc.ValidateWithPath("CT_DdeItems") }
func (_gbfdd *ST_Scope) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ggbfg, _fadag := d.Token()
	if _fadag != nil {
		return _fadag
	}
	if _dgfde, _ecgfa := _ggbfg.(_f.EndElement); _ecgfa && _dgfde.Name == start.Name {
		*_gbfdd = 1
		return nil
	}
	if _gbdccd, _gfgef := _ggbfg.(_f.CharData); !_gfgef {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ggbfg)
	} else {
		switch string(_gbdccd) {
		case "":
			*_gbfdd = 0
		case "selection":
			*_gbfdd = 1
		case "data":
			*_gbfdd = 2
		case "field":
			*_gbfdd = 3
		}
	}
	_ggbfg, _fadag = d.Token()
	if _fadag != nil {
		return _fadag
	}
	if _ceacbb, _aegbbd := _ggbfg.(_f.EndElement); _aegbbd && _ceacbb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ggbfg)
}
func (_dgggb *Dialogsheet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:dialogsheet"
	return _dgggb.CT_Dialogsheet.MarshalXML(e, start)
}
func NewCT_RElt() *CT_RElt { _feeegg := &CT_RElt{}; return _feeegg }
func NewCT_Rst() *CT_Rst   { _cggfe := &CT_Rst{}; return _cggfe }

type CT_WebPublishObject struct {

	// Id
	IdAttr uint32

	// Div Id
	DivIdAttr string

	// Source Object
	SourceObjectAttr *string

	// Destination File
	DestinationFileAttr string

	// Title
	TitleAttr *string

	// Auto Republish
	AutoRepublishAttr *bool
}

// Validate validates the CT_SmartTagType and its children
func (_fgfeg *CT_SmartTagType) Validate() error { return _fgfeg.ValidateWithPath("CT_SmartTagType") }
func (_aebcb *Chartsheet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:chartsheet"
	return _aebcb.CT_Chartsheet.MarshalXML(e, start)
}

type CT_Control struct {

	// Shape Id
	ShapeIdAttr uint32
	IdAttr      string

	// Control Name
	NameAttr *string

	// Embedded Control Properties
	ControlPr *CT_ControlPr
}

func (_cddeg ST_DataValidationErrorStyle) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_cddeg.String(), start)
}
func (_gdgfa *CT_PivotHierarchies) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cgfga := range start.Attr {
		if _cgfga.Name.Local == "count" {
			_aedgc, _fdedbe := _g.ParseUint(_cgfga.Value, 10, 32)
			if _fdedbe != nil {
				return _fdedbe
			}
			_adbcg := uint32(_aedgc)
			_gdgfa.CountAttr = &_adbcg
			continue
		}
	}
_bbcg:
	for {
		_cffabe, _bcfe := d.Token()
		if _bcfe != nil {
			return _bcfe
		}
		switch _agacd := _cffabe.(type) {
		case _f.StartElement:
			switch _agacd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotHierarchy"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotHierarchy"}:
				_aabed := NewCT_PivotHierarchy()
				if _cabeef := d.DecodeElement(_aabed, &_agacd); _cabeef != nil {
					return _cabeef
				}
				_gdgfa.PivotHierarchy = append(_gdgfa.PivotHierarchy, _aabed)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PivotHierarchies\u0020\u0025v", _agacd.Name)
				if _gadbd := d.Skip(); _gadbd != nil {
					return _gadbd
				}
			}
		case _f.EndElement:
			break _bbcg
		case _f.CharData:
		}
	}
	return nil
}
func (_bafabge ST_TableType) ValidateWithPath(path string) error {
	switch _bafabge {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bafabge))
	}
	return nil
}
func (_fgccc *CT_IntProperty) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gaddg := range start.Attr {
		if _gaddg.Name.Local == "val" {
			_adead, _gddda := _g.ParseInt(_gaddg.Value, 10, 32)
			if _gddda != nil {
				return _gddda
			}
			_fgccc.ValAttr = int32(_adead)
			continue
		}
	}
	for {
		_dbef, _caeec := d.Token()
		if _caeec != nil {
			return _bg.Errorf("parsing\u0020CT_IntProperty:\u0020\u0025s", _caeec)
		}
		if _bcbfac, _dbefc := _dbef.(_f.EndElement); _dbefc && _bcbfac.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_MetadataBlock and its children
func (_dcddfd *CT_MetadataBlock) Validate() error {
	return _dcddfd.ValidateWithPath("CT_MetadataBlock")
}

// ValidateWithPath validates the CT_QueryCache and its children, prefixing error messages with path
func (_gffce *CT_QueryCache) ValidateWithPath(path string) error {
	for _bdddaa, _fdaef := range _gffce.Query {
		if _fdbbea := _fdaef.ValidateWithPath(_bg.Sprintf("\u0025s\u002fQuery\u005b\u0025d\u005d", path, _bdddaa)); _fdbbea != nil {
			return _fdbbea
		}
	}
	return nil
}

// Validate validates the CT_Index and its children
func (_ddacd *CT_Index) Validate() error { return _ddacd.ValidateWithPath("CT_Index") }

const (
	ST_CfvoTypeUnset      ST_CfvoType = 0
	ST_CfvoTypeNum        ST_CfvoType = 1
	ST_CfvoTypePercent    ST_CfvoType = 2
	ST_CfvoTypeMax        ST_CfvoType = 3
	ST_CfvoTypeMin        ST_CfvoType = 4
	ST_CfvoTypeFormula    ST_CfvoType = 5
	ST_CfvoTypePercentile ST_CfvoType = 6
)

func (_gggcgg *CT_RevisionFormatting) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetId"}, Value: _bg.Sprintf("\u0025v", _gggcgg.SheetIdAttr)})
	if _gggcgg.XfDxfAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xfDxf"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gggcgg.XfDxfAttr))})
	}
	if _gggcgg.SAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "s"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gggcgg.SAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sqref"}, Value: _bg.Sprintf("\u0025v", _gggcgg.SqrefAttr)})
	if _gggcgg.StartAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "start"}, Value: _bg.Sprintf("\u0025v", *_gggcgg.StartAttr)})
	}
	if _gggcgg.LengthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "length"}, Value: _bg.Sprintf("\u0025v", *_gggcgg.LengthAttr)})
	}
	e.EncodeToken(start)
	if _gggcgg.Dxf != nil {
		_cbgca := _f.StartElement{Name: _f.Name{Local: "ma:dxf"}}
		e.EncodeElement(_gggcgg.Dxf, _cbgca)
	}
	if _gggcgg.ExtLst != nil {
		_gbegb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_gggcgg.ExtLst, _gbegb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gcfgf ST_FieldSortType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_ddegaa := _f.Attr{}
	_ddegaa.Name = name
	switch _gcfgf {
	case ST_FieldSortTypeUnset:
		_ddegaa.Value = ""
	case ST_FieldSortTypeManual:
		_ddegaa.Value = "manual"
	case ST_FieldSortTypeAscending:
		_ddegaa.Value = "ascending"
	case ST_FieldSortTypeDescending:
		_ddegaa.Value = "descending"
	}
	return _ddegaa, nil
}

type CT_DynamicFilter struct {

	// Dynamic filter type
	TypeAttr ST_DynamicFilterType

	// Value
	ValAttr *float64

	// ISO Value
	ValIsoAttr *_b.Time

	// Max Value
	MaxValAttr *float64

	// Max ISO Value
	MaxValIsoAttr *_b.Time
}

func (_gdgae *ST_CalcMode) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cdfed, _gggcfc := d.Token()
	if _gggcfc != nil {
		return _gggcfc
	}
	if _fbgcde, _gdbag := _cdfed.(_f.EndElement); _gdbag && _fbgcde.Name == start.Name {
		*_gdgae = 1
		return nil
	}
	if _fccfc, _ggcec := _cdfed.(_f.CharData); !_ggcec {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cdfed)
	} else {
		switch string(_fccfc) {
		case "":
			*_gdgae = 0
		case "manual":
			*_gdgae = 1
		case "auto":
			*_gdgae = 2
		case "autoNoTable":
			*_gdgae = 3
		}
	}
	_cdfed, _gggcfc = d.Token()
	if _gggcfc != nil {
		return _gggcfc
	}
	if _ccccg, _gcgfea := _cdfed.(_f.EndElement); _gcgfea && _ccccg.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cdfed)
}
func NewCT_ExternalCell() *CT_ExternalCell { _aagcb := &CT_ExternalCell{}; return _aagcb }
func (_adafbd ST_SmartTagShow) ValidateWithPath(path string) error {
	switch _adafbd {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_adafbd))
	}
	return nil
}

// ValidateWithPath validates the CT_InputCells and its children, prefixing error messages with path
func (_gdfc *CT_InputCells) ValidateWithPath(path string) error { return nil }

type CT_Authors struct {

	// Author
	Author []string
}
type CT_Parameters struct {

	// Parameter Count
	CountAttr *uint32

	// Parameter Properties
	Parameter []*CT_Parameter
}
type CT_Consolidation struct {

	// Auto Page
	AutoPageAttr *bool

	// Page Item Values
	Pages *CT_Pages

	// Range Sets
	RangeSets *CT_RangeSets
}

func NewCT_PageSetup() *CT_PageSetup { _ebceb := &CT_PageSetup{}; return _ebceb }
func (_efebc *CT_ExternalBook) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _efebc.IdAttr)})
	e.EncodeToken(start)
	if _efebc.SheetNames != nil {
		_bcgcb := _f.StartElement{Name: _f.Name{Local: "ma:sheetNames"}}
		e.EncodeElement(_efebc.SheetNames, _bcgcb)
	}
	if _efebc.DefinedNames != nil {
		_acfb := _f.StartElement{Name: _f.Name{Local: "ma:definedNames"}}
		e.EncodeElement(_efebc.DefinedNames, _acfb)
	}
	if _efebc.SheetDataSet != nil {
		_cegcf := _f.StartElement{Name: _f.Name{Local: "ma:sheetDataSet"}}
		e.EncodeElement(_efebc.SheetDataSet, _cegcf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gdcab ST_OleUpdate) ValidateWithPath(path string) error {
	switch _gdcab {
	case 0, 1, 2:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gdcab))
	}
	return nil
}

// ValidateWithPath validates the CT_Font and its children, prefixing error messages with path
func (_bbea *CT_Font) ValidateWithPath(path string) error {
	for _dfagf, _cefcb := range _bbea.Name {
		if _edbc := _cefcb.ValidateWithPath(_bg.Sprintf("%s\u002fName\u005b\u0025d\u005d", path, _dfagf)); _edbc != nil {
			return _edbc
		}
	}
	for _fcbbc, _bfbd := range _bbea.Charset {
		if _aafeg := _bfbd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCharset\u005b\u0025d\u005d", path, _fcbbc)); _aafeg != nil {
			return _aafeg
		}
	}
	for _aaee, _fbcf := range _bbea.Family {
		if _aeabg := _fbcf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fFamily\u005b\u0025d\u005d", path, _aaee)); _aeabg != nil {
			return _aeabg
		}
	}
	for _aacg, _gagdf := range _bbea.B {
		if _afebc := _gagdf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fB\u005b\u0025d\u005d", path, _aacg)); _afebc != nil {
			return _afebc
		}
	}
	for _gggdfc, _cddfb := range _bbea.I {
		if _cefee := _cddfb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fI\u005b\u0025d\u005d", path, _gggdfc)); _cefee != nil {
			return _cefee
		}
	}
	for _bfgfb, _ffgcd := range _bbea.Strike {
		if _bfab := _ffgcd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fStrike\u005b\u0025d\u005d", path, _bfgfb)); _bfab != nil {
			return _bfab
		}
	}
	for _gcbgd, _efebg := range _bbea.Outline {
		if _bdagg := _efebg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fOutline\u005b\u0025d\u005d", path, _gcbgd)); _bdagg != nil {
			return _bdagg
		}
	}
	for _efccf, _cdeg := range _bbea.Shadow {
		if _cafec := _cdeg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fShadow\u005b\u0025d\u005d", path, _efccf)); _cafec != nil {
			return _cafec
		}
	}
	for _cddb, _cfcd := range _bbea.Condense {
		if _edgec := _cfcd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCondense\u005b\u0025d\u005d", path, _cddb)); _edgec != nil {
			return _edgec
		}
	}
	for _dafbd, _cafdc := range _bbea.Extend {
		if _gcddf := _cafdc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fExtend\u005b\u0025d\u005d", path, _dafbd)); _gcddf != nil {
			return _gcddf
		}
	}
	for _bfgca, _dbgd := range _bbea.Color {
		if _dcac := _dbgd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fColor\u005b\u0025d\u005d", path, _bfgca)); _dcac != nil {
			return _dcac
		}
	}
	for _dedge, _fdfgb := range _bbea.Sz {
		if _cebaa := _fdfgb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fSz\u005b\u0025d]", path, _dedge)); _cebaa != nil {
			return _cebaa
		}
	}
	for _degg, _adeeb := range _bbea.U {
		if _cdaagb := _adeeb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fU\u005b\u0025d\u005d", path, _degg)); _cdaagb != nil {
			return _cdaagb
		}
	}
	for _cfae, _ffdca := range _bbea.VertAlign {
		if _bdbec := _ffdca.ValidateWithPath(_bg.Sprintf("\u0025s/VertAlign\u005b\u0025d\u005d", path, _cfae)); _bdbec != nil {
			return _bdbec
		}
	}
	for _gdcfe, _dfgdgb := range _bbea.Scheme {
		if _ceedc := _dfgdgb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fScheme\u005b\u0025d\u005d", path, _gdcfe)); _ceedc != nil {
			return _ceedc
		}
	}
	return nil
}
func (_ccaca ST_ShowDataAs) ValidateWithPath(path string) error {
	switch _ccaca {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ccaca))
	}
	return nil
}
func (_cccebb ST_Type) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_ggfgdf := _f.Attr{}
	_ggfgdf.Name = name
	switch _cccebb {
	case ST_TypeUnset:
		_ggfgdf.Value = ""
	case ST_TypeNone:
		_ggfgdf.Value = "none"
	case ST_TypeAll:
		_ggfgdf.Value = "all"
	case ST_TypeRow:
		_ggfgdf.Value = "row"
	case ST_TypeColumn:
		_ggfgdf.Value = "column"
	}
	return _ggfgdf, nil
}

type CT_PivotTableStyle struct {

	// Table Style Name
	NameAttr *string

	// Show Row Header Formatting
	ShowRowHeadersAttr *bool

	// Show Table Style Column Header Formatting
	ShowColHeadersAttr *bool

	// Show Row Stripes
	ShowRowStripesAttr *bool

	// Show Column Stripes
	ShowColStripesAttr *bool

	// Show Last Column
	ShowLastColumnAttr *bool
}

func NewCT_OleObject() *CT_OleObject { _edfc := &CT_OleObject{}; return _edfc }
func NewCT_RevisionQueryTableField() *CT_RevisionQueryTableField {
	_gegbd := &CT_RevisionQueryTableField{}
	return _gegbd
}

// ValidateWithPath validates the CT_VerticalAlignFontProperty and its children, prefixing error messages with path
func (_acbeg *CT_VerticalAlignFontProperty) ValidateWithPath(path string) error {
	if _acbeg.ValAttr == _e.ST_VerticalAlignRunUnset {
		return _bg.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bcaeb := _acbeg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bcaeb != nil {
		return _bcaeb
	}
	return nil
}

type ST_ParameterType byte

// ValidateWithPath validates the CT_RevisionDefinedName and its children, prefixing error messages with path
func (_acdae *CT_RevisionDefinedName) ValidateWithPath(path string) error {
	if _acdae.ExtLst != nil {
		if _fbcff := _acdae.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fbcff != nil {
			return _fbcff
		}
	}
	return nil
}

// Validate validates the CT_ChartsheetPr and its children
func (_adgcb *CT_ChartsheetPr) Validate() error { return _adgcb.ValidateWithPath("CT_ChartsheetPr") }
func (_cdcbc *CT_LevelGroup) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cdcbc.GroupMembers = NewCT_GroupMembers()
	for _, _bafd := range start.Attr {
		if _bafd.Name.Local == "name" {
			_bddbea, _fegbc := _bafd.Value, error(nil)
			if _fegbc != nil {
				return _fegbc
			}
			_cdcbc.NameAttr = _bddbea
			continue
		}
		if _bafd.Name.Local == "uniqueName" {
			_egada, _acbfa := _bafd.Value, error(nil)
			if _acbfa != nil {
				return _acbfa
			}
			_cdcbc.UniqueNameAttr = _egada
			continue
		}
		if _bafd.Name.Local == "caption" {
			_gfeb, _cegfb := _bafd.Value, error(nil)
			if _cegfb != nil {
				return _cegfb
			}
			_cdcbc.CaptionAttr = _gfeb
			continue
		}
		if _bafd.Name.Local == "uniqueParent" {
			_agbaca, _eefed := _bafd.Value, error(nil)
			if _eefed != nil {
				return _eefed
			}
			_cdcbc.UniqueParentAttr = &_agbaca
			continue
		}
		if _bafd.Name.Local == "id" {
			_acdee, _cecc := _g.ParseInt(_bafd.Value, 10, 32)
			if _cecc != nil {
				return _cecc
			}
			_efccg := int32(_acdee)
			_cdcbc.IdAttr = &_efccg
			continue
		}
	}
_feffe:
	for {
		_ffcf, _dedfb := d.Token()
		if _dedfb != nil {
			return _dedfb
		}
		switch _bcde := _ffcf.(type) {
		case _f.StartElement:
			switch _bcde.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "groupMembers"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "groupMembers"}:
				if _bffcb := d.DecodeElement(_cdcbc.GroupMembers, &_bcde); _bffcb != nil {
					return _bffcb
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_LevelGroup \u0025v", _bcde.Name)
				if _aeabfg := d.Skip(); _aeabfg != nil {
					return _aeabfg
				}
			}
		case _f.EndElement:
			break _feffe
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_PageSetUpPr and its children
func (_ffggc *CT_PageSetUpPr) Validate() error { return _ffggc.ValidateWithPath("CT_PageSetUpPr") }

// ValidateWithPath validates the CT_Boolean and its children, prefixing error messages with path
func (_dbb *CT_Boolean) ValidateWithPath(path string) error {
	for _bbg, _abe := range _dbb.X {
		if _efg := _abe.ValidateWithPath(_bg.Sprintf("\u0025s\u002fX\u005b\u0025d\u005d", path, _bbg)); _efg != nil {
			return _efg
		}
	}
	return nil
}

type CT_WorksheetSource struct {

	// Reference
	RefAttr *string

	// Named Range
	NameAttr *string

	// Sheet Name
	SheetAttr *string
	IdAttr    *string
}

func (_bfffa ST_Pane) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bfffa.String(), start)
}
func (_aefbe *CT_UndoInfo) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "index"}, Value: _bg.Sprintf("\u0025v", _aefbe.IndexAttr)})
	_beebed, _eafag := _aefbe.ExpAttr.MarshalXMLAttr(_f.Name{Local: "exp"})
	if _eafag != nil {
		return _eafag
	}
	start.Attr = append(start.Attr, _beebed)
	if _aefbe.Ref3DAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref3D"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aefbe.Ref3DAttr))})
	}
	if _aefbe.ArrayAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "array"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aefbe.ArrayAttr))})
	}
	if _aefbe.VAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "v"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aefbe.VAttr))})
	}
	if _aefbe.NfAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "nf"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aefbe.NfAttr))})
	}
	if _aefbe.CsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cs"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aefbe.CsAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dr"}, Value: _bg.Sprintf("\u0025v", _aefbe.DrAttr)})
	if _aefbe.DnAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dn"}, Value: _bg.Sprintf("\u0025v", *_aefbe.DnAttr)})
	}
	if _aefbe.RAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", *_aefbe.RAttr)})
	}
	if _aefbe.SIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sId"}, Value: _bg.Sprintf("\u0025v", *_aefbe.SIdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_Cell struct {

	// Reference
	RAttr *string

	// Style Index
	SAttr *uint32

	// Cell Data Type
	TAttr ST_CellType

	// Cell Metadata Index
	CmAttr *uint32

	// Value Metadata Index
	VmAttr *uint32

	// Show Phonetic
	PhAttr *bool

	// Formula
	F *CT_CellFormula

	// Cell Value
	V *string

	// Rich Text Inline
	Is *CT_Rst

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func NewCT_ControlPr() *CT_ControlPr {
	_effg := &CT_ControlPr{}
	_effg.Anchor = NewCT_ObjectAnchor()
	return _effg
}
func (_ccaac ST_Qualifier) String() string {
	switch _ccaac {
	case 0:
		return ""
	case 1:
		return "doubleQuote"
	case 2:
		return "singleQuote"
	case 3:
		return "none"
	}
	return ""
}

type CT_WebPublishItems struct {

	// Web Publishing Items Count
	CountAttr *uint32

	// Web Publishing Item
	WebPublishItem []*CT_WebPublishItem
}

func (_cgabeg ST_TextVAlign) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_deggb := _f.Attr{}
	_deggb.Name = name
	switch _cgabeg {
	case ST_TextVAlignUnset:
		_deggb.Value = ""
	case ST_TextVAlignTop:
		_deggb.Value = "top"
	case ST_TextVAlignCenter:
		_deggb.Value = "center"
	case ST_TextVAlignBottom:
		_deggb.Value = "bottom"
	case ST_TextVAlignJustify:
		_deggb.Value = "justify"
	case ST_TextVAlignDistributed:
		_deggb.Value = "distributed"
	}
	return _deggb, nil
}

type CT_BookView struct {

	// Visibility
	VisibilityAttr ST_Visibility

	// Minimized
	MinimizedAttr *bool

	// Show Horizontal Scroll
	ShowHorizontalScrollAttr *bool

	// Show Vertical Scroll
	ShowVerticalScrollAttr *bool

	// Show Sheet Tabs
	ShowSheetTabsAttr *bool

	// Upper Left Corner (X Coordinate)
	XWindowAttr *int32

	// Upper Left Corner (Y Coordinate)
	YWindowAttr *int32

	// Window Width
	WindowWidthAttr *uint32

	// Window Height
	WindowHeightAttr *uint32

	// Sheet Tab Ratio
	TabRatioAttr *uint32

	// First Sheet
	FirstSheetAttr *uint32

	// Active Sheet Index
	ActiveTabAttr *uint32

	// AutoFilter Date Grouping
	AutoFilterDateGroupingAttr *bool
	ExtLst                     *CT_ExtensionList
}

func (_aeefe *CT_PivotTableStyle) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _egcdb := range start.Attr {
		if _egcdb.Name.Local == "name" {
			_cagca, _fegec := _egcdb.Value, error(nil)
			if _fegec != nil {
				return _fegec
			}
			_aeefe.NameAttr = &_cagca
			continue
		}
		if _egcdb.Name.Local == "showRowHeaders" {
			_fcfad, _bgdfe := _g.ParseBool(_egcdb.Value)
			if _bgdfe != nil {
				return _bgdfe
			}
			_aeefe.ShowRowHeadersAttr = &_fcfad
			continue
		}
		if _egcdb.Name.Local == "showColHeaders" {
			_bfgdfd, _ecceb := _g.ParseBool(_egcdb.Value)
			if _ecceb != nil {
				return _ecceb
			}
			_aeefe.ShowColHeadersAttr = &_bfgdfd
			continue
		}
		if _egcdb.Name.Local == "showRowStripes" {
			_caaff, _ccdbg := _g.ParseBool(_egcdb.Value)
			if _ccdbg != nil {
				return _ccdbg
			}
			_aeefe.ShowRowStripesAttr = &_caaff
			continue
		}
		if _egcdb.Name.Local == "showColStripes" {
			_fadfa, _ccffce := _g.ParseBool(_egcdb.Value)
			if _ccffce != nil {
				return _ccffce
			}
			_aeefe.ShowColStripesAttr = &_fadfa
			continue
		}
		if _egcdb.Name.Local == "showLastColumn" {
			_fcbcg, _adabce := _g.ParseBool(_egcdb.Value)
			if _adabce != nil {
				return _adabce
			}
			_aeefe.ShowLastColumnAttr = &_fcbcg
			continue
		}
	}
	for {
		_bcedf, _feaaf := d.Token()
		if _feaaf != nil {
			return _bg.Errorf("parsing\u0020CT_PivotTableStyle:\u0020\u0025s", _feaaf)
		}
		if _eccbf, _cgbfc := _bcedf.(_f.EndElement); _cgbfc && _eccbf.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_CacheFields struct {

	// Field Count
	CountAttr *uint32

	// PivotCache Field
	CacheField []*CT_CacheField
}

const (
	ST_PhoneticAlignmentUnset       ST_PhoneticAlignment = 0
	ST_PhoneticAlignmentNoControl   ST_PhoneticAlignment = 1
	ST_PhoneticAlignmentLeft        ST_PhoneticAlignment = 2
	ST_PhoneticAlignmentCenter      ST_PhoneticAlignment = 3
	ST_PhoneticAlignmentDistributed ST_PhoneticAlignment = 4
)

// ValidateWithPath validates the CT_CellAlignment and its children, prefixing error messages with path
func (_dfa *CT_CellAlignment) ValidateWithPath(path string) error {
	if _deff := _dfa.HorizontalAttr.ValidateWithPath(path + "\u002fHorizontalAttr"); _deff != nil {
		return _deff
	}
	if _bgfc := _dfa.VerticalAttr.ValidateWithPath(path + "\u002fVerticalAttr"); _bgfc != nil {
		return _bgfc
	}
	return nil
}
func NewCT_ExternalSheetData() *CT_ExternalSheetData {
	_ccfcd := &CT_ExternalSheetData{}
	return _ccfcd
}
func (_eg *AG_AutoFormat) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _eg.AutoFormatIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoFormatId"}, Value: _bg.Sprintf("\u0025v", *_eg.AutoFormatIdAttr)})
	}
	if _eg.ApplyNumberFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyNumberFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eg.ApplyNumberFormatsAttr))})
	}
	if _eg.ApplyBorderFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyBorderFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eg.ApplyBorderFormatsAttr))})
	}
	if _eg.ApplyFontFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyFontFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eg.ApplyFontFormatsAttr))})
	}
	if _eg.ApplyPatternFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyPatternFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eg.ApplyPatternFormatsAttr))})
	}
	if _eg.ApplyAlignmentFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyAlignmentFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eg.ApplyAlignmentFormatsAttr))})
	}
	if _eg.ApplyWidthHeightFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyWidthHeightFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eg.ApplyWidthHeightFormatsAttr))})
	}
	return nil
}

// Validate validates the CT_FileRecoveryPr and its children
func (_adfff *CT_FileRecoveryPr) Validate() error {
	return _adfff.ValidateWithPath("CT_FileRecoveryPr")
}
func (_ccaga *CT_RevisionAutoFormatting) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _effffa := range start.Attr {
		if _effffa.Name.Local == "sheetId" {
			_bgece, _cdfaa := _g.ParseUint(_effffa.Value, 10, 32)
			if _cdfaa != nil {
				return _cdfaa
			}
			_ccaga.SheetIdAttr = uint32(_bgece)
			continue
		}
		if _effffa.Name.Local == "ref" {
			_fdceg, _geebfd := _effffa.Value, error(nil)
			if _geebfd != nil {
				return _geebfd
			}
			_ccaga.RefAttr = _fdceg
			continue
		}
		if _effffa.Name.Local == "autoFormatId" {
			_ebdeg, _bcbcaa := _g.ParseUint(_effffa.Value, 10, 32)
			if _bcbcaa != nil {
				return _bcbcaa
			}
			_affdg := uint32(_ebdeg)
			_ccaga.AutoFormatIdAttr = &_affdg
			continue
		}
		if _effffa.Name.Local == "applyNumberFormats" {
			_dafed, _ggcfd := _g.ParseBool(_effffa.Value)
			if _ggcfd != nil {
				return _ggcfd
			}
			_ccaga.ApplyNumberFormatsAttr = &_dafed
			continue
		}
		if _effffa.Name.Local == "applyBorderFormats" {
			_fbggg, _adece := _g.ParseBool(_effffa.Value)
			if _adece != nil {
				return _adece
			}
			_ccaga.ApplyBorderFormatsAttr = &_fbggg
			continue
		}
		if _effffa.Name.Local == "applyFontFormats" {
			_dggcc, _cgbd := _g.ParseBool(_effffa.Value)
			if _cgbd != nil {
				return _cgbd
			}
			_ccaga.ApplyFontFormatsAttr = &_dggcc
			continue
		}
		if _effffa.Name.Local == "applyPatternFormats" {
			_cdagac, _efdgd := _g.ParseBool(_effffa.Value)
			if _efdgd != nil {
				return _efdgd
			}
			_ccaga.ApplyPatternFormatsAttr = &_cdagac
			continue
		}
		if _effffa.Name.Local == "applyAlignmentFormats" {
			_cebfd, _cggegeb := _g.ParseBool(_effffa.Value)
			if _cggegeb != nil {
				return _cggegeb
			}
			_ccaga.ApplyAlignmentFormatsAttr = &_cebfd
			continue
		}
		if _effffa.Name.Local == "applyWidthHeightFormats" {
			_gcbfee, _daefab := _g.ParseBool(_effffa.Value)
			if _daefab != nil {
				return _daefab
			}
			_ccaga.ApplyWidthHeightFormatsAttr = &_gcbfee
			continue
		}
	}
	for {
		_fdaga, _agcbd := d.Token()
		if _agcbd != nil {
			return _bg.Errorf("parsing CT_RevisionAutoFormatting:\u0020\u0025s", _agcbd)
		}
		if _gefcd, _ebffda := _fdaga.(_f.EndElement); _ebffda && _gefcd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fceca *CT_RElt) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _fceca.RPr != nil {
		_bcfgea := _f.StartElement{Name: _f.Name{Local: "ma:rPr"}}
		e.EncodeElement(_fceca.RPr, _bcfgea)
	}
	_adebd := _f.StartElement{Name: _f.Name{Local: "ma:t"}}
	_cb.AddPreserveSpaceAttr(&_adebd, _fceca.T)
	e.EncodeElement(_fceca.T, _adebd)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bagcea ST_DataValidationImeMode) String() string {
	switch _bagcea {
	case 0:
		return ""
	case 1:
		return "noControl"
	case 2:
		return "off"
	case 3:
		return "on"
	case 4:
		return "disabled"
	case 5:
		return "hiragana"
	case 6:
		return "fullKatakana"
	case 7:
		return "halfKatakana"
	case 8:
		return "fullAlpha"
	case 9:
		return "halfAlpha"
	case 10:
		return "fullHangul"
	case 11:
		return "halfHangul"
	}
	return ""
}

type CT_QueryTable struct {

	// QueryTable Name
	NameAttr string

	// First Row Column Titles
	HeadersAttr *bool

	// Row Numbers
	RowNumbersAttr *bool

	// Disable Refresh
	DisableRefreshAttr *bool

	// Background Refresh
	BackgroundRefreshAttr *bool

	// First Background Refresh
	FirstBackgroundRefreshAttr *bool

	// Refresh On Load
	RefreshOnLoadAttr *bool

	// Grow Shrink Type
	GrowShrinkTypeAttr ST_GrowShrinkType

	// Fill Adjacent Formulas
	FillFormulasAttr *bool

	// Remove Data On Save
	RemoveDataOnSaveAttr *bool

	// Disable Edit
	DisableEditAttr *bool

	// Preserve Formatting On Refresh
	PreserveFormattingAttr *bool

	// Adjust Column Width On Refresh
	AdjustColumnWidthAttr *bool

	// Intermediate
	IntermediateAttr *bool

	// Connection Id
	ConnectionIdAttr uint32

	// QueryTable Refresh Information
	QueryTableRefresh *CT_QueryTableRefresh

	// Future Feature Data Storage Area
	ExtLst                      *CT_ExtensionList
	AutoFormatIdAttr            *uint32
	ApplyNumberFormatsAttr      *bool
	ApplyBorderFormatsAttr      *bool
	ApplyFontFormatsAttr        *bool
	ApplyPatternFormatsAttr     *bool
	ApplyAlignmentFormatsAttr   *bool
	ApplyWidthHeightFormatsAttr *bool
}

// ValidateWithPath validates the CT_MdxKPI and its children, prefixing error messages with path
func (_fdbbe *CT_MdxKPI) ValidateWithPath(path string) error {
	if _fdbbe.PAttr == ST_MdxKPIPropertyUnset {
		return _bg.Errorf("\u0025s/PAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _cabeg := _fdbbe.PAttr.ValidateWithPath(path + "\u002fPAttr"); _cabeg != nil {
		return _cabeg
	}
	return nil
}
func NewCT_FontFamily() *CT_FontFamily            { _fecea := &CT_FontFamily{}; _fecea.ValAttr = 0; return _fecea }
func (_abeag ST_rwColActionType) Validate() error { return _abeag.ValidateWithPath("") }
func (_ffgecf ST_SourceType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_edcbgf := _f.Attr{}
	_edcbgf.Name = name
	switch _ffgecf {
	case ST_SourceTypeUnset:
		_edcbgf.Value = ""
	case ST_SourceTypeWorksheet:
		_edcbgf.Value = "worksheet"
	case ST_SourceTypeExternal:
		_edcbgf.Value = "external"
	case ST_SourceTypeConsolidation:
		_edcbgf.Value = "consolidation"
	case ST_SourceTypeScenario:
		_edcbgf.Value = "scenario"
	}
	return _edcbgf, nil
}
func NewCT_Macrosheet() *CT_Macrosheet {
	_dccca := &CT_Macrosheet{}
	_dccca.SheetData = NewCT_SheetData()
	return _dccca
}
func (_bcbafb *ST_SheetViewType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ccbd, _faccac := d.Token()
	if _faccac != nil {
		return _faccac
	}
	if _dceaf, _bgecg := _ccbd.(_f.EndElement); _bgecg && _dceaf.Name == start.Name {
		*_bcbafb = 1
		return nil
	}
	if _dcagac, _fadcd := _ccbd.(_f.CharData); !_fadcd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ccbd)
	} else {
		switch string(_dcagac) {
		case "":
			*_bcbafb = 0
		case "normal":
			*_bcbafb = 1
		case "pageBreakPreview":
			*_bcbafb = 2
		case "pageLayout":
			*_bcbafb = 3
		}
	}
	_ccbd, _faccac = d.Token()
	if _faccac != nil {
		return _faccac
	}
	if _fefaa, _ccbfgc := _ccbd.(_f.EndElement); _ccbfgc && _fefaa.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ccbd)
}

// Validate validates the CT_SheetData and its children
func (_ddegb *CT_SheetData) Validate() error { return _ddegb.ValidateWithPath("CT_SheetData") }
func (_beccdg ST_FieldSortType) String() string {
	switch _beccdg {
	case 0:
		return ""
	case 1:
		return "manual"
	case 2:
		return "ascending"
	case 3:
		return "descending"
	}
	return ""
}
func (_gbbcd *CT_MapInfo) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "SelectionNamespaces"}, Value: _bg.Sprintf("\u0025v", _gbbcd.SelectionNamespacesAttr)})
	e.EncodeToken(start)
	_efgce := _f.StartElement{Name: _f.Name{Local: "ma:Schema"}}
	for _, _aceec := range _gbbcd.Schema {
		e.EncodeElement(_aceec, _efgce)
	}
	_bdddd := _f.StartElement{Name: _f.Name{Local: "ma:Map"}}
	for _, _edggbg := range _gbbcd.Map {
		e.EncodeElement(_edggbg, _bdddd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_FontFamily and its children, prefixing error messages with path
func (_bbfgc *CT_FontFamily) ValidateWithPath(path string) error {
	if _bbfgc.ValAttr < 0 {
		return _bg.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _bbfgc.ValAttr)
	}
	if _bbfgc.ValAttr > 14 {
		return _bg.Errorf("\u0025s/m\u002eValAttr must be\u0020\u003c\u003d\u002014 \u0028have\u0020\u0025v\u0029", path, _bbfgc.ValAttr)
	}
	return nil
}

// Validate validates the CT_Stylesheet and its children
func (_dcebf *CT_Stylesheet) Validate() error { return _dcebf.ValidateWithPath("CT_Stylesheet") }

// Validate validates the CT_Member and its children
func (_fccaef *CT_Member) Validate() error { return _fccaef.ValidateWithPath("CT_Member") }

// ValidateWithPath validates the CT_DdeValues and its children, prefixing error messages with path
func (_cbebe *CT_DdeValues) ValidateWithPath(path string) error {
	for _febaf, _ggeag := range _cbebe.Value {
		if _eedb := _ggeag.ValidateWithPath(_bg.Sprintf("\u0025s\u002fValue\u005b\u0025d\u005d", path, _febaf)); _eedb != nil {
			return _eedb
		}
	}
	return nil
}

type CT_ChartsheetProtection struct {

	// Password
	PasswordAttr *string

	// Cryptographic Algorithm Name
	AlgorithmNameAttr *string

	// Password Hash Value
	HashValueAttr *string

	// Salt Value for Password Verifier
	SaltValueAttr *string

	// Iterations to Run Hashing Algorithm
	SpinCountAttr *uint32

	// Contents
	ContentAttr *bool

	// Objects Locked
	ObjectsAttr *bool
}
type CT_SheetDimension struct {

	// Reference
	RefAttr string
}

func (_eacgb *CT_OlapPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _baefa := range start.Attr {
		if _baefa.Name.Local == "local" {
			_agaac, _bddbff := _g.ParseBool(_baefa.Value)
			if _bddbff != nil {
				return _bddbff
			}
			_eacgb.LocalAttr = &_agaac
			continue
		}
		if _baefa.Name.Local == "localConnection" {
			_ddegf, _aeddb := _baefa.Value, error(nil)
			if _aeddb != nil {
				return _aeddb
			}
			_eacgb.LocalConnectionAttr = &_ddegf
			continue
		}
		if _baefa.Name.Local == "localRefresh" {
			_egbdd, _fbaab := _g.ParseBool(_baefa.Value)
			if _fbaab != nil {
				return _fbaab
			}
			_eacgb.LocalRefreshAttr = &_egbdd
			continue
		}
		if _baefa.Name.Local == "sendLocale" {
			_bcceg, _aabba := _g.ParseBool(_baefa.Value)
			if _aabba != nil {
				return _aabba
			}
			_eacgb.SendLocaleAttr = &_bcceg
			continue
		}
		if _baefa.Name.Local == "rowDrillCount" {
			_abbfc, _cafaaf := _g.ParseUint(_baefa.Value, 10, 32)
			if _cafaaf != nil {
				return _cafaaf
			}
			_fbfed := uint32(_abbfc)
			_eacgb.RowDrillCountAttr = &_fbfed
			continue
		}
		if _baefa.Name.Local == "serverFill" {
			_eacgbf, _bedb := _g.ParseBool(_baefa.Value)
			if _bedb != nil {
				return _bedb
			}
			_eacgb.ServerFillAttr = &_eacgbf
			continue
		}
		if _baefa.Name.Local == "serverNumberFormat" {
			_deada, _fdgf := _g.ParseBool(_baefa.Value)
			if _fdgf != nil {
				return _fdgf
			}
			_eacgb.ServerNumberFormatAttr = &_deada
			continue
		}
		if _baefa.Name.Local == "serverFont" {
			_ccdde, _ddbbe := _g.ParseBool(_baefa.Value)
			if _ddbbe != nil {
				return _ddbbe
			}
			_eacgb.ServerFontAttr = &_ccdde
			continue
		}
		if _baefa.Name.Local == "serverFontColor" {
			_bagc, _degdgg := _g.ParseBool(_baefa.Value)
			if _degdgg != nil {
				return _degdgg
			}
			_eacgb.ServerFontColorAttr = &_bagc
			continue
		}
	}
	for {
		_afecd, _bcaab := d.Token()
		if _bcaab != nil {
			return _bg.Errorf("parsing\u0020CT_OlapPr:\u0020\u0025s", _bcaab)
		}
		if _fgfaa, _fegcb := _afecd.(_f.EndElement); _fegcb && _fgfaa.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_DrawingHF and its children, prefixing error messages with path
func (_cfbf *CT_DrawingHF) ValidateWithPath(path string) error { return nil }
func (_badae ST_SortMethod) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bceace := _f.Attr{}
	_bceace.Name = name
	switch _badae {
	case ST_SortMethodUnset:
		_bceace.Value = ""
	case ST_SortMethodStroke:
		_bceace.Value = "stroke"
	case ST_SortMethodPinYin:
		_bceace.Value = "pinYin"
	case ST_SortMethodNone:
		_bceace.Value = "none"
	}
	return _bceace, nil
}

// ValidateWithPath validates the CT_Metadata and its children, prefixing error messages with path
func (_baged *CT_Metadata) ValidateWithPath(path string) error {
	if _baged.MetadataTypes != nil {
		if _bbdf := _baged.MetadataTypes.ValidateWithPath(path + "\u002fMetadataTypes"); _bbdf != nil {
			return _bbdf
		}
	}
	if _baged.MetadataStrings != nil {
		if _bgfgf := _baged.MetadataStrings.ValidateWithPath(path + "\u002fMetadataStrings"); _bgfgf != nil {
			return _bgfgf
		}
	}
	if _baged.MdxMetadata != nil {
		if _aebad := _baged.MdxMetadata.ValidateWithPath(path + "\u002fMdxMetadata"); _aebad != nil {
			return _aebad
		}
	}
	for _bacdc, _gbeed := range _baged.FutureMetadata {
		if _dbeabb := _gbeed.ValidateWithPath(_bg.Sprintf("%s\u002fFutureMetadata\u005b\u0025d\u005d", path, _bacdc)); _dbeabb != nil {
			return _dbeabb
		}
	}
	if _baged.CellMetadata != nil {
		if _gecfb := _baged.CellMetadata.ValidateWithPath(path + "\u002fCellMetadata"); _gecfb != nil {
			return _gecfb
		}
	}
	if _baged.ValueMetadata != nil {
		if _edeag := _baged.ValueMetadata.ValidateWithPath(path + "\u002fValueMetadata"); _edeag != nil {
			return _edeag
		}
	}
	if _baged.ExtLst != nil {
		if _bbgfb := _baged.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bbgfb != nil {
			return _bbgfb
		}
	}
	return nil
}
func (_dcffc *ST_ExternalConnectionType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_afabca, _abccdg := d.Token()
	if _abccdg != nil {
		return _abccdg
	}
	if _fgeafd, _agada := _afabca.(_f.EndElement); _agada && _fgeafd.Name == start.Name {
		*_dcffc = 1
		return nil
	}
	if _dedfe, _gbfefe := _afabca.(_f.CharData); !_gbfefe {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _afabca)
	} else {
		switch string(_dedfe) {
		case "":
			*_dcffc = 0
		case "general":
			*_dcffc = 1
		case "text":
			*_dcffc = 2
		case "MDY":
			*_dcffc = 3
		case "DMY":
			*_dcffc = 4
		case "YMD":
			*_dcffc = 5
		case "MYD":
			*_dcffc = 6
		case "DYM":
			*_dcffc = 7
		case "YDM":
			*_dcffc = 8
		case "skip":
			*_dcffc = 9
		case "EMD":
			*_dcffc = 10
		}
	}
	_afabca, _abccdg = d.Token()
	if _abccdg != nil {
		return _abccdg
	}
	if _eabed, _dgeaad := _afabca.(_f.EndElement); _dgeaad && _eabed.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _afabca)
}

// Validate validates the CT_IntProperty and its children
func (_cafde *CT_IntProperty) Validate() error { return _cafde.ValidateWithPath("CT_IntProperty") }
func (_bbccb *CT_OleItems) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _bbccb.OleItem != nil {
		_ebbef := _f.StartElement{Name: _f.Name{Local: "ma:oleItem"}}
		for _, _bbecg := range _bbccb.OleItem {
			e.EncodeElement(_bbecg, _ebbef)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_HierarchyUsage struct {

	// Hierarchy Usage
	HierarchyUsageAttr int32
}

func NewCT_Members() *CT_Members { _abeda := &CT_Members{}; return _abeda }
func (_gdgef *CT_MemberProperty) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gdgef.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_gdgef.NameAttr)})
	}
	if _gdgef.ShowCellAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showCell"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgef.ShowCellAttr))})
	}
	if _gdgef.ShowTipAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showTip"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgef.ShowTipAttr))})
	}
	if _gdgef.ShowAsCaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showAsCaption"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgef.ShowAsCaptionAttr))})
	}
	if _gdgef.NameLenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "nameLen"}, Value: _bg.Sprintf("\u0025v", *_gdgef.NameLenAttr)})
	}
	if _gdgef.PPosAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pPos"}, Value: _bg.Sprintf("\u0025v", *_gdgef.PPosAttr)})
	}
	if _gdgef.PLenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pLen"}, Value: _bg.Sprintf("\u0025v", *_gdgef.PLenAttr)})
	}
	if _gdgef.LevelAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "level"}, Value: _bg.Sprintf("\u0025v", *_gdgef.LevelAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "field"}, Value: _bg.Sprintf("\u0025v", _gdgef.FieldAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_agafd *ST_UnderlineValues) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_agafd = 0
	case "single":
		*_agafd = 1
	case "double":
		*_agafd = 2
	case "singleAccounting":
		*_agafd = 3
	case "doubleAccounting":
		*_agafd = 4
	case "none":
		*_agafd = 5
	}
	return nil
}

type CT_BooleanProperty struct {

	// Value
	ValAttr *bool
}

// ValidateWithPath validates the CT_Users and its children, prefixing error messages with path
func (_bcfcg *CT_Users) ValidateWithPath(path string) error {
	for _aacea, _ebaece := range _bcfcg.UserInfo {
		if _eegfg := _ebaece.ValidateWithPath(_bg.Sprintf("\u0025s\u002fUserInfo\u005b\u0025d\u005d", path, _aacea)); _eegfg != nil {
			return _eegfg
		}
	}
	return nil
}
func (_bbefb *ST_rwColActionType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bbefb = 0
	case "insertRow":
		*_bbefb = 1
	case "deleteRow":
		*_bbefb = 2
	case "insertCol":
		*_bbefb = 3
	case "deleteCol":
		*_bbefb = 4
	}
	return nil
}

// ValidateWithPath validates the CT_FieldGroup and its children, prefixing error messages with path
func (_gabgd *CT_FieldGroup) ValidateWithPath(path string) error {
	if _gabgd.RangePr != nil {
		if _efbdc := _gabgd.RangePr.ValidateWithPath(path + "\u002fRangePr"); _efbdc != nil {
			return _efbdc
		}
	}
	if _gabgd.DiscretePr != nil {
		if _gcabb := _gabgd.DiscretePr.ValidateWithPath(path + "/DiscretePr"); _gcabb != nil {
			return _gcabb
		}
	}
	if _gabgd.GroupItems != nil {
		if _egac := _gabgd.GroupItems.ValidateWithPath(path + "/GroupItems"); _egac != nil {
			return _egac
		}
	}
	return nil
}
func (_facbb ST_CfType) ValidateWithPath(path string) error {
	switch _facbb {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_facbb))
	}
	return nil
}
func NewCT_CustomChartsheetView() *CT_CustomChartsheetView {
	_afged := &CT_CustomChartsheetView{}
	_afged.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	return _afged
}
func (_bdgddg ST_GroupBy) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_badgc := _f.Attr{}
	_badgc.Name = name
	switch _bdgddg {
	case ST_GroupByUnset:
		_badgc.Value = ""
	case ST_GroupByRange:
		_badgc.Value = "range"
	case ST_GroupBySeconds:
		_badgc.Value = "seconds"
	case ST_GroupByMinutes:
		_badgc.Value = "minutes"
	case ST_GroupByHours:
		_badgc.Value = "hours"
	case ST_GroupByDays:
		_badgc.Value = "days"
	case ST_GroupByMonths:
		_badgc.Value = "months"
	case ST_GroupByQuarters:
		_badgc.Value = "quarters"
	case ST_GroupByYears:
		_badgc.Value = "years"
	}
	return _badgc, nil
}
func NewCT_SmartTags() *CT_SmartTags { _beacdb := &CT_SmartTags{}; return _beacdb }
func (_cdggcc *CT_TableStyleElement) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	_bdcede, _ebdcf := _cdggcc.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
	if _ebdcf != nil {
		return _ebdcf
	}
	start.Attr = append(start.Attr, _bdcede)
	if _cdggcc.SizeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "size"}, Value: _bg.Sprintf("\u0025v", *_cdggcc.SizeAttr)})
	}
	if _cdggcc.DxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dxfId"}, Value: _bg.Sprintf("\u0025v", *_cdggcc.DxfIdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_MetadataStrings struct {

	// MDX Metadata String Count
	CountAttr *uint32

	// MDX Metadata String
	S []*CT_XStringElement
}

func (_egdfd *CalcChain) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:calcChain"
	return _egdfd.CT_CalcChain.MarshalXML(e, start)
}
func (_cefdg *CT_SheetId) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", _cefdg.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Filter and its children, prefixing error messages with path
func (_dgdeed *CT_Filter) ValidateWithPath(path string) error { return nil }

type CT_FutureMetadata struct {

	// Metadata Type Name
	NameAttr string

	// Future Metadata Block Count
	CountAttr *uint32

	// Future Metadata Block
	Bk []*CT_FutureMetadataBlock

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_ebegf *StyleSheet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:styleSheet"
	return _ebegf.CT_Stylesheet.MarshalXML(e, start)
}
func NewCT_BookView() *CT_BookView { _gaf := &CT_BookView{}; return _gaf }
func (_bdaf *CT_ExternalSheetData) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fgadgb := range start.Attr {
		if _fgadgb.Name.Local == "sheetId" {
			_bdfcg, _fgagg := _g.ParseUint(_fgadgb.Value, 10, 32)
			if _fgagg != nil {
				return _fgagg
			}
			_bdaf.SheetIdAttr = uint32(_bdfcg)
			continue
		}
		if _fgadgb.Name.Local == "refreshError" {
			_adad, _eeaa := _g.ParseBool(_fgadgb.Value)
			if _eeaa != nil {
				return _eeaa
			}
			_bdaf.RefreshErrorAttr = &_adad
			continue
		}
	}
_gbfda:
	for {
		_bcaef, _abgf := d.Token()
		if _abgf != nil {
			return _abgf
		}
		switch _dcgfb := _bcaef.(type) {
		case _f.StartElement:
			switch _dcgfb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "row"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "row"}:
				_fgfd := NewCT_ExternalRow()
				if _agffc := d.DecodeElement(_fgfd, &_dcgfb); _agffc != nil {
					return _agffc
				}
				_bdaf.Row = append(_bdaf.Row, _fgfd)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on\u0020CT_ExternalSheetData\u0020\u0025v", _dcgfb.Name)
				if _gcabf := d.Skip(); _gcabf != nil {
					return _gcabf
				}
			}
		case _f.EndElement:
			break _gbfda
		case _f.CharData:
		}
	}
	return nil
}
func (_ggdcb *CT_FutureMetadata) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _ggdcb.NameAttr)})
	if _ggdcb.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_ggdcb.CountAttr)})
	}
	e.EncodeToken(start)
	if _ggdcb.Bk != nil {
		_fcdcd := _f.StartElement{Name: _f.Name{Local: "ma:bk"}}
		for _, _ddcba := range _ggdcb.Bk {
			e.EncodeElement(_ddcba, _fcdcd)
		}
	}
	if _ggdcb.ExtLst != nil {
		_bcbbb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_ggdcb.ExtLst, _bcbbb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_caggb *CT_IconSet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _caggb.IconSetAttr != ST_IconSetTypeUnset {
		_febf, _bccdd := _caggb.IconSetAttr.MarshalXMLAttr(_f.Name{Local: "iconSet"})
		if _bccdd != nil {
			return _bccdd
		}
		start.Attr = append(start.Attr, _febf)
	}
	if _caggb.ShowValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showValue"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caggb.ShowValueAttr))})
	}
	if _caggb.PercentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "percent"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caggb.PercentAttr))})
	}
	if _caggb.ReverseAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "reverse"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caggb.ReverseAttr))})
	}
	e.EncodeToken(start)
	_fgae := _f.StartElement{Name: _f.Name{Local: "ma:cfvo"}}
	for _, _bdcbb := range _caggb.Cfvo {
		e.EncodeElement(_bdcbb, _fgae)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bdfge *CT_Xf) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bdfge.NumFmtIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "numFmtId"}, Value: _bg.Sprintf("\u0025v", *_bdfge.NumFmtIdAttr)})
	}
	if _bdfge.FontIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fontId"}, Value: _bg.Sprintf("\u0025v", *_bdfge.FontIdAttr)})
	}
	if _bdfge.FillIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fillId"}, Value: _bg.Sprintf("\u0025v", *_bdfge.FillIdAttr)})
	}
	if _bdfge.BorderIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "borderId"}, Value: _bg.Sprintf("\u0025v", *_bdfge.BorderIdAttr)})
	}
	if _bdfge.XfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xfId"}, Value: _bg.Sprintf("\u0025v", *_bdfge.XfIdAttr)})
	}
	if _bdfge.QuotePrefixAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "quotePrefix"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bdfge.QuotePrefixAttr))})
	}
	if _bdfge.PivotButtonAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pivotButton"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bdfge.PivotButtonAttr))})
	}
	if _bdfge.ApplyNumberFormatAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyNumberFormat"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bdfge.ApplyNumberFormatAttr))})
	}
	if _bdfge.ApplyFontAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyFont"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bdfge.ApplyFontAttr))})
	}
	if _bdfge.ApplyFillAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyFill"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bdfge.ApplyFillAttr))})
	}
	if _bdfge.ApplyBorderAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyBorder"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bdfge.ApplyBorderAttr))})
	}
	if _bdfge.ApplyAlignmentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyAlignment"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bdfge.ApplyAlignmentAttr))})
	}
	if _bdfge.ApplyProtectionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyProtection"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bdfge.ApplyProtectionAttr))})
	}
	e.EncodeToken(start)
	if _bdfge.Alignment != nil {
		_ebbea := _f.StartElement{Name: _f.Name{Local: "ma:alignment"}}
		e.EncodeElement(_bdfge.Alignment, _ebbea)
	}
	if _bdfge.Protection != nil {
		_dgeaf := _f.StartElement{Name: _f.Name{Local: "ma:protection"}}
		e.EncodeElement(_bdfge.Protection, _dgeaf)
	}
	if _bdfge.ExtLst != nil {
		_ebbgd := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_bdfge.ExtLst, _ebbgd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_RangeSets() *CT_RangeSets { _cbbac := &CT_RangeSets{}; return _cbbac }
func (_fbfeaa *CT_MdxMetadata) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fbfeaa.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_fbfeaa.CountAttr)})
	}
	e.EncodeToken(start)
	_fdcfd := _f.StartElement{Name: _f.Name{Local: "ma:mdx"}}
	for _, _baaea := range _fbfeaa.Mdx {
		e.EncodeElement(_baaea, _fdcfd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_abafcf ST_RefMode) String() string {
	switch _abafcf {
	case 0:
		return ""
	case 1:
		return "A1"
	case 2:
		return "R1C1"
	}
	return ""
}

// Validate validates the CT_CustomFilters and its children
func (_dcbga *CT_CustomFilters) Validate() error { return _dcbga.ValidateWithPath("CT_CustomFilters") }
func (_fgafc *CT_Filters) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gbcfc := range start.Attr {
		if _gbcfc.Name.Local == "blank" {
			_adbga, _gaeg := _g.ParseBool(_gbcfc.Value)
			if _gaeg != nil {
				return _gaeg
			}
			_fgafc.BlankAttr = &_adbga
			continue
		}
		if _gbcfc.Name.Local == "calendarType" {
			_fgafc.CalendarTypeAttr.UnmarshalXMLAttr(_gbcfc)
			continue
		}
	}
_fddd:
	for {
		_dgggc, _accfc := d.Token()
		if _accfc != nil {
			return _accfc
		}
		switch _dfdc := _dgggc.(type) {
		case _f.StartElement:
			switch _dfdc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "filter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "filter"}:
				_acgcg := NewCT_Filter()
				if _gaggf := d.DecodeElement(_acgcg, &_dfdc); _gaggf != nil {
					return _gaggf
				}
				_fgafc.Filter = append(_fgafc.Filter, _acgcg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dateGroupItem"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dateGroupItem"}:
				_dagce := NewCT_DateGroupItem()
				if _dfefc := d.DecodeElement(_dagce, &_dfdc); _dfefc != nil {
					return _dfefc
				}
				_fgafc.DateGroupItem = append(_fgafc.DateGroupItem, _dagce)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_Filters\u0020\u0025v", _dfdc.Name)
				if _fedcb := d.Skip(); _fedcb != nil {
					return _fedcb
				}
			}
		case _f.EndElement:
			break _fddd
		case _f.CharData:
		}
	}
	return nil
}
func (_dcecd *ST_ConditionalFormattingOperator) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_dcecd = 0
	case "lessThan":
		*_dcecd = 1
	case "lessThanOrEqual":
		*_dcecd = 2
	case "equal":
		*_dcecd = 3
	case "notEqual":
		*_dcecd = 4
	case "greaterThanOrEqual":
		*_dcecd = 5
	case "greaterThan":
		*_dcecd = 6
	case "between":
		*_dcecd = 7
	case "notBetween":
		*_dcecd = 8
	case "containsText":
		*_dcecd = 9
	case "notContains":
		*_dcecd = 10
	case "beginsWith":
		*_dcecd = 11
	case "endsWith":
		*_dcecd = 12
	}
	return nil
}

// Validate validates the CT_SheetCalcPr and its children
func (_ddffc *CT_SheetCalcPr) Validate() error { return _ddffc.ValidateWithPath("CT_SheetCalcPr") }
func NewCT_SheetView() *CT_SheetView           { _fbefgd := &CT_SheetView{}; return _fbefgd }

type CT_CustomWorkbookView struct {

	// Custom View Name
	NameAttr string

	// Custom View GUID
	GuidAttr string

	// Auto Update
	AutoUpdateAttr *bool

	// Merge Interval
	MergeIntervalAttr *uint32

	// Changes Saved Win
	ChangesSavedWinAttr *bool

	// Only Synch
	OnlySyncAttr *bool

	// Personal View
	PersonalViewAttr *bool

	// Include Print Settings
	IncludePrintSettingsAttr *bool

	// Include Hidden Rows & Columns
	IncludeHiddenRowColAttr *bool

	// Maximized
	MaximizedAttr *bool

	// Minimized
	MinimizedAttr *bool

	// Show Horizontal Scroll
	ShowHorizontalScrollAttr *bool

	// Show Vertical Scroll
	ShowVerticalScrollAttr *bool

	// Show Sheet Tabs
	ShowSheetTabsAttr *bool

	// Top Left Corner (X Coordinate)
	XWindowAttr *int32

	// Top Left Corner (Y Coordinate)
	YWindowAttr *int32

	// Window Width
	WindowWidthAttr uint32

	// Window Height
	WindowHeightAttr uint32

	// Sheet Tab Ratio
	TabRatioAttr *uint32

	// Active Sheet in Book View
	ActiveSheetIdAttr uint32

	// Show Formula Bar
	ShowFormulaBarAttr *bool

	// Show Status Bar
	ShowStatusbarAttr *bool

	// Show Comments
	ShowCommentsAttr ST_Comments

	// Show Objects
	ShowObjectsAttr ST_Objects
	ExtLst          *CT_ExtensionList
}

// ValidateWithPath validates the CT_DataBinding and its children, prefixing error messages with path
func (_bbbb *CT_DataBinding) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_Pages and its children, prefixing error messages with path
func (_abfca *CT_Pages) ValidateWithPath(path string) error {
	for _bffbd, _fbafa := range _abfca.Page {
		if _gcbec := _fbafa.ValidateWithPath(_bg.Sprintf("%s\u002fPage\u005b\u0025d\u005d", path, _bffbd)); _gcbec != nil {
			return _gcbec
		}
	}
	return nil
}
func NewCT_PageSetUpPr() *CT_PageSetUpPr { _ecgdd := &CT_PageSetUpPr{}; return _ecgdd }
func (_efdd *CT_CalculatedMembers) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dbbe := range start.Attr {
		if _dbbe.Name.Local == "count" {
			_adgb, _fff := _g.ParseUint(_dbbe.Value, 10, 32)
			if _fff != nil {
				return _fff
			}
			_aceed := uint32(_adgb)
			_efdd.CountAttr = &_aceed
			continue
		}
	}
_fbg:
	for {
		_babc, _dbeb := d.Token()
		if _dbeb != nil {
			return _dbeb
		}
		switch _geacg := _babc.(type) {
		case _f.StartElement:
			switch _geacg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "calculatedMember"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "calculatedMember"}:
				_eaf := NewCT_CalculatedMember()
				if _egca := d.DecodeElement(_eaf, &_geacg); _egca != nil {
					return _egca
				}
				_efdd.CalculatedMember = append(_efdd.CalculatedMember, _eaf)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on\u0020CT_CalculatedMembers\u0020\u0025v", _geacg.Name)
				if _ggce := d.Skip(); _ggce != nil {
					return _ggce
				}
			}
		case _f.EndElement:
			break _fbg
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_DataRefs() *CT_DataRefs { _eccad := &CT_DataRefs{}; return _eccad }
func (_eccg *CT_Control) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fdgdc := range start.Attr {
		if _fdgdc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _fdgdc.Name.Local == "id" || _fdgdc.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _fdgdc.Name.Local == "id" {
			_ecdfe, _aacd := _fdgdc.Value, error(nil)
			if _aacd != nil {
				return _aacd
			}
			_eccg.IdAttr = _ecdfe
			continue
		}
		if _fdgdc.Name.Local == "shapeId" {
			_bdffa, _acbg := _g.ParseUint(_fdgdc.Value, 10, 32)
			if _acbg != nil {
				return _acbg
			}
			_eccg.ShapeIdAttr = uint32(_bdffa)
			continue
		}
		if _fdgdc.Name.Local == "name" {
			_ccade, _gagb := _fdgdc.Value, error(nil)
			if _gagb != nil {
				return _gagb
			}
			_eccg.NameAttr = &_ccade
			continue
		}
	}
_acaf:
	for {
		_acfdd, _ccdfb := d.Token()
		if _ccdfb != nil {
			return _ccdfb
		}
		switch _gbac := _acfdd.(type) {
		case _f.StartElement:
			switch _gbac.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "controlPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "controlPr"}:
				_eccg.ControlPr = NewCT_ControlPr()
				if _eagca := d.DecodeElement(_eccg.ControlPr, &_gbac); _eagca != nil {
					return _eagca
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_Control\u0020\u0025v", _gbac.Name)
				if _fbege := d.Skip(); _fbege != nil {
					return _fbege
				}
			}
		case _f.EndElement:
			break _acaf
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_GroupMember and its children
func (_ffdfd *CT_GroupMember) Validate() error { return _ffdfd.ValidateWithPath("CT_GroupMember") }
func (_dedca *CT_PivotAreaReference) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bafcf := range start.Attr {
		if _bafcf.Name.Local == "maxSubtotal" {
			_fbagb, _eadae := _g.ParseBool(_bafcf.Value)
			if _eadae != nil {
				return _eadae
			}
			_dedca.MaxSubtotalAttr = &_fbagb
			continue
		}
		if _bafcf.Name.Local == "minSubtotal" {
			_ceag, _eddbg := _g.ParseBool(_bafcf.Value)
			if _eddbg != nil {
				return _eddbg
			}
			_dedca.MinSubtotalAttr = &_ceag
			continue
		}
		if _bafcf.Name.Local == "count" {
			_cabga, _dcgeg := _g.ParseUint(_bafcf.Value, 10, 32)
			if _dcgeg != nil {
				return _dcgeg
			}
			_efbdca := uint32(_cabga)
			_dedca.CountAttr = &_efbdca
			continue
		}
		if _bafcf.Name.Local == "productSubtotal" {
			_fbgce, _gfcfac := _g.ParseBool(_bafcf.Value)
			if _gfcfac != nil {
				return _gfcfac
			}
			_dedca.ProductSubtotalAttr = &_fbgce
			continue
		}
		if _bafcf.Name.Local == "byPosition" {
			_bfdbfd, _fada := _g.ParseBool(_bafcf.Value)
			if _fada != nil {
				return _fada
			}
			_dedca.ByPositionAttr = &_bfdbfd
			continue
		}
		if _bafcf.Name.Local == "countSubtotal" {
			_badad, _aebfcd := _g.ParseBool(_bafcf.Value)
			if _aebfcd != nil {
				return _aebfcd
			}
			_dedca.CountSubtotalAttr = &_badad
			continue
		}
		if _bafcf.Name.Local == "defaultSubtotal" {
			_cabbb, _bcebb := _g.ParseBool(_bafcf.Value)
			if _bcebb != nil {
				return _bcebb
			}
			_dedca.DefaultSubtotalAttr = &_cabbb
			continue
		}
		if _bafcf.Name.Local == "countASubtotal" {
			_ccdbb, _bdcce := _g.ParseBool(_bafcf.Value)
			if _bdcce != nil {
				return _bdcce
			}
			_dedca.CountASubtotalAttr = &_ccdbb
			continue
		}
		if _bafcf.Name.Local == "avgSubtotal" {
			_egdad, _ccdcbb := _g.ParseBool(_bafcf.Value)
			if _ccdcbb != nil {
				return _ccdcbb
			}
			_dedca.AvgSubtotalAttr = &_egdad
			continue
		}
		if _bafcf.Name.Local == "field" {
			_eddff, _bbdeb := _g.ParseUint(_bafcf.Value, 10, 32)
			if _bbdeb != nil {
				return _bbdeb
			}
			_gfdad := uint32(_eddff)
			_dedca.FieldAttr = &_gfdad
			continue
		}
		if _bafcf.Name.Local == "selected" {
			_ebdac, _cddgff := _g.ParseBool(_bafcf.Value)
			if _cddgff != nil {
				return _cddgff
			}
			_dedca.SelectedAttr = &_ebdac
			continue
		}
		if _bafcf.Name.Local == "relative" {
			_aebfea, _cbeeg := _g.ParseBool(_bafcf.Value)
			if _cbeeg != nil {
				return _cbeeg
			}
			_dedca.RelativeAttr = &_aebfea
			continue
		}
		if _bafcf.Name.Local == "sumSubtotal" {
			_afced, _fedda := _g.ParseBool(_bafcf.Value)
			if _fedda != nil {
				return _fedda
			}
			_dedca.SumSubtotalAttr = &_afced
			continue
		}
		if _bafcf.Name.Local == "stdDevSubtotal" {
			_abbgg, _gdeda := _g.ParseBool(_bafcf.Value)
			if _gdeda != nil {
				return _gdeda
			}
			_dedca.StdDevSubtotalAttr = &_abbgg
			continue
		}
		if _bafcf.Name.Local == "stdDevPSubtotal" {
			_abccd, _dcffe := _g.ParseBool(_bafcf.Value)
			if _dcffe != nil {
				return _dcffe
			}
			_dedca.StdDevPSubtotalAttr = &_abccd
			continue
		}
		if _bafcf.Name.Local == "varSubtotal" {
			_egfefe, _fcbad := _g.ParseBool(_bafcf.Value)
			if _fcbad != nil {
				return _fcbad
			}
			_dedca.VarSubtotalAttr = &_egfefe
			continue
		}
		if _bafcf.Name.Local == "varPSubtotal" {
			_egdgf, _agedg := _g.ParseBool(_bafcf.Value)
			if _agedg != nil {
				return _agedg
			}
			_dedca.VarPSubtotalAttr = &_egdgf
			continue
		}
	}
_cdffa:
	for {
		_dgedd, _dadeda := d.Token()
		if _dadeda != nil {
			return _dadeda
		}
		switch _gbfef := _dgedd.(type) {
		case _f.StartElement:
			switch _gbfef.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "x"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "x"}:
				_aeaaf := NewCT_Index()
				if _cdeab := d.DecodeElement(_aeaaf, &_gbfef); _cdeab != nil {
					return _cdeab
				}
				_dedca.X = append(_dedca.X, _aeaaf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_dedca.ExtLst = NewCT_ExtensionList()
				if _bfbead := d.DecodeElement(_dedca.ExtLst, &_gbfef); _bfbead != nil {
					return _bfbead
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on CT_PivotAreaReference\u0020\u0025v", _gbfef.Name)
				if _cggac := d.Skip(); _cggac != nil {
					return _cggac
				}
			}
		case _f.EndElement:
			break _cdffa
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_MdxKPI() *CT_MdxKPI {
	_gfag := &CT_MdxKPI{}
	_gfag.PAttr = ST_MdxKPIProperty(1)
	return _gfag
}

// Validate validates the CT_Members and its children
func (_afaef *CT_Members) Validate() error { return _afaef.ValidateWithPath("CT_Members") }

// Validate validates the CT_ReviewedRevisions and its children
func (_adafc *CT_ReviewedRevisions) Validate() error {
	return _adafc.ValidateWithPath("CT_ReviewedRevisions")
}
func (_becgcc *ST_CredMethod) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_eeebdf, _eggge := d.Token()
	if _eggge != nil {
		return _eggge
	}
	if _ffgdbd, _aggdc := _eeebdf.(_f.EndElement); _aggdc && _ffgdbd.Name == start.Name {
		*_becgcc = 1
		return nil
	}
	if _cbccd, _baecfad := _eeebdf.(_f.CharData); !_baecfad {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eeebdf)
	} else {
		switch string(_cbccd) {
		case "":
			*_becgcc = 0
		case "integrated":
			*_becgcc = 1
		case "none":
			*_becgcc = 2
		case "stored":
			*_becgcc = 3
		case "prompt":
			*_becgcc = 4
		}
	}
	_eeebdf, _eggge = d.Token()
	if _eggge != nil {
		return _eggge
	}
	if _eaddd, _gccgg := _eeebdf.(_f.EndElement); _gccgg && _eaddd.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eeebdf)
}
func (_bfbbgf *CT_PivotCacheRecords) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ebbcg := range start.Attr {
		if _ebbcg.Name.Local == "count" {
			_ggbgc, _gdgfg := _g.ParseUint(_ebbcg.Value, 10, 32)
			if _gdgfg != nil {
				return _gdgfg
			}
			_bdccf := uint32(_ggbgc)
			_bfbbgf.CountAttr = &_bdccf
			continue
		}
	}
_ecgggg:
	for {
		_gfcge, _feccc := d.Token()
		if _feccc != nil {
			return _feccc
		}
		switch _ebfff := _gfcge.(type) {
		case _f.StartElement:
			switch _ebfff.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "r"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "r"}:
				_fcbab := NewCT_Record()
				if _cabad := d.DecodeElement(_fcbab, &_ebfff); _cabad != nil {
					return _cabad
				}
				_bfbbgf.R = append(_bfbbgf.R, _fcbab)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bfbbgf.ExtLst = NewCT_ExtensionList()
				if _agced := d.DecodeElement(_bfbbgf.ExtLst, &_ebfff); _agced != nil {
					return _agced
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on\u0020CT_PivotCacheRecords\u0020\u0025v", _ebfff.Name)
				if _dggbe := d.Skip(); _dggbe != nil {
					return _dggbe
				}
			}
		case _f.EndElement:
			break _ecgggg
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PivotSelection and its children, prefixing error messages with path
func (_acdbea *CT_PivotSelection) ValidateWithPath(path string) error {
	if _cgagb := _acdbea.PaneAttr.ValidateWithPath(path + "\u002fPaneAttr"); _cgagb != nil {
		return _cgagb
	}
	if _egabb := _acdbea.AxisAttr.ValidateWithPath(path + "\u002fAxisAttr"); _egabb != nil {
		return _egabb
	}
	if _afggab := _acdbea.PivotArea.ValidateWithPath(path + "\u002fPivotArea"); _afggab != nil {
		return _afggab
	}
	return nil
}
func (_efagc *CT_XmlCellPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", _efagc.IdAttr)})
	if _efagc.UniqueNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueName"}, Value: _bg.Sprintf("\u0025v", *_efagc.UniqueNameAttr)})
	}
	e.EncodeToken(start)
	_bcbcaag := _f.StartElement{Name: _f.Name{Local: "ma:xmlPr"}}
	e.EncodeElement(_efagc.XmlPr, _bcbcaag)
	if _efagc.ExtLst != nil {
		_adgdd := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_efagc.ExtLst, _adgdd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_QueryTableFields and its children, prefixing error messages with path
func (_cada *CT_QueryTableFields) ValidateWithPath(path string) error {
	for _fbdb, _fgagc := range _cada.QueryTableField {
		if _cfdga := _fgagc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fQueryTableField\u005b\u0025d\u005d", path, _fbdb)); _cfdga != nil {
			return _cfdga
		}
	}
	return nil
}
func (_gdefd *CT_ExternalRow) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", _gdefd.RAttr)})
	e.EncodeToken(start)
	if _gdefd.Cell != nil {
		_fbeff := _f.StartElement{Name: _f.Name{Local: "ma:cell"}}
		for _, _ddfdb := range _gdefd.Cell {
			e.EncodeElement(_ddfdb, _fbeff)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_Field struct {

	// Field Index
	XAttr int32
}

func (_bbggd *CT_MetadataStrings) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bbggd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bbggd.CountAttr)})
	}
	e.EncodeToken(start)
	_cccef := _f.StartElement{Name: _f.Name{Local: "ma:s"}}
	for _, _ggbfd := range _bbggd.S {
		e.EncodeElement(_ggbfd, _cccef)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Workbook and its children, prefixing error messages with path
func (_fggdf *CT_Workbook) ValidateWithPath(path string) error {
	if _fecgba := _fggdf.ConformanceAttr.ValidateWithPath(path + "\u002fConformanceAttr"); _fecgba != nil {
		return _fecgba
	}
	if _fggdf.FileVersion != nil {
		if _dfebdgc := _fggdf.FileVersion.ValidateWithPath(path + "\u002fFileVersion"); _dfebdgc != nil {
			return _dfebdgc
		}
	}
	if _fggdf.FileSharing != nil {
		if _afbdc := _fggdf.FileSharing.ValidateWithPath(path + "\u002fFileSharing"); _afbdc != nil {
			return _afbdc
		}
	}
	if _fggdf.WorkbookPr != nil {
		if _dcfdd := _fggdf.WorkbookPr.ValidateWithPath(path + "/WorkbookPr"); _dcfdd != nil {
			return _dcfdd
		}
	}
	if _fggdf.WorkbookProtection != nil {
		if _gbceg := _fggdf.WorkbookProtection.ValidateWithPath(path + "\u002fWorkbookProtection"); _gbceg != nil {
			return _gbceg
		}
	}
	if _fggdf.BookViews != nil {
		if _aacba := _fggdf.BookViews.ValidateWithPath(path + "\u002fBookViews"); _aacba != nil {
			return _aacba
		}
	}
	if _bafgg := _fggdf.Sheets.ValidateWithPath(path + "\u002fSheets"); _bafgg != nil {
		return _bafgg
	}
	if _fggdf.FunctionGroups != nil {
		if _defcdf := _fggdf.FunctionGroups.ValidateWithPath(path + "\u002fFunctionGroups"); _defcdf != nil {
			return _defcdf
		}
	}
	if _fggdf.ExternalReferences != nil {
		if _fedfd := _fggdf.ExternalReferences.ValidateWithPath(path + "\u002fExternalReferences"); _fedfd != nil {
			return _fedfd
		}
	}
	if _fggdf.DefinedNames != nil {
		if _efag := _fggdf.DefinedNames.ValidateWithPath(path + "\u002fDefinedNames"); _efag != nil {
			return _efag
		}
	}
	if _fggdf.CalcPr != nil {
		if _cceadd := _fggdf.CalcPr.ValidateWithPath(path + "\u002fCalcPr"); _cceadd != nil {
			return _cceadd
		}
	}
	if _fggdf.OleSize != nil {
		if _fbaebd := _fggdf.OleSize.ValidateWithPath(path + "\u002fOleSize"); _fbaebd != nil {
			return _fbaebd
		}
	}
	if _fggdf.CustomWorkbookViews != nil {
		if _fadfaa := _fggdf.CustomWorkbookViews.ValidateWithPath(path + "/CustomWorkbookViews"); _fadfaa != nil {
			return _fadfaa
		}
	}
	if _fggdf.PivotCaches != nil {
		if _bgcbb := _fggdf.PivotCaches.ValidateWithPath(path + "\u002fPivotCaches"); _bgcbb != nil {
			return _bgcbb
		}
	}
	if _fggdf.SmartTagPr != nil {
		if _fggffg := _fggdf.SmartTagPr.ValidateWithPath(path + "/SmartTagPr"); _fggffg != nil {
			return _fggffg
		}
	}
	if _fggdf.SmartTagTypes != nil {
		if _facecg := _fggdf.SmartTagTypes.ValidateWithPath(path + "\u002fSmartTagTypes"); _facecg != nil {
			return _facecg
		}
	}
	if _fggdf.WebPublishing != nil {
		if _acgfe := _fggdf.WebPublishing.ValidateWithPath(path + "\u002fWebPublishing"); _acgfe != nil {
			return _acgfe
		}
	}
	for _eafcd, _dfbdf := range _fggdf.FileRecoveryPr {
		if _addae := _dfbdf.ValidateWithPath(_bg.Sprintf("%s\u002fFileRecoveryPr\u005b\u0025d\u005d", path, _eafcd)); _addae != nil {
			return _addae
		}
	}
	if _fggdf.WebPublishObjects != nil {
		if _dgeegf := _fggdf.WebPublishObjects.ValidateWithPath(path + "\u002fWebPublishObjects"); _dgeegf != nil {
			return _dgeegf
		}
	}
	if _fggdf.ExtLst != nil {
		if _gdgccc := _fggdf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gdgccc != nil {
			return _gdgccc
		}
	}
	return nil
}

// Validate validates the Worksheet and its children
func (_edgac *Worksheet) Validate() error { return _edgac.ValidateWithPath("Worksheet") }

// ValidateWithPath validates the CT_UnderlineProperty and its children, prefixing error messages with path
func (_fgeaec *CT_UnderlineProperty) ValidateWithPath(path string) error {
	if _fabbd := _fgeaec.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _fabbd != nil {
		return _fabbd
	}
	return nil
}
func (_age *CT_CellSmartTag) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aaeb := range start.Attr {
		if _aaeb.Name.Local == "type" {
			_geacb, _cfbe := _g.ParseUint(_aaeb.Value, 10, 32)
			if _cfbe != nil {
				return _cfbe
			}
			_age.TypeAttr = uint32(_geacb)
			continue
		}
		if _aaeb.Name.Local == "deleted" {
			_bbdc, _gca := _g.ParseBool(_aaeb.Value)
			if _gca != nil {
				return _gca
			}
			_age.DeletedAttr = &_bbdc
			continue
		}
		if _aaeb.Name.Local == "xmlBased" {
			_gabf, _bcd := _g.ParseBool(_aaeb.Value)
			if _bcd != nil {
				return _bcd
			}
			_age.XmlBasedAttr = &_gabf
			continue
		}
	}
_aaea:
	for {
		_eaag, _afcc := d.Token()
		if _afcc != nil {
			return _afcc
		}
		switch _dfe := _eaag.(type) {
		case _f.StartElement:
			switch _dfe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellSmartTagPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellSmartTagPr"}:
				_acbb := NewCT_CellSmartTagPr()
				if _affee := d.DecodeElement(_acbb, &_dfe); _affee != nil {
					return _affee
				}
				_age.CellSmartTagPr = append(_age.CellSmartTagPr, _acbb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CellSmartTag\u0020\u0025v", _dfe.Name)
				if _dcf := d.Skip(); _dcf != nil {
					return _dcf
				}
			}
		case _f.EndElement:
			break _aaea
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_SheetBackgroundPicture() *CT_SheetBackgroundPicture {
	_ebeggc := &CT_SheetBackgroundPicture{}
	return _ebeggc
}

// ValidateWithPath validates the CT_ColorFilter and its children, prefixing error messages with path
func (_aagdb *CT_ColorFilter) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_Field and its children, prefixing error messages with path
func (_edcdc *CT_Field) ValidateWithPath(path string) error { return nil }
func (_bcdfd *CT_PivotFields) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bcdfd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bcdfd.CountAttr)})
	}
	e.EncodeToken(start)
	_bcebf := _f.StartElement{Name: _f.Name{Local: "ma:pivotField"}}
	for _, _gefgd := range _bcdfd.PivotField {
		e.EncodeElement(_gefgd, _bcebf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_ExtensionList struct {

	// Extension
	Ext []*CT_Extension
}
type CT_RevisionQueryTableField struct {

	// Sheet Id
	SheetIdAttr uint32

	// QueryTable Reference
	RefAttr string

	// Field Id
	FieldIdAttr uint32
}

func (_gacad ST_MdxSetOrder) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_cfddd := _f.Attr{}
	_cfddd.Name = name
	switch _gacad {
	case ST_MdxSetOrderUnset:
		_cfddd.Value = ""
	case ST_MdxSetOrderU:
		_cfddd.Value = "u"
	case ST_MdxSetOrderA:
		_cfddd.Value = "a"
	case ST_MdxSetOrderD:
		_cfddd.Value = "d"
	case ST_MdxSetOrderAa:
		_cfddd.Value = "aa"
	case ST_MdxSetOrderAd:
		_cfddd.Value = "ad"
	case ST_MdxSetOrderNa:
		_cfddd.Value = "na"
	case ST_MdxSetOrderNd:
		_cfddd.Value = "nd"
	}
	return _cfddd, nil
}

type ST_FieldSortType byte
type CT_ChartsheetViews struct {

	// Chart Sheet View
	SheetView []*CT_ChartsheetView
	ExtLst    *CT_ExtensionList
}
type ST_PhoneticAlignment byte

// Validate validates the CT_CustomWorkbookViews and its children
func (_facf *CT_CustomWorkbookViews) Validate() error {
	return _facf.ValidateWithPath("CT_CustomWorkbookViews")
}

const (
	ST_SortByUnset     ST_SortBy = 0
	ST_SortByValue     ST_SortBy = 1
	ST_SortByCellColor ST_SortBy = 2
	ST_SortByFontColor ST_SortBy = 3
	ST_SortByIcon      ST_SortBy = 4
)

func (_bgdgd *CT_MeasureDimensionMaps) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bgdgd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bgdgd.CountAttr)})
	}
	e.EncodeToken(start)
	if _bgdgd.Map != nil {
		_adagg := _f.StartElement{Name: _f.Name{Local: "ma:map"}}
		for _, _ggdd := range _bgdgd.Map {
			e.EncodeElement(_ggdd, _adagg)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type ST_TimePeriod byte

func (_fgdbc ST_CellType) String() string {
	switch _fgdbc {
	case 0:
		return ""
	case 1:
		return "b"
	case 2:
		return "n"
	case 3:
		return "e"
	case 4:
		return "s"
	case 5:
		return "str"
	case 6:
		return "inlineStr"
	}
	return ""
}

// ValidateWithPath validates the CT_CustomSheetViews and its children, prefixing error messages with path
func (_aaab *CT_CustomSheetViews) ValidateWithPath(path string) error {
	for _bccf, _fcedd := range _aaab.CustomSheetView {
		if _fcea := _fcedd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCustomSheetView\u005b\u0025d\u005d", path, _bccf)); _fcea != nil {
			return _fcea
		}
	}
	return nil
}
func NewPivotCacheDefinition() *PivotCacheDefinition {
	_edabf := &PivotCacheDefinition{}
	_edabf.CT_PivotCacheDefinition = *NewCT_PivotCacheDefinition()
	return _edabf
}
func (_dbgcdc *CT_SingleXmlCells) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_eccaca := _f.StartElement{Name: _f.Name{Local: "ma:singleXmlCell"}}
	for _, _effdgc := range _dbgcdc.SingleXmlCell {
		e.EncodeElement(_effdgc, _eccaca)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ceebf *CT_RevisionQueryTableField) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetId"}, Value: _bg.Sprintf("\u0025v", _ceebf.SheetIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _ceebf.RefAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fieldId"}, Value: _bg.Sprintf("\u0025v", _ceebf.FieldIdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_egef *CT_Boolean) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ebb := range start.Attr {
		if _ebb.Name.Local == "v" {
			_add, _gddb := _g.ParseBool(_ebb.Value)
			if _gddb != nil {
				return _gddb
			}
			_egef.VAttr = _add
			continue
		}
		if _ebb.Name.Local == "u" {
			_bfa, _aaa := _g.ParseBool(_ebb.Value)
			if _aaa != nil {
				return _aaa
			}
			_egef.UAttr = &_bfa
			continue
		}
		if _ebb.Name.Local == "f" {
			_adbb, _aegf := _g.ParseBool(_ebb.Value)
			if _aegf != nil {
				return _aegf
			}
			_egef.FAttr = &_adbb
			continue
		}
		if _ebb.Name.Local == "c" {
			_cbfc, _aed := _ebb.Value, error(nil)
			if _aed != nil {
				return _aed
			}
			_egef.CAttr = &_cbfc
			continue
		}
		if _ebb.Name.Local == "cp" {
			_feg, _fcge := _g.ParseUint(_ebb.Value, 10, 32)
			if _fcge != nil {
				return _fcge
			}
			_gaade := uint32(_feg)
			_egef.CpAttr = &_gaade
			continue
		}
	}
_caae:
	for {
		_fae, _acg := d.Token()
		if _acg != nil {
			return _acg
		}
		switch _dcdd := _fae.(type) {
		case _f.StartElement:
			switch _dcdd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "x"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "x"}:
				_aaae := NewCT_X()
				if _bdbe := d.DecodeElement(_aaae, &_dcdd); _bdbe != nil {
					return _bdbe
				}
				_egef.X = append(_egef.X, _aaae)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_Boolean\u0020\u0025v", _dcdd.Name)
				if _ge := d.Skip(); _ge != nil {
					return _ge
				}
			}
		case _f.EndElement:
			break _caae
		case _f.CharData:
		}
	}
	return nil
}
func (_eecgf ST_MdxKPIProperty) ValidateWithPath(path string) error {
	switch _eecgf {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eecgf))
	}
	return nil
}
func (_eafee *CT_CustomSheetView) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_eafee.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	for _, _ccfcg := range start.Attr {
		if _ccfcg.Name.Local == "state" {
			_eafee.StateAttr.UnmarshalXMLAttr(_ccfcg)
			continue
		}
		if _ccfcg.Name.Local == "guid" {
			_dddbd, _dgefd := _ccfcg.Value, error(nil)
			if _dgefd != nil {
				return _dgefd
			}
			_eafee.GuidAttr = _dddbd
			continue
		}
		if _ccfcg.Name.Local == "filterUnique" {
			_aafdg, _adbec := _g.ParseBool(_ccfcg.Value)
			if _adbec != nil {
				return _adbec
			}
			_eafee.FilterUniqueAttr = &_aafdg
			continue
		}
		if _ccfcg.Name.Local == "colorId" {
			_edfa, _decgc := _g.ParseUint(_ccfcg.Value, 10, 32)
			if _decgc != nil {
				return _decgc
			}
			_gdcad := uint32(_edfa)
			_eafee.ColorIdAttr = &_gdcad
			continue
		}
		if _ccfcg.Name.Local == "view" {
			_eafee.ViewAttr.UnmarshalXMLAttr(_ccfcg)
			continue
		}
		if _ccfcg.Name.Local == "showFormulas" {
			_bfbc, _edce := _g.ParseBool(_ccfcg.Value)
			if _edce != nil {
				return _edce
			}
			_eafee.ShowFormulasAttr = &_bfbc
			continue
		}
		if _ccfcg.Name.Local == "showRuler" {
			_cagb, _efcd := _g.ParseBool(_ccfcg.Value)
			if _efcd != nil {
				return _efcd
			}
			_eafee.ShowRulerAttr = &_cagb
			continue
		}
		if _ccfcg.Name.Local == "showRowCol" {
			_egfa, _edbe := _g.ParseBool(_ccfcg.Value)
			if _edbe != nil {
				return _edbe
			}
			_eafee.ShowRowColAttr = &_egfa
			continue
		}
		if _ccfcg.Name.Local == "topLeftCell" {
			_gada, _cedgb := _ccfcg.Value, error(nil)
			if _cedgb != nil {
				return _cedgb
			}
			_eafee.TopLeftCellAttr = &_gada
			continue
		}
		if _ccfcg.Name.Local == "zeroValues" {
			_bgdf, _gecbf := _g.ParseBool(_ccfcg.Value)
			if _gecbf != nil {
				return _gecbf
			}
			_eafee.ZeroValuesAttr = &_bgdf
			continue
		}
		if _ccfcg.Name.Local == "hiddenColumns" {
			_cbfag, _fgbe := _g.ParseBool(_ccfcg.Value)
			if _fgbe != nil {
				return _fgbe
			}
			_eafee.HiddenColumnsAttr = &_cbfag
			continue
		}
		if _ccfcg.Name.Local == "outlineSymbols" {
			_cgee, _bdgf := _g.ParseBool(_ccfcg.Value)
			if _bdgf != nil {
				return _bdgf
			}
			_eafee.OutlineSymbolsAttr = &_cgee
			continue
		}
		if _ccfcg.Name.Local == "filter" {
			_acdg, _gebcd := _g.ParseBool(_ccfcg.Value)
			if _gebcd != nil {
				return _gebcd
			}
			_eafee.FilterAttr = &_acdg
			continue
		}
		if _ccfcg.Name.Local == "scale" {
			_faaa, _ecddf := _g.ParseUint(_ccfcg.Value, 10, 32)
			if _ecddf != nil {
				return _ecddf
			}
			_dbfee := uint32(_faaa)
			_eafee.ScaleAttr = &_dbfee
			continue
		}
		if _ccfcg.Name.Local == "showGridLines" {
			_bafcd, _aege := _g.ParseBool(_ccfcg.Value)
			if _aege != nil {
				return _aege
			}
			_eafee.ShowGridLinesAttr = &_bafcd
			continue
		}
		if _ccfcg.Name.Local == "hiddenRows" {
			_cadbd, _geeb := _g.ParseBool(_ccfcg.Value)
			if _geeb != nil {
				return _geeb
			}
			_eafee.HiddenRowsAttr = &_cadbd
			continue
		}
		if _ccfcg.Name.Local == "fitToPage" {
			_dggb, _gfgde := _g.ParseBool(_ccfcg.Value)
			if _gfgde != nil {
				return _gfgde
			}
			_eafee.FitToPageAttr = &_dggb
			continue
		}
		if _ccfcg.Name.Local == "printArea" {
			_bgaef, _ccedd := _g.ParseBool(_ccfcg.Value)
			if _ccedd != nil {
				return _ccedd
			}
			_eafee.PrintAreaAttr = &_bgaef
			continue
		}
		if _ccfcg.Name.Local == "showAutoFilter" {
			_befc, _cacg := _g.ParseBool(_ccfcg.Value)
			if _cacg != nil {
				return _cacg
			}
			_eafee.ShowAutoFilterAttr = &_befc
			continue
		}
		if _ccfcg.Name.Local == "showPageBreaks" {
			_afbg, _cbaa := _g.ParseBool(_ccfcg.Value)
			if _cbaa != nil {
				return _cbaa
			}
			_eafee.ShowPageBreaksAttr = &_afbg
			continue
		}
	}
_gggdf:
	for {
		_egeb, _cdcg := d.Token()
		if _cdcg != nil {
			return _cdcg
		}
		switch _fcef := _egeb.(type) {
		case _f.StartElement:
			switch _fcef.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pane"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pane"}:
				_eafee.Pane = NewCT_Pane()
				if _edfb := d.DecodeElement(_eafee.Pane, &_fcef); _edfb != nil {
					return _edfb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "selection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "selection"}:
				_eafee.Selection = NewCT_Selection()
				if _cecf := d.DecodeElement(_eafee.Selection, &_fcef); _cecf != nil {
					return _cecf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rowBreaks"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rowBreaks"}:
				_eafee.RowBreaks = NewCT_PageBreak()
				if _ddcf := d.DecodeElement(_eafee.RowBreaks, &_fcef); _ddcf != nil {
					return _ddcf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colBreaks"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colBreaks"}:
				_eafee.ColBreaks = NewCT_PageBreak()
				if _abef := d.DecodeElement(_eafee.ColBreaks, &_fcef); _abef != nil {
					return _abef
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageMargins"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageMargins"}:
				_eafee.PageMargins = NewCT_PageMargins()
				if _decde := d.DecodeElement(_eafee.PageMargins, &_fcef); _decde != nil {
					return _decde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "printOptions"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "printOptions"}:
				_eafee.PrintOptions = NewCT_PrintOptions()
				if _dcdf := d.DecodeElement(_eafee.PrintOptions, &_fcef); _dcdf != nil {
					return _dcdf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageSetup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageSetup"}:
				_eafee.PageSetup = NewCT_PageSetup()
				if _bfdg := d.DecodeElement(_eafee.PageSetup, &_fcef); _bfdg != nil {
					return _bfdg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "headerFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "headerFooter"}:
				_eafee.HeaderFooter = NewCT_HeaderFooter()
				if _bafeg := d.DecodeElement(_eafee.HeaderFooter, &_fcef); _bafeg != nil {
					return _bafeg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "autoFilter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "autoFilter"}:
				_eafee.AutoFilter = NewCT_AutoFilter()
				if _ddbbc := d.DecodeElement(_eafee.AutoFilter, &_fcef); _ddbbc != nil {
					return _ddbbc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_eafee.ExtLst = NewCT_ExtensionList()
				if _dfaff := d.DecodeElement(_eafee.ExtLst, &_fcef); _dfaff != nil {
					return _dfaff
				}
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_CustomSheetView\u0020\u0025v", _fcef.Name)
				if _eced := d.Skip(); _eced != nil {
					return _eced
				}
			}
		case _f.EndElement:
			break _gggdf
		case _f.CharData:
		}
	}
	return nil
}
func (_abgag *ST_DataValidationType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_abgag = 0
	case "none":
		*_abgag = 1
	case "whole":
		*_abgag = 2
	case "decimal":
		*_abgag = 3
	case "list":
		*_abgag = 4
	case "date":
		*_abgag = 5
	case "time":
		*_abgag = 6
	case "textLength":
		*_abgag = 7
	case "custom":
		*_abgag = 8
	}
	return nil
}
func (_dage *CT_PCDSDTCEntries) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dage.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_dage.CountAttr)})
	}
	e.EncodeToken(start)
	if _dage.M != nil {
		_cabeb := _f.StartElement{Name: _f.Name{Local: "ma:m"}}
		for _, _afabbe := range _dage.M {
			e.EncodeElement(_afabbe, _cabeb)
		}
	}
	if _dage.N != nil {
		_dbcbc := _f.StartElement{Name: _f.Name{Local: "ma:n"}}
		for _, _ecfa := range _dage.N {
			e.EncodeElement(_ecfa, _dbcbc)
		}
	}
	if _dage.E != nil {
		_ebfdg := _f.StartElement{Name: _f.Name{Local: "ma:e"}}
		for _, _gebdg := range _dage.E {
			e.EncodeElement(_gebdg, _ebfdg)
		}
	}
	if _dage.S != nil {
		_eagg := _f.StartElement{Name: _f.Name{Local: "ma:s"}}
		for _, _aecbf := range _dage.S {
			e.EncodeElement(_aecbf, _eagg)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

const (
	ST_FieldSortTypeUnset      ST_FieldSortType = 0
	ST_FieldSortTypeManual     ST_FieldSortType = 1
	ST_FieldSortTypeAscending  ST_FieldSortType = 2
	ST_FieldSortTypeDescending ST_FieldSortType = 3
)

func (_decad *CT_FunctionGroups) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _decad.BuiltInGroupCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "builtInGroupCount"}, Value: _bg.Sprintf("\u0025v", *_decad.BuiltInGroupCountAttr)})
	}
	e.EncodeToken(start)
	if _decad.FunctionGroup != nil {
		_aegef := _f.StartElement{Name: _f.Name{Local: "ma:functionGroup"}}
		for _, _edfbc := range _decad.FunctionGroup {
			e.EncodeElement(_edfbc, _aegef)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Hyperlink and its children, prefixing error messages with path
func (_acfac *CT_Hyperlink) ValidateWithPath(path string) error { return nil }
func (_dafbg *ST_PhoneticType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cgcfa, _dcaag := d.Token()
	if _dcaag != nil {
		return _dcaag
	}
	if _dadegf, _ecfbf := _cgcfa.(_f.EndElement); _ecfbf && _dadegf.Name == start.Name {
		*_dafbg = 1
		return nil
	}
	if _fafdca, _ecbfgc := _cgcfa.(_f.CharData); !_ecbfgc {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cgcfa)
	} else {
		switch string(_fafdca) {
		case "":
			*_dafbg = 0
		case "halfwidthKatakana":
			*_dafbg = 1
		case "fullwidthKatakana":
			*_dafbg = 2
		case "Hiragana":
			*_dafbg = 3
		case "noConversion":
			*_dafbg = 4
		}
	}
	_cgcfa, _dcaag = d.Token()
	if _dcaag != nil {
		return _dcaag
	}
	if _dbgbf, _eccbgf := _cgcfa.(_f.EndElement); _eccbgf && _dbgbf.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cgcfa)
}
func (_cbfdf *CT_MergeCells) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gabfb := range start.Attr {
		if _gabfb.Name.Local == "count" {
			_ecded, _fdfea := _g.ParseUint(_gabfb.Value, 10, 32)
			if _fdfea != nil {
				return _fdfea
			}
			_fadgbc := uint32(_ecded)
			_cbfdf.CountAttr = &_fadgbc
			continue
		}
	}
_gbbef:
	for {
		_bebdd, _edfgb := d.Token()
		if _edfgb != nil {
			return _edfgb
		}
		switch _edae := _bebdd.(type) {
		case _f.StartElement:
			switch _edae.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "mergeCell"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "mergeCell"}:
				_fgfc := NewCT_MergeCell()
				if _agbad := d.DecodeElement(_fgfc, &_edae); _agbad != nil {
					return _agbad
				}
				_cbfdf.MergeCell = append(_cbfdf.MergeCell, _fgfc)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_MergeCells \u0025v", _edae.Name)
				if _aagfff := d.Skip(); _aagfff != nil {
					return _aagfff
				}
			}
		case _f.EndElement:
			break _gbbef
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the Worksheet and its children, prefixing error messages with path
func (_fcggcc *Worksheet) ValidateWithPath(path string) error {
	if _ddgecb := _fcggcc.CT_Worksheet.ValidateWithPath(path); _ddgecb != nil {
		return _ddgecb
	}
	return nil
}

type ST_FontScheme byte

func (_ebfffb *CT_Stylesheet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _ebfffb.NumFmts != nil {
		_fbcde := _f.StartElement{Name: _f.Name{Local: "ma:numFmts"}}
		e.EncodeElement(_ebfffb.NumFmts, _fbcde)
	}
	if _ebfffb.Fonts != nil {
		_gafef := _f.StartElement{Name: _f.Name{Local: "ma:fonts"}}
		e.EncodeElement(_ebfffb.Fonts, _gafef)
	}
	if _ebfffb.Fills != nil {
		_edfdcf := _f.StartElement{Name: _f.Name{Local: "ma:fills"}}
		e.EncodeElement(_ebfffb.Fills, _edfdcf)
	}
	if _ebfffb.Borders != nil {
		_dgdbaa := _f.StartElement{Name: _f.Name{Local: "ma:borders"}}
		e.EncodeElement(_ebfffb.Borders, _dgdbaa)
	}
	if _ebfffb.CellStyleXfs != nil {
		_edegg := _f.StartElement{Name: _f.Name{Local: "ma:cellStyleXfs"}}
		e.EncodeElement(_ebfffb.CellStyleXfs, _edegg)
	}
	if _ebfffb.CellXfs != nil {
		_egced := _f.StartElement{Name: _f.Name{Local: "ma:cellXfs"}}
		e.EncodeElement(_ebfffb.CellXfs, _egced)
	}
	if _ebfffb.CellStyles != nil {
		_bcfgc := _f.StartElement{Name: _f.Name{Local: "ma:cellStyles"}}
		e.EncodeElement(_ebfffb.CellStyles, _bcfgc)
	}
	if _ebfffb.Dxfs != nil {
		_ddbcf := _f.StartElement{Name: _f.Name{Local: "ma:dxfs"}}
		e.EncodeElement(_ebfffb.Dxfs, _ddbcf)
	}
	if _ebfffb.TableStyles != nil {
		_efea := _f.StartElement{Name: _f.Name{Local: "ma:tableStyles"}}
		e.EncodeElement(_ebfffb.TableStyles, _efea)
	}
	if _ebfffb.Colors != nil {
		_faedg := _f.StartElement{Name: _f.Name{Local: "ma:colors"}}
		e.EncodeElement(_ebfffb.Colors, _faedg)
	}
	if _ebfffb.ExtLst != nil {
		_ddfdc := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_ebfffb.ExtLst, _ddfdc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_ExternalRow struct {

	// Row
	RAttr uint32

	// External Cell Data
	Cell []*CT_ExternalCell
}
type CT_Filter struct {

	// Filter Value
	ValAttr *string
}
type ST_HtmlFmt byte

func (_gaefb *CT_SingleXmlCell) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", _gaefb.IdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", _gaefb.RAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "connectionId"}, Value: _bg.Sprintf("\u0025v", _gaefb.ConnectionIdAttr)})
	e.EncodeToken(start)
	_fdfdfa := _f.StartElement{Name: _f.Name{Local: "ma:xmlCellPr"}}
	e.EncodeElement(_gaefb.XmlCellPr, _fdfdfa)
	if _gaefb.ExtLst != nil {
		_fcgba := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_gaefb.ExtLst, _fcgba)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_SmartTags struct {

	// Cell Smart Tags
	CellSmartTags []*CT_CellSmartTags
}

func (_eebbf ST_SheetState) ValidateWithPath(path string) error {
	switch _eebbf {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eebbf))
	}
	return nil
}
func (_gggag *CT_TableStyleInfo) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gggag.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_gggag.NameAttr)})
	}
	if _gggag.ShowFirstColumnAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showFirstColumn"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gggag.ShowFirstColumnAttr))})
	}
	if _gggag.ShowLastColumnAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showLastColumn"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gggag.ShowLastColumnAttr))})
	}
	if _gggag.ShowRowStripesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showRowStripes"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gggag.ShowRowStripesAttr))})
	}
	if _gggag.ShowColumnStripesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showColumnStripes"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gggag.ShowColumnStripesAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TextFields and its children
func (_ggdae *CT_TextFields) Validate() error      { return _ggdae.ValidateWithPath("CT_TextFields") }
func NewCT_WebPublishObject() *CT_WebPublishObject { _ddbab := &CT_WebPublishObject{}; return _ddbab }

type CT_Sst struct {

	// String Count
	CountAttr *uint32

	// Unique String Count
	UniqueCountAttr *uint32

	// String Item
	Si     []*CT_Rst
	ExtLst *CT_ExtensionList
}

// Validate validates the CT_MetadataTypes and its children
func (_gedab *CT_MetadataTypes) Validate() error { return _gedab.ValidateWithPath("CT_MetadataTypes") }
func (_cegdg *ST_Qualifier) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_cegdg = 0
	case "doubleQuote":
		*_cegdg = 1
	case "singleQuote":
		*_cegdg = 2
	case "none":
		*_cegdg = 3
	}
	return nil
}
func (_ecd *CT_CacheHierarchy) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueName"}, Value: _bg.Sprintf("\u0025v", _ecd.UniqueNameAttr)})
	if _ecd.CaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "caption"}, Value: _bg.Sprintf("\u0025v", *_ecd.CaptionAttr)})
	}
	if _ecd.MeasureAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "measure"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecd.MeasureAttr))})
	}
	if _ecd.SetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "set"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecd.SetAttr))})
	}
	if _ecd.ParentSetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "parentSet"}, Value: _bg.Sprintf("\u0025v", *_ecd.ParentSetAttr)})
	}
	if _ecd.IconSetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "iconSet"}, Value: _bg.Sprintf("\u0025v", *_ecd.IconSetAttr)})
	}
	if _ecd.AttributeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "attribute"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecd.AttributeAttr))})
	}
	if _ecd.TimeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "time"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecd.TimeAttr))})
	}
	if _ecd.KeyAttributeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "keyAttribute"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecd.KeyAttributeAttr))})
	}
	if _ecd.DefaultMemberUniqueNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultMemberUniqueName"}, Value: _bg.Sprintf("\u0025v", *_ecd.DefaultMemberUniqueNameAttr)})
	}
	if _ecd.AllUniqueNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "allUniqueName"}, Value: _bg.Sprintf("\u0025v", *_ecd.AllUniqueNameAttr)})
	}
	if _ecd.AllCaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "allCaption"}, Value: _bg.Sprintf("\u0025v", *_ecd.AllCaptionAttr)})
	}
	if _ecd.DimensionUniqueNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dimensionUniqueName"}, Value: _bg.Sprintf("\u0025v", *_ecd.DimensionUniqueNameAttr)})
	}
	if _ecd.DisplayFolderAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "displayFolder"}, Value: _bg.Sprintf("\u0025v", *_ecd.DisplayFolderAttr)})
	}
	if _ecd.MeasureGroupAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "measureGroup"}, Value: _bg.Sprintf("\u0025v", *_ecd.MeasureGroupAttr)})
	}
	if _ecd.MeasuresAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "measures"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecd.MeasuresAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", _ecd.CountAttr)})
	if _ecd.OneFieldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oneField"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecd.OneFieldAttr))})
	}
	if _ecd.MemberValueDatatypeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "memberValueDatatype"}, Value: _bg.Sprintf("\u0025v", *_ecd.MemberValueDatatypeAttr)})
	}
	if _ecd.UnbalancedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "unbalanced"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecd.UnbalancedAttr))})
	}
	if _ecd.UnbalancedGroupAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "unbalancedGroup"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecd.UnbalancedGroupAttr))})
	}
	if _ecd.HiddenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hidden"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecd.HiddenAttr))})
	}
	e.EncodeToken(start)
	if _ecd.FieldsUsage != nil {
		_cefdc := _f.StartElement{Name: _f.Name{Local: "ma:fieldsUsage"}}
		e.EncodeElement(_ecd.FieldsUsage, _cefdc)
	}
	if _ecd.GroupLevels != nil {
		_ffef := _f.StartElement{Name: _f.Name{Local: "ma:groupLevels"}}
		e.EncodeElement(_ecd.GroupLevels, _ffef)
	}
	if _ecd.ExtLst != nil {
		_gaag := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_ecd.ExtLst, _gaag)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_ConditionalFormatting struct {

	// PivotTable Conditional Formatting
	PivotAttr *bool

	// Sequence of References
	SqrefAttr *ST_Sqref

	// Conditional Formatting Rule
	CfRule []*CT_CfRule
	ExtLst *CT_ExtensionList
}

func NewCT_PivotTableStyle() *CT_PivotTableStyle { _edgda := &CT_PivotTableStyle{}; return _edgda }
func NewCT_LegacyDrawing() *CT_LegacyDrawing     { _cccb := &CT_LegacyDrawing{}; return _cccb }
func (_defagg *CT_RangePr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _defagg.AutoStartAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoStart"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_defagg.AutoStartAttr))})
	}
	if _defagg.AutoEndAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoEnd"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_defagg.AutoEndAttr))})
	}
	if _defagg.GroupByAttr != ST_GroupByUnset {
		_dgfgc, _cefdag := _defagg.GroupByAttr.MarshalXMLAttr(_f.Name{Local: "groupBy"})
		if _cefdag != nil {
			return _cefdag
		}
		start.Attr = append(start.Attr, _dgfgc)
	}
	if _defagg.StartNumAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "startNum"}, Value: _bg.Sprintf("\u0025v", *_defagg.StartNumAttr)})
	}
	if _defagg.EndNumAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "endNum"}, Value: _bg.Sprintf("\u0025v", *_defagg.EndNumAttr)})
	}
	if _defagg.StartDateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "startDate"}, Value: _bg.Sprintf("\u0025v", *_defagg.StartDateAttr)})
	}
	if _defagg.EndDateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "endDate"}, Value: _bg.Sprintf("\u0025v", *_defagg.EndDateAttr)})
	}
	if _defagg.GroupIntervalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "groupInterval"}, Value: _bg.Sprintf("\u0025v", *_defagg.GroupIntervalAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bbgffb *Workbook) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bbgffb.CT_Workbook = *NewCT_Workbook()
	for _, _bgdfa := range start.Attr {
		if _bgdfa.Name.Local == "conformance" {
			_bbgffb.ConformanceAttr.UnmarshalXMLAttr(_bgdfa)
			continue
		}
	}
_gagcc:
	for {
		_aeeecd, _aebbd := d.Token()
		if _aebbd != nil {
			return _aebbd
		}
		switch _ccfgac := _aeeecd.(type) {
		case _f.StartElement:
			switch _ccfgac.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fileVersion"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fileVersion"}:
				_bbgffb.FileVersion = NewCT_FileVersion()
				if _egegb := d.DecodeElement(_bbgffb.FileVersion, &_ccfgac); _egegb != nil {
					return _egegb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fileSharing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fileSharing"}:
				_bbgffb.FileSharing = NewCT_FileSharing()
				if _ccffg := d.DecodeElement(_bbgffb.FileSharing, &_ccfgac); _ccffg != nil {
					return _ccffg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "workbookPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "workbookPr"}:
				_bbgffb.WorkbookPr = NewCT_WorkbookPr()
				if _ccfeb := d.DecodeElement(_bbgffb.WorkbookPr, &_ccfgac); _ccfeb != nil {
					return _ccfeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "workbookProtection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "workbookProtection"}:
				_bbgffb.WorkbookProtection = NewCT_WorkbookProtection()
				if _ebcbab := d.DecodeElement(_bbgffb.WorkbookProtection, &_ccfgac); _ebcbab != nil {
					return _ebcbab
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "bookViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "bookViews"}:
				_bbgffb.BookViews = NewCT_BookViews()
				if _ccdec := d.DecodeElement(_bbgffb.BookViews, &_ccfgac); _ccdec != nil {
					return _ccdec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheets"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheets"}:
				if _geade := d.DecodeElement(_bbgffb.Sheets, &_ccfgac); _geade != nil {
					return _geade
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "functionGroups"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "functionGroups"}:
				_bbgffb.FunctionGroups = NewCT_FunctionGroups()
				if _adbage := d.DecodeElement(_bbgffb.FunctionGroups, &_ccfgac); _adbage != nil {
					return _adbage
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "externalReferences"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "externalReferences"}:
				_bbgffb.ExternalReferences = NewCT_ExternalReferences()
				if _eacgbd := d.DecodeElement(_bbgffb.ExternalReferences, &_ccfgac); _eacgbd != nil {
					return _eacgbd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "definedNames"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "definedNames"}:
				_bbgffb.DefinedNames = NewCT_DefinedNames()
				if _ggbgag := d.DecodeElement(_bbgffb.DefinedNames, &_ccfgac); _ggbgag != nil {
					return _ggbgag
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "calcPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "calcPr"}:
				_bbgffb.CalcPr = NewCT_CalcPr()
				if _bbfgg := d.DecodeElement(_bbgffb.CalcPr, &_ccfgac); _bbfgg != nil {
					return _bbfgg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleSize"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleSize"}:
				_bbgffb.OleSize = NewCT_OleSize()
				if _cfffag := d.DecodeElement(_bbgffb.OleSize, &_ccfgac); _cfffag != nil {
					return _cfffag
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customWorkbookViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customWorkbookViews"}:
				_bbgffb.CustomWorkbookViews = NewCT_CustomWorkbookViews()
				if _dgdcb := d.DecodeElement(_bbgffb.CustomWorkbookViews, &_ccfgac); _dgdcb != nil {
					return _dgdcb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotCaches"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotCaches"}:
				_bbgffb.PivotCaches = NewCT_PivotCaches()
				if _acdgc := d.DecodeElement(_bbgffb.PivotCaches, &_ccfgac); _acdgc != nil {
					return _acdgc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "smartTagPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "smartTagPr"}:
				_bbgffb.SmartTagPr = NewCT_SmartTagPr()
				if _fgggde := d.DecodeElement(_bbgffb.SmartTagPr, &_ccfgac); _fgggde != nil {
					return _fgggde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "smartTagTypes"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "smartTagTypes"}:
				_bbgffb.SmartTagTypes = NewCT_SmartTagTypes()
				if _cdgaf := d.DecodeElement(_bbgffb.SmartTagTypes, &_ccfgac); _cdgaf != nil {
					return _cdgaf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "webPublishing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "webPublishing"}:
				_bbgffb.WebPublishing = NewCT_WebPublishing()
				if _gdefa := d.DecodeElement(_bbgffb.WebPublishing, &_ccfgac); _gdefa != nil {
					return _gdefa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fileRecoveryPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fileRecoveryPr"}:
				_efcccg := NewCT_FileRecoveryPr()
				if _deacdd := d.DecodeElement(_efcccg, &_ccfgac); _deacdd != nil {
					return _deacdd
				}
				_bbgffb.FileRecoveryPr = append(_bbgffb.FileRecoveryPr, _efcccg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "webPublishObjects"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "webPublishObjects"}:
				_bbgffb.WebPublishObjects = NewCT_WebPublishObjects()
				if _debfc := d.DecodeElement(_bbgffb.WebPublishObjects, &_ccfgac); _debfc != nil {
					return _debfc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bbgffb.ExtLst = NewCT_ExtensionList()
				if _efabc := d.DecodeElement(_bbgffb.ExtLst, &_ccfgac); _efabc != nil {
					return _efabc
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Workbook\u0020\u0025v", _ccfgac.Name)
				if _cgceb := d.Skip(); _cgceb != nil {
					return _cgceb
				}
			}
		case _f.EndElement:
			break _gagcc
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_MergeCells and its children
func (_dccfc *CT_MergeCells) Validate() error { return _dccfc.ValidateWithPath("CT_MergeCells") }
func (_gbbde *CT_PivotArea) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aecgf := range start.Attr {
		if _aecgf.Name.Local == "outline" {
			_egbaf, _acbbb := _g.ParseBool(_aecgf.Value)
			if _acbbb != nil {
				return _acbbb
			}
			_gbbde.OutlineAttr = &_egbaf
			continue
		}
		if _aecgf.Name.Local == "field" {
			_ebdcb, _ddged := _g.ParseInt(_aecgf.Value, 10, 32)
			if _ddged != nil {
				return _ddged
			}
			_cggggd := int32(_ebdcb)
			_gbbde.FieldAttr = &_cggggd
			continue
		}
		if _aecgf.Name.Local == "dataOnly" {
			_fbacaa, _bdaae := _g.ParseBool(_aecgf.Value)
			if _bdaae != nil {
				return _bdaae
			}
			_gbbde.DataOnlyAttr = &_fbacaa
			continue
		}
		if _aecgf.Name.Local == "labelOnly" {
			_ebgfd, _ebgcf := _g.ParseBool(_aecgf.Value)
			if _ebgcf != nil {
				return _ebgcf
			}
			_gbbde.LabelOnlyAttr = &_ebgfd
			continue
		}
		if _aecgf.Name.Local == "grandRow" {
			_cbgdb, _cffab := _g.ParseBool(_aecgf.Value)
			if _cffab != nil {
				return _cffab
			}
			_gbbde.GrandRowAttr = &_cbgdb
			continue
		}
		if _aecgf.Name.Local == "grandCol" {
			_aged, _daaf := _g.ParseBool(_aecgf.Value)
			if _daaf != nil {
				return _daaf
			}
			_gbbde.GrandColAttr = &_aged
			continue
		}
		if _aecgf.Name.Local == "cacheIndex" {
			_ebcfa, _caddd := _g.ParseBool(_aecgf.Value)
			if _caddd != nil {
				return _caddd
			}
			_gbbde.CacheIndexAttr = &_ebcfa
			continue
		}
		if _aecgf.Name.Local == "type" {
			_gbbde.TypeAttr.UnmarshalXMLAttr(_aecgf)
			continue
		}
		if _aecgf.Name.Local == "offset" {
			_bggcab, _effaee := _aecgf.Value, error(nil)
			if _effaee != nil {
				return _effaee
			}
			_gbbde.OffsetAttr = &_bggcab
			continue
		}
		if _aecgf.Name.Local == "collapsedLevelsAreSubtotals" {
			_ebgcfd, _fdefb := _g.ParseBool(_aecgf.Value)
			if _fdefb != nil {
				return _fdefb
			}
			_gbbde.CollapsedLevelsAreSubtotalsAttr = &_ebgcfd
			continue
		}
		if _aecgf.Name.Local == "axis" {
			_gbbde.AxisAttr.UnmarshalXMLAttr(_aecgf)
			continue
		}
		if _aecgf.Name.Local == "fieldPosition" {
			_fabfed, _gffc := _g.ParseUint(_aecgf.Value, 10, 32)
			if _gffc != nil {
				return _gffc
			}
			_ffaeg := uint32(_fabfed)
			_gbbde.FieldPositionAttr = &_ffaeg
			continue
		}
	}
_dabc:
	for {
		_ccgeb, _cddbc := d.Token()
		if _cddbc != nil {
			return _cddbc
		}
		switch _cbae := _ccgeb.(type) {
		case _f.StartElement:
			switch _cbae.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "references"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "references"}:
				_gbbde.References = NewCT_PivotAreaReferences()
				if _bfgcd := d.DecodeElement(_gbbde.References, &_cbae); _bfgcd != nil {
					return _bfgcd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gbbde.ExtLst = NewCT_ExtensionList()
				if _fdebf := d.DecodeElement(_gbbde.ExtLst, &_cbae); _fdebf != nil {
					return _fdebf
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PivotArea\u0020\u0025v", _cbae.Name)
				if _eddebc := d.Skip(); _eddebc != nil {
					return _eddebc
				}
			}
		case _f.EndElement:
			break _dabc
		case _f.CharData:
		}
	}
	return nil
}
func (_ccbad *CT_ReviewedRevisions) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gfdaa := range start.Attr {
		if _gfdaa.Name.Local == "count" {
			_dccfg, _gfeffab := _g.ParseUint(_gfdaa.Value, 10, 32)
			if _gfeffab != nil {
				return _gfeffab
			}
			_ggcgc := uint32(_dccfg)
			_ccbad.CountAttr = &_ggcgc
			continue
		}
	}
_ffcag:
	for {
		_dbdbde, _bfacd := d.Token()
		if _bfacd != nil {
			return _bfacd
		}
		switch _beceg := _dbdbde.(type) {
		case _f.StartElement:
			switch _beceg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "reviewed"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "reviewed"}:
				_dabag := NewCT_Reviewed()
				if _bcbgd := d.DecodeElement(_dabag, &_beceg); _bcbgd != nil {
					return _bcbgd
				}
				_ccbad.Reviewed = append(_ccbad.Reviewed, _dabag)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on\u0020CT_ReviewedRevisions\u0020\u0025v", _beceg.Name)
				if _dfcee := d.Skip(); _dfcee != nil {
					return _dfcee
				}
			}
		case _f.EndElement:
			break _ffcag
		case _f.CharData:
		}
	}
	return nil
}
func (_cbecf *Connections) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cbecf.CT_Connections = *NewCT_Connections()
_abaced:
	for {
		_gdeed, _ebdag := d.Token()
		if _ebdag != nil {
			return _ebdag
		}
		switch _ccbgae := _gdeed.(type) {
		case _f.StartElement:
			switch _ccbgae.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "connection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "connection"}:
				_aface := NewCT_Connection()
				if _dggadg := d.DecodeElement(_aface, &_ccbgae); _dggadg != nil {
					return _dggadg
				}
				_cbecf.Connection = append(_cbecf.Connection, _aface)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Connections\u0020\u0025v", _ccbgae.Name)
				if _ccgada := d.Skip(); _ccgada != nil {
					return _ccgada
				}
			}
		case _f.EndElement:
			break _abaced
		case _f.CharData:
		}
	}
	return nil
}
func (_afebcb *ST_PivotAreaType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_afebcb = 0
	case "none":
		*_afebcb = 1
	case "normal":
		*_afebcb = 2
	case "data":
		*_afebcb = 3
	case "all":
		*_afebcb = 4
	case "origin":
		*_afebcb = 5
	case "button":
		*_afebcb = 6
	case "topEnd":
		*_afebcb = 7
	case "topRight":
		*_afebcb = 8
	}
	return nil
}

// ValidateWithPath validates the CT_OutlinePr and its children, prefixing error messages with path
func (_daeea *CT_OutlinePr) ValidateWithPath(path string) error { return nil }

type CT_Table struct {

	// Table Id
	IdAttr uint32

	// Name
	NameAttr *string

	// Table Name
	DisplayNameAttr string

	// Table Comment
	CommentAttr *string

	// Reference
	RefAttr string

	// Table Type
	TableTypeAttr ST_TableType

	// Header Row Count
	HeaderRowCountAttr *uint32

	// Insert Row Showing
	InsertRowAttr *bool

	// Insert Row Shift
	InsertRowShiftAttr *bool

	// Totals Row Count
	TotalsRowCountAttr *uint32

	// Totals Row Shown
	TotalsRowShownAttr *bool

	// Published
	PublishedAttr *bool

	// Header Row Format Id
	HeaderRowDxfIdAttr *uint32

	// Data Area Format Id
	DataDxfIdAttr *uint32

	// Totals Row Format Id
	TotalsRowDxfIdAttr *uint32

	// Header Row Border Format Id
	HeaderRowBorderDxfIdAttr *uint32

	// Table Border Format Id
	TableBorderDxfIdAttr *uint32

	// Totals Row Border Format Id
	TotalsRowBorderDxfIdAttr *uint32

	// Header Row Style
	HeaderRowCellStyleAttr *string

	// Data Style Name
	DataCellStyleAttr *string

	// Totals Row Style
	TotalsRowCellStyleAttr *string

	// Connection ID
	ConnectionIdAttr *uint32

	// Table AutoFilter
	AutoFilter *CT_AutoFilter

	// Sort State
	SortState *CT_SortState

	// Table Columns
	TableColumns *CT_TableColumns

	// Table Style
	TableStyleInfo *CT_TableStyleInfo

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_cacag ST_FileType) String() string {
	switch _cacag {
	case 0:
		return ""
	case 1:
		return "mac"
	case 2:
		return "win"
	case 3:
		return "dos"
	case 4:
		return "lin"
	case 5:
		return "other"
	}
	return ""
}

type CT_RevisionAutoFormatting struct {

	// Sheet Id
	SheetIdAttr uint32

	// Reference
	RefAttr                     string
	AutoFormatIdAttr            *uint32
	ApplyNumberFormatsAttr      *bool
	ApplyBorderFormatsAttr      *bool
	ApplyFontFormatsAttr        *bool
	ApplyPatternFormatsAttr     *bool
	ApplyAlignmentFormatsAttr   *bool
	ApplyWidthHeightFormatsAttr *bool
}
type CT_PCDSCPage struct {

	// Page Item String Count
	CountAttr *uint32

	// Page Item
	PageItem []*CT_PageItem
}
type CT_CellSmartTag struct {

	// Smart Tag Type Index
	TypeAttr uint32

	// Deleted
	DeletedAttr *bool

	// XML Based
	XmlBasedAttr *bool

	// Smart Tag Properties
	CellSmartTagPr []*CT_CellSmartTagPr
}
type ST_PivotFilterType byte
type CT_ExternalSheetDataSet struct {

	// External Sheet Data Set
	SheetData []*CT_ExternalSheetData
}

func (_ddfacg ST_TextHAlign) String() string {
	switch _ddfacg {
	case 0:
		return ""
	case 1:
		return "left"
	case 2:
		return "center"
	case 3:
		return "right"
	case 4:
		return "justify"
	case 5:
		return "distributed"
	}
	return ""
}
func (_egdaag *CT_PivotCaches) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_fgdac := _f.StartElement{Name: _f.Name{Local: "ma:pivotCache"}}
	for _, _gaafaf := range _egdaag.PivotCache {
		e.EncodeElement(_gaafaf, _fgdac)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_efcgdb *CalcChain) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_efcgdb.CT_CalcChain = *NewCT_CalcChain()
_gfffa:
	for {
		_gccacd, _bdead := d.Token()
		if _bdead != nil {
			return _bdead
		}
		switch _bbecgf := _gccacd.(type) {
		case _f.StartElement:
			switch _bbecgf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "c"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "c"}:
				_dfcgc := NewCT_CalcCell()
				if _faebde := d.DecodeElement(_dfcgc, &_bbecgf); _faebde != nil {
					return _faebde
				}
				_efcgdb.C = append(_efcgdb.C, _dfcgc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_efcgdb.ExtLst = NewCT_ExtensionList()
				if _dbedd := d.DecodeElement(_efcgdb.ExtLst, &_bbecgf); _dbedd != nil {
					return _dbedd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CalcChain \u0025v", _bbecgf.Name)
				if _dgccf := d.Skip(); _dgccf != nil {
					return _dgccf
				}
			}
		case _f.EndElement:
			break _gfffa
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Dxfs and its children
func (_ffbda *CT_Dxfs) Validate() error { return _ffbda.ValidateWithPath("CT_Dxfs") }

// ValidateWithPath validates the CT_WebPublishItem and its children, prefixing error messages with path
func (_cfbgb *CT_WebPublishItem) ValidateWithPath(path string) error {
	if _cfbgb.SourceTypeAttr == ST_WebSourceTypeUnset {
		return _bg.Errorf("\u0025s\u002fSourceTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _agdcd := _cfbgb.SourceTypeAttr.ValidateWithPath(path + "\u002fSourceTypeAttr"); _agdcd != nil {
		return _agdcd
	}
	return nil
}
func (_gcfaa *CT_Sheet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bddfc := range start.Attr {
		if _bddfc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bddfc.Name.Local == "id" || _bddfc.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bddfc.Name.Local == "id" {
			_cbcfe, _daeaa := _bddfc.Value, error(nil)
			if _daeaa != nil {
				return _daeaa
			}
			_gcfaa.IdAttr = _cbcfe
			continue
		}
		if _bddfc.Name.Local == "name" {
			_gddfbd, _agggf := _bddfc.Value, error(nil)
			if _agggf != nil {
				return _agggf
			}
			_gcfaa.NameAttr = _gddfbd
			continue
		}
		if _bddfc.Name.Local == "sheetId" {
			_bgebe, _gffdg := _g.ParseUint(_bddfc.Value, 10, 32)
			if _gffdg != nil {
				return _gffdg
			}
			_gcfaa.SheetIdAttr = uint32(_bgebe)
			continue
		}
		if _bddfc.Name.Local == "state" {
			_gcfaa.StateAttr.UnmarshalXMLAttr(_bddfc)
			continue
		}
	}
	for {
		_eaagd, _cfdcbe := d.Token()
		if _cfdcbe != nil {
			return _bg.Errorf("parsing\u0020CT_Sheet: \u0025s", _cfdcbe)
		}
		if _ccddag, _bfgcbf := _eaagd.(_f.EndElement); _bfgcbf && _ccddag.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_CfTypeUnset             ST_CfType = 0
	ST_CfTypeExpression        ST_CfType = 1
	ST_CfTypeCellIs            ST_CfType = 2
	ST_CfTypeColorScale        ST_CfType = 3
	ST_CfTypeDataBar           ST_CfType = 4
	ST_CfTypeIconSet           ST_CfType = 5
	ST_CfTypeTop10             ST_CfType = 6
	ST_CfTypeUniqueValues      ST_CfType = 7
	ST_CfTypeDuplicateValues   ST_CfType = 8
	ST_CfTypeContainsText      ST_CfType = 9
	ST_CfTypeNotContainsText   ST_CfType = 10
	ST_CfTypeBeginsWith        ST_CfType = 11
	ST_CfTypeEndsWith          ST_CfType = 12
	ST_CfTypeContainsBlanks    ST_CfType = 13
	ST_CfTypeNotContainsBlanks ST_CfType = 14
	ST_CfTypeContainsErrors    ST_CfType = 15
	ST_CfTypeNotContainsErrors ST_CfType = 16
	ST_CfTypeTimePeriod        ST_CfType = 17
	ST_CfTypeAboveAverage      ST_CfType = 18
)

func NewCT_RevisionCellChange() *CT_RevisionCellChange {
	_cbdfb := &CT_RevisionCellChange{}
	_cbdfb.Nc = NewCT_Cell()
	return _cbdfb
}

// Validate validates the PivotCacheDefinition and its children
func (_gfaabf *PivotCacheDefinition) Validate() error {
	return _gfaabf.ValidateWithPath("PivotCacheDefinition")
}
func (_cagdc ST_SheetViewType) String() string {
	switch _cagdc {
	case 0:
		return ""
	case 1:
		return "normal"
	case 2:
		return "pageBreakPreview"
	case 3:
		return "pageLayout"
	}
	return ""
}

type CT_DateGroupItem struct {

	// Year
	YearAttr uint16

	// Month
	MonthAttr *uint16

	// Day
	DayAttr *uint16

	// Hour
	HourAttr *uint16

	// Minute
	MinuteAttr *uint16

	// Second
	SecondAttr *uint16

	// Date Time Grouping
	DateTimeGroupingAttr ST_DateTimeGrouping
}

// ValidateWithPath validates the CT_FontName and its children, prefixing error messages with path
func (_bddbe *CT_FontName) ValidateWithPath(path string) error { return nil }
func (_gedea *CT_RevisionMove) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetId"}, Value: _bg.Sprintf("\u0025v", _gedea.SheetIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "source"}, Value: _bg.Sprintf("\u0025v", _gedea.SourceAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "destination"}, Value: _bg.Sprintf("\u0025v", _gedea.DestinationAttr)})
	if _gedea.SourceSheetIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sourceSheetId"}, Value: _bg.Sprintf("\u0025v", *_gedea.SourceSheetIdAttr)})
	}
	if _gedea.RIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rId"}, Value: _bg.Sprintf("\u0025v", *_gedea.RIdAttr)})
	}
	if _gedea.UaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ua"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gedea.UaAttr))})
	}
	if _gedea.RaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ra"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gedea.RaAttr))})
	}
	e.EncodeToken(start)
	if _gedea.Undo != nil {
		_dcaeb := _f.StartElement{Name: _f.Name{Local: "ma:undo"}}
		for _, _bgfbe := range _gedea.Undo {
			e.EncodeElement(_bgfbe, _dcaeb)
		}
	}
	if _gedea.Rcc != nil {
		_cfbga := _f.StartElement{Name: _f.Name{Local: "ma:rcc"}}
		for _, _fdadg := range _gedea.Rcc {
			e.EncodeElement(_fdadg, _cfbga)
		}
	}
	if _gedea.Rfmt != nil {
		_aeeec := _f.StartElement{Name: _f.Name{Local: "ma:rfmt"}}
		for _, _daeab := range _gedea.Rfmt {
			e.EncodeElement(_daeab, _aeeec)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_CacheField struct {

	// PivotCache Field Name
	NameAttr string

	// PivotCache Field Caption
	CaptionAttr *string

	// Property Name
	PropertyNameAttr *string

	// Server-based Field
	ServerFieldAttr *bool

	// Unique List Retrieved
	UniqueListAttr *bool

	// Number Format Id
	NumFmtIdAttr *uint32

	// Calculated Field Formula
	FormulaAttr *string

	// SQL Data Type
	SqlTypeAttr *int32

	// Hierarchy
	HierarchyAttr *int32

	// Hierarchy Level
	LevelAttr *uint32

	// Database Field
	DatabaseFieldAttr *bool

	// Member Property Count
	MappingCountAttr *uint32

	// Member Property Field
	MemberPropertyFieldAttr *bool

	// Shared Items
	SharedItems *CT_SharedItems

	// Field Group Properties
	FieldGroup *CT_FieldGroup

	// Member Properties Map
	MpMap []*CT_X

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_ffgcg *CT_PhoneticRun) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aacee := range start.Attr {
		if _aacee.Name.Local == "sb" {
			_bbbge, _fbgga := _g.ParseUint(_aacee.Value, 10, 32)
			if _fbgga != nil {
				return _fbgga
			}
			_ffgcg.SbAttr = uint32(_bbbge)
			continue
		}
		if _aacee.Name.Local == "eb" {
			_ddedc, _cbafbd := _g.ParseUint(_aacee.Value, 10, 32)
			if _cbafbd != nil {
				return _cbafbd
			}
			_ffgcg.EbAttr = uint32(_ddedc)
			continue
		}
	}
_fafec:
	for {
		_cdbca, _badfaf := d.Token()
		if _badfaf != nil {
			return _badfaf
		}
		switch _efdge := _cdbca.(type) {
		case _f.StartElement:
			switch _efdge.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "t"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "t"}:
				if _dcafa := d.DecodeElement(&_ffgcg.T, &_efdge); _dcafa != nil {
					return _dcafa
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PhoneticRun\u0020\u0025v", _efdge.Name)
				if _facfe := d.Skip(); _facfe != nil {
					return _facfe
				}
			}
		case _f.EndElement:
			break _fafec
		case _f.CharData:
		}
	}
	return nil
}
func (_cfceb ST_SortType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_affac := _f.Attr{}
	_affac.Name = name
	switch _cfceb {
	case ST_SortTypeUnset:
		_affac.Value = ""
	case ST_SortTypeNone:
		_affac.Value = "none"
	case ST_SortTypeAscending:
		_affac.Value = "ascending"
	case ST_SortTypeDescending:
		_affac.Value = "descending"
	case ST_SortTypeAscendingAlpha:
		_affac.Value = "ascendingAlpha"
	case ST_SortTypeDescendingAlpha:
		_affac.Value = "descendingAlpha"
	case ST_SortTypeAscendingNatural:
		_affac.Value = "ascendingNatural"
	case ST_SortTypeDescendingNatural:
		_affac.Value = "descendingNatural"
	}
	return _affac, nil
}
func (_gcc *CT_CellSmartTagPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "key"}, Value: _bg.Sprintf("\u0025v", _gcc.KeyAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", _gcc.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_CustomChartsheetView struct {

	// GUID
	GuidAttr string

	// Print Scale
	ScaleAttr *uint32

	// Visible State
	StateAttr ST_SheetState

	// Zoom To Fit
	ZoomToFitAttr *bool
	PageMargins   *CT_PageMargins

	// Chart Sheet Page Setup
	PageSetup    *CT_CsPageSetup
	HeaderFooter *CT_HeaderFooter
}

func (_edbee *CT_UndoInfo) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_edbee.ExpAttr = ST_FormulaExpression(1)
	for _, _caaefe := range start.Attr {
		if _caaefe.Name.Local == "index" {
			_gcgfd, _daggc := _g.ParseUint(_caaefe.Value, 10, 32)
			if _daggc != nil {
				return _daggc
			}
			_edbee.IndexAttr = uint32(_gcgfd)
			continue
		}
		if _caaefe.Name.Local == "exp" {
			_edbee.ExpAttr.UnmarshalXMLAttr(_caaefe)
			continue
		}
		if _caaefe.Name.Local == "ref3D" {
			_eadbd, _cdabbg := _g.ParseBool(_caaefe.Value)
			if _cdabbg != nil {
				return _cdabbg
			}
			_edbee.Ref3DAttr = &_eadbd
			continue
		}
		if _caaefe.Name.Local == "array" {
			_cdgde, _ccaad := _g.ParseBool(_caaefe.Value)
			if _ccaad != nil {
				return _ccaad
			}
			_edbee.ArrayAttr = &_cdgde
			continue
		}
		if _caaefe.Name.Local == "v" {
			_gbcad, _bagba := _g.ParseBool(_caaefe.Value)
			if _bagba != nil {
				return _bagba
			}
			_edbee.VAttr = &_gbcad
			continue
		}
		if _caaefe.Name.Local == "nf" {
			_dcbagb, _cfeeg := _g.ParseBool(_caaefe.Value)
			if _cfeeg != nil {
				return _cfeeg
			}
			_edbee.NfAttr = &_dcbagb
			continue
		}
		if _caaefe.Name.Local == "cs" {
			_faged, _dbbbc := _g.ParseBool(_caaefe.Value)
			if _dbbbc != nil {
				return _dbbbc
			}
			_edbee.CsAttr = &_faged
			continue
		}
		if _caaefe.Name.Local == "dr" {
			_bbgdd, _gabaa := _caaefe.Value, error(nil)
			if _gabaa != nil {
				return _gabaa
			}
			_edbee.DrAttr = _bbgdd
			continue
		}
		if _caaefe.Name.Local == "dn" {
			_abbee, _aegeb := _caaefe.Value, error(nil)
			if _aegeb != nil {
				return _aegeb
			}
			_edbee.DnAttr = &_abbee
			continue
		}
		if _caaefe.Name.Local == "r" {
			_gabdf, _bedga := _caaefe.Value, error(nil)
			if _bedga != nil {
				return _bedga
			}
			_edbee.RAttr = &_gabdf
			continue
		}
		if _caaefe.Name.Local == "sId" {
			_afbgc, _bdbgf := _g.ParseUint(_caaefe.Value, 10, 32)
			if _bdbgf != nil {
				return _bdbgf
			}
			_adfade := uint32(_afbgc)
			_edbee.SIdAttr = &_adfade
			continue
		}
	}
	for {
		_ecbca, _acbgga := d.Token()
		if _acbgga != nil {
			return _bg.Errorf("parsing\u0020CT_UndoInfo:\u0020\u0025s", _acbgga)
		}
		if _fcefab, _cbcdec := _ecbca.(_f.EndElement); _cbcdec && _fcefab.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Tuple() *CT_Tuple { _deceg := &CT_Tuple{}; return _deceg }
func (_eagd *CT_OleObject) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ebadc := range start.Attr {
		if _ebadc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _ebadc.Name.Local == "id" || _ebadc.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _ebadc.Name.Local == "id" {
			_fdddb, _beada := _ebadc.Value, error(nil)
			if _beada != nil {
				return _beada
			}
			_eagd.IdAttr = &_fdddb
			continue
		}
		if _ebadc.Name.Local == "dvAspect" {
			_eagd.DvAspectAttr.UnmarshalXMLAttr(_ebadc)
			continue
		}
		if _ebadc.Name.Local == "link" {
			_adgda, _feaf := _ebadc.Value, error(nil)
			if _feaf != nil {
				return _feaf
			}
			_eagd.LinkAttr = &_adgda
			continue
		}
		if _ebadc.Name.Local == "oleUpdate" {
			_eagd.OleUpdateAttr.UnmarshalXMLAttr(_ebadc)
			continue
		}
		if _ebadc.Name.Local == "autoLoad" {
			_dbdge, _cdead := _g.ParseBool(_ebadc.Value)
			if _cdead != nil {
				return _cdead
			}
			_eagd.AutoLoadAttr = &_dbdge
			continue
		}
		if _ebadc.Name.Local == "shapeId" {
			_fgaed, _cccd := _g.ParseUint(_ebadc.Value, 10, 32)
			if _cccd != nil {
				return _cccd
			}
			_eagd.ShapeIdAttr = uint32(_fgaed)
			continue
		}
		if _ebadc.Name.Local == "progId" {
			_efffe, _fcec := _ebadc.Value, error(nil)
			if _fcec != nil {
				return _fcec
			}
			_eagd.ProgIdAttr = &_efffe
			continue
		}
	}
_bbegc:
	for {
		_dbdgb, _fdeed := d.Token()
		if _fdeed != nil {
			return _fdeed
		}
		switch _ebeag := _dbdgb.(type) {
		case _f.StartElement:
			switch _ebeag.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "objectPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "objectPr"}:
				_eagd.ObjectPr = NewCT_ObjectPr()
				if _bbbfb := d.DecodeElement(_eagd.ObjectPr, &_ebeag); _bbbfb != nil {
					return _bbbfb
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OleObject\u0020\u0025v", _ebeag.Name)
				if _gega := d.Skip(); _gega != nil {
					return _gega
				}
			}
		case _f.EndElement:
			break _bbegc
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Location and its children, prefixing error messages with path
func (_ggefc *CT_Location) ValidateWithPath(path string) error { return nil }
func (_fdgcc *CT_CellStyles) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fdgcc.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_fdgcc.CountAttr)})
	}
	e.EncodeToken(start)
	_gaef := _f.StartElement{Name: _f.Name{Local: "ma:cellStyle"}}
	for _, _cffb := range _fdgcc.CellStyle {
		e.EncodeElement(_cffb, _gaef)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cegfa *CT_DefinedNames) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_cefdd:
	for {
		_bdbcf, _gddec := d.Token()
		if _gddec != nil {
			return _gddec
		}
		switch _cdad := _bdbcf.(type) {
		case _f.StartElement:
			switch _cdad.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "definedName"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "definedName"}:
				_dcfdb := NewCT_DefinedName()
				if _dacf := d.DecodeElement(_dcfdb, &_cdad); _dacf != nil {
					return _dacf
				}
				_cegfa.DefinedName = append(_cegfa.DefinedName, _dcfdb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DefinedNames\u0020\u0025v", _cdad.Name)
				if _cbfca := d.Skip(); _cbfca != nil {
					return _cbfca
				}
			}
		case _f.EndElement:
			break _cefdd
		case _f.CharData:
		}
	}
	return nil
}

type CT_GroupItems struct {

	// Items Created Count
	CountAttr *uint32

	// No Value
	M []*CT_Missing

	// Numeric Value
	N []*CT_Number

	// Boolean
	B []*CT_Boolean

	// Error Value
	E []*CT_Error

	// Character Value
	S []*CT_String

	// Date Time
	D []*CT_DateTime
}
type ST_FilterOperator byte

// Validate validates the CT_Authors and its children
func (_ec *CT_Authors) Validate() error { return _ec.ValidateWithPath("CT_Authors") }
func (_eabad *ST_IconSetType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_eabad = 0
	case "3Arrows":
		*_eabad = 1
	case "3ArrowsGray":
		*_eabad = 2
	case "3Flags":
		*_eabad = 3
	case "3TrafficLights1":
		*_eabad = 4
	case "3TrafficLights2":
		*_eabad = 5
	case "3Signs":
		*_eabad = 6
	case "3Symbols":
		*_eabad = 7
	case "3Symbols2":
		*_eabad = 8
	case "4Arrows":
		*_eabad = 9
	case "4ArrowsGray":
		*_eabad = 10
	case "4RedToBlack":
		*_eabad = 11
	case "4Rating":
		*_eabad = 12
	case "4TrafficLights":
		*_eabad = 13
	case "5Arrows":
		*_eabad = 14
	case "5ArrowsGray":
		*_eabad = 15
	case "5Rating":
		*_eabad = 16
	case "5Quarters":
		*_eabad = 17
	}
	return nil
}

// ValidateWithPath validates the CT_SmartTagTypes and its children, prefixing error messages with path
func (_cacfd *CT_SmartTagTypes) ValidateWithPath(path string) error {
	for _gccec, _agcfbf := range _cacfd.SmartTagType {
		if _effea := _agcfbf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fSmartTagType\u005b\u0025d\u005d", path, _gccec)); _effea != nil {
			return _effea
		}
	}
	return nil
}
func (_abde *CT_DataRefs) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dffdc := range start.Attr {
		if _dffdc.Name.Local == "count" {
			_gbecd, _gcde := _g.ParseUint(_dffdc.Value, 10, 32)
			if _gcde != nil {
				return _gcde
			}
			_fbad := uint32(_gbecd)
			_abde.CountAttr = &_fbad
			continue
		}
	}
_cbgdf:
	for {
		_fgde, _bgfb := d.Token()
		if _bgfb != nil {
			return _bgfb
		}
		switch _cecbc := _fgde.(type) {
		case _f.StartElement:
			switch _cecbc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataRef"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataRef"}:
				_ebdaa := NewCT_DataRef()
				if _baeag := d.DecodeElement(_ebdaa, &_cecbc); _baeag != nil {
					return _baeag
				}
				_abde.DataRef = append(_abde.DataRef, _ebdaa)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DataRefs\u0020\u0025v", _cecbc.Name)
				if _dcddd := d.Skip(); _dcddd != nil {
					return _dcddd
				}
			}
		case _f.EndElement:
			break _cbgdf
		case _f.CharData:
		}
	}
	return nil
}
func (_ebad *CT_CellWatch) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", _ebad.RAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewWorksheet() *Worksheet {
	_fedeg := &Worksheet{}
	_fedeg.CT_Worksheet = *NewCT_Worksheet()
	return _fedeg
}

// ValidateWithPath validates the CT_CellSmartTag and its children, prefixing error messages with path
func (_aaed *CT_CellSmartTag) ValidateWithPath(path string) error {
	for _dcdgf, _fbdd := range _aaed.CellSmartTagPr {
		if _dafb := _fbdd.ValidateWithPath(_bg.Sprintf("%s\u002fCellSmartTagPr\u005b\u0025d\u005d", path, _dcdgf)); _dafb != nil {
			return _dafb
		}
	}
	return nil
}
func (_cebcg *CT_DeletedField) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ecdgd := range start.Attr {
		if _ecdgd.Name.Local == "name" {
			_dadbg, _cdeda := _ecdgd.Value, error(nil)
			if _cdeda != nil {
				return _cdeda
			}
			_cebcg.NameAttr = _dadbg
			continue
		}
	}
	for {
		_dbcf, _gggca := d.Token()
		if _gggca != nil {
			return _bg.Errorf("parsing CT_DeletedField:\u0020\u0025s", _gggca)
		}
		if _cdaca, _cdec := _dbcf.(_f.EndElement); _cdec && _cdaca.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cccac *CT_MeasureDimensionMaps) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _eceeed := range start.Attr {
		if _eceeed.Name.Local == "count" {
			_eccbg, _dfee := _g.ParseUint(_eceeed.Value, 10, 32)
			if _dfee != nil {
				return _dfee
			}
			_fadge := uint32(_eccbg)
			_cccac.CountAttr = &_fadge
			continue
		}
	}
_dagae:
	for {
		_dggd, _dfdea := d.Token()
		if _dfdea != nil {
			return _dfdea
		}
		switch _abeb := _dggd.(type) {
		case _f.StartElement:
			switch _abeb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "map"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "map"}:
				_ggcd := NewCT_MeasureDimensionMap()
				if _ebedg := d.DecodeElement(_ggcd, &_abeb); _ebedg != nil {
					return _ebedg
				}
				_cccac.Map = append(_cccac.Map, _ggcd)
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_MeasureDimensionMaps \u0025v", _abeb.Name)
				if _ggfcf := d.Skip(); _ggfcf != nil {
					return _ggfcf
				}
			}
		case _f.EndElement:
			break _dagae
		case _f.CharData:
		}
	}
	return nil
}

type CT_PivotCacheDefinition struct {
	IdAttr *string

	// Invalid Cache
	InvalidAttr *bool

	// Save Pivot Records
	SaveDataAttr *bool

	// Refresh On Load
	RefreshOnLoadAttr *bool

	// Optimize Cache for Memory
	OptimizeMemoryAttr *bool

	// Enable PivotCache Refresh
	EnableRefreshAttr *bool

	// Last Refreshed By
	RefreshedByAttr *string

	// PivotCache Last Refreshed Date
	RefreshedDateAttr *float64

	// PivotCache Last Refreshed Date ISO
	RefreshedDateIsoAttr *_b.Time

	// Background Query
	BackgroundQueryAttr *bool

	// Missing Items Limit
	MissingItemsLimitAttr *uint32

	// PivotCache Created Version
	CreatedVersionAttr *uint8

	// PivotCache Last Refreshed Version
	RefreshedVersionAttr *uint8

	// Minimum Version Required for Refresh
	MinRefreshableVersionAttr *uint8

	// PivotCache Record Count
	RecordCountAttr *uint32

	// Upgrade PivotCache on Refresh
	UpgradeOnRefreshAttr *bool

	// Tuple Cache
	TupleCacheAttr *bool

	// Supports Subqueries
	SupportSubqueryAttr *bool

	// Supports Attribute Drilldown
	SupportAdvancedDrillAttr *bool

	// PivotCache Source Description
	CacheSource *CT_CacheSource

	// PivotCache Fields
	CacheFields *CT_CacheFields

	// PivotCache Hierarchies
	CacheHierarchies *CT_CacheHierarchies

	// OLAP KPIs
	Kpis *CT_PCDKPIs

	// Tuple Cache
	TupleCache *CT_TupleCache

	// Calculated Items
	CalculatedItems *CT_CalculatedItems

	// Calculated Members
	CalculatedMembers *CT_CalculatedMembers

	// OLAP Dimensions
	Dimensions *CT_Dimensions

	// OLAP Measure Groups
	MeasureGroups *CT_MeasureGroups

	// OLAP Measure Group
	Maps *CT_MeasureDimensionMaps

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func NewCT_SmartTagTypes() *CT_SmartTagTypes { _egege := &CT_SmartTagTypes{}; return _egege }
func (_cedgda *EG_ExtensionList) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_dgcbc:
	for {
		_ddaeg, _dcaeba := d.Token()
		if _dcaeba != nil {
			return _dcaeba
		}
		switch _gggeca := _ddaeg.(type) {
		case _f.StartElement:
			switch _gggeca.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ext"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ext"}:
				_cfgef := NewCT_Extension()
				if _eegeg := d.DecodeElement(_cfgef, &_gggeca); _eegeg != nil {
					return _eegeg
				}
				_cedgda.Ext = append(_cedgda.Ext, _cfgef)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_ExtensionList\u0020\u0025v", _gggeca.Name)
				if _fefdg := d.Skip(); _fefdg != nil {
					return _fefdg
				}
			}
		case _f.EndElement:
			break _dgcbc
		case _f.CharData:
		}
	}
	return nil
}

type AG_AutoFormat struct {
	AutoFormatIdAttr            *uint32
	ApplyNumberFormatsAttr      *bool
	ApplyBorderFormatsAttr      *bool
	ApplyFontFormatsAttr        *bool
	ApplyPatternFormatsAttr     *bool
	ApplyAlignmentFormatsAttr   *bool
	ApplyWidthHeightFormatsAttr *bool
}

func NewCT_CellStyles() *CT_CellStyles { _fgbc := &CT_CellStyles{}; return _fgbc }

// Validate validates the CT_PageField and its children
func (_aeacd *CT_PageField) Validate() error { return _aeacd.ValidateWithPath("CT_PageField") }

type Metadata struct{ CT_Metadata }

func (_daeaf *CT_Filter) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abega := range start.Attr {
		if _abega.Name.Local == "val" {
			_bedfge, _gcgcb := _abega.Value, error(nil)
			if _gcgcb != nil {
				return _gcgcb
			}
			_daeaf.ValAttr = &_bedfge
			continue
		}
	}
	for {
		_egcag, _cgacf := d.Token()
		if _cgacf != nil {
			return _bg.Errorf("parsing\u0020CT_Filter:\u0020\u0025s", _cgacf)
		}
		if _edab, _agefb := _egcag.(_f.EndElement); _agefb && _edab.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_AxisUnset      ST_Axis = 0
	ST_AxisAxisRow    ST_Axis = 1
	ST_AxisAxisCol    ST_Axis = 2
	ST_AxisAxisPage   ST_Axis = 3
	ST_AxisAxisValues ST_Axis = 4
)

type CT_CellWatch struct {

	// Reference
	RAttr string
}

func (_fdaf *CT_BorderPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ecf := range start.Attr {
		if _ecf.Name.Local == "style" {
			_fdaf.StyleAttr.UnmarshalXMLAttr(_ecf)
			continue
		}
	}
_bee:
	for {
		_cgbb, _feae := d.Token()
		if _feae != nil {
			return _feae
		}
		switch _fefe := _cgbb.(type) {
		case _f.StartElement:
			switch _fefe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "color"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "color"}:
				_fdaf.Color = NewCT_Color()
				if _acge := d.DecodeElement(_fdaf.Color, &_fefe); _acge != nil {
					return _acge
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BorderPr\u0020\u0025v", _fefe.Name)
				if _ddac := d.Skip(); _ddac != nil {
					return _ddac
				}
			}
		case _f.EndElement:
			break _bee
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_Groups() *CT_Groups { _bagag := &CT_Groups{}; return _bagag }
func (_ecabb *CT_Mdx) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ecabb.FAttr = ST_MdxFunctionType(1)
	for _, _bcec := range start.Attr {
		if _bcec.Name.Local == "n" {
			_dfcge, _dgfaed := _g.ParseUint(_bcec.Value, 10, 32)
			if _dgfaed != nil {
				return _dgfaed
			}
			_ecabb.NAttr = uint32(_dfcge)
			continue
		}
		if _bcec.Name.Local == "f" {
			_ecabb.FAttr.UnmarshalXMLAttr(_bcec)
			continue
		}
	}
_dgaag:
	for {
		_dcdfed, _aagbgb := d.Token()
		if _aagbgb != nil {
			return _aagbgb
		}
		switch _abaca := _dcdfed.(type) {
		case _f.StartElement:
			switch _abaca.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "t"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "t"}:
				_ecabb.T = NewCT_MdxTuple()
				if _fgbf := d.DecodeElement(_ecabb.T, &_abaca); _fgbf != nil {
					return _fgbf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ms"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ms"}:
				_ecabb.Ms = NewCT_MdxSet()
				if _bbfea := d.DecodeElement(_ecabb.Ms, &_abaca); _bbfea != nil {
					return _bbfea
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "p"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "p"}:
				_ecabb.P = NewCT_MdxMemeberProp()
				if _ggbb := d.DecodeElement(_ecabb.P, &_abaca); _ggbb != nil {
					return _ggbb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "k"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "k"}:
				_ecabb.K = NewCT_MdxKPI()
				if _gccda := d.DecodeElement(_ecabb.K, &_abaca); _gccda != nil {
					return _gccda
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Mdx\u0020\u0025v", _abaca.Name)
				if _cdeec := d.Skip(); _cdeec != nil {
					return _cdeec
				}
			}
		case _f.EndElement:
			break _dgaag
		case _f.CharData:
		}
	}
	return nil
}
func (_ddcgd *CT_Parameter) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aebeb := range start.Attr {
		if _aebeb.Name.Local == "name" {
			_aabfe, _eebbb := _aebeb.Value, error(nil)
			if _eebbb != nil {
				return _eebbb
			}
			_ddcgd.NameAttr = &_aabfe
			continue
		}
		if _aebeb.Name.Local == "sqlType" {
			_bbecgd, _bfffgc := _g.ParseInt(_aebeb.Value, 10, 32)
			if _bfffgc != nil {
				return _bfffgc
			}
			_eaeac := int32(_bbecgd)
			_ddcgd.SqlTypeAttr = &_eaeac
			continue
		}
		if _aebeb.Name.Local == "parameterType" {
			_ddcgd.ParameterTypeAttr.UnmarshalXMLAttr(_aebeb)
			continue
		}
		if _aebeb.Name.Local == "refreshOnChange" {
			_bagfb, _efecc := _g.ParseBool(_aebeb.Value)
			if _efecc != nil {
				return _efecc
			}
			_ddcgd.RefreshOnChangeAttr = &_bagfb
			continue
		}
		if _aebeb.Name.Local == "prompt" {
			_defce, _gagc := _aebeb.Value, error(nil)
			if _gagc != nil {
				return _gagc
			}
			_ddcgd.PromptAttr = &_defce
			continue
		}
		if _aebeb.Name.Local == "boolean" {
			_edbfg, _cfde := _g.ParseBool(_aebeb.Value)
			if _cfde != nil {
				return _cfde
			}
			_ddcgd.BooleanAttr = &_edbfg
			continue
		}
		if _aebeb.Name.Local == "double" {
			_cbega, _bagdg := _g.ParseFloat(_aebeb.Value, 64)
			if _bagdg != nil {
				return _bagdg
			}
			_ddcgd.DoubleAttr = &_cbega
			continue
		}
		if _aebeb.Name.Local == "integer" {
			_fedfe, _dbcbb := _g.ParseInt(_aebeb.Value, 10, 32)
			if _dbcbb != nil {
				return _dbcbb
			}
			_cfaa := int32(_fedfe)
			_ddcgd.IntegerAttr = &_cfaa
			continue
		}
		if _aebeb.Name.Local == "string" {
			_ebee, _dgcdg := _aebeb.Value, error(nil)
			if _dgcdg != nil {
				return _dgcdg
			}
			_ddcgd.StringAttr = &_ebee
			continue
		}
		if _aebeb.Name.Local == "cell" {
			_eaege, _dfcfg := _aebeb.Value, error(nil)
			if _dfcfg != nil {
				return _dfcfg
			}
			_ddcgd.CellAttr = &_eaege
			continue
		}
	}
	for {
		_agdgb, _edcbg := d.Token()
		if _edcbg != nil {
			return _bg.Errorf("parsing\u0020CT_Parameter:\u0020\u0025s", _edcbg)
		}
		if _gcaag, _bggdg := _agdgb.(_f.EndElement); _bggdg && _gcaag.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ExternalReferences and its children, prefixing error messages with path
func (_bffa *CT_ExternalReferences) ValidateWithPath(path string) error {
	for _bacba, _baage := range _bffa.ExternalReference {
		if _gdfag := _baage.ValidateWithPath(_bg.Sprintf("\u0025s\u002fExternalReference\u005b\u0025d\u005d", path, _bacba)); _gdfag != nil {
			return _gdfag
		}
	}
	return nil
}

type CT_FileRecoveryPr struct {

	// Auto Recover
	AutoRecoverAttr *bool

	// Crash Save
	CrashSaveAttr *bool

	// Data Extract Load
	DataExtractLoadAttr *bool

	// Repair Load
	RepairLoadAttr *bool
}

func (_bcecc ST_PrintError) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bcecc.String(), start)
}

// Validate validates the CT_ObjectAnchor and its children
func (_fgbbg *CT_ObjectAnchor) Validate() error { return _fgbbg.ValidateWithPath("CT_ObjectAnchor") }

// ValidateWithPath validates the CT_SheetPr and its children, prefixing error messages with path
func (_afefa *CT_SheetPr) ValidateWithPath(path string) error {
	if _afefa.TabColor != nil {
		if _feabf := _afefa.TabColor.ValidateWithPath(path + "\u002fTabColor"); _feabf != nil {
			return _feabf
		}
	}
	if _afefa.OutlinePr != nil {
		if _fdbaa := _afefa.OutlinePr.ValidateWithPath(path + "\u002fOutlinePr"); _fdbaa != nil {
			return _fdbaa
		}
	}
	if _afefa.PageSetUpPr != nil {
		if _ccggbd := _afefa.PageSetUpPr.ValidateWithPath(path + "\u002fPageSetUpPr"); _ccggbd != nil {
			return _ccggbd
		}
	}
	return nil
}

type CT_SheetProtection struct {

	// Legacy Password
	PasswordAttr *string

	// Cryptographic Algorithm Name
	AlgorithmNameAttr *string

	// Password Hash Value
	HashValueAttr *string

	// Salt Value for Password Verifier
	SaltValueAttr *string

	// Iterations to Run Hashing Algorithm
	SpinCountAttr *uint32

	// Sheet Locked
	SheetAttr *bool

	// Objects Locked
	ObjectsAttr *bool

	// Scenarios Locked
	ScenariosAttr *bool

	// Format Cells Locked
	FormatCellsAttr *bool

	// Format Columns Locked
	FormatColumnsAttr *bool

	// Format Rows Locked
	FormatRowsAttr *bool

	// Insert Columns Locked
	InsertColumnsAttr *bool

	// Insert Rows Locked
	InsertRowsAttr *bool

	// Insert Hyperlinks Locked
	InsertHyperlinksAttr *bool

	// Delete Columns Locked
	DeleteColumnsAttr *bool

	// Delete Rows Locked
	DeleteRowsAttr *bool

	// Select Locked Cells Locked
	SelectLockedCellsAttr *bool

	// Sort Locked
	SortAttr *bool

	// AutoFilter Locked
	AutoFilterAttr *bool

	// Pivot Tables Locked
	PivotTablesAttr *bool

	// Select Unlocked Cells Locked
	SelectUnlockedCellsAttr *bool
}

// Validate validates the CT_CustomChartsheetView and its children
func (_aeeg *CT_CustomChartsheetView) Validate() error {
	return _aeeg.ValidateWithPath("CT_CustomChartsheetView")
}

// ValidateWithPath validates the CT_Hyperlinks and its children, prefixing error messages with path
func (_egbcb *CT_Hyperlinks) ValidateWithPath(path string) error {
	for _adadd, _cfbfd := range _egbcb.Hyperlink {
		if _fddgb := _cfbfd.ValidateWithPath(_bg.Sprintf("\u0025s/Hyperlink\u005b\u0025d\u005d", path, _adadd)); _fddgb != nil {
			return _fddgb
		}
	}
	return nil
}
func (_feabb *Users) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_feabb.CT_Users = *NewCT_Users()
	for _, _ebfgga := range start.Attr {
		if _ebfgga.Name.Local == "count" {
			_cgeafea, _abfdeb := _g.ParseUint(_ebfgga.Value, 10, 32)
			if _abfdeb != nil {
				return _abfdeb
			}
			_dcfee := uint32(_cgeafea)
			_feabb.CountAttr = &_dcfee
			continue
		}
	}
_ecegc:
	for {
		_ebfgda, _cfadga := d.Token()
		if _cfadga != nil {
			return _cfadga
		}
		switch _bdfeb := _ebfgda.(type) {
		case _f.StartElement:
			switch _bdfeb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "userInfo"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "userInfo"}:
				_abgbb := NewCT_SharedUser()
				if _cbffebf := d.DecodeElement(_abgbb, &_bdfeb); _cbffebf != nil {
					return _cbffebf
				}
				_feabb.UserInfo = append(_feabb.UserInfo, _abgbb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on Users \u0025v", _bdfeb.Name)
				if _fagead := d.Skip(); _fagead != nil {
					return _fagead
				}
			}
		case _f.EndElement:
			break _ecegc
		case _f.CharData:
		}
	}
	return nil
}
func (_bcdc *CT_CfRule) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ffab := range start.Attr {
		if _ffab.Name.Local == "timePeriod" {
			_bcdc.TimePeriodAttr.UnmarshalXMLAttr(_ffab)
			continue
		}
		if _ffab.Name.Local == "type" {
			_bcdc.TypeAttr.UnmarshalXMLAttr(_ffab)
			continue
		}
		if _ffab.Name.Local == "rank" {
			_ecae, _bgbfc := _g.ParseUint(_ffab.Value, 10, 32)
			if _bgbfc != nil {
				return _bgbfc
			}
			_edf := uint32(_ecae)
			_bcdc.RankAttr = &_edf
			continue
		}
		if _ffab.Name.Local == "priority" {
			_abaf, _gddf := _g.ParseInt(_ffab.Value, 10, 32)
			if _gddf != nil {
				return _gddf
			}
			_bcdc.PriorityAttr = int32(_abaf)
			continue
		}
		if _ffab.Name.Local == "stdDev" {
			_gbgg, _ddad := _g.ParseInt(_ffab.Value, 10, 32)
			if _ddad != nil {
				return _ddad
			}
			_geea := int32(_gbgg)
			_bcdc.StdDevAttr = &_geea
			continue
		}
		if _ffab.Name.Local == "aboveAverage" {
			_bedd, _acef := _g.ParseBool(_ffab.Value)
			if _acef != nil {
				return _acef
			}
			_bcdc.AboveAverageAttr = &_bedd
			continue
		}
		if _ffab.Name.Local == "bottom" {
			_fdcg, _bdg := _g.ParseBool(_ffab.Value)
			if _bdg != nil {
				return _bdg
			}
			_bcdc.BottomAttr = &_fdcg
			continue
		}
		if _ffab.Name.Local == "operator" {
			_bcdc.OperatorAttr.UnmarshalXMLAttr(_ffab)
			continue
		}
		if _ffab.Name.Local == "text" {
			_dfdbd, _afce := _ffab.Value, error(nil)
			if _afce != nil {
				return _afce
			}
			_bcdc.TextAttr = &_dfdbd
			continue
		}
		if _ffab.Name.Local == "dxfId" {
			_bacb, _acgef := _g.ParseUint(_ffab.Value, 10, 32)
			if _acgef != nil {
				return _acgef
			}
			_fbbc := uint32(_bacb)
			_bcdc.DxfIdAttr = &_fbbc
			continue
		}
		if _ffab.Name.Local == "stopIfTrue" {
			_cdac, _dade := _g.ParseBool(_ffab.Value)
			if _dade != nil {
				return _dade
			}
			_bcdc.StopIfTrueAttr = &_cdac
			continue
		}
		if _ffab.Name.Local == "percent" {
			_ebbge, _cbfg := _g.ParseBool(_ffab.Value)
			if _cbfg != nil {
				return _cbfg
			}
			_bcdc.PercentAttr = &_ebbge
			continue
		}
		if _ffab.Name.Local == "equalAverage" {
			_edee, _aefaf := _g.ParseBool(_ffab.Value)
			if _aefaf != nil {
				return _aefaf
			}
			_bcdc.EqualAverageAttr = &_edee
			continue
		}
	}
_dgee:
	for {
		_fedf, _adgc := d.Token()
		if _adgc != nil {
			return _adgc
		}
		switch _efab := _fedf.(type) {
		case _f.StartElement:
			switch _efab.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "formula"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "formula"}:
				var _accb string
				if _ffeb := d.DecodeElement(&_accb, &_efab); _ffeb != nil {
					return _ffeb
				}
				_bcdc.Formula = append(_bcdc.Formula, _accb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colorScale"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colorScale"}:
				_bcdc.ColorScale = NewCT_ColorScale()
				if _deea := d.DecodeElement(_bcdc.ColorScale, &_efab); _deea != nil {
					return _deea
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataBar"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataBar"}:
				_bcdc.DataBar = NewCT_DataBar()
				if _ecgb := d.DecodeElement(_bcdc.DataBar, &_efab); _ecgb != nil {
					return _ecgb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "iconSet"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "iconSet"}:
				_bcdc.IconSet = NewCT_IconSet()
				if _aafa := d.DecodeElement(_bcdc.IconSet, &_efab); _aafa != nil {
					return _aafa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bcdc.ExtLst = NewCT_ExtensionList()
				if _ggceg := d.DecodeElement(_bcdc.ExtLst, &_efab); _ggceg != nil {
					return _ggceg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_CfRule \u0025v", _efab.Name)
				if _becc := d.Skip(); _becc != nil {
					return _becc
				}
			}
		case _f.EndElement:
			break _dgee
		case _f.CharData:
		}
	}
	return nil
}

type CT_SheetId struct {

	// Sheet Id
	ValAttr uint32
}

func (_eggad *CT_PCDKPIs) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gbfad := range start.Attr {
		if _gbfad.Name.Local == "count" {
			_ccdede, _edafc := _g.ParseUint(_gbfad.Value, 10, 32)
			if _edafc != nil {
				return _edafc
			}
			_edaad := uint32(_ccdede)
			_eggad.CountAttr = &_edaad
			continue
		}
	}
_aggga:
	for {
		_cefde, _bggggb := d.Token()
		if _bggggb != nil {
			return _bggggb
		}
		switch _efddd := _cefde.(type) {
		case _f.StartElement:
			switch _efddd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "kpi"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "kpi"}:
				_eedgc := NewCT_PCDKPI()
				if _ffdcdc := d.DecodeElement(_eedgc, &_efddd); _ffdcdc != nil {
					return _ffdcdc
				}
				_eggad.Kpi = append(_eggad.Kpi, _eedgc)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_PCDKPIs\u0020\u0025v", _efddd.Name)
				if _ffegf := d.Skip(); _ffegf != nil {
					return _ffegf
				}
			}
		case _f.EndElement:
			break _aggga
		case _f.CharData:
		}
	}
	return nil
}
func (_cfgfa *CT_MdxMemeberProp) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ecfcd := range start.Attr {
		if _ecfcd.Name.Local == "n" {
			_ceeda, _bcfd := _g.ParseUint(_ecfcd.Value, 10, 32)
			if _bcfd != nil {
				return _bcfd
			}
			_cfgfa.NAttr = uint32(_ceeda)
			continue
		}
		if _ecfcd.Name.Local == "np" {
			_gacce, _bfbgd := _g.ParseUint(_ecfcd.Value, 10, 32)
			if _bfbgd != nil {
				return _bfbgd
			}
			_cfgfa.NpAttr = uint32(_gacce)
			continue
		}
	}
	for {
		_bebeac, _fbbbe := d.Token()
		if _fbbbe != nil {
			return _bg.Errorf("parsing\u0020CT_MdxMemeberProp: \u0025s", _fbbbe)
		}
		if _bdfff, _gcaa := _bebeac.(_f.EndElement); _gcaa && _bdfff.Name == start.Name {
			break
		}
	}
	return nil
}
func (_edacc ST_BorderStyle) Validate() error { return _edacc.ValidateWithPath("") }

const (
	ST_TotalsRowFunctionUnset     ST_TotalsRowFunction = 0
	ST_TotalsRowFunctionNone      ST_TotalsRowFunction = 1
	ST_TotalsRowFunctionSum       ST_TotalsRowFunction = 2
	ST_TotalsRowFunctionMin       ST_TotalsRowFunction = 3
	ST_TotalsRowFunctionMax       ST_TotalsRowFunction = 4
	ST_TotalsRowFunctionAverage   ST_TotalsRowFunction = 5
	ST_TotalsRowFunctionCount     ST_TotalsRowFunction = 6
	ST_TotalsRowFunctionCountNums ST_TotalsRowFunction = 7
	ST_TotalsRowFunctionStdDev    ST_TotalsRowFunction = 8
	ST_TotalsRowFunctionVar       ST_TotalsRowFunction = 9
	ST_TotalsRowFunctionCustom    ST_TotalsRowFunction = 10
)

func (_cegefa *ST_CfvoType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_cegefa = 0
	case "num":
		*_cegefa = 1
	case "percent":
		*_cegefa = 2
	case "max":
		*_cegefa = 3
	case "min":
		*_cegefa = 4
	case "formula":
		*_cegefa = 5
	case "percentile":
		*_cegefa = 6
	}
	return nil
}

type CT_SheetCalcPr struct {

	// Full Calculation On Load
	FullCalcOnLoadAttr *bool
}
type CT_GroupLevel struct {

	// Unique Name
	UniqueNameAttr string

	// Grouping Level Display Name
	CaptionAttr string

	// User-Defined Group Level
	UserAttr *bool

	// Custom Roll Up
	CustomRollUpAttr *bool

	// OLAP Level Groups
	Groups *CT_Groups

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_gfbgf *CT_WebPublishing) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gfbgf.CssAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "css"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gfbgf.CssAttr))})
	}
	if _gfbgf.ThicketAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "thicket"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gfbgf.ThicketAttr))})
	}
	if _gfbgf.LongFileNamesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "longFileNames"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gfbgf.LongFileNamesAttr))})
	}
	if _gfbgf.VmlAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "vml"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gfbgf.VmlAttr))})
	}
	if _gfbgf.AllowPngAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "allowPng"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gfbgf.AllowPngAttr))})
	}
	if _gfbgf.TargetScreenSizeAttr != ST_TargetScreenSizeUnset {
		_bbgaae, _caegcc := _gfbgf.TargetScreenSizeAttr.MarshalXMLAttr(_f.Name{Local: "targetScreenSize"})
		if _caegcc != nil {
			return _caegcc
		}
		start.Attr = append(start.Attr, _bbgaae)
	}
	if _gfbgf.DpiAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dpi"}, Value: _bg.Sprintf("\u0025v", *_gfbgf.DpiAttr)})
	}
	if _gfbgf.CodePageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "codePage"}, Value: _bg.Sprintf("\u0025v", *_gfbgf.CodePageAttr)})
	}
	if _gfbgf.CharacterSetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "characterSet"}, Value: _bg.Sprintf("\u0025v", *_gfbgf.CharacterSetAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_egbgac *ST_rwColActionType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gabdc, _fgbbce := d.Token()
	if _fgbbce != nil {
		return _fgbbce
	}
	if _aadebf, _eadfad := _gabdc.(_f.EndElement); _eadfad && _aadebf.Name == start.Name {
		*_egbgac = 1
		return nil
	}
	if _beeaaa, _dbgag := _gabdc.(_f.CharData); !_dbgag {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gabdc)
	} else {
		switch string(_beeaaa) {
		case "":
			*_egbgac = 0
		case "insertRow":
			*_egbgac = 1
		case "deleteRow":
			*_egbgac = 2
		case "insertCol":
			*_egbgac = 3
		case "deleteCol":
			*_egbgac = 4
		}
	}
	_gabdc, _fgbbce = d.Token()
	if _fgbbce != nil {
		return _fgbbce
	}
	if _bgebed, _efacgd := _gabdc.(_f.EndElement); _efacgd && _bgebed.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gabdc)
}

type CT_MdxKPI struct {

	// Member Unique Name Index
	NAttr uint32

	// KPI Index
	NpAttr uint32

	// KPI Property
	PAttr ST_MdxKPIProperty
}

func (_aegdfa ST_DateTimeGrouping) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_ddcgdc := _f.Attr{}
	_ddcgdc.Name = name
	switch _aegdfa {
	case ST_DateTimeGroupingUnset:
		_ddcgdc.Value = ""
	case ST_DateTimeGroupingYear:
		_ddcgdc.Value = "year"
	case ST_DateTimeGroupingMonth:
		_ddcgdc.Value = "month"
	case ST_DateTimeGroupingDay:
		_ddcgdc.Value = "day"
	case ST_DateTimeGroupingHour:
		_ddcgdc.Value = "hour"
	case ST_DateTimeGroupingMinute:
		_ddcgdc.Value = "minute"
	case ST_DateTimeGroupingSecond:
		_ddcgdc.Value = "second"
	}
	return _ddcgdc, nil
}
func (_dgcd *CT_MdxTuple) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dgabd := range start.Attr {
		if _dgabd.Name.Local == "c" {
			_gaadec, _bgbdg := _g.ParseUint(_dgabd.Value, 10, 32)
			if _bgbdg != nil {
				return _bgbdg
			}
			_febdb := uint32(_gaadec)
			_dgcd.CAttr = &_febdb
			continue
		}
		if _dgabd.Name.Local == "ct" {
			_afdbf, _aeggg := _dgabd.Value, error(nil)
			if _aeggg != nil {
				return _aeggg
			}
			_dgcd.CtAttr = &_afdbf
			continue
		}
		if _dgabd.Name.Local == "si" {
			_gbff, _fdfc := _g.ParseUint(_dgabd.Value, 10, 32)
			if _fdfc != nil {
				return _fdfc
			}
			_aeabd := uint32(_gbff)
			_dgcd.SiAttr = &_aeabd
			continue
		}
		if _dgabd.Name.Local == "fi" {
			_decbf, _ccfge := _g.ParseUint(_dgabd.Value, 10, 32)
			if _ccfge != nil {
				return _ccfge
			}
			_eabgcb := uint32(_decbf)
			_dgcd.FiAttr = &_eabgcb
			continue
		}
		if _dgabd.Name.Local == "bc" {
			_gcfe, _fdcad := _dgabd.Value, error(nil)
			if _fdcad != nil {
				return _fdcad
			}
			_dgcd.BcAttr = &_gcfe
			continue
		}
		if _dgabd.Name.Local == "fc" {
			_fbbgg, _ebfce := _dgabd.Value, error(nil)
			if _ebfce != nil {
				return _ebfce
			}
			_dgcd.FcAttr = &_fbbgg
			continue
		}
		if _dgabd.Name.Local == "i" {
			_fgcaa, _cabafb := _g.ParseBool(_dgabd.Value)
			if _cabafb != nil {
				return _cabafb
			}
			_dgcd.IAttr = &_fgcaa
			continue
		}
		if _dgabd.Name.Local == "u" {
			_ddaaf, _acecf := _g.ParseBool(_dgabd.Value)
			if _acecf != nil {
				return _acecf
			}
			_dgcd.UAttr = &_ddaaf
			continue
		}
		if _dgabd.Name.Local == "st" {
			_ffcc, _ccefb := _g.ParseBool(_dgabd.Value)
			if _ccefb != nil {
				return _ccefb
			}
			_dgcd.StAttr = &_ffcc
			continue
		}
		if _dgabd.Name.Local == "b" {
			_bcfbf, _aecea := _g.ParseBool(_dgabd.Value)
			if _aecea != nil {
				return _aecea
			}
			_dgcd.BAttr = &_bcfbf
			continue
		}
	}
_cdbeg:
	for {
		_ggdbe, _adaa := d.Token()
		if _adaa != nil {
			return _adaa
		}
		switch _geggc := _ggdbe.(type) {
		case _f.StartElement:
			switch _geggc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "n"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "n"}:
				_aedbg := NewCT_MetadataStringIndex()
				if _ddgag := d.DecodeElement(_aedbg, &_geggc); _ddgag != nil {
					return _ddgag
				}
				_dgcd.N = append(_dgcd.N, _aedbg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_MdxTuple\u0020\u0025v", _geggc.Name)
				if _cddaca := d.Skip(); _cddaca != nil {
					return _cddaca
				}
			}
		case _f.EndElement:
			break _cdbeg
		case _f.CharData:
		}
	}
	return nil
}
func (_eceag ST_FormatAction) Validate() error { return _eceag.ValidateWithPath("") }
func (_dgffcf ST_CellType) ValidateWithPath(path string) error {
	switch _dgffcf {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dgffcf))
	}
	return nil
}

type CT_CacheHierarchy struct {

	// Hierarchy Unique Name
	UniqueNameAttr string

	// Hierarchy Display Name
	CaptionAttr *string

	// Measure Hierarchy
	MeasureAttr *bool

	// Set
	SetAttr *bool

	// Parent Set
	ParentSetAttr *uint32

	// KPI Icon Set
	IconSetAttr *int32

	// Attribute Hierarchy
	AttributeAttr *bool

	// Time
	TimeAttr *bool

	// Key Attribute Hierarchy
	KeyAttributeAttr *bool

	// Default Member Unique Name
	DefaultMemberUniqueNameAttr *string

	// Unique Name of 'All'
	AllUniqueNameAttr *string

	// Display Name of 'All'
	AllCaptionAttr *string

	// Dimension Unique Name
	DimensionUniqueNameAttr *string

	// Display Folder
	DisplayFolderAttr *string

	// Measure Group Name
	MeasureGroupAttr *string

	// Measures
	MeasuresAttr *bool

	// Levels Count
	CountAttr uint32

	// One Field
	OneFieldAttr *bool

	// Member Value Data Type
	MemberValueDatatypeAttr *uint16

	// Unbalanced
	UnbalancedAttr *bool

	// Unbalanced Group
	UnbalancedGroupAttr *bool

	// Hidden
	HiddenAttr *bool

	// Fields Usage
	FieldsUsage *CT_FieldsUsage

	// OLAP Grouping Levels
	GroupLevels *CT_GroupLevels

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_dfeg *CT_SortState) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cabc := range start.Attr {
		if _cabc.Name.Local == "columnSort" {
			_cfda, _fffeda := _g.ParseBool(_cabc.Value)
			if _fffeda != nil {
				return _fffeda
			}
			_dfeg.ColumnSortAttr = &_cfda
			continue
		}
		if _cabc.Name.Local == "caseSensitive" {
			_bbggb, _eacgg := _g.ParseBool(_cabc.Value)
			if _eacgg != nil {
				return _eacgg
			}
			_dfeg.CaseSensitiveAttr = &_bbggb
			continue
		}
		if _cabc.Name.Local == "sortMethod" {
			_dfeg.SortMethodAttr.UnmarshalXMLAttr(_cabc)
			continue
		}
		if _cabc.Name.Local == "ref" {
			_fbagc, _bdcfc := _cabc.Value, error(nil)
			if _bdcfc != nil {
				return _bdcfc
			}
			_dfeg.RefAttr = _fbagc
			continue
		}
	}
_dfbbb:
	for {
		_efcaa, _accbc := d.Token()
		if _accbc != nil {
			return _accbc
		}
		switch _cgaage := _efcaa.(type) {
		case _f.StartElement:
			switch _cgaage.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sortCondition"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sortCondition"}:
				_daacf := NewCT_SortCondition()
				if _fedcba := d.DecodeElement(_daacf, &_cgaage); _fedcba != nil {
					return _fedcba
				}
				_dfeg.SortCondition = append(_dfeg.SortCondition, _daacf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_dfeg.ExtLst = NewCT_ExtensionList()
				if _aaefd := d.DecodeElement(_dfeg.ExtLst, &_cgaage); _aaefd != nil {
					return _aaefd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SortState\u0020\u0025v", _cgaage.Name)
				if _fgdba := d.Skip(); _fgdba != nil {
					return _fgdba
				}
			}
		case _f.EndElement:
			break _dfbbb
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_CustomSheetViews and its children
func (_gdgd *CT_CustomSheetViews) Validate() error {
	return _gdgd.ValidateWithPath("CT_CustomSheetViews")
}

type ST_OleUpdate byte
type ST_ItemType byte

func (_aacbce *ST_SortType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_aacbce = 0
	case "none":
		*_aacbce = 1
	case "ascending":
		*_aacbce = 2
	case "descending":
		*_aacbce = 3
	case "ascendingAlpha":
		*_aacbce = 4
	case "descendingAlpha":
		*_aacbce = 5
	case "ascendingNatural":
		*_aacbce = 6
	case "descendingNatural":
		*_aacbce = 7
	}
	return nil
}
func (_eadgd *CT_VolTopicRef) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", _eadgd.RAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "s"}, Value: _bg.Sprintf("\u0025v", _eadgd.SAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_deadd *CT_FieldsUsage) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _acfdf := range start.Attr {
		if _acfdf.Name.Local == "count" {
			_bafgc, _cgcd := _g.ParseUint(_acfdf.Value, 10, 32)
			if _cgcd != nil {
				return _cgcd
			}
			_dbfda := uint32(_bafgc)
			_deadd.CountAttr = &_dbfda
			continue
		}
	}
_adec:
	for {
		_fdefa, _abag := d.Token()
		if _abag != nil {
			return _abag
		}
		switch _bgaaf := _fdefa.(type) {
		case _f.StartElement:
			switch _bgaaf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fieldUsage"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fieldUsage"}:
				_baffc := NewCT_FieldUsage()
				if _fdgge := d.DecodeElement(_baffc, &_bgaaf); _fdgge != nil {
					return _fdgge
				}
				_deadd.FieldUsage = append(_deadd.FieldUsage, _baffc)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_FieldsUsage\u0020\u0025v", _bgaaf.Name)
				if _cbagfc := d.Skip(); _cbagfc != nil {
					return _cbagfc
				}
			}
		case _f.EndElement:
			break _adec
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PageMargins and its children, prefixing error messages with path
func (_gceb *CT_PageMargins) ValidateWithPath(path string) error { return nil }
func (_aeegff *CT_VolTopic) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cgecd := range start.Attr {
		if _cgecd.Name.Local == "t" {
			_aeegff.TAttr.UnmarshalXMLAttr(_cgecd)
			continue
		}
	}
_ecgfff:
	for {
		_adeac, _bgfag := d.Token()
		if _bgfag != nil {
			return _bgfag
		}
		switch _beggf := _adeac.(type) {
		case _f.StartElement:
			switch _beggf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "v"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "v"}:
				if _gcac := d.DecodeElement(&_aeegff.V, &_beggf); _gcac != nil {
					return _gcac
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "stp"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "stp"}:
				var _gcdbb string
				if _addaff := d.DecodeElement(&_gcdbb, &_beggf); _addaff != nil {
					return _addaff
				}
				_aeegff.Stp = append(_aeegff.Stp, _gcdbb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tr"}:
				_dggecd := NewCT_VolTopicRef()
				if _cacbgc := d.DecodeElement(_dggecd, &_beggf); _cacbgc != nil {
					return _cacbgc
				}
				_aeegff.Tr = append(_aeegff.Tr, _dggecd)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_VolTopic\u0020\u0025v", _beggf.Name)
				if _eaaff := d.Skip(); _eaaff != nil {
					return _eaaff
				}
			}
		case _f.EndElement:
			break _ecgfff
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_RevisionHeaders and its children
func (_ecfba *CT_RevisionHeaders) Validate() error {
	return _ecfba.ValidateWithPath("CT_RevisionHeaders")
}

// Validate validates the CT_ChartsheetView and its children
func (_agcg *CT_ChartsheetView) Validate() error { return _agcg.ValidateWithPath("CT_ChartsheetView") }

// ValidateWithPath validates the CT_Scenarios and its children, prefixing error messages with path
func (_ebaecd *CT_Scenarios) ValidateWithPath(path string) error {
	for _abfbb, _gaacad := range _ebaecd.Scenario {
		if _fefga := _gaacad.ValidateWithPath(_bg.Sprintf("\u0025s\u002fScenario\u005b\u0025d\u005d", path, _abfbb)); _fefga != nil {
			return _fefga
		}
	}
	return nil
}

// Validate validates the CT_VolType and its children
func (_abcec *CT_VolType) Validate() error { return _abcec.ValidateWithPath("CT_VolType") }

// ValidateWithPath validates the CT_WebPublishObjects and its children, prefixing error messages with path
func (_ffadba *CT_WebPublishObjects) ValidateWithPath(path string) error {
	for _fefaf, _cfaeeg := range _ffadba.WebPublishObject {
		if _effef := _cfaeeg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fWebPublishObject\u005b\u0025d\u005d", path, _fefaf)); _effef != nil {
			return _effef
		}
	}
	return nil
}

// Validate validates the CT_ExternalReference and its children
func (_feagg *CT_ExternalReference) Validate() error {
	return _feagg.ValidateWithPath("CT_ExternalReference")
}
func NewCT_ChartsheetPr() *CT_ChartsheetPr { _bgfg := &CT_ChartsheetPr{}; return _bgfg }
func (_acbfgg *CT_SheetView) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _acbfgg.WindowProtectionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "windowProtection"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbfgg.WindowProtectionAttr))})
	}
	if _acbfgg.ShowFormulasAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showFormulas"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbfgg.ShowFormulasAttr))})
	}
	if _acbfgg.ShowGridLinesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showGridLines"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbfgg.ShowGridLinesAttr))})
	}
	if _acbfgg.ShowRowColHeadersAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showRowColHeaders"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbfgg.ShowRowColHeadersAttr))})
	}
	if _acbfgg.ShowZerosAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showZeros"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbfgg.ShowZerosAttr))})
	}
	if _acbfgg.RightToLeftAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rightToLeft"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbfgg.RightToLeftAttr))})
	}
	if _acbfgg.TabSelectedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "tabSelected"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbfgg.TabSelectedAttr))})
	}
	if _acbfgg.ShowRulerAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showRuler"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbfgg.ShowRulerAttr))})
	}
	if _acbfgg.ShowOutlineSymbolsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showOutlineSymbols"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbfgg.ShowOutlineSymbolsAttr))})
	}
	if _acbfgg.DefaultGridColorAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultGridColor"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbfgg.DefaultGridColorAttr))})
	}
	if _acbfgg.ShowWhiteSpaceAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showWhiteSpace"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_acbfgg.ShowWhiteSpaceAttr))})
	}
	if _acbfgg.ViewAttr != ST_SheetViewTypeUnset {
		_dfabg, _gdgfad := _acbfgg.ViewAttr.MarshalXMLAttr(_f.Name{Local: "view"})
		if _gdgfad != nil {
			return _gdgfad
		}
		start.Attr = append(start.Attr, _dfabg)
	}
	if _acbfgg.TopLeftCellAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "topLeftCell"}, Value: _bg.Sprintf("\u0025v", *_acbfgg.TopLeftCellAttr)})
	}
	if _acbfgg.ColorIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "colorId"}, Value: _bg.Sprintf("\u0025v", *_acbfgg.ColorIdAttr)})
	}
	if _acbfgg.ZoomScaleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "zoomScale"}, Value: _bg.Sprintf("\u0025v", *_acbfgg.ZoomScaleAttr)})
	}
	if _acbfgg.ZoomScaleNormalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "zoomScaleNormal"}, Value: _bg.Sprintf("\u0025v", *_acbfgg.ZoomScaleNormalAttr)})
	}
	if _acbfgg.ZoomScaleSheetLayoutViewAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "zoomScaleSheetLayoutView"}, Value: _bg.Sprintf("\u0025v", *_acbfgg.ZoomScaleSheetLayoutViewAttr)})
	}
	if _acbfgg.ZoomScalePageLayoutViewAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "zoomScalePageLayoutView"}, Value: _bg.Sprintf("\u0025v", *_acbfgg.ZoomScalePageLayoutViewAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "workbookViewId"}, Value: _bg.Sprintf("\u0025v", _acbfgg.WorkbookViewIdAttr)})
	e.EncodeToken(start)
	if _acbfgg.Pane != nil {
		_afdfd := _f.StartElement{Name: _f.Name{Local: "ma:pane"}}
		e.EncodeElement(_acbfgg.Pane, _afdfd)
	}
	if _acbfgg.Selection != nil {
		_fdced := _f.StartElement{Name: _f.Name{Local: "ma:selection"}}
		for _, _cgafa := range _acbfgg.Selection {
			e.EncodeElement(_cgafa, _fdced)
		}
	}
	if _acbfgg.PivotSelection != nil {
		_aabef := _f.StartElement{Name: _f.Name{Local: "ma:pivotSelection"}}
		for _, _bccdg := range _acbfgg.PivotSelection {
			e.EncodeElement(_bccdg, _aabef)
		}
	}
	if _acbfgg.ExtLst != nil {
		_cefdga := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_acbfgg.ExtLst, _cefdga)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_PageItem struct {

	// Page Item Name
	NameAttr string
}

func (_bgeaf ST_SortMethod) Validate() error { return _bgeaf.ValidateWithPath("") }
func NewCT_Format() *CT_Format {
	_ccged := &CT_Format{}
	_ccged.PivotArea = NewCT_PivotArea()
	return _ccged
}

type ST_SortMethod byte

func (_cgcf *CT_CustomChartsheetView) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "guid"}, Value: _bg.Sprintf("\u0025v", _cgcf.GuidAttr)})
	if _cgcf.ScaleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "scale"}, Value: _bg.Sprintf("\u0025v", *_cgcf.ScaleAttr)})
	}
	if _cgcf.StateAttr != ST_SheetStateUnset {
		_addf, _gcgfc := _cgcf.StateAttr.MarshalXMLAttr(_f.Name{Local: "state"})
		if _gcgfc != nil {
			return _gcgfc
		}
		start.Attr = append(start.Attr, _addf)
	}
	if _cgcf.ZoomToFitAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "zoomToFit"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cgcf.ZoomToFitAttr))})
	}
	e.EncodeToken(start)
	if _cgcf.PageMargins != nil {
		_gecg := _f.StartElement{Name: _f.Name{Local: "ma:pageMargins"}}
		e.EncodeElement(_cgcf.PageMargins, _gecg)
	}
	if _cgcf.PageSetup != nil {
		_bgeac := _f.StartElement{Name: _f.Name{Local: "ma:pageSetup"}}
		e.EncodeElement(_cgcf.PageSetup, _bgeac)
	}
	if _cgcf.HeaderFooter != nil {
		_aedgf := _f.StartElement{Name: _f.Name{Local: "ma:headerFooter"}}
		e.EncodeElement(_cgcf.HeaderFooter, _aedgf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_MetadataStringIndex and its children
func (_gafgb *CT_MetadataStringIndex) Validate() error {
	return _gafgb.ValidateWithPath("CT_MetadataStringIndex")
}
func (_dcfgdb *CT_XmlCellPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dcfgdb.XmlPr = NewCT_XmlPr()
	for _, _begead := range start.Attr {
		if _begead.Name.Local == "id" {
			_daaea, _ccbegd := _g.ParseUint(_begead.Value, 10, 32)
			if _ccbegd != nil {
				return _ccbegd
			}
			_dcfgdb.IdAttr = uint32(_daaea)
			continue
		}
		if _begead.Name.Local == "uniqueName" {
			_gfgec, _faafbf := _begead.Value, error(nil)
			if _faafbf != nil {
				return _faafbf
			}
			_dcfgdb.UniqueNameAttr = &_gfgec
			continue
		}
	}
_gdffg:
	for {
		_egaeee, _defbe := d.Token()
		if _defbe != nil {
			return _defbe
		}
		switch _eecbe := _egaeee.(type) {
		case _f.StartElement:
			switch _eecbe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "xmlPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "xmlPr"}:
				if _eaffa := d.DecodeElement(_dcfgdb.XmlPr, &_eecbe); _eaffa != nil {
					return _eaffa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_dcfgdb.ExtLst = NewCT_ExtensionList()
				if _fgaac := d.DecodeElement(_dcfgdb.ExtLst, &_eecbe); _fgaac != nil {
					return _fgaac
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_XmlCellPr\u0020\u0025v", _eecbe.Name)
				if _abefce := d.Skip(); _abefce != nil {
					return _abefce
				}
			}
		case _f.EndElement:
			break _gdffg
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Format and its children
func (_abefa *CT_Format) Validate() error { return _abefa.ValidateWithPath("CT_Format") }
func (_ddadbg ST_Type) ValidateWithPath(path string) error {
	switch _ddadbg {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ddadbg))
	}
	return nil
}

// ValidateWithPath validates the CT_CustomWorkbookView and its children, prefixing error messages with path
func (_bdbebc *CT_CustomWorkbookView) ValidateWithPath(path string) error {
	if !_e.ST_GuidPatternRe.MatchString(_bdbebc.GuidAttr) {
		return _bg.Errorf("\u0025s\u002fm\u002eGuidAttr must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_GuidPatternRe, _bdbebc.GuidAttr)
	}
	if _abcga := _bdbebc.ShowCommentsAttr.ValidateWithPath(path + "\u002fShowCommentsAttr"); _abcga != nil {
		return _abcga
	}
	if _edgg := _bdbebc.ShowObjectsAttr.ValidateWithPath(path + "\u002fShowObjectsAttr"); _edgg != nil {
		return _edgg
	}
	if _bdbebc.ExtLst != nil {
		if _edbae := _bdbebc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _edbae != nil {
			return _edbae
		}
	}
	return nil
}
func (_ebadcf ST_RevisionAction) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_cgcba := _f.Attr{}
	_cgcba.Name = name
	switch _ebadcf {
	case ST_RevisionActionUnset:
		_cgcba.Value = ""
	case ST_RevisionActionAdd:
		_cgcba.Value = "add"
	case ST_RevisionActionDelete:
		_cgcba.Value = "delete"
	}
	return _cgcba, nil
}

// Validate validates the CT_OutlinePr and its children
func (_bbgd *CT_OutlinePr) Validate() error { return _bbgd.ValidateWithPath("CT_OutlinePr") }
func (_acacd *CT_GradientStop) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_acacd.Color = NewCT_Color()
	for _, _gefb := range start.Attr {
		if _gefb.Name.Local == "position" {
			_afaf, _gfcba := _g.ParseFloat(_gefb.Value, 64)
			if _gfcba != nil {
				return _gfcba
			}
			_acacd.PositionAttr = _afaf
			continue
		}
	}
_cdge:
	for {
		_ebacc, _afdce := d.Token()
		if _afdce != nil {
			return _afdce
		}
		switch _eegcd := _ebacc.(type) {
		case _f.StartElement:
			switch _eegcd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "color"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "color"}:
				if _egbca := d.DecodeElement(_acacd.Color, &_eegcd); _egbca != nil {
					return _egbca
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GradientStop\u0020\u0025v", _eegcd.Name)
				if _adbda := d.Skip(); _adbda != nil {
					return _adbda
				}
			}
		case _f.EndElement:
			break _cdge
		case _f.CharData:
		}
	}
	return nil
}

type CT_Filters struct {

	// Filter by Blank
	BlankAttr *bool

	// Calendar Type
	CalendarTypeAttr _e.ST_CalendarType

	// Filter
	Filter []*CT_Filter

	// Date Grouping
	DateGroupItem []*CT_DateGroupItem
}

func NewCT_PivotField() *CT_PivotField { _gbedf := &CT_PivotField{}; return _gbedf }

// Validate validates the CT_Color and its children
func (_aaedd *CT_Color) Validate() error { return _aaedd.ValidateWithPath("CT_Color") }

type CT_OleItem struct {

	// Object Name
	NameAttr string

	// Icon
	IconAttr *bool

	// Advise
	AdviseAttr *bool

	// Object is an Image
	PreferPicAttr *bool
}

func (_dacdc ST_DvAspect) ValidateWithPath(path string) error {
	switch _dacdc {
	case 0, 1, 2:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dacdc))
	}
	return nil
}
func (_acecg ST_TargetScreenSize) ValidateWithPath(path string) error {
	switch _acecg {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_acecg))
	}
	return nil
}
func (_begbbf *ST_TotalsRowFunction) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_begbbf = 0
	case "none":
		*_begbbf = 1
	case "sum":
		*_begbbf = 2
	case "min":
		*_begbbf = 3
	case "max":
		*_begbbf = 4
	case "average":
		*_begbbf = 5
	case "count":
		*_begbbf = 6
	case "countNums":
		*_begbbf = 7
	case "stdDev":
		*_begbbf = 8
	case "var":
		*_begbbf = 9
	case "custom":
		*_begbbf = 10
	}
	return nil
}

type CT_Fills struct {

	// Fill Count
	CountAttr *uint32

	// Fill
	Fill []*CT_Fill
}

func NewCT_Cfvo() *CT_Cfvo { _edfe := &CT_Cfvo{}; _edfe.TypeAttr = ST_CfvoType(1); return _edfe }
func (_fffa *CT_HeaderFooter) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fffa.DifferentOddEvenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "differentOddEven"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fffa.DifferentOddEvenAttr))})
	}
	if _fffa.DifferentFirstAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "differentFirst"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fffa.DifferentFirstAttr))})
	}
	if _fffa.ScaleWithDocAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "scaleWithDoc"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fffa.ScaleWithDocAttr))})
	}
	if _fffa.AlignWithMarginsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "alignWithMargins"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fffa.AlignWithMarginsAttr))})
	}
	e.EncodeToken(start)
	if _fffa.OddHeader != nil {
		_ggafb := _f.StartElement{Name: _f.Name{Local: "ma:oddHeader"}}
		_cb.AddPreserveSpaceAttr(&_ggafb, *_fffa.OddHeader)
		e.EncodeElement(_fffa.OddHeader, _ggafb)
	}
	if _fffa.OddFooter != nil {
		_fbbgb := _f.StartElement{Name: _f.Name{Local: "ma:oddFooter"}}
		_cb.AddPreserveSpaceAttr(&_fbbgb, *_fffa.OddFooter)
		e.EncodeElement(_fffa.OddFooter, _fbbgb)
	}
	if _fffa.EvenHeader != nil {
		_gbccf := _f.StartElement{Name: _f.Name{Local: "ma:evenHeader"}}
		_cb.AddPreserveSpaceAttr(&_gbccf, *_fffa.EvenHeader)
		e.EncodeElement(_fffa.EvenHeader, _gbccf)
	}
	if _fffa.EvenFooter != nil {
		_caddc := _f.StartElement{Name: _f.Name{Local: "ma:evenFooter"}}
		_cb.AddPreserveSpaceAttr(&_caddc, *_fffa.EvenFooter)
		e.EncodeElement(_fffa.EvenFooter, _caddc)
	}
	if _fffa.FirstHeader != nil {
		_eadfb := _f.StartElement{Name: _f.Name{Local: "ma:firstHeader"}}
		_cb.AddPreserveSpaceAttr(&_eadfb, *_fffa.FirstHeader)
		e.EncodeElement(_fffa.FirstHeader, _eadfb)
	}
	if _fffa.FirstFooter != nil {
		_bcbec := _f.StartElement{Name: _f.Name{Local: "ma:firstFooter"}}
		_cb.AddPreserveSpaceAttr(&_bcbec, *_fffa.FirstFooter)
		e.EncodeElement(_fffa.FirstFooter, _bcbec)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gfdfa ST_GroupBy) String() string {
	switch _gfdfa {
	case 0:
		return ""
	case 1:
		return "range"
	case 2:
		return "seconds"
	case 3:
		return "minutes"
	case 4:
		return "hours"
	case 5:
		return "days"
	case 6:
		return "months"
	case 7:
		return "quarters"
	case 8:
		return "years"
	}
	return ""
}
func (_befce *CT_PageSetup) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fafge := range start.Attr {
		if _fafge.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _fafge.Name.Local == "id" || _fafge.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _fafge.Name.Local == "id" {
			_fgbab, _cafcc := _fafge.Value, error(nil)
			if _cafcc != nil {
				return _cafcc
			}
			_befce.IdAttr = &_fgbab
			continue
		}
		if _fafge.Name.Local == "paperSize" {
			_ecffbd, _dcbffe := _g.ParseUint(_fafge.Value, 10, 32)
			if _dcbffe != nil {
				return _dcbffe
			}
			_fbdf := uint32(_ecffbd)
			_befce.PaperSizeAttr = &_fbdf
			continue
		}
		if _fafge.Name.Local == "blackAndWhite" {
			_ababg, _gcgg := _g.ParseBool(_fafge.Value)
			if _gcgg != nil {
				return _gcgg
			}
			_befce.BlackAndWhiteAttr = &_ababg
			continue
		}
		if _fafge.Name.Local == "draft" {
			_abbdb, _ebdcda := _g.ParseBool(_fafge.Value)
			if _ebdcda != nil {
				return _ebdcda
			}
			_befce.DraftAttr = &_abbdb
			continue
		}
		if _fafge.Name.Local == "scale" {
			_aceeba, _acdba := _g.ParseUint(_fafge.Value, 10, 32)
			if _acdba != nil {
				return _acdba
			}
			_fcded := uint32(_aceeba)
			_befce.ScaleAttr = &_fcded
			continue
		}
		if _fafge.Name.Local == "cellComments" {
			_befce.CellCommentsAttr.UnmarshalXMLAttr(_fafge)
			continue
		}
		if _fafge.Name.Local == "fitToWidth" {
			_cdcc, _facba := _g.ParseUint(_fafge.Value, 10, 32)
			if _facba != nil {
				return _facba
			}
			_aggce := uint32(_cdcc)
			_befce.FitToWidthAttr = &_aggce
			continue
		}
		if _fafge.Name.Local == "pageOrder" {
			_befce.PageOrderAttr.UnmarshalXMLAttr(_fafge)
			continue
		}
		if _fafge.Name.Local == "orientation" {
			_befce.OrientationAttr.UnmarshalXMLAttr(_fafge)
			continue
		}
		if _fafge.Name.Local == "paperHeight" {
			_fecf, _dgfgde := _fafge.Value, error(nil)
			if _dgfgde != nil {
				return _dgfgde
			}
			_befce.PaperHeightAttr = &_fecf
			continue
		}
		if _fafge.Name.Local == "paperWidth" {
			_ffcdf, _eeeba := _fafge.Value, error(nil)
			if _eeeba != nil {
				return _eeeba
			}
			_befce.PaperWidthAttr = &_ffcdf
			continue
		}
		if _fafge.Name.Local == "firstPageNumber" {
			_faga, _fdggg := _g.ParseUint(_fafge.Value, 10, 32)
			if _fdggg != nil {
				return _fdggg
			}
			_addgc := uint32(_faga)
			_befce.FirstPageNumberAttr = &_addgc
			continue
		}
		if _fafge.Name.Local == "fitToHeight" {
			_cegfe, _edecf := _g.ParseUint(_fafge.Value, 10, 32)
			if _edecf != nil {
				return _edecf
			}
			_fdafe := uint32(_cegfe)
			_befce.FitToHeightAttr = &_fdafe
			continue
		}
		if _fafge.Name.Local == "useFirstPageNumber" {
			_ebbgaa, _feeade := _g.ParseBool(_fafge.Value)
			if _feeade != nil {
				return _feeade
			}
			_befce.UseFirstPageNumberAttr = &_ebbgaa
			continue
		}
		if _fafge.Name.Local == "errors" {
			_befce.ErrorsAttr.UnmarshalXMLAttr(_fafge)
			continue
		}
		if _fafge.Name.Local == "horizontalDpi" {
			_aadga, _fdfeag := _g.ParseUint(_fafge.Value, 10, 32)
			if _fdfeag != nil {
				return _fdfeag
			}
			_eefgee := uint32(_aadga)
			_befce.HorizontalDpiAttr = &_eefgee
			continue
		}
		if _fafge.Name.Local == "verticalDpi" {
			_dgeg, _efcag := _g.ParseUint(_fafge.Value, 10, 32)
			if _efcag != nil {
				return _efcag
			}
			_cfecd := uint32(_dgeg)
			_befce.VerticalDpiAttr = &_cfecd
			continue
		}
		if _fafge.Name.Local == "copies" {
			_becfdf, _bgbg := _g.ParseUint(_fafge.Value, 10, 32)
			if _bgbg != nil {
				return _bgbg
			}
			_badeb := uint32(_becfdf)
			_befce.CopiesAttr = &_badeb
			continue
		}
		if _fafge.Name.Local == "usePrinterDefaults" {
			_gcgcfa, _edcbdg := _g.ParseBool(_fafge.Value)
			if _edcbdg != nil {
				return _edcbdg
			}
			_befce.UsePrinterDefaultsAttr = &_gcgcfa
			continue
		}
	}
	for {
		_cfbac, _fcbaga := d.Token()
		if _fcbaga != nil {
			return _bg.Errorf("parsing\u0020CT_PageSetup:\u0020\u0025s", _fcbaga)
		}
		if _ggabg, _affb := _cfbac.(_f.EndElement); _affb && _ggabg.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_TupleCache struct {

	// Entries
	Entries *CT_PCDSDTCEntries

	// Sets
	Sets *CT_Sets

	// OLAP Query Cache
	QueryCache *CT_QueryCache

	// Server Formats
	ServerFormats *CT_ServerFormats

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}
type CT_GroupMembers struct {

	// Group Member Count
	CountAttr *uint32

	// OLAP Group Member
	GroupMember []*CT_GroupMember
}

func NewCT_MRUColors() *CT_MRUColors           { _gfdbd := &CT_MRUColors{}; return _gfdbd }
func (_dcedba ST_Orientation) Validate() error { return _dcedba.ValidateWithPath("") }

// ValidateWithPath validates the CT_MetadataStrings and its children, prefixing error messages with path
func (_eagfg *CT_MetadataStrings) ValidateWithPath(path string) error {
	for _fdda, _fadgfd := range _eagfg.S {
		if _gacfc := _fadgfd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fS\u005b\u0025d\u005d", path, _fdda)); _gacfc != nil {
			return _gacfc
		}
	}
	return nil
}
func (_aeegb ST_GrowShrinkType) Validate() error { return _aeegb.ValidateWithPath("") }
func (_cgage *ST_HorizontalAlignment) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_cgage = 0
	case "general":
		*_cgage = 1
	case "left":
		*_cgage = 2
	case "center":
		*_cgage = 3
	case "right":
		*_cgage = 4
	case "fill":
		*_cgage = 5
	case "justify":
		*_cgage = 6
	case "centerContinuous":
		*_cgage = 7
	case "distributed":
		*_cgage = 8
	}
	return nil
}
func (_fdbeed *CT_Filter) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fdbeed.ValAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", *_fdbeed.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ddagb *CT_RevisionHeader) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "guid"}, Value: _bg.Sprintf("\u0025v", _ddagb.GuidAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dateTime"}, Value: _bg.Sprintf("\u0025v", _ddagb.DateTimeAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "maxSheetId"}, Value: _bg.Sprintf("\u0025v", _ddagb.MaxSheetIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "userName"}, Value: _bg.Sprintf("\u0025v", _ddagb.UserNameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _ddagb.IdAttr)})
	if _ddagb.MinRIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minRId"}, Value: _bg.Sprintf("\u0025v", *_ddagb.MinRIdAttr)})
	}
	if _ddagb.MaxRIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "maxRId"}, Value: _bg.Sprintf("\u0025v", *_ddagb.MaxRIdAttr)})
	}
	e.EncodeToken(start)
	_gfdfd := _f.StartElement{Name: _f.Name{Local: "ma:sheetIdMap"}}
	e.EncodeElement(_ddagb.SheetIdMap, _gfdfd)
	if _ddagb.ReviewedList != nil {
		_aegffe := _f.StartElement{Name: _f.Name{Local: "ma:reviewedList"}}
		e.EncodeElement(_ddagb.ReviewedList, _aegffe)
	}
	if _ddagb.ExtLst != nil {
		_dbce := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_ddagb.ExtLst, _dbce)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_FunctionGroup struct {

	// Name
	NameAttr *string
}

func (_gebda *CT_OleSize) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _gebda.RefAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_DynamicFilter and its children, prefixing error messages with path
func (_ggfc *CT_DynamicFilter) ValidateWithPath(path string) error {
	if _ggfc.TypeAttr == ST_DynamicFilterTypeUnset {
		return _bg.Errorf("\u0025s\u002fTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _fddcf := _ggfc.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _fddcf != nil {
		return _fddcf
	}
	return nil
}

// ValidateWithPath validates the CT_Colors and its children, prefixing error messages with path
func (_gcgf *CT_Colors) ValidateWithPath(path string) error {
	if _gcgf.IndexedColors != nil {
		if _eefae := _gcgf.IndexedColors.ValidateWithPath(path + "\u002fIndexedColors"); _eefae != nil {
			return _eefae
		}
	}
	if _gcgf.MruColors != nil {
		if _fffc := _gcgf.MruColors.ValidateWithPath(path + "\u002fMruColors"); _fffc != nil {
			return _fffc
		}
	}
	return nil
}
func (_ececed *ST_CfType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_eggeeab, _dfdfdg := d.Token()
	if _dfdfdg != nil {
		return _dfdfdg
	}
	if _bbgfd, _cbdbffb := _eggeeab.(_f.EndElement); _cbdbffb && _bbgfd.Name == start.Name {
		*_ececed = 1
		return nil
	}
	if _eddbc, _aeadc := _eggeeab.(_f.CharData); !_aeadc {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eggeeab)
	} else {
		switch string(_eddbc) {
		case "":
			*_ececed = 0
		case "expression":
			*_ececed = 1
		case "cellIs":
			*_ececed = 2
		case "colorScale":
			*_ececed = 3
		case "dataBar":
			*_ececed = 4
		case "iconSet":
			*_ececed = 5
		case "top10":
			*_ececed = 6
		case "uniqueValues":
			*_ececed = 7
		case "duplicateValues":
			*_ececed = 8
		case "containsText":
			*_ececed = 9
		case "notContainsText":
			*_ececed = 10
		case "beginsWith":
			*_ececed = 11
		case "endsWith":
			*_ececed = 12
		case "containsBlanks":
			*_ececed = 13
		case "notContainsBlanks":
			*_ececed = 14
		case "containsErrors":
			*_ececed = 15
		case "notContainsErrors":
			*_ececed = 16
		case "timePeriod":
			*_ececed = 17
		case "aboveAverage":
			*_ececed = 18
		}
	}
	_eggeeab, _dfdfdg = d.Token()
	if _dfdfdg != nil {
		return _dfdfdg
	}
	if _acgggb, _eggdec := _eggeeab.(_f.EndElement); _eggdec && _acgggb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eggeeab)
}
func (_dagcbba *ST_CellComments) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gcebd, _agbfb := d.Token()
	if _agbfb != nil {
		return _agbfb
	}
	if _aadgd, _cccdg := _gcebd.(_f.EndElement); _cccdg && _aadgd.Name == start.Name {
		*_dagcbba = 1
		return nil
	}
	if _edbfb, _cabfee := _gcebd.(_f.CharData); !_cabfee {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gcebd)
	} else {
		switch string(_edbfb) {
		case "":
			*_dagcbba = 0
		case "none":
			*_dagcbba = 1
		case "asDisplayed":
			*_dagcbba = 2
		case "atEnd":
			*_dagcbba = 3
		}
	}
	_gcebd, _agbfb = d.Token()
	if _agbfb != nil {
		return _agbfb
	}
	if _ebafde, _edbeeg := _gcebd.(_f.EndElement); _edbeeg && _ebafde.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gcebd)
}
func (_dacba *CT_SheetDimension) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bafea := range start.Attr {
		if _bafea.Name.Local == "ref" {
			_ebdfa, _aabac := _bafea.Value, error(nil)
			if _aabac != nil {
				return _aabac
			}
			_dacba.RefAttr = _ebdfa
			continue
		}
	}
	for {
		_gecabc, _efgfb := d.Token()
		if _efgfb != nil {
			return _bg.Errorf("parsing\u0020CT_SheetDimension: \u0025s", _efgfb)
		}
		if _dadaa, _cbcfa := _gecabc.(_f.EndElement); _cbcfa && _dadaa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_caaed *ST_DataValidationErrorStyle) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_eagabe, _gadfa := d.Token()
	if _gadfa != nil {
		return _gadfa
	}
	if _bdaag, _fabab := _eagabe.(_f.EndElement); _fabab && _bdaag.Name == start.Name {
		*_caaed = 1
		return nil
	}
	if _deegc, _abcac := _eagabe.(_f.CharData); !_abcac {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eagabe)
	} else {
		switch string(_deegc) {
		case "":
			*_caaed = 0
		case "stop":
			*_caaed = 1
		case "warning":
			*_caaed = 2
		case "information":
			*_caaed = 3
		}
	}
	_eagabe, _gadfa = d.Token()
	if _gadfa != nil {
		return _gadfa
	}
	if _bebade, _ggbaa := _eagabe.(_f.EndElement); _ggbaa && _bebade.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eagabe)
}

type CT_PageField struct {

	// Field
	FldAttr int32

	// Item Index
	ItemAttr *uint32

	// OLAP Hierarchy Index
	HierAttr *int32

	// Hierarchy Unique Name
	NameAttr *string

	// Hierarchy Display Name
	CapAttr *string

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

// Validate validates the CT_OleObject and its children
func (_eacb *CT_OleObject) Validate() error { return _eacb.ValidateWithPath("CT_OleObject") }
func (_ea *AG_AutoFormat) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dg := range start.Attr {
		if _dg.Name.Local == "autoFormatId" {
			_ca, _ege := _g.ParseUint(_dg.Value, 10, 32)
			if _ege != nil {
				return _ege
			}
			_ba := uint32(_ca)
			_ea.AutoFormatIdAttr = &_ba
			continue
		}
		if _dg.Name.Local == "applyNumberFormats" {
			_gd, _a := _g.ParseBool(_dg.Value)
			if _a != nil {
				return _a
			}
			_ea.ApplyNumberFormatsAttr = &_gd
			continue
		}
		if _dg.Name.Local == "applyBorderFormats" {
			_db, _fa := _g.ParseBool(_dg.Value)
			if _fa != nil {
				return _fa
			}
			_ea.ApplyBorderFormatsAttr = &_db
			continue
		}
		if _dg.Name.Local == "applyFontFormats" {
			_dgd, _cc := _g.ParseBool(_dg.Value)
			if _cc != nil {
				return _cc
			}
			_ea.ApplyFontFormatsAttr = &_dgd
			continue
		}
		if _dg.Name.Local == "applyPatternFormats" {
			_cbf, _ag := _g.ParseBool(_dg.Value)
			if _ag != nil {
				return _ag
			}
			_ea.ApplyPatternFormatsAttr = &_cbf
			continue
		}
		if _dg.Name.Local == "applyAlignmentFormats" {
			_gda, _fe := _g.ParseBool(_dg.Value)
			if _fe != nil {
				return _fe
			}
			_ea.ApplyAlignmentFormatsAttr = &_gda
			continue
		}
		if _dg.Name.Local == "applyWidthHeightFormats" {
			_ae, _ed := _g.ParseBool(_dg.Value)
			if _ed != nil {
				return _ed
			}
			_ea.ApplyWidthHeightFormatsAttr = &_ae
			continue
		}
	}
	for {
		_bf, _ce := d.Token()
		if _ce != nil {
			return _bg.Errorf("parsing\u0020AG_AutoFormat:\u0020\u0025s", _ce)
		}
		if _fda, _gde := _bf.(_f.EndElement); _gde && _fda.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Set() *CT_Set                           { _gabgg := &CT_Set{}; return _gabgg }
func NewCT_QueryTableFields() *CT_QueryTableFields { _cdbegd := &CT_QueryTableFields{}; return _cdbegd }

type ST_UpdateLinks byte

func (_aabdd *CT_GroupLevels) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aabdd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_aabdd.CountAttr)})
	}
	e.EncodeToken(start)
	_fffe := _f.StartElement{Name: _f.Name{Local: "ma:groupLevel"}}
	for _, _deeed := range _aabdd.GroupLevel {
		e.EncodeElement(_deeed, _fffe)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_Error struct {

	// Value
	VAttr string

	// Unused Item
	UAttr *bool

	// Calculated Item
	FAttr *bool

	// Item Caption
	CAttr *string

	// Member Property Count
	CpAttr *uint32

	// Format Index
	InAttr *uint32

	// background Color
	BcAttr *string

	// Foreground Color
	FcAttr *string

	// Italic
	IAttr *bool

	// Underline
	UnAttr *bool

	// Strikethrough
	StAttr *bool

	// Bold
	BAttr *bool

	// Tuples
	Tpls *CT_Tuples

	// Member Property Indexes
	X []*CT_X
}
type CT_MdxMemeberProp struct {

	// Member Unique Name Index
	NAttr uint32

	// Property Name Index
	NpAttr uint32
}

// ValidateWithPath validates the QueryTable and its children, prefixing error messages with path
func (_cedcg *QueryTable) ValidateWithPath(path string) error {
	if _daaceb := _cedcg.CT_QueryTable.ValidateWithPath(path); _daaceb != nil {
		return _daaceb
	}
	return nil
}
func (_bcac *CT_Error) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dcgc := range start.Attr {
		if _dcgc.Name.Local == "fc" {
			_egee, _bggac := _dcgc.Value, error(nil)
			if _bggac != nil {
				return _bggac
			}
			_bcac.FcAttr = &_egee
			continue
		}
		if _dcgc.Name.Local == "v" {
			_degf, _dgdde := _dcgc.Value, error(nil)
			if _dgdde != nil {
				return _dgdde
			}
			_bcac.VAttr = _degf
			continue
		}
		if _dcgc.Name.Local == "f" {
			_fggd, _faeff := _g.ParseBool(_dcgc.Value)
			if _faeff != nil {
				return _faeff
			}
			_bcac.FAttr = &_fggd
			continue
		}
		if _dcgc.Name.Local == "c" {
			_eggdg, _eacd := _dcgc.Value, error(nil)
			if _eacd != nil {
				return _eacd
			}
			_bcac.CAttr = &_eggdg
			continue
		}
		if _dcgc.Name.Local == "cp" {
			_eccda, _egbdgg := _g.ParseUint(_dcgc.Value, 10, 32)
			if _egbdgg != nil {
				return _egbdgg
			}
			_fcfcf := uint32(_eccda)
			_bcac.CpAttr = &_fcfcf
			continue
		}
		if _dcgc.Name.Local == "in" {
			_afgf, _dcabd := _g.ParseUint(_dcgc.Value, 10, 32)
			if _dcabd != nil {
				return _dcabd
			}
			_bebfe := uint32(_afgf)
			_bcac.InAttr = &_bebfe
			continue
		}
		if _dcgc.Name.Local == "bc" {
			_bgcga, _fadbf := _dcgc.Value, error(nil)
			if _fadbf != nil {
				return _fadbf
			}
			_bcac.BcAttr = &_bgcga
			continue
		}
		if _dcgc.Name.Local == "u" {
			_ebca, _gfeceaa := _g.ParseBool(_dcgc.Value)
			if _gfeceaa != nil {
				return _gfeceaa
			}
			_bcac.UAttr = &_ebca
			continue
		}
		if _dcgc.Name.Local == "i" {
			_abeac, _befee := _g.ParseBool(_dcgc.Value)
			if _befee != nil {
				return _befee
			}
			_bcac.IAttr = &_abeac
			continue
		}
		if _dcgc.Name.Local == "un" {
			_ddcd, _fbbdf := _g.ParseBool(_dcgc.Value)
			if _fbbdf != nil {
				return _fbbdf
			}
			_bcac.UnAttr = &_ddcd
			continue
		}
		if _dcgc.Name.Local == "st" {
			_afcf, _bcaecf := _g.ParseBool(_dcgc.Value)
			if _bcaecf != nil {
				return _bcaecf
			}
			_bcac.StAttr = &_afcf
			continue
		}
		if _dcgc.Name.Local == "b" {
			_fbede, _dcge := _g.ParseBool(_dcgc.Value)
			if _dcge != nil {
				return _dcge
			}
			_bcac.BAttr = &_fbede
			continue
		}
	}
_cadfa:
	for {
		_dddbe, _aeceg := d.Token()
		if _aeceg != nil {
			return _aeceg
		}
		switch _ebfdf := _dddbe.(type) {
		case _f.StartElement:
			switch _ebfdf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tpls"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tpls"}:
				_bcac.Tpls = NewCT_Tuples()
				if _efgfg := d.DecodeElement(_bcac.Tpls, &_ebfdf); _efgfg != nil {
					return _efgfg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "x"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "x"}:
				_acaee := NewCT_X()
				if _bcab := d.DecodeElement(_acaee, &_ebfdf); _bcab != nil {
					return _bcab
				}
				_bcac.X = append(_bcac.X, _acaee)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Error\u0020\u0025v", _ebfdf.Name)
				if _bbee := d.Skip(); _bbee != nil {
					return _bbee
				}
			}
		case _f.EndElement:
			break _cadfa
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_RevisionComment and its children
func (_fdebd *CT_RevisionComment) Validate() error {
	return _fdebd.ValidateWithPath("CT_RevisionComment")
}
func (_cade *CT_ColHierarchiesUsage) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cade.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_cade.CountAttr)})
	}
	e.EncodeToken(start)
	_agcea := _f.StartElement{Name: _f.Name{Local: "ma:colHierarchyUsage"}}
	for _, _gcge := range _cade.ColHierarchyUsage {
		e.EncodeElement(_gcge, _agcea)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ecdcba ST_Visibility) ValidateWithPath(path string) error {
	switch _ecdcba {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ecdcba))
	}
	return nil
}

// Validate validates the CT_GradientStop and its children
func (_dcabe *CT_GradientStop) Validate() error { return _dcabe.ValidateWithPath("CT_GradientStop") }
func (_dcafba ST_ParameterType) String() string {
	switch _dcafba {
	case 0:
		return ""
	case 1:
		return "prompt"
	case 2:
		return "value"
	case 3:
		return "cell"
	}
	return ""
}

// ValidateWithPath validates the CT_TableFormula and its children, prefixing error messages with path
func (_ggaff *CT_TableFormula) ValidateWithPath(path string) error { return nil }
func (_bfb *CT_BookViews) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_caef := _f.StartElement{Name: _f.Name{Local: "ma:workbookView"}}
	for _, _faf := range _bfb.WorkbookView {
		e.EncodeElement(_faf, _caef)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_TablePart struct{ IdAttr string }

func (_gdbcg ST_CellComments) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bebbb := _f.Attr{}
	_bebbb.Name = name
	switch _gdbcg {
	case ST_CellCommentsUnset:
		_bebbb.Value = ""
	case ST_CellCommentsNone:
		_bebbb.Value = "none"
	case ST_CellCommentsAsDisplayed:
		_bebbb.Value = "asDisplayed"
	case ST_CellCommentsAtEnd:
		_bebbb.Value = "atEnd"
	}
	return _bebbb, nil
}

type CT_SheetFormatPr struct {

	// Base Column Width
	BaseColWidthAttr *uint32

	// Default Column Width
	DefaultColWidthAttr *float64

	// Default Row Height
	DefaultRowHeightAttr float64

	// Custom Height
	CustomHeightAttr *bool

	// Hidden By Default
	ZeroHeightAttr *bool

	// Thick Top Border
	ThickTopAttr *bool

	// Thick Bottom Border
	ThickBottomAttr *bool

	// Maximum Outline Row
	OutlineLevelRowAttr *uint8

	// Column Outline Level
	OutlineLevelColAttr *uint8
}

// ValidateWithPath validates the CT_GroupItems and its children, prefixing error messages with path
func (_edbaa *CT_GroupItems) ValidateWithPath(path string) error {
	for _cccfe, _dbfdc := range _edbaa.M {
		if _acgf := _dbfdc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fM\u005b\u0025d\u005d", path, _cccfe)); _acgf != nil {
			return _acgf
		}
	}
	for _ecggg, _aedba := range _edbaa.N {
		if _aefada := _aedba.ValidateWithPath(_bg.Sprintf("\u0025s\u002fN\u005b\u0025d\u005d", path, _ecggg)); _aefada != nil {
			return _aefada
		}
	}
	for _gfceba, _aeaf := range _edbaa.B {
		if _dbdb := _aeaf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fB\u005b\u0025d\u005d", path, _gfceba)); _dbdb != nil {
			return _dbdb
		}
	}
	for _efdaf, _baagc := range _edbaa.E {
		if _bgcgg := _baagc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fE\u005b\u0025d\u005d", path, _efdaf)); _bgcgg != nil {
			return _bgcgg
		}
	}
	for _ddffa, _babad := range _edbaa.S {
		if _gefgc := _babad.ValidateWithPath(_bg.Sprintf("\u0025s\u002fS\u005b\u0025d\u005d", path, _ddffa)); _gefgc != nil {
			return _gefgc
		}
	}
	for _gbcga, _ecbbe := range _edbaa.D {
		if _cdgb := _ecbbe.ValidateWithPath(_bg.Sprintf("\u0025s\u002fD\u005b\u0025d\u005d", path, _gbcga)); _cdgb != nil {
			return _cdgb
		}
	}
	return nil
}
func (_dgbbe *CT_MetadataTypes) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _egdde := range start.Attr {
		if _egdde.Name.Local == "count" {
			_cbcga, _cefgg := _g.ParseUint(_egdde.Value, 10, 32)
			if _cefgg != nil {
				return _cefgg
			}
			_beagg := uint32(_cbcga)
			_dgbbe.CountAttr = &_beagg
			continue
		}
	}
_ecdge:
	for {
		_ddcg, _fddf := d.Token()
		if _fddf != nil {
			return _fddf
		}
		switch _ccbfec := _ddcg.(type) {
		case _f.StartElement:
			switch _ccbfec.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "metadataType"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "metadataType"}:
				_abfbc := NewCT_MetadataType()
				if _fccdb := d.DecodeElement(_abfbc, &_ccbfec); _fccdb != nil {
					return _fccdb
				}
				_dgbbe.MetadataType = append(_dgbbe.MetadataType, _abfbc)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_MetadataTypes\u0020\u0025v", _ccbfec.Name)
				if _fedee := d.Skip(); _fedee != nil {
					return _fedee
				}
			}
		case _f.EndElement:
			break _ecdge
		case _f.CharData:
		}
	}
	return nil
}
func (_eebfcb ST_SortType) String() string {
	switch _eebfcb {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "ascending"
	case 3:
		return "descending"
	case 4:
		return "ascendingAlpha"
	case 5:
		return "descendingAlpha"
	case 6:
		return "ascendingNatural"
	case 7:
		return "descendingNatural"
	}
	return ""
}
func (_gaegbf *ST_VolDepType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gcdgg, _aedcce := d.Token()
	if _aedcce != nil {
		return _aedcce
	}
	if _bgfee, _fddec := _gcdgg.(_f.EndElement); _fddec && _bgfee.Name == start.Name {
		*_gaegbf = 1
		return nil
	}
	if _edffee, _gbdead := _gcdgg.(_f.CharData); !_gbdead {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gcdgg)
	} else {
		switch string(_edffee) {
		case "":
			*_gaegbf = 0
		case "realTimeData":
			*_gaegbf = 1
		case "olapFunctions":
			*_gaegbf = 2
		}
	}
	_gcdgg, _aedcce = d.Token()
	if _aedcce != nil {
		return _aedcce
	}
	if _fgfdf, _cgdfg := _gcdgg.(_f.EndElement); _cgdfg && _fgfdf.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gcdgg)
}

// Validate validates the CT_InputCells and its children
func (_abgfg *CT_InputCells) Validate() error { return _abgfg.ValidateWithPath("CT_InputCells") }
func (_dcaf *CT_ExternalSheetNames) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_abdag:
	for {
		_gfegf, _fggf := d.Token()
		if _fggf != nil {
			return _fggf
		}
		switch _bfff := _gfegf.(type) {
		case _f.StartElement:
			switch _bfff.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetName"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetName"}:
				_dfcff := NewCT_ExternalSheetName()
				if _gfcg := d.DecodeElement(_dfcff, &_bfff); _gfcg != nil {
					return _gfcg
				}
				_dcaf.SheetName = append(_dcaf.SheetName, _dfcff)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on CT_ExternalSheetNames\u0020\u0025v", _bfff.Name)
				if _deac := d.Skip(); _deac != nil {
					return _deac
				}
			}
		case _f.EndElement:
			break _abdag
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Filters and its children, prefixing error messages with path
func (_fade *CT_Filters) ValidateWithPath(path string) error {
	if _dgag := _fade.CalendarTypeAttr.ValidateWithPath(path + "\u002fCalendarTypeAttr"); _dgag != nil {
		return _dgag
	}
	for _ffbbe, _efccd := range _fade.Filter {
		if _gdedc := _efccd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fFilter\u005b\u0025d\u005d", path, _ffbbe)); _gdedc != nil {
			return _gdedc
		}
	}
	for _gfge, _febad := range _fade.DateGroupItem {
		if _aaeag := _febad.ValidateWithPath(_bg.Sprintf("%s/DateGroupItem[%d\u005d", path, _gfge)); _aaeag != nil {
			return _aaeag
		}
	}
	return nil
}
func (_bgeb *CT_Formats) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bgeb.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bgeb.CountAttr)})
	}
	e.EncodeToken(start)
	_cdgfe := _f.StartElement{Name: _f.Name{Local: "ma:format"}}
	for _, _bbadf := range _bgeb.Format {
		e.EncodeElement(_bbadf, _cdgfe)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Error and its children
func (_debb *CT_Error) Validate() error { return _debb.ValidateWithPath("CT_Error") }
func (_adbed *ST_PhoneticAlignment) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_afddd, _efdcge := d.Token()
	if _efdcge != nil {
		return _efdcge
	}
	if _aacddc, _gbddfbf := _afddd.(_f.EndElement); _gbddfbf && _aacddc.Name == start.Name {
		*_adbed = 1
		return nil
	}
	if _gecdc, _dbgda := _afddd.(_f.CharData); !_dbgda {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _afddd)
	} else {
		switch string(_gecdc) {
		case "":
			*_adbed = 0
		case "noControl":
			*_adbed = 1
		case "left":
			*_adbed = 2
		case "center":
			*_adbed = 3
		case "distributed":
			*_adbed = 4
		}
	}
	_afddd, _efdcge = d.Token()
	if _efdcge != nil {
		return _efdcge
	}
	if _faaagce, _agegb := _afddd.(_f.EndElement); _agegb && _faaagce.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _afddd)
}

// ValidateWithPath validates the CT_ConditionalFormatting and its children, prefixing error messages with path
func (_defd *CT_ConditionalFormatting) ValidateWithPath(path string) error {
	for _faef, _dabfg := range _defd.CfRule {
		if _bfaf := _dabfg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCfRule\u005b\u0025d\u005d", path, _faef)); _bfaf != nil {
			return _bfaf
		}
	}
	if _defd.ExtLst != nil {
		if _bafc := _defd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bafc != nil {
			return _bafc
		}
	}
	return nil
}

// Validate validates the CT_Number and its children
func (_ffcefe *CT_Number) Validate() error { return _ffcefe.ValidateWithPath("CT_Number") }

// ValidateWithPath validates the CT_Groups and its children, prefixing error messages with path
func (_acgba *CT_Groups) ValidateWithPath(path string) error {
	for _daef, _fgdd := range _acgba.Group {
		if _bdbd := _fgdd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fGroup\u005b\u0025d\u005d", path, _daef)); _bdbd != nil {
			return _bdbd
		}
	}
	return nil
}

type CT_PatternFill struct {

	// Pattern Type
	PatternTypeAttr ST_PatternType

	// Foreground Color
	FgColor *CT_Color

	// Background Color
	BgColor *CT_Color
}

func (_ecdfcd ST_PhoneticAlignment) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_ebgfc := _f.Attr{}
	_ebgfc.Name = name
	switch _ecdfcd {
	case ST_PhoneticAlignmentUnset:
		_ebgfc.Value = ""
	case ST_PhoneticAlignmentNoControl:
		_ebgfc.Value = "noControl"
	case ST_PhoneticAlignmentLeft:
		_ebgfc.Value = "left"
	case ST_PhoneticAlignmentCenter:
		_ebgfc.Value = "center"
	case ST_PhoneticAlignmentDistributed:
		_ebgfc.Value = "distributed"
	}
	return _ebgfc, nil
}
func (_bfcdce ST_SortMethod) String() string {
	switch _bfcdce {
	case 0:
		return ""
	case 1:
		return "stroke"
	case 2:
		return "pinYin"
	case 3:
		return "none"
	}
	return ""
}
func NewCT_Workbook() *CT_Workbook {
	_ggefb := &CT_Workbook{}
	_ggefb.Sheets = NewCT_Sheets()
	return _ggefb
}
func (_gbae *CT_FileVersion) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gbae.AppNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "appName"}, Value: _bg.Sprintf("\u0025v", *_gbae.AppNameAttr)})
	}
	if _gbae.LastEditedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lastEdited"}, Value: _bg.Sprintf("\u0025v", *_gbae.LastEditedAttr)})
	}
	if _gbae.LowestEditedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lowestEdited"}, Value: _bg.Sprintf("\u0025v", *_gbae.LowestEditedAttr)})
	}
	if _gbae.RupBuildAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rupBuild"}, Value: _bg.Sprintf("\u0025v", *_gbae.RupBuildAttr)})
	}
	if _gbae.CodeNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "codeName"}, Value: _bg.Sprintf("\u0025v", *_gbae.CodeNameAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ecabf *CT_WebPublishItem) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ecabf.SourceTypeAttr = ST_WebSourceType(1)
	for _, _bfffc := range start.Attr {
		if _bfffc.Name.Local == "id" {
			_eebga, _dacag := _g.ParseUint(_bfffc.Value, 10, 32)
			if _dacag != nil {
				return _dacag
			}
			_ecabf.IdAttr = uint32(_eebga)
			continue
		}
		if _bfffc.Name.Local == "divId" {
			_gcbfed, _adbbe := _bfffc.Value, error(nil)
			if _adbbe != nil {
				return _adbbe
			}
			_ecabf.DivIdAttr = _gcbfed
			continue
		}
		if _bfffc.Name.Local == "sourceType" {
			_ecabf.SourceTypeAttr.UnmarshalXMLAttr(_bfffc)
			continue
		}
		if _bfffc.Name.Local == "sourceRef" {
			_bgddb, _fcfgc := _bfffc.Value, error(nil)
			if _fcfgc != nil {
				return _fcfgc
			}
			_ecabf.SourceRefAttr = &_bgddb
			continue
		}
		if _bfffc.Name.Local == "sourceObject" {
			_cfedf, _faefda := _bfffc.Value, error(nil)
			if _faefda != nil {
				return _faefda
			}
			_ecabf.SourceObjectAttr = &_cfedf
			continue
		}
		if _bfffc.Name.Local == "destinationFile" {
			_ggdcdf, _aaebb := _bfffc.Value, error(nil)
			if _aaebb != nil {
				return _aaebb
			}
			_ecabf.DestinationFileAttr = _ggdcdf
			continue
		}
		if _bfffc.Name.Local == "title" {
			_bfbad, _ecddg := _bfffc.Value, error(nil)
			if _ecddg != nil {
				return _ecddg
			}
			_ecabf.TitleAttr = &_bfbad
			continue
		}
		if _bfffc.Name.Local == "autoRepublish" {
			_ffgbf, _ddacga := _g.ParseBool(_bfffc.Value)
			if _ddacga != nil {
				return _ddacga
			}
			_ecabf.AutoRepublishAttr = &_ffgbf
			continue
		}
	}
	for {
		_egbdc, _adgbgg := d.Token()
		if _adgbgg != nil {
			return _bg.Errorf("parsing\u0020CT_WebPublishItem: \u0025s", _adgbgg)
		}
		if _ebafb, _eebgab := _egbdc.(_f.EndElement); _eebgab && _ebafb.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PivotHierarchy and its children, prefixing error messages with path
func (_bagebe *CT_PivotHierarchy) ValidateWithPath(path string) error {
	if _bagebe.Mps != nil {
		if _dgced := _bagebe.Mps.ValidateWithPath(path + "\u002fMps"); _dgced != nil {
			return _dgced
		}
	}
	for _geecf, _cfgcdc := range _bagebe.Members {
		if _dacfd := _cfgcdc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fMembers\u005b\u0025d\u005d", path, _geecf)); _dacfd != nil {
			return _dacfd
		}
	}
	if _bagebe.ExtLst != nil {
		if _fdfade := _bagebe.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fdfade != nil {
			return _fdfade
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Comment and its children, prefixing error messages with path
func (_dafg *CT_Comment) ValidateWithPath(path string) error {
	if _dafg.GuidAttr != nil {
		if !_e.ST_GuidPatternRe.MatchString(*_dafg.GuidAttr) {
			return _bg.Errorf("\u0025s\u002fm\u002eGuidAttr must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_GuidPatternRe, *_dafg.GuidAttr)
		}
	}
	if _cdaf := _dafg.Text.ValidateWithPath(path + "\u002fText"); _cdaf != nil {
		return _cdaf
	}
	if _dafg.CommentPr != nil {
		if _dfcf := _dafg.CommentPr.ValidateWithPath(path + "\u002fCommentPr"); _dfcf != nil {
			return _dfcf
		}
	}
	return nil
}
func (_fagcg *CT_PivotHierarchies) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fagcg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_fagcg.CountAttr)})
	}
	e.EncodeToken(start)
	_cefeef := _f.StartElement{Name: _f.Name{Local: "ma:pivotHierarchy"}}
	for _, _bgcfe := range _fagcg.PivotHierarchy {
		e.EncodeElement(_bgcfe, _cefeef)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_afbb *CT_Missing) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _afbb.UAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "u"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afbb.UAttr))})
	}
	if _afbb.FAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "f"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afbb.FAttr))})
	}
	if _afbb.CAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "c"}, Value: _bg.Sprintf("\u0025v", *_afbb.CAttr)})
	}
	if _afbb.CpAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cp"}, Value: _bg.Sprintf("\u0025v", *_afbb.CpAttr)})
	}
	if _afbb.InAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "in"}, Value: _bg.Sprintf("\u0025v", *_afbb.InAttr)})
	}
	if _afbb.BcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "bc"}, Value: _bg.Sprintf("\u0025v", *_afbb.BcAttr)})
	}
	if _afbb.FcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fc"}, Value: _bg.Sprintf("\u0025v", *_afbb.FcAttr)})
	}
	if _afbb.IAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "i"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afbb.IAttr))})
	}
	if _afbb.UnAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "un"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afbb.UnAttr))})
	}
	if _afbb.StAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "st"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afbb.StAttr))})
	}
	if _afbb.BAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "b"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afbb.BAttr))})
	}
	e.EncodeToken(start)
	if _afbb.Tpls != nil {
		_gabfbd := _f.StartElement{Name: _f.Name{Local: "ma:tpls"}}
		for _, _afabb := range _afbb.Tpls {
			e.EncodeElement(_afabb, _gabfbd)
		}
	}
	if _afbb.X != nil {
		_ecddd := _f.StartElement{Name: _f.Name{Local: "ma:x"}}
		for _, _agaf := range _afbb.X {
			e.EncodeElement(_agaf, _ecddd)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dgbdg *CT_Tuple) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dgbdg.FldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fld"}, Value: _bg.Sprintf("\u0025v", *_dgbdg.FldAttr)})
	}
	if _dgbdg.HierAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hier"}, Value: _bg.Sprintf("\u0025v", *_dgbdg.HierAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "item"}, Value: _bg.Sprintf("\u0025v", _dgbdg.ItemAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_aebgc *CT_TableColumn) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abcgf := range start.Attr {
		if _abcgf.Name.Local == "totalsRowDxfId" {
			_fedcd, _dgbaba := _g.ParseUint(_abcgf.Value, 10, 32)
			if _dgbaba != nil {
				return _dgbaba
			}
			_gaebe := uint32(_fedcd)
			_aebgc.TotalsRowDxfIdAttr = &_gaebe
			continue
		}
		if _abcgf.Name.Local == "id" {
			_fbdba, _geggf := _g.ParseUint(_abcgf.Value, 10, 32)
			if _geggf != nil {
				return _geggf
			}
			_aebgc.IdAttr = uint32(_fbdba)
			continue
		}
		if _abcgf.Name.Local == "headerRowCellStyle" {
			_egbgc, _gdafa := _abcgf.Value, error(nil)
			if _gdafa != nil {
				return _gdafa
			}
			_aebgc.HeaderRowCellStyleAttr = &_egbgc
			continue
		}
		if _abcgf.Name.Local == "name" {
			_gfgbcb, _eacgc := _abcgf.Value, error(nil)
			if _eacgc != nil {
				return _eacgc
			}
			_aebgc.NameAttr = _gfgbcb
			continue
		}
		if _abcgf.Name.Local == "totalsRowLabel" {
			_baadbe, _becbg := _abcgf.Value, error(nil)
			if _becbg != nil {
				return _becbg
			}
			_aebgc.TotalsRowLabelAttr = &_baadbe
			continue
		}
		if _abcgf.Name.Local == "queryTableFieldId" {
			_eggee, _cecfb := _g.ParseUint(_abcgf.Value, 10, 32)
			if _cecfb != nil {
				return _cecfb
			}
			_gedaeb := uint32(_eggee)
			_aebgc.QueryTableFieldIdAttr = &_gedaeb
			continue
		}
		if _abcgf.Name.Local == "headerRowDxfId" {
			_gbdcb, _bgbgf := _g.ParseUint(_abcgf.Value, 10, 32)
			if _bgbgf != nil {
				return _bgbgf
			}
			_dacddf := uint32(_gbdcb)
			_aebgc.HeaderRowDxfIdAttr = &_dacddf
			continue
		}
		if _abcgf.Name.Local == "dataDxfId" {
			_daabf, _bbfeec := _g.ParseUint(_abcgf.Value, 10, 32)
			if _bbfeec != nil {
				return _bbfeec
			}
			_feaeg := uint32(_daabf)
			_aebgc.DataDxfIdAttr = &_feaeg
			continue
		}
		if _abcgf.Name.Local == "uniqueName" {
			_bfabe, _ffebd := _abcgf.Value, error(nil)
			if _ffebd != nil {
				return _ffebd
			}
			_aebgc.UniqueNameAttr = &_bfabe
			continue
		}
		if _abcgf.Name.Local == "totalsRowFunction" {
			_aebgc.TotalsRowFunctionAttr.UnmarshalXMLAttr(_abcgf)
			continue
		}
		if _abcgf.Name.Local == "dataCellStyle" {
			_bfdad, _cdcge := _abcgf.Value, error(nil)
			if _cdcge != nil {
				return _cdcge
			}
			_aebgc.DataCellStyleAttr = &_bfdad
			continue
		}
		if _abcgf.Name.Local == "totalsRowCellStyle" {
			_bdece, _eebgd := _abcgf.Value, error(nil)
			if _eebgd != nil {
				return _eebgd
			}
			_aebgc.TotalsRowCellStyleAttr = &_bdece
			continue
		}
	}
_bcbeg:
	for {
		_edbcf, _dcacf := d.Token()
		if _dcacf != nil {
			return _dcacf
		}
		switch _fagbae := _edbcf.(type) {
		case _f.StartElement:
			switch _fagbae.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "calculatedColumnFormula"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "calculatedColumnFormula"}:
				_aebgc.CalculatedColumnFormula = NewCT_TableFormula()
				if _dceede := d.DecodeElement(_aebgc.CalculatedColumnFormula, &_fagbae); _dceede != nil {
					return _dceede
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "totalsRowFormula"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "totalsRowFormula"}:
				_aebgc.TotalsRowFormula = NewCT_TableFormula()
				if _dgafd := d.DecodeElement(_aebgc.TotalsRowFormula, &_fagbae); _dgafd != nil {
					return _dgafd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "xmlColumnPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "xmlColumnPr"}:
				_aebgc.XmlColumnPr = NewCT_XmlColumnPr()
				if _cgfgd := d.DecodeElement(_aebgc.XmlColumnPr, &_fagbae); _cgfgd != nil {
					return _cgfgd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_aebgc.ExtLst = NewCT_ExtensionList()
				if _bbacd := d.DecodeElement(_aebgc.ExtLst, &_fagbae); _bbacd != nil {
					return _bbacd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TableColumn\u0020\u0025v", _fagbae.Name)
				if _gdadcb := d.Skip(); _gdadcb != nil {
					return _gdadcb
				}
			}
		case _f.EndElement:
			break _bcbeg
		case _f.CharData:
		}
	}
	return nil
}
func (_dacdgd *CT_SheetView) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fafea := range start.Attr {
		if _fafea.Name.Local == "view" {
			_dacdgd.ViewAttr.UnmarshalXMLAttr(_fafea)
			continue
		}
		if _fafea.Name.Local == "topLeftCell" {
			_fcbcgc, _gagdc := _fafea.Value, error(nil)
			if _gagdc != nil {
				return _gagdc
			}
			_dacdgd.TopLeftCellAttr = &_fcbcgc
			continue
		}
		if _fafea.Name.Local == "showFormulas" {
			_faafb, _fdbaad := _g.ParseBool(_fafea.Value)
			if _fdbaad != nil {
				return _fdbaad
			}
			_dacdgd.ShowFormulasAttr = &_faafb
			continue
		}
		if _fafea.Name.Local == "colorId" {
			_adafcb, _fgccd := _g.ParseUint(_fafea.Value, 10, 32)
			if _fgccd != nil {
				return _fgccd
			}
			_gcecb := uint32(_adafcb)
			_dacdgd.ColorIdAttr = &_gcecb
			continue
		}
		if _fafea.Name.Local == "showRowColHeaders" {
			_cagcfa, _dbgcdf := _g.ParseBool(_fafea.Value)
			if _dbgcdf != nil {
				return _dbgcdf
			}
			_dacdgd.ShowRowColHeadersAttr = &_cagcfa
			continue
		}
		if _fafea.Name.Local == "zoomScale" {
			_acbedf, _bded := _g.ParseUint(_fafea.Value, 10, 32)
			if _bded != nil {
				return _bded
			}
			_daeffg := uint32(_acbedf)
			_dacdgd.ZoomScaleAttr = &_daeffg
			continue
		}
		if _fafea.Name.Local == "rightToLeft" {
			_cbfcda, _eeacb := _g.ParseBool(_fafea.Value)
			if _eeacb != nil {
				return _eeacb
			}
			_dacdgd.RightToLeftAttr = &_cbfcda
			continue
		}
		if _fafea.Name.Local == "zoomScaleNormal" {
			_aefab, _aedgfa := _g.ParseUint(_fafea.Value, 10, 32)
			if _aedgfa != nil {
				return _aedgfa
			}
			_cccgd := uint32(_aefab)
			_dacdgd.ZoomScaleNormalAttr = &_cccgd
			continue
		}
		if _fafea.Name.Local == "showRuler" {
			_bdedb, _cgbag := _g.ParseBool(_fafea.Value)
			if _cgbag != nil {
				return _cgbag
			}
			_dacdgd.ShowRulerAttr = &_bdedb
			continue
		}
		if _fafea.Name.Local == "zoomScaleSheetLayoutView" {
			_cfced, _adgfc := _g.ParseUint(_fafea.Value, 10, 32)
			if _adgfc != nil {
				return _adgfc
			}
			_ddegff := uint32(_cfced)
			_dacdgd.ZoomScaleSheetLayoutViewAttr = &_ddegff
			continue
		}
		if _fafea.Name.Local == "workbookViewId" {
			_bcedg, _fbaac := _g.ParseUint(_fafea.Value, 10, 32)
			if _fbaac != nil {
				return _fbaac
			}
			_dacdgd.WorkbookViewIdAttr = uint32(_bcedg)
			continue
		}
		if _fafea.Name.Local == "tabSelected" {
			_edbfc, _eaecgb := _g.ParseBool(_fafea.Value)
			if _eaecgb != nil {
				return _eaecgb
			}
			_dacdgd.TabSelectedAttr = &_edbfc
			continue
		}
		if _fafea.Name.Local == "zoomScalePageLayoutView" {
			_abfge, _ccggg := _g.ParseUint(_fafea.Value, 10, 32)
			if _ccggg != nil {
				return _ccggg
			}
			_ccbfg := uint32(_abfge)
			_dacdgd.ZoomScalePageLayoutViewAttr = &_ccbfg
			continue
		}
		if _fafea.Name.Local == "showZeros" {
			_fadea, _cgabb := _g.ParseBool(_fafea.Value)
			if _cgabb != nil {
				return _cgabb
			}
			_dacdgd.ShowZerosAttr = &_fadea
			continue
		}
		if _fafea.Name.Local == "windowProtection" {
			_afggaa, _ddeab := _g.ParseBool(_fafea.Value)
			if _ddeab != nil {
				return _ddeab
			}
			_dacdgd.WindowProtectionAttr = &_afggaa
			continue
		}
		if _fafea.Name.Local == "showOutlineSymbols" {
			_eefgg, _bcbfacb := _g.ParseBool(_fafea.Value)
			if _bcbfacb != nil {
				return _bcbfacb
			}
			_dacdgd.ShowOutlineSymbolsAttr = &_eefgg
			continue
		}
		if _fafea.Name.Local == "showWhiteSpace" {
			_gfbda, _adeae := _g.ParseBool(_fafea.Value)
			if _adeae != nil {
				return _adeae
			}
			_dacdgd.ShowWhiteSpaceAttr = &_gfbda
			continue
		}
		if _fafea.Name.Local == "showGridLines" {
			_agfeee, _agadf := _g.ParseBool(_fafea.Value)
			if _agadf != nil {
				return _agadf
			}
			_dacdgd.ShowGridLinesAttr = &_agfeee
			continue
		}
		if _fafea.Name.Local == "defaultGridColor" {
			_eeefg, _feafeb := _g.ParseBool(_fafea.Value)
			if _feafeb != nil {
				return _feafeb
			}
			_dacdgd.DefaultGridColorAttr = &_eeefg
			continue
		}
	}
_affbd:
	for {
		_gcadbf, _edddd := d.Token()
		if _edddd != nil {
			return _edddd
		}
		switch _eged := _gcadbf.(type) {
		case _f.StartElement:
			switch _eged.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pane"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pane"}:
				_dacdgd.Pane = NewCT_Pane()
				if _gecde := d.DecodeElement(_dacdgd.Pane, &_eged); _gecde != nil {
					return _gecde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "selection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "selection"}:
				_aeeef := NewCT_Selection()
				if _gcabbf := d.DecodeElement(_aeeef, &_eged); _gcabbf != nil {
					return _gcabbf
				}
				_dacdgd.Selection = append(_dacdgd.Selection, _aeeef)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotSelection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotSelection"}:
				_dgecd := NewCT_PivotSelection()
				if _bcdcd := d.DecodeElement(_dgecd, &_eged); _bcdcd != nil {
					return _bcdcd
				}
				_dacdgd.PivotSelection = append(_dacdgd.PivotSelection, _dgecd)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_dacdgd.ExtLst = NewCT_ExtensionList()
				if _fdeacg := d.DecodeElement(_dacdgd.ExtLst, &_eged); _fdeacg != nil {
					return _fdeacg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SheetView\u0020\u0025v", _eged.Name)
				if _abdgba := d.Skip(); _abdgba != nil {
					return _abdgba
				}
			}
		case _f.EndElement:
			break _affbd
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_DataBinding() *CT_DataBinding { _gfcdf := &CT_DataBinding{}; return _gfcdf }
func (_bagda ST_DataValidationOperator) ValidateWithPath(path string) error {
	switch _bagda {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bagda))
	}
	return nil
}

// Validate validates the CT_ServerFormats and its children
func (_bafab *CT_ServerFormats) Validate() error { return _bafab.ValidateWithPath("CT_ServerFormats") }
func (_ccdcb *CT_Items) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cfgbdc := range start.Attr {
		if _cfgbdc.Name.Local == "count" {
			_cgae, _cdedb := _g.ParseUint(_cfgbdc.Value, 10, 32)
			if _cdedb != nil {
				return _cdedb
			}
			_gecec := uint32(_cgae)
			_ccdcb.CountAttr = &_gecec
			continue
		}
	}
_badda:
	for {
		_fcbf, _cfecc := d.Token()
		if _cfecc != nil {
			return _cfecc
		}
		switch _cdcfa := _fcbf.(type) {
		case _f.StartElement:
			switch _cdcfa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "item"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "item"}:
				_afgcf := NewCT_Item()
				if _aeeea := d.DecodeElement(_afgcf, &_cdcfa); _aeeea != nil {
					return _aeeea
				}
				_ccdcb.Item = append(_ccdcb.Item, _afgcf)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Items\u0020\u0025v", _cdcfa.Name)
				if _ebff := d.Skip(); _ebff != nil {
					return _ebff
				}
			}
		case _f.EndElement:
			break _badda
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_ConditionalFormat() *CT_ConditionalFormat {
	_gffg := &CT_ConditionalFormat{}
	_gffg.PivotAreas = NewCT_PivotAreas()
	return _gffg
}
func (_ggdeg *CT_GroupMember) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueName"}, Value: _bg.Sprintf("\u0025v", _ggdeg.UniqueNameAttr)})
	if _ggdeg.GroupAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "group"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ggdeg.GroupAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_aggdf *CT_MetadataType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ecaba := range start.Attr {
		if _ecaba.Name.Local == "pasteColWidths" {
			_aecbe, _acdfd := _g.ParseBool(_ecaba.Value)
			if _acdfd != nil {
				return _acdfd
			}
			_aggdf.PasteColWidthsAttr = &_aecbe
			continue
		}
		if _ecaba.Name.Local == "name" {
			_afggg, _gbcae := _ecaba.Value, error(nil)
			if _gbcae != nil {
				return _gbcae
			}
			_aggdf.NameAttr = _afggg
			continue
		}
		if _ecaba.Name.Local == "pasteNumberFormats" {
			_aeeeg, _ecdc := _g.ParseBool(_ecaba.Value)
			if _ecdc != nil {
				return _ecdc
			}
			_aggdf.PasteNumberFormatsAttr = &_aeeeg
			continue
		}
		if _ecaba.Name.Local == "ghostRow" {
			_daecd, _gbbdda := _g.ParseBool(_ecaba.Value)
			if _gbbdda != nil {
				return _gbbdda
			}
			_aggdf.GhostRowAttr = &_daecd
			continue
		}
		if _ecaba.Name.Local == "merge" {
			_gdadc, _ebagg := _g.ParseBool(_ecaba.Value)
			if _ebagg != nil {
				return _ebagg
			}
			_aggdf.MergeAttr = &_gdadc
			continue
		}
		if _ecaba.Name.Local == "edit" {
			_dbcgb, _dacee := _g.ParseBool(_ecaba.Value)
			if _dacee != nil {
				return _dacee
			}
			_aggdf.EditAttr = &_dbcgb
			continue
		}
		if _ecaba.Name.Local == "splitFirst" {
			_bagdb, _cdcd := _g.ParseBool(_ecaba.Value)
			if _cdcd != nil {
				return _cdcd
			}
			_aggdf.SplitFirstAttr = &_bagdb
			continue
		}
		if _ecaba.Name.Local == "copy" {
			_cdcefd, _fbga := _g.ParseBool(_ecaba.Value)
			if _fbga != nil {
				return _fbga
			}
			_aggdf.CopyAttr = &_cdcefd
			continue
		}
		if _ecaba.Name.Local == "splitAll" {
			_feeae, _egefg := _g.ParseBool(_ecaba.Value)
			if _egefg != nil {
				return _egefg
			}
			_aggdf.SplitAllAttr = &_feeae
			continue
		}
		if _ecaba.Name.Local == "pasteFormulas" {
			_befa, _fbdaf := _g.ParseBool(_ecaba.Value)
			if _fbdaf != nil {
				return _fbdaf
			}
			_aggdf.PasteFormulasAttr = &_befa
			continue
		}
		if _ecaba.Name.Local == "cellMeta" {
			_deegaf, _gebeed := _g.ParseBool(_ecaba.Value)
			if _gebeed != nil {
				return _gebeed
			}
			_aggdf.CellMetaAttr = &_deegaf
			continue
		}
		if _ecaba.Name.Local == "clearAll" {
			_aefgg, _ddaeae := _g.ParseBool(_ecaba.Value)
			if _ddaeae != nil {
				return _ddaeae
			}
			_aggdf.ClearAllAttr = &_aefgg
			continue
		}
		if _ecaba.Name.Local == "minSupportedVersion" {
			_faebfg, _aagbga := _g.ParseUint(_ecaba.Value, 10, 32)
			if _aagbga != nil {
				return _aagbga
			}
			_aggdf.MinSupportedVersionAttr = uint32(_faebfg)
			continue
		}
		if _ecaba.Name.Local == "adjust" {
			_ebcbg, _fdfge := _g.ParseBool(_ecaba.Value)
			if _fdfge != nil {
				return _fdfge
			}
			_aggdf.AdjustAttr = &_ebcbg
			continue
		}
		if _ecaba.Name.Local == "clearContents" {
			_eaagb, _gdfff := _g.ParseBool(_ecaba.Value)
			if _gdfff != nil {
				return _gdfff
			}
			_aggdf.ClearContentsAttr = &_eaagb
			continue
		}
		if _ecaba.Name.Local == "pasteValues" {
			_ebgg, _bffce := _g.ParseBool(_ecaba.Value)
			if _bffce != nil {
				return _bffce
			}
			_aggdf.PasteValuesAttr = &_ebgg
			continue
		}
		if _ecaba.Name.Local == "rowColShift" {
			_ecba, _bdfb := _g.ParseBool(_ecaba.Value)
			if _bdfb != nil {
				return _bdfb
			}
			_aggdf.RowColShiftAttr = &_ecba
			continue
		}
		if _ecaba.Name.Local == "pasteComments" {
			_efbbf, _agad := _g.ParseBool(_ecaba.Value)
			if _agad != nil {
				return _agad
			}
			_aggdf.PasteCommentsAttr = &_efbbf
			continue
		}
		if _ecaba.Name.Local == "clearFormats" {
			_edfdd, _fgcae := _g.ParseBool(_ecaba.Value)
			if _fgcae != nil {
				return _fgcae
			}
			_aggdf.ClearFormatsAttr = &_edfdd
			continue
		}
		if _ecaba.Name.Local == "ghostCol" {
			_egecf, _dcdgff := _g.ParseBool(_ecaba.Value)
			if _dcdgff != nil {
				return _dcdgff
			}
			_aggdf.GhostColAttr = &_egecf
			continue
		}
		if _ecaba.Name.Local == "coerce" {
			_dabef, _gddga := _g.ParseBool(_ecaba.Value)
			if _gddga != nil {
				return _gddga
			}
			_aggdf.CoerceAttr = &_dabef
			continue
		}
		if _ecaba.Name.Local == "clearComments" {
			_gbacda, _acfca := _g.ParseBool(_ecaba.Value)
			if _acfca != nil {
				return _acfca
			}
			_aggdf.ClearCommentsAttr = &_gbacda
			continue
		}
		if _ecaba.Name.Local == "pasteAll" {
			_bcecd, _cecee := _g.ParseBool(_ecaba.Value)
			if _cecee != nil {
				return _cecee
			}
			_aggdf.PasteAllAttr = &_bcecd
			continue
		}
		if _ecaba.Name.Local == "pasteBorders" {
			_edfgc, _abceege := _g.ParseBool(_ecaba.Value)
			if _abceege != nil {
				return _abceege
			}
			_aggdf.PasteBordersAttr = &_edfgc
			continue
		}
		if _ecaba.Name.Local == "pasteFormats" {
			_aegdc, _aecda := _g.ParseBool(_ecaba.Value)
			if _aecda != nil {
				return _aecda
			}
			_aggdf.PasteFormatsAttr = &_aegdc
			continue
		}
		if _ecaba.Name.Local == "pasteDataValidation" {
			_bdgae, _gacef := _g.ParseBool(_ecaba.Value)
			if _gacef != nil {
				return _gacef
			}
			_aggdf.PasteDataValidationAttr = &_bdgae
			continue
		}
		if _ecaba.Name.Local == "delete" {
			_feeadg, _feeeb := _g.ParseBool(_ecaba.Value)
			if _feeeb != nil {
				return _feeeb
			}
			_aggdf.DeleteAttr = &_feeadg
			continue
		}
		if _ecaba.Name.Local == "assign" {
			_fbefg, _bcgcd := _g.ParseBool(_ecaba.Value)
			if _bcgcd != nil {
				return _bcgcd
			}
			_aggdf.AssignAttr = &_fbefg
			continue
		}
	}
	for {
		_bbcbe, _egace := d.Token()
		if _egace != nil {
			return _bg.Errorf("parsing CT_MetadataType:\u0020\u0025s", _egace)
		}
		if _cgeea, _baade := _bbcbe.(_f.EndElement); _baade && _cgeea.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cegaf *CT_PCDKPI) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueName"}, Value: _bg.Sprintf("\u0025v", _cegaf.UniqueNameAttr)})
	if _cegaf.CaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "caption"}, Value: _bg.Sprintf("\u0025v", *_cegaf.CaptionAttr)})
	}
	if _cegaf.DisplayFolderAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "displayFolder"}, Value: _bg.Sprintf("\u0025v", *_cegaf.DisplayFolderAttr)})
	}
	if _cegaf.MeasureGroupAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "measureGroup"}, Value: _bg.Sprintf("\u0025v", *_cegaf.MeasureGroupAttr)})
	}
	if _cegaf.ParentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "parent"}, Value: _bg.Sprintf("\u0025v", *_cegaf.ParentAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "value"}, Value: _bg.Sprintf("\u0025v", _cegaf.ValueAttr)})
	if _cegaf.GoalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "goal"}, Value: _bg.Sprintf("\u0025v", *_cegaf.GoalAttr)})
	}
	if _cegaf.StatusAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "status"}, Value: _bg.Sprintf("\u0025v", *_cegaf.StatusAttr)})
	}
	if _cegaf.TrendAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "trend"}, Value: _bg.Sprintf("\u0025v", *_cegaf.TrendAttr)})
	}
	if _cegaf.WeightAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "weight"}, Value: _bg.Sprintf("\u0025v", *_cegaf.WeightAttr)})
	}
	if _cegaf.TimeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "time"}, Value: _bg.Sprintf("\u0025v", *_cegaf.TimeAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_AutoFilter struct {

	// Cell or Range Reference
	RefAttr *string

	// AutoFilter Column
	FilterColumn []*CT_FilterColumn

	// Sort State for Auto Filter
	SortState *CT_SortState
	ExtLst    *CT_ExtensionList
}

const (
	ST_MdxSetOrderUnset ST_MdxSetOrder = 0
	ST_MdxSetOrderU     ST_MdxSetOrder = 1
	ST_MdxSetOrderA     ST_MdxSetOrder = 2
	ST_MdxSetOrderD     ST_MdxSetOrder = 3
	ST_MdxSetOrderAa    ST_MdxSetOrder = 4
	ST_MdxSetOrderAd    ST_MdxSetOrder = 5
	ST_MdxSetOrderNa    ST_MdxSetOrder = 6
	ST_MdxSetOrderNd    ST_MdxSetOrder = 7
)

// Validate validates the CT_CacheHierarchy and its children
func (_fcgd *CT_CacheHierarchy) Validate() error { return _fcgd.ValidateWithPath("CT_CacheHierarchy") }
func (_bdcdf *CT_RgbColor) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bdcdf.RgbAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rgb"}, Value: _bg.Sprintf("\u0025v", *_bdcdf.RgbAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_PivotCache and its children
func (_edccb *CT_PivotCache) Validate() error { return _edccb.ValidateWithPath("CT_PivotCache") }
func NewCT_Authors() *CT_Authors              { _agf := &CT_Authors{}; return _agf }

type CT_Number struct {

	// Value
	VAttr float64

	// Unused Item
	UAttr *bool

	// Calculated Item
	FAttr *bool

	// Caption
	CAttr *string

	// Member Property Count
	CpAttr *uint32

	// Format Index
	InAttr *uint32

	// Background Color
	BcAttr *string

	// Foreground Color
	FcAttr *string

	// Italic
	IAttr *bool

	// Underline
	UnAttr *bool

	// Strikethrough
	StAttr *bool

	// Bold
	BAttr *bool

	// OLAP Members
	Tpls []*CT_Tuples

	// Member Property Index
	X []*CT_X
}

func NewCT_UnderlineProperty() *CT_UnderlineProperty {
	_facfeg := &CT_UnderlineProperty{}
	return _facfeg
}
func (_gcafe ST_DdeValueType) Validate() error { return _gcafe.ValidateWithPath("") }

// ValidateWithPath validates the CT_DataRef and its children, prefixing error messages with path
func (_aeebb *CT_DataRef) ValidateWithPath(path string) error { return nil }

type CT_PivotHierarchies struct {

	// OLAP Hierarchy Count
	CountAttr *uint32

	// OLAP Hierarchy
	PivotHierarchy []*CT_PivotHierarchy
}
type CT_PivotAreaReference struct {

	// Field Index
	FieldAttr *uint32

	// Item Index Count
	CountAttr *uint32

	// Selected
	SelectedAttr *bool

	// Positional Reference
	ByPositionAttr *bool

	// Relative Reference
	RelativeAttr *bool

	// Include Default Filter
	DefaultSubtotalAttr *bool

	// Include Sum Filter
	SumSubtotalAttr *bool

	// Include CountA Filter
	CountASubtotalAttr *bool

	// Include Average Filter
	AvgSubtotalAttr *bool

	// Include Maximum Filter
	MaxSubtotalAttr *bool

	// Include Minimum Filter
	MinSubtotalAttr *bool

	// Include Product Filter
	ProductSubtotalAttr *bool

	// Include Count Subtotal
	CountSubtotalAttr *bool

	// Include StdDev Filter
	StdDevSubtotalAttr *bool

	// Include StdDevP Filter
	StdDevPSubtotalAttr *bool

	// Include Var Filter
	VarSubtotalAttr *bool

	// Include VarP Filter
	VarPSubtotalAttr *bool

	// Field Item
	X      []*CT_Index
	ExtLst *CT_ExtensionList
}

func (_cdeacc ST_PivotAreaType) ValidateWithPath(path string) error {
	switch _cdeacc {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cdeacc))
	}
	return nil
}

type CT_ExternalCell struct {

	// Reference
	RAttr *string

	// Type
	TAttr ST_CellType

	// Value Metadata
	VmAttr *uint32

	// Value
	V *string
}

func NewCT_RevisionCustomView() *CT_RevisionCustomView {
	_gbfba := &CT_RevisionCustomView{}
	_gbfba.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	_gbfba.ActionAttr = ST_RevisionAction(1)
	return _gbfba
}

type CT_RevisionSheetRename struct {

	// Sheet Id
	SheetIdAttr uint32

	// Old Sheet Name
	OldNameAttr string

	// New Sheet Name
	NewNameAttr string
	ExtLst      *CT_ExtensionList
	RIdAttr     *uint32
	UaAttr      *bool
	RaAttr      *bool
}
type ST_MdxKPIProperty byte

func (_gggeg *CT_ConditionalFormat) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gggeg.PivotAreas = NewCT_PivotAreas()
	for _, _eaadd := range start.Attr {
		if _eaadd.Name.Local == "scope" {
			_gggeg.ScopeAttr.UnmarshalXMLAttr(_eaadd)
			continue
		}
		if _eaadd.Name.Local == "type" {
			_gggeg.TypeAttr.UnmarshalXMLAttr(_eaadd)
			continue
		}
		if _eaadd.Name.Local == "priority" {
			_cadb, _aafd := _g.ParseUint(_eaadd.Value, 10, 32)
			if _aafd != nil {
				return _aafd
			}
			_gggeg.PriorityAttr = uint32(_cadb)
			continue
		}
	}
_bbgf:
	for {
		_cafg, _geeg := d.Token()
		if _geeg != nil {
			return _geeg
		}
		switch _bacg := _cafg.(type) {
		case _f.StartElement:
			switch _bacg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotAreas"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotAreas"}:
				if _affcc := d.DecodeElement(_gggeg.PivotAreas, &_bacg); _affcc != nil {
					return _affcc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gggeg.ExtLst = NewCT_ExtensionList()
				if _bbga := d.DecodeElement(_gggeg.ExtLst, &_bacg); _bbga != nil {
					return _bbga
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on\u0020CT_ConditionalFormat\u0020\u0025v", _bacg.Name)
				if _bgbd := d.Skip(); _bgbd != nil {
					return _bgbd
				}
			}
		case _f.EndElement:
			break _bbgf
		case _f.CharData:
		}
	}
	return nil
}
func (_dad *CT_AutoFilter) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dad.RefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", *_dad.RefAttr)})
	}
	e.EncodeToken(start)
	if _dad.FilterColumn != nil {
		_ad := _f.StartElement{Name: _f.Name{Local: "ma:filterColumn"}}
		for _, _gac := range _dad.FilterColumn {
			e.EncodeElement(_gac, _ad)
		}
	}
	if _dad.SortState != nil {
		_adf := _f.StartElement{Name: _f.Name{Local: "ma:sortState"}}
		e.EncodeElement(_dad.SortState, _adf)
	}
	if _dad.ExtLst != nil {
		_gb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_dad.ExtLst, _gb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SheetDimension and its children
func (_ccgbac *CT_SheetDimension) Validate() error {
	return _ccgbac.ValidateWithPath("CT_SheetDimension")
}

// Validate validates the CT_PhoneticRun and its children
func (_fgcadb *CT_PhoneticRun) Validate() error { return _fgcadb.ValidateWithPath("CT_PhoneticRun") }

// Validate validates the CT_DateGroupItem and its children
func (_fbaa *CT_DateGroupItem) Validate() error { return _fbaa.ValidateWithPath("CT_DateGroupItem") }
func (_ecdb *CT_ObjectPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ecdb.LockedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "locked"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecdb.LockedAttr))})
	}
	if _ecdb.DefaultSizeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultSize"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecdb.DefaultSizeAttr))})
	}
	if _ecdb.PrintAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "print"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecdb.PrintAttr))})
	}
	if _ecdb.DisabledAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "disabled"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecdb.DisabledAttr))})
	}
	if _ecdb.UiObjectAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uiObject"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecdb.UiObjectAttr))})
	}
	if _ecdb.AutoFillAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoFill"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecdb.AutoFillAttr))})
	}
	if _ecdb.AutoLineAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoLine"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecdb.AutoLineAttr))})
	}
	if _ecdb.AutoPictAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoPict"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecdb.AutoPictAttr))})
	}
	if _ecdb.MacroAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "macro"}, Value: _bg.Sprintf("\u0025v", *_ecdb.MacroAttr)})
	}
	if _ecdb.AltTextAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "altText"}, Value: _bg.Sprintf("\u0025v", *_ecdb.AltTextAttr)})
	}
	if _ecdb.DdeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dde"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ecdb.DdeAttr))})
	}
	if _ecdb.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", *_ecdb.IdAttr)})
	}
	e.EncodeToken(start)
	_fgaab := _f.StartElement{Name: _f.Name{Local: "ma:anchor"}}
	e.EncodeElement(_ecdb.Anchor, _fgaab)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_TableMissing() *CT_TableMissing { _bcdac := &CT_TableMissing{}; return _bcdac }

type CT_Query struct {

	// MDX Query String
	MdxAttr string

	// Tuples
	Tpls *CT_Tuples
}

func (_faeab ST_DataConsolidateFunction) ValidateWithPath(path string) error {
	switch _faeab {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_faeab))
	}
	return nil
}
func (_cbafb *CT_GroupLevels) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ecbbf := range start.Attr {
		if _ecbbf.Name.Local == "count" {
			_aefga, _cfcdd := _g.ParseUint(_ecbbf.Value, 10, 32)
			if _cfcdd != nil {
				return _cfcdd
			}
			_gbcee := uint32(_aefga)
			_cbafb.CountAttr = &_gbcee
			continue
		}
	}
_gfgdd:
	for {
		_cdgcbf, _cagg := d.Token()
		if _cagg != nil {
			return _cagg
		}
		switch _aegda := _cdgcbf.(type) {
		case _f.StartElement:
			switch _aegda.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "groupLevel"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "groupLevel"}:
				_ffea := NewCT_GroupLevel()
				if _fcabc := d.DecodeElement(_ffea, &_aegda); _fcabc != nil {
					return _fcabc
				}
				_cbafb.GroupLevel = append(_cbafb.GroupLevel, _ffea)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GroupLevels\u0020\u0025v", _aegda.Name)
				if _edfd := d.Skip(); _edfd != nil {
					return _edfd
				}
			}
		case _f.EndElement:
			break _gfgdd
		case _f.CharData:
		}
	}
	return nil
}

type CT_Sheet struct {

	// Sheet Name
	NameAttr string

	// Sheet Tab Id
	SheetIdAttr uint32

	// Visible State
	StateAttr ST_SheetState
	IdAttr    string
}

// ValidateWithPath validates the CT_Schema and its children, prefixing error messages with path
func (_fggdd *CT_Schema) ValidateWithPath(path string) error { return nil }
func (_ggfgea ST_CfvoType) String() string {
	switch _ggfgea {
	case 0:
		return ""
	case 1:
		return "num"
	case 2:
		return "percent"
	case 3:
		return "max"
	case 4:
		return "min"
	case 5:
		return "formula"
	case 6:
		return "percentile"
	}
	return ""
}
func (_ecaddf ST_Objects) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_adbfe := _f.Attr{}
	_adbfe.Name = name
	switch _ecaddf {
	case ST_ObjectsUnset:
		_adbfe.Value = ""
	case ST_ObjectsAll:
		_adbfe.Value = "all"
	case ST_ObjectsPlaceholders:
		_adbfe.Value = "placeholders"
	case ST_ObjectsNone:
		_adbfe.Value = "none"
	}
	return _adbfe, nil
}

// Validate validates the CT_RPrElt and its children
func (_fgbbc *CT_RPrElt) Validate() error { return _fgbbc.ValidateWithPath("CT_RPrElt") }

type CT_NumFmt struct {

	// Number Format Id
	NumFmtIdAttr uint32

	// Number Format Code
	FormatCodeAttr string
}

func (_bdbbea *CT_TableStyle) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cdbcg := range start.Attr {
		if _cdbcg.Name.Local == "name" {
			_fgcde, _fcfcg := _cdbcg.Value, error(nil)
			if _fcfcg != nil {
				return _fcfcg
			}
			_bdbbea.NameAttr = _fgcde
			continue
		}
		if _cdbcg.Name.Local == "pivot" {
			_baffdb, _fefcba := _g.ParseBool(_cdbcg.Value)
			if _fefcba != nil {
				return _fefcba
			}
			_bdbbea.PivotAttr = &_baffdb
			continue
		}
		if _cdbcg.Name.Local == "table" {
			_effeac, _dbebe := _g.ParseBool(_cdbcg.Value)
			if _dbebe != nil {
				return _dbebe
			}
			_bdbbea.TableAttr = &_effeac
			continue
		}
		if _cdbcg.Name.Local == "count" {
			_fcefaa, _egdfa := _g.ParseUint(_cdbcg.Value, 10, 32)
			if _egdfa != nil {
				return _egdfa
			}
			_dcggg := uint32(_fcefaa)
			_bdbbea.CountAttr = &_dcggg
			continue
		}
	}
_ddadg:
	for {
		_dcabc, _ggcbe := d.Token()
		if _ggcbe != nil {
			return _ggcbe
		}
		switch _bfdae := _dcabc.(type) {
		case _f.StartElement:
			switch _bfdae.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tableStyleElement"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tableStyleElement"}:
				_dbefb := NewCT_TableStyleElement()
				if _bggeb := d.DecodeElement(_dbefb, &_bfdae); _bggeb != nil {
					return _bggeb
				}
				_bdbbea.TableStyleElement = append(_bdbbea.TableStyleElement, _dbefb)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_TableStyle \u0025v", _bfdae.Name)
				if _bagef := d.Skip(); _bagef != nil {
					return _bagef
				}
			}
		case _f.EndElement:
			break _ddadg
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SharedUser and its children, prefixing error messages with path
func (_efgfdb *CT_SharedUser) ValidateWithPath(path string) error {
	if !_e.ST_GuidPatternRe.MatchString(_efgfdb.GuidAttr) {
		return _bg.Errorf("\u0025s\u002fm\u002eGuidAttr must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_GuidPatternRe, _efgfdb.GuidAttr)
	}
	if _efgfdb.ExtLst != nil {
		if _cefcca := _efgfdb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cefcca != nil {
			return _cefcca
		}
	}
	return nil
}
func NewCT_PivotCacheDefinition() *CT_PivotCacheDefinition {
	_cffff := &CT_PivotCacheDefinition{}
	_cffff.CacheSource = NewCT_CacheSource()
	_cffff.CacheFields = NewCT_CacheFields()
	return _cffff
}
func (_gefbgc ST_Type) String() string {
	switch _gefbgc {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "all"
	case 3:
		return "row"
	case 4:
		return "column"
	}
	return ""
}

type CT_FontScheme struct {

	// Font Scheme
	ValAttr ST_FontScheme
}

func (_gaaaaf *CT_WorkbookPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _efggef := range start.Attr {
		if _efggef.Name.Local == "codeName" {
			_debeea, _deaff := _efggef.Value, error(nil)
			if _deaff != nil {
				return _deaff
			}
			_gaaaaf.CodeNameAttr = &_debeea
			continue
		}
		if _efggef.Name.Local == "date1904" {
			_dbaca, _aeedc := _g.ParseBool(_efggef.Value)
			if _aeedc != nil {
				return _aeedc
			}
			_gaaaaf.Date1904Attr = &_dbaca
			continue
		}
		if _efggef.Name.Local == "hidePivotFieldList" {
			_dabga, _eaacg := _g.ParseBool(_efggef.Value)
			if _eaacg != nil {
				return _eaacg
			}
			_gaaaaf.HidePivotFieldListAttr = &_dabga
			continue
		}
		if _efggef.Name.Local == "showBorderUnselectedTables" {
			_fefbd, _abdea := _g.ParseBool(_efggef.Value)
			if _abdea != nil {
				return _abdea
			}
			_gaaaaf.ShowBorderUnselectedTablesAttr = &_fefbd
			continue
		}
		if _efggef.Name.Local == "showPivotChartFilter" {
			_beaagf, _bdfbd := _g.ParseBool(_efggef.Value)
			if _bdfbd != nil {
				return _bdfbd
			}
			_gaaaaf.ShowPivotChartFilterAttr = &_beaagf
			continue
		}
		if _efggef.Name.Local == "promptedSolutions" {
			_faebe, _gbaea := _g.ParseBool(_efggef.Value)
			if _gbaea != nil {
				return _gbaea
			}
			_gaaaaf.PromptedSolutionsAttr = &_faebe
			continue
		}
		if _efggef.Name.Local == "backupFile" {
			_adafea, _bbgeb := _g.ParseBool(_efggef.Value)
			if _bbgeb != nil {
				return _bbgeb
			}
			_gaaaaf.BackupFileAttr = &_adafea
			continue
		}
		if _efggef.Name.Local == "saveExternalLinkValues" {
			_eebde, _agdbg := _g.ParseBool(_efggef.Value)
			if _agdbg != nil {
				return _agdbg
			}
			_gaaaaf.SaveExternalLinkValuesAttr = &_eebde
			continue
		}
		if _efggef.Name.Local == "updateLinks" {
			_gaaaaf.UpdateLinksAttr.UnmarshalXMLAttr(_efggef)
			continue
		}
		if _efggef.Name.Local == "showObjects" {
			_gaaaaf.ShowObjectsAttr.UnmarshalXMLAttr(_efggef)
			continue
		}
		if _efggef.Name.Local == "filterPrivacy" {
			_eeegd, _dfage := _g.ParseBool(_efggef.Value)
			if _dfage != nil {
				return _dfage
			}
			_gaaaaf.FilterPrivacyAttr = &_eeegd
			continue
		}
		if _efggef.Name.Local == "showInkAnnotation" {
			_adgaa, _fbfee := _g.ParseBool(_efggef.Value)
			if _fbfee != nil {
				return _fbfee
			}
			_gaaaaf.ShowInkAnnotationAttr = &_adgaa
			continue
		}
		if _efggef.Name.Local == "allowRefreshQuery" {
			_dgbag, _cbffeb := _g.ParseBool(_efggef.Value)
			if _cbffeb != nil {
				return _cbffeb
			}
			_gaaaaf.AllowRefreshQueryAttr = &_dgbag
			continue
		}
		if _efggef.Name.Local == "publishItems" {
			_fcefc, _cgcef := _g.ParseBool(_efggef.Value)
			if _cgcef != nil {
				return _cgcef
			}
			_gaaaaf.PublishItemsAttr = &_fcefc
			continue
		}
		if _efggef.Name.Local == "checkCompatibility" {
			_gbeab, _gcgfe := _g.ParseBool(_efggef.Value)
			if _gcgfe != nil {
				return _gcgfe
			}
			_gaaaaf.CheckCompatibilityAttr = &_gbeab
			continue
		}
		if _efggef.Name.Local == "autoCompressPictures" {
			_accbg, _fadae := _g.ParseBool(_efggef.Value)
			if _fadae != nil {
				return _fadae
			}
			_gaaaaf.AutoCompressPicturesAttr = &_accbg
			continue
		}
		if _efggef.Name.Local == "refreshAllConnections" {
			_eaffe, _acaff := _g.ParseBool(_efggef.Value)
			if _acaff != nil {
				return _acaff
			}
			_gaaaaf.RefreshAllConnectionsAttr = &_eaffe
			continue
		}
		if _efggef.Name.Local == "defaultThemeVersion" {
			_fadef, _adbcee := _g.ParseUint(_efggef.Value, 10, 32)
			if _adbcee != nil {
				return _adbcee
			}
			_abfacd := uint32(_fadef)
			_gaaaaf.DefaultThemeVersionAttr = &_abfacd
			continue
		}
	}
	for {
		_fcegab, _gcaecf := d.Token()
		if _gcaecf != nil {
			return _bg.Errorf("parsing\u0020CT_WorkbookPr:\u0020\u0025s", _gcaecf)
		}
		if _dfcbcc, _egagfe := _fcegab.(_f.EndElement); _egagfe && _dfcbcc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gggbf ST_VerticalAlignment) ValidateWithPath(path string) error {
	switch _gggbf {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gggbf))
	}
	return nil
}
func (_eafda *CT_IconFilter) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	_gfgdb, _abefad := _eafda.IconSetAttr.MarshalXMLAttr(_f.Name{Local: "iconSet"})
	if _abefad != nil {
		return _abefad
	}
	start.Attr = append(start.Attr, _gfgdb)
	if _eafda.IconIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "iconId"}, Value: _bg.Sprintf("\u0025v", *_eafda.IconIdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_SheetProtection and its children, prefixing error messages with path
func (_fafacb *CT_SheetProtection) ValidateWithPath(path string) error { return nil }
func (_agdgca *CT_VolTopic) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _agdgca.TAttr != ST_VolValueTypeUnset {
		_eefcg, _cbcddf := _agdgca.TAttr.MarshalXMLAttr(_f.Name{Local: "t"})
		if _cbcddf != nil {
			return _cbcddf
		}
		start.Attr = append(start.Attr, _eefcg)
	}
	e.EncodeToken(start)
	_faafeg := _f.StartElement{Name: _f.Name{Local: "ma:v"}}
	_cb.AddPreserveSpaceAttr(&_faafeg, _agdgca.V)
	e.EncodeElement(_agdgca.V, _faafeg)
	if _agdgca.Stp != nil {
		_fdgaga := _f.StartElement{Name: _f.Name{Local: "ma:stp"}}
		for _, _fgeagf := range _agdgca.Stp {
			e.EncodeElement(_fgeagf, _fdgaga)
		}
	}
	_bgace := _f.StartElement{Name: _f.Name{Local: "ma:tr"}}
	for _, _egbaab := range _agdgca.Tr {
		e.EncodeElement(_egbaab, _bgace)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gcec *CT_Connections) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_ecaae := _f.StartElement{Name: _f.Name{Local: "ma:connection"}}
	for _, _agfd := range _gcec.Connection {
		e.EncodeElement(_agfd, _ecaae)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_beffgf *CT_SheetFormatPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _adgde := range start.Attr {
		if _adgde.Name.Local == "baseColWidth" {
			_eagafg, _cffgc := _g.ParseUint(_adgde.Value, 10, 32)
			if _cffgc != nil {
				return _cffgc
			}
			_agcfbe := uint32(_eagafg)
			_beffgf.BaseColWidthAttr = &_agcfbe
			continue
		}
		if _adgde.Name.Local == "defaultColWidth" {
			_bgcec, _acbcd := _g.ParseFloat(_adgde.Value, 64)
			if _acbcd != nil {
				return _acbcd
			}
			_beffgf.DefaultColWidthAttr = &_bgcec
			continue
		}
		if _adgde.Name.Local == "defaultRowHeight" {
			_acdff, _dbcee := _g.ParseFloat(_adgde.Value, 64)
			if _dbcee != nil {
				return _dbcee
			}
			_beffgf.DefaultRowHeightAttr = _acdff
			continue
		}
		if _adgde.Name.Local == "customHeight" {
			_ebabe, _cbcaa := _g.ParseBool(_adgde.Value)
			if _cbcaa != nil {
				return _cbcaa
			}
			_beffgf.CustomHeightAttr = &_ebabe
			continue
		}
		if _adgde.Name.Local == "zeroHeight" {
			_afeea, _aagbe := _g.ParseBool(_adgde.Value)
			if _aagbe != nil {
				return _aagbe
			}
			_beffgf.ZeroHeightAttr = &_afeea
			continue
		}
		if _adgde.Name.Local == "thickTop" {
			_baaad, _agecd := _g.ParseBool(_adgde.Value)
			if _agecd != nil {
				return _agecd
			}
			_beffgf.ThickTopAttr = &_baaad
			continue
		}
		if _adgde.Name.Local == "thickBottom" {
			_bebfgg, _egbde := _g.ParseBool(_adgde.Value)
			if _egbde != nil {
				return _egbde
			}
			_beffgf.ThickBottomAttr = &_bebfgg
			continue
		}
		if _adgde.Name.Local == "outlineLevelRow" {
			_gagcf, _fdgeb := _g.ParseUint(_adgde.Value, 10, 8)
			if _fdgeb != nil {
				return _fdgeb
			}
			_dcdee := uint8(_gagcf)
			_beffgf.OutlineLevelRowAttr = &_dcdee
			continue
		}
		if _adgde.Name.Local == "outlineLevelCol" {
			_facgb, _ffbfb := _g.ParseUint(_adgde.Value, 10, 8)
			if _ffbfb != nil {
				return _ffbfb
			}
			_feebfb := uint8(_facgb)
			_beffgf.OutlineLevelColAttr = &_feebfb
			continue
		}
	}
	for {
		_daccd, _deegf := d.Token()
		if _deegf != nil {
			return _bg.Errorf("parsing\u0020CT_SheetFormatPr: \u0025s", _deegf)
		}
		if _daebd, _bddc := _daccd.(_f.EndElement); _bddc && _daebd.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Selection() *CT_Selection { _dgfegd := &CT_Selection{}; return _dgfegd }

type CT_GradientStop struct {

	// Gradient Stop Position
	PositionAttr float64

	// Color
	Color *CT_Color
}

func (_agggb *ST_WebSourceType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_agggb = 0
	case "sheet":
		*_agggb = 1
	case "printArea":
		*_agggb = 2
	case "autoFilter":
		*_agggb = 3
	case "range":
		*_agggb = 4
	case "chart":
		*_agggb = 5
	case "pivotTable":
		*_agggb = 6
	case "query":
		*_agggb = 7
	case "label":
		*_agggb = 8
	}
	return nil
}

type ST_TargetScreenSize byte

// ValidateWithPath validates the CT_Worksheet and its children, prefixing error messages with path
func (_gacefc *CT_Worksheet) ValidateWithPath(path string) error {
	if _gacefc.SheetPr != nil {
		if _gcbad := _gacefc.SheetPr.ValidateWithPath(path + "\u002fSheetPr"); _gcbad != nil {
			return _gcbad
		}
	}
	if _gacefc.Dimension != nil {
		if _bbgfad := _gacefc.Dimension.ValidateWithPath(path + "\u002fDimension"); _bbgfad != nil {
			return _bbgfad
		}
	}
	if _gacefc.SheetViews != nil {
		if _eaded := _gacefc.SheetViews.ValidateWithPath(path + "/SheetViews"); _eaded != nil {
			return _eaded
		}
	}
	if _gacefc.SheetFormatPr != nil {
		if _aabeeg := _gacefc.SheetFormatPr.ValidateWithPath(path + "\u002fSheetFormatPr"); _aabeeg != nil {
			return _aabeeg
		}
	}
	for _cffge, _egcfa := range _gacefc.Cols {
		if _dafca := _egcfa.ValidateWithPath(_bg.Sprintf("%s\u002fCols\u005b\u0025d\u005d", path, _cffge)); _dafca != nil {
			return _dafca
		}
	}
	if _faebdf := _gacefc.SheetData.ValidateWithPath(path + "\u002fSheetData"); _faebdf != nil {
		return _faebdf
	}
	if _gacefc.SheetCalcPr != nil {
		if _aebgb := _gacefc.SheetCalcPr.ValidateWithPath(path + "\u002fSheetCalcPr"); _aebgb != nil {
			return _aebgb
		}
	}
	if _gacefc.SheetProtection != nil {
		if _bfecb := _gacefc.SheetProtection.ValidateWithPath(path + "\u002fSheetProtection"); _bfecb != nil {
			return _bfecb
		}
	}
	if _gacefc.ProtectedRanges != nil {
		if _eaedfb := _gacefc.ProtectedRanges.ValidateWithPath(path + "\u002fProtectedRanges"); _eaedfb != nil {
			return _eaedfb
		}
	}
	if _gacefc.Scenarios != nil {
		if _ggfgf := _gacefc.Scenarios.ValidateWithPath(path + "\u002fScenarios"); _ggfgf != nil {
			return _ggfgf
		}
	}
	if _gacefc.AutoFilter != nil {
		if _cbbgg := _gacefc.AutoFilter.ValidateWithPath(path + "/AutoFilter"); _cbbgg != nil {
			return _cbbgg
		}
	}
	if _gacefc.SortState != nil {
		if _dbdeb := _gacefc.SortState.ValidateWithPath(path + "\u002fSortState"); _dbdeb != nil {
			return _dbdeb
		}
	}
	if _gacefc.DataConsolidate != nil {
		if _edccd := _gacefc.DataConsolidate.ValidateWithPath(path + "\u002fDataConsolidate"); _edccd != nil {
			return _edccd
		}
	}
	if _gacefc.CustomSheetViews != nil {
		if _dbdgea := _gacefc.CustomSheetViews.ValidateWithPath(path + "\u002fCustomSheetViews"); _dbdgea != nil {
			return _dbdgea
		}
	}
	if _gacefc.MergeCells != nil {
		if _efbfd := _gacefc.MergeCells.ValidateWithPath(path + "/MergeCells"); _efbfd != nil {
			return _efbfd
		}
	}
	if _gacefc.PhoneticPr != nil {
		if _fefaff := _gacefc.PhoneticPr.ValidateWithPath(path + "/PhoneticPr"); _fefaff != nil {
			return _fefaff
		}
	}
	for _fbcfba, _cdgca := range _gacefc.ConditionalFormatting {
		if _agccg := _cdgca.ValidateWithPath(_bg.Sprintf("\u0025s\u002fConditionalFormatting\u005b%d\u005d", path, _fbcfba)); _agccg != nil {
			return _agccg
		}
	}
	if _gacefc.DataValidations != nil {
		if _fbccf := _gacefc.DataValidations.ValidateWithPath(path + "\u002fDataValidations"); _fbccf != nil {
			return _fbccf
		}
	}
	if _gacefc.Hyperlinks != nil {
		if _fdafd := _gacefc.Hyperlinks.ValidateWithPath(path + "/Hyperlinks"); _fdafd != nil {
			return _fdafd
		}
	}
	if _gacefc.PrintOptions != nil {
		if _aedcc := _gacefc.PrintOptions.ValidateWithPath(path + "\u002fPrintOptions"); _aedcc != nil {
			return _aedcc
		}
	}
	if _gacefc.PageMargins != nil {
		if _abgeg := _gacefc.PageMargins.ValidateWithPath(path + "\u002fPageMargins"); _abgeg != nil {
			return _abgeg
		}
	}
	if _gacefc.PageSetup != nil {
		if _eacgf := _gacefc.PageSetup.ValidateWithPath(path + "\u002fPageSetup"); _eacgf != nil {
			return _eacgf
		}
	}
	if _gacefc.HeaderFooter != nil {
		if _febge := _gacefc.HeaderFooter.ValidateWithPath(path + "\u002fHeaderFooter"); _febge != nil {
			return _febge
		}
	}
	if _gacefc.RowBreaks != nil {
		if _ggfec := _gacefc.RowBreaks.ValidateWithPath(path + "\u002fRowBreaks"); _ggfec != nil {
			return _ggfec
		}
	}
	if _gacefc.ColBreaks != nil {
		if _aeabb := _gacefc.ColBreaks.ValidateWithPath(path + "\u002fColBreaks"); _aeabb != nil {
			return _aeabb
		}
	}
	if _gacefc.CustomProperties != nil {
		if _bbdegf := _gacefc.CustomProperties.ValidateWithPath(path + "\u002fCustomProperties"); _bbdegf != nil {
			return _bbdegf
		}
	}
	if _gacefc.CellWatches != nil {
		if _afdfc := _gacefc.CellWatches.ValidateWithPath(path + "\u002fCellWatches"); _afdfc != nil {
			return _afdfc
		}
	}
	if _gacefc.IgnoredErrors != nil {
		if _eebgdg := _gacefc.IgnoredErrors.ValidateWithPath(path + "\u002fIgnoredErrors"); _eebgdg != nil {
			return _eebgdg
		}
	}
	if _gacefc.SmartTags != nil {
		if _bfebc := _gacefc.SmartTags.ValidateWithPath(path + "\u002fSmartTags"); _bfebc != nil {
			return _bfebc
		}
	}
	if _gacefc.Drawing != nil {
		if _cfeac := _gacefc.Drawing.ValidateWithPath(path + "\u002fDrawing"); _cfeac != nil {
			return _cfeac
		}
	}
	if _gacefc.LegacyDrawing != nil {
		if _gcbadd := _gacefc.LegacyDrawing.ValidateWithPath(path + "\u002fLegacyDrawing"); _gcbadd != nil {
			return _gcbadd
		}
	}
	if _gacefc.LegacyDrawingHF != nil {
		if _fbgccgd := _gacefc.LegacyDrawingHF.ValidateWithPath(path + "\u002fLegacyDrawingHF"); _fbgccgd != nil {
			return _fbgccgd
		}
	}
	if _gacefc.DrawingHF != nil {
		if _ebge := _gacefc.DrawingHF.ValidateWithPath(path + "\u002fDrawingHF"); _ebge != nil {
			return _ebge
		}
	}
	if _gacefc.Picture != nil {
		if _fgdfe := _gacefc.Picture.ValidateWithPath(path + "\u002fPicture"); _fgdfe != nil {
			return _fgdfe
		}
	}
	if _gacefc.OleObjects != nil {
		if _ceaee := _gacefc.OleObjects.ValidateWithPath(path + "/OleObjects"); _ceaee != nil {
			return _ceaee
		}
	}
	if _gacefc.Controls != nil {
		if _bcbee := _gacefc.Controls.ValidateWithPath(path + "\u002fControls"); _bcbee != nil {
			return _bcbee
		}
	}
	if _gacefc.WebPublishItems != nil {
		if _cbafa := _gacefc.WebPublishItems.ValidateWithPath(path + "\u002fWebPublishItems"); _cbafa != nil {
			return _cbafa
		}
	}
	if _gacefc.TableParts != nil {
		if _bbdbd := _gacefc.TableParts.ValidateWithPath(path + "/TableParts"); _bbdbd != nil {
			return _bbdbd
		}
	}
	if _gacefc.ExtLst != nil {
		if _badce := _gacefc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _badce != nil {
			return _badce
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SortCondition and its children, prefixing error messages with path
func (_aabefe *CT_SortCondition) ValidateWithPath(path string) error {
	if _fcace := _aabefe.SortByAttr.ValidateWithPath(path + "/SortByAttr"); _fcace != nil {
		return _fcace
	}
	if _bfcff := _aabefe.IconSetAttr.ValidateWithPath(path + "\u002fIconSetAttr"); _bfcff != nil {
		return _bfcff
	}
	return nil
}
func NewCT_GradientFill() *CT_GradientFill { _dadc := &CT_GradientFill{}; return _dadc }
func NewCT_Item() *CT_Item                 { _acgae := &CT_Item{}; return _acgae }
func (_dcdeea *ST_TextHAlign) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_dcdeea = 0
	case "left":
		*_dcdeea = 1
	case "center":
		*_dcdeea = 2
	case "right":
		*_dcdeea = 3
	case "justify":
		*_dcdeea = 4
	case "distributed":
		*_dcdeea = 5
	}
	return nil
}
func NewCT_RevisionInsertSheet() *CT_RevisionInsertSheet {
	_abgea := &CT_RevisionInsertSheet{}
	return _abgea
}
func (_gbacb ST_SheetState) Validate() error { return _gbacb.ValidateWithPath("") }
func (_aaedfd *CT_SingleXmlCell) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_aaedfd.XmlCellPr = NewCT_XmlCellPr()
	for _, _gaafac := range start.Attr {
		if _gaafac.Name.Local == "id" {
			_ccbbeb, _faafg := _g.ParseUint(_gaafac.Value, 10, 32)
			if _faafg != nil {
				return _faafg
			}
			_aaedfd.IdAttr = uint32(_ccbbeb)
			continue
		}
		if _gaafac.Name.Local == "r" {
			_fafgg, _gbbec := _gaafac.Value, error(nil)
			if _gbbec != nil {
				return _gbbec
			}
			_aaedfd.RAttr = _fafgg
			continue
		}
		if _gaafac.Name.Local == "connectionId" {
			_gedddb, _bbadfe := _g.ParseUint(_gaafac.Value, 10, 32)
			if _bbadfe != nil {
				return _bbadfe
			}
			_aaedfd.ConnectionIdAttr = uint32(_gedddb)
			continue
		}
	}
_ggdafe:
	for {
		_fagfc, _bageba := d.Token()
		if _bageba != nil {
			return _bageba
		}
		switch _afgead := _fagfc.(type) {
		case _f.StartElement:
			switch _afgead.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "xmlCellPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "xmlCellPr"}:
				if _dbcae := d.DecodeElement(_aaedfd.XmlCellPr, &_afgead); _dbcae != nil {
					return _dbcae
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_aaedfd.ExtLst = NewCT_ExtensionList()
				if _dgaff := d.DecodeElement(_aaedfd.ExtLst, &_afgead); _dgaff != nil {
					return _dgaff
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SingleXmlCell\u0020\u0025v", _afgead.Name)
				if _ebagc := d.Skip(); _ebagc != nil {
					return _ebagc
				}
			}
		case _f.EndElement:
			break _ggdafe
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_ProtectedRanges and its children
func (_ecadf *CT_ProtectedRanges) Validate() error {
	return _ecadf.ValidateWithPath("CT_ProtectedRanges")
}
func (_cegg *CT_CellWatches) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_adebb := _f.StartElement{Name: _f.Name{Local: "ma:cellWatch"}}
	for _, _fgfeb := range _cegg.CellWatch {
		e.EncodeElement(_fgfeb, _adebb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_caadc *CT_PivotFields) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bfead := range start.Attr {
		if _bfead.Name.Local == "count" {
			_aeeda, _dfdgg := _g.ParseUint(_bfead.Value, 10, 32)
			if _dfdgg != nil {
				return _dfdgg
			}
			_beaeg := uint32(_aeeda)
			_caadc.CountAttr = &_beaeg
			continue
		}
	}
_gbfbe:
	for {
		_dgbcc, _gfbbc := d.Token()
		if _gfbbc != nil {
			return _gfbbc
		}
		switch _fbbacf := _dgbcc.(type) {
		case _f.StartElement:
			switch _fbbacf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotField"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotField"}:
				_bcecdg := NewCT_PivotField()
				if _defga := d.DecodeElement(_bcecdg, &_fbbacf); _defga != nil {
					return _defga
				}
				_caadc.PivotField = append(_caadc.PivotField, _bcecdg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PivotFields\u0020\u0025v", _fbbacf.Name)
				if _fagfga := d.Skip(); _fagfga != nil {
					return _fagfga
				}
			}
		case _f.EndElement:
			break _gbfbe
		case _f.CharData:
		}
	}
	return nil
}
func (_bggab *CT_Sheets) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_cacga := _f.StartElement{Name: _f.Name{Local: "ma:sheet"}}
	for _, _ccbag := range _bggab.Sheet {
		e.EncodeElement(_ccbag, _cacga)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gcfaf *CT_DdeItem) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bfbeg := range start.Attr {
		if _bfbeg.Name.Local == "name" {
			_ddade, _bebeg := _bfbeg.Value, error(nil)
			if _bebeg != nil {
				return _bebeg
			}
			_gcfaf.NameAttr = &_ddade
			continue
		}
		if _bfbeg.Name.Local == "ole" {
			_cacc, _cbac := _g.ParseBool(_bfbeg.Value)
			if _cbac != nil {
				return _cbac
			}
			_gcfaf.OleAttr = &_cacc
			continue
		}
		if _bfbeg.Name.Local == "advise" {
			_dfddc, _edgcg := _g.ParseBool(_bfbeg.Value)
			if _edgcg != nil {
				return _edgcg
			}
			_gcfaf.AdviseAttr = &_dfddc
			continue
		}
		if _bfbeg.Name.Local == "preferPic" {
			_ggcc, _afad := _g.ParseBool(_bfbeg.Value)
			if _afad != nil {
				return _afad
			}
			_gcfaf.PreferPicAttr = &_ggcc
			continue
		}
	}
_dbea:
	for {
		_aebgd, _gfdd := d.Token()
		if _gfdd != nil {
			return _gfdd
		}
		switch _bafbe := _aebgd.(type) {
		case _f.StartElement:
			switch _bafbe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "values"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "values"}:
				_gcfaf.Values = NewCT_DdeValues()
				if _ddef := d.DecodeElement(_gcfaf.Values, &_bafbe); _ddef != nil {
					return _ddef
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_DdeItem\u0020\u0025v", _bafbe.Name)
				if _ceec := d.Skip(); _ceec != nil {
					return _ceec
				}
			}
		case _f.EndElement:
			break _dbea
		case _f.CharData:
		}
	}
	return nil
}
func (_fdfae *CT_DdeValue) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fdfae.TAttr != ST_DdeValueTypeUnset {
		_abefe, _bcad := _fdfae.TAttr.MarshalXMLAttr(_f.Name{Local: "t"})
		if _bcad != nil {
			return _bcad
		}
		start.Attr = append(start.Attr, _abefe)
	}
	e.EncodeToken(start)
	_bcbga := _f.StartElement{Name: _f.Name{Local: "ma:val"}}
	_cb.AddPreserveSpaceAttr(&_bcbga, _fdfae.Val)
	e.EncodeElement(_fdfae.Val, _bcbga)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Items and its children
func (_bdbg *CT_Items) Validate() error { return _bdbg.ValidateWithPath("CT_Items") }
func (_dcfg *CT_ConditionalFormatting) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dcfg.PivotAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pivot"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dcfg.PivotAttr))})
	}
	if _dcfg.SqrefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sqref"}, Value: _bg.Sprintf("\u0025v", *_dcfg.SqrefAttr)})
	}
	e.EncodeToken(start)
	_fgafa := _f.StartElement{Name: _f.Name{Local: "ma:cfRule"}}
	for _, _aaaed := range _dcfg.CfRule {
		e.EncodeElement(_aaaed, _fgafa)
	}
	if _dcfg.ExtLst != nil {
		_beec := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_dcfg.ExtLst, _beec)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_ColHierarchiesUsage() *CT_ColHierarchiesUsage {
	_ccfe := &CT_ColHierarchiesUsage{}
	return _ccfe
}

// Validate validates the CT_RangePr and its children
func (_gdceg *CT_RangePr) Validate() error { return _gdceg.ValidateWithPath("CT_RangePr") }
func (_ggcdg *CT_TableFormula) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "array"}, Value: _bg.Sprintf("\u0025d", _fdbfb(_ggcdg.ArrayAttr))})
	e.EncodeElement(_ggcdg.Content, start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_CacheField and its children, prefixing error messages with path
func (_dee *CT_CacheField) ValidateWithPath(path string) error {
	if _dee.SharedItems != nil {
		if _geac := _dee.SharedItems.ValidateWithPath(path + "\u002fSharedItems"); _geac != nil {
			return _geac
		}
	}
	if _dee.FieldGroup != nil {
		if _aegc := _dee.FieldGroup.ValidateWithPath(path + "/FieldGroup"); _aegc != nil {
			return _aegc
		}
	}
	for _acfd, _bcg := range _dee.MpMap {
		if _aegff := _bcg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fMpMap\u005b\u0025d\u005d", path, _acfd)); _aegff != nil {
			return _aegff
		}
	}
	if _dee.ExtLst != nil {
		if _ede := _dee.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ede != nil {
			return _ede
		}
	}
	return nil
}
func (_abbg *CT_DataValidation) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bgbb := range start.Attr {
		if _bgbb.Name.Local == "showErrorMessage" {
			_cege, _adfdg := _g.ParseBool(_bgbb.Value)
			if _adfdg != nil {
				return _adfdg
			}
			_abbg.ShowErrorMessageAttr = &_cege
			continue
		}
		if _bgbb.Name.Local == "errorTitle" {
			_gced, _dgdad := _bgbb.Value, error(nil)
			if _dgdad != nil {
				return _dgdad
			}
			_abbg.ErrorTitleAttr = &_gced
			continue
		}
		if _bgbb.Name.Local == "errorStyle" {
			_abbg.ErrorStyleAttr.UnmarshalXMLAttr(_bgbb)
			continue
		}
		if _bgbb.Name.Local == "operator" {
			_abbg.OperatorAttr.UnmarshalXMLAttr(_bgbb)
			continue
		}
		if _bgbb.Name.Local == "allowBlank" {
			_dedc, _bgab := _g.ParseBool(_bgbb.Value)
			if _bgab != nil {
				return _bgab
			}
			_abbg.AllowBlankAttr = &_dedc
			continue
		}
		if _bgbb.Name.Local == "showDropDown" {
			_bgabf, _agef := _g.ParseBool(_bgbb.Value)
			if _agef != nil {
				return _agef
			}
			_abbg.ShowDropDownAttr = &_bgabf
			continue
		}
		if _bgbb.Name.Local == "showInputMessage" {
			_bcgd, _facb := _g.ParseBool(_bgbb.Value)
			if _facb != nil {
				return _facb
			}
			_abbg.ShowInputMessageAttr = &_bcgd
			continue
		}
		if _bgbb.Name.Local == "type" {
			_abbg.TypeAttr.UnmarshalXMLAttr(_bgbb)
			continue
		}
		if _bgbb.Name.Local == "imeMode" {
			_abbg.ImeModeAttr.UnmarshalXMLAttr(_bgbb)
			continue
		}
		if _bgbb.Name.Local == "error" {
			_edec, _ecaf := _bgbb.Value, error(nil)
			if _ecaf != nil {
				return _ecaf
			}
			_abbg.ErrorAttr = &_edec
			continue
		}
		if _bgbb.Name.Local == "promptTitle" {
			_beaec, _faab := _bgbb.Value, error(nil)
			if _faab != nil {
				return _faab
			}
			_abbg.PromptTitleAttr = &_beaec
			continue
		}
		if _bgbb.Name.Local == "prompt" {
			_gggad, _gcgba := _bgbb.Value, error(nil)
			if _gcgba != nil {
				return _gcgba
			}
			_abbg.PromptAttr = &_gggad
			continue
		}
		if _bgbb.Name.Local == "sqref" {
			_bdefc, _bfga := ParseSliceST_Sqref(_bgbb.Value)
			if _bfga != nil {
				return _bfga
			}
			_abbg.SqrefAttr = _bdefc
			continue
		}
	}
_afgcg:
	for {
		_aceda, _ddfed := d.Token()
		if _ddfed != nil {
			return _ddfed
		}
		switch _gfffb := _aceda.(type) {
		case _f.StartElement:
			switch _gfffb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "formula1"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "formula1"}:
				_abbg.Formula1 = new(string)
				if _cbcf := d.DecodeElement(_abbg.Formula1, &_gfffb); _cbcf != nil {
					return _cbcf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "formula2"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "formula2"}:
				_abbg.Formula2 = new(string)
				if _dcce := d.DecodeElement(_abbg.Formula2, &_gfffb); _dcce != nil {
					return _dcce
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_DataValidation\u0020\u0025v", _gfffb.Name)
				if _bgfcb := d.Skip(); _bgfcb != nil {
					return _bgfcb
				}
			}
		case _f.EndElement:
			break _afgcg
		case _f.CharData:
		}
	}
	return nil
}
func (_bdgda *ST_PivotFilterType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bdgda = 0
	case "unknown":
		*_bdgda = 1
	case "count":
		*_bdgda = 2
	case "percent":
		*_bdgda = 3
	case "sum":
		*_bdgda = 4
	case "captionEqual":
		*_bdgda = 5
	case "captionNotEqual":
		*_bdgda = 6
	case "captionBeginsWith":
		*_bdgda = 7
	case "captionNotBeginsWith":
		*_bdgda = 8
	case "captionEndsWith":
		*_bdgda = 9
	case "captionNotEndsWith":
		*_bdgda = 10
	case "captionContains":
		*_bdgda = 11
	case "captionNotContains":
		*_bdgda = 12
	case "captionGreaterThan":
		*_bdgda = 13
	case "captionGreaterThanOrEqual":
		*_bdgda = 14
	case "captionLessThan":
		*_bdgda = 15
	case "captionLessThanOrEqual":
		*_bdgda = 16
	case "captionBetween":
		*_bdgda = 17
	case "captionNotBetween":
		*_bdgda = 18
	case "valueEqual":
		*_bdgda = 19
	case "valueNotEqual":
		*_bdgda = 20
	case "valueGreaterThan":
		*_bdgda = 21
	case "valueGreaterThanOrEqual":
		*_bdgda = 22
	case "valueLessThan":
		*_bdgda = 23
	case "valueLessThanOrEqual":
		*_bdgda = 24
	case "valueBetween":
		*_bdgda = 25
	case "valueNotBetween":
		*_bdgda = 26
	case "dateEqual":
		*_bdgda = 27
	case "dateNotEqual":
		*_bdgda = 28
	case "dateOlderThan":
		*_bdgda = 29
	case "dateOlderThanOrEqual":
		*_bdgda = 30
	case "dateNewerThan":
		*_bdgda = 31
	case "dateNewerThanOrEqual":
		*_bdgda = 32
	case "dateBetween":
		*_bdgda = 33
	case "dateNotBetween":
		*_bdgda = 34
	case "tomorrow":
		*_bdgda = 35
	case "today":
		*_bdgda = 36
	case "yesterday":
		*_bdgda = 37
	case "nextWeek":
		*_bdgda = 38
	case "thisWeek":
		*_bdgda = 39
	case "lastWeek":
		*_bdgda = 40
	case "nextMonth":
		*_bdgda = 41
	case "thisMonth":
		*_bdgda = 42
	case "lastMonth":
		*_bdgda = 43
	case "nextQuarter":
		*_bdgda = 44
	case "thisQuarter":
		*_bdgda = 45
	case "lastQuarter":
		*_bdgda = 46
	case "nextYear":
		*_bdgda = 47
	case "thisYear":
		*_bdgda = 48
	case "lastYear":
		*_bdgda = 49
	case "yearToDate":
		*_bdgda = 50
	case "Q1":
		*_bdgda = 51
	case "Q2":
		*_bdgda = 52
	case "Q3":
		*_bdgda = 53
	case "Q4":
		*_bdgda = 54
	case "M1":
		*_bdgda = 55
	case "M2":
		*_bdgda = 56
	case "M3":
		*_bdgda = 57
	case "M4":
		*_bdgda = 58
	case "M5":
		*_bdgda = 59
	case "M6":
		*_bdgda = 60
	case "M7":
		*_bdgda = 61
	case "M8":
		*_bdgda = 62
	case "M9":
		*_bdgda = 63
	case "M10":
		*_bdgda = 64
	case "M11":
		*_bdgda = 65
	case "M12":
		*_bdgda = 66
	}
	return nil
}
func NewHeaders() *Headers {
	_gegde := &Headers{}
	_gegde.CT_RevisionHeaders = *NewCT_RevisionHeaders()
	return _gegde
}

// Validate validates the CT_PivotHierarchies and its children
func (_daedg *CT_PivotHierarchies) Validate() error {
	return _daedg.ValidateWithPath("CT_PivotHierarchies")
}
func NewCT_GroupMembers() *CT_GroupMembers { _gaeee := &CT_GroupMembers{}; return _gaeee }

// Validate validates the CT_DataBinding and its children
func (_egfae *CT_DataBinding) Validate() error { return _egfae.ValidateWithPath("CT_DataBinding") }
func (_ceagg ST_UpdateLinks) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_cddfee := _f.Attr{}
	_cddfee.Name = name
	switch _ceagg {
	case ST_UpdateLinksUnset:
		_cddfee.Value = ""
	case ST_UpdateLinksUserSet:
		_cddfee.Value = "userSet"
	case ST_UpdateLinksNever:
		_cddfee.Value = "never"
	case ST_UpdateLinksAlways:
		_cddfee.Value = "always"
	}
	return _cddfee, nil
}

type CT_XmlPr struct {

	// XML Map Id
	MapIdAttr uint32

	// XPath
	XpathAttr string

	// XML Data Type
	XmlDataTypeAttr string

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}
type CT_PCDSDTCEntries struct {

	// Tuple Count
	CountAttr *uint32

	// No Value
	M []*CT_Missing

	// Numeric Value
	N []*CT_Number

	// Error Value
	E []*CT_Error

	// Character Value
	S []*CT_String
}

func (_fdbcd *CT_Colors) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _fdbcd.IndexedColors != nil {
		_egaa := _f.StartElement{Name: _f.Name{Local: "ma:indexedColors"}}
		e.EncodeElement(_fdbcd.IndexedColors, _egaa)
	}
	if _fdbcd.MruColors != nil {
		_cabbe := _f.StartElement{Name: _f.Name{Local: "ma:mruColors"}}
		e.EncodeElement(_fdbcd.MruColors, _cabbe)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_CacheHierarchies and its children, prefixing error messages with path
func (_fbe *CT_CacheHierarchies) ValidateWithPath(path string) error {
	for _gfee, _beacg := range _fbe.CacheHierarchy {
		if _ggac := _beacg.ValidateWithPath(_bg.Sprintf("%s\u002fCacheHierarchy\u005b\u0025d\u005d", path, _gfee)); _ggac != nil {
			return _ggac
		}
	}
	return nil
}

// Validate validates the CT_GroupLevel and its children
func (_eeab *CT_GroupLevel) Validate() error { return _eeab.ValidateWithPath("CT_GroupLevel") }
func (_dcef *CT_ColHierarchiesUsage) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dgfgf := range start.Attr {
		if _dgfgf.Name.Local == "count" {
			_ggaga, _cbffb := _g.ParseUint(_dgfgf.Value, 10, 32)
			if _cbffb != nil {
				return _cbffb
			}
			_deaed := uint32(_ggaga)
			_dcef.CountAttr = &_deaed
			continue
		}
	}
_ffbd:
	for {
		_ebdf, _bggad := d.Token()
		if _bggad != nil {
			return _bggad
		}
		switch _egfd := _ebdf.(type) {
		case _f.StartElement:
			switch _egfd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colHierarchyUsage"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colHierarchyUsage"}:
				_ebadb := NewCT_HierarchyUsage()
				if _egcg := d.DecodeElement(_ebadb, &_egfd); _egcg != nil {
					return _egcg
				}
				_dcef.ColHierarchyUsage = append(_dcef.ColHierarchyUsage, _ebadb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ColHierarchiesUsage\u0020\u0025v", _egfd.Name)
				if _adfc := d.Skip(); _adfc != nil {
					return _adfc
				}
			}
		case _f.EndElement:
			break _ffbd
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_PrintOptions and its children
func (_bdfgb *CT_PrintOptions) Validate() error { return _bdfgb.ValidateWithPath("CT_PrintOptions") }
func (_agfcd *CT_FieldsUsage) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _agfcd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_agfcd.CountAttr)})
	}
	e.EncodeToken(start)
	if _agfcd.FieldUsage != nil {
		_fcgcg := _f.StartElement{Name: _f.Name{Local: "ma:fieldUsage"}}
		for _, _efdf := range _agfcd.FieldUsage {
			e.EncodeElement(_efdf, _fcgcg)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

const (
	ST_TableTypeUnset      ST_TableType = 0
	ST_TableTypeWorksheet  ST_TableType = 1
	ST_TableTypeXml        ST_TableType = 2
	ST_TableTypeQueryTable ST_TableType = 3
)

func (_fdcac *CT_ObjectAnchor) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fdcac.MoveWithCellsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "moveWithCells"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fdcac.MoveWithCellsAttr))})
	}
	if _fdcac.SizeWithCellsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sizeWithCells"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fdcac.SizeWithCellsAttr))})
	}
	e.EncodeToken(start)
	_dgbcfc := _f.StartElement{Name: _f.Name{Local: "xdr:from"}}
	e.EncodeElement(_fdcac.From, _dgbcfc)
	_fgfed := _f.StartElement{Name: _f.Name{Local: "xdr:to"}}
	e.EncodeElement(_fdcac.To, _fgfed)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_acfag ST_UpdateLinks) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_acfag.String(), start)
}

type CT_VolMain struct {

	// First String
	FirstAttr string

	// Topic
	Tp []*CT_VolTopic
}

func (_adba *CT_ExternalSheetName) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _adba.ValAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", *_adba.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_adgdde ST_ParameterType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_fgafb := _f.Attr{}
	_fgafb.Name = name
	switch _adgdde {
	case ST_ParameterTypeUnset:
		_fgafb.Value = ""
	case ST_ParameterTypePrompt:
		_fgafb.Value = "prompt"
	case ST_ParameterTypeValue:
		_fgafb.Value = "value"
	case ST_ParameterTypeCell:
		_fgafb.Value = "cell"
	}
	return _fgafb, nil
}

type CT_RevisionHeaders struct {

	// Last Revision GUID
	GuidAttr string

	// Last GUID
	LastGuidAttr *string

	// Shared Workbook
	SharedAttr *bool

	// Disk Revisions
	DiskRevisionsAttr *bool

	// History
	HistoryAttr *bool

	// Track Revisions
	TrackRevisionsAttr *bool

	// Exclusive Mode
	ExclusiveAttr *bool

	// Revision Id
	RevisionIdAttr *uint32

	// Version
	VersionAttr *int32

	// Keep Change History
	KeepChangeHistoryAttr *bool

	// Protected
	ProtectedAttr *bool

	// Preserve History
	PreserveHistoryAttr *uint32

	// Header
	Header []*CT_RevisionHeader
}
type CT_DataRef struct {

	// Reference
	RefAttr *string

	// Named Range
	NameAttr *string

	// Sheet Name
	SheetAttr *string
	IdAttr    *string
}

// Validate validates the CT_SortState and its children
func (_ceecd *CT_SortState) Validate() error { return _ceecd.ValidateWithPath("CT_SortState") }
func (_caeda *CT_Schema) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gfbad := range start.Attr {
		if _gfbad.Name.Local == "ID" {
			_dgefb, _dedgde := _gfbad.Value, error(nil)
			if _dedgde != nil {
				return _dedgde
			}
			_caeda.IDAttr = _dgefb
			continue
		}
		if _gfbad.Name.Local == "SchemaRef" {
			_fbeebc, _bedgg := _gfbad.Value, error(nil)
			if _bedgg != nil {
				return _bedgg
			}
			_caeda.SchemaRefAttr = &_fbeebc
			continue
		}
		if _gfbad.Name.Local == "Namespace" {
			_feced, _fdbcc := _gfbad.Value, error(nil)
			if _fdbcc != nil {
				return _fdbcc
			}
			_caeda.NamespaceAttr = &_feced
			continue
		}
		if _gfbad.Name.Local == "SchemaLanguage" {
			_adafdc, _efcdg := _gfbad.Value, error(nil)
			if _efcdg != nil {
				return _efcdg
			}
			_caeda.SchemaLanguageAttr = &_adafdc
			continue
		}
	}
_adeecg:
	for {
		_addagc, _dafade := d.Token()
		if _dafade != nil {
			return _dafade
		}
		switch _cgbda := _addagc.(type) {
		case _f.StartElement:
			switch _cgbda.Name {
			default:
				if _afebea, _adgacb := _cb.CreateElement(_cgbda); _adgacb != nil {
					return _adgacb
				} else {
					if _bcebgb := d.DecodeElement(_afebea, &_cgbda); _bcebgb != nil {
						return _bcebgb
					}
					_caeda.Any = _afebea
				}
			}
		case _f.EndElement:
			break _adeecg
		case _f.CharData:
		}
	}
	return nil
}
func (_dfgee ST_SourceType) Validate() error { return _dfgee.ValidateWithPath("") }
func (_fecgdb *CT_TableStyles) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fecgdb.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_fecgdb.CountAttr)})
	}
	if _fecgdb.DefaultTableStyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultTableStyle"}, Value: _bg.Sprintf("\u0025v", *_fecgdb.DefaultTableStyleAttr)})
	}
	if _fecgdb.DefaultPivotStyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultPivotStyle"}, Value: _bg.Sprintf("\u0025v", *_fecgdb.DefaultPivotStyleAttr)})
	}
	e.EncodeToken(start)
	if _fecgdb.TableStyle != nil {
		_gbdef := _f.StartElement{Name: _f.Name{Local: "ma:tableStyle"}}
		for _, _cfbbc := range _fecgdb.TableStyle {
			e.EncodeElement(_cfbbc, _gbdef)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_aeceea ST_TextVAlign) ValidateWithPath(path string) error {
	switch _aeceea {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aeceea))
	}
	return nil
}
func NewCT_ChartsheetProtection() *CT_ChartsheetProtection {
	_bdff := &CT_ChartsheetProtection{}
	return _bdff
}
func (_fbfbf ST_SortBy) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_fbfbf.String(), start)
}
func (_fgafga ST_UnderlineValues) Validate() error { return _fgafga.ValidateWithPath("") }
func NewCT_Stylesheet() *CT_Stylesheet             { _ebfcbc := &CT_Stylesheet{}; return _ebfcbc }

type ST_Axis byte

// Validate validates the CT_PivotDimension and its children
func (_acfcg *CT_PivotDimension) Validate() error {
	return _acfcg.ValidateWithPath("CT_PivotDimension")
}

// Validate validates the CT_PivotCaches and its children
func (_dafeeb *CT_PivotCaches) Validate() error { return _dafeeb.ValidateWithPath("CT_PivotCaches") }
func NewCT_MapInfo() *CT_MapInfo                { _bebfa := &CT_MapInfo{}; return _bebfa }
func NewCT_AutoSortScope() *CT_AutoSortScope {
	_eee := &CT_AutoSortScope{}
	_eee.PivotArea = NewCT_PivotArea()
	return _eee
}
func NewCT_Pane() *CT_Pane { _gebcf := &CT_Pane{}; return _gebcf }
func (_fffff ST_SmartTagShow) String() string {
	switch _fffff {
	case 0:
		return ""
	case 1:
		return "all"
	case 2:
		return "none"
	case 3:
		return "noIndicator"
	}
	return ""
}

// ValidateWithPath validates the CT_TablePart and its children, prefixing error messages with path
func (_gdgdfe *CT_TablePart) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_Consolidation and its children, prefixing error messages with path
func (_aefca *CT_Consolidation) ValidateWithPath(path string) error {
	if _aefca.Pages != nil {
		if _ageb := _aefca.Pages.ValidateWithPath(path + "\u002fPages"); _ageb != nil {
			return _ageb
		}
	}
	if _abffe := _aefca.RangeSets.ValidateWithPath(path + "\u002fRangeSets"); _abffe != nil {
		return _abffe
	}
	return nil
}
func (_fccaeb ST_IconSetType) Validate() error { return _fccaeb.ValidateWithPath("") }

type CT_ReviewedRevisions struct {

	// Reviewed Revisions Count
	CountAttr *uint32

	// Reviewed
	Reviewed []*CT_Reviewed
}
type Revisions struct{ CT_Revisions }
type CT_Workbook struct {

	// Document Conformance Class
	ConformanceAttr _e.ST_ConformanceClass

	// File Version
	FileVersion *CT_FileVersion

	// File Sharing
	FileSharing *CT_FileSharing

	// Workbook Properties
	WorkbookPr *CT_WorkbookPr

	// Workbook Protection
	WorkbookProtection *CT_WorkbookProtection

	// Workbook Views
	BookViews *CT_BookViews

	// Sheets
	Sheets *CT_Sheets

	// Function Groups
	FunctionGroups *CT_FunctionGroups

	// External References
	ExternalReferences *CT_ExternalReferences

	// Defined Names
	DefinedNames *CT_DefinedNames

	// Calculation Properties
	CalcPr *CT_CalcPr

	// Embedded Object Size
	OleSize *CT_OleSize

	// Custom Workbook Views
	CustomWorkbookViews *CT_CustomWorkbookViews

	// PivotCaches
	PivotCaches *CT_PivotCaches

	// Smart Tag Properties
	SmartTagPr *CT_SmartTagPr

	// Smart Tag Types
	SmartTagTypes *CT_SmartTagTypes

	// Web Publishing Properties
	WebPublishing *CT_WebPublishing

	// File Recovery Properties
	FileRecoveryPr []*CT_FileRecoveryPr

	// Web Publish Objects
	WebPublishObjects *CT_WebPublishObjects

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

const (
	ST_SortTypeUnset             ST_SortType = 0
	ST_SortTypeNone              ST_SortType = 1
	ST_SortTypeAscending         ST_SortType = 2
	ST_SortTypeDescending        ST_SortType = 3
	ST_SortTypeAscendingAlpha    ST_SortType = 4
	ST_SortTypeDescendingAlpha   ST_SortType = 5
	ST_SortTypeAscendingNatural  ST_SortType = 6
	ST_SortTypeDescendingNatural ST_SortType = 7
)

// Validate validates the CT_ObjectPr and its children
func (_bbfbc *CT_ObjectPr) Validate() error { return _bbfbc.ValidateWithPath("CT_ObjectPr") }
func (_befbed *CT_GroupItems) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dbddb := range start.Attr {
		if _dbddb.Name.Local == "count" {
			_dbfa, _ggfd := _g.ParseUint(_dbddb.Value, 10, 32)
			if _ggfd != nil {
				return _ggfd
			}
			_dafee := uint32(_dbfa)
			_befbed.CountAttr = &_dafee
			continue
		}
	}
_abefb:
	for {
		_adfcb, _cabee := d.Token()
		if _cabee != nil {
			return _cabee
		}
		switch _cbbaa := _adfcb.(type) {
		case _f.StartElement:
			switch _cbbaa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "m"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "m"}:
				_debeb := NewCT_Missing()
				if _egag := d.DecodeElement(_debeb, &_cbbaa); _egag != nil {
					return _egag
				}
				_befbed.M = append(_befbed.M, _debeb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "n"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "n"}:
				_bgced := NewCT_Number()
				if _dgdc := d.DecodeElement(_bgced, &_cbbaa); _dgdc != nil {
					return _dgdc
				}
				_befbed.N = append(_befbed.N, _bgced)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "b"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "b"}:
				_ccagf := NewCT_Boolean()
				if _gccdcd := d.DecodeElement(_ccagf, &_cbbaa); _gccdcd != nil {
					return _gccdcd
				}
				_befbed.B = append(_befbed.B, _ccagf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "e"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "e"}:
				_abede := NewCT_Error()
				if _dccbg := d.DecodeElement(_abede, &_cbbaa); _dccbg != nil {
					return _dccbg
				}
				_befbed.E = append(_befbed.E, _abede)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "s"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "s"}:
				_cacdc := NewCT_String()
				if _dgdbc := d.DecodeElement(_cacdc, &_cbbaa); _dgdbc != nil {
					return _dgdbc
				}
				_befbed.S = append(_befbed.S, _cacdc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "d"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "d"}:
				_deega := NewCT_DateTime()
				if _ggfa := d.DecodeElement(_deega, &_cbbaa); _ggfa != nil {
					return _ggfa
				}
				_befbed.D = append(_befbed.D, _deega)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_GroupItems \u0025v", _cbbaa.Name)
				if _fbeebd := d.Skip(); _fbeebd != nil {
					return _fbeebd
				}
			}
		case _f.EndElement:
			break _abefb
		case _f.CharData:
		}
	}
	return nil
}
func (_abgc *CT_RevisionHeaders) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_abgc.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	for _, _eagef := range start.Attr {
		if _eagef.Name.Local == "exclusive" {
			_ecggge, _cgggge := _g.ParseBool(_eagef.Value)
			if _cgggge != nil {
				return _cgggge
			}
			_abgc.ExclusiveAttr = &_ecggge
			continue
		}
		if _eagef.Name.Local == "lastGuid" {
			_bdcbbd, _bggbb := _eagef.Value, error(nil)
			if _bggbb != nil {
				return _bggbb
			}
			_abgc.LastGuidAttr = &_bdcbbd
			continue
		}
		if _eagef.Name.Local == "shared" {
			_faggeg, _dbgcd := _g.ParseBool(_eagef.Value)
			if _dbgcd != nil {
				return _dbgcd
			}
			_abgc.SharedAttr = &_faggeg
			continue
		}
		if _eagef.Name.Local == "diskRevisions" {
			_fgeac, _dgacc := _g.ParseBool(_eagef.Value)
			if _dgacc != nil {
				return _dgacc
			}
			_abgc.DiskRevisionsAttr = &_fgeac
			continue
		}
		if _eagef.Name.Local == "history" {
			_cbgfc, _fcacg := _g.ParseBool(_eagef.Value)
			if _fcacg != nil {
				return _fcacg
			}
			_abgc.HistoryAttr = &_cbgfc
			continue
		}
		if _eagef.Name.Local == "trackRevisions" {
			_fedfg, _gfdea := _g.ParseBool(_eagef.Value)
			if _gfdea != nil {
				return _gfdea
			}
			_abgc.TrackRevisionsAttr = &_fedfg
			continue
		}
		if _eagef.Name.Local == "guid" {
			_agcac, _febdc := _eagef.Value, error(nil)
			if _febdc != nil {
				return _febdc
			}
			_abgc.GuidAttr = _agcac
			continue
		}
		if _eagef.Name.Local == "revisionId" {
			_gegga, _eebge := _g.ParseUint(_eagef.Value, 10, 32)
			if _eebge != nil {
				return _eebge
			}
			_dffgbd := uint32(_gegga)
			_abgc.RevisionIdAttr = &_dffgbd
			continue
		}
		if _eagef.Name.Local == "version" {
			_dffbdc, _eebac := _g.ParseInt(_eagef.Value, 10, 32)
			if _eebac != nil {
				return _eebac
			}
			_efebe := int32(_dffbdc)
			_abgc.VersionAttr = &_efebe
			continue
		}
		if _eagef.Name.Local == "keepChangeHistory" {
			_cdfdb, _bbabf := _g.ParseBool(_eagef.Value)
			if _bbabf != nil {
				return _bbabf
			}
			_abgc.KeepChangeHistoryAttr = &_cdfdb
			continue
		}
		if _eagef.Name.Local == "protected" {
			_cffca, _ccbcf := _g.ParseBool(_eagef.Value)
			if _ccbcf != nil {
				return _ccbcf
			}
			_abgc.ProtectedAttr = &_cffca
			continue
		}
		if _eagef.Name.Local == "preserveHistory" {
			_acba, _dfabe := _g.ParseUint(_eagef.Value, 10, 32)
			if _dfabe != nil {
				return _dfabe
			}
			_acfaca := uint32(_acba)
			_abgc.PreserveHistoryAttr = &_acfaca
			continue
		}
	}
_fabgg:
	for {
		_eecba, _cgfde := d.Token()
		if _cgfde != nil {
			return _cgfde
		}
		switch _fddag := _eecba.(type) {
		case _f.StartElement:
			switch _fddag.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "header"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "header"}:
				_abbdg := NewCT_RevisionHeader()
				if _ccadec := d.DecodeElement(_abbdg, &_fddag); _ccadec != nil {
					return _ccadec
				}
				_abgc.Header = append(_abgc.Header, _abbdg)
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_RevisionHeaders\u0020\u0025v", _fddag.Name)
				if _adbdb := d.Skip(); _adbdb != nil {
					return _adbdb
				}
			}
		case _f.EndElement:
			break _fabgg
		case _f.CharData:
		}
	}
	return nil
}

type ST_CalcMode byte

func (_bdfdd ST_GrowShrinkType) ValidateWithPath(path string) error {
	switch _bdfdd {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bdfdd))
	}
	return nil
}
func (_befecf ST_SortBy) String() string {
	switch _befecf {
	case 0:
		return ""
	case 1:
		return "value"
	case 2:
		return "cellColor"
	case 3:
		return "fontColor"
	case 4:
		return "icon"
	}
	return ""
}

// ValidateWithPath validates the CT_SheetDimension and its children, prefixing error messages with path
func (_efbacb *CT_SheetDimension) ValidateWithPath(path string) error { return nil }
func (_ffgcb *CT_Fill) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_eccac:
	for {
		_gbgd, _caegg := d.Token()
		if _caegg != nil {
			return _caegg
		}
		switch _eccf := _gbgd.(type) {
		case _f.StartElement:
			switch _eccf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "patternFill"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "patternFill"}:
				_ffgcb.PatternFill = NewCT_PatternFill()
				if _bbacb := d.DecodeElement(_ffgcb.PatternFill, &_eccf); _bbacb != nil {
					return _bbacb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "gradientFill"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "gradientFill"}:
				_ffgcb.GradientFill = NewCT_GradientFill()
				if _aeegc := d.DecodeElement(_ffgcb.GradientFill, &_eccf); _aeegc != nil {
					return _aeegc
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Fill\u0020\u0025v", _eccf.Name)
				if _decfb := d.Skip(); _decfb != nil {
					return _decfb
				}
			}
		case _f.EndElement:
			break _eccac
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Cols and its children, prefixing error messages with path
func (_ccdgd *CT_Cols) ValidateWithPath(path string) error {
	for _fdce, _fdfggb := range _ccdgd.Col {
		if _egea := _fdfggb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCol\u005b\u0025d\u005d", path, _fdce)); _egea != nil {
			return _egea
		}
	}
	return nil
}
func (_abfec *ST_MdxSetOrder) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dddff, _bedfd := d.Token()
	if _bedfd != nil {
		return _bedfd
	}
	if _efaggg, _ggdedc := _dddff.(_f.EndElement); _ggdedc && _efaggg.Name == start.Name {
		*_abfec = 1
		return nil
	}
	if _fageba, _afccd := _dddff.(_f.CharData); !_afccd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dddff)
	} else {
		switch string(_fageba) {
		case "":
			*_abfec = 0
		case "u":
			*_abfec = 1
		case "a":
			*_abfec = 2
		case "d":
			*_abfec = 3
		case "aa":
			*_abfec = 4
		case "ad":
			*_abfec = 5
		case "na":
			*_abfec = 6
		case "nd":
			*_abfec = 7
		}
	}
	_dddff, _bedfd = d.Token()
	if _bedfd != nil {
		return _bedfd
	}
	if _fafbcb, _bgefb := _dddff.(_f.EndElement); _bgefb && _fafbcb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dddff)
}
func (_bagbb *CT_MeasureGroups) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cbacc := range start.Attr {
		if _cbacc.Name.Local == "count" {
			_babbf, _feddc := _g.ParseUint(_cbacc.Value, 10, 32)
			if _feddc != nil {
				return _feddc
			}
			_dedbd := uint32(_babbf)
			_bagbb.CountAttr = &_dedbd
			continue
		}
	}
_fcbfe:
	for {
		_abbbe, _gaggd := d.Token()
		if _gaggd != nil {
			return _gaggd
		}
		switch _beffg := _abbbe.(type) {
		case _f.StartElement:
			switch _beffg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "measureGroup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "measureGroup"}:
				_cdafec := NewCT_MeasureGroup()
				if _geaaa := d.DecodeElement(_cdafec, &_beffg); _geaaa != nil {
					return _geaaa
				}
				_bagbb.MeasureGroup = append(_bagbb.MeasureGroup, _cdafec)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_MeasureGroups\u0020\u0025v", _beffg.Name)
				if _aeecaa := d.Skip(); _aeecaa != nil {
					return _aeecaa
				}
			}
		case _f.EndElement:
			break _fcbfe
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Scenario and its children, prefixing error messages with path
func (_gabegb *CT_Scenario) ValidateWithPath(path string) error {
	for _bbbeb, _ecccfc := range _gabegb.InputCells {
		if _acca := _ecccfc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fInputCells\u005b\u0025d\u005d", path, _bbbeb)); _acca != nil {
			return _acca
		}
	}
	return nil
}
func (_fadad *CT_PivotHierarchy) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cagdb := range start.Attr {
		if _cagdb.Name.Local == "dragToData" {
			_dddgaf, _aacfda := _g.ParseBool(_cagdb.Value)
			if _aacfda != nil {
				return _aacfda
			}
			_fadad.DragToDataAttr = &_dddgaf
			continue
		}
		if _cagdb.Name.Local == "outline" {
			_cccbf, _geffg := _g.ParseBool(_cagdb.Value)
			if _geffg != nil {
				return _geffg
			}
			_fadad.OutlineAttr = &_cccbf
			continue
		}
		if _cagdb.Name.Local == "subtotalTop" {
			_dabefe, _cgead := _g.ParseBool(_cagdb.Value)
			if _cgead != nil {
				return _cgead
			}
			_fadad.SubtotalTopAttr = &_dabefe
			continue
		}
		if _cagdb.Name.Local == "showInFieldList" {
			_adgeg, _cegfff := _g.ParseBool(_cagdb.Value)
			if _cegfff != nil {
				return _cegfff
			}
			_fadad.ShowInFieldListAttr = &_adgeg
			continue
		}
		if _cagdb.Name.Local == "dragToRow" {
			_bbgbd, _ddafc := _g.ParseBool(_cagdb.Value)
			if _ddafc != nil {
				return _ddafc
			}
			_fadad.DragToRowAttr = &_bbgbd
			continue
		}
		if _cagdb.Name.Local == "dragToCol" {
			_efbdd, _ccegfb := _g.ParseBool(_cagdb.Value)
			if _ccegfb != nil {
				return _ccegfb
			}
			_fadad.DragToColAttr = &_efbdd
			continue
		}
		if _cagdb.Name.Local == "dragToPage" {
			_dffbda, _cfaab := _g.ParseBool(_cagdb.Value)
			if _cfaab != nil {
				return _cfaab
			}
			_fadad.DragToPageAttr = &_dffbda
			continue
		}
		if _cagdb.Name.Local == "multipleItemSelectionAllowed" {
			_adafe, _efgcd := _g.ParseBool(_cagdb.Value)
			if _efgcd != nil {
				return _efgcd
			}
			_fadad.MultipleItemSelectionAllowedAttr = &_adafe
			continue
		}
		if _cagdb.Name.Local == "dragOff" {
			_gfaffd, _beffad := _g.ParseBool(_cagdb.Value)
			if _beffad != nil {
				return _beffad
			}
			_fadad.DragOffAttr = &_gfaffd
			continue
		}
		if _cagdb.Name.Local == "includeNewItemsInFilter" {
			_bdcdd, _ggdgb := _g.ParseBool(_cagdb.Value)
			if _ggdgb != nil {
				return _ggdgb
			}
			_fadad.IncludeNewItemsInFilterAttr = &_bdcdd
			continue
		}
		if _cagdb.Name.Local == "caption" {
			_deddg, _ecgff := _cagdb.Value, error(nil)
			if _ecgff != nil {
				return _ecgff
			}
			_fadad.CaptionAttr = &_deddg
			continue
		}
	}
_fbfce:
	for {
		_edgbd, _edbdd := d.Token()
		if _edbdd != nil {
			return _edbdd
		}
		switch _bccag := _edgbd.(type) {
		case _f.StartElement:
			switch _bccag.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "mps"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "mps"}:
				_fadad.Mps = NewCT_MemberProperties()
				if _befecg := d.DecodeElement(_fadad.Mps, &_bccag); _befecg != nil {
					return _befecg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "members"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "members"}:
				_cfcfg := NewCT_Members()
				if _fgfdc := d.DecodeElement(_cfcfg, &_bccag); _fgfdc != nil {
					return _fgfdc
				}
				_fadad.Members = append(_fadad.Members, _cfcfg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_fadad.ExtLst = NewCT_ExtensionList()
				if _cgafg := d.DecodeElement(_fadad.ExtLst, &_bccag); _cgafg != nil {
					return _cgafg
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_PivotHierarchy\u0020\u0025v", _bccag.Name)
				if _efac := d.Skip(); _efac != nil {
					return _efac
				}
			}
		case _f.EndElement:
			break _fbfce
		case _f.CharData:
		}
	}
	return nil
}
func (_dgbcag *CT_MemberProperties) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abddgg := range start.Attr {
		if _abddgg.Name.Local == "count" {
			_bccgc, _gfdc := _g.ParseUint(_abddgg.Value, 10, 32)
			if _gfdc != nil {
				return _gfdc
			}
			_aaffc := uint32(_bccgc)
			_dgbcag.CountAttr = &_aaffc
			continue
		}
	}
_egagg:
	for {
		_cdcef, _bgfd := d.Token()
		if _bgfd != nil {
			return _bgfd
		}
		switch _feecf := _cdcef.(type) {
		case _f.StartElement:
			switch _feecf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "mp"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "mp"}:
				_aeddg := NewCT_MemberProperty()
				if _ggeaga := d.DecodeElement(_aeddg, &_feecf); _ggeaga != nil {
					return _ggeaga
				}
				_dgbcag.Mp = append(_dgbcag.Mp, _aeddg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_MemberProperties\u0020\u0025v", _feecf.Name)
				if _dfdeg := d.Skip(); _dfdeg != nil {
					return _dfdeg
				}
			}
		case _f.EndElement:
			break _egagg
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_SortCondition() *CT_SortCondition { _eacef := &CT_SortCondition{}; return _eacef }

// ValidateWithPath validates the CT_TableColumn and its children, prefixing error messages with path
func (_eggddb *CT_TableColumn) ValidateWithPath(path string) error {
	if _bfebe := _eggddb.TotalsRowFunctionAttr.ValidateWithPath(path + "\u002fTotalsRowFunctionAttr"); _bfebe != nil {
		return _bfebe
	}
	if _eggddb.CalculatedColumnFormula != nil {
		if _fdcbgdb := _eggddb.CalculatedColumnFormula.ValidateWithPath(path + "\u002fCalculatedColumnFormula"); _fdcbgdb != nil {
			return _fdcbgdb
		}
	}
	if _eggddb.TotalsRowFormula != nil {
		if _baega := _eggddb.TotalsRowFormula.ValidateWithPath(path + "\u002fTotalsRowFormula"); _baega != nil {
			return _baega
		}
	}
	if _eggddb.XmlColumnPr != nil {
		if _gggf := _eggddb.XmlColumnPr.ValidateWithPath(path + "\u002fXmlColumnPr"); _gggf != nil {
			return _gggf
		}
	}
	if _eggddb.ExtLst != nil {
		if _ageae := _eggddb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ageae != nil {
			return _ageae
		}
	}
	return nil
}

// Validate validates the CT_Hyperlink and its children
func (_effegg *CT_Hyperlink) Validate() error { return _effegg.ValidateWithPath("CT_Hyperlink") }
func (_gagdg *StyleSheet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gagdg.CT_Stylesheet = *NewCT_Stylesheet()
_faffa:
	for {
		_cdcdc, _cbgde := d.Token()
		if _cbgde != nil {
			return _cbgde
		}
		switch _fcdgf := _cdcdc.(type) {
		case _f.StartElement:
			switch _fcdgf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "numFmts"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "numFmts"}:
				_gagdg.NumFmts = NewCT_NumFmts()
				if _gebfce := d.DecodeElement(_gagdg.NumFmts, &_fcdgf); _gebfce != nil {
					return _gebfce
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fonts"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fonts"}:
				_gagdg.Fonts = NewCT_Fonts()
				if _ecbdc := d.DecodeElement(_gagdg.Fonts, &_fcdgf); _ecbdc != nil {
					return _ecbdc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fills"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fills"}:
				_gagdg.Fills = NewCT_Fills()
				if _agefg := d.DecodeElement(_gagdg.Fills, &_fcdgf); _agefg != nil {
					return _agefg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "borders"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "borders"}:
				_gagdg.Borders = NewCT_Borders()
				if _bbdafe := d.DecodeElement(_gagdg.Borders, &_fcdgf); _bbdafe != nil {
					return _bbdafe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellStyleXfs"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellStyleXfs"}:
				_gagdg.CellStyleXfs = NewCT_CellStyleXfs()
				if _ebagab := d.DecodeElement(_gagdg.CellStyleXfs, &_fcdgf); _ebagab != nil {
					return _ebagab
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellXfs"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellXfs"}:
				_gagdg.CellXfs = NewCT_CellXfs()
				if _ecbdg := d.DecodeElement(_gagdg.CellXfs, &_fcdgf); _ecbdg != nil {
					return _ecbdg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellStyles"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellStyles"}:
				_gagdg.CellStyles = NewCT_CellStyles()
				if _fddda := d.DecodeElement(_gagdg.CellStyles, &_fcdgf); _fddda != nil {
					return _fddda
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dxfs"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dxfs"}:
				_gagdg.Dxfs = NewCT_Dxfs()
				if _deacff := d.DecodeElement(_gagdg.Dxfs, &_fcdgf); _deacff != nil {
					return _deacff
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tableStyles"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tableStyles"}:
				_gagdg.TableStyles = NewCT_TableStyles()
				if _ebgca := d.DecodeElement(_gagdg.TableStyles, &_fcdgf); _ebgca != nil {
					return _ebgca
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colors"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colors"}:
				_gagdg.Colors = NewCT_Colors()
				if _dcbcb := d.DecodeElement(_gagdg.Colors, &_fcdgf); _dcbcb != nil {
					return _dcbcb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gagdg.ExtLst = NewCT_ExtensionList()
				if _bgbbcba := d.DecodeElement(_gagdg.ExtLst, &_fcdgf); _bgbbcba != nil {
					return _bgbbcba
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020StyleSheet\u0020\u0025v", _fcdgf.Name)
				if _gdfbf := d.Skip(); _gdfbf != nil {
					return _gdfbf
				}
			}
		case _f.EndElement:
			break _faffa
		case _f.CharData:
		}
	}
	return nil
}
func (_dabbbc ST_DynamicFilterType) String() string {
	switch _dabbbc {
	case 0:
		return ""
	case 1:
		return "null"
	case 2:
		return "aboveAverage"
	case 3:
		return "belowAverage"
	case 4:
		return "tomorrow"
	case 5:
		return "today"
	case 6:
		return "yesterday"
	case 7:
		return "nextWeek"
	case 8:
		return "thisWeek"
	case 9:
		return "lastWeek"
	case 10:
		return "nextMonth"
	case 11:
		return "thisMonth"
	case 12:
		return "lastMonth"
	case 13:
		return "nextQuarter"
	case 14:
		return "thisQuarter"
	case 15:
		return "lastQuarter"
	case 16:
		return "nextYear"
	case 17:
		return "thisYear"
	case 18:
		return "lastYear"
	case 19:
		return "yearToDate"
	case 20:
		return "Q1"
	case 21:
		return "Q2"
	case 22:
		return "Q3"
	case 23:
		return "Q4"
	case 24:
		return "M1"
	case 25:
		return "M2"
	case 26:
		return "M3"
	case 27:
		return "M4"
	case 28:
		return "M5"
	case 29:
		return "M6"
	case 30:
		return "M7"
	case 31:
		return "M8"
	case 32:
		return "M9"
	case 33:
		return "M10"
	case 34:
		return "M11"
	case 35:
		return "M12"
	}
	return ""
}

const (
	ST_SortMethodUnset  ST_SortMethod = 0
	ST_SortMethodStroke ST_SortMethod = 1
	ST_SortMethodPinYin ST_SortMethod = 2
	ST_SortMethodNone   ST_SortMethod = 3
)

type CT_IconFilter struct {

	// Icon Set
	IconSetAttr ST_IconSetType

	// Icon Id
	IconIdAttr *uint32
}

// Validate validates the CT_ChartsheetViews and its children
func (_caea *CT_ChartsheetViews) Validate() error {
	return _caea.ValidateWithPath("CT_ChartsheetViews")
}
func NewCT_Drawing() *CT_Drawing { _cddee := &CT_Drawing{}; return _cddee }

// Validate validates the CT_MdxSet and its children
func (_bgggg *CT_MdxSet) Validate() error          { return _bgggg.ValidateWithPath("CT_MdxSet") }
func NewCT_MemberProperties() *CT_MemberProperties { _aabbf := &CT_MemberProperties{}; return _aabbf }

// Validate validates the CT_WorkbookProtection and its children
func (_gfbfe *CT_WorkbookProtection) Validate() error {
	return _gfbfe.ValidateWithPath("CT_WorkbookProtection")
}

// ValidateWithPath validates the CT_Table and its children, prefixing error messages with path
func (_babce *CT_Table) ValidateWithPath(path string) error {
	if _fcgad := _babce.TableTypeAttr.ValidateWithPath(path + "\u002fTableTypeAttr"); _fcgad != nil {
		return _fcgad
	}
	if _babce.AutoFilter != nil {
		if _bcebgd := _babce.AutoFilter.ValidateWithPath(path + "/AutoFilter"); _bcebgd != nil {
			return _bcebgd
		}
	}
	if _babce.SortState != nil {
		if _dedff := _babce.SortState.ValidateWithPath(path + "\u002fSortState"); _dedff != nil {
			return _dedff
		}
	}
	if _fcage := _babce.TableColumns.ValidateWithPath(path + "\u002fTableColumns"); _fcage != nil {
		return _fcage
	}
	if _babce.TableStyleInfo != nil {
		if _gefcad := _babce.TableStyleInfo.ValidateWithPath(path + "\u002fTableStyleInfo"); _gefcad != nil {
			return _gefcad
		}
	}
	if _babce.ExtLst != nil {
		if _egecb := _babce.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _egecb != nil {
			return _egecb
		}
	}
	return nil
}
func (_bfacf *CT_RowHierarchiesUsage) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cgba := range start.Attr {
		if _cgba.Name.Local == "count" {
			_dbgbg, _aagceb := _g.ParseUint(_cgba.Value, 10, 32)
			if _aagceb != nil {
				return _aagceb
			}
			_fffcd := uint32(_dbgbg)
			_bfacf.CountAttr = &_fffcd
			continue
		}
	}
_cgbegd:
	for {
		_afdee, _eacfcf := d.Token()
		if _eacfcf != nil {
			return _eacfcf
		}
		switch _aeddcd := _afdee.(type) {
		case _f.StartElement:
			switch _aeddcd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rowHierarchyUsage"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rowHierarchyUsage"}:
				_adfbc := NewCT_HierarchyUsage()
				if _fdcda := d.DecodeElement(_adfbc, &_aeddcd); _fdcda != nil {
					return _fdcda
				}
				_bfacf.RowHierarchyUsage = append(_bfacf.RowHierarchyUsage, _adfbc)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RowHierarchiesUsage\u0020\u0025v", _aeddcd.Name)
				if _bdgdd := d.Skip(); _bdgdd != nil {
					return _bdgdd
				}
			}
		case _f.EndElement:
			break _cgbegd
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_XmlColumnPr and its children, prefixing error messages with path
func (_fgbabc *CT_XmlColumnPr) ValidateWithPath(path string) error {
	if _fgbabc.ExtLst != nil {
		if _feada := _fgbabc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _feada != nil {
			return _feada
		}
	}
	return nil
}

// Validate validates the CT_UndoInfo and its children
func (_dcgfe *CT_UndoInfo) Validate() error { return _dcgfe.ValidateWithPath("CT_UndoInfo") }
func NewCT_RowHierarchiesUsage() *CT_RowHierarchiesUsage {
	_baedee := &CT_RowHierarchiesUsage{}
	return _baedee
}

// ValidateWithPath validates the CT_OleItems and its children, prefixing error messages with path
func (_gdade *CT_OleItems) ValidateWithPath(path string) error {
	for _fggfc, _fcdfd := range _gdade.OleItem {
		if _gedeb := _fcdfd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fOleItem\u005b\u0025d\u005d", path, _fggfc)); _gedeb != nil {
			return _gedeb
		}
	}
	return nil
}

type CT_FutureMetadataBlock struct {

	// Future Feature Storage Area
	ExtLst *CT_ExtensionList
}

const (
	ST_CredMethodUnset      ST_CredMethod = 0
	ST_CredMethodIntegrated ST_CredMethod = 1
	ST_CredMethodNone       ST_CredMethod = 2
	ST_CredMethodStored     ST_CredMethod = 3
	ST_CredMethodPrompt     ST_CredMethod = 4
)

func (_dcfcc ST_HorizontalAlignment) String() string {
	switch _dcfcc {
	case 0:
		return ""
	case 1:
		return "general"
	case 2:
		return "left"
	case 3:
		return "center"
	case 4:
		return "right"
	case 5:
		return "fill"
	case 6:
		return "justify"
	case 7:
		return "centerContinuous"
	case 8:
		return "distributed"
	}
	return ""
}

type CT_IgnoredError struct {

	// Sequence of References
	SqrefAttr ST_Sqref

	// Evaluation Error
	EvalErrorAttr *bool

	// Two Digit Text Year
	TwoDigitTextYearAttr *bool

	// Number Stored As Text
	NumberStoredAsTextAttr *bool

	// Formula
	FormulaAttr *bool

	// Formula Range
	FormulaRangeAttr *bool

	// Unlocked Formula
	UnlockedFormulaAttr *bool

	// Empty Cell Reference
	EmptyCellReferenceAttr *bool

	// List Data Validation
	ListDataValidationAttr *bool

	// Calculated Column
	CalculatedColumnAttr *bool
}

func (_feggg *CT_TableMissing) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_VolType and its children, prefixing error messages with path
func (_adbced *CT_VolType) ValidateWithPath(path string) error {
	if _adbced.TypeAttr == ST_VolDepTypeUnset {
		return _bg.Errorf("\u0025s\u002fTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _dfcfb := _adbced.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _dfcfb != nil {
		return _dfcfb
	}
	for _agdgba, _addfbe := range _adbced.Main {
		if _gegbg := _addfbe.ValidateWithPath(_bg.Sprintf("%s\u002fMain\u005b\u0025d\u005d", path, _agdgba)); _gegbg != nil {
			return _gegbg
		}
	}
	return nil
}
func (_ccac *CT_Cell) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cfe := range start.Attr {
		if _cfe.Name.Local == "r" {
			_def, _gaca := _cfe.Value, error(nil)
			if _gaca != nil {
				return _gaca
			}
			_ccac.RAttr = &_def
			continue
		}
		if _cfe.Name.Local == "s" {
			_fdge, _ccbc := _g.ParseUint(_cfe.Value, 10, 32)
			if _ccbc != nil {
				return _ccbc
			}
			_acd := uint32(_fdge)
			_ccac.SAttr = &_acd
			continue
		}
		if _cfe.Name.Local == "t" {
			_ccac.TAttr.UnmarshalXMLAttr(_cfe)
			continue
		}
		if _cfe.Name.Local == "cm" {
			_cace, _abba := _g.ParseUint(_cfe.Value, 10, 32)
			if _abba != nil {
				return _abba
			}
			_ddaac := uint32(_cace)
			_ccac.CmAttr = &_ddaac
			continue
		}
		if _cfe.Name.Local == "vm" {
			_dfgd, _cbcd := _g.ParseUint(_cfe.Value, 10, 32)
			if _cbcd != nil {
				return _cbcd
			}
			_fcfd := uint32(_dfgd)
			_ccac.VmAttr = &_fcfd
			continue
		}
		if _cfe.Name.Local == "ph" {
			_dbdg, _fabb := _g.ParseBool(_cfe.Value)
			if _fabb != nil {
				return _fabb
			}
			_ccac.PhAttr = &_dbdg
			continue
		}
	}
_agab:
	for {
		_cbcb, _ccba := d.Token()
		if _ccba != nil {
			return _ccba
		}
		switch _gacc := _cbcb.(type) {
		case _f.StartElement:
			switch _gacc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "f"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "f"}:
				_ccac.F = NewCT_CellFormula()
				if _dffd := d.DecodeElement(_ccac.F, &_gacc); _dffd != nil {
					return _dffd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "v"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "v"}:
				_ccac.V = new(string)
				if _fabf := d.DecodeElement(_ccac.V, &_gacc); _fabf != nil {
					return _fabf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "is"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "is"}:
				_ccac.Is = NewCT_Rst()
				if _fccb := d.DecodeElement(_ccac.Is, &_gacc); _fccb != nil {
					return _fccb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ccac.ExtLst = NewCT_ExtensionList()
				if _ddfb := d.DecodeElement(_ccac.ExtLst, &_gacc); _ddfb != nil {
					return _ddfb
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Cell\u0020\u0025v", _gacc.Name)
				if _bde := d.Skip(); _bde != nil {
					return _bde
				}
			}
		case _f.EndElement:
			break _agab
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_DefinedName() *CT_DefinedName { _accg := &CT_DefinedName{}; return _accg }

type ST_TableStyleType byte

// Validate validates the CT_RevisionHeader and its children
func (_dgcdgd *CT_RevisionHeader) Validate() error {
	return _dgcdgd.ValidateWithPath("CT_RevisionHeader")
}

type Dialogsheet struct{ CT_Dialogsheet }

func (_beeac ST_GradientType) Validate() error { return _beeac.ValidateWithPath("") }
func (_gbdaf ST_GradientType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_egbbbg := _f.Attr{}
	_egbbbg.Name = name
	switch _gbdaf {
	case ST_GradientTypeUnset:
		_egbbbg.Value = ""
	case ST_GradientTypeLinear:
		_egbbbg.Value = "linear"
	case ST_GradientTypePath:
		_egbbbg.Value = "path"
	}
	return _egbbbg, nil
}
func NewWorkbook() *Workbook {
	_fgabe := &Workbook{}
	_fgabe.CT_Workbook = *NewCT_Workbook()
	return _fgabe
}
func (_cccfb ST_Pane) String() string {
	switch _cccfb {
	case 0:
		return ""
	case 1:
		return "bottomRight"
	case 2:
		return "topRight"
	case 3:
		return "bottomLeft"
	case 4:
		return "topLeft"
	}
	return ""
}

type CT_PageSetup struct {

	// Paper Size
	PaperSizeAttr *uint32

	// Paper Height
	PaperHeightAttr *string

	// Paper Width
	PaperWidthAttr *string

	// Print Scale
	ScaleAttr *uint32

	// First Page Number
	FirstPageNumberAttr *uint32

	// Fit To Width
	FitToWidthAttr *uint32

	// Fit To Height
	FitToHeightAttr *uint32

	// Page Order
	PageOrderAttr ST_PageOrder

	// Orientation
	OrientationAttr ST_Orientation

	// Use Printer Defaults
	UsePrinterDefaultsAttr *bool

	// Black And White
	BlackAndWhiteAttr *bool

	// Draft
	DraftAttr *bool

	// Print Cell Comments
	CellCommentsAttr ST_CellComments

	// Use First Page Number
	UseFirstPageNumberAttr *bool

	// Print Error Handling
	ErrorsAttr ST_PrintError

	// Horizontal DPI
	HorizontalDpiAttr *uint32

	// Vertical DPI
	VerticalDpiAttr *uint32

	// Number Of Copies
	CopiesAttr *uint32
	IdAttr     *string
}

func NewCT_PivotAreaReference() *CT_PivotAreaReference {
	_eddgg := &CT_PivotAreaReference{}
	return _eddgg
}

// ValidateWithPath validates the CT_PageSetUpPr and its children, prefixing error messages with path
func (_cddbe *CT_PageSetUpPr) ValidateWithPath(path string) error { return nil }

type CT_WebPublishItem struct {

	// Id
	IdAttr uint32

	// Destination Bookmark
	DivIdAttr string

	// Web Source Type
	SourceTypeAttr ST_WebSourceType

	// Source Id
	SourceRefAttr *string

	// Source Object Name
	SourceObjectAttr *string

	// Destination File Name
	DestinationFileAttr string

	// Title
	TitleAttr *string

	// Automatically Publish
	AutoRepublishAttr *bool
}

func NewCT_CsPageSetup() *CT_CsPageSetup { _dbgb := &CT_CsPageSetup{}; return _dbgb }
func (_gacb *CT_CellProtection) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gacb.LockedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "locked"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gacb.LockedAttr))})
	}
	if _gacb.HiddenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hidden"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gacb.HiddenAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_SheetCalcPr and its children, prefixing error messages with path
func (_fbcfc *CT_SheetCalcPr) ValidateWithPath(path string) error { return nil }

type CT_DefinedNames struct {

	// Defined Name
	DefinedName []*CT_DefinedName
}

func (_caaae *CT_DdeItem) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _caaae.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_caaae.NameAttr)})
	}
	if _caaae.OleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ole"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caaae.OleAttr))})
	}
	if _caaae.AdviseAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "advise"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caaae.AdviseAttr))})
	}
	if _caaae.PreferPicAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "preferPic"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_caaae.PreferPicAttr))})
	}
	e.EncodeToken(start)
	if _caaae.Values != nil {
		_deee := _f.StartElement{Name: _f.Name{Local: "ma:values"}}
		e.EncodeElement(_caaae.Values, _deee)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_aagd *CT_CalculatedItems) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aagd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_aagd.CountAttr)})
	}
	e.EncodeToken(start)
	_cbgb := _f.StartElement{Name: _f.Name{Local: "ma:calculatedItem"}}
	for _, _gbcc := range _aagd.CalculatedItem {
		e.EncodeElement(_gbcc, _cbgb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_FontName() *CT_FontName { _dceg := &CT_FontName{}; return _dceg }
func (_dedcb *CT_MetadataBlocks) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dedcb.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_dedcb.CountAttr)})
	}
	e.EncodeToken(start)
	_decdc := _f.StartElement{Name: _f.Name{Local: "ma:bk"}}
	for _, _ebegg := range _dedcb.Bk {
		e.EncodeElement(_ebegg, _decdc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_efggb *CT_InputCells) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", _efggb.RAttr)})
	if _efggb.DeletedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "deleted"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_efggb.DeletedAttr))})
	}
	if _efggb.UndoneAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "undone"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_efggb.UndoneAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", _efggb.ValAttr)})
	if _efggb.NumFmtIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "numFmtId"}, Value: _bg.Sprintf("\u0025v", *_efggb.NumFmtIdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_babfe ST_CfType) Validate() error { return _babfe.ValidateWithPath("") }
func (_edfbed *ST_Axis) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fadgff, _cegdb := d.Token()
	if _cegdb != nil {
		return _cegdb
	}
	if _cabdb, _bbfec := _fadgff.(_f.EndElement); _bbfec && _cabdb.Name == start.Name {
		*_edfbed = 1
		return nil
	}
	if _fdbdbd, _cbdgd := _fadgff.(_f.CharData); !_cbdgd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fadgff)
	} else {
		switch string(_fdbdbd) {
		case "":
			*_edfbed = 0
		case "axisRow":
			*_edfbed = 1
		case "axisCol":
			*_edfbed = 2
		case "axisPage":
			*_edfbed = 3
		case "axisValues":
			*_edfbed = 4
		}
	}
	_fadgff, _cegdb = d.Token()
	if _cegdb != nil {
		return _cegdb
	}
	if _bdcfg, _eegfa := _fadgff.(_f.EndElement); _eegfa && _bdcfg.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fadgff)
}

// Validate validates the CT_SheetProtection and its children
func (_cgfdd *CT_SheetProtection) Validate() error {
	return _cgfdd.ValidateWithPath("CT_SheetProtection")
}
func (_bfggea ST_GrowShrinkType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_eafffg := _f.Attr{}
	_eafffg.Name = name
	switch _bfggea {
	case ST_GrowShrinkTypeUnset:
		_eafffg.Value = ""
	case ST_GrowShrinkTypeInsertDelete:
		_eafffg.Value = "insertDelete"
	case ST_GrowShrinkTypeInsertClear:
		_eafffg.Value = "insertClear"
	case ST_GrowShrinkTypeOverwriteClear:
		_eafffg.Value = "overwriteClear"
	}
	return _eafffg, nil
}
func (_geaca *CT_RPrElt) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _geaca.RFont != nil {
		_defcd := _f.StartElement{Name: _f.Name{Local: "ma:rFont"}}
		e.EncodeElement(_geaca.RFont, _defcd)
	}
	if _geaca.Charset != nil {
		_abbfea := _f.StartElement{Name: _f.Name{Local: "ma:charset"}}
		e.EncodeElement(_geaca.Charset, _abbfea)
	}
	if _geaca.Family != nil {
		_aedfb := _f.StartElement{Name: _f.Name{Local: "ma:family"}}
		e.EncodeElement(_geaca.Family, _aedfb)
	}
	if _geaca.B != nil {
		_gcabfg := _f.StartElement{Name: _f.Name{Local: "ma:b"}}
		e.EncodeElement(_geaca.B, _gcabfg)
	}
	if _geaca.I != nil {
		_gcddc := _f.StartElement{Name: _f.Name{Local: "ma:i"}}
		e.EncodeElement(_geaca.I, _gcddc)
	}
	if _geaca.Strike != nil {
		_feccdcg := _f.StartElement{Name: _f.Name{Local: "ma:strike"}}
		e.EncodeElement(_geaca.Strike, _feccdcg)
	}
	if _geaca.Outline != nil {
		_deaedd := _f.StartElement{Name: _f.Name{Local: "ma:outline"}}
		e.EncodeElement(_geaca.Outline, _deaedd)
	}
	if _geaca.Shadow != nil {
		_accbb := _f.StartElement{Name: _f.Name{Local: "ma:shadow"}}
		e.EncodeElement(_geaca.Shadow, _accbb)
	}
	if _geaca.Condense != nil {
		_fbacga := _f.StartElement{Name: _f.Name{Local: "ma:condense"}}
		e.EncodeElement(_geaca.Condense, _fbacga)
	}
	if _geaca.Extend != nil {
		_bfcee := _f.StartElement{Name: _f.Name{Local: "ma:extend"}}
		e.EncodeElement(_geaca.Extend, _bfcee)
	}
	if _geaca.Color != nil {
		_baffeg := _f.StartElement{Name: _f.Name{Local: "ma:color"}}
		e.EncodeElement(_geaca.Color, _baffeg)
	}
	if _geaca.Sz != nil {
		_daace := _f.StartElement{Name: _f.Name{Local: "ma:sz"}}
		e.EncodeElement(_geaca.Sz, _daace)
	}
	if _geaca.U != nil {
		_fdfeac := _f.StartElement{Name: _f.Name{Local: "ma:u"}}
		e.EncodeElement(_geaca.U, _fdfeac)
	}
	if _geaca.VertAlign != nil {
		_bdbce := _f.StartElement{Name: _f.Name{Local: "ma:vertAlign"}}
		e.EncodeElement(_geaca.VertAlign, _bdbce)
	}
	if _geaca.Scheme != nil {
		_dcdeb := _f.StartElement{Name: _f.Name{Local: "ma:scheme"}}
		e.EncodeElement(_geaca.Scheme, _dcdeb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cgea *CT_ExternalCell) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cgea.RAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", *_cgea.RAttr)})
	}
	if _cgea.TAttr != ST_CellTypeUnset {
		_ggaf, _ccbcb := _cgea.TAttr.MarshalXMLAttr(_f.Name{Local: "t"})
		if _ccbcb != nil {
			return _ccbcb
		}
		start.Attr = append(start.Attr, _ggaf)
	}
	if _cgea.VmAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "vm"}, Value: _bg.Sprintf("\u0025v", *_cgea.VmAttr)})
	}
	e.EncodeToken(start)
	if _cgea.V != nil {
		_fbafe := _f.StartElement{Name: _f.Name{Local: "ma:v"}}
		_cb.AddPreserveSpaceAttr(&_fbafe, *_cgea.V)
		e.EncodeElement(_cgea.V, _fbafe)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gfbbdd ST_PageOrder) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_cccge := _f.Attr{}
	_cccge.Name = name
	switch _gfbbdd {
	case ST_PageOrderUnset:
		_cccge.Value = ""
	case ST_PageOrderDownThenOver:
		_cccge.Value = "downThenOver"
	case ST_PageOrderOverThenDown:
		_cccge.Value = "overThenDown"
	}
	return _cccge, nil
}

// Validate validates the CT_Cols and its children
func (_eeeb *CT_Cols) Validate() error { return _eeeb.ValidateWithPath("CT_Cols") }
func (_gbeefc ST_RevisionAction) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_gbeefc.String(), start)
}
func NewCT_GradientStop() *CT_GradientStop {
	_efdbd := &CT_GradientStop{}
	_efdbd.Color = NewCT_Color()
	return _efdbd
}
func (_dffed *CT_RevisionRowColumn) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dffed.ActionAttr = ST_rwColActionType(1)
	for _, _gdbab := range start.Attr {
		if _gdbab.Name.Local == "sId" {
			_dgfad, _gbfcfc := _g.ParseUint(_gdbab.Value, 10, 32)
			if _gbfcfc != nil {
				return _gbfcfc
			}
			_dffed.SIdAttr = uint32(_dgfad)
			continue
		}
		if _gdbab.Name.Local == "eol" {
			_eebcg, _cfbfc := _g.ParseBool(_gdbab.Value)
			if _cfbfc != nil {
				return _cfbfc
			}
			_dffed.EolAttr = &_eebcg
			continue
		}
		if _gdbab.Name.Local == "ref" {
			_ecgec, _faeege := _gdbab.Value, error(nil)
			if _faeege != nil {
				return _faeege
			}
			_dffed.RefAttr = _ecgec
			continue
		}
		if _gdbab.Name.Local == "action" {
			_dffed.ActionAttr.UnmarshalXMLAttr(_gdbab)
			continue
		}
		if _gdbab.Name.Local == "edge" {
			_cccad, _fdege := _g.ParseBool(_gdbab.Value)
			if _fdege != nil {
				return _fdege
			}
			_dffed.EdgeAttr = &_cccad
			continue
		}
		if _gdbab.Name.Local == "rId" {
			_edeae, _egacee := _g.ParseUint(_gdbab.Value, 10, 32)
			if _egacee != nil {
				return _egacee
			}
			_cafecc := uint32(_edeae)
			_dffed.RIdAttr = &_cafecc
			continue
		}
		if _gdbab.Name.Local == "ua" {
			_ffgdf, _ebaac := _g.ParseBool(_gdbab.Value)
			if _ebaac != nil {
				return _ebaac
			}
			_dffed.UaAttr = &_ffgdf
			continue
		}
		if _gdbab.Name.Local == "ra" {
			_gacecg, _afgefc := _g.ParseBool(_gdbab.Value)
			if _afgefc != nil {
				return _afgefc
			}
			_dffed.RaAttr = &_gacecg
			continue
		}
	}
_eagdd:
	for {
		_cdecb, _ccbbba := d.Token()
		if _ccbbba != nil {
			return _ccbbba
		}
		switch _gdcbb := _cdecb.(type) {
		case _f.StartElement:
			switch _gdcbb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "undo"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "undo"}:
				_ecbadc := NewCT_UndoInfo()
				if _ceaga := d.DecodeElement(_ecbadc, &_gdcbb); _ceaga != nil {
					return _ceaga
				}
				_dffed.Undo = append(_dffed.Undo, _ecbadc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rcc"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rcc"}:
				_eaebf := NewCT_RevisionCellChange()
				if _cbbge := d.DecodeElement(_eaebf, &_gdcbb); _cbbge != nil {
					return _cbbge
				}
				_dffed.Rcc = append(_dffed.Rcc, _eaebf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rfmt"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rfmt"}:
				_bbbfbf := NewCT_RevisionFormatting()
				if _eegdf := d.DecodeElement(_bbbfbf, &_gdcbb); _eegdf != nil {
					return _eegdf
				}
				_dffed.Rfmt = append(_dffed.Rfmt, _bbbfbf)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on\u0020CT_RevisionRowColumn\u0020\u0025v", _gdcbb.Name)
				if _ebfca := d.Skip(); _ebfca != nil {
					return _ebfca
				}
			}
		case _f.EndElement:
			break _eagdd
		case _f.CharData:
		}
	}
	return nil
}
func (_gfagf *ST_DataValidationImeMode) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ecfeb, _gaedg := d.Token()
	if _gaedg != nil {
		return _gaedg
	}
	if _bdacf, _feega := _ecfeb.(_f.EndElement); _feega && _bdacf.Name == start.Name {
		*_gfagf = 1
		return nil
	}
	if _gbdab, _ggceec := _ecfeb.(_f.CharData); !_ggceec {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ecfeb)
	} else {
		switch string(_gbdab) {
		case "":
			*_gfagf = 0
		case "noControl":
			*_gfagf = 1
		case "off":
			*_gfagf = 2
		case "on":
			*_gfagf = 3
		case "disabled":
			*_gfagf = 4
		case "hiragana":
			*_gfagf = 5
		case "fullKatakana":
			*_gfagf = 6
		case "halfKatakana":
			*_gfagf = 7
		case "fullAlpha":
			*_gfagf = 8
		case "halfAlpha":
			*_gfagf = 9
		case "fullHangul":
			*_gfagf = 10
		case "halfHangul":
			*_gfagf = 11
		}
	}
	_ecfeb, _gaedg = d.Token()
	if _gaedg != nil {
		return _gaedg
	}
	if _afcedf, _cafbb := _ecfeb.(_f.EndElement); _cafbb && _afcedf.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ecfeb)
}
func ParseStdlibTime(s string) (_b.Time, error) { return _b.Time{}, nil }
func (_gbffb *ST_MdxKPIProperty) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_gbffb = 0
	case "v":
		*_gbffb = 1
	case "g":
		*_gbffb = 2
	case "s":
		*_gbffb = 3
	case "t":
		*_gbffb = 4
	case "w":
		*_gbffb = 5
	case "m":
		*_gbffb = 6
	}
	return nil
}
func (_cgad *CT_ChartFormat) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cgad.PivotArea = NewCT_PivotArea()
	for _, _fdcag := range start.Attr {
		if _fdcag.Name.Local == "chart" {
			_degb, _abfg := _g.ParseUint(_fdcag.Value, 10, 32)
			if _abfg != nil {
				return _abfg
			}
			_cgad.ChartAttr = uint32(_degb)
			continue
		}
		if _fdcag.Name.Local == "format" {
			_gfcd, _ecdf := _g.ParseUint(_fdcag.Value, 10, 32)
			if _ecdf != nil {
				return _ecdf
			}
			_cgad.FormatAttr = uint32(_gfcd)
			continue
		}
		if _fdcag.Name.Local == "series" {
			_gdfa, _faeb := _g.ParseBool(_fdcag.Value)
			if _faeb != nil {
				return _faeb
			}
			_cgad.SeriesAttr = &_gdfa
			continue
		}
	}
_cdbf:
	for {
		_ccc, _faag := d.Token()
		if _faag != nil {
			return _faag
		}
		switch _becd := _ccc.(type) {
		case _f.StartElement:
			switch _becd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotArea"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotArea"}:
				if _edbg := d.DecodeElement(_cgad.PivotArea, &_becd); _edbg != nil {
					return _edbg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ChartFormat\u0020\u0025v", _becd.Name)
				if _acfc := d.Skip(); _acfc != nil {
					return _acfc
				}
			}
		case _f.EndElement:
			break _cdbf
		case _f.CharData:
		}
	}
	return nil
}

type ST_Objects byte
type CT_Parameter struct {

	// Parameter Name
	NameAttr *string

	// SQL Data Type
	SqlTypeAttr *int32

	// Parameter Type
	ParameterTypeAttr ST_ParameterType

	// Refresh on Change
	RefreshOnChangeAttr *bool

	// Parameter Prompt String
	PromptAttr *string

	// Boolean
	BooleanAttr *bool

	// Double
	DoubleAttr *float64

	// Integer
	IntegerAttr *int32

	// String
	StringAttr *string

	// Cell Reference
	CellAttr *string
}
type CT_Comment struct {

	// Cell Reference
	RefAttr string

	// Author Id
	AuthorIdAttr uint32

	// Unique Identifier for Comment
	GuidAttr *string

	// Shape ID
	ShapeIdAttr *uint32

	// Comment Text
	Text *CT_Rst

	// Comment Properties
	CommentPr *CT_CommentPr
}

func (_ecaaa *CT_SmartTags) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_dgabe:
	for {
		_agebad, _fgeag := d.Token()
		if _fgeag != nil {
			return _fgeag
		}
		switch _deebg := _agebad.(type) {
		case _f.StartElement:
			switch _deebg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellSmartTags"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellSmartTags"}:
				_fabde := NewCT_CellSmartTags()
				if _dafce := d.DecodeElement(_fabde, &_deebg); _dafce != nil {
					return _dafce
				}
				_ecaaa.CellSmartTags = append(_ecaaa.CellSmartTags, _fabde)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SmartTags\u0020\u0025v", _deebg.Name)
				if _fdcadd := d.Skip(); _fdcadd != nil {
					return _fdcadd
				}
			}
		case _f.EndElement:
			break _dgabe
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_PivotHierarchies() *CT_PivotHierarchies { _adcdb := &CT_PivotHierarchies{}; return _adcdb }
func (_abacb *CT_DdeValues) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _abacb.RowsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rows"}, Value: _bg.Sprintf("\u0025v", *_abacb.RowsAttr)})
	}
	if _abacb.ColsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cols"}, Value: _bg.Sprintf("\u0025v", *_abacb.ColsAttr)})
	}
	e.EncodeToken(start)
	_cbace := _f.StartElement{Name: _f.Name{Local: "ma:value"}}
	for _, _gdgdd := range _abacb.Value {
		e.EncodeElement(_gdgdd, _cbace)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_AutoSortScope and its children, prefixing error messages with path
func (_ddc *CT_AutoSortScope) ValidateWithPath(path string) error {
	if _ceb := _ddc.PivotArea.ValidateWithPath(path + "\u002fPivotArea"); _ceb != nil {
		return _ceb
	}
	return nil
}
func NewCT_QueryTable() *CT_QueryTable { _eebbg := &CT_QueryTable{}; return _eebbg }
func (_dccgf *CT_GroupMembers) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dccgf.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_dccgf.CountAttr)})
	}
	e.EncodeToken(start)
	_fgfad := _f.StartElement{Name: _f.Name{Local: "ma:groupMember"}}
	for _, _adafg := range _dccgf.GroupMember {
		e.EncodeElement(_adafg, _fgfad)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_Rst struct {

	// Text
	T *string

	// Rich Text Run
	R []*CT_RElt

	// Phonetic Run
	RPh []*CT_PhoneticRun

	// Phonetic Properties
	PhoneticPr *CT_PhoneticPr
}

func (_cddagg *CT_PivotHierarchy) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cddagg.OutlineAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "outline"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cddagg.OutlineAttr))})
	}
	if _cddagg.MultipleItemSelectionAllowedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "multipleItemSelectionAllowed"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cddagg.MultipleItemSelectionAllowedAttr))})
	}
	if _cddagg.SubtotalTopAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "subtotalTop"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cddagg.SubtotalTopAttr))})
	}
	if _cddagg.ShowInFieldListAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showInFieldList"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cddagg.ShowInFieldListAttr))})
	}
	if _cddagg.DragToRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dragToRow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cddagg.DragToRowAttr))})
	}
	if _cddagg.DragToColAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dragToCol"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cddagg.DragToColAttr))})
	}
	if _cddagg.DragToPageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dragToPage"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cddagg.DragToPageAttr))})
	}
	if _cddagg.DragToDataAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dragToData"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cddagg.DragToDataAttr))})
	}
	if _cddagg.DragOffAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dragOff"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cddagg.DragOffAttr))})
	}
	if _cddagg.IncludeNewItemsInFilterAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "includeNewItemsInFilter"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cddagg.IncludeNewItemsInFilterAttr))})
	}
	if _cddagg.CaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "caption"}, Value: _bg.Sprintf("\u0025v", *_cddagg.CaptionAttr)})
	}
	e.EncodeToken(start)
	if _cddagg.Mps != nil {
		_ffggg := _f.StartElement{Name: _f.Name{Local: "ma:mps"}}
		e.EncodeElement(_cddagg.Mps, _ffggg)
	}
	if _cddagg.Members != nil {
		_gfaafa := _f.StartElement{Name: _f.Name{Local: "ma:members"}}
		for _, _gcagd := range _cddagg.Members {
			e.EncodeElement(_gcagd, _gfaafa)
		}
	}
	if _cddagg.ExtLst != nil {
		_gedcc := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_cddagg.ExtLst, _gedcc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_caeacc *CT_RangePr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cgadbb := range start.Attr {
		if _cgadbb.Name.Local == "autoStart" {
			_gdfagc, _gdcfb := _g.ParseBool(_cgadbb.Value)
			if _gdcfb != nil {
				return _gdcfb
			}
			_caeacc.AutoStartAttr = &_gdfagc
			continue
		}
		if _cgadbb.Name.Local == "autoEnd" {
			_cdeac, _eefgd := _g.ParseBool(_cgadbb.Value)
			if _eefgd != nil {
				return _eefgd
			}
			_caeacc.AutoEndAttr = &_cdeac
			continue
		}
		if _cgadbb.Name.Local == "groupBy" {
			_caeacc.GroupByAttr.UnmarshalXMLAttr(_cgadbb)
			continue
		}
		if _cgadbb.Name.Local == "startNum" {
			_dbafe, _ggbcf := _g.ParseFloat(_cgadbb.Value, 64)
			if _ggbcf != nil {
				return _ggbcf
			}
			_caeacc.StartNumAttr = &_dbafe
			continue
		}
		if _cgadbb.Name.Local == "endNum" {
			_efecbe, _ebagae := _g.ParseFloat(_cgadbb.Value, 64)
			if _ebagae != nil {
				return _ebagae
			}
			_caeacc.EndNumAttr = &_efecbe
			continue
		}
		if _cgadbb.Name.Local == "startDate" {
			_ggdegd, _fagce := ParseStdlibTime(_cgadbb.Value)
			if _fagce != nil {
				return _fagce
			}
			_caeacc.StartDateAttr = &_ggdegd
			continue
		}
		if _cgadbb.Name.Local == "endDate" {
			_dagcf, _afdcedg := ParseStdlibTime(_cgadbb.Value)
			if _afdcedg != nil {
				return _afdcedg
			}
			_caeacc.EndDateAttr = &_dagcf
			continue
		}
		if _cgadbb.Name.Local == "groupInterval" {
			_deagf, _acbcef := _g.ParseFloat(_cgadbb.Value, 64)
			if _acbcef != nil {
				return _acbcef
			}
			_caeacc.GroupIntervalAttr = &_deagf
			continue
		}
	}
	for {
		_becde, _ddacc := d.Token()
		if _ddacc != nil {
			return _bg.Errorf("parsing\u0020CT_RangePr:\u0020%s", _ddacc)
		}
		if _cdabb, _cegce := _becde.(_f.EndElement); _cegce && _cdabb.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_ServerFormat() *CT_ServerFormat { _dcbaag := &CT_ServerFormat{}; return _dcbaag }

type PivotTableDefinition struct{ CT_pivotTableDefinition }

// Validate validates the CT_Selection and its children
func (_defgc *CT_Selection) Validate() error { return _defgc.ValidateWithPath("CT_Selection") }
func (_beaea *CT_SmartTagTypes) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _beaea.SmartTagType != nil {
		_gaace := _f.StartElement{Name: _f.Name{Local: "ma:smartTagType"}}
		for _, _bcgcac := range _beaea.SmartTagType {
			e.EncodeElement(_bcgcac, _gaace)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cgafd *CT_MetadataTypes) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cgafd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_cgafd.CountAttr)})
	}
	e.EncodeToken(start)
	_fbfc := _f.StartElement{Name: _f.Name{Local: "ma:metadataType"}}
	for _, _bcgb := range _cgafd.MetadataType {
		e.EncodeElement(_bcgb, _fbfc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_fddfeg *ST_SortType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bbgaf, _ebfag := d.Token()
	if _ebfag != nil {
		return _ebfag
	}
	if _ebcgff, _cefae := _bbgaf.(_f.EndElement); _cefae && _ebcgff.Name == start.Name {
		*_fddfeg = 1
		return nil
	}
	if _adddg, _fffbbg := _bbgaf.(_f.CharData); !_fffbbg {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bbgaf)
	} else {
		switch string(_adddg) {
		case "":
			*_fddfeg = 0
		case "none":
			*_fddfeg = 1
		case "ascending":
			*_fddfeg = 2
		case "descending":
			*_fddfeg = 3
		case "ascendingAlpha":
			*_fddfeg = 4
		case "descendingAlpha":
			*_fddfeg = 5
		case "ascendingNatural":
			*_fddfeg = 6
		case "descendingNatural":
			*_fddfeg = 7
		}
	}
	_bbgaf, _ebfag = d.Token()
	if _ebfag != nil {
		return _ebfag
	}
	if _deggef, _dgfcd := _bbgaf.(_f.EndElement); _dgfcd && _deggef.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bbgaf)
}

// ValidateWithPath validates the CT_IconSet and its children, prefixing error messages with path
func (_gccff *CT_IconSet) ValidateWithPath(path string) error {
	if _gffae := _gccff.IconSetAttr.ValidateWithPath(path + "\u002fIconSetAttr"); _gffae != nil {
		return _gffae
	}
	for _fgbce, _fbbeb := range _gccff.Cfvo {
		if _dcfa := _fbbeb.ValidateWithPath(_bg.Sprintf("%s\u002fCfvo\u005b\u0025d\u005d", path, _fgbce)); _dcfa != nil {
			return _dcfa
		}
	}
	return nil
}
func NewCT_NumFmts() *CT_NumFmts { _geeed := &CT_NumFmts{}; return _geeed }
func (_cagga *ST_TableStyleType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_efcbge, _fcdebd := d.Token()
	if _fcdebd != nil {
		return _fcdebd
	}
	if _cgdde, _fdaff := _efcbge.(_f.EndElement); _fdaff && _cgdde.Name == start.Name {
		*_cagga = 1
		return nil
	}
	if _agcace, _fcebbd := _efcbge.(_f.CharData); !_fcebbd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _efcbge)
	} else {
		switch string(_agcace) {
		case "":
			*_cagga = 0
		case "wholeTable":
			*_cagga = 1
		case "headerRow":
			*_cagga = 2
		case "totalRow":
			*_cagga = 3
		case "firstColumn":
			*_cagga = 4
		case "lastColumn":
			*_cagga = 5
		case "firstRowStripe":
			*_cagga = 6
		case "secondRowStripe":
			*_cagga = 7
		case "firstColumnStripe":
			*_cagga = 8
		case "secondColumnStripe":
			*_cagga = 9
		case "firstHeaderCell":
			*_cagga = 10
		case "lastHeaderCell":
			*_cagga = 11
		case "firstTotalCell":
			*_cagga = 12
		case "lastTotalCell":
			*_cagga = 13
		case "firstSubtotalColumn":
			*_cagga = 14
		case "secondSubtotalColumn":
			*_cagga = 15
		case "thirdSubtotalColumn":
			*_cagga = 16
		case "firstSubtotalRow":
			*_cagga = 17
		case "secondSubtotalRow":
			*_cagga = 18
		case "thirdSubtotalRow":
			*_cagga = 19
		case "blankRow":
			*_cagga = 20
		case "firstColumnSubheading":
			*_cagga = 21
		case "secondColumnSubheading":
			*_cagga = 22
		case "thirdColumnSubheading":
			*_cagga = 23
		case "firstRowSubheading":
			*_cagga = 24
		case "secondRowSubheading":
			*_cagga = 25
		case "thirdRowSubheading":
			*_cagga = 26
		case "pageFieldLabels":
			*_cagga = 27
		case "pageFieldValues":
			*_cagga = 28
		}
	}
	_efcbge, _fcdebd = d.Token()
	if _fcdebd != nil {
		return _fcdebd
	}
	if _gcgcg, _gfdgfa := _efcbge.(_f.EndElement); _gfdgfa && _gcgcg.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _efcbge)
}
func NewTable() *Table                   { _dgccdd := &Table{}; _dgccdd.CT_Table = *NewCT_Table(); return _dgccdd }
func NewCT_TableColumn() *CT_TableColumn { _gcaff := &CT_TableColumn{}; return _gcaff }
func (_afdeg *CT_SheetFormatPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _afdeg.BaseColWidthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "baseColWidth"}, Value: _bg.Sprintf("\u0025v", *_afdeg.BaseColWidthAttr)})
	}
	if _afdeg.DefaultColWidthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultColWidth"}, Value: _bg.Sprintf("\u0025v", *_afdeg.DefaultColWidthAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultRowHeight"}, Value: _bg.Sprintf("\u0025v", _afdeg.DefaultRowHeightAttr)})
	if _afdeg.CustomHeightAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "customHeight"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afdeg.CustomHeightAttr))})
	}
	if _afdeg.ZeroHeightAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "zeroHeight"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afdeg.ZeroHeightAttr))})
	}
	if _afdeg.ThickTopAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "thickTop"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afdeg.ThickTopAttr))})
	}
	if _afdeg.ThickBottomAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "thickBottom"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afdeg.ThickBottomAttr))})
	}
	if _afdeg.OutlineLevelRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "outlineLevelRow"}, Value: _bg.Sprintf("\u0025v", *_afdeg.OutlineLevelRowAttr)})
	}
	if _afdeg.OutlineLevelColAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "outlineLevelCol"}, Value: _bg.Sprintf("\u0025v", *_afdeg.OutlineLevelColAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Comment and its children
func (_fced *CT_Comment) Validate() error { return _fced.ValidateWithPath("CT_Comment") }

type CT_ConditionalFormats struct {

	// Conditional Format Count
	CountAttr *uint32

	// Conditional Formatting
	ConditionalFormat []*CT_ConditionalFormat
}

func (_dgdg *CT_IconFilter) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dgdg.IconSetAttr = ST_IconSetType(1)
	for _, _eabfa := range start.Attr {
		if _eabfa.Name.Local == "iconSet" {
			_dgdg.IconSetAttr.UnmarshalXMLAttr(_eabfa)
			continue
		}
		if _eabfa.Name.Local == "iconId" {
			_efbde, _cfgbd := _g.ParseUint(_eabfa.Value, 10, 32)
			if _cfgbd != nil {
				return _cfgbd
			}
			_effed := uint32(_efbde)
			_dgdg.IconIdAttr = &_effed
			continue
		}
	}
	for {
		_ecgef, _decge := d.Token()
		if _decge != nil {
			return _bg.Errorf("parsing\u0020CT_IconFilter:\u0020\u0025s", _decge)
		}
		if _cgbf, _bddeb := _ecgef.(_f.EndElement); _bddeb && _cgbf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gcefb ST_DynamicFilterType) ValidateWithPath(path string) error {
	switch _gcefb {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gcefb))
	}
	return nil
}
func (_faaag *CT_CustomWorkbookViews) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_dgffc := _f.StartElement{Name: _f.Name{Local: "ma:customWorkbookView"}}
	for _, _ggba := range _faaag.CustomWorkbookView {
		e.EncodeElement(_ggba, _dgffc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_CacheFields() *CT_CacheFields { _ddf := &CT_CacheFields{}; return _ddf }
func (_daadc ST_SheetViewType) ValidateWithPath(path string) error {
	switch _daadc {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_daadc))
	}
	return nil
}
func (_bdeb *CT_DrawingHF) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _afcd := range start.Attr {
		if _afcd.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _afcd.Name.Local == "id" || _afcd.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _afcd.Name.Local == "id" {
			_fbgf, _eefaeb := _afcd.Value, error(nil)
			if _eefaeb != nil {
				return _eefaeb
			}
			_bdeb.IdAttr = _fbgf
			continue
		}
		if _afcd.Name.Local == "rhf" {
			_dacbg, _cgeb := _g.ParseUint(_afcd.Value, 10, 32)
			if _cgeb != nil {
				return _cgeb
			}
			_fbdg := uint32(_dacbg)
			_bdeb.RhfAttr = &_fbdg
			continue
		}
		if _afcd.Name.Local == "lfo" {
			_daffc, _ccgdd := _g.ParseUint(_afcd.Value, 10, 32)
			if _ccgdd != nil {
				return _ccgdd
			}
			_dgcbd := uint32(_daffc)
			_bdeb.LfoAttr = &_dgcbd
			continue
		}
		if _afcd.Name.Local == "lfe" {
			_acgee, _cdfce := _g.ParseUint(_afcd.Value, 10, 32)
			if _cdfce != nil {
				return _cdfce
			}
			_cbfgb := uint32(_acgee)
			_bdeb.LfeAttr = &_cbfgb
			continue
		}
		if _afcd.Name.Local == "lhf" {
			_cbcbaa, _cedcd := _g.ParseUint(_afcd.Value, 10, 32)
			if _cedcd != nil {
				return _cedcd
			}
			_fbgb := uint32(_cbcbaa)
			_bdeb.LhfAttr = &_fbgb
			continue
		}
		if _afcd.Name.Local == "lff" {
			_dacbf, _abaa := _g.ParseUint(_afcd.Value, 10, 32)
			if _abaa != nil {
				return _abaa
			}
			_cccf := uint32(_dacbf)
			_bdeb.LffAttr = &_cccf
			continue
		}
		if _afcd.Name.Local == "che" {
			_ccef, _edbab := _g.ParseUint(_afcd.Value, 10, 32)
			if _edbab != nil {
				return _edbab
			}
			_bdbag := uint32(_ccef)
			_bdeb.CheAttr = &_bdbag
			continue
		}
		if _afcd.Name.Local == "rho" {
			_ffgb, _ccefc := _g.ParseUint(_afcd.Value, 10, 32)
			if _ccefc != nil {
				return _ccefc
			}
			_efbf := uint32(_ffgb)
			_bdeb.RhoAttr = &_efbf
			continue
		}
		if _afcd.Name.Local == "rhe" {
			_dfafe, _gafba := _g.ParseUint(_afcd.Value, 10, 32)
			if _gafba != nil {
				return _gafba
			}
			_fgfa := uint32(_dfafe)
			_bdeb.RheAttr = &_fgfa
			continue
		}
		if _afcd.Name.Local == "lho" {
			_ebfaf, _dfbcgg := _g.ParseUint(_afcd.Value, 10, 32)
			if _dfbcgg != nil {
				return _dfbcgg
			}
			_acaeg := uint32(_ebfaf)
			_bdeb.LhoAttr = &_acaeg
			continue
		}
		if _afcd.Name.Local == "lhe" {
			_ffac, _fbaeg := _g.ParseUint(_afcd.Value, 10, 32)
			if _fbaeg != nil {
				return _fbaeg
			}
			_cabge := uint32(_ffac)
			_bdeb.LheAttr = &_cabge
			continue
		}
		if _afcd.Name.Local == "cho" {
			_dfed, _abgd := _g.ParseUint(_afcd.Value, 10, 32)
			if _abgd != nil {
				return _abgd
			}
			_bdefg := uint32(_dfed)
			_bdeb.ChoAttr = &_bdefg
			continue
		}
		if _afcd.Name.Local == "chf" {
			_fcbc, _gffa := _g.ParseUint(_afcd.Value, 10, 32)
			if _gffa != nil {
				return _gffa
			}
			_caac := uint32(_fcbc)
			_bdeb.ChfAttr = &_caac
			continue
		}
		if _afcd.Name.Local == "cfo" {
			_bgbc, _afdfa := _g.ParseUint(_afcd.Value, 10, 32)
			if _afdfa != nil {
				return _afdfa
			}
			_acdfg := uint32(_bgbc)
			_bdeb.CfoAttr = &_acdfg
			continue
		}
		if _afcd.Name.Local == "cfe" {
			_dcdfe, _cece := _g.ParseUint(_afcd.Value, 10, 32)
			if _cece != nil {
				return _cece
			}
			_ecga := uint32(_dcdfe)
			_bdeb.CfeAttr = &_ecga
			continue
		}
		if _afcd.Name.Local == "cff" {
			_dadbd, _bcddd := _g.ParseUint(_afcd.Value, 10, 32)
			if _bcddd != nil {
				return _bcddd
			}
			_abaec := uint32(_dadbd)
			_bdeb.CffAttr = &_abaec
			continue
		}
		if _afcd.Name.Local == "rfo" {
			_ecdfc, _gfaff := _g.ParseUint(_afcd.Value, 10, 32)
			if _gfaff != nil {
				return _gfaff
			}
			_dbdfb := uint32(_ecdfc)
			_bdeb.RfoAttr = &_dbdfb
			continue
		}
		if _afcd.Name.Local == "rfe" {
			_aebfb, _fgcac := _g.ParseUint(_afcd.Value, 10, 32)
			if _fgcac != nil {
				return _fgcac
			}
			_bfaa := uint32(_aebfb)
			_bdeb.RfeAttr = &_bfaa
			continue
		}
		if _afcd.Name.Local == "rff" {
			_ffagd, _cbacg := _g.ParseUint(_afcd.Value, 10, 32)
			if _cbacg != nil {
				return _cbacg
			}
			_bcfff := uint32(_ffagd)
			_bdeb.RffAttr = &_bcfff
			continue
		}
	}
	for {
		_agdc, _badec := d.Token()
		if _badec != nil {
			return _bg.Errorf("parsing\u0020CT_DrawingHF:\u0020\u0025s", _badec)
		}
		if _egfef, _ebed := _agdc.(_f.EndElement); _ebed && _egfef.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PivotHierarchies and its children, prefixing error messages with path
func (_cfbgfb *CT_PivotHierarchies) ValidateWithPath(path string) error {
	for _bgaba, _cbcdf := range _cfbgfb.PivotHierarchy {
		if _fega := _cbcdf.ValidateWithPath(_bg.Sprintf("%s\u002fPivotHierarchy\u005b\u0025d\u005d", path, _bgaba)); _fega != nil {
			return _fega
		}
	}
	return nil
}
func (_ecbcg *CT_PCDSCPage) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ecbcg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_ecbcg.CountAttr)})
	}
	e.EncodeToken(start)
	if _ecbcg.PageItem != nil {
		_gbdd := _f.StartElement{Name: _f.Name{Local: "ma:pageItem"}}
		for _, _gdfgc := range _ecbcg.PageItem {
			e.EncodeElement(_gdfgc, _gbdd)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_eadca *CT_MemberProperty) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cfgca := range start.Attr {
		if _cfgca.Name.Local == "name" {
			_efccc, _bffbg := _cfgca.Value, error(nil)
			if _bffbg != nil {
				return _bffbg
			}
			_eadca.NameAttr = &_efccc
			continue
		}
		if _cfgca.Name.Local == "showCell" {
			_ffaba, _gffeb := _g.ParseBool(_cfgca.Value)
			if _gffeb != nil {
				return _gffeb
			}
			_eadca.ShowCellAttr = &_ffaba
			continue
		}
		if _cfgca.Name.Local == "showTip" {
			_dadgf, _faff := _g.ParseBool(_cfgca.Value)
			if _faff != nil {
				return _faff
			}
			_eadca.ShowTipAttr = &_dadgf
			continue
		}
		if _cfgca.Name.Local == "showAsCaption" {
			_dfcgec, _cgacg := _g.ParseBool(_cfgca.Value)
			if _cgacg != nil {
				return _cgacg
			}
			_eadca.ShowAsCaptionAttr = &_dfcgec
			continue
		}
		if _cfgca.Name.Local == "nameLen" {
			_dbaag, _abgg := _g.ParseUint(_cfgca.Value, 10, 32)
			if _abgg != nil {
				return _abgg
			}
			_gfcbd := uint32(_dbaag)
			_eadca.NameLenAttr = &_gfcbd
			continue
		}
		if _cfgca.Name.Local == "pPos" {
			_edgdg, _fabeb := _g.ParseUint(_cfgca.Value, 10, 32)
			if _fabeb != nil {
				return _fabeb
			}
			_fcfdg := uint32(_edgdg)
			_eadca.PPosAttr = &_fcfdg
			continue
		}
		if _cfgca.Name.Local == "pLen" {
			_ecfeg, _dbcgg := _g.ParseUint(_cfgca.Value, 10, 32)
			if _dbcgg != nil {
				return _dbcgg
			}
			_ffgdb := uint32(_ecfeg)
			_eadca.PLenAttr = &_ffgdb
			continue
		}
		if _cfgca.Name.Local == "level" {
			_beadb, _cafcb := _g.ParseUint(_cfgca.Value, 10, 32)
			if _cafcb != nil {
				return _cafcb
			}
			_cffgad := uint32(_beadb)
			_eadca.LevelAttr = &_cffgad
			continue
		}
		if _cfgca.Name.Local == "field" {
			_ffcfg, _ebeaf := _g.ParseUint(_cfgca.Value, 10, 32)
			if _ebeaf != nil {
				return _ebeaf
			}
			_eadca.FieldAttr = uint32(_ffcfg)
			continue
		}
	}
	for {
		_gggda, _babda := d.Token()
		if _babda != nil {
			return _bg.Errorf("parsing\u0020CT_MemberProperty: \u0025s", _babda)
		}
		if _ceffd, _fggdg := _gggda.(_f.EndElement); _fggdg && _ceffd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_acfcf ST_FontScheme) ValidateWithPath(path string) error {
	switch _acfcf {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_acfcf))
	}
	return nil
}

const (
	ST_SheetStateUnset      ST_SheetState = 0
	ST_SheetStateVisible    ST_SheetState = 1
	ST_SheetStateHidden     ST_SheetState = 2
	ST_SheetStateVeryHidden ST_SheetState = 3
)

func ParseSliceST_CellSpans(s string) (ST_CellSpans, error) { return ST_CellSpans(_fd.Fields(s)), nil }
func NewCT_CustomSheetView() *CT_CustomSheetView {
	_ecffe := &CT_CustomSheetView{}
	_ecffe.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	return _ecffe
}

// Validate validates the CT_PageItem and its children
func (_beabe *CT_PageItem) Validate() error { return _beabe.ValidateWithPath("CT_PageItem") }

// ValidateWithPath validates the CT_CellStyles and its children, prefixing error messages with path
func (_cfce *CT_CellStyles) ValidateWithPath(path string) error {
	for _dagc, _bbcb := range _cfce.CellStyle {
		if _efgb := _bbcb.ValidateWithPath(_bg.Sprintf("\u0025s/CellStyle\u005b\u0025d\u005d", path, _dagc)); _efgb != nil {
			return _efgb
		}
	}
	return nil
}
func (_ffdaba ST_Visibility) Validate() error { return _ffdaba.ValidateWithPath("") }

const (
	ST_PrintErrorUnset     ST_PrintError = 0
	ST_PrintErrorDisplayed ST_PrintError = 1
	ST_PrintErrorBlank     ST_PrintError = 2
	ST_PrintErrorDash      ST_PrintError = 3
	ST_PrintErrorNA        ST_PrintError = 4
)

type StyleSheet struct{ CT_Stylesheet }

func (_bgbgff ST_FormulaExpression) Validate() error { return _bgbgff.ValidateWithPath("") }
func NewCT_QueryTableRefresh() *CT_QueryTableRefresh {
	_dccaa := &CT_QueryTableRefresh{}
	_dccaa.QueryTableFields = NewCT_QueryTableFields()
	return _dccaa
}
func (_gcbfc *CT_DataBar) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gcbfc.MinLengthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minLength"}, Value: _bg.Sprintf("\u0025v", *_gcbfc.MinLengthAttr)})
	}
	if _gcbfc.MaxLengthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "maxLength"}, Value: _bg.Sprintf("\u0025v", *_gcbfc.MaxLengthAttr)})
	}
	if _gcbfc.ShowValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showValue"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcbfc.ShowValueAttr))})
	}
	e.EncodeToken(start)
	_gccc := _f.StartElement{Name: _f.Name{Local: "ma:cfvo"}}
	for _, _ddbeb := range _gcbfc.Cfvo {
		e.EncodeElement(_ddbeb, _gccc)
	}
	_befcc := _f.StartElement{Name: _f.Name{Local: "ma:color"}}
	e.EncodeElement(_gcbfc.Color, _befcc)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cbgcbg ST_HtmlFmt) ValidateWithPath(path string) error {
	switch _cbgcbg {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cbgcbg))
	}
	return nil
}
func (_gecbda ST_TableType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_eeceg := _f.Attr{}
	_eeceg.Name = name
	switch _gecbda {
	case ST_TableTypeUnset:
		_eeceg.Value = ""
	case ST_TableTypeWorksheet:
		_eeceg.Value = "worksheet"
	case ST_TableTypeXml:
		_eeceg.Value = "xml"
	case ST_TableTypeQueryTable:
		_eeceg.Value = "queryTable"
	}
	return _eeceg, nil
}
func (_ecedbc ST_rwColActionType) String() string {
	switch _ecedbc {
	case 0:
		return ""
	case 1:
		return "insertRow"
	case 2:
		return "deleteRow"
	case 3:
		return "insertCol"
	case 4:
		return "deleteCol"
	}
	return ""
}
func (_ceac *CT_FilterColumn) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "colId"}, Value: _bg.Sprintf("\u0025v", _ceac.ColIdAttr)})
	if _ceac.HiddenButtonAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hiddenButton"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ceac.HiddenButtonAttr))})
	}
	if _ceac.ShowButtonAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showButton"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ceac.ShowButtonAttr))})
	}
	e.EncodeToken(start)
	if _ceac.Filters != nil {
		_bgcf := _f.StartElement{Name: _f.Name{Local: "ma:filters"}}
		e.EncodeElement(_ceac.Filters, _bgcf)
	}
	if _ceac.Top10 != nil {
		_aeeeb := _f.StartElement{Name: _f.Name{Local: "ma:top10"}}
		e.EncodeElement(_ceac.Top10, _aeeeb)
	}
	if _ceac.CustomFilters != nil {
		_eggc := _f.StartElement{Name: _f.Name{Local: "ma:customFilters"}}
		e.EncodeElement(_ceac.CustomFilters, _eggc)
	}
	if _ceac.DynamicFilter != nil {
		_faade := _f.StartElement{Name: _f.Name{Local: "ma:dynamicFilter"}}
		e.EncodeElement(_ceac.DynamicFilter, _faade)
	}
	if _ceac.ColorFilter != nil {
		_afbgd := _f.StartElement{Name: _f.Name{Local: "ma:colorFilter"}}
		e.EncodeElement(_ceac.ColorFilter, _afbgd)
	}
	if _ceac.IconFilter != nil {
		_agga := _f.StartElement{Name: _f.Name{Local: "ma:iconFilter"}}
		e.EncodeElement(_ceac.IconFilter, _agga)
	}
	if _ceac.ExtLst != nil {
		_dgddgd := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_ceac.ExtLst, _dgddgd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_afgbf *CT_IgnoredError) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sqref"}, Value: _bg.Sprintf("\u0025v", _afgbf.SqrefAttr)})
	if _afgbf.EvalErrorAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "evalError"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afgbf.EvalErrorAttr))})
	}
	if _afgbf.TwoDigitTextYearAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "twoDigitTextYear"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afgbf.TwoDigitTextYearAttr))})
	}
	if _afgbf.NumberStoredAsTextAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "numberStoredAsText"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afgbf.NumberStoredAsTextAttr))})
	}
	if _afgbf.FormulaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "formula"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afgbf.FormulaAttr))})
	}
	if _afgbf.FormulaRangeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "formulaRange"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afgbf.FormulaRangeAttr))})
	}
	if _afgbf.UnlockedFormulaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "unlockedFormula"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afgbf.UnlockedFormulaAttr))})
	}
	if _afgbf.EmptyCellReferenceAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "emptyCellReference"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afgbf.EmptyCellReferenceAttr))})
	}
	if _afgbf.ListDataValidationAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "listDataValidation"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afgbf.ListDataValidationAttr))})
	}
	if _afgbf.CalculatedColumnAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "calculatedColumn"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afgbf.CalculatedColumnAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_RevisionMove struct {

	// Sheet Id
	SheetIdAttr uint32

	// Source
	SourceAttr string

	// Destination
	DestinationAttr string

	// Source Sheet Id
	SourceSheetIdAttr *uint32

	// Undo
	Undo []*CT_UndoInfo

	// Revision Cell Change
	Rcc []*CT_RevisionCellChange

	// Revision Format
	Rfmt    []*CT_RevisionFormatting
	RIdAttr *uint32
	UaAttr  *bool
	RaAttr  *bool
}

// Validate validates the CT_TableParts and its children
func (_fadba *CT_TableParts) Validate() error { return _fadba.ValidateWithPath("CT_TableParts") }
func NewCT_ColFields() *CT_ColFields          { _dgdd := &CT_ColFields{}; return _dgdd }
func (_defdgf *CT_RevisionCellChange) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_defdgf.Nc = NewCT_Cell()
	for _, _fgaeea := range start.Attr {
		if _fgaeea.Name.Local == "oldPh" {
			_bgbcg, _dbdfe := _g.ParseBool(_fgaeea.Value)
			if _dbdfe != nil {
				return _dbdfe
			}
			_defdgf.OldPhAttr = &_bgbcg
			continue
		}
		if _fgaeea.Name.Local == "endOfListFormulaUpdate" {
			_becfg, _gdfbb := _g.ParseBool(_fgaeea.Value)
			if _gdfbb != nil {
				return _gdfbb
			}
			_defdgf.EndOfListFormulaUpdateAttr = &_becfg
			continue
		}
		if _fgaeea.Name.Local == "odxf" {
			_aafde, _dadag := _g.ParseBool(_fgaeea.Value)
			if _dadag != nil {
				return _dadag
			}
			_defdgf.OdxfAttr = &_aafde
			continue
		}
		if _fgaeea.Name.Local == "s" {
			_fbefd, _gedee := _g.ParseBool(_fgaeea.Value)
			if _gedee != nil {
				return _gedee
			}
			_defdgf.SAttr = &_fbefd
			continue
		}
		if _fgaeea.Name.Local == "numFmtId" {
			_gcgdc, _babfb := _g.ParseUint(_fgaeea.Value, 10, 32)
			if _babfb != nil {
				return _babfb
			}
			_bebcb := uint32(_gcgdc)
			_defdgf.NumFmtIdAttr = &_bebcb
			continue
		}
		if _fgaeea.Name.Local == "oldQuotePrefix" {
			_bfaag, _fbbedc := _g.ParseBool(_fgaeea.Value)
			if _fbbedc != nil {
				return _fbbedc
			}
			_defdgf.OldQuotePrefixAttr = &_bfaag
			continue
		}
		if _fgaeea.Name.Local == "ph" {
			_dcfgb, _gfaac := _g.ParseBool(_fgaeea.Value)
			if _gfaac != nil {
				return _gfaac
			}
			_defdgf.PhAttr = &_dcfgb
			continue
		}
		if _fgaeea.Name.Local == "sId" {
			_badgd, _gbacg := _g.ParseUint(_fgaeea.Value, 10, 32)
			if _gbacg != nil {
				return _gbacg
			}
			_defdgf.SIdAttr = uint32(_badgd)
			continue
		}
		if _fgaeea.Name.Local == "xfDxf" {
			_bfbaf, _becg := _g.ParseBool(_fgaeea.Value)
			if _becg != nil {
				return _becg
			}
			_defdgf.XfDxfAttr = &_bfbaf
			continue
		}
		if _fgaeea.Name.Local == "dxf" {
			_cgffa, _becad := _g.ParseBool(_fgaeea.Value)
			if _becad != nil {
				return _becad
			}
			_defdgf.DxfAttr = &_cgffa
			continue
		}
		if _fgaeea.Name.Local == "quotePrefix" {
			_ggbgaa, _fecb := _g.ParseBool(_fgaeea.Value)
			if _fecb != nil {
				return _fecb
			}
			_defdgf.QuotePrefixAttr = &_ggbgaa
			continue
		}
		if _fgaeea.Name.Local == "rId" {
			_fdeac, _febca := _g.ParseUint(_fgaeea.Value, 10, 32)
			if _febca != nil {
				return _febca
			}
			_dcegg := uint32(_fdeac)
			_defdgf.RIdAttr = &_dcegg
			continue
		}
		if _fgaeea.Name.Local == "ua" {
			_efebga, _acfacb := _g.ParseBool(_fgaeea.Value)
			if _acfacb != nil {
				return _acfacb
			}
			_defdgf.UaAttr = &_efebga
			continue
		}
		if _fgaeea.Name.Local == "ra" {
			_cggdgac, _caaeg := _g.ParseBool(_fgaeea.Value)
			if _caaeg != nil {
				return _caaeg
			}
			_defdgf.RaAttr = &_cggdgac
			continue
		}
	}
_geccf:
	for {
		_ccgc, _fdgef := d.Token()
		if _fdgef != nil {
			return _fdgef
		}
		switch _fbaeag := _ccgc.(type) {
		case _f.StartElement:
			switch _fbaeag.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oc"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oc"}:
				_defdgf.Oc = NewCT_Cell()
				if _aagfg := d.DecodeElement(_defdgf.Oc, &_fbaeag); _aagfg != nil {
					return _aagfg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "nc"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "nc"}:
				if _bbdfe := d.DecodeElement(_defdgf.Nc, &_fbaeag); _bbdfe != nil {
					return _bbdfe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "odxf"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "odxf"}:
				_defdgf.Odxf = NewCT_Dxf()
				if _dcfabb := d.DecodeElement(_defdgf.Odxf, &_fbaeag); _dcfabb != nil {
					return _dcfabb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ndxf"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ndxf"}:
				_defdgf.Ndxf = NewCT_Dxf()
				if _edeeb := d.DecodeElement(_defdgf.Ndxf, &_fbaeag); _edeeb != nil {
					return _edeeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_defdgf.ExtLst = NewCT_ExtensionList()
				if _cfdba := d.DecodeElement(_defdgf.ExtLst, &_fbaeag); _cfdba != nil {
					return _cfdba
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on CT_RevisionCellChange\u0020\u0025v", _fbaeag.Name)
				if _ebefa := d.Skip(); _ebefa != nil {
					return _ebefa
				}
			}
		case _f.EndElement:
			break _geccf
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_TableStyle() *CT_TableStyle { _afcga := &CT_TableStyle{}; return _afcga }
func (_cggggeb ST_BorderStyle) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_cdbga := _f.Attr{}
	_cdbga.Name = name
	switch _cggggeb {
	case ST_BorderStyleUnset:
		_cdbga.Value = ""
	case ST_BorderStyleNone:
		_cdbga.Value = "none"
	case ST_BorderStyleThin:
		_cdbga.Value = "thin"
	case ST_BorderStyleMedium:
		_cdbga.Value = "medium"
	case ST_BorderStyleDashed:
		_cdbga.Value = "dashed"
	case ST_BorderStyleDotted:
		_cdbga.Value = "dotted"
	case ST_BorderStyleThick:
		_cdbga.Value = "thick"
	case ST_BorderStyleDouble:
		_cdbga.Value = "double"
	case ST_BorderStyleHair:
		_cdbga.Value = "hair"
	case ST_BorderStyleMediumDashed:
		_cdbga.Value = "mediumDashed"
	case ST_BorderStyleDashDot:
		_cdbga.Value = "dashDot"
	case ST_BorderStyleMediumDashDot:
		_cdbga.Value = "mediumDashDot"
	case ST_BorderStyleDashDotDot:
		_cdbga.Value = "dashDotDot"
	case ST_BorderStyleMediumDashDotDot:
		_cdbga.Value = "mediumDashDotDot"
	case ST_BorderStyleSlantDashDot:
		_cdbga.Value = "slantDashDot"
	}
	return _cdbga, nil
}
func NewCT_CacheHierarchy() *CT_CacheHierarchy { _ddee := &CT_CacheHierarchy{}; return _ddee }
func NewCT_Items() *CT_Items                   { _gfcec := &CT_Items{}; return _gfcec }

// Validate validates the CT_CellAlignment and its children
func (_gbbc *CT_CellAlignment) Validate() error { return _gbbc.ValidateWithPath("CT_CellAlignment") }

// Validate validates the CT_Sheet and its children
func (_agbbf *CT_Sheet) Validate() error { return _agbbf.ValidateWithPath("CT_Sheet") }

// ValidateWithPath validates the CT_Query and its children, prefixing error messages with path
func (_dbaeeg *CT_Query) ValidateWithPath(path string) error {
	if _dbaeeg.Tpls != nil {
		if _ccffd := _dbaeeg.Tpls.ValidateWithPath(path + "\u002fTpls"); _ccffd != nil {
			return _ccffd
		}
	}
	return nil
}
func (_bcgab *CT_RgbColor) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fdegd := range start.Attr {
		if _fdegd.Name.Local == "rgb" {
			_gefge, _ddfbb := _fdegd.Value, error(nil)
			if _ddfbb != nil {
				return _ddfbb
			}
			_bcgab.RgbAttr = &_gefge
			continue
		}
	}
	for {
		_cacegcf, _eefde := d.Token()
		if _eefde != nil {
			return _bg.Errorf("parsing\u0020CT_RgbColor:\u0020\u0025s", _eefde)
		}
		if _ffaca, _cgffg := _cacegcf.(_f.EndElement); _cgffg && _ffaca.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CellFormula and its children, prefixing error messages with path
func (_acc *CT_CellFormula) ValidateWithPath(path string) error {
	if _dbda := _acc.TAttr.ValidateWithPath(path + "\u002fTAttr"); _dbda != nil {
		return _dbda
	}
	return nil
}

// ValidateWithPath validates the CT_ExternalRow and its children, prefixing error messages with path
func (_edcgd *CT_ExternalRow) ValidateWithPath(path string) error {
	for _afagf, _dcfe := range _edcgd.Cell {
		if _fdcbg := _dcfe.ValidateWithPath(_bg.Sprintf("%s\u002fCell\u005b\u0025d\u005d", path, _afagf)); _fdcbg != nil {
			return _fdcbg
		}
	}
	return nil
}
func (_aaaad *ST_DynamicFilterType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gaefd, _ddfaf := d.Token()
	if _ddfaf != nil {
		return _ddfaf
	}
	if _fbcce, _bafae := _gaefd.(_f.EndElement); _bafae && _fbcce.Name == start.Name {
		*_aaaad = 1
		return nil
	}
	if _afgeeg, _agbee := _gaefd.(_f.CharData); !_agbee {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gaefd)
	} else {
		switch string(_afgeeg) {
		case "":
			*_aaaad = 0
		case "null":
			*_aaaad = 1
		case "aboveAverage":
			*_aaaad = 2
		case "belowAverage":
			*_aaaad = 3
		case "tomorrow":
			*_aaaad = 4
		case "today":
			*_aaaad = 5
		case "yesterday":
			*_aaaad = 6
		case "nextWeek":
			*_aaaad = 7
		case "thisWeek":
			*_aaaad = 8
		case "lastWeek":
			*_aaaad = 9
		case "nextMonth":
			*_aaaad = 10
		case "thisMonth":
			*_aaaad = 11
		case "lastMonth":
			*_aaaad = 12
		case "nextQuarter":
			*_aaaad = 13
		case "thisQuarter":
			*_aaaad = 14
		case "lastQuarter":
			*_aaaad = 15
		case "nextYear":
			*_aaaad = 16
		case "thisYear":
			*_aaaad = 17
		case "lastYear":
			*_aaaad = 18
		case "yearToDate":
			*_aaaad = 19
		case "Q1":
			*_aaaad = 20
		case "Q2":
			*_aaaad = 21
		case "Q3":
			*_aaaad = 22
		case "Q4":
			*_aaaad = 23
		case "M1":
			*_aaaad = 24
		case "M2":
			*_aaaad = 25
		case "M3":
			*_aaaad = 26
		case "M4":
			*_aaaad = 27
		case "M5":
			*_aaaad = 28
		case "M6":
			*_aaaad = 29
		case "M7":
			*_aaaad = 30
		case "M8":
			*_aaaad = 31
		case "M9":
			*_aaaad = 32
		case "M10":
			*_aaaad = 33
		case "M11":
			*_aaaad = 34
		case "M12":
			*_aaaad = 35
		}
	}
	_gaefd, _ddfaf = d.Token()
	if _ddfaf != nil {
		return _ddfaf
	}
	if _gacdc, _aeafee := _gaefd.(_f.EndElement); _aeafee && _gacdc.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gaefd)
}
func (_aeffg *CT_Index) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "v"}, Value: _bg.Sprintf("\u0025v", _aeffg.VAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_abgga *CT_Scenario) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _abgga.NameAttr)})
	if _abgga.LockedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "locked"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abgga.LockedAttr))})
	}
	if _abgga.HiddenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hidden"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_abgga.HiddenAttr))})
	}
	if _abgga.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_abgga.CountAttr)})
	}
	if _abgga.UserAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "user"}, Value: _bg.Sprintf("\u0025v", *_abgga.UserAttr)})
	}
	if _abgga.CommentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "comment"}, Value: _bg.Sprintf("\u0025v", *_abgga.CommentAttr)})
	}
	e.EncodeToken(start)
	_cdedg := _f.StartElement{Name: _f.Name{Local: "ma:inputCells"}}
	for _, _efeece := range _abgga.InputCells {
		e.EncodeElement(_efeece, _cdedg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_IconFilter and its children
func (_fcaec *CT_IconFilter) Validate() error { return _fcaec.ValidateWithPath("CT_IconFilter") }
func (_acbab *ST_DataConsolidateFunction) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_acbab = 0
	case "average":
		*_acbab = 1
	case "count":
		*_acbab = 2
	case "countNums":
		*_acbab = 3
	case "max":
		*_acbab = 4
	case "min":
		*_acbab = 5
	case "product":
		*_acbab = 6
	case "stdDev":
		*_acbab = 7
	case "stdDevp":
		*_acbab = 8
	case "sum":
		*_acbab = 9
	case "var":
		*_acbab = 10
	case "varp":
		*_acbab = 11
	}
	return nil
}
func (_aggcf *CT_Member) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _aggcf.NameAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SmartTagPr and its children
func (_bafec *CT_SmartTagPr) Validate() error { return _bafec.ValidateWithPath("CT_SmartTagPr") }

type CT_GradientFill struct {

	// Gradient Fill Type
	TypeAttr ST_GradientType

	// Linear Gradient Degree
	DegreeAttr *float64

	// Left Convergence
	LeftAttr *float64

	// Right Convergence
	RightAttr *float64

	// Top Gradient Convergence
	TopAttr *float64

	// Bottom Convergence
	BottomAttr *float64

	// Gradient Stop
	Stop []*CT_GradientStop
}

// ValidateWithPath validates the CT_Fonts and its children, prefixing error messages with path
func (_ddbbac *CT_Fonts) ValidateWithPath(path string) error {
	for _aeffe, _adfbfc := range _ddbbac.Font {
		if _afgbd := _adfbfc.ValidateWithPath(_bg.Sprintf("%s\u002fFont\u005b\u0025d\u005d", path, _aeffe)); _afgbd != nil {
			return _afgbd
		}
	}
	return nil
}
func NewCT_ExternalBook() *CT_ExternalBook { _efdga := &CT_ExternalBook{}; return _efdga }

type SingleXmlCells struct{ CT_SingleXmlCells }

// Validate validates the CT_MetadataStrings and its children
func (_ebbgc *CT_MetadataStrings) Validate() error {
	return _ebbgc.ValidateWithPath("CT_MetadataStrings")
}

// Validate validates the CT_Sst and its children
func (_agbecb *CT_Sst) Validate() error { return _agbecb.ValidateWithPath("CT_Sst") }
func (_aegfg *ST_SortMethod) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_eggca, _geecgc := d.Token()
	if _geecgc != nil {
		return _geecgc
	}
	if _fbaeef, _aggae := _eggca.(_f.EndElement); _aggae && _fbaeef.Name == start.Name {
		*_aegfg = 1
		return nil
	}
	if _geegbf, _becdcf := _eggca.(_f.CharData); !_becdcf {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eggca)
	} else {
		switch string(_geegbf) {
		case "":
			*_aegfg = 0
		case "stroke":
			*_aegfg = 1
		case "pinYin":
			*_aegfg = 2
		case "none":
			*_aegfg = 3
		}
	}
	_eggca, _geecgc = d.Token()
	if _geecgc != nil {
		return _geecgc
	}
	if _bcbfacf, _dgbffg := _eggca.(_f.EndElement); _dgbffg && _bcbfacf.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eggca)
}

type CT_CellAlignment struct {

	// Horizontal Alignment
	HorizontalAttr ST_HorizontalAlignment

	// Vertical Alignment
	VerticalAttr ST_VerticalAlignment

	// Text Rotation
	TextRotationAttr *uint8

	// Wrap Text
	WrapTextAttr *bool

	// Indent
	IndentAttr *uint32

	// Relative Indent
	RelativeIndentAttr *int32

	// Justify Last Line
	JustifyLastLineAttr *bool

	// Shrink To Fit
	ShrinkToFitAttr *bool

	// Reading Order
	ReadingOrderAttr *uint32
}

func (_aacdfa ST_Objects) Validate() error { return _aacdfa.ValidateWithPath("") }

// Validate validates the CT_CellWatches and its children
func (_cceag *CT_CellWatches) Validate() error { return _cceag.ValidateWithPath("CT_CellWatches") }
func (_effag *ST_FileType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_effag = 0
	case "mac":
		*_effag = 1
	case "win":
		*_effag = 2
	case "dos":
		*_effag = 3
	case "lin":
		*_effag = 4
	case "other":
		*_effag = 5
	}
	return nil
}

type CT_RevisionInsertSheet struct {

	// Sheet Id
	SheetIdAttr uint32

	// Sheet Name
	NameAttr string

	// Sheet Position
	SheetPositionAttr uint32
	RIdAttr           *uint32
	UaAttr            *bool
	RaAttr            *bool
}

// Validate validates the CT_Tuples and its children
func (_abaccg *CT_Tuples) Validate() error { return _abaccg.ValidateWithPath("CT_Tuples") }

type CT_UndoInfo struct {

	// Index
	IndexAttr uint32

	// Expression
	ExpAttr ST_FormulaExpression

	// Reference 3D
	Ref3DAttr *bool

	// Array Formula
	ArrayAttr *bool

	// Value Needed
	VAttr *bool

	// Defined Name Formula
	NfAttr *bool

	// Cross Sheet Move
	CsAttr *bool

	// Range
	DrAttr string

	// Defined Name
	DnAttr *string

	// Cell Reference
	RAttr *string

	// Sheet Id
	SIdAttr *uint32
}

func (_dfegf *CT_TextFields) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _agecc := range start.Attr {
		if _agecc.Name.Local == "count" {
			_becff, _cfgcf := _g.ParseUint(_agecc.Value, 10, 32)
			if _cfgcf != nil {
				return _cfgcf
			}
			_cefbe := uint32(_becff)
			_dfegf.CountAttr = &_cefbe
			continue
		}
	}
_bbdafg:
	for {
		_fddcg, _gecbdg := d.Token()
		if _gecbdg != nil {
			return _gecbdg
		}
		switch _egeebg := _fddcg.(type) {
		case _f.StartElement:
			switch _egeebg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "textField"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "textField"}:
				_bdgce := NewCT_TextField()
				if _aebfeae := d.DecodeElement(_bdgce, &_egeebg); _aebfeae != nil {
					return _aebfeae
				}
				_dfegf.TextField = append(_dfegf.TextField, _bdgce)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_TextFields \u0025v", _egeebg.Name)
				if _dbfac := d.Skip(); _dbfac != nil {
					return _dbfac
				}
			}
		case _f.EndElement:
			break _bbdafg
		case _f.CharData:
		}
	}
	return nil
}
func (_bgbabg *ST_Type) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bgbabg = 0
	case "none":
		*_bgbabg = 1
	case "all":
		*_bgbabg = 2
	case "row":
		*_bgbabg = 3
	case "column":
		*_bgbabg = 4
	}
	return nil
}

// Validate validates the CT_Xf and its children
func (_eafcb *CT_Xf) Validate() error { return _eafcb.ValidateWithPath("CT_Xf") }

// Validate validates the CT_TablePart and its children
func (_bgfdag *CT_TablePart) Validate() error { return _bgfdag.ValidateWithPath("CT_TablePart") }
func NewCT_ObjectPr() *CT_ObjectPr {
	_acdfb := &CT_ObjectPr{}
	_acdfb.Anchor = NewCT_ObjectAnchor()
	return _acdfb
}

// Validate validates the Comments and its children
func (_daeeaf *Comments) Validate() error { return _daeeaf.ValidateWithPath("Comments") }

type CT_CustomSheetViews struct {

	// Custom Sheet View
	CustomSheetView []*CT_CustomSheetView
}

// ValidateWithPath validates the CT_CustomChartsheetView and its children, prefixing error messages with path
func (_fbfd *CT_CustomChartsheetView) ValidateWithPath(path string) error {
	if !_e.ST_GuidPatternRe.MatchString(_fbfd.GuidAttr) {
		return _bg.Errorf("\u0025s\u002fm\u002eGuidAttr must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_GuidPatternRe, _fbfd.GuidAttr)
	}
	if _bgaea := _fbfd.StateAttr.ValidateWithPath(path + "\u002fStateAttr"); _bgaea != nil {
		return _bgaea
	}
	if _fbfd.PageMargins != nil {
		if _fbebb := _fbfd.PageMargins.ValidateWithPath(path + "\u002fPageMargins"); _fbebb != nil {
			return _fbebb
		}
	}
	if _fbfd.PageSetup != nil {
		if _gcbff := _fbfd.PageSetup.ValidateWithPath(path + "\u002fPageSetup"); _gcbff != nil {
			return _gcbff
		}
	}
	if _fbfd.HeaderFooter != nil {
		if _dcabf := _fbfd.HeaderFooter.ValidateWithPath(path + "\u002fHeaderFooter"); _dcabf != nil {
			return _dcabf
		}
	}
	return nil
}
func (_cefea *CT_ProtectedRange) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abdfc := range start.Attr {
		if _abdfc.Name.Local == "password" {
			_dadga, _ggcgd := _abdfc.Value, error(nil)
			if _ggcgd != nil {
				return _ggcgd
			}
			_cefea.PasswordAttr = &_dadga
			continue
		}
		if _abdfc.Name.Local == "sqref" {
			_badab, _fgfee := ParseSliceST_Sqref(_abdfc.Value)
			if _fgfee != nil {
				return _fgfee
			}
			_cefea.SqrefAttr = _badab
			continue
		}
		if _abdfc.Name.Local == "name" {
			_abdfd, _ceege := _abdfc.Value, error(nil)
			if _ceege != nil {
				return _ceege
			}
			_cefea.NameAttr = _abdfd
			continue
		}
		if _abdfc.Name.Local == "securityDescriptor" {
			_edgfc, _decae := _abdfc.Value, error(nil)
			if _decae != nil {
				return _decae
			}
			_cefea.SecurityDescriptorAttr = &_edgfc
			continue
		}
		if _abdfc.Name.Local == "algorithmName" {
			_afedd, _ecdab := _abdfc.Value, error(nil)
			if _ecdab != nil {
				return _ecdab
			}
			_cefea.AlgorithmNameAttr = &_afedd
			continue
		}
		if _abdfc.Name.Local == "hashValue" {
			_cffae, _geebf := _abdfc.Value, error(nil)
			if _geebf != nil {
				return _geebf
			}
			_cefea.HashValueAttr = &_cffae
			continue
		}
		if _abdfc.Name.Local == "saltValue" {
			_fadgd, _agfcb := _abdfc.Value, error(nil)
			if _agfcb != nil {
				return _agfcb
			}
			_cefea.SaltValueAttr = &_fadgd
			continue
		}
		if _abdfc.Name.Local == "spinCount" {
			_bcbge, _acafae := _g.ParseUint(_abdfc.Value, 10, 32)
			if _acafae != nil {
				return _acafae
			}
			_agefc := uint32(_bcbge)
			_cefea.SpinCountAttr = &_agefc
			continue
		}
	}
_ddcag:
	for {
		_dbgeb, _edac := d.Token()
		if _edac != nil {
			return _edac
		}
		switch _bgaaa := _dbgeb.(type) {
		case _f.StartElement:
			switch _bgaaa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "securityDescriptor"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "securityDescriptor"}:
				var _ebgfb string
				if _fceaa := d.DecodeElement(&_ebgfb, &_bgaaa); _fceaa != nil {
					return _fceaa
				}
				_cefea.SecurityDescriptor = append(_cefea.SecurityDescriptor, _ebgfb)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_ProtectedRange\u0020\u0025v", _bgaaa.Name)
				if _fgeae := d.Skip(); _fgeae != nil {
					return _fgeae
				}
			}
		case _f.EndElement:
			break _ddcag
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_VolTopic and its children
func (_eegga *CT_VolTopic) Validate() error { return _eegga.ValidateWithPath("CT_VolTopic") }

// Validate validates the CT_DiscretePr and its children
func (_gfecc *CT_DiscretePr) Validate() error { return _gfecc.ValidateWithPath("CT_DiscretePr") }
func (_gggba *CT_MeasureDimensionMap) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fdbce := range start.Attr {
		if _fdbce.Name.Local == "measureGroup" {
			_dfdgc, _befec := _g.ParseUint(_fdbce.Value, 10, 32)
			if _befec != nil {
				return _befec
			}
			_ddafb := uint32(_dfdgc)
			_gggba.MeasureGroupAttr = &_ddafb
			continue
		}
		if _fdbce.Name.Local == "dimension" {
			_afbe, _gdag := _g.ParseUint(_fdbce.Value, 10, 32)
			if _gdag != nil {
				return _gdag
			}
			_ecef := uint32(_afbe)
			_gggba.DimensionAttr = &_ecef
			continue
		}
	}
	for {
		_fgcf, _aabcf := d.Token()
		if _aabcf != nil {
			return _bg.Errorf("parsing\u0020CT_MeasureDimensionMap:\u0020\u0025s", _aabcf)
		}
		if _dedgd, _daefa := _fgcf.(_f.EndElement); _daefa && _dedgd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fafbd *CT_CommentPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fafbd.Anchor = NewCT_ObjectAnchor()
	for _, _fgef := range start.Attr {
		if _fgef.Name.Local == "altText" {
			_cgac, _cddag := _fgef.Value, error(nil)
			if _cddag != nil {
				return _cddag
			}
			_fafbd.AltTextAttr = &_cgac
			continue
		}
		if _fgef.Name.Local == "defaultSize" {
			_baeg, _bcag := _g.ParseBool(_fgef.Value)
			if _bcag != nil {
				return _bcag
			}
			_fafbd.DefaultSizeAttr = &_baeg
			continue
		}
		if _fgef.Name.Local == "print" {
			_cgfec, _bgde := _g.ParseBool(_fgef.Value)
			if _bgde != nil {
				return _bgde
			}
			_fafbd.PrintAttr = &_cgfec
			continue
		}
		if _fgef.Name.Local == "disabled" {
			_ddcccd, _eacff := _g.ParseBool(_fgef.Value)
			if _eacff != nil {
				return _eacff
			}
			_fafbd.DisabledAttr = &_ddcccd
			continue
		}
		if _fgef.Name.Local == "autoFill" {
			_gbba, _ceffg := _g.ParseBool(_fgef.Value)
			if _ceffg != nil {
				return _ceffg
			}
			_fafbd.AutoFillAttr = &_gbba
			continue
		}
		if _fgef.Name.Local == "autoLine" {
			_ebeb, _bbba := _g.ParseBool(_fgef.Value)
			if _bbba != nil {
				return _bbba
			}
			_fafbd.AutoLineAttr = &_ebeb
			continue
		}
		if _fgef.Name.Local == "locked" {
			_fadc, _bdef := _g.ParseBool(_fgef.Value)
			if _bdef != nil {
				return _bdef
			}
			_fafbd.LockedAttr = &_fadc
			continue
		}
		if _fgef.Name.Local == "textHAlign" {
			_fafbd.TextHAlignAttr.UnmarshalXMLAttr(_fgef)
			continue
		}
		if _fgef.Name.Local == "textVAlign" {
			_fafbd.TextVAlignAttr.UnmarshalXMLAttr(_fgef)
			continue
		}
		if _fgef.Name.Local == "lockText" {
			_bdee, _cfef := _g.ParseBool(_fgef.Value)
			if _cfef != nil {
				return _cfef
			}
			_fafbd.LockTextAttr = &_bdee
			continue
		}
		if _fgef.Name.Local == "justLastX" {
			_cbdaa, _afgc := _g.ParseBool(_fgef.Value)
			if _afgc != nil {
				return _afgc
			}
			_fafbd.JustLastXAttr = &_cbdaa
			continue
		}
		if _fgef.Name.Local == "autoScale" {
			_adgf, _ddeeg := _g.ParseBool(_fgef.Value)
			if _ddeeg != nil {
				return _ddeeg
			}
			_fafbd.AutoScaleAttr = &_adgf
			continue
		}
	}
_gcbaa:
	for {
		_acedd, _cgga := d.Token()
		if _cgga != nil {
			return _cgga
		}
		switch _bgea := _acedd.(type) {
		case _f.StartElement:
			switch _bgea.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "anchor"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "anchor"}:
				if _cabe := d.DecodeElement(_fafbd.Anchor, &_bgea); _cabe != nil {
					return _cabe
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CommentPr\u0020\u0025v", _bgea.Name)
				if _gfbbg := d.Skip(); _gfbbg != nil {
					return _gfbbg
				}
			}
		case _f.EndElement:
			break _gcbaa
		case _f.CharData:
		}
	}
	return nil
}
func (_debfaa *CT_PivotField) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fdddc := range start.Attr {
		if _fdddc.Name.Local == "measureFilter" {
			_ecfab, _fcfdc := _g.ParseBool(_fdddc.Value)
			if _fcfdc != nil {
				return _fcfdc
			}
			_debfaa.MeasureFilterAttr = &_ecfab
			continue
		}
		if _fdddc.Name.Local == "includeNewItemsInFilter" {
			_gfggg, _dgfbcg := _g.ParseBool(_fdddc.Value)
			if _dgfbcg != nil {
				return _dgfbcg
			}
			_debfaa.IncludeNewItemsInFilterAttr = &_gfggg
			continue
		}
		if _fdddc.Name.Local == "compact" {
			_bacga, _bdacd := _g.ParseBool(_fdddc.Value)
			if _bdacd != nil {
				return _bdacd
			}
			_debfaa.CompactAttr = &_bacga
			continue
		}
		if _fdddc.Name.Local == "itemPageCount" {
			_dfbd, _cffbg := _g.ParseUint(_fdddc.Value, 10, 32)
			if _cffbg != nil {
				return _cffbg
			}
			_aecdcd := uint32(_dfbd)
			_debfaa.ItemPageCountAttr = &_aecdcd
			continue
		}
		if _fdddc.Name.Local == "numFmtId" {
			_adefc, _fbdgb := _g.ParseUint(_fdddc.Value, 10, 32)
			if _fbdgb != nil {
				return _fbdgb
			}
			_dadff := uint32(_adefc)
			_debfaa.NumFmtIdAttr = &_dadff
			continue
		}
		if _fdddc.Name.Local == "sortType" {
			_debfaa.SortTypeAttr.UnmarshalXMLAttr(_fdddc)
			continue
		}
		if _fdddc.Name.Local == "outline" {
			_eadbf, _ddadf := _g.ParseBool(_fdddc.Value)
			if _ddadf != nil {
				return _ddadf
			}
			_debfaa.OutlineAttr = &_eadbf
			continue
		}
		if _fdddc.Name.Local == "dataSourceSort" {
			_degfg, _dgeb := _g.ParseBool(_fdddc.Value)
			if _dgeb != nil {
				return _dgeb
			}
			_debfaa.DataSourceSortAttr = &_degfg
			continue
		}
		if _fdddc.Name.Local == "dragToRow" {
			_adafb, _adffcb := _g.ParseBool(_fdddc.Value)
			if _adffcb != nil {
				return _adffcb
			}
			_debfaa.DragToRowAttr = &_adafb
			continue
		}
		if _fdddc.Name.Local == "nonAutoSortDefault" {
			_ddceg, _dgbac := _g.ParseBool(_fdddc.Value)
			if _dgbac != nil {
				return _dgbac
			}
			_debfaa.NonAutoSortDefaultAttr = &_ddceg
			continue
		}
		if _fdddc.Name.Local == "multipleItemSelectionAllowed" {
			_fafed, _daafb := _g.ParseBool(_fdddc.Value)
			if _daafb != nil {
				return _daafb
			}
			_debfaa.MultipleItemSelectionAllowedAttr = &_fafed
			continue
		}
		if _fdddc.Name.Local == "rankBy" {
			_ecead, _dfdde := _g.ParseUint(_fdddc.Value, 10, 32)
			if _dfdde != nil {
				return _dfdde
			}
			_aeadb := uint32(_ecead)
			_debfaa.RankByAttr = &_aeadb
			continue
		}
		if _fdddc.Name.Local == "stdDevSubtotal" {
			_fagge, _gddcd := _g.ParseBool(_fdddc.Value)
			if _gddcd != nil {
				return _gddcd
			}
			_debfaa.StdDevSubtotalAttr = &_fagge
			continue
		}
		if _fdddc.Name.Local == "countASubtotal" {
			_cfaee, _cffc := _g.ParseBool(_fdddc.Value)
			if _cffc != nil {
				return _cffc
			}
			_debfaa.CountASubtotalAttr = &_cfaee
			continue
		}
		if _fdddc.Name.Local == "autoShow" {
			_cdggg, _bddbcb := _g.ParseBool(_fdddc.Value)
			if _bddbcb != nil {
				return _bddbcb
			}
			_debfaa.AutoShowAttr = &_cdggg
			continue
		}
		if _fdddc.Name.Local == "showPropAsCaption" {
			_fccdbe, _facae := _g.ParseBool(_fdddc.Value)
			if _facae != nil {
				return _facae
			}
			_debfaa.ShowPropAsCaptionAttr = &_fccdbe
			continue
		}
		if _fdddc.Name.Local == "productSubtotal" {
			_afdad, _fggad := _g.ParseBool(_fdddc.Value)
			if _fggad != nil {
				return _fggad
			}
			_debfaa.ProductSubtotalAttr = &_afdad
			continue
		}
		if _fdddc.Name.Local == "dragToPage" {
			_ddeba, _gdcgb := _g.ParseBool(_fdddc.Value)
			if _gdcgb != nil {
				return _gdcgb
			}
			_debfaa.DragToPageAttr = &_ddeba
			continue
		}
		if _fdddc.Name.Local == "defaultSubtotal" {
			_gbdga, _baedc := _g.ParseBool(_fdddc.Value)
			if _baedc != nil {
				return _baedc
			}
			_debfaa.DefaultSubtotalAttr = &_gbdga
			continue
		}
		if _fdddc.Name.Local == "dragToData" {
			_gcccc, _acbfg := _g.ParseBool(_fdddc.Value)
			if _acbfg != nil {
				return _acbfg
			}
			_debfaa.DragToDataAttr = &_gcccc
			continue
		}
		if _fdddc.Name.Local == "maxSubtotal" {
			_ecccg, _ebgaa := _g.ParseBool(_fdddc.Value)
			if _ebgaa != nil {
				return _ebgaa
			}
			_debfaa.MaxSubtotalAttr = &_ecccg
			continue
		}
		if _fdddc.Name.Local == "hideNewItems" {
			_eeefe, _cccab := _g.ParseBool(_fdddc.Value)
			if _cccab != nil {
				return _cccab
			}
			_debfaa.HideNewItemsAttr = &_eeefe
			continue
		}
		if _fdddc.Name.Local == "showPropCell" {
			_dddgc, _adfba := _g.ParseBool(_fdddc.Value)
			if _adfba != nil {
				return _adfba
			}
			_debfaa.ShowPropCellAttr = &_dddgc
			continue
		}
		if _fdddc.Name.Local == "subtotalTop" {
			_cbffeg, _bgedee := _g.ParseBool(_fdddc.Value)
			if _bgedee != nil {
				return _bgedee
			}
			_debfaa.SubtotalTopAttr = &_cbffeg
			continue
		}
		if _fdddc.Name.Local == "serverField" {
			_decea, _acdfbdf := _g.ParseBool(_fdddc.Value)
			if _acdfbdf != nil {
				return _acdfbdf
			}
			_debfaa.ServerFieldAttr = &_decea
			continue
		}
		if _fdddc.Name.Local == "name" {
			_gefca, _dcbdd := _fdddc.Value, error(nil)
			if _dcbdd != nil {
				return _dcbdd
			}
			_debfaa.NameAttr = &_gefca
			continue
		}
		if _fdddc.Name.Local == "insertPageBreak" {
			_dccgfa, _ecdcc := _g.ParseBool(_fdddc.Value)
			if _ecdcc != nil {
				return _ecdcc
			}
			_debfaa.InsertPageBreakAttr = &_dccgfa
			continue
		}
		if _fdddc.Name.Local == "sumSubtotal" {
			_bgbab, _eabfb := _g.ParseBool(_fdddc.Value)
			if _eabfb != nil {
				return _eabfb
			}
			_debfaa.SumSubtotalAttr = &_bgbab
			continue
		}
		if _fdddc.Name.Local == "dataField" {
			_afafe, _ddebdf := _g.ParseBool(_fdddc.Value)
			if _ddebdf != nil {
				return _ddebdf
			}
			_debfaa.DataFieldAttr = &_afafe
			continue
		}
		if _fdddc.Name.Local == "avgSubtotal" {
			_daefc, _aeabeb := _g.ParseBool(_fdddc.Value)
			if _aeabeb != nil {
				return _aeabeb
			}
			_debfaa.AvgSubtotalAttr = &_daefc
			continue
		}
		if _fdddc.Name.Local == "topAutoShow" {
			_gbddf, _fcfdf := _g.ParseBool(_fdddc.Value)
			if _fcfdf != nil {
				return _fcfdf
			}
			_debfaa.TopAutoShowAttr = &_gbddf
			continue
		}
		if _fdddc.Name.Local == "minSubtotal" {
			_bfcf, _gcbed := _g.ParseBool(_fdddc.Value)
			if _gcbed != nil {
				return _gcbed
			}
			_debfaa.MinSubtotalAttr = &_bfcf
			continue
		}
		if _fdddc.Name.Local == "dragOff" {
			_bbfgeb, _ddfbf := _g.ParseBool(_fdddc.Value)
			if _ddfbf != nil {
				return _ddfbf
			}
			_debfaa.DragOffAttr = &_bbfgeb
			continue
		}
		if _fdddc.Name.Local == "countSubtotal" {
			_gbbefg, _efffd := _g.ParseBool(_fdddc.Value)
			if _efffd != nil {
				return _efffd
			}
			_debfaa.CountSubtotalAttr = &_gbbefg
			continue
		}
		if _fdddc.Name.Local == "uniqueMemberProperty" {
			_cfdea, _dcbaf := _fdddc.Value, error(nil)
			if _dcbaf != nil {
				return _dcbaf
			}
			_debfaa.UniqueMemberPropertyAttr = &_cfdea
			continue
		}
		if _fdddc.Name.Local == "varPSubtotal" {
			_acgfc, _degde := _g.ParseBool(_fdddc.Value)
			if _degde != nil {
				return _degde
			}
			_debfaa.VarPSubtotalAttr = &_acgfc
			continue
		}
		if _fdddc.Name.Local == "stdDevPSubtotal" {
			_bfgdf, _beeca := _g.ParseBool(_fdddc.Value)
			if _beeca != nil {
				return _beeca
			}
			_debfaa.StdDevPSubtotalAttr = &_bfgdf
			continue
		}
		if _fdddc.Name.Local == "subtotalCaption" {
			_ccaae, _ebcc := _fdddc.Value, error(nil)
			if _ebcc != nil {
				return _ebcc
			}
			_debfaa.SubtotalCaptionAttr = &_ccaae
			continue
		}
		if _fdddc.Name.Local == "showPropTip" {
			_cagea, _cefda := _g.ParseBool(_fdddc.Value)
			if _cefda != nil {
				return _cefda
			}
			_debfaa.ShowPropTipAttr = &_cagea
			continue
		}
		if _fdddc.Name.Local == "insertBlankRow" {
			_dcbaa, _aaabc := _g.ParseBool(_fdddc.Value)
			if _aaabc != nil {
				return _aaabc
			}
			_debfaa.InsertBlankRowAttr = &_dcbaa
			continue
		}
		if _fdddc.Name.Local == "defaultAttributeDrillState" {
			_gbdac, _aagag := _g.ParseBool(_fdddc.Value)
			if _aagag != nil {
				return _aagag
			}
			_debfaa.DefaultAttributeDrillStateAttr = &_gbdac
			continue
		}
		if _fdddc.Name.Local == "dragToCol" {
			_ddefb, _bagedf := _g.ParseBool(_fdddc.Value)
			if _bagedf != nil {
				return _bagedf
			}
			_debfaa.DragToColAttr = &_ddefb
			continue
		}
		if _fdddc.Name.Local == "hiddenLevel" {
			_aeacb, _gaaeb := _g.ParseBool(_fdddc.Value)
			if _gaaeb != nil {
				return _gaaeb
			}
			_debfaa.HiddenLevelAttr = &_aeacb
			continue
		}
		if _fdddc.Name.Local == "axis" {
			_debfaa.AxisAttr.UnmarshalXMLAttr(_fdddc)
			continue
		}
		if _fdddc.Name.Local == "showDropDowns" {
			_eaefe, _efgedd := _g.ParseBool(_fdddc.Value)
			if _efgedd != nil {
				return _efgedd
			}
			_debfaa.ShowDropDownsAttr = &_eaefe
			continue
		}
		if _fdddc.Name.Local == "showAll" {
			_dadacg, _feafe := _g.ParseBool(_fdddc.Value)
			if _feafe != nil {
				return _feafe
			}
			_debfaa.ShowAllAttr = &_dadacg
			continue
		}
		if _fdddc.Name.Local == "allDrilled" {
			_cgccb, _dgfaf := _g.ParseBool(_fdddc.Value)
			if _dgfaf != nil {
				return _dgfaf
			}
			_debfaa.AllDrilledAttr = &_cgccb
			continue
		}
		if _fdddc.Name.Local == "varSubtotal" {
			_cfgdca, _acedge := _g.ParseBool(_fdddc.Value)
			if _acedge != nil {
				return _acedge
			}
			_debfaa.VarSubtotalAttr = &_cfgdca
			continue
		}
	}
_baacf:
	for {
		_fgdbe, _fgggd := d.Token()
		if _fgggd != nil {
			return _fgggd
		}
		switch _bcfdd := _fgdbe.(type) {
		case _f.StartElement:
			switch _bcfdd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "items"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "items"}:
				_debfaa.Items = NewCT_Items()
				if _daccg := d.DecodeElement(_debfaa.Items, &_bcfdd); _daccg != nil {
					return _daccg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "autoSortScope"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "autoSortScope"}:
				_debfaa.AutoSortScope = NewCT_AutoSortScope()
				if _gdeeb := d.DecodeElement(_debfaa.AutoSortScope, &_bcfdd); _gdeeb != nil {
					return _gdeeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_debfaa.ExtLst = NewCT_ExtensionList()
				if _abdba := d.DecodeElement(_debfaa.ExtLst, &_bcfdd); _abdba != nil {
					return _abdba
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_PivotField \u0025v", _bcfdd.Name)
				if _ffed := d.Skip(); _ffed != nil {
					return _ffed
				}
			}
		case _f.EndElement:
			break _baacf
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the StyleSheet and its children
func (_abebc *StyleSheet) Validate() error { return _abebc.ValidateWithPath("StyleSheet") }

// ValidateWithPath validates the CT_ProtectedRange and its children, prefixing error messages with path
func (_dbffdg *CT_ProtectedRange) ValidateWithPath(path string) error { return nil }

type CT_PivotFilters struct {

	// Pivot Filter Count
	CountAttr *uint32

	// PivotTable Advanced Filter
	Filter []*CT_PivotFilter
}
type CT_Tables struct {

	// Count of Tables
	CountAttr *uint32

	// No Value
	M []*CT_TableMissing

	// Character Value
	S []*CT_XStringElement

	// Index
	X []*CT_Index
}
type CT_CustomChartsheetViews struct {

	// Custom Chart Sheet View
	CustomSheetView []*CT_CustomChartsheetView
}

// Validate validates the CT_CsPageSetup and its children
func (_fcega *CT_CsPageSetup) Validate() error { return _fcega.ValidateWithPath("CT_CsPageSetup") }

// Validate validates the CT_Rst and its children
func (_deagc *CT_Rst) Validate() error { return _deagc.ValidateWithPath("CT_Rst") }

// Validate validates the CT_DdeValues and its children
func (_cagf *CT_DdeValues) Validate() error { return _cagf.ValidateWithPath("CT_DdeValues") }

type ST_SheetState byte

// Validate validates the CT_DynamicFilter and its children
func (_cfadg *CT_DynamicFilter) Validate() error { return _cfadg.ValidateWithPath("CT_DynamicFilter") }
func NewCT_LevelGroup() *CT_LevelGroup {
	_fbecf := &CT_LevelGroup{}
	_fbecf.GroupMembers = NewCT_GroupMembers()
	return _fbecf
}

// ValidateWithPath validates the CT_TableStyles and its children, prefixing error messages with path
func (_dceeg *CT_TableStyles) ValidateWithPath(path string) error {
	for _bffgd, _ceccb := range _dceeg.TableStyle {
		if _gbaeg := _ceccb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fTableStyle\u005b\u0025d\u005d", path, _bffgd)); _gbaeg != nil {
			return _gbaeg
		}
	}
	return nil
}
func NewCT_SharedItems() *CT_SharedItems { _acafe := &CT_SharedItems{}; return _acafe }

// Validate validates the CT_RangeSets and its children
func (_gaegb *CT_RangeSets) Validate() error { return _gaegb.ValidateWithPath("CT_RangeSets") }

// ValidateWithPath validates the CT_SmartTags and its children, prefixing error messages with path
func (_cgaaga *CT_SmartTags) ValidateWithPath(path string) error {
	for _faeeb, _fbgda := range _cgaaga.CellSmartTags {
		if _aaddb := _fbgda.ValidateWithPath(_bg.Sprintf("%s/CellSmartTags[%d\u005d", path, _faeeb)); _aaddb != nil {
			return _aaddb
		}
	}
	return nil
}
func (_egefe ST_PivotAreaType) String() string {
	switch _egefe {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "normal"
	case 3:
		return "data"
	case 4:
		return "all"
	case 5:
		return "origin"
	case 6:
		return "button"
	case 7:
		return "topEnd"
	case 8:
		return "topRight"
	}
	return ""
}
func (_ebaa *CT_FilterColumn) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bdccd := range start.Attr {
		if _bdccd.Name.Local == "colId" {
			_cddacc, _gdddb := _g.ParseUint(_bdccd.Value, 10, 32)
			if _gdddb != nil {
				return _gdddb
			}
			_ebaa.ColIdAttr = uint32(_cddacc)
			continue
		}
		if _bdccd.Name.Local == "hiddenButton" {
			_bddbf, _acdcc := _g.ParseBool(_bdccd.Value)
			if _acdcc != nil {
				return _acdcc
			}
			_ebaa.HiddenButtonAttr = &_bddbf
			continue
		}
		if _bdccd.Name.Local == "showButton" {
			_dcec, _gddfd := _g.ParseBool(_bdccd.Value)
			if _gddfd != nil {
				return _gddfd
			}
			_ebaa.ShowButtonAttr = &_dcec
			continue
		}
	}
_dddga:
	for {
		_ecdae, _gdccc := d.Token()
		if _gdccc != nil {
			return _gdccc
		}
		switch _bgfa := _ecdae.(type) {
		case _f.StartElement:
			switch _bgfa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "filters"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "filters"}:
				_ebaa.Filters = NewCT_Filters()
				if _gabec := d.DecodeElement(_ebaa.Filters, &_bgfa); _gabec != nil {
					return _gabec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "top10"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "top10"}:
				_ebaa.Top10 = NewCT_Top10()
				if _dedag := d.DecodeElement(_ebaa.Top10, &_bgfa); _dedag != nil {
					return _dedag
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customFilters"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customFilters"}:
				_ebaa.CustomFilters = NewCT_CustomFilters()
				if _aeebc := d.DecodeElement(_ebaa.CustomFilters, &_bgfa); _aeebc != nil {
					return _aeebc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dynamicFilter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dynamicFilter"}:
				_ebaa.DynamicFilter = NewCT_DynamicFilter()
				if _bdfdf := d.DecodeElement(_ebaa.DynamicFilter, &_bgfa); _bdfdf != nil {
					return _bdfdf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colorFilter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colorFilter"}:
				_ebaa.ColorFilter = NewCT_ColorFilter()
				if _acce := d.DecodeElement(_ebaa.ColorFilter, &_bgfa); _acce != nil {
					return _acce
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "iconFilter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "iconFilter"}:
				_ebaa.IconFilter = NewCT_IconFilter()
				if _ddcfa := d.DecodeElement(_ebaa.IconFilter, &_bgfa); _ddcfa != nil {
					return _ddcfa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ebaa.ExtLst = NewCT_ExtensionList()
				if _bddeg := d.DecodeElement(_ebaa.ExtLst, &_bgfa); _bddeg != nil {
					return _bddeg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_FilterColumn\u0020\u0025v", _bgfa.Name)
				if _bbef := d.Skip(); _bbef != nil {
					return _bbef
				}
			}
		case _f.EndElement:
			break _dddga
		case _f.CharData:
		}
	}
	return nil
}
func (_gcacab *CT_XStringElement) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bdgde := range start.Attr {
		if _bdgde.Name.Local == "v" {
			_ebgfe, _gdbbg := _bdgde.Value, error(nil)
			if _gdbbg != nil {
				return _gdbbg
			}
			_gcacab.VAttr = _ebgfe
			continue
		}
	}
	for {
		_bcffc, _cebde := d.Token()
		if _cebde != nil {
			return _bg.Errorf("parsing\u0020CT_XStringElement: \u0025s", _cebde)
		}
		if _eefggd, _adgcc := _bcffc.(_f.EndElement); _adgcc && _eefggd.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Controls and its children, prefixing error messages with path
func (_adeg *CT_Controls) ValidateWithPath(path string) error {
	for _ceeag, _fcgag := range _adeg.Control {
		if _bfdc := _fcgag.ValidateWithPath(_bg.Sprintf("\u0025s\u002fControl\u005b\u0025d\u005d", path, _ceeag)); _bfdc != nil {
			return _bfdc
		}
	}
	return nil
}
func NewCT_DbPr() *CT_DbPr { _dbdffa := &CT_DbPr{}; return _dbdffa }

type CT_RowHierarchiesUsage struct {

	// Item Count
	CountAttr *uint32

	// Row OLAP Hierarchies
	RowHierarchyUsage []*CT_HierarchyUsage
}

// Validate validates the CT_GroupMembers and its children
func (_fbbf *CT_GroupMembers) Validate() error { return _fbbf.ValidateWithPath("CT_GroupMembers") }
func (_fcbfb *ST_FilterOperator) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_fcbfb = 0
	case "equal":
		*_fcbfb = 1
	case "lessThan":
		*_fcbfb = 2
	case "lessThanOrEqual":
		*_fcbfb = 3
	case "notEqual":
		*_fcbfb = 4
	case "greaterThanOrEqual":
		*_fcbfb = 5
	case "greaterThan":
		*_fcbfb = 6
	}
	return nil
}
func (_gfeba *CT_TextFields) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gfeba.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_gfeba.CountAttr)})
	}
	e.EncodeToken(start)
	_faaea := _f.StartElement{Name: _f.Name{Local: "ma:textField"}}
	for _, _becgc := range _gfeba.TextField {
		e.EncodeElement(_becgc, _faaea)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_ConditionalFormatting() *CT_ConditionalFormatting {
	_bdfc := &CT_ConditionalFormatting{}
	return _bdfc
}
func (_fgdcg *CT_Hyperlink) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _fgdcg.RefAttr)})
	if _fgdcg.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", *_fgdcg.IdAttr)})
	}
	if _fgdcg.LocationAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "location"}, Value: _bg.Sprintf("\u0025v", *_fgdcg.LocationAttr)})
	}
	if _fgdcg.TooltipAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "tooltip"}, Value: _bg.Sprintf("\u0025v", *_fgdcg.TooltipAttr)})
	}
	if _fgdcg.DisplayAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "display"}, Value: _bg.Sprintf("\u0025v", *_fgdcg.DisplayAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TableColumns and its children
func (_gdbgd *CT_TableColumns) Validate() error { return _gdbgd.ValidateWithPath("CT_TableColumns") }

// ValidateWithPath validates the CT_WebPublishObject and its children, prefixing error messages with path
func (_acacdab *CT_WebPublishObject) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_XStringElement and its children
func (_fbdfe *CT_XStringElement) Validate() error {
	return _fbdfe.ValidateWithPath("CT_XStringElement")
}
func (_daffcf ST_UnderlineValues) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_eeeafg := _f.Attr{}
	_eeeafg.Name = name
	switch _daffcf {
	case ST_UnderlineValuesUnset:
		_eeeafg.Value = ""
	case ST_UnderlineValuesSingle:
		_eeeafg.Value = "single"
	case ST_UnderlineValuesDouble:
		_eeeafg.Value = "double"
	case ST_UnderlineValuesSingleAccounting:
		_eeeafg.Value = "singleAccounting"
	case ST_UnderlineValuesDoubleAccounting:
		_eeeafg.Value = "doubleAccounting"
	case ST_UnderlineValuesNone:
		_eeeafg.Value = "none"
	}
	return _eeeafg, nil
}

// Validate validates the CT_Metadata and its children
func (_ffcb *CT_Metadata) Validate() error { return _ffcb.ValidateWithPath("CT_Metadata") }

type CT_DdeValues struct {

	// Rows
	RowsAttr *uint32

	// Columns
	ColsAttr *uint32

	// Value
	Value []*CT_DdeValue
}

func (_fdgga *CT_OleSize) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _addbe := range start.Attr {
		if _addbe.Name.Local == "ref" {
			_cafgb, _ccaa := _addbe.Value, error(nil)
			if _ccaa != nil {
				return _ccaa
			}
			_fdgga.RefAttr = _cafgb
			continue
		}
	}
	for {
		_cgfaa, _gedec := d.Token()
		if _gedec != nil {
			return _bg.Errorf("parsing\u0020CT_OleSize:\u0020%s", _gedec)
		}
		if _dagfbb, _cfebb := _cgfaa.(_f.EndElement); _cfebb && _dagfbb.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PivotCacheDefinition and its children, prefixing error messages with path
func (_fbcca *CT_PivotCacheDefinition) ValidateWithPath(path string) error {
	if _dedad := _fbcca.CacheSource.ValidateWithPath(path + "\u002fCacheSource"); _dedad != nil {
		return _dedad
	}
	if _adcdee := _fbcca.CacheFields.ValidateWithPath(path + "\u002fCacheFields"); _adcdee != nil {
		return _adcdee
	}
	if _fbcca.CacheHierarchies != nil {
		if _fggbgf := _fbcca.CacheHierarchies.ValidateWithPath(path + "\u002fCacheHierarchies"); _fggbgf != nil {
			return _fggbgf
		}
	}
	if _fbcca.Kpis != nil {
		if _dffcgg := _fbcca.Kpis.ValidateWithPath(path + "\u002fKpis"); _dffcgg != nil {
			return _dffcgg
		}
	}
	if _fbcca.TupleCache != nil {
		if _eaeae := _fbcca.TupleCache.ValidateWithPath(path + "/TupleCache"); _eaeae != nil {
			return _eaeae
		}
	}
	if _fbcca.CalculatedItems != nil {
		if _dacdg := _fbcca.CalculatedItems.ValidateWithPath(path + "\u002fCalculatedItems"); _dacdg != nil {
			return _dacdg
		}
	}
	if _fbcca.CalculatedMembers != nil {
		if _aceefc := _fbcca.CalculatedMembers.ValidateWithPath(path + "\u002fCalculatedMembers"); _aceefc != nil {
			return _aceefc
		}
	}
	if _fbcca.Dimensions != nil {
		if _fagaa := _fbcca.Dimensions.ValidateWithPath(path + "/Dimensions"); _fagaa != nil {
			return _fagaa
		}
	}
	if _fbcca.MeasureGroups != nil {
		if _fefbe := _fbcca.MeasureGroups.ValidateWithPath(path + "\u002fMeasureGroups"); _fefbe != nil {
			return _fefbe
		}
	}
	if _fbcca.Maps != nil {
		if _abca := _fbcca.Maps.ValidateWithPath(path + "\u002fMaps"); _abca != nil {
			return _abca
		}
	}
	if _fbcca.ExtLst != nil {
		if _fadec := _fbcca.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fadec != nil {
			return _fadec
		}
	}
	return nil
}
func NewCT_MergeCell() *CT_MergeCell           { _afdgd := &CT_MergeCell{}; return _afdgd }
func NewCT_SingleXmlCells() *CT_SingleXmlCells { _ceagb := &CT_SingleXmlCells{}; return _ceagb }
func (_feddff ST_UnderlineValues) ValidateWithPath(path string) error {
	switch _feddff {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_feddff))
	}
	return nil
}
func (_fgceb *CT_ColorFilter) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ceaf := range start.Attr {
		if _ceaf.Name.Local == "dxfId" {
			_bcbe, _gggga := _g.ParseUint(_ceaf.Value, 10, 32)
			if _gggga != nil {
				return _gggga
			}
			_befg := uint32(_bcbe)
			_fgceb.DxfIdAttr = &_befg
			continue
		}
		if _ceaf.Name.Local == "cellColor" {
			_eabba, _bdcca := _g.ParseBool(_ceaf.Value)
			if _bdcca != nil {
				return _bdcca
			}
			_fgceb.CellColorAttr = &_eabba
			continue
		}
	}
	for {
		_gbfd, _degc := d.Token()
		if _degc != nil {
			return _bg.Errorf("parsing\u0020CT_ColorFilter:\u0020\u0025s", _degc)
		}
		if _bagf, _edff := _gbfd.(_f.EndElement); _edff && _bagf.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_ExternalReferences() *CT_ExternalReferences {
	_fbggb := &CT_ExternalReferences{}
	return _fbggb
}
func NewCT_Member() *CT_Member { _aegee := &CT_Member{}; return _aegee }

const (
	ST_PaneStateUnset       ST_PaneState = 0
	ST_PaneStateSplit       ST_PaneState = 1
	ST_PaneStateFrozen      ST_PaneState = 2
	ST_PaneStateFrozenSplit ST_PaneState = 3
)

func (_feeeg *CT_CustomFilters) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bfbee := range start.Attr {
		if _bfbee.Name.Local == "and" {
			_eeee, _gabbd := _g.ParseBool(_bfbee.Value)
			if _gabbd != nil {
				return _gabbd
			}
			_feeeg.AndAttr = &_eeee
			continue
		}
	}
_cfee:
	for {
		_faadg, _eeeef := d.Token()
		if _eeeef != nil {
			return _eeeef
		}
		switch _facg := _faadg.(type) {
		case _f.StartElement:
			switch _facg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customFilter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customFilter"}:
				_dfbc := NewCT_CustomFilter()
				if _gfbbd := d.DecodeElement(_dfbc, &_facg); _gfbbd != nil {
					return _gfbbd
				}
				_feeeg.CustomFilter = append(_feeeg.CustomFilter, _dfbc)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CustomFilters\u0020\u0025v", _facg.Name)
				if _ecge := d.Skip(); _ecge != nil {
					return _ecge
				}
			}
		case _f.EndElement:
			break _cfee
		case _f.CharData:
		}
	}
	return nil
}
func (_adgbd *CT_Comments) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_adgbd.Authors = NewCT_Authors()
	_adgbd.CommentList = NewCT_CommentList()
_feeb:
	for {
		_face, _eefcf := d.Token()
		if _eefcf != nil {
			return _eefcf
		}
		switch _ecbcf := _face.(type) {
		case _f.StartElement:
			switch _ecbcf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "authors"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "authors"}:
				if _dbdff := d.DecodeElement(_adgbd.Authors, &_ecbcf); _dbdff != nil {
					return _dbdff
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "commentList"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "commentList"}:
				if _ceae := d.DecodeElement(_adgbd.CommentList, &_ecbcf); _ceae != nil {
					return _ceae
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_adgbd.ExtLst = NewCT_ExtensionList()
				if _ggbf := d.DecodeElement(_adgbd.ExtLst, &_ecbcf); _ggbf != nil {
					return _ggbf
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Comments\u0020\u0025v", _ecbcf.Name)
				if _bddga := d.Skip(); _bddga != nil {
					return _bddga
				}
			}
		case _f.EndElement:
			break _feeb
		case _f.CharData:
		}
	}
	return nil
}

const (
	ST_FilterOperatorUnset              ST_FilterOperator = 0
	ST_FilterOperatorEqual              ST_FilterOperator = 1
	ST_FilterOperatorLessThan           ST_FilterOperator = 2
	ST_FilterOperatorLessThanOrEqual    ST_FilterOperator = 3
	ST_FilterOperatorNotEqual           ST_FilterOperator = 4
	ST_FilterOperatorGreaterThanOrEqual ST_FilterOperator = 5
	ST_FilterOperatorGreaterThan        ST_FilterOperator = 6
)

type CT_CellProtection struct {

	// Cell Locked
	LockedAttr *bool

	// Hidden Cell
	HiddenAttr *bool
}

// ValidateWithPath validates the CT_WebPr and its children, prefixing error messages with path
func (_cbcagf *CT_WebPr) ValidateWithPath(path string) error {
	if _daeeag := _cbcagf.HtmlFormatAttr.ValidateWithPath(path + "\u002fHtmlFormatAttr"); _daeeag != nil {
		return _daeeag
	}
	if _cbcagf.Tables != nil {
		if _feadfd := _cbcagf.Tables.ValidateWithPath(path + "\u002fTables"); _feadfd != nil {
			return _feadfd
		}
	}
	return nil
}

type CT_Selection struct {

	// Pane
	PaneAttr ST_Pane

	// Active Cell Location
	ActiveCellAttr *string

	// Active Cell Index
	ActiveCellIdAttr *uint32

	// Sequence of References
	SqrefAttr *ST_Sqref
}

func (_aabdfb *ST_GroupBy) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_aabdfb = 0
	case "range":
		*_aabdfb = 1
	case "seconds":
		*_aabdfb = 2
	case "minutes":
		*_aabdfb = 3
	case "hours":
		*_aabdfb = 4
	case "days":
		*_aabdfb = 5
	case "months":
		*_aabdfb = 6
	case "quarters":
		*_aabdfb = 7
	case "years":
		*_aabdfb = 8
	}
	return nil
}
func (_edfaf ST_VolValueType) Validate() error { return _edfaf.ValidateWithPath("") }

const (
	ST_PatternTypeUnset           ST_PatternType = 0
	ST_PatternTypeNone            ST_PatternType = 1
	ST_PatternTypeSolid           ST_PatternType = 2
	ST_PatternTypeMediumGray      ST_PatternType = 3
	ST_PatternTypeDarkGray        ST_PatternType = 4
	ST_PatternTypeLightGray       ST_PatternType = 5
	ST_PatternTypeDarkHorizontal  ST_PatternType = 6
	ST_PatternTypeDarkVertical    ST_PatternType = 7
	ST_PatternTypeDarkDown        ST_PatternType = 8
	ST_PatternTypeDarkUp          ST_PatternType = 9
	ST_PatternTypeDarkGrid        ST_PatternType = 10
	ST_PatternTypeDarkTrellis     ST_PatternType = 11
	ST_PatternTypeLightHorizontal ST_PatternType = 12
	ST_PatternTypeLightVertical   ST_PatternType = 13
	ST_PatternTypeLightDown       ST_PatternType = 14
	ST_PatternTypeLightUp         ST_PatternType = 15
	ST_PatternTypeLightGrid       ST_PatternType = 16
	ST_PatternTypeLightTrellis    ST_PatternType = 17
	ST_PatternTypeGray125         ST_PatternType = 18
	ST_PatternTypeGray0625        ST_PatternType = 19
)

type CT_ExternalReference struct{ IdAttr string }

func (_fbgg *CT_ChartFormats) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gefa := range start.Attr {
		if _gefa.Name.Local == "count" {
			_ecgfg, _abae := _g.ParseUint(_gefa.Value, 10, 32)
			if _abae != nil {
				return _abae
			}
			_aafc := uint32(_ecgfg)
			_fbgg.CountAttr = &_aafc
			continue
		}
	}
_bebe:
	for {
		_ecb, _cbef := d.Token()
		if _cbef != nil {
			return _cbef
		}
		switch _bebb := _ecb.(type) {
		case _f.StartElement:
			switch _bebb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "chartFormat"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "chartFormat"}:
				_bcbf := NewCT_ChartFormat()
				if _cgc := d.DecodeElement(_bcbf, &_bebb); _cgc != nil {
					return _cgc
				}
				_fbgg.ChartFormat = append(_fbgg.ChartFormat, _bcbf)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ChartFormats\u0020\u0025v", _bebb.Name)
				if _gdggf := d.Skip(); _gdggf != nil {
					return _gdggf
				}
			}
		case _f.EndElement:
			break _bebe
		case _f.CharData:
		}
	}
	return nil
}
func (_bfecbde ST_OleUpdate) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bfecbde.String(), start)
}

// ValidateWithPath validates the CT_DefinedName and its children, prefixing error messages with path
func (_eebfba *CT_DefinedName) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_FutureMetadataBlock and its children, prefixing error messages with path
func (_aggg *CT_FutureMetadataBlock) ValidateWithPath(path string) error {
	if _aggg.ExtLst != nil {
		if _dafd := _aggg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dafd != nil {
			return _dafd
		}
	}
	return nil
}
func (_gfbcd *CT_CellStyle) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ddb := range start.Attr {
		if _ddb.Name.Local == "name" {
			_egbd, _aeab := _ddb.Value, error(nil)
			if _aeab != nil {
				return _aeab
			}
			_gfbcd.NameAttr = &_egbd
			continue
		}
		if _ddb.Name.Local == "xfId" {
			_fefef, _eaac := _g.ParseUint(_ddb.Value, 10, 32)
			if _eaac != nil {
				return _eaac
			}
			_gfbcd.XfIdAttr = uint32(_fefef)
			continue
		}
		if _ddb.Name.Local == "builtinId" {
			_ecaa, _ffad := _g.ParseUint(_ddb.Value, 10, 32)
			if _ffad != nil {
				return _ffad
			}
			_ebf := uint32(_ecaa)
			_gfbcd.BuiltinIdAttr = &_ebf
			continue
		}
		if _ddb.Name.Local == "iLevel" {
			_gaga, _cbfd := _g.ParseUint(_ddb.Value, 10, 32)
			if _cbfd != nil {
				return _cbfd
			}
			_dgcg := uint32(_gaga)
			_gfbcd.ILevelAttr = &_dgcg
			continue
		}
		if _ddb.Name.Local == "hidden" {
			_gbcb, _aeabf := _g.ParseBool(_ddb.Value)
			if _aeabf != nil {
				return _aeabf
			}
			_gfbcd.HiddenAttr = &_gbcb
			continue
		}
		if _ddb.Name.Local == "customBuiltin" {
			_cgdf, _fabc := _g.ParseBool(_ddb.Value)
			if _fabc != nil {
				return _fabc
			}
			_gfbcd.CustomBuiltinAttr = &_cgdf
			continue
		}
	}
_fadg:
	for {
		_ebe, _dgbf := d.Token()
		if _dgbf != nil {
			return _dgbf
		}
		switch _edca := _ebe.(type) {
		case _f.StartElement:
			switch _edca.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gfbcd.ExtLst = NewCT_ExtensionList()
				if _gedf := d.DecodeElement(_gfbcd.ExtLst, &_edca); _gedf != nil {
					return _gedf
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CellStyle\u0020\u0025v", _edca.Name)
				if _agae := d.Skip(); _agae != nil {
					return _agae
				}
			}
		case _f.EndElement:
			break _fadg
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_CellFormula() *CT_CellFormula { _agbg := &CT_CellFormula{}; return _agbg }
func (_abffg *CT_WorksheetSource) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _egceg := range start.Attr {
		if _egceg.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _egceg.Name.Local == "id" || _egceg.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _egceg.Name.Local == "id" {
			_egdaca, _fagfa := _egceg.Value, error(nil)
			if _fagfa != nil {
				return _fagfa
			}
			_abffg.IdAttr = &_egdaca
			continue
		}
		if _egceg.Name.Local == "ref" {
			_abebdd, _afcb := _egceg.Value, error(nil)
			if _afcb != nil {
				return _afcb
			}
			_abffg.RefAttr = &_abebdd
			continue
		}
		if _egceg.Name.Local == "name" {
			_ffgbb, _dcacfg := _egceg.Value, error(nil)
			if _dcacfg != nil {
				return _dcacfg
			}
			_abffg.NameAttr = &_ffgbb
			continue
		}
		if _egceg.Name.Local == "sheet" {
			_dgdbafe, _bbcfc := _egceg.Value, error(nil)
			if _bbcfc != nil {
				return _bbcfc
			}
			_abffg.SheetAttr = &_dgdbafe
			continue
		}
	}
	for {
		_ecgc, _fgccbec := d.Token()
		if _fgccbec != nil {
			return _bg.Errorf("parsing\u0020CT_WorksheetSource:\u0020\u0025s", _fgccbec)
		}
		if _dcefd, _bebcc := _ecgc.(_f.EndElement); _bebcc && _dcefd.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_Fonts and its children
func (_cdgdb *CT_Fonts) Validate() error { return _cdgdb.ValidateWithPath("CT_Fonts") }

type CT_PageMargins struct {

	// Left Page Margin
	LeftAttr float64

	// Right Page Margin
	RightAttr float64

	// Top Page Margin
	TopAttr float64

	// Bottom Page Margin
	BottomAttr float64

	// Header Page Margin
	HeaderAttr float64

	// Footer Page Margin
	FooterAttr float64
}
type CT_ObjectAnchor struct {

	// Move With Cells
	MoveWithCellsAttr *bool

	// Size With Cells
	SizeWithCellsAttr *bool
	From              *_d.From
	To                *_d.To
}

func (_bbdcg *CT_Sst) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bbdcg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bbdcg.CountAttr)})
	}
	if _bbdcg.UniqueCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueCount"}, Value: _bg.Sprintf("\u0025v", *_bbdcg.UniqueCountAttr)})
	}
	e.EncodeToken(start)
	if _bbdcg.Si != nil {
		_gbddd := _f.StartElement{Name: _f.Name{Local: "ma:si"}}
		for _, _dcfec := range _bbdcg.Si {
			e.EncodeElement(_dcfec, _gbddd)
		}
	}
	if _bbdcg.ExtLst != nil {
		_cegffb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_bbdcg.ExtLst, _cegffb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bfec *CT_CellWatch) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _eddd := range start.Attr {
		if _eddd.Name.Local == "r" {
			_abbfd, _dfcb := _eddd.Value, error(nil)
			if _dfcb != nil {
				return _dfcb
			}
			_bfec.RAttr = _abbfd
			continue
		}
	}
	for {
		_begd, _cdga := d.Token()
		if _cdga != nil {
			return _bg.Errorf("parsing\u0020CT_CellWatch:\u0020\u0025s", _cdga)
		}
		if _bebg, _fgfe := _begd.(_f.EndElement); _fgfe && _bebg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_agacg ST_ItemType) Validate() error { return _agacg.ValidateWithPath("") }
func NewCT_PCDKPIs() *CT_PCDKPIs           { _aeccf := &CT_PCDKPIs{}; return _aeccf }
func (_ffacc ST_RevisionAction) String() string {
	switch _ffacc {
	case 0:
		return ""
	case 1:
		return "add"
	case 2:
		return "delete"
	}
	return ""
}
func NewCT_String() *CT_String { _eaegb := &CT_String{}; return _eaegb }
func (_gffceb *ST_FontScheme) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_acaea, _fgggb := d.Token()
	if _fgggb != nil {
		return _fgggb
	}
	if _gfcfb, _fcfbea := _acaea.(_f.EndElement); _fcfbea && _gfcfb.Name == start.Name {
		*_gffceb = 1
		return nil
	}
	if _gaaeg, _eebdb := _acaea.(_f.CharData); !_eebdb {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _acaea)
	} else {
		switch string(_gaaeg) {
		case "":
			*_gffceb = 0
		case "none":
			*_gffceb = 1
		case "major":
			*_gffceb = 2
		case "minor":
			*_gffceb = 3
		}
	}
	_acaea, _fgggb = d.Token()
	if _fgggb != nil {
		return _fgggb
	}
	if _ebgab, _gcgcbe := _acaea.(_f.EndElement); _gcgcbe && _ebgab.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _acaea)
}

type CT_DataFields struct {

	// Data Items Count
	CountAttr *uint32

	// Data Field Item
	DataField []*CT_DataField
}

// ValidateWithPath validates the CT_Connections and its children, prefixing error messages with path
func (_fdgb *CT_Connections) ValidateWithPath(path string) error {
	for _abcg, _afaa := range _fdgb.Connection {
		if _ebda := _afaa.ValidateWithPath(_bg.Sprintf("\u0025s\u002fConnection\u005b\u0025d\u005d", path, _abcg)); _ebda != nil {
			return _ebda
		}
	}
	return nil
}

// Validate validates the CT_QueryTableRefresh and its children
func (_fffag *CT_QueryTableRefresh) Validate() error {
	return _fffag.ValidateWithPath("CT_QueryTableRefresh")
}

type CT_RgbColor struct {

	// Alpha Red Green Blue
	RgbAttr *string
}

// ValidateWithPath validates the CT_RevisionFormatting and its children, prefixing error messages with path
func (_bcdab *CT_RevisionFormatting) ValidateWithPath(path string) error {
	if _bcdab.Dxf != nil {
		if _cgagf := _bcdab.Dxf.ValidateWithPath(path + "\u002fDxf"); _cgagf != nil {
			return _cgagf
		}
	}
	if _bcdab.ExtLst != nil {
		if _egefc := _bcdab.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _egefc != nil {
			return _egefc
		}
	}
	return nil
}

type CT_SmartTagTypes struct {

	// Smart Tag Type
	SmartTagType []*CT_SmartTagType
}

// Validate validates the CT_MeasureDimensionMaps and its children
func (_fgaa *CT_MeasureDimensionMaps) Validate() error {
	return _fgaa.ValidateWithPath("CT_MeasureDimensionMaps")
}
func (_abbgb ST_SmartTagShow) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_ccgafa := _f.Attr{}
	_ccgafa.Name = name
	switch _abbgb {
	case ST_SmartTagShowUnset:
		_ccgafa.Value = ""
	case ST_SmartTagShowAll:
		_ccgafa.Value = "all"
	case ST_SmartTagShowNone:
		_ccgafa.Value = "none"
	case ST_SmartTagShowNoIndicator:
		_ccgafa.Value = "noIndicator"
	}
	return _ccgafa, nil
}
func (_gbacd *CT_IntProperty) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", _gbacd.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_faeeg *CT_PivotSelection) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_faeeg.PivotArea = NewCT_PivotArea()
	for _, _adfaa := range start.Attr {
		if _adfaa.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _adfaa.Name.Local == "id" || _adfaa.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _adfaa.Name.Local == "id" {
			_cbecce, _ffeeb := _adfaa.Value, error(nil)
			if _ffeeb != nil {
				return _ffeeb
			}
			_faeeg.IdAttr = &_cbecce
			continue
		}
		if _adfaa.Name.Local == "min" {
			_dbfag, _egffa := _g.ParseUint(_adfaa.Value, 10, 32)
			if _egffa != nil {
				return _egffa
			}
			_ccdcd := uint32(_dbfag)
			_faeeg.MinAttr = &_ccdcd
			continue
		}
		if _adfaa.Name.Local == "max" {
			_eafcg, _acbcg := _g.ParseUint(_adfaa.Value, 10, 32)
			if _acbcg != nil {
				return _acbcg
			}
			_gcbded := uint32(_eafcg)
			_faeeg.MaxAttr = &_gcbded
			continue
		}
		if _adfaa.Name.Local == "label" {
			_afdcb, _bbfee := _g.ParseBool(_adfaa.Value)
			if _bbfee != nil {
				return _bbfee
			}
			_faeeg.LabelAttr = &_afdcb
			continue
		}
		if _adfaa.Name.Local == "activeRow" {
			_dfded, _gecc := _g.ParseUint(_adfaa.Value, 10, 32)
			if _gecc != nil {
				return _gecc
			}
			_agbgb := uint32(_dfded)
			_faeeg.ActiveRowAttr = &_agbgb
			continue
		}
		if _adfaa.Name.Local == "extendable" {
			_bfgaa, _caaaa := _g.ParseBool(_adfaa.Value)
			if _caaaa != nil {
				return _caaaa
			}
			_faeeg.ExtendableAttr = &_bfgaa
			continue
		}
		if _adfaa.Name.Local == "axis" {
			_faeeg.AxisAttr.UnmarshalXMLAttr(_adfaa)
			continue
		}
		if _adfaa.Name.Local == "dimension" {
			_caabg, _gbafc := _g.ParseUint(_adfaa.Value, 10, 32)
			if _gbafc != nil {
				return _gbafc
			}
			_ddeff := uint32(_caabg)
			_faeeg.DimensionAttr = &_ddeff
			continue
		}
		if _adfaa.Name.Local == "start" {
			_cdceb, _ececb := _g.ParseUint(_adfaa.Value, 10, 32)
			if _ececb != nil {
				return _ececb
			}
			_dcadf := uint32(_cdceb)
			_faeeg.StartAttr = &_dcadf
			continue
		}
		if _adfaa.Name.Local == "pane" {
			_faeeg.PaneAttr.UnmarshalXMLAttr(_adfaa)
			continue
		}
		if _adfaa.Name.Local == "data" {
			_ggdab, _facfec := _g.ParseBool(_adfaa.Value)
			if _facfec != nil {
				return _facfec
			}
			_faeeg.DataAttr = &_ggdab
			continue
		}
		if _adfaa.Name.Local == "count" {
			_cbfeb, _eebed := _g.ParseUint(_adfaa.Value, 10, 32)
			if _eebed != nil {
				return _eebed
			}
			_cafef := uint32(_cbfeb)
			_faeeg.CountAttr = &_cafef
			continue
		}
		if _adfaa.Name.Local == "activeCol" {
			_gcdca, _gdea := _g.ParseUint(_adfaa.Value, 10, 32)
			if _gdea != nil {
				return _gdea
			}
			_befgc := uint32(_gcdca)
			_faeeg.ActiveColAttr = &_befgc
			continue
		}
		if _adfaa.Name.Local == "previousRow" {
			_gdcfed, _ffagbc := _g.ParseUint(_adfaa.Value, 10, 32)
			if _ffagbc != nil {
				return _ffagbc
			}
			_ebeef := uint32(_gdcfed)
			_faeeg.PreviousRowAttr = &_ebeef
			continue
		}
		if _adfaa.Name.Local == "previousCol" {
			_eccef, _cdfab := _g.ParseUint(_adfaa.Value, 10, 32)
			if _cdfab != nil {
				return _cdfab
			}
			_fbcge := uint32(_eccef)
			_faeeg.PreviousColAttr = &_fbcge
			continue
		}
		if _adfaa.Name.Local == "click" {
			_ebaef, _gcfeb := _g.ParseUint(_adfaa.Value, 10, 32)
			if _gcfeb != nil {
				return _gcfeb
			}
			_eceeb := uint32(_ebaef)
			_faeeg.ClickAttr = &_eceeb
			continue
		}
		if _adfaa.Name.Local == "showHeader" {
			_cccee, _cgceg := _g.ParseBool(_adfaa.Value)
			if _cgceg != nil {
				return _cgceg
			}
			_faeeg.ShowHeaderAttr = &_cccee
			continue
		}
	}
_dbffd:
	for {
		_ddaca, _egabc := d.Token()
		if _egabc != nil {
			return _egabc
		}
		switch _ecbad := _ddaca.(type) {
		case _f.StartElement:
			switch _ecbad.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotArea"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotArea"}:
				if _egbcf := d.DecodeElement(_faeeg.PivotArea, &_ecbad); _egbcf != nil {
					return _egbcf
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_PivotSelection\u0020\u0025v", _ecbad.Name)
				if _cacbe := d.Skip(); _cacbe != nil {
					return _cacbe
				}
			}
		case _f.EndElement:
			break _dbffd
		case _f.CharData:
		}
	}
	return nil
}

type CT_MdxSet struct {

	// Set Definition Index
	NsAttr uint32

	// Sort By Member Index Count
	CAttr *uint32

	// Set Sort Order
	OAttr ST_MdxSetOrder

	// Member Unique Name Index
	N []*CT_MetadataStringIndex
}
type CT_SheetViews struct {

	// Worksheet View
	SheetView []*CT_SheetView

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_becceda ST_CellType) Validate() error { return _becceda.ValidateWithPath("") }
func (_ceced ST_UpdateLinks) String() string {
	switch _ceced {
	case 0:
		return ""
	case 1:
		return "userSet"
	case 2:
		return "never"
	case 3:
		return "always"
	}
	return ""
}
func (_gcbfg *CT_NumFmt) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "numFmtId"}, Value: _bg.Sprintf("\u0025v", _gcbfg.NumFmtIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "formatCode"}, Value: _bg.Sprintf("\u0025v", _gcbfg.FormatCodeAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_CalculatedMembers() *CT_CalculatedMembers { _ffdc := &CT_CalculatedMembers{}; return _ffdc }

type CT_XmlCellPr struct {

	// Table Field Id
	IdAttr uint32

	// Unique Table Name
	UniqueNameAttr *string

	// Column XML Properties
	XmlPr *CT_XmlPr

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}
type CT_MeasureDimensionMap struct {

	// Measure Group Id
	MeasureGroupAttr *uint32

	// Dimension Id
	DimensionAttr *uint32
}
type ST_PageOrder byte
type CT_CalculatedItem struct {

	// Field Index
	FieldAttr *uint32

	// Calculated Item Formula
	FormulaAttr *string

	// Calculated Item Location
	PivotArea *CT_PivotArea

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_bfbfee *CT_MetadataBlocks) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aaefcc := range start.Attr {
		if _aaefcc.Name.Local == "count" {
			_daffef, _gdefb := _g.ParseUint(_aaefcc.Value, 10, 32)
			if _gdefb != nil {
				return _gdefb
			}
			_gead := uint32(_daffef)
			_bfbfee.CountAttr = &_gead
			continue
		}
	}
_bbcaa:
	for {
		_gdbd, _ffdeb := d.Token()
		if _ffdeb != nil {
			return _ffdeb
		}
		switch _bgdag := _gdbd.(type) {
		case _f.StartElement:
			switch _bgdag.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "bk"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "bk"}:
				_abcbd := NewCT_MetadataBlock()
				if _eceda := d.DecodeElement(_abcbd, &_bgdag); _eceda != nil {
					return _eceda
				}
				_bfbfee.Bk = append(_bfbfee.Bk, _abcbd)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_MetadataBlocks\u0020\u0025v", _bgdag.Name)
				if _fdcgf := d.Skip(); _fdcgf != nil {
					return _fdcgf
				}
			}
		case _f.EndElement:
			break _bbcaa
		case _f.CharData:
		}
	}
	return nil
}
func (_dddfc ST_Type) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_dddfc.String(), start)
}
func (_aaece ST_Axis) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bbfgae := _f.Attr{}
	_bbfgae.Name = name
	switch _aaece {
	case ST_AxisUnset:
		_bbfgae.Value = ""
	case ST_AxisAxisRow:
		_bbfgae.Value = "axisRow"
	case ST_AxisAxisCol:
		_bbfgae.Value = "axisCol"
	case ST_AxisAxisPage:
		_bbfgae.Value = "axisPage"
	case ST_AxisAxisValues:
		_bbfgae.Value = "axisValues"
	}
	return _bbfgae, nil
}
func (_bfecf *CT_PhoneticRun) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sb"}, Value: _bg.Sprintf("\u0025v", _bfecf.SbAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "eb"}, Value: _bg.Sprintf("\u0025v", _bfecf.EbAttr)})
	e.EncodeToken(start)
	_fgbfe := _f.StartElement{Name: _f.Name{Local: "ma:t"}}
	_cb.AddPreserveSpaceAttr(&_fgbfe, _bfecf.T)
	e.EncodeElement(_bfecf.T, _fgbfe)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_edgeac *CT_CellStyles) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fcfb := range start.Attr {
		if _fcfb.Name.Local == "count" {
			_dgbc, _aecc := _g.ParseUint(_fcfb.Value, 10, 32)
			if _aecc != nil {
				return _aecc
			}
			_cfgc := uint32(_dgbc)
			_edgeac.CountAttr = &_cfgc
			continue
		}
	}
_gcfb:
	for {
		_gbeaec, _gbbg := d.Token()
		if _gbbg != nil {
			return _gbbg
		}
		switch _dcba := _gbeaec.(type) {
		case _f.StartElement:
			switch _dcba.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellStyle"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellStyle"}:
				_dcgf := NewCT_CellStyle()
				if _gade := d.DecodeElement(_dcgf, &_dcba); _gade != nil {
					return _gade
				}
				_edgeac.CellStyle = append(_edgeac.CellStyle, _dcgf)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_CellStyles \u0025v", _dcba.Name)
				if _cabb := d.Skip(); _cabb != nil {
					return _cabb
				}
			}
		case _f.EndElement:
			break _gcfb
		case _f.CharData:
		}
	}
	return nil
}
func (_gddeg *CT_Color) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bgac := range start.Attr {
		if _bgac.Name.Local == "auto" {
			_adbc, _gbeag := _g.ParseBool(_bgac.Value)
			if _gbeag != nil {
				return _gbeag
			}
			_gddeg.AutoAttr = &_adbc
			continue
		}
		if _bgac.Name.Local == "indexed" {
			_feaad, _efaa := _g.ParseUint(_bgac.Value, 10, 32)
			if _efaa != nil {
				return _efaa
			}
			_fdbc := uint32(_feaad)
			_gddeg.IndexedAttr = &_fdbc
			continue
		}
		if _bgac.Name.Local == "rgb" {
			_dgfae, _bca := _bgac.Value, error(nil)
			if _bca != nil {
				return _bca
			}
			_gddeg.RgbAttr = &_dgfae
			continue
		}
		if _bgac.Name.Local == "theme" {
			_egfga, _dceb := _g.ParseUint(_bgac.Value, 10, 32)
			if _dceb != nil {
				return _dceb
			}
			_fgaf := uint32(_egfga)
			_gddeg.ThemeAttr = &_fgaf
			continue
		}
		if _bgac.Name.Local == "tint" {
			_dgafg, _cfdd := _g.ParseFloat(_bgac.Value, 64)
			if _cfdd != nil {
				return _cfdd
			}
			_gddeg.TintAttr = &_dgafg
			continue
		}
	}
	for {
		_abdg, _efbg := d.Token()
		if _efbg != nil {
			return _bg.Errorf("parsing\u0020CT_Color: \u0025s", _efbg)
		}
		if _agaa, _bfdf := _abdg.(_f.EndElement); _bfdf && _agaa.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ChartsheetPr and its children, prefixing error messages with path
func (_gfa *CT_ChartsheetPr) ValidateWithPath(path string) error {
	if _gfa.TabColor != nil {
		if _fecg := _gfa.TabColor.ValidateWithPath(path + "\u002fTabColor"); _fecg != nil {
			return _fecg
		}
	}
	return nil
}
func (_fafg *CT_ChartsheetViews) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_gdee:
	for {
		_aeae, _edbd := d.Token()
		if _edbd != nil {
			return _edbd
		}
		switch _ebadg := _aeae.(type) {
		case _f.StartElement:
			switch _ebadg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetView"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetView"}:
				_afge := NewCT_ChartsheetView()
				if _aefff := d.DecodeElement(_afge, &_ebadg); _aefff != nil {
					return _aefff
				}
				_fafg.SheetView = append(_fafg.SheetView, _afge)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_fafg.ExtLst = NewCT_ExtensionList()
				if _fdbee := d.DecodeElement(_fafg.ExtLst, &_ebadg); _fdbee != nil {
					return _fdbee
				}
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_ChartsheetViews\u0020\u0025v", _ebadg.Name)
				if _caff := d.Skip(); _caff != nil {
					return _caff
				}
			}
		case _f.EndElement:
			break _gdee
		case _f.CharData:
		}
	}
	return nil
}
func (_efebgc *ST_TextVAlign) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dbfgd, _beagfd := d.Token()
	if _beagfd != nil {
		return _beagfd
	}
	if _dgbed, _eegbag := _dbfgd.(_f.EndElement); _eegbag && _dgbed.Name == start.Name {
		*_efebgc = 1
		return nil
	}
	if _accccb, _ffdb := _dbfgd.(_f.CharData); !_ffdb {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dbfgd)
	} else {
		switch string(_accccb) {
		case "":
			*_efebgc = 0
		case "top":
			*_efebgc = 1
		case "center":
			*_efebgc = 2
		case "bottom":
			*_efebgc = 3
		case "justify":
			*_efebgc = 4
		case "distributed":
			*_efebgc = 5
		}
	}
	_dbfgd, _beagfd = d.Token()
	if _beagfd != nil {
		return _beagfd
	}
	if _aeafgf, _agceff := _dbfgd.(_f.EndElement); _agceff && _aeafgf.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dbfgd)
}

// Validate validates the CT_String and its children
func (_cebff *CT_String) Validate() error { return _cebff.ValidateWithPath("CT_String") }

// Validate validates the Table and its children
func (_gcecfe *Table) Validate() error { return _gcecfe.ValidateWithPath("Table") }
func (_cceca *CT_DataRef) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cceca.RefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", *_cceca.RefAttr)})
	}
	if _cceca.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_cceca.NameAttr)})
	}
	if _cceca.SheetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheet"}, Value: _bg.Sprintf("\u0025v", *_cceca.SheetAttr)})
	}
	if _cceca.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", *_cceca.IdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_DataValidations struct {

	// Disable Prompts
	DisablePromptsAttr *bool

	// Top Left Corner (X Coodrinate)
	XWindowAttr *uint32

	// Top Left Corner (Y Coordinate)
	YWindowAttr *uint32

	// Data Validation Item Count
	CountAttr *uint32

	// Data Validation
	DataValidation []*CT_DataValidation
}

// ValidateWithPath validates the CT_WebPublishItems and its children, prefixing error messages with path
func (_bfece *CT_WebPublishItems) ValidateWithPath(path string) error {
	for _bgagf, _cdgfeb := range _bfece.WebPublishItem {
		if _bcdfa := _cdgfeb.ValidateWithPath(_bg.Sprintf("%s\u002fWebPublishItem\u005b\u0025d\u005d", path, _bgagf)); _bcdfa != nil {
			return _bcdfa
		}
	}
	return nil
}
func NewCT_Users() *CT_Users { _dfedd := &CT_Users{}; return _dfedd }
func (_ebce *CT_CalcChain) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_gbb:
	for {
		_ccb, _feead := d.Token()
		if _feead != nil {
			return _feead
		}
		switch _dfdf := _ccb.(type) {
		case _f.StartElement:
			switch _dfdf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "c"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "c"}:
				_fcdc := NewCT_CalcCell()
				if _bgbf := d.DecodeElement(_fcdc, &_dfdf); _bgbf != nil {
					return _bgbf
				}
				_ebce.C = append(_ebce.C, _fcdc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ebce.ExtLst = NewCT_ExtensionList()
				if _fcgg := d.DecodeElement(_ebce.ExtLst, &_dfdf); _fcgg != nil {
					return _fcgg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CalcChain\u0020\u0025v", _dfdf.Name)
				if _ebdg := d.Skip(); _ebdg != nil {
					return _ebdg
				}
			}
		case _f.EndElement:
			break _gbb
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_PCDKPI() *CT_PCDKPI { _becdda := &CT_PCDKPI{}; return _becdda }

// ValidateWithPath validates the CT_BorderPr and its children, prefixing error messages with path
func (_gga *CT_BorderPr) ValidateWithPath(path string) error {
	if _ecec := _gga.StyleAttr.ValidateWithPath(path + "\u002fStyleAttr"); _ecec != nil {
		return _ecec
	}
	if _gga.Color != nil {
		if _gded := _gga.Color.ValidateWithPath(path + "\u002fColor"); _gded != nil {
			return _gded
		}
	}
	return nil
}
func (_bfecbd *ST_HtmlFmt) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bfecbd = 0
	case "none":
		*_bfecbd = 1
	case "rtf":
		*_bfecbd = 2
	case "all":
		*_bfecbd = 3
	}
	return nil
}
func (_eaecg *CT_RevisionDefinedName) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _eaecg.LocalSheetIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "localSheetId"}, Value: _bg.Sprintf("\u0025v", *_eaecg.LocalSheetIdAttr)})
	}
	if _eaecg.CustomViewAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "customView"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eaecg.CustomViewAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _eaecg.NameAttr)})
	if _eaecg.FunctionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "function"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eaecg.FunctionAttr))})
	}
	if _eaecg.OldFunctionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldFunction"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eaecg.OldFunctionAttr))})
	}
	if _eaecg.FunctionGroupIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "functionGroupId"}, Value: _bg.Sprintf("\u0025v", *_eaecg.FunctionGroupIdAttr)})
	}
	if _eaecg.OldFunctionGroupIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldFunctionGroupId"}, Value: _bg.Sprintf("\u0025v", *_eaecg.OldFunctionGroupIdAttr)})
	}
	if _eaecg.ShortcutKeyAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "shortcutKey"}, Value: _bg.Sprintf("\u0025v", *_eaecg.ShortcutKeyAttr)})
	}
	if _eaecg.OldShortcutKeyAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldShortcutKey"}, Value: _bg.Sprintf("\u0025v", *_eaecg.OldShortcutKeyAttr)})
	}
	if _eaecg.HiddenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hidden"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eaecg.HiddenAttr))})
	}
	if _eaecg.OldHiddenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldHidden"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eaecg.OldHiddenAttr))})
	}
	if _eaecg.CustomMenuAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "customMenu"}, Value: _bg.Sprintf("\u0025v", *_eaecg.CustomMenuAttr)})
	}
	if _eaecg.OldCustomMenuAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldCustomMenu"}, Value: _bg.Sprintf("\u0025v", *_eaecg.OldCustomMenuAttr)})
	}
	if _eaecg.DescriptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "description"}, Value: _bg.Sprintf("\u0025v", *_eaecg.DescriptionAttr)})
	}
	if _eaecg.OldDescriptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldDescription"}, Value: _bg.Sprintf("\u0025v", *_eaecg.OldDescriptionAttr)})
	}
	if _eaecg.HelpAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "help"}, Value: _bg.Sprintf("\u0025v", *_eaecg.HelpAttr)})
	}
	if _eaecg.OldHelpAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldHelp"}, Value: _bg.Sprintf("\u0025v", *_eaecg.OldHelpAttr)})
	}
	if _eaecg.StatusBarAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "statusBar"}, Value: _bg.Sprintf("\u0025v", *_eaecg.StatusBarAttr)})
	}
	if _eaecg.OldStatusBarAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldStatusBar"}, Value: _bg.Sprintf("\u0025v", *_eaecg.OldStatusBarAttr)})
	}
	if _eaecg.CommentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "comment"}, Value: _bg.Sprintf("\u0025v", *_eaecg.CommentAttr)})
	}
	if _eaecg.OldCommentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldComment"}, Value: _bg.Sprintf("\u0025v", *_eaecg.OldCommentAttr)})
	}
	if _eaecg.RIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rId"}, Value: _bg.Sprintf("\u0025v", *_eaecg.RIdAttr)})
	}
	if _eaecg.UaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ua"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eaecg.UaAttr))})
	}
	if _eaecg.RaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ra"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eaecg.RaAttr))})
	}
	e.EncodeToken(start)
	if _eaecg.Formula != nil {
		_dabbb := _f.StartElement{Name: _f.Name{Local: "ma:formula"}}
		_cb.AddPreserveSpaceAttr(&_dabbb, *_eaecg.Formula)
		e.EncodeElement(_eaecg.Formula, _dabbb)
	}
	if _eaecg.OldFormula != nil {
		_ddggg := _f.StartElement{Name: _f.Name{Local: "ma:oldFormula"}}
		_cb.AddPreserveSpaceAttr(&_ddggg, *_eaecg.OldFormula)
		e.EncodeElement(_eaecg.OldFormula, _ddggg)
	}
	if _eaecg.ExtLst != nil {
		_cfbec := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_eaecg.ExtLst, _cfbec)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_FileRecoveryPr() *CT_FileRecoveryPr { _gace := &CT_FileRecoveryPr{}; return _gace }
func NewCT_OleLink() *CT_OleLink               { _bfbbb := &CT_OleLink{}; return _bfbbb }
func NewCT_TableStyles() *CT_TableStyles       { _fcfcge := &CT_TableStyles{}; return _fcfcge }
func (_ffggga ST_FontScheme) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bffafe := _f.Attr{}
	_bffafe.Name = name
	switch _ffggga {
	case ST_FontSchemeUnset:
		_bffafe.Value = ""
	case ST_FontSchemeNone:
		_bffafe.Value = "none"
	case ST_FontSchemeMajor:
		_bffafe.Value = "major"
	case ST_FontSchemeMinor:
		_bffafe.Value = "minor"
	}
	return _bffafe, nil
}

// ValidateWithPath validates the CT_Format and its children, prefixing error messages with path
func (_bdgc *CT_Format) ValidateWithPath(path string) error {
	if _fbbg := _bdgc.ActionAttr.ValidateWithPath(path + "/ActionAttr"); _fbbg != nil {
		return _fbbg
	}
	if _dceed := _bdgc.PivotArea.ValidateWithPath(path + "\u002fPivotArea"); _dceed != nil {
		return _dceed
	}
	if _bdgc.ExtLst != nil {
		if _fbbe := _bdgc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fbbe != nil {
			return _fbbe
		}
	}
	return nil
}

type CT_Cfvo struct {

	// Type
	TypeAttr ST_CfvoType

	// Value
	ValAttr *string

	// Greater Than Or Equal
	GteAttr *bool
	ExtLst  *CT_ExtensionList
}

func (_efcb *CT_Consolidation) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_efcb.RangeSets = NewCT_RangeSets()
	for _, _acfad := range start.Attr {
		if _acfad.Name.Local == "autoPage" {
			_fcfca, _ddeb := _g.ParseBool(_acfad.Value)
			if _ddeb != nil {
				return _ddeb
			}
			_efcb.AutoPageAttr = &_fcfca
			continue
		}
	}
_aafb:
	for {
		_ggadfd, _fceb := d.Token()
		if _fceb != nil {
			return _fceb
		}
		switch _dgab := _ggadfd.(type) {
		case _f.StartElement:
			switch _dgab.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pages"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pages"}:
				_efcb.Pages = NewCT_Pages()
				if _bfde := d.DecodeElement(_efcb.Pages, &_dgab); _bfde != nil {
					return _bfde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rangeSets"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rangeSets"}:
				if _cfaf := d.DecodeElement(_efcb.RangeSets, &_dgab); _cfaf != nil {
					return _cfaf
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Consolidation\u0020\u0025v", _dgab.Name)
				if _ebea := d.Skip(); _ebea != nil {
					return _ebea
				}
			}
		case _f.EndElement:
			break _aafb
		case _f.CharData:
		}
	}
	return nil
}
func (_fbgbc ST_SortBy) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_fbffb := _f.Attr{}
	_fbffb.Name = name
	switch _fbgbc {
	case ST_SortByUnset:
		_fbffb.Value = ""
	case ST_SortByValue:
		_fbffb.Value = "value"
	case ST_SortByCellColor:
		_fbffb.Value = "cellColor"
	case ST_SortByFontColor:
		_fbffb.Value = "fontColor"
	case ST_SortByIcon:
		_fbffb.Value = "icon"
	}
	return _fbffb, nil
}

// Validate validates the CT_Reviewed and its children
func (_eeffg *CT_Reviewed) Validate() error { return _eeffg.ValidateWithPath("CT_Reviewed") }
func (_abfga *CT_ProtectedRanges) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_fbagd := _f.StartElement{Name: _f.Name{Local: "ma:protectedRange"}}
	for _, _bddag := range _abfga.ProtectedRange {
		e.EncodeElement(_bddag, _fbagd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gdgcc *CT_SharedItems) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gdgcc.ContainsSemiMixedTypesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "containsSemiMixedTypes"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgcc.ContainsSemiMixedTypesAttr))})
	}
	if _gdgcc.ContainsNonDateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "containsNonDate"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgcc.ContainsNonDateAttr))})
	}
	if _gdgcc.ContainsDateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "containsDate"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgcc.ContainsDateAttr))})
	}
	if _gdgcc.ContainsStringAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "containsString"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgcc.ContainsStringAttr))})
	}
	if _gdgcc.ContainsBlankAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "containsBlank"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgcc.ContainsBlankAttr))})
	}
	if _gdgcc.ContainsMixedTypesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "containsMixedTypes"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgcc.ContainsMixedTypesAttr))})
	}
	if _gdgcc.ContainsNumberAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "containsNumber"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgcc.ContainsNumberAttr))})
	}
	if _gdgcc.ContainsIntegerAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "containsInteger"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgcc.ContainsIntegerAttr))})
	}
	if _gdgcc.MinValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minValue"}, Value: _bg.Sprintf("\u0025v", *_gdgcc.MinValueAttr)})
	}
	if _gdgcc.MaxValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "maxValue"}, Value: _bg.Sprintf("\u0025v", *_gdgcc.MaxValueAttr)})
	}
	if _gdgcc.MinDateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minDate"}, Value: _bg.Sprintf("\u0025v", *_gdgcc.MinDateAttr)})
	}
	if _gdgcc.MaxDateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "maxDate"}, Value: _bg.Sprintf("\u0025v", *_gdgcc.MaxDateAttr)})
	}
	if _gdgcc.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_gdgcc.CountAttr)})
	}
	if _gdgcc.LongTextAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "longText"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdgcc.LongTextAttr))})
	}
	e.EncodeToken(start)
	if _gdgcc.M != nil {
		_gbfbc := _f.StartElement{Name: _f.Name{Local: "ma:m"}}
		for _, _aabde := range _gdgcc.M {
			e.EncodeElement(_aabde, _gbfbc)
		}
	}
	if _gdgcc.N != nil {
		_efcfg := _f.StartElement{Name: _f.Name{Local: "ma:n"}}
		for _, _aggceg := range _gdgcc.N {
			e.EncodeElement(_aggceg, _efcfg)
		}
	}
	if _gdgcc.B != nil {
		_acagea := _f.StartElement{Name: _f.Name{Local: "ma:b"}}
		for _, _fgabca := range _gdgcc.B {
			e.EncodeElement(_fgabca, _acagea)
		}
	}
	if _gdgcc.E != nil {
		_ageag := _f.StartElement{Name: _f.Name{Local: "ma:e"}}
		for _, _gbfgg := range _gdgcc.E {
			e.EncodeElement(_gbfgg, _ageag)
		}
	}
	if _gdgcc.S != nil {
		_begfg := _f.StartElement{Name: _f.Name{Local: "ma:s"}}
		for _, _cfgee := range _gdgcc.S {
			e.EncodeElement(_cfgee, _begfg)
		}
	}
	if _gdgcc.D != nil {
		_dbfede := _f.StartElement{Name: _f.Name{Local: "ma:d"}}
		for _, _ffdff := range _gdgcc.D {
			e.EncodeElement(_ffdff, _dbfede)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gaaca *CT_Reviewed) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bcebbf := range start.Attr {
		if _bcebbf.Name.Local == "rId" {
			_efecf, _adgdg := _g.ParseUint(_bcebbf.Value, 10, 32)
			if _adgdg != nil {
				return _adgdg
			}
			_gaaca.RIdAttr = uint32(_efecf)
			continue
		}
	}
	for {
		_cceb, _agfeg := d.Token()
		if _agfeg != nil {
			return _bg.Errorf("parsing\u0020CT_Reviewed:\u0020\u0025s", _agfeg)
		}
		if _ecceg, _fdcbbd := _cceb.(_f.EndElement); _fdcbbd && _ecceg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dccgd *CT_CustomChartsheetView) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dccgd.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	for _, _bfdbf := range start.Attr {
		if _bfdbf.Name.Local == "guid" {
			_bgaa, _dbbb := _bfdbf.Value, error(nil)
			if _dbbb != nil {
				return _dbbb
			}
			_dccgd.GuidAttr = _bgaa
			continue
		}
		if _bfdbf.Name.Local == "scale" {
			_feag, _ccda := _g.ParseUint(_bfdbf.Value, 10, 32)
			if _ccda != nil {
				return _ccda
			}
			_abfc := uint32(_feag)
			_dccgd.ScaleAttr = &_abfc
			continue
		}
		if _bfdbf.Name.Local == "state" {
			_dccgd.StateAttr.UnmarshalXMLAttr(_bfdbf)
			continue
		}
		if _bfdbf.Name.Local == "zoomToFit" {
			_babf, _gggb := _g.ParseBool(_bfdbf.Value)
			if _gggb != nil {
				return _gggb
			}
			_dccgd.ZoomToFitAttr = &_babf
			continue
		}
	}
_fccea:
	for {
		_cbcde, _cgff := d.Token()
		if _cgff != nil {
			return _cgff
		}
		switch _ddbbae := _cbcde.(type) {
		case _f.StartElement:
			switch _ddbbae.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageMargins"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageMargins"}:
				_dccgd.PageMargins = NewCT_PageMargins()
				if _aede := d.DecodeElement(_dccgd.PageMargins, &_ddbbae); _aede != nil {
					return _aede
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageSetup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageSetup"}:
				_dccgd.PageSetup = NewCT_CsPageSetup()
				if _cdgdc := d.DecodeElement(_dccgd.PageSetup, &_ddbbae); _cdgdc != nil {
					return _cdgdc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "headerFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "headerFooter"}:
				_dccgd.HeaderFooter = NewCT_HeaderFooter()
				if _bccc := d.DecodeElement(_dccgd.HeaderFooter, &_ddbbae); _bccc != nil {
					return _bccc
				}
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_CustomChartsheetView \u0025v", _ddbbae.Name)
				if _fbdec := d.Skip(); _fbdec != nil {
					return _fbdec
				}
			}
		case _f.EndElement:
			break _fccea
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_CalculatedItems() *CT_CalculatedItems { _aeeee := &CT_CalculatedItems{}; return _aeeee }
func (_ffaae *CT_SheetDimension) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _ffaae.RefAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_SheetBackgroundPicture and its children, prefixing error messages with path
func (_dadge *CT_SheetBackgroundPicture) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_Color and its children, prefixing error messages with path
func (_ggdg *CT_Color) ValidateWithPath(path string) error { return nil }

type CT_ObjectPr struct {

	// Locked Flag
	LockedAttr *bool

	// Default Size Flag
	DefaultSizeAttr *bool

	// Print Flag
	PrintAttr *bool

	// Disabled Flag
	DisabledAttr *bool

	// UI Object Flag
	UiObjectAttr *bool

	// Automatic Fill Flag
	AutoFillAttr *bool

	// Automatic Line Flag
	AutoLineAttr *bool

	// Automatic Size Flag
	AutoPictAttr *bool

	// Custom Function
	MacroAttr *string

	// Alternative Text
	AltTextAttr *string

	// Dynamic Data Exchange Flag
	DdeAttr *bool
	IdAttr  *string
	Anchor  *CT_ObjectAnchor
}

func (_agbcc *CT_MeasureGroup) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _eggda := range start.Attr {
		if _eggda.Name.Local == "name" {
			_adaed, _dabd := _eggda.Value, error(nil)
			if _dabd != nil {
				return _dabd
			}
			_agbcc.NameAttr = _adaed
			continue
		}
		if _eggda.Name.Local == "caption" {
			_acbgad, _babgf := _eggda.Value, error(nil)
			if _babgf != nil {
				return _babgf
			}
			_agbcc.CaptionAttr = _acbgad
			continue
		}
	}
	for {
		_dfbfg, _ddde := d.Token()
		if _ddde != nil {
			return _bg.Errorf("parsing CT_MeasureGroup:\u0020\u0025s", _ddde)
		}
		if _cggggf, _baabe := _dfbfg.(_f.EndElement); _baabe && _cggggf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bgb *CT_CalcCell) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bgb.RAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", *_bgb.RAttr)})
	}
	if _bgb.RefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", *_bgb.RefAttr)})
	}
	if _bgb.IAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "i"}, Value: _bg.Sprintf("\u0025v", *_bgb.IAttr)})
	}
	if _bgb.SAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "s"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgb.SAttr))})
	}
	if _bgb.LAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "l"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgb.LAttr))})
	}
	if _bgb.TAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "t"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgb.TAttr))})
	}
	if _bgb.AAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "a"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgb.AAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ceebdb ST_Axis) ValidateWithPath(path string) error {
	switch _ceebdb {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ceebdb))
	}
	return nil
}

type CT_SmartTagType struct {

	// SmartTag Namespace URI
	NamespaceUriAttr *string

	// Name
	NameAttr *string

	// Smart Tag URL
	UrlAttr *string
}
type Connections struct{ CT_Connections }

func NewCT_CellWatch() *CT_CellWatch { _bggc := &CT_CellWatch{}; return _bggc }
func (_deec *CT_CacheHierarchies) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bcgc := range start.Attr {
		if _bcgc.Name.Local == "count" {
			_bgf, _egc := _g.ParseUint(_bcgc.Value, 10, 32)
			if _egc != nil {
				return _egc
			}
			_dfdb := uint32(_bgf)
			_deec.CountAttr = &_dfdb
			continue
		}
	}
_bfd:
	for {
		_ceg, _cdgd := d.Token()
		if _cdgd != nil {
			return _cdgd
		}
		switch _bbfa := _ceg.(type) {
		case _f.StartElement:
			switch _bbfa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cacheHierarchy"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cacheHierarchy"}:
				_caag := NewCT_CacheHierarchy()
				if _deg := d.DecodeElement(_caag, &_bbfa); _deg != nil {
					return _deg
				}
				_deec.CacheHierarchy = append(_deec.CacheHierarchy, _caag)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CacheHierarchies\u0020\u0025v", _bbfa.Name)
				if _afba := d.Skip(); _afba != nil {
					return _afba
				}
			}
		case _f.EndElement:
			break _bfd
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_RowHierarchiesUsage and its children
func (_aabebf *CT_RowHierarchiesUsage) Validate() error {
	return _aabebf.ValidateWithPath("CT_RowHierarchiesUsage")
}
func NewCT_SheetData() *CT_SheetData { _cbdbfe := &CT_SheetData{}; return _cbdbfe }

type CT_SheetBackgroundPicture struct{ IdAttr string }

func (_accecd *ST_TimePeriod) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ageacb, _bfdga := d.Token()
	if _bfdga != nil {
		return _bfdga
	}
	if _gcdec, _feccdd := _ageacb.(_f.EndElement); _feccdd && _gcdec.Name == start.Name {
		*_accecd = 1
		return nil
	}
	if _bccef, _fcdcge := _ageacb.(_f.CharData); !_fcdcge {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ageacb)
	} else {
		switch string(_bccef) {
		case "":
			*_accecd = 0
		case "today":
			*_accecd = 1
		case "yesterday":
			*_accecd = 2
		case "tomorrow":
			*_accecd = 3
		case "last7Days":
			*_accecd = 4
		case "thisMonth":
			*_accecd = 5
		case "lastMonth":
			*_accecd = 6
		case "nextMonth":
			*_accecd = 7
		case "thisWeek":
			*_accecd = 8
		case "lastWeek":
			*_accecd = 9
		case "nextWeek":
			*_accecd = 10
		}
	}
	_ageacb, _bfdga = d.Token()
	if _bfdga != nil {
		return _bfdga
	}
	if _fdgfa, _cccdc := _ageacb.(_f.EndElement); _cccdc && _fdgfa.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ageacb)
}
func NewCT_SheetCalcPr() *CT_SheetCalcPr { _cbagfa := &CT_SheetCalcPr{}; return _cbagfa }

type ST_SortType byte

func (_fcedgc *CT_RevisionCustomView) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "guid"}, Value: _bg.Sprintf("\u0025v", _fcedgc.GuidAttr)})
	_ebdgdg, _ecbec := _fcedgc.ActionAttr.MarshalXMLAttr(_f.Name{Local: "action"})
	if _ecbec != nil {
		return _ecbec
	}
	start.Attr = append(start.Attr, _ebdgdg)
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_feaab ST_RefMode) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_feaab.String(), start)
}
func (_dfccf *CT_OleItems) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_cggfcg:
	for {
		_dacde, _egdba := d.Token()
		if _egdba != nil {
			return _egdba
		}
		switch _gfgdf := _dacde.(type) {
		case _f.StartElement:
			switch _gfgdf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleItem"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleItem"}:
				_eddbd := NewCT_OleItem()
				if _cafeb := d.DecodeElement(_eddbd, &_gfgdf); _cafeb != nil {
					return _cafeb
				}
				_dfccf.OleItem = append(_dfccf.OleItem, _eddbd)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OleItems\u0020\u0025v", _gfgdf.Name)
				if _gcdac := d.Skip(); _gcdac != nil {
					return _gcdac
				}
			}
		case _f.EndElement:
			break _cggfcg
		case _f.CharData:
		}
	}
	return nil
}
func (_afaege ST_GroupBy) Validate() error { return _afaege.ValidateWithPath("") }
func (_fefgdb *CT_XmlColumnPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gefdc := range start.Attr {
		if _gefdc.Name.Local == "mapId" {
			_daeece, _begga := _g.ParseUint(_gefdc.Value, 10, 32)
			if _begga != nil {
				return _begga
			}
			_fefgdb.MapIdAttr = uint32(_daeece)
			continue
		}
		if _gefdc.Name.Local == "xpath" {
			_fcfff, _aacca := _gefdc.Value, error(nil)
			if _aacca != nil {
				return _aacca
			}
			_fefgdb.XpathAttr = _fcfff
			continue
		}
		if _gefdc.Name.Local == "denormalized" {
			_bbdfb, _cgeca := _g.ParseBool(_gefdc.Value)
			if _cgeca != nil {
				return _cgeca
			}
			_fefgdb.DenormalizedAttr = &_bbdfb
			continue
		}
		if _gefdc.Name.Local == "xmlDataType" {
			_cefdb, _fdbfdf := _gefdc.Value, error(nil)
			if _fdbfdf != nil {
				return _fdbfdf
			}
			_fefgdb.XmlDataTypeAttr = _cefdb
			continue
		}
	}
_caefc:
	for {
		_daadec, _dagad := d.Token()
		if _dagad != nil {
			return _dagad
		}
		switch _faecg := _daadec.(type) {
		case _f.StartElement:
			switch _faecg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_fefgdb.ExtLst = NewCT_ExtensionList()
				if _bbebbd := d.DecodeElement(_fefgdb.ExtLst, &_faecg); _bbebbd != nil {
					return _bbebbd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_XmlColumnPr\u0020\u0025v", _faecg.Name)
				if _gacbb := d.Skip(); _gacbb != nil {
					return _gacbb
				}
			}
		case _f.EndElement:
			break _caefc
		case _f.CharData:
		}
	}
	return nil
}

const (
	ST_TargetScreenSizeUnset     ST_TargetScreenSize = 0
	ST_TargetScreenSize544x376   ST_TargetScreenSize = 1
	ST_TargetScreenSize640x480   ST_TargetScreenSize = 2
	ST_TargetScreenSize720x512   ST_TargetScreenSize = 3
	ST_TargetScreenSize800x600   ST_TargetScreenSize = 4
	ST_TargetScreenSize1024x768  ST_TargetScreenSize = 5
	ST_TargetScreenSize1152x882  ST_TargetScreenSize = 6
	ST_TargetScreenSize1152x900  ST_TargetScreenSize = 7
	ST_TargetScreenSize1280x1024 ST_TargetScreenSize = 8
	ST_TargetScreenSize1600x1200 ST_TargetScreenSize = 9
	ST_TargetScreenSize1800x1440 ST_TargetScreenSize = 10
	ST_TargetScreenSize1920x1200 ST_TargetScreenSize = 11
)

func (_gffcf *CT_RevisionHeaders) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "guid"}, Value: _bg.Sprintf("\u0025v", _gffcf.GuidAttr)})
	if _gffcf.LastGuidAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lastGuid"}, Value: _bg.Sprintf("\u0025v", *_gffcf.LastGuidAttr)})
	}
	if _gffcf.SharedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "shared"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gffcf.SharedAttr))})
	}
	if _gffcf.DiskRevisionsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "diskRevisions"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gffcf.DiskRevisionsAttr))})
	}
	if _gffcf.HistoryAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "history"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gffcf.HistoryAttr))})
	}
	if _gffcf.TrackRevisionsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "trackRevisions"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gffcf.TrackRevisionsAttr))})
	}
	if _gffcf.ExclusiveAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "exclusive"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gffcf.ExclusiveAttr))})
	}
	if _gffcf.RevisionIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "revisionId"}, Value: _bg.Sprintf("\u0025v", *_gffcf.RevisionIdAttr)})
	}
	if _gffcf.VersionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "version"}, Value: _bg.Sprintf("\u0025v", *_gffcf.VersionAttr)})
	}
	if _gffcf.KeepChangeHistoryAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "keepChangeHistory"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gffcf.KeepChangeHistoryAttr))})
	}
	if _gffcf.ProtectedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "protected"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gffcf.ProtectedAttr))})
	}
	if _gffcf.PreserveHistoryAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "preserveHistory"}, Value: _bg.Sprintf("\u0025v", *_gffcf.PreserveHistoryAttr)})
	}
	e.EncodeToken(start)
	_gdebd := _f.StartElement{Name: _f.Name{Local: "ma:header"}}
	for _, _bedbf := range _gffcf.Header {
		e.EncodeElement(_bedbf, _gdebd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bgefg ST_PivotFilterType) ValidateWithPath(path string) error {
	switch _bgefg {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bgefg))
	}
	return nil
}
func (_eafac *Dialogsheet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_eafac.CT_Dialogsheet = *NewCT_Dialogsheet()
_ffabaa:
	for {
		_ceeefg, _bgbdd := d.Token()
		if _bgbdd != nil {
			return _bgbdd
		}
		switch _cegfbgf := _ceeefg.(type) {
		case _f.StartElement:
			switch _cegfbgf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetPr"}:
				_eafac.SheetPr = NewCT_SheetPr()
				if _degacd := d.DecodeElement(_eafac.SheetPr, &_cegfbgf); _degacd != nil {
					return _degacd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetViews"}:
				_eafac.SheetViews = NewCT_SheetViews()
				if _dfdagg := d.DecodeElement(_eafac.SheetViews, &_cegfbgf); _dfdagg != nil {
					return _dfdagg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetFormatPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetFormatPr"}:
				_eafac.SheetFormatPr = NewCT_SheetFormatPr()
				if _fdaeba := d.DecodeElement(_eafac.SheetFormatPr, &_cegfbgf); _fdaeba != nil {
					return _fdaeba
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetProtection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetProtection"}:
				_eafac.SheetProtection = NewCT_SheetProtection()
				if _edadb := d.DecodeElement(_eafac.SheetProtection, &_cegfbgf); _edadb != nil {
					return _edadb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customSheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customSheetViews"}:
				_eafac.CustomSheetViews = NewCT_CustomSheetViews()
				if _agbacg := d.DecodeElement(_eafac.CustomSheetViews, &_cegfbgf); _agbacg != nil {
					return _agbacg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "printOptions"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "printOptions"}:
				_eafac.PrintOptions = NewCT_PrintOptions()
				if _bcdga := d.DecodeElement(_eafac.PrintOptions, &_cegfbgf); _bcdga != nil {
					return _bcdga
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageMargins"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageMargins"}:
				_eafac.PageMargins = NewCT_PageMargins()
				if _gcbcb := d.DecodeElement(_eafac.PageMargins, &_cegfbgf); _gcbcb != nil {
					return _gcbcb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageSetup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageSetup"}:
				_eafac.PageSetup = NewCT_PageSetup()
				if _bcaaf := d.DecodeElement(_eafac.PageSetup, &_cegfbgf); _bcaaf != nil {
					return _bcaaf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "headerFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "headerFooter"}:
				_eafac.HeaderFooter = NewCT_HeaderFooter()
				if _gacgb := d.DecodeElement(_eafac.HeaderFooter, &_cegfbgf); _gacgb != nil {
					return _gacgb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawing"}:
				_eafac.Drawing = NewCT_Drawing()
				if _gccee := d.DecodeElement(_eafac.Drawing, &_cegfbgf); _gccee != nil {
					return _gccee
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawing"}:
				_eafac.LegacyDrawing = NewCT_LegacyDrawing()
				if _cedbc := d.DecodeElement(_eafac.LegacyDrawing, &_cegfbgf); _cedbc != nil {
					return _cedbc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawingHF"}:
				_eafac.LegacyDrawingHF = NewCT_LegacyDrawing()
				if _aaaaf := d.DecodeElement(_eafac.LegacyDrawingHF, &_cegfbgf); _aaaaf != nil {
					return _aaaaf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawingHF"}:
				_eafac.DrawingHF = NewCT_DrawingHF()
				if _cfdbab := d.DecodeElement(_eafac.DrawingHF, &_cegfbgf); _cfdbab != nil {
					return _cfdbab
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleObjects"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleObjects"}:
				_eafac.OleObjects = NewCT_OleObjects()
				if _bdabc := d.DecodeElement(_eafac.OleObjects, &_cegfbgf); _bdabc != nil {
					return _bdabc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "controls"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "controls"}:
				_eafac.Controls = NewCT_Controls()
				if _dfgegg := d.DecodeElement(_eafac.Controls, &_cegfbgf); _dfgegg != nil {
					return _dfgegg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_eafac.ExtLst = NewCT_ExtensionList()
				if _adgfgd := d.DecodeElement(_eafac.ExtLst, &_cegfbgf); _adgfgd != nil {
					return _adgfgd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Dialogsheet\u0020\u0025v", _cegfbgf.Name)
				if _ecfgc := d.Skip(); _ecfgc != nil {
					return _ecfgc
				}
			}
		case _f.EndElement:
			break _ffabaa
		case _f.CharData:
		}
	}
	return nil
}
func (_egggc *CT_ExternalSheetName) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fcabg := range start.Attr {
		if _fcabg.Name.Local == "val" {
			_defdg, _dabgf := _fcabg.Value, error(nil)
			if _dabgf != nil {
				return _dabgf
			}
			_egggc.ValAttr = &_defdg
			continue
		}
	}
	for {
		_egbfa, _cbga := d.Token()
		if _cbga != nil {
			return _bg.Errorf("parsing\u0020CT_ExternalSheetName:\u0020\u0025s", _cbga)
		}
		if _cgdef, _eegd := _egbfa.(_f.EndElement); _eegd && _cgdef.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fbfg *CT_ExternalReferences) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_edggb:
	for {
		_bggf, _eeeac := d.Token()
		if _eeeac != nil {
			return _eeeac
		}
		switch _cbgdg := _bggf.(type) {
		case _f.StartElement:
			switch _cbgdg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "externalReference"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "externalReference"}:
				_decc := NewCT_ExternalReference()
				if _cgabc := d.DecodeElement(_decc, &_cbgdg); _cgabc != nil {
					return _cgabc
				}
				_fbfg.ExternalReference = append(_fbfg.ExternalReference, _decc)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on CT_ExternalReferences\u0020\u0025v", _cbgdg.Name)
				if _dbegc := d.Skip(); _dbegc != nil {
					return _dbegc
				}
			}
		case _f.EndElement:
			break _edggb
		case _f.CharData:
		}
	}
	return nil
}
func (_cgbgd *CT_CustomSheetViews) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_adcde := _f.StartElement{Name: _f.Name{Local: "ma:customSheetView"}}
	for _, _gebed := range _cgbgd.CustomSheetView {
		e.EncodeElement(_gebed, _adcde)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Sst and its children, prefixing error messages with path
func (_dgaea *Sst) ValidateWithPath(path string) error {
	if _bbadgb := _dgaea.CT_Sst.ValidateWithPath(path); _bbadgb != nil {
		return _bbadgb
	}
	return nil
}
func (_dadgde *CT_PivotFilters) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dadgde.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_dadgde.CountAttr)})
	}
	e.EncodeToken(start)
	if _dadgde.Filter != nil {
		_gfebe := _f.StartElement{Name: _f.Name{Local: "ma:filter"}}
		for _, _bbcabe := range _dadgde.Filter {
			e.EncodeElement(_bbcabe, _gfebe)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_VolTypes and its children, prefixing error messages with path
func (_dbgff *CT_VolTypes) ValidateWithPath(path string) error {
	for _acbbfc, _dgafgf := range _dbgff.VolType {
		if _fadadd := _dgafgf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fVolType\u005b\u0025d\u005d", path, _acbbfc)); _fadadd != nil {
			return _fadadd
		}
	}
	if _dbgff.ExtLst != nil {
		if _fageb := _dbgff.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fageb != nil {
			return _fageb
		}
	}
	return nil
}
func NewCT_MeasureGroup() *CT_MeasureGroup { _acdbf := &CT_MeasureGroup{}; return _acdbf }
func (_ccbade ST_Axis) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_ccbade.String(), start)
}

// ValidateWithPath validates the CT_FontScheme and its children, prefixing error messages with path
func (_fgcdd *CT_FontScheme) ValidateWithPath(path string) error {
	if _fgcdd.ValAttr == ST_FontSchemeUnset {
		return _bg.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bdbfa := _fgcdd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bdbfa != nil {
		return _bdbfa
	}
	return nil
}
func (_fgdgd ST_Comments) Validate() error { return _fgdgd.ValidateWithPath("") }
func (_cbdfd *CT_CommentList) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _cbdfd.Comment != nil {
		_fcdb := _f.StartElement{Name: _f.Name{Local: "ma:comment"}}
		for _, _feaef := range _cbdfd.Comment {
			e.EncodeElement(_feaef, _fcdb)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Formats and its children, prefixing error messages with path
func (_dfgac *CT_Formats) ValidateWithPath(path string) error {
	for _cgeeg, _ffeed := range _dfgac.Format {
		if _eabagf := _ffeed.ValidateWithPath(_bg.Sprintf("\u0025s\u002fFormat\u005b\u0025d\u005d", path, _cgeeg)); _eabagf != nil {
			return _eabagf
		}
	}
	return nil
}
func (_afefae *ST_RevisionAction) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ffaac, _gfeccf := d.Token()
	if _gfeccf != nil {
		return _gfeccf
	}
	if _geage, _ffebgae := _ffaac.(_f.EndElement); _ffebgae && _geage.Name == start.Name {
		*_afefae = 1
		return nil
	}
	if _ccbacf, _feeedgf := _ffaac.(_f.CharData); !_feeedgf {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ffaac)
	} else {
		switch string(_ccbacf) {
		case "":
			*_afefae = 0
		case "add":
			*_afefae = 1
		case "delete":
			*_afefae = 2
		}
	}
	_ffaac, _gfeccf = d.Token()
	if _gfeccf != nil {
		return _gfeccf
	}
	if _edgdc, _cbeef := _ffaac.(_f.EndElement); _cbeef && _edgdc.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ffaac)
}
func (_aebgee ST_TextHAlign) ValidateWithPath(path string) error {
	switch _aebgee {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aebgee))
	}
	return nil
}
func (_ddfca ST_CredMethod) ValidateWithPath(path string) error {
	switch _ddfca {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ddfca))
	}
	return nil
}

// ValidateWithPath validates the CT_CustomChartsheetViews and its children, prefixing error messages with path
func (_cdafe *CT_CustomChartsheetViews) ValidateWithPath(path string) error {
	for _gfcee, _dggae := range _cdafe.CustomSheetView {
		if _bdfg := _dggae.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCustomSheetView\u005b\u0025d\u005d", path, _gfcee)); _bdfg != nil {
			return _bdfg
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SmartTagPr and its children, prefixing error messages with path
func (_gabgdf *CT_SmartTagPr) ValidateWithPath(path string) error {
	if _fefffa := _gabgdf.ShowAttr.ValidateWithPath(path + "\u002fShowAttr"); _fefffa != nil {
		return _fefffa
	}
	return nil
}
func (_fafbc *CT_TablePart) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cgccd := range start.Attr {
		if _cgccd.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _cgccd.Name.Local == "id" || _cgccd.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _cgccd.Name.Local == "id" {
			_afdgb, _bcbgca := _cgccd.Value, error(nil)
			if _bcbgca != nil {
				return _bcbgca
			}
			_fafbc.IdAttr = _afdgb
			continue
		}
	}
	for {
		_cagcg, _eafdcb := d.Token()
		if _eafdcb != nil {
			return _bg.Errorf("parsing\u0020CT_TablePart:\u0020\u0025s", _eafdcb)
		}
		if _efbga, _gfcgg := _cagcg.(_f.EndElement); _gfcgg && _efbga.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_CellStyle struct {

	// User Defined Cell Style
	NameAttr *string

	// Format Id
	XfIdAttr uint32

	// Built-In Style Id
	BuiltinIdAttr *uint32

	// Outline Style
	ILevelAttr *uint32

	// Hidden Style
	HiddenAttr *bool

	// Custom Built In
	CustomBuiltinAttr *bool

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_cebac *CT_PivotCacheRecords) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cebac.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_cebac.CountAttr)})
	}
	e.EncodeToken(start)
	if _cebac.R != nil {
		_degcgf := _f.StartElement{Name: _f.Name{Local: "ma:r"}}
		for _, _fbceac := range _cebac.R {
			e.EncodeElement(_fbceac, _degcgf)
		}
	}
	if _cebac.ExtLst != nil {
		_bafcg := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_cebac.ExtLst, _bafcg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gbcbg *CT_RowFields) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gbcbg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_gbcbg.CountAttr)})
	}
	e.EncodeToken(start)
	_fdfcd := _f.StartElement{Name: _f.Name{Local: "ma:field"}}
	for _, _ccege := range _gbcbg.Field {
		e.EncodeElement(_ccege, _fdfcd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_FunctionGroups() *CT_FunctionGroups { _edead := &CT_FunctionGroups{}; return _edead }

type ST_MdxSetOrder byte

func (_bgbffa *CT_Groups) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bgbffa.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bgbffa.CountAttr)})
	}
	e.EncodeToken(start)
	_dacg := _f.StartElement{Name: _f.Name{Local: "ma:group"}}
	for _, _ceadd := range _bgbffa.Group {
		e.EncodeElement(_ceadd, _dacg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Col and its children
func (_cacd *CT_Col) Validate() error { return _cacd.ValidateWithPath("CT_Col") }
func (_edfcg ST_DataValidationType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_edfcg.String(), start)
}
func NewCT_Cols() *CT_Cols { _dfff := &CT_Cols{}; return _dfff }
func (_dddbfb ST_CfvoType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_dfca := _f.Attr{}
	_dfca.Name = name
	switch _dddbfb {
	case ST_CfvoTypeUnset:
		_dfca.Value = ""
	case ST_CfvoTypeNum:
		_dfca.Value = "num"
	case ST_CfvoTypePercent:
		_dfca.Value = "percent"
	case ST_CfvoTypeMax:
		_dfca.Value = "max"
	case ST_CfvoTypeMin:
		_dfca.Value = "min"
	case ST_CfvoTypeFormula:
		_dfca.Value = "formula"
	case ST_CfvoTypePercentile:
		_dfca.Value = "percentile"
	}
	return _dfca, nil
}
func (_adeabf ST_TotalsRowFunction) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_adeabf.String(), start)
}
func (_ffae *CT_Col) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ccaf := range start.Attr {
		if _ccaf.Name.Local == "min" {
			_ggbg, _ggga := _g.ParseUint(_ccaf.Value, 10, 32)
			if _ggga != nil {
				return _ggga
			}
			_ffae.MinAttr = uint32(_ggbg)
			continue
		}
		if _ccaf.Name.Local == "max" {
			_gbdc, _fafb := _g.ParseUint(_ccaf.Value, 10, 32)
			if _fafb != nil {
				return _fafb
			}
			_ffae.MaxAttr = uint32(_gbdc)
			continue
		}
		if _ccaf.Name.Local == "width" {
			_bfbg, _eaedf := _g.ParseFloat(_ccaf.Value, 64)
			if _eaedf != nil {
				return _eaedf
			}
			_ffae.WidthAttr = &_bfbg
			continue
		}
		if _ccaf.Name.Local == "style" {
			_cefc, _eefc := _g.ParseUint(_ccaf.Value, 10, 32)
			if _eefc != nil {
				return _eefc
			}
			_cgadb := uint32(_cefc)
			_ffae.StyleAttr = &_cgadb
			continue
		}
		if _ccaf.Name.Local == "hidden" {
			_bfgc, _gebf := _g.ParseBool(_ccaf.Value)
			if _gebf != nil {
				return _gebf
			}
			_ffae.HiddenAttr = &_bfgc
			continue
		}
		if _ccaf.Name.Local == "bestFit" {
			_dgffb, _bbfb := _g.ParseBool(_ccaf.Value)
			if _bbfb != nil {
				return _bbfb
			}
			_ffae.BestFitAttr = &_dgffb
			continue
		}
		if _ccaf.Name.Local == "customWidth" {
			_bedfg, _cgge := _g.ParseBool(_ccaf.Value)
			if _cgge != nil {
				return _cgge
			}
			_ffae.CustomWidthAttr = &_bedfg
			continue
		}
		if _ccaf.Name.Local == "phonetic" {
			_ggag, _daag := _g.ParseBool(_ccaf.Value)
			if _daag != nil {
				return _daag
			}
			_ffae.PhoneticAttr = &_ggag
			continue
		}
		if _ccaf.Name.Local == "outlineLevel" {
			_ebga, _gebfa := _g.ParseUint(_ccaf.Value, 10, 8)
			if _gebfa != nil {
				return _gebfa
			}
			_cbdb := uint8(_ebga)
			_ffae.OutlineLevelAttr = &_cbdb
			continue
		}
		if _ccaf.Name.Local == "collapsed" {
			_fgba, _abab := _g.ParseBool(_ccaf.Value)
			if _abab != nil {
				return _abab
			}
			_ffae.CollapsedAttr = &_fgba
			continue
		}
	}
	for {
		_fedd, _acdc := d.Token()
		if _acdc != nil {
			return _bg.Errorf("parsing\u0020CT_Col:\u0020\u0025s", _acdc)
		}
		if _fdedb, _fdeb := _fedd.(_f.EndElement); _fdeb && _fdedb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dafcf ST_CalcMode) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_daggd := _f.Attr{}
	_daggd.Name = name
	switch _dafcf {
	case ST_CalcModeUnset:
		_daggd.Value = ""
	case ST_CalcModeManual:
		_daggd.Value = "manual"
	case ST_CalcModeAuto:
		_daggd.Value = "auto"
	case ST_CalcModeAutoNoTable:
		_daggd.Value = "autoNoTable"
	}
	return _daggd, nil
}

const (
	ST_QualifierUnset       ST_Qualifier = 0
	ST_QualifierDoubleQuote ST_Qualifier = 1
	ST_QualifierSingleQuote ST_Qualifier = 2
	ST_QualifierNone        ST_Qualifier = 3
)

func (_gdcafd *CT_SharedUser) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "guid"}, Value: _bg.Sprintf("\u0025v", _gdcafd.GuidAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _gdcafd.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", _gdcafd.IdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dateTime"}, Value: _bg.Sprintf("\u0025v", _gdcafd.DateTimeAttr)})
	e.EncodeToken(start)
	if _gdcafd.ExtLst != nil {
		_ccebg := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_gdcafd.ExtLst, _ccebg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_fbbde *ST_CellType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dcgabd, _baaaf := d.Token()
	if _baaaf != nil {
		return _baaaf
	}
	if _daceb, _fdbad := _dcgabd.(_f.EndElement); _fdbad && _daceb.Name == start.Name {
		*_fbbde = 1
		return nil
	}
	if _febb, _bddfb := _dcgabd.(_f.CharData); !_bddfb {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dcgabd)
	} else {
		switch string(_febb) {
		case "":
			*_fbbde = 0
		case "b":
			*_fbbde = 1
		case "n":
			*_fbbde = 2
		case "e":
			*_fbbde = 3
		case "s":
			*_fbbde = 4
		case "str":
			*_fbbde = 5
		case "inlineStr":
			*_fbbde = 6
		}
	}
	_dcgabd, _baaaf = d.Token()
	if _baaaf != nil {
		return _baaaf
	}
	if _dfggc, _cedbg := _dcgabd.(_f.EndElement); _cedbg && _dfggc.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dcgabd)
}
func (_aag *CT_CacheHierarchies) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aag.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_aag.CountAttr)})
	}
	e.EncodeToken(start)
	if _aag.CacheHierarchy != nil {
		_cafd := _f.StartElement{Name: _f.Name{Local: "ma:cacheHierarchy"}}
		for _, _cbeg := range _aag.CacheHierarchy {
			e.EncodeElement(_cbeg, _cafd)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_WebPublishItem() *CT_WebPublishItem {
	_agdec := &CT_WebPublishItem{}
	_agdec.SourceTypeAttr = ST_WebSourceType(1)
	return _agdec
}
func (_ceaefb *ST_GrowShrinkType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_ceaefb = 0
	case "insertDelete":
		*_ceaefb = 1
	case "insertClear":
		*_ceaefb = 2
	case "overwriteClear":
		*_ceaefb = 3
	}
	return nil
}

type ST_UnderlineValues byte

func (_fbdge *CT_QueryTable) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aafcfa := range start.Attr {
		if _aafcfa.Name.Local == "adjustColumnWidth" {
			_ecdaf, _cggdga := _g.ParseBool(_aafcfa.Value)
			if _cggdga != nil {
				return _cggdga
			}
			_fbdge.AdjustColumnWidthAttr = &_ecdaf
			continue
		}
		if _aafcfa.Name.Local == "name" {
			_egbab, _gfcdc := _aafcfa.Value, error(nil)
			if _gfcdc != nil {
				return _gfcdc
			}
			_fbdge.NameAttr = _egbab
			continue
		}
		if _aafcfa.Name.Local == "intermediate" {
			_bcebc, _aaedca := _g.ParseBool(_aafcfa.Value)
			if _aaedca != nil {
				return _aaedca
			}
			_fbdge.IntermediateAttr = &_bcebc
			continue
		}
		if _aafcfa.Name.Local == "rowNumbers" {
			_ffddd, _dcgegc := _g.ParseBool(_aafcfa.Value)
			if _dcgegc != nil {
				return _dcgegc
			}
			_fbdge.RowNumbersAttr = &_ffddd
			continue
		}
		if _aafcfa.Name.Local == "connectionId" {
			_bfacb, _cbdff := _g.ParseUint(_aafcfa.Value, 10, 32)
			if _cbdff != nil {
				return _cbdff
			}
			_fbdge.ConnectionIdAttr = uint32(_bfacb)
			continue
		}
		if _aafcfa.Name.Local == "backgroundRefresh" {
			_gagea, _eagcg := _g.ParseBool(_aafcfa.Value)
			if _eagcg != nil {
				return _eagcg
			}
			_fbdge.BackgroundRefreshAttr = &_gagea
			continue
		}
		if _aafcfa.Name.Local == "refreshOnLoad" {
			_cagbce, _cecfc := _g.ParseBool(_aafcfa.Value)
			if _cecfc != nil {
				return _cecfc
			}
			_fbdge.RefreshOnLoadAttr = &_cagbce
			continue
		}
		if _aafcfa.Name.Local == "fillFormulas" {
			_caebg, _efbafc := _g.ParseBool(_aafcfa.Value)
			if _efbafc != nil {
				return _efbafc
			}
			_fbdge.FillFormulasAttr = &_caebg
			continue
		}
		if _aafcfa.Name.Local == "applyNumberFormats" {
			_cegfag, _dgddd := _g.ParseBool(_aafcfa.Value)
			if _dgddd != nil {
				return _dgddd
			}
			_fbdge.ApplyNumberFormatsAttr = &_cegfag
			continue
		}
		if _aafcfa.Name.Local == "applyFontFormats" {
			_gcaage, _cgbbb := _g.ParseBool(_aafcfa.Value)
			if _cgbbb != nil {
				return _cgbbb
			}
			_fbdge.ApplyFontFormatsAttr = &_gcaage
			continue
		}
		if _aafcfa.Name.Local == "firstBackgroundRefresh" {
			_eaffc, _begada := _g.ParseBool(_aafcfa.Value)
			if _begada != nil {
				return _begada
			}
			_fbdge.FirstBackgroundRefreshAttr = &_eaffc
			continue
		}
		if _aafcfa.Name.Local == "autoFormatId" {
			_gfebc, _gagbe := _g.ParseUint(_aafcfa.Value, 10, 32)
			if _gagbe != nil {
				return _gagbe
			}
			_fbbfb := uint32(_gfebc)
			_fbdge.AutoFormatIdAttr = &_fbbfb
			continue
		}
		if _aafcfa.Name.Local == "applyAlignmentFormats" {
			_ebfcfg, _decbd := _g.ParseBool(_aafcfa.Value)
			if _decbd != nil {
				return _decbd
			}
			_fbdge.ApplyAlignmentFormatsAttr = &_ebfcfg
			continue
		}
		if _aafcfa.Name.Local == "disableRefresh" {
			_aceeca, _ebaea := _g.ParseBool(_aafcfa.Value)
			if _ebaea != nil {
				return _ebaea
			}
			_fbdge.DisableRefreshAttr = &_aceeca
			continue
		}
		if _aafcfa.Name.Local == "applyBorderFormats" {
			_ccbbb, _gdbc := _g.ParseBool(_aafcfa.Value)
			if _gdbc != nil {
				return _gdbc
			}
			_fbdge.ApplyBorderFormatsAttr = &_ccbbb
			continue
		}
		if _aafcfa.Name.Local == "preserveFormatting" {
			_abada, _gecac := _g.ParseBool(_aafcfa.Value)
			if _gecac != nil {
				return _gecac
			}
			_fbdge.PreserveFormattingAttr = &_abada
			continue
		}
		if _aafcfa.Name.Local == "applyPatternFormats" {
			_eabbe, _geab := _g.ParseBool(_aafcfa.Value)
			if _geab != nil {
				return _geab
			}
			_fbdge.ApplyPatternFormatsAttr = &_eabbe
			continue
		}
		if _aafcfa.Name.Local == "growShrinkType" {
			_fbdge.GrowShrinkTypeAttr.UnmarshalXMLAttr(_aafcfa)
			continue
		}
		if _aafcfa.Name.Local == "disableEdit" {
			_fbedc, _cegdf := _g.ParseBool(_aafcfa.Value)
			if _cegdf != nil {
				return _cegdf
			}
			_fbdge.DisableEditAttr = &_fbedc
			continue
		}
		if _aafcfa.Name.Local == "headers" {
			_ecggdg, _effff := _g.ParseBool(_aafcfa.Value)
			if _effff != nil {
				return _effff
			}
			_fbdge.HeadersAttr = &_ecggdg
			continue
		}
		if _aafcfa.Name.Local == "removeDataOnSave" {
			_afdbfa, _begggc := _g.ParseBool(_aafcfa.Value)
			if _begggc != nil {
				return _begggc
			}
			_fbdge.RemoveDataOnSaveAttr = &_afdbfa
			continue
		}
		if _aafcfa.Name.Local == "applyWidthHeightFormats" {
			_adfbgba, _defgd := _g.ParseBool(_aafcfa.Value)
			if _defgd != nil {
				return _defgd
			}
			_fbdge.ApplyWidthHeightFormatsAttr = &_adfbgba
			continue
		}
	}
_ffead:
	for {
		_daeafe, _abdac := d.Token()
		if _abdac != nil {
			return _abdac
		}
		switch _baadc := _daeafe.(type) {
		case _f.StartElement:
			switch _baadc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "queryTableRefresh"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "queryTableRefresh"}:
				_fbdge.QueryTableRefresh = NewCT_QueryTableRefresh()
				if _dbac := d.DecodeElement(_fbdge.QueryTableRefresh, &_baadc); _dbac != nil {
					return _dbac
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_fbdge.ExtLst = NewCT_ExtensionList()
				if _fccgf := d.DecodeElement(_fbdge.ExtLst, &_baadc); _fccgf != nil {
					return _fccgf
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_QueryTable \u0025v", _baadc.Name)
				if _deabed := d.Skip(); _deabed != nil {
					return _deabed
				}
			}
		case _f.EndElement:
			break _ffead
		case _f.CharData:
		}
	}
	return nil
}
func (_ecbfe *CT_SheetViews) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_fbcfb:
	for {
		_dbaeg, _efcfa := d.Token()
		if _efcfa != nil {
			return _efcfa
		}
		switch _fbacdf := _dbaeg.(type) {
		case _f.StartElement:
			switch _fbacdf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetView"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetView"}:
				_eadfa := NewCT_SheetView()
				if _fccce := d.DecodeElement(_eadfa, &_fbacdf); _fccce != nil {
					return _fccce
				}
				_ecbfe.SheetView = append(_ecbfe.SheetView, _eadfa)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ecbfe.ExtLst = NewCT_ExtensionList()
				if _gcgbca := d.DecodeElement(_ecbfe.ExtLst, &_fbacdf); _gcgbca != nil {
					return _gcgbca
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_SheetViews \u0025v", _fbacdf.Name)
				if _dfgeg := d.Skip(); _dfgeg != nil {
					return _dfgeg
				}
			}
		case _f.EndElement:
			break _fbcfb
		case _f.CharData:
		}
	}
	return nil
}
func (_dcggde *ST_MdxFunctionType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_dcggde = 0
	case "m":
		*_dcggde = 1
	case "v":
		*_dcggde = 2
	case "s":
		*_dcggde = 3
	case "c":
		*_dcggde = 4
	case "r":
		*_dcggde = 5
	case "p":
		*_dcggde = 6
	case "k":
		*_dcggde = 7
	}
	return nil
}
func (_aegd *CT_ChartsheetProtection) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aegd.PasswordAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "password"}, Value: _bg.Sprintf("\u0025v", *_aegd.PasswordAttr)})
	}
	if _aegd.AlgorithmNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "algorithmName"}, Value: _bg.Sprintf("\u0025v", *_aegd.AlgorithmNameAttr)})
	}
	if _aegd.HashValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hashValue"}, Value: _bg.Sprintf("\u0025v", *_aegd.HashValueAttr)})
	}
	if _aegd.SaltValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "saltValue"}, Value: _bg.Sprintf("\u0025v", *_aegd.SaltValueAttr)})
	}
	if _aegd.SpinCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "spinCount"}, Value: _bg.Sprintf("\u0025v", *_aegd.SpinCountAttr)})
	}
	if _aegd.ContentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "content"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aegd.ContentAttr))})
	}
	if _aegd.ObjectsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "objects"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aegd.ObjectsAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dbbg *CT_CellXfs) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dddbf := range start.Attr {
		if _dddbf.Name.Local == "count" {
			_ecc, _afdd := _g.ParseUint(_dddbf.Value, 10, 32)
			if _afdd != nil {
				return _afdd
			}
			_ecaaf := uint32(_ecc)
			_dbbg.CountAttr = &_ecaaf
			continue
		}
	}
_ceed:
	for {
		_egddf, _efb := d.Token()
		if _efb != nil {
			return _efb
		}
		switch _ggdfg := _egddf.(type) {
		case _f.StartElement:
			switch _ggdfg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "xf"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "xf"}:
				_edea := NewCT_Xf()
				if _ecde := d.DecodeElement(_edea, &_ggdfg); _ecde != nil {
					return _ecde
				}
				_dbbg.Xf = append(_dbbg.Xf, _edea)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_CellXfs\u0020\u0025v", _ggdfg.Name)
				if _ceea := d.Skip(); _ceea != nil {
					return _ceea
				}
			}
		case _f.EndElement:
			break _ceed
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_DataValidations and its children
func (_cbfaa *CT_DataValidations) Validate() error {
	return _cbfaa.ValidateWithPath("CT_DataValidations")
}

type ST_FileType byte
type CT_ServerFormat struct {

	// Culture
	CultureAttr *string

	// Format
	FormatAttr *string
}

// ValidateWithPath validates the Table and its children, prefixing error messages with path
func (_gadeb *Table) ValidateWithPath(path string) error {
	if _bebfab := _gadeb.CT_Table.ValidateWithPath(path); _bebfab != nil {
		return _bebfab
	}
	return nil
}

type CT_TableParts struct {

	// Count
	CountAttr *uint32

	// Table Part
	TablePart []*CT_TablePart
}

const (
	ST_ObjectsUnset        ST_Objects = 0
	ST_ObjectsAll          ST_Objects = 1
	ST_ObjectsPlaceholders ST_Objects = 2
	ST_ObjectsNone         ST_Objects = 3
)

type CT_RevisionComment struct {

	// Sheet Id
	SheetIdAttr uint32

	// Cell
	CellAttr string

	// GUID
	GuidAttr string

	// User Action
	ActionAttr ST_RevisionAction

	// Always Show Comment
	AlwaysShowAttr *bool

	// Old Comment
	OldAttr *bool

	// Comment In Hidden Row
	HiddenRowAttr *bool

	// Hidden Column
	HiddenColumnAttr *bool

	// Author
	AuthorAttr string

	// Original Comment Length
	OldLengthAttr *uint32

	// New Comment Length
	NewLengthAttr *uint32
}

func (_cgffad *ST_DateTimeGrouping) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_afabbeg, _gfggf := d.Token()
	if _gfggf != nil {
		return _gfggf
	}
	if _ebecb, _beadfb := _afabbeg.(_f.EndElement); _beadfb && _ebecb.Name == start.Name {
		*_cgffad = 1
		return nil
	}
	if _fbeae, _ggaegf := _afabbeg.(_f.CharData); !_ggaegf {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _afabbeg)
	} else {
		switch string(_fbeae) {
		case "":
			*_cgffad = 0
		case "year":
			*_cgffad = 1
		case "month":
			*_cgffad = 2
		case "day":
			*_cgffad = 3
		case "hour":
			*_cgffad = 4
		case "minute":
			*_cgffad = 5
		case "second":
			*_cgffad = 6
		}
	}
	_afabbeg, _gfggf = d.Token()
	if _gfggf != nil {
		return _gfggf
	}
	if _gbafdf, _gffcg := _afabbeg.(_f.EndElement); _gffcg && _gbafdf.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _afabbeg)
}

type ST_Comments byte

func (_abdaec *PivotTableDefinition) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_abdaec.CT_pivotTableDefinition = *NewCT_pivotTableDefinition()
	for _, _caeaf := range start.Attr {
		if _caeaf.Name.Local == "createdVersion" {
			_fgbgcf, _egddfb := _g.ParseUint(_caeaf.Value, 10, 8)
			if _egddfb != nil {
				return _egddfb
			}
			_dbdae := uint8(_fgbgcf)
			_abdaec.CreatedVersionAttr = &_dbdae
			continue
		}
		if _caeaf.Name.Local == "indent" {
			_cbecfe, _fcfgba := _g.ParseUint(_caeaf.Value, 10, 32)
			if _fcfgba != nil {
				return _fcfgba
			}
			_ffbcdb := uint32(_cbecfe)
			_abdaec.IndentAttr = &_ffbcdb
			continue
		}
		if _caeaf.Name.Local == "pivotTableStyle" {
			_fgbgee, _dceac := _caeaf.Value, error(nil)
			if _dceac != nil {
				return _dceac
			}
			_abdaec.PivotTableStyleAttr = &_fgbgee
			continue
		}
		if _caeaf.Name.Local == "showEmptyRow" {
			_ggedbe, _efacf := _g.ParseBool(_caeaf.Value)
			if _efacf != nil {
				return _efacf
			}
			_abdaec.ShowEmptyRowAttr = &_ggedbe
			continue
		}
		if _caeaf.Name.Local == "tag" {
			_cgabf, _efagb := _caeaf.Value, error(nil)
			if _efagb != nil {
				return _efagb
			}
			_abdaec.TagAttr = &_cgabf
			continue
		}
		if _caeaf.Name.Local == "showEmptyCol" {
			_ddcfc, _dbadb := _g.ParseBool(_caeaf.Value)
			if _dbadb != nil {
				return _dbadb
			}
			_abdaec.ShowEmptyColAttr = &_ddcfc
			continue
		}
		if _caeaf.Name.Local == "minRefreshableVersion" {
			_cegca, _ffbcac := _g.ParseUint(_caeaf.Value, 10, 8)
			if _ffbcac != nil {
				return _ffbcac
			}
			_eafabb := uint8(_cegca)
			_abdaec.MinRefreshableVersionAttr = &_eafabb
			continue
		}
		if _caeaf.Name.Local == "showHeaders" {
			_eaaca, _afecg := _g.ParseBool(_caeaf.Value)
			if _afecg != nil {
				return _afecg
			}
			_abdaec.ShowHeadersAttr = &_eaaca
			continue
		}
		if _caeaf.Name.Local == "asteriskTotals" {
			_ebecae, _cfgfc := _g.ParseBool(_caeaf.Value)
			if _cfgfc != nil {
				return _cfgfc
			}
			_abdaec.AsteriskTotalsAttr = &_ebecae
			continue
		}
		if _caeaf.Name.Local == "compact" {
			_cgcag, _bcege := _g.ParseBool(_caeaf.Value)
			if _bcege != nil {
				return _bcege
			}
			_abdaec.CompactAttr = &_cgcag
			continue
		}
		if _caeaf.Name.Local == "editData" {
			_dggabg, _fggab := _g.ParseBool(_caeaf.Value)
			if _fggab != nil {
				return _fggab
			}
			_abdaec.EditDataAttr = &_dggabg
			continue
		}
		if _caeaf.Name.Local == "outline" {
			_gaccee, _baefd := _g.ParseBool(_caeaf.Value)
			if _baefd != nil {
				return _baefd
			}
			_abdaec.OutlineAttr = &_gaccee
			continue
		}
		if _caeaf.Name.Local == "showCalcMbrs" {
			_cgdgff, _eddee := _g.ParseBool(_caeaf.Value)
			if _eddee != nil {
				return _eddee
			}
			_abdaec.ShowCalcMbrsAttr = &_cgdgff
			continue
		}
		if _caeaf.Name.Local == "outlineData" {
			_edddc, _fbgeg := _g.ParseBool(_caeaf.Value)
			if _fbgeg != nil {
				return _fbgeg
			}
			_abdaec.OutlineDataAttr = &_edddc
			continue
		}
		if _caeaf.Name.Local == "gridDropZones" {
			_afbcb, _cfgedc := _g.ParseBool(_caeaf.Value)
			if _cfgedc != nil {
				return _cfgedc
			}
			_abdaec.GridDropZonesAttr = &_afbcb
			continue
		}
		if _caeaf.Name.Local == "customListSort" {
			_cbadb, _aedgdd := _g.ParseBool(_caeaf.Value)
			if _aedgdd != nil {
				return _aedgdd
			}
			_abdaec.CustomListSortAttr = &_cbadb
			continue
		}
		if _caeaf.Name.Local == "rowGrandTotals" {
			_dcbgc, _cebec := _g.ParseBool(_caeaf.Value)
			if _cebec != nil {
				return _cebec
			}
			_abdaec.RowGrandTotalsAttr = &_dcbgc
			continue
		}
		if _caeaf.Name.Local == "applyWidthHeightFormats" {
			_fafaf, _bcgdd := _g.ParseBool(_caeaf.Value)
			if _bcgdd != nil {
				return _bcgdd
			}
			_abdaec.ApplyWidthHeightFormatsAttr = &_fafaf
			continue
		}
		if _caeaf.Name.Local == "useAutoFormatting" {
			_bagdd, _gfdef := _g.ParseBool(_caeaf.Value)
			if _gfdef != nil {
				return _gfdef
			}
			_abdaec.UseAutoFormattingAttr = &_bagdd
			continue
		}
		if _caeaf.Name.Local == "rowHeaderCaption" {
			_gbegc, _gedbb := _caeaf.Value, error(nil)
			if _gedbb != nil {
				return _gedbb
			}
			_abdaec.RowHeaderCaptionAttr = &_gbegc
			continue
		}
		if _caeaf.Name.Local == "showDrill" {
			_dgffe, _fbeba := _g.ParseBool(_caeaf.Value)
			if _fbeba != nil {
				return _fbeba
			}
			_abdaec.ShowDrillAttr = &_dgffe
			continue
		}
		if _caeaf.Name.Local == "mergeItem" {
			_cbebg, _badgdb := _g.ParseBool(_caeaf.Value)
			if _badgdb != nil {
				return _badgdb
			}
			_abdaec.MergeItemAttr = &_cbebg
			continue
		}
		if _caeaf.Name.Local == "applyBorderFormats" {
			_fgdbb, _ccafad := _g.ParseBool(_caeaf.Value)
			if _ccafad != nil {
				return _ccafad
			}
			_abdaec.ApplyBorderFormatsAttr = &_fgdbb
			continue
		}
		if _caeaf.Name.Local == "visualTotals" {
			_dcbfg, _cagdg := _g.ParseBool(_caeaf.Value)
			if _cagdg != nil {
				return _cagdg
			}
			_abdaec.VisualTotalsAttr = &_dcbfg
			continue
		}
		if _caeaf.Name.Local == "compactData" {
			_edbed, _dcfbd := _g.ParseBool(_caeaf.Value)
			if _dcfbd != nil {
				return _dcfbd
			}
			_abdaec.CompactDataAttr = &_edbed
			continue
		}
		if _caeaf.Name.Local == "dataPosition" {
			_agfaf, _deaab := _g.ParseUint(_caeaf.Value, 10, 32)
			if _deaab != nil {
				return _deaab
			}
			_eadeb := uint32(_agfaf)
			_abdaec.DataPositionAttr = &_eadeb
			continue
		}
		if _caeaf.Name.Local == "multipleFieldFilters" {
			_ffgec, _bfcegf := _g.ParseBool(_caeaf.Value)
			if _bfcegf != nil {
				return _bfcegf
			}
			_abdaec.MultipleFieldFiltersAttr = &_ffgec
			continue
		}
		if _caeaf.Name.Local == "pageOverThenDown" {
			_acedgac, _babceb := _g.ParseBool(_caeaf.Value)
			if _babceb != nil {
				return _babceb
			}
			_abdaec.PageOverThenDownAttr = &_acedgac
			continue
		}
		if _caeaf.Name.Local == "fieldListSortAscending" {
			_bgeggg, _ggebc := _g.ParseBool(_caeaf.Value)
			if _ggebc != nil {
				return _ggebc
			}
			_abdaec.FieldListSortAscendingAttr = &_bgeggg
			continue
		}
		if _caeaf.Name.Local == "showMissing" {
			_cfbabg, _eddac := _g.ParseBool(_caeaf.Value)
			if _eddac != nil {
				return _eddac
			}
			_abdaec.ShowMissingAttr = &_cfbabg
			continue
		}
		if _caeaf.Name.Local == "fieldPrintTitles" {
			_dcgaf, _bacbd := _g.ParseBool(_caeaf.Value)
			if _bacbd != nil {
				return _bacbd
			}
			_abdaec.FieldPrintTitlesAttr = &_dcgaf
			continue
		}
		if _caeaf.Name.Local == "showMemberPropertyTips" {
			_fafeg, _efbfgd := _g.ParseBool(_caeaf.Value)
			if _efbfgd != nil {
				return _efbfgd
			}
			_abdaec.ShowMemberPropertyTipsAttr = &_fafeg
			continue
		}
		if _caeaf.Name.Local == "pageStyle" {
			_gffgf, _agdfg := _caeaf.Value, error(nil)
			if _agdfg != nil {
				return _agdfg
			}
			_abdaec.PageStyleAttr = &_gffgf
			continue
		}
		if _caeaf.Name.Local == "autoFormatId" {
			_bbdfc, _cdgacb := _g.ParseUint(_caeaf.Value, 10, 32)
			if _cdgacb != nil {
				return _cdgacb
			}
			_abcea := uint32(_bbdfc)
			_abdaec.AutoFormatIdAttr = &_abcea
			continue
		}
		if _caeaf.Name.Local == "showItems" {
			_dcbbca, _aaddcd := _g.ParseBool(_caeaf.Value)
			if _aaddcd != nil {
				return _aaddcd
			}
			_abdaec.ShowItemsAttr = &_dcbbca
			continue
		}
		if _caeaf.Name.Local == "applyPatternFormats" {
			_fgbgfg, _gecaa := _g.ParseBool(_caeaf.Value)
			if _gecaa != nil {
				return _gecaa
			}
			_abdaec.ApplyPatternFormatsAttr = &_fgbgfg
			continue
		}
		if _caeaf.Name.Local == "enableFieldProperties" {
			_bcafff, _ceeefa := _g.ParseBool(_caeaf.Value)
			if _ceeefa != nil {
				return _ceeefa
			}
			_abdaec.EnableFieldPropertiesAttr = &_bcafff
			continue
		}
		if _caeaf.Name.Local == "showMultipleLabel" {
			_gedggd, _addagg := _g.ParseBool(_caeaf.Value)
			if _addagg != nil {
				return _addagg
			}
			_abdaec.ShowMultipleLabelAttr = &_gedggd
			continue
		}
		if _caeaf.Name.Local == "preserveFormatting" {
			_cdeadb, _cfecab := _g.ParseBool(_caeaf.Value)
			if _cfecab != nil {
				return _cfecab
			}
			_abdaec.PreserveFormattingAttr = &_cdeadb
			continue
		}
		if _caeaf.Name.Local == "published" {
			_ccccd, _cegbb := _g.ParseBool(_caeaf.Value)
			if _cegbb != nil {
				return _cegbb
			}
			_abdaec.PublishedAttr = &_ccccd
			continue
		}
		if _caeaf.Name.Local == "missingCaption" {
			_cabeba, _cadfef := _caeaf.Value, error(nil)
			if _cadfef != nil {
				return _cadfef
			}
			_abdaec.MissingCaptionAttr = &_cabeba
			continue
		}
		if _caeaf.Name.Local == "immersive" {
			_bbfbe, _bdada := _g.ParseBool(_caeaf.Value)
			if _bdada != nil {
				return _bdada
			}
			_abdaec.ImmersiveAttr = &_bbfbe
			continue
		}
		if _caeaf.Name.Local == "pageWrap" {
			_dbfae, _bedbc := _g.ParseUint(_caeaf.Value, 10, 32)
			if _bedbc != nil {
				return _bedbc
			}
			_fadde := uint32(_dbfae)
			_abdaec.PageWrapAttr = &_fadde
			continue
		}
		if _caeaf.Name.Local == "chartFormat" {
			_gfeee, _cffcg := _g.ParseUint(_caeaf.Value, 10, 32)
			if _cffcg != nil {
				return _cffcg
			}
			_ceacb := uint32(_gfeee)
			_abdaec.ChartFormatAttr = &_ceacb
			continue
		}
		if _caeaf.Name.Local == "showDataDropDown" {
			_gecdf, _caccg := _g.ParseBool(_caeaf.Value)
			if _caccg != nil {
				return _caccg
			}
			_abdaec.ShowDataDropDownAttr = &_gecdf
			continue
		}
		if _caeaf.Name.Local == "colHeaderCaption" {
			_cgadcgb, _cgecf := _caeaf.Value, error(nil)
			if _cgecf != nil {
				return _cgecf
			}
			_abdaec.ColHeaderCaptionAttr = &_cgadcgb
			continue
		}
		if _caeaf.Name.Local == "subtotalHiddenItems" {
			_ccfbgf, _cabaa := _g.ParseBool(_caeaf.Value)
			if _cabaa != nil {
				return _cabaa
			}
			_abdaec.SubtotalHiddenItemsAttr = &_ccfbgf
			continue
		}
		if _caeaf.Name.Local == "mdxSubqueries" {
			_dcbba, _aecge := _g.ParseBool(_caeaf.Value)
			if _aecge != nil {
				return _aecge
			}
			_abdaec.MdxSubqueriesAttr = &_dcbba
			continue
		}
		if _caeaf.Name.Local == "errorCaption" {
			_bcdfc, _bcbbd := _caeaf.Value, error(nil)
			if _bcbbd != nil {
				return _bcbbd
			}
			_abdaec.ErrorCaptionAttr = &_bcdfc
			continue
		}
		if _caeaf.Name.Local == "colGrandTotals" {
			_cgfed, _bgbbcb := _g.ParseBool(_caeaf.Value)
			if _bgbbcb != nil {
				return _bgbbcb
			}
			_abdaec.ColGrandTotalsAttr = &_cgfed
			continue
		}
		if _caeaf.Name.Local == "printDrill" {
			_faeae, _gbdce := _g.ParseBool(_caeaf.Value)
			if _gbdce != nil {
				return _gbdce
			}
			_abdaec.PrintDrillAttr = &_faeae
			continue
		}
		if _caeaf.Name.Local == "itemPrintTitles" {
			_ebeacc, _dbgeg := _g.ParseBool(_caeaf.Value)
			if _dbgeg != nil {
				return _dbgeg
			}
			_abdaec.ItemPrintTitlesAttr = &_ebeacc
			continue
		}
		if _caeaf.Name.Local == "name" {
			_ddfab, _eagfd := _caeaf.Value, error(nil)
			if _eagfd != nil {
				return _eagfd
			}
			_abdaec.NameAttr = _ddfab
			continue
		}
		if _caeaf.Name.Local == "showDropZones" {
			_daacfg, _bbfff := _g.ParseBool(_caeaf.Value)
			if _bbfff != nil {
				return _bbfff
			}
			_abdaec.ShowDropZonesAttr = &_daacfg
			continue
		}
		if _caeaf.Name.Local == "showDataTips" {
			_ffeac, _ffbeb := _g.ParseBool(_caeaf.Value)
			if _ffbeb != nil {
				return _ffbeb
			}
			_abdaec.ShowDataTipsAttr = &_ffeac
			continue
		}
		if _caeaf.Name.Local == "vacatedStyle" {
			_begc, _ecgge := _caeaf.Value, error(nil)
			if _ecgge != nil {
				return _ecgge
			}
			_abdaec.VacatedStyleAttr = &_begc
			continue
		}
		if _caeaf.Name.Local == "grandTotalCaption" {
			_gdggdf, _decdd := _caeaf.Value, error(nil)
			if _decdd != nil {
				return _decdd
			}
			_abdaec.GrandTotalCaptionAttr = &_gdggdf
			continue
		}
		if _caeaf.Name.Local == "applyNumberFormats" {
			_feeda, _dddfg := _g.ParseBool(_caeaf.Value)
			if _dddfg != nil {
				return _dddfg
			}
			_abdaec.ApplyNumberFormatsAttr = &_feeda
			continue
		}
		if _caeaf.Name.Local == "enableDrill" {
			_aeggf, _cacgb := _g.ParseBool(_caeaf.Value)
			if _cacgb != nil {
				return _cacgb
			}
			_abdaec.EnableDrillAttr = &_aeggf
			continue
		}
		if _caeaf.Name.Local == "applyFontFormats" {
			_cgfdea, _bfcge := _g.ParseBool(_caeaf.Value)
			if _bfcge != nil {
				return _bfcge
			}
			_abdaec.ApplyFontFormatsAttr = &_cgfdea
			continue
		}
		if _caeaf.Name.Local == "disableFieldList" {
			_acgfg, _badafb := _g.ParseBool(_caeaf.Value)
			if _badafb != nil {
				return _badafb
			}
			_abdaec.DisableFieldListAttr = &_acgfg
			continue
		}
		if _caeaf.Name.Local == "applyAlignmentFormats" {
			_dcgee, _gcfga := _g.ParseBool(_caeaf.Value)
			if _gcfga != nil {
				return _gcfga
			}
			_abdaec.ApplyAlignmentFormatsAttr = &_dcgee
			continue
		}
		if _caeaf.Name.Local == "dataOnRows" {
			_efbee, _dbdeda := _g.ParseBool(_caeaf.Value)
			if _dbdeda != nil {
				return _dbdeda
			}
			_abdaec.DataOnRowsAttr = &_efbee
			continue
		}
		if _caeaf.Name.Local == "dataCaption" {
			_baecg, _gabcb := _caeaf.Value, error(nil)
			if _gabcb != nil {
				return _gabcb
			}
			_abdaec.DataCaptionAttr = _baecg
			continue
		}
		if _caeaf.Name.Local == "showError" {
			_gccce, _caceea := _g.ParseBool(_caeaf.Value)
			if _caceea != nil {
				return _caceea
			}
			_abdaec.ShowErrorAttr = &_gccce
			continue
		}
		if _caeaf.Name.Local == "cacheId" {
			_eegbc, _bffec := _g.ParseUint(_caeaf.Value, 10, 32)
			if _bffec != nil {
				return _bffec
			}
			_abdaec.CacheIdAttr = uint32(_eegbc)
			continue
		}
		if _caeaf.Name.Local == "enableWizard" {
			_efdcbb, _gadbda := _g.ParseBool(_caeaf.Value)
			if _gadbda != nil {
				return _gadbda
			}
			_abdaec.EnableWizardAttr = &_efdcbb
			continue
		}
		if _caeaf.Name.Local == "updatedVersion" {
			_deacg, _daaed := _g.ParseUint(_caeaf.Value, 10, 8)
			if _daaed != nil {
				return _daaed
			}
			_ecfea := uint8(_deacg)
			_abdaec.UpdatedVersionAttr = &_ecfea
			continue
		}
	}
_ggcddc:
	for {
		_aeccge, _fdgfcf := d.Token()
		if _fdgfcf != nil {
			return _fdgfcf
		}
		switch _fcdfbc := _aeccge.(type) {
		case _f.StartElement:
			switch _fcdfbc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "location"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "location"}:
				if _fdcaea := d.DecodeElement(_abdaec.Location, &_fcdfbc); _fdcaea != nil {
					return _fdcaea
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotFields"}:
				_abdaec.PivotFields = NewCT_PivotFields()
				if _fgadb := d.DecodeElement(_abdaec.PivotFields, &_fcdfbc); _fgadb != nil {
					return _fgadb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rowFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rowFields"}:
				_abdaec.RowFields = NewCT_RowFields()
				if _abcdb := d.DecodeElement(_abdaec.RowFields, &_fcdfbc); _abcdb != nil {
					return _abcdb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rowItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rowItems"}:
				_abdaec.RowItems = NewCT_rowItems()
				if _dagbc := d.DecodeElement(_abdaec.RowItems, &_fcdfbc); _dagbc != nil {
					return _dagbc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colFields"}:
				_abdaec.ColFields = NewCT_ColFields()
				if _daeded := d.DecodeElement(_abdaec.ColFields, &_fcdfbc); _daeded != nil {
					return _daeded
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colItems"}:
				_abdaec.ColItems = NewCT_colItems()
				if _gecabd := d.DecodeElement(_abdaec.ColItems, &_fcdfbc); _gecabd != nil {
					return _gecabd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageFields"}:
				_abdaec.PageFields = NewCT_PageFields()
				if _edfdf := d.DecodeElement(_abdaec.PageFields, &_fcdfbc); _edfdf != nil {
					return _edfdf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataFields"}:
				_abdaec.DataFields = NewCT_DataFields()
				if _ccgeeb := d.DecodeElement(_abdaec.DataFields, &_fcdfbc); _ccgeeb != nil {
					return _ccgeeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "formats"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "formats"}:
				_abdaec.Formats = NewCT_Formats()
				if _fedcdb := d.DecodeElement(_abdaec.Formats, &_fcdfbc); _fedcdb != nil {
					return _fedcdb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "conditionalFormats"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "conditionalFormats"}:
				_abdaec.ConditionalFormats = NewCT_ConditionalFormats()
				if _eagab := d.DecodeElement(_abdaec.ConditionalFormats, &_fcdfbc); _eagab != nil {
					return _eagab
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "chartFormats"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "chartFormats"}:
				_abdaec.ChartFormats = NewCT_ChartFormats()
				if _cfcffg := d.DecodeElement(_abdaec.ChartFormats, &_fcdfbc); _cfcffg != nil {
					return _cfcffg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotHierarchies"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotHierarchies"}:
				_abdaec.PivotHierarchies = NewCT_PivotHierarchies()
				if _febgeb := d.DecodeElement(_abdaec.PivotHierarchies, &_fcdfbc); _febgeb != nil {
					return _febgeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotTableStyleInfo"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotTableStyleInfo"}:
				_abdaec.PivotTableStyleInfo = NewCT_PivotTableStyle()
				if _aagdd := d.DecodeElement(_abdaec.PivotTableStyleInfo, &_fcdfbc); _aagdd != nil {
					return _aagdd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "filters"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "filters"}:
				_abdaec.Filters = NewCT_PivotFilters()
				if _dgecbg := d.DecodeElement(_abdaec.Filters, &_fcdfbc); _dgecbg != nil {
					return _dgecbg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rowHierarchiesUsage"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rowHierarchiesUsage"}:
				_abdaec.RowHierarchiesUsage = NewCT_RowHierarchiesUsage()
				if _gfdaaf := d.DecodeElement(_abdaec.RowHierarchiesUsage, &_fcdfbc); _gfdaaf != nil {
					return _gfdaaf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colHierarchiesUsage"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colHierarchiesUsage"}:
				_abdaec.ColHierarchiesUsage = NewCT_ColHierarchiesUsage()
				if _gbagdg := d.DecodeElement(_abdaec.ColHierarchiesUsage, &_fcdfbc); _gbagdg != nil {
					return _gbagdg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_abdaec.ExtLst = NewCT_ExtensionList()
				if _abdcfg := d.DecodeElement(_abdaec.ExtLst, &_fcdfbc); _abdcfg != nil {
					return _abdcfg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on\u0020PivotTableDefinition\u0020\u0025v", _fcdfbc.Name)
				if _bffed := d.Skip(); _bffed != nil {
					return _bffed
				}
			}
		case _f.EndElement:
			break _ggcddc
		case _f.CharData:
		}
	}
	return nil
}
func (_babac ST_Objects) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_babac.String(), start)
}
func (_ffgacg *CT_SheetProtection) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ffgacg.PasswordAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "password"}, Value: _bg.Sprintf("\u0025v", *_ffgacg.PasswordAttr)})
	}
	if _ffgacg.AlgorithmNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "algorithmName"}, Value: _bg.Sprintf("\u0025v", *_ffgacg.AlgorithmNameAttr)})
	}
	if _ffgacg.HashValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hashValue"}, Value: _bg.Sprintf("\u0025v", *_ffgacg.HashValueAttr)})
	}
	if _ffgacg.SaltValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "saltValue"}, Value: _bg.Sprintf("\u0025v", *_ffgacg.SaltValueAttr)})
	}
	if _ffgacg.SpinCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "spinCount"}, Value: _bg.Sprintf("\u0025v", *_ffgacg.SpinCountAttr)})
	}
	if _ffgacg.SheetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheet"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.SheetAttr))})
	}
	if _ffgacg.ObjectsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "objects"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.ObjectsAttr))})
	}
	if _ffgacg.ScenariosAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "scenarios"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.ScenariosAttr))})
	}
	if _ffgacg.FormatCellsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "formatCells"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.FormatCellsAttr))})
	}
	if _ffgacg.FormatColumnsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "formatColumns"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.FormatColumnsAttr))})
	}
	if _ffgacg.FormatRowsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "formatRows"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.FormatRowsAttr))})
	}
	if _ffgacg.InsertColumnsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "insertColumns"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.InsertColumnsAttr))})
	}
	if _ffgacg.InsertRowsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "insertRows"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.InsertRowsAttr))})
	}
	if _ffgacg.InsertHyperlinksAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "insertHyperlinks"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.InsertHyperlinksAttr))})
	}
	if _ffgacg.DeleteColumnsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "deleteColumns"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.DeleteColumnsAttr))})
	}
	if _ffgacg.DeleteRowsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "deleteRows"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.DeleteRowsAttr))})
	}
	if _ffgacg.SelectLockedCellsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "selectLockedCells"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.SelectLockedCellsAttr))})
	}
	if _ffgacg.SortAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sort"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.SortAttr))})
	}
	if _ffgacg.AutoFilterAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoFilter"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.AutoFilterAttr))})
	}
	if _ffgacg.PivotTablesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pivotTables"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.PivotTablesAttr))})
	}
	if _ffgacg.SelectUnlockedCellsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "selectUnlockedCells"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgacg.SelectUnlockedCellsAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bdfcgc *ST_DateTimeGrouping) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bdfcgc = 0
	case "year":
		*_bdfcgc = 1
	case "month":
		*_bdfcgc = 2
	case "day":
		*_bdfcgc = 3
	case "hour":
		*_bdfcgc = 4
	case "minute":
		*_bdfcgc = 5
	case "second":
		*_bdfcgc = 6
	}
	return nil
}

// ValidateWithPath validates the CT_BookViews and its children, prefixing error messages with path
func (_gbea *CT_BookViews) ValidateWithPath(path string) error {
	for _cbag, _afg := range _gbea.WorkbookView {
		if _fee := _afg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fWorkbookView\u005b\u0025d\u005d", path, _cbag)); _fee != nil {
			return _fee
		}
	}
	return nil
}
func (_bddbeag ST_GroupBy) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bddbeag.String(), start)
}
func NewCT_IgnoredErrors() *CT_IgnoredErrors { _aedda := &CT_IgnoredErrors{}; return _aedda }
func (_bcdbd ST_FieldSortType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bcdbd.String(), start)
}

type CT_SingleXmlCells struct {

	// Table Properties
	SingleXmlCell []*CT_SingleXmlCell
}

func NewCT_PageFields() *CT_PageFields { _gdfcc := &CT_PageFields{}; return _gdfcc }

// Validate validates the CT_CalculatedItem and its children
func (_abc *CT_CalculatedItem) Validate() error { return _abc.ValidateWithPath("CT_CalculatedItem") }
func (_beggb *ST_PageOrder) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fgbae, _dfcdcb := d.Token()
	if _dfcdcb != nil {
		return _dfcdcb
	}
	if _bbbac, _bgdfd := _fgbae.(_f.EndElement); _bgdfd && _bbbac.Name == start.Name {
		*_beggb = 1
		return nil
	}
	if _dfggge, _dccea := _fgbae.(_f.CharData); !_dccea {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fgbae)
	} else {
		switch string(_dfggge) {
		case "":
			*_beggb = 0
		case "downThenOver":
			*_beggb = 1
		case "overThenDown":
			*_beggb = 2
		}
	}
	_fgbae, _dfcdcb = d.Token()
	if _dfcdcb != nil {
		return _dfcdcb
	}
	if _cfccb, _fcdefcf := _fgbae.(_f.EndElement); _fcdefcf && _cfccb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fgbae)
}

type ST_Sqref []string

func (_aagbc ST_FormatAction) String() string {
	switch _aagbc {
	case 0:
		return ""
	case 1:
		return "blank"
	case 2:
		return "formatting"
	case 3:
		return "drill"
	case 4:
		return "formula"
	}
	return ""
}
func (_cfceg *CT_SheetIdMap) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cfceg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_cfceg.CountAttr)})
	}
	e.EncodeToken(start)
	_fcagb := _f.StartElement{Name: _f.Name{Local: "ma:sheetId"}}
	for _, _beeede := range _cfceg.SheetId {
		e.EncodeElement(_beeede, _fcagb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Comments and its children, prefixing error messages with path
func (_beagf *Comments) ValidateWithPath(path string) error {
	if _fgcgb := _beagf.CT_Comments.ValidateWithPath(path); _fgcgb != nil {
		return _fgcgb
	}
	return nil
}
func (_acefc *CT_Pane) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _acefc.XSplitAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xSplit"}, Value: _bg.Sprintf("\u0025v", *_acefc.XSplitAttr)})
	}
	if _acefc.YSplitAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ySplit"}, Value: _bg.Sprintf("\u0025v", *_acefc.YSplitAttr)})
	}
	if _acefc.TopLeftCellAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "topLeftCell"}, Value: _bg.Sprintf("\u0025v", *_acefc.TopLeftCellAttr)})
	}
	if _acefc.ActivePaneAttr != ST_PaneUnset {
		_dgdae, _gfaef := _acefc.ActivePaneAttr.MarshalXMLAttr(_f.Name{Local: "activePane"})
		if _gfaef != nil {
			return _gfaef
		}
		start.Attr = append(start.Attr, _dgdae)
	}
	if _acefc.StateAttr != ST_PaneStateUnset {
		_cegefg, _dfgbd := _acefc.StateAttr.MarshalXMLAttr(_f.Name{Local: "state"})
		if _dfgbd != nil {
			return _dfgbd
		}
		start.Attr = append(start.Attr, _cegefg)
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_PCDSDTCEntries() *CT_PCDSDTCEntries { _afdced := &CT_PCDSDTCEntries{}; return _afdced }

type CT_BorderPr struct {

	// Line Style
	StyleAttr ST_BorderStyle

	// Color
	Color *CT_Color
}

// Validate validates the CT_Border and its children
func (_dga *CT_Border) Validate() error { return _dga.ValidateWithPath("CT_Border") }
func (_egeac *CT_ConditionalFormat) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _egeac.ScopeAttr != ST_ScopeUnset {
		_gabb, _cafc := _egeac.ScopeAttr.MarshalXMLAttr(_f.Name{Local: "scope"})
		if _cafc != nil {
			return _cafc
		}
		start.Attr = append(start.Attr, _gabb)
	}
	if _egeac.TypeAttr != ST_TypeUnset {
		_edga, _baaa := _egeac.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
		if _baaa != nil {
			return _baaa
		}
		start.Attr = append(start.Attr, _edga)
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "priority"}, Value: _bg.Sprintf("\u0025v", _egeac.PriorityAttr)})
	e.EncodeToken(start)
	_bbcbb := _f.StartElement{Name: _f.Name{Local: "ma:pivotAreas"}}
	e.EncodeElement(_egeac.PivotAreas, _bbcbb)
	if _egeac.ExtLst != nil {
		_gfaf := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_egeac.ExtLst, _gfaf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

const (
	ST_OleUpdateUnset            ST_OleUpdate = 0
	ST_OleUpdateOLEUPDATE_ALWAYS ST_OleUpdate = 1
	ST_OleUpdateOLEUPDATE_ONCALL ST_OleUpdate = 2
)

func (_geefdc ST_TableStyleType) ValidateWithPath(path string) error {
	switch _geefdc {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_geefdc))
	}
	return nil
}
func (_gbgccd ST_ExternalConnectionType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_gbgccd.String(), start)
}

// Validate validates the Metadata and its children
func (_dabbg *Metadata) Validate() error            { return _dabbg.ValidateWithPath("Metadata") }
func ParseSliceST_Sqref(s string) (ST_Sqref, error) { return ST_Sqref(_fd.Fields(s)), nil }

// Validate validates the CT_ConditionalFormatting and its children
func (_dgfac *CT_ConditionalFormatting) Validate() error {
	return _dgfac.ValidateWithPath("CT_ConditionalFormatting")
}
func (_fcafd ST_ExternalConnectionType) ValidateWithPath(path string) error {
	switch _fcafd {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fcafd))
	}
	return nil
}

type CT_Top10 struct {

	// Top
	TopAttr *bool

	// Filter by Percent
	PercentAttr *bool

	// Top or Bottom Value
	ValAttr float64

	// Filter Value
	FilterValAttr *float64
}
type CT_DdeValue struct {

	// DDE Value Type
	TAttr ST_DdeValueType

	// DDE Link Value
	Val string
}

// ValidateWithPath validates the CT_RevisionHeader and its children, prefixing error messages with path
func (_fdcbgb *CT_RevisionHeader) ValidateWithPath(path string) error {
	if !_e.ST_GuidPatternRe.MatchString(_fdcbgb.GuidAttr) {
		return _bg.Errorf("\u0025s\u002fm\u002eGuidAttr must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_GuidPatternRe, _fdcbgb.GuidAttr)
	}
	if _dggffd := _fdcbgb.SheetIdMap.ValidateWithPath(path + "/SheetIdMap"); _dggffd != nil {
		return _dggffd
	}
	if _fdcbgb.ReviewedList != nil {
		if _ecegg := _fdcbgb.ReviewedList.ValidateWithPath(path + "\u002fReviewedList"); _ecegg != nil {
			return _ecegg
		}
	}
	if _fdcbgb.ExtLst != nil {
		if _gfcffb := _fdcbgb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gfcffb != nil {
			return _gfcffb
		}
	}
	return nil
}
func NewCT_Control() *CT_Control { _ebgb := &CT_Control{}; return _ebgb }
func (_eeeafb ST_MdxFunctionType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_aegfba := _f.Attr{}
	_aegfba.Name = name
	switch _eeeafb {
	case ST_MdxFunctionTypeUnset:
		_aegfba.Value = ""
	case ST_MdxFunctionTypeM:
		_aegfba.Value = "m"
	case ST_MdxFunctionTypeV:
		_aegfba.Value = "v"
	case ST_MdxFunctionTypeS:
		_aegfba.Value = "s"
	case ST_MdxFunctionTypeC:
		_aegfba.Value = "c"
	case ST_MdxFunctionTypeR:
		_aegfba.Value = "r"
	case ST_MdxFunctionTypeP:
		_aegfba.Value = "p"
	case ST_MdxFunctionTypeK:
		_aegfba.Value = "k"
	}
	return _aegfba, nil
}
func NewDialogsheet() *Dialogsheet {
	_beaefe := &Dialogsheet{}
	_beaefe.CT_Dialogsheet = *NewCT_Dialogsheet()
	return _beaefe
}
func (_fdefe *ST_SortMethod) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_fdefe = 0
	case "stroke":
		*_fdefe = 1
	case "pinYin":
		*_fdefe = 2
	case "none":
		*_fdefe = 3
	}
	return nil
}

type CT_CustomFilters struct {

	// And
	AndAttr *bool

	// Custom Filter Criteria
	CustomFilter []*CT_CustomFilter
}

// ValidateWithPath validates the CT_TableStyleElement and its children, prefixing error messages with path
func (_gbedc *CT_TableStyleElement) ValidateWithPath(path string) error {
	if _gbedc.TypeAttr == ST_TableStyleTypeUnset {
		return _bg.Errorf("\u0025s\u002fTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _afege := _gbedc.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _afege != nil {
		return _afege
	}
	return nil
}

// ValidateWithPath validates the CT_CellStyleXfs and its children, prefixing error messages with path
func (_ebag *CT_CellStyleXfs) ValidateWithPath(path string) error {
	for _cadf, _bagge := range _ebag.Xf {
		if _abfe := _bagge.ValidateWithPath(_bg.Sprintf("\u0025s\u002fXf\u005b\u0025d]", path, _cadf)); _abfe != nil {
			return _abfe
		}
	}
	return nil
}

// Validate validates the MapInfo and its children
func (_bgfbb *MapInfo) Validate() error { return _bgfbb.ValidateWithPath("MapInfo") }
func (_eeccgf *CT_QueryTableFields) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bfdab := range start.Attr {
		if _bfdab.Name.Local == "count" {
			_aedef, _eecaec := _g.ParseUint(_bfdab.Value, 10, 32)
			if _eecaec != nil {
				return _eecaec
			}
			_fcdcgd := uint32(_aedef)
			_eeccgf.CountAttr = &_fcdcgd
			continue
		}
	}
_ddcfb:
	for {
		_gadf, _gecacb := d.Token()
		if _gecacb != nil {
			return _gecacb
		}
		switch _bfce := _gadf.(type) {
		case _f.StartElement:
			switch _bfce.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "queryTableField"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "queryTableField"}:
				_bdbbd := NewCT_QueryTableField()
				if _addaf := d.DecodeElement(_bdbbd, &_bfce); _addaf != nil {
					return _addaf
				}
				_eeccgf.QueryTableField = append(_eeccgf.QueryTableField, _bdbbd)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_QueryTableFields\u0020\u0025v", _bfce.Name)
				if _ebbecd := d.Skip(); _ebbecd != nil {
					return _ebbecd
				}
			}
		case _f.EndElement:
			break _ddcfb
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_FieldUsage() *CT_FieldUsage { _gabgb := &CT_FieldUsage{}; return _gabgb }
func (_daccb ST_ItemType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_beeece := _f.Attr{}
	_beeece.Name = name
	switch _daccb {
	case ST_ItemTypeUnset:
		_beeece.Value = ""
	case ST_ItemTypeData:
		_beeece.Value = "data"
	case ST_ItemTypeDefault:
		_beeece.Value = "default"
	case ST_ItemTypeSum:
		_beeece.Value = "sum"
	case ST_ItemTypeCountA:
		_beeece.Value = "countA"
	case ST_ItemTypeAvg:
		_beeece.Value = "avg"
	case ST_ItemTypeMax:
		_beeece.Value = "max"
	case ST_ItemTypeMin:
		_beeece.Value = "min"
	case ST_ItemTypeProduct:
		_beeece.Value = "product"
	case ST_ItemTypeCount:
		_beeece.Value = "count"
	case ST_ItemTypeStdDev:
		_beeece.Value = "stdDev"
	case ST_ItemTypeStdDevP:
		_beeece.Value = "stdDevP"
	case ST_ItemTypeVar:
		_beeece.Value = "var"
	case ST_ItemTypeVarP:
		_beeece.Value = "varP"
	case ST_ItemTypeGrand:
		_beeece.Value = "grand"
	case ST_ItemTypeBlank:
		_beeece.Value = "blank"
	}
	return _beeece, nil
}

type CT_MetadataTypes struct {

	// Metadata Type Count
	CountAttr *uint32

	// Metadata Type Information
	MetadataType []*CT_MetadataType
}

func NewCT_CfRule() *CT_CfRule { _bcee := &CT_CfRule{}; return _bcee }

const (
	ST_VolValueTypeUnset ST_VolValueType = 0
	ST_VolValueTypeB     ST_VolValueType = 1
	ST_VolValueTypeN     ST_VolValueType = 2
	ST_VolValueTypeE     ST_VolValueType = 3
	ST_VolValueTypeS     ST_VolValueType = 4
)

func (_gdfacd ST_Pane) Validate() error { return _gdfacd.ValidateWithPath("") }

// ValidateWithPath validates the CT_colItems and its children, prefixing error messages with path
func (_ceeeg *CT_colItems) ValidateWithPath(path string) error {
	for _gbfga, _gcafg := range _ceeeg.I {
		if _adeag := _gcafg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fI\u005b\u0025d\u005d", path, _gbfga)); _adeag != nil {
			return _adeag
		}
	}
	return nil
}

// Validate validates the CT_ProtectedRange and its children
func (_cgdbd *CT_ProtectedRange) Validate() error {
	return _cgdbd.ValidateWithPath("CT_ProtectedRange")
}
func (_dcadff ST_SheetState) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_dcadff.String(), start)
}
func (_cca *CT_BookView) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cca.VisibilityAttr != ST_VisibilityUnset {
		_dab, _eeb := _cca.VisibilityAttr.MarshalXMLAttr(_f.Name{Local: "visibility"})
		if _eeb != nil {
			return _eeb
		}
		start.Attr = append(start.Attr, _dab)
	}
	if _cca.MinimizedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minimized"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cca.MinimizedAttr))})
	}
	if _cca.ShowHorizontalScrollAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showHorizontalScroll"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cca.ShowHorizontalScrollAttr))})
	}
	if _cca.ShowVerticalScrollAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showVerticalScroll"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cca.ShowVerticalScrollAttr))})
	}
	if _cca.ShowSheetTabsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showSheetTabs"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cca.ShowSheetTabsAttr))})
	}
	if _cca.XWindowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xWindow"}, Value: _bg.Sprintf("\u0025v", *_cca.XWindowAttr)})
	}
	if _cca.YWindowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "yWindow"}, Value: _bg.Sprintf("\u0025v", *_cca.YWindowAttr)})
	}
	if _cca.WindowWidthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "windowWidth"}, Value: _bg.Sprintf("\u0025v", *_cca.WindowWidthAttr)})
	}
	if _cca.WindowHeightAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "windowHeight"}, Value: _bg.Sprintf("\u0025v", *_cca.WindowHeightAttr)})
	}
	if _cca.TabRatioAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "tabRatio"}, Value: _bg.Sprintf("\u0025v", *_cca.TabRatioAttr)})
	}
	if _cca.FirstSheetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "firstSheet"}, Value: _bg.Sprintf("\u0025v", *_cca.FirstSheetAttr)})
	}
	if _cca.ActiveTabAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "activeTab"}, Value: _bg.Sprintf("\u0025v", *_cca.ActiveTabAttr)})
	}
	if _cca.AutoFilterDateGroupingAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoFilterDateGrouping"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cca.AutoFilterDateGroupingAttr))})
	}
	e.EncodeToken(start)
	if _cca.ExtLst != nil {
		_gdd := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_cca.ExtLst, _gdd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gcdfcb *CT_Selection) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cacaa := range start.Attr {
		if _cacaa.Name.Local == "pane" {
			_gcdfcb.PaneAttr.UnmarshalXMLAttr(_cacaa)
			continue
		}
		if _cacaa.Name.Local == "activeCell" {
			_bebbad, _bdgfc := _cacaa.Value, error(nil)
			if _bdgfc != nil {
				return _bdgfc
			}
			_gcdfcb.ActiveCellAttr = &_bebbad
			continue
		}
		if _cacaa.Name.Local == "activeCellId" {
			_gedfge, _eeeaf := _g.ParseUint(_cacaa.Value, 10, 32)
			if _eeeaf != nil {
				return _eeeaf
			}
			_fgbbgf := uint32(_gedfge)
			_gcdfcb.ActiveCellIdAttr = &_fgbbgf
			continue
		}
		if _cacaa.Name.Local == "sqref" {
			_fdcfe, _gcaead := ParseSliceST_Sqref(_cacaa.Value)
			if _gcaead != nil {
				return _gcaead
			}
			_gcdfcb.SqrefAttr = &_fdcfe
			continue
		}
	}
	for {
		_eabgd, _fgffe := d.Token()
		if _fgffe != nil {
			return _bg.Errorf("parsing\u0020CT_Selection:\u0020\u0025s", _fgffe)
		}
		if _gaeca, _fgddg := _eabgd.(_f.EndElement); _fgddg && _gaeca.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ExternalDefinedNames and its children, prefixing error messages with path
func (_bbfef *CT_ExternalDefinedNames) ValidateWithPath(path string) error {
	for _eadge, _gbedb := range _bbfef.DefinedName {
		if _afeb := _gbedb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fDefinedName\u005b\u0025d\u005d", path, _eadge)); _afeb != nil {
			return _afeb
		}
	}
	return nil
}

// Validate validates the CT_rowItems and its children
func (_gaeff *CT_rowItems) Validate() error { return _gaeff.ValidateWithPath("CT_rowItems") }
func (_ebdfe *CT_CustomSheetViews) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_ddbc:
	for {
		_dcbf, _bddae := d.Token()
		if _bddae != nil {
			return _bddae
		}
		switch _gdcga := _dcbf.(type) {
		case _f.StartElement:
			switch _gdcga.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customSheetView"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customSheetView"}:
				_ccdag := NewCT_CustomSheetView()
				if _cbdaab := d.DecodeElement(_ccdag, &_gdcga); _cbdaab != nil {
					return _cbdaab
				}
				_ebdfe.CustomSheetView = append(_ebdfe.CustomSheetView, _ccdag)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CustomSheetViews\u0020\u0025v", _gdcga.Name)
				if _ffbab := d.Skip(); _ffbab != nil {
					return _ffbab
				}
			}
		case _f.EndElement:
			break _ddbc
		case _f.CharData:
		}
	}
	return nil
}

type CT_SharedUser struct {

	// User Revisions GUID
	GuidAttr string

	// User Name
	NameAttr string

	// User Id
	IdAttr int32

	// Date Time
	DateTimeAttr _b.Time
	ExtLst       *CT_ExtensionList
}
type CT_Metadata struct {

	// Metadata Types Collection
	MetadataTypes *CT_MetadataTypes

	// Metadata String Store
	MetadataStrings *CT_MetadataStrings

	// MDX Metadata Information
	MdxMetadata *CT_MdxMetadata

	// Future Metadata
	FutureMetadata []*CT_FutureMetadata

	// Cell Metadata
	CellMetadata *CT_MetadataBlocks

	// Value Metadata
	ValueMetadata *CT_MetadataBlocks

	// Future Feature Storage Area
	ExtLst *CT_ExtensionList
}
type CT_Boolean struct {

	// Value
	VAttr bool

	// Unused Item
	UAttr *bool

	// Calculated Item
	FAttr *bool

	// Caption
	CAttr *string

	// Member Property Count
	CpAttr *uint32

	// Member Property Indexes
	X []*CT_X
}

func (_aafbe *CT_ExtensionList) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_adcb:
	for {
		_befcf, _adbca := d.Token()
		if _adbca != nil {
			return _adbca
		}
		switch _gdacf := _befcf.(type) {
		case _f.StartElement:
			switch _gdacf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ext"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ext"}:
				_faaab := NewCT_Extension()
				if _gadee := d.DecodeElement(_faaab, &_gdacf); _gadee != nil {
					return _gadee
				}
				_aafbe.Ext = append(_aafbe.Ext, _faaab)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ExtensionList\u0020\u0025v", _gdacf.Name)
				if _dgeedg := d.Skip(); _dgeedg != nil {
					return _dgeedg
				}
			}
		case _f.EndElement:
			break _adcb
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PivotTableStyle and its children, prefixing error messages with path
func (_gggcaa *CT_PivotTableStyle) ValidateWithPath(path string) error { return nil }
func (_daefdg ST_FontScheme) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_daefdg.String(), start)
}

// ValidateWithPath validates the CT_Reviewed and its children, prefixing error messages with path
func (_egffd *CT_Reviewed) ValidateWithPath(path string) error { return nil }

type CT_Hyperlinks struct {

	// Hyperlink
	Hyperlink []*CT_Hyperlink
}

func (_ddbe *CT_CommentList) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_dfef:
	for {
		_cacbg, _bggca := d.Token()
		if _bggca != nil {
			return _bggca
		}
		switch _fbffa := _cacbg.(type) {
		case _f.StartElement:
			switch _fbffa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "comment"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "comment"}:
				_bdfd := NewCT_Comment()
				if _aedf := d.DecodeElement(_bdfd, &_fbffa); _aedf != nil {
					return _aedf
				}
				_ddbe.Comment = append(_ddbe.Comment, _bdfd)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CommentList\u0020\u0025v", _fbffa.Name)
				if _dcae := d.Skip(); _dcae != nil {
					return _dcae
				}
			}
		case _f.EndElement:
			break _dfef
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Filters and its children
func (_abedg *CT_Filters) Validate() error { return _abedg.ValidateWithPath("CT_Filters") }
func (_afffe *CT_MetadataStringIndex) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "x"}, Value: _bg.Sprintf("\u0025v", _afffe.XAttr)})
	if _afffe.SAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "s"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_afffe.SAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_aec *CT_BorderPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aec.StyleAttr != ST_BorderStyleUnset {
		_ggg, _aeag := _aec.StyleAttr.MarshalXMLAttr(_f.Name{Local: "style"})
		if _aeag != nil {
			return _aeag
		}
		start.Attr = append(start.Attr, _ggg)
	}
	e.EncodeToken(start)
	if _aec.Color != nil {
		_cdfa := _f.StartElement{Name: _f.Name{Local: "ma:color"}}
		e.EncodeElement(_aec.Color, _cdfa)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_IgnoredErrors and its children, prefixing error messages with path
func (_cdedac *CT_IgnoredErrors) ValidateWithPath(path string) error {
	for _dddd, _dgbb := range _cdedac.IgnoredError {
		if _gccb := _dgbb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fIgnoredError\u005b\u0025d\u005d", path, _dddd)); _gccb != nil {
			return _gccb
		}
	}
	if _cdedac.ExtLst != nil {
		if _geded := _cdedac.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _geded != nil {
			return _geded
		}
	}
	return nil
}

// Validate validates the CT_DataRefs and its children
func (_daca *CT_DataRefs) Validate() error { return _daca.ValidateWithPath("CT_DataRefs") }

type CT_Reviewed struct {

	// revision Id
	RIdAttr uint32
}

// ValidateWithPath validates the CT_VolTopicRef and its children, prefixing error messages with path
func (_ebeeb *CT_VolTopicRef) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_TableStyleElement and its children
func (_bbdbc *CT_TableStyleElement) Validate() error {
	return _bbdbc.ValidateWithPath("CT_TableStyleElement")
}

// Validate validates the CT_BorderPr and its children
func (_cdg *CT_BorderPr) Validate() error { return _cdg.ValidateWithPath("CT_BorderPr") }

type CT_WebPr struct {

	// XML Source
	XmlAttr *bool

	// Import XML Source Data
	SourceDataAttr *bool

	// Parse PRE
	ParsePreAttr *bool

	// Consecutive Delimiters
	ConsecutiveAttr *bool

	// Use First Row
	FirstRowAttr *bool

	// Created in Excel 97
	Xl97Attr *bool

	// Dates as Text
	TextDatesAttr *bool

	// Refreshed in Excel 2000
	Xl2000Attr *bool

	// URL
	UrlAttr *string

	// Web Post
	PostAttr *string

	// HTML Tables Only
	HtmlTablesAttr *bool

	// HTML Formatting Handling
	HtmlFormatAttr ST_HtmlFmt

	// Edit Query URL
	EditPageAttr *string

	// Tables
	Tables *CT_Tables
}

// Validate validates the CT_FutureMetadata and its children
func (_caeb *CT_FutureMetadata) Validate() error { return _caeb.ValidateWithPath("CT_FutureMetadata") }
func (_ffa *CT_CacheField) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _ffa.NameAttr)})
	if _ffa.CaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "caption"}, Value: _bg.Sprintf("\u0025v", *_ffa.CaptionAttr)})
	}
	if _ffa.PropertyNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "propertyName"}, Value: _bg.Sprintf("\u0025v", *_ffa.PropertyNameAttr)})
	}
	if _ffa.ServerFieldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "serverField"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffa.ServerFieldAttr))})
	}
	if _ffa.UniqueListAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueList"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffa.UniqueListAttr))})
	}
	if _ffa.NumFmtIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "numFmtId"}, Value: _bg.Sprintf("\u0025v", *_ffa.NumFmtIdAttr)})
	}
	if _ffa.FormulaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "formula"}, Value: _bg.Sprintf("\u0025v", *_ffa.FormulaAttr)})
	}
	if _ffa.SqlTypeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sqlType"}, Value: _bg.Sprintf("\u0025v", *_ffa.SqlTypeAttr)})
	}
	if _ffa.HierarchyAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hierarchy"}, Value: _bg.Sprintf("\u0025v", *_ffa.HierarchyAttr)})
	}
	if _ffa.LevelAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "level"}, Value: _bg.Sprintf("\u0025v", *_ffa.LevelAttr)})
	}
	if _ffa.DatabaseFieldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "databaseField"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffa.DatabaseFieldAttr))})
	}
	if _ffa.MappingCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "mappingCount"}, Value: _bg.Sprintf("\u0025v", *_ffa.MappingCountAttr)})
	}
	if _ffa.MemberPropertyFieldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "memberPropertyField"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffa.MemberPropertyFieldAttr))})
	}
	e.EncodeToken(start)
	if _ffa.SharedItems != nil {
		_feac := _f.StartElement{Name: _f.Name{Local: "ma:sharedItems"}}
		e.EncodeElement(_ffa.SharedItems, _feac)
	}
	if _ffa.FieldGroup != nil {
		_aefa := _f.StartElement{Name: _f.Name{Local: "ma:fieldGroup"}}
		e.EncodeElement(_ffa.FieldGroup, _aefa)
	}
	if _ffa.MpMap != nil {
		_afbd := _f.StartElement{Name: _f.Name{Local: "ma:mpMap"}}
		for _, _faea := range _ffa.MpMap {
			e.EncodeElement(_faea, _afbd)
		}
	}
	if _ffa.ExtLst != nil {
		_eaga := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_ffa.ExtLst, _eaga)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_GradientFill and its children
func (_bfagc *CT_GradientFill) Validate() error { return _bfagc.ValidateWithPath("CT_GradientFill") }

// ValidateWithPath validates the CT_Index and its children, prefixing error messages with path
func (_accc *CT_Index) ValidateWithPath(path string) error { return nil }
func (_abbge *CT_TableStyles) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gbebb := range start.Attr {
		if _gbebb.Name.Local == "count" {
			_cdgggb, _gfcbec := _g.ParseUint(_gbebb.Value, 10, 32)
			if _gfcbec != nil {
				return _gfcbec
			}
			_bfceg := uint32(_cdgggb)
			_abbge.CountAttr = &_bfceg
			continue
		}
		if _gbebb.Name.Local == "defaultTableStyle" {
			_agggef, _bdfeca := _gbebb.Value, error(nil)
			if _bdfeca != nil {
				return _bdfeca
			}
			_abbge.DefaultTableStyleAttr = &_agggef
			continue
		}
		if _gbebb.Name.Local == "defaultPivotStyle" {
			_ebafd, _eaceda := _gbebb.Value, error(nil)
			if _eaceda != nil {
				return _eaceda
			}
			_abbge.DefaultPivotStyleAttr = &_ebafd
			continue
		}
	}
_cadfb:
	for {
		_bbdda, _dgcdf := d.Token()
		if _dgcdf != nil {
			return _dgcdf
		}
		switch _ebaacb := _bbdda.(type) {
		case _f.StartElement:
			switch _ebaacb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tableStyle"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tableStyle"}:
				_ecdedb := NewCT_TableStyle()
				if _acfbg := d.DecodeElement(_ecdedb, &_ebaacb); _acfbg != nil {
					return _acfbg
				}
				_abbge.TableStyle = append(_abbge.TableStyle, _ecdedb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TableStyles\u0020\u0025v", _ebaacb.Name)
				if _ccbef := d.Skip(); _ccbef != nil {
					return _ccbef
				}
			}
		case _f.EndElement:
			break _cadfb
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PivotField and its children, prefixing error messages with path
func (_fgbgce *CT_PivotField) ValidateWithPath(path string) error {
	if _beeg := _fgbgce.AxisAttr.ValidateWithPath(path + "\u002fAxisAttr"); _beeg != nil {
		return _beeg
	}
	if _cacgd := _fgbgce.SortTypeAttr.ValidateWithPath(path + "\u002fSortTypeAttr"); _cacgd != nil {
		return _cacgd
	}
	if _fgbgce.Items != nil {
		if _egagc := _fgbgce.Items.ValidateWithPath(path + "\u002fItems"); _egagc != nil {
			return _egagc
		}
	}
	if _fgbgce.AutoSortScope != nil {
		if _feaeff := _fgbgce.AutoSortScope.ValidateWithPath(path + "\u002fAutoSortScope"); _feaeff != nil {
			return _feaeff
		}
	}
	if _fgbgce.ExtLst != nil {
		if _eggdgb := _fgbgce.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eggdgb != nil {
			return _eggdgb
		}
	}
	return nil
}

type CT_ChartFormats struct {

	// Format Count
	CountAttr *uint32

	// PivotChart Format
	ChartFormat []*CT_ChartFormat
}

func (_fdgdb *CT_WebPublishObject) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", _fdgdb.IdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "divId"}, Value: _bg.Sprintf("\u0025v", _fdgdb.DivIdAttr)})
	if _fdgdb.SourceObjectAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sourceObject"}, Value: _bg.Sprintf("\u0025v", *_fdgdb.SourceObjectAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "destinationFile"}, Value: _bg.Sprintf("\u0025v", _fdgdb.DestinationFileAttr)})
	if _fdgdb.TitleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "title"}, Value: _bg.Sprintf("\u0025v", *_fdgdb.TitleAttr)})
	}
	if _fdgdb.AutoRepublishAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoRepublish"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fdgdb.AutoRepublishAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_efbgf *CT_RevisionComment) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_efbgf.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	for _, _gdffa := range start.Attr {
		if _gdffa.Name.Local == "sheetId" {
			_dfdab, _ecaeb := _g.ParseUint(_gdffa.Value, 10, 32)
			if _ecaeb != nil {
				return _ecaeb
			}
			_efbgf.SheetIdAttr = uint32(_dfdab)
			continue
		}
		if _gdffa.Name.Local == "cell" {
			_defe, _ecagf := _gdffa.Value, error(nil)
			if _ecagf != nil {
				return _ecagf
			}
			_efbgf.CellAttr = _defe
			continue
		}
		if _gdffa.Name.Local == "guid" {
			_fecgg, _gefefd := _gdffa.Value, error(nil)
			if _gefefd != nil {
				return _gefefd
			}
			_efbgf.GuidAttr = _fecgg
			continue
		}
		if _gdffa.Name.Local == "action" {
			_efbgf.ActionAttr.UnmarshalXMLAttr(_gdffa)
			continue
		}
		if _gdffa.Name.Local == "alwaysShow" {
			_fddbf, _fgfada := _g.ParseBool(_gdffa.Value)
			if _fgfada != nil {
				return _fgfada
			}
			_efbgf.AlwaysShowAttr = &_fddbf
			continue
		}
		if _gdffa.Name.Local == "old" {
			_cbeegf, _cegfae := _g.ParseBool(_gdffa.Value)
			if _cegfae != nil {
				return _cegfae
			}
			_efbgf.OldAttr = &_cbeegf
			continue
		}
		if _gdffa.Name.Local == "hiddenRow" {
			_aecee, _edfdc := _g.ParseBool(_gdffa.Value)
			if _edfdc != nil {
				return _edfdc
			}
			_efbgf.HiddenRowAttr = &_aecee
			continue
		}
		if _gdffa.Name.Local == "hiddenColumn" {
			_febdd, _acdcce := _g.ParseBool(_gdffa.Value)
			if _acdcce != nil {
				return _acdcce
			}
			_efbgf.HiddenColumnAttr = &_febdd
			continue
		}
		if _gdffa.Name.Local == "author" {
			_defdfb, _dfcca := _gdffa.Value, error(nil)
			if _dfcca != nil {
				return _dfcca
			}
			_efbgf.AuthorAttr = _defdfb
			continue
		}
		if _gdffa.Name.Local == "oldLength" {
			_baafd, _dfebf := _g.ParseUint(_gdffa.Value, 10, 32)
			if _dfebf != nil {
				return _dfebf
			}
			_bccde := uint32(_baafd)
			_efbgf.OldLengthAttr = &_bccde
			continue
		}
		if _gdffa.Name.Local == "newLength" {
			_bgeea, _eeaae := _g.ParseUint(_gdffa.Value, 10, 32)
			if _eeaae != nil {
				return _eeaae
			}
			_dbgeba := uint32(_bgeea)
			_efbgf.NewLengthAttr = &_dbgeba
			continue
		}
	}
	for {
		_fbdbc, _fcffcg := d.Token()
		if _fcffcg != nil {
			return _bg.Errorf("parsing\u0020CT_RevisionComment:\u0020\u0025s", _fcffcg)
		}
		if _dedfgb, _feggf := _fbdbc.(_f.EndElement); _feggf && _dedfgb.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_HeaderFooter and its children
func (_bcaca *CT_HeaderFooter) Validate() error { return _bcaca.ValidateWithPath("CT_HeaderFooter") }
func (_edaab *CT_pivotTableDefinition) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_edaab.Location = NewCT_Location()
	for _, _acfcad := range start.Attr {
		if _acfcad.Name.Local == "createdVersion" {
			_edfbg, _bcgbf := _g.ParseUint(_acfcad.Value, 10, 8)
			if _bcgbf != nil {
				return _bcgbf
			}
			_gbabd := uint8(_edfbg)
			_edaab.CreatedVersionAttr = &_gbabd
			continue
		}
		if _acfcad.Name.Local == "indent" {
			_cdegc, _bdfaa := _g.ParseUint(_acfcad.Value, 10, 32)
			if _bdfaa != nil {
				return _bdfaa
			}
			_ffceda := uint32(_cdegc)
			_edaab.IndentAttr = &_ffceda
			continue
		}
		if _acfcad.Name.Local == "pivotTableStyle" {
			_caadcb, _dfaab := _acfcad.Value, error(nil)
			if _dfaab != nil {
				return _dfaab
			}
			_edaab.PivotTableStyleAttr = &_caadcb
			continue
		}
		if _acfcad.Name.Local == "showEmptyRow" {
			_ddgggb, _gebaf := _g.ParseBool(_acfcad.Value)
			if _gebaf != nil {
				return _gebaf
			}
			_edaab.ShowEmptyRowAttr = &_ddgggb
			continue
		}
		if _acfcad.Name.Local == "tag" {
			_cfecg, _effcbc := _acfcad.Value, error(nil)
			if _effcbc != nil {
				return _effcbc
			}
			_edaab.TagAttr = &_cfecg
			continue
		}
		if _acfcad.Name.Local == "showEmptyCol" {
			_cdacf, _cebad := _g.ParseBool(_acfcad.Value)
			if _cebad != nil {
				return _cebad
			}
			_edaab.ShowEmptyColAttr = &_cdacf
			continue
		}
		if _acfcad.Name.Local == "minRefreshableVersion" {
			_fdada, _aedee := _g.ParseUint(_acfcad.Value, 10, 8)
			if _aedee != nil {
				return _aedee
			}
			_afggb := uint8(_fdada)
			_edaab.MinRefreshableVersionAttr = &_afggb
			continue
		}
		if _acfcad.Name.Local == "showHeaders" {
			_caddb, _bffdb := _g.ParseBool(_acfcad.Value)
			if _bffdb != nil {
				return _bffdb
			}
			_edaab.ShowHeadersAttr = &_caddb
			continue
		}
		if _acfcad.Name.Local == "asteriskTotals" {
			_adaae, _gcadd := _g.ParseBool(_acfcad.Value)
			if _gcadd != nil {
				return _gcadd
			}
			_edaab.AsteriskTotalsAttr = &_adaae
			continue
		}
		if _acfcad.Name.Local == "compact" {
			_bdggb, _bebff := _g.ParseBool(_acfcad.Value)
			if _bebff != nil {
				return _bebff
			}
			_edaab.CompactAttr = &_bdggb
			continue
		}
		if _acfcad.Name.Local == "editData" {
			_bgacf, _efagg := _g.ParseBool(_acfcad.Value)
			if _efagg != nil {
				return _efagg
			}
			_edaab.EditDataAttr = &_bgacf
			continue
		}
		if _acfcad.Name.Local == "outline" {
			_geabg, _dbfeeb := _g.ParseBool(_acfcad.Value)
			if _dbfeeb != nil {
				return _dbfeeb
			}
			_edaab.OutlineAttr = &_geabg
			continue
		}
		if _acfcad.Name.Local == "showCalcMbrs" {
			_bfceea, _ceafd := _g.ParseBool(_acfcad.Value)
			if _ceafd != nil {
				return _ceafd
			}
			_edaab.ShowCalcMbrsAttr = &_bfceea
			continue
		}
		if _acfcad.Name.Local == "outlineData" {
			_cbgdba, _gceeaf := _g.ParseBool(_acfcad.Value)
			if _gceeaf != nil {
				return _gceeaf
			}
			_edaab.OutlineDataAttr = &_cbgdba
			continue
		}
		if _acfcad.Name.Local == "gridDropZones" {
			_eefggb, _bcbdd := _g.ParseBool(_acfcad.Value)
			if _bcbdd != nil {
				return _bcbdd
			}
			_edaab.GridDropZonesAttr = &_eefggb
			continue
		}
		if _acfcad.Name.Local == "customListSort" {
			_bbfaf, _gffadd := _g.ParseBool(_acfcad.Value)
			if _gffadd != nil {
				return _gffadd
			}
			_edaab.CustomListSortAttr = &_bbfaf
			continue
		}
		if _acfcad.Name.Local == "rowGrandTotals" {
			_begacg, _adfgae := _g.ParseBool(_acfcad.Value)
			if _adfgae != nil {
				return _adfgae
			}
			_edaab.RowGrandTotalsAttr = &_begacg
			continue
		}
		if _acfcad.Name.Local == "applyWidthHeightFormats" {
			_adbag, _cdeed := _g.ParseBool(_acfcad.Value)
			if _cdeed != nil {
				return _cdeed
			}
			_edaab.ApplyWidthHeightFormatsAttr = &_adbag
			continue
		}
		if _acfcad.Name.Local == "useAutoFormatting" {
			_ceabff, _dbbdcf := _g.ParseBool(_acfcad.Value)
			if _dbbdcf != nil {
				return _dbbdcf
			}
			_edaab.UseAutoFormattingAttr = &_ceabff
			continue
		}
		if _acfcad.Name.Local == "rowHeaderCaption" {
			_gdgfdd, _dgbbd := _acfcad.Value, error(nil)
			if _dgbbd != nil {
				return _dgbbd
			}
			_edaab.RowHeaderCaptionAttr = &_gdgfdd
			continue
		}
		if _acfcad.Name.Local == "showDrill" {
			_eccfa, _gfcgd := _g.ParseBool(_acfcad.Value)
			if _gfcgd != nil {
				return _gfcgd
			}
			_edaab.ShowDrillAttr = &_eccfa
			continue
		}
		if _acfcad.Name.Local == "mergeItem" {
			_abgad, _aacfg := _g.ParseBool(_acfcad.Value)
			if _aacfg != nil {
				return _aacfg
			}
			_edaab.MergeItemAttr = &_abgad
			continue
		}
		if _acfcad.Name.Local == "applyBorderFormats" {
			_baffa, _gcfeda := _g.ParseBool(_acfcad.Value)
			if _gcfeda != nil {
				return _gcfeda
			}
			_edaab.ApplyBorderFormatsAttr = &_baffa
			continue
		}
		if _acfcad.Name.Local == "visualTotals" {
			_gcbcd, _fccgc := _g.ParseBool(_acfcad.Value)
			if _fccgc != nil {
				return _fccgc
			}
			_edaab.VisualTotalsAttr = &_gcbcd
			continue
		}
		if _acfcad.Name.Local == "compactData" {
			_ffgfd, _gcadfc := _g.ParseBool(_acfcad.Value)
			if _gcadfc != nil {
				return _gcadfc
			}
			_edaab.CompactDataAttr = &_ffgfd
			continue
		}
		if _acfcad.Name.Local == "dataPosition" {
			_cfafcc, _ebebeb := _g.ParseUint(_acfcad.Value, 10, 32)
			if _ebebeb != nil {
				return _ebebeb
			}
			_fddge := uint32(_cfafcc)
			_edaab.DataPositionAttr = &_fddge
			continue
		}
		if _acfcad.Name.Local == "multipleFieldFilters" {
			_cabddf, _ggace := _g.ParseBool(_acfcad.Value)
			if _ggace != nil {
				return _ggace
			}
			_edaab.MultipleFieldFiltersAttr = &_cabddf
			continue
		}
		if _acfcad.Name.Local == "pageOverThenDown" {
			_fcggc, _ggaeb := _g.ParseBool(_acfcad.Value)
			if _ggaeb != nil {
				return _ggaeb
			}
			_edaab.PageOverThenDownAttr = &_fcggc
			continue
		}
		if _acfcad.Name.Local == "fieldListSortAscending" {
			_cfgde, _dbegf := _g.ParseBool(_acfcad.Value)
			if _dbegf != nil {
				return _dbegf
			}
			_edaab.FieldListSortAscendingAttr = &_cfgde
			continue
		}
		if _acfcad.Name.Local == "showMissing" {
			_aggdd, _adefbc := _g.ParseBool(_acfcad.Value)
			if _adefbc != nil {
				return _adefbc
			}
			_edaab.ShowMissingAttr = &_aggdd
			continue
		}
		if _acfcad.Name.Local == "fieldPrintTitles" {
			_fdacagg, _dedgae := _g.ParseBool(_acfcad.Value)
			if _dedgae != nil {
				return _dedgae
			}
			_edaab.FieldPrintTitlesAttr = &_fdacagg
			continue
		}
		if _acfcad.Name.Local == "showMemberPropertyTips" {
			_dgegfd, _cgafad := _g.ParseBool(_acfcad.Value)
			if _cgafad != nil {
				return _cgafad
			}
			_edaab.ShowMemberPropertyTipsAttr = &_dgegfd
			continue
		}
		if _acfcad.Name.Local == "pageStyle" {
			_adceda, _dfgf := _acfcad.Value, error(nil)
			if _dfgf != nil {
				return _dfgf
			}
			_edaab.PageStyleAttr = &_adceda
			continue
		}
		if _acfcad.Name.Local == "autoFormatId" {
			_dbaafe, _cfbba := _g.ParseUint(_acfcad.Value, 10, 32)
			if _cfbba != nil {
				return _cfbba
			}
			_daebag := uint32(_dbaafe)
			_edaab.AutoFormatIdAttr = &_daebag
			continue
		}
		if _acfcad.Name.Local == "showItems" {
			_cfgac, _edegad := _g.ParseBool(_acfcad.Value)
			if _edegad != nil {
				return _edegad
			}
			_edaab.ShowItemsAttr = &_cfgac
			continue
		}
		if _acfcad.Name.Local == "applyPatternFormats" {
			_adbcb, _agabe := _g.ParseBool(_acfcad.Value)
			if _agabe != nil {
				return _agabe
			}
			_edaab.ApplyPatternFormatsAttr = &_adbcb
			continue
		}
		if _acfcad.Name.Local == "enableFieldProperties" {
			_gcacd, _bgaceb := _g.ParseBool(_acfcad.Value)
			if _bgaceb != nil {
				return _bgaceb
			}
			_edaab.EnableFieldPropertiesAttr = &_gcacd
			continue
		}
		if _acfcad.Name.Local == "showMultipleLabel" {
			_bfgfa, _dabdc := _g.ParseBool(_acfcad.Value)
			if _dabdc != nil {
				return _dabdc
			}
			_edaab.ShowMultipleLabelAttr = &_bfgfa
			continue
		}
		if _acfcad.Name.Local == "preserveFormatting" {
			_egbag, _gaabbe := _g.ParseBool(_acfcad.Value)
			if _gaabbe != nil {
				return _gaabbe
			}
			_edaab.PreserveFormattingAttr = &_egbag
			continue
		}
		if _acfcad.Name.Local == "published" {
			_dcgfec, _fbedb := _g.ParseBool(_acfcad.Value)
			if _fbedb != nil {
				return _fbedb
			}
			_edaab.PublishedAttr = &_dcgfec
			continue
		}
		if _acfcad.Name.Local == "missingCaption" {
			_gefbgg, _eagbd := _acfcad.Value, error(nil)
			if _eagbd != nil {
				return _eagbd
			}
			_edaab.MissingCaptionAttr = &_gefbgg
			continue
		}
		if _acfcad.Name.Local == "immersive" {
			_cbaad, _dgdbf := _g.ParseBool(_acfcad.Value)
			if _dgdbf != nil {
				return _dgdbf
			}
			_edaab.ImmersiveAttr = &_cbaad
			continue
		}
		if _acfcad.Name.Local == "pageWrap" {
			_dgbccgg, _ceeffg := _g.ParseUint(_acfcad.Value, 10, 32)
			if _ceeffg != nil {
				return _ceeffg
			}
			_gaagf := uint32(_dgbccgg)
			_edaab.PageWrapAttr = &_gaagf
			continue
		}
		if _acfcad.Name.Local == "chartFormat" {
			_efga, _afefg := _g.ParseUint(_acfcad.Value, 10, 32)
			if _afefg != nil {
				return _afefg
			}
			_egfca := uint32(_efga)
			_edaab.ChartFormatAttr = &_egfca
			continue
		}
		if _acfcad.Name.Local == "showDataDropDown" {
			_agbegd, _gcfbc := _g.ParseBool(_acfcad.Value)
			if _gcfbc != nil {
				return _gcfbc
			}
			_edaab.ShowDataDropDownAttr = &_agbegd
			continue
		}
		if _acfcad.Name.Local == "colHeaderCaption" {
			_fdagd, _eaegeb := _acfcad.Value, error(nil)
			if _eaegeb != nil {
				return _eaegeb
			}
			_edaab.ColHeaderCaptionAttr = &_fdagd
			continue
		}
		if _acfcad.Name.Local == "subtotalHiddenItems" {
			_fgfcg, _edeba := _g.ParseBool(_acfcad.Value)
			if _edeba != nil {
				return _edeba
			}
			_edaab.SubtotalHiddenItemsAttr = &_fgfcg
			continue
		}
		if _acfcad.Name.Local == "mdxSubqueries" {
			_dfdbag, _gbdgdc := _g.ParseBool(_acfcad.Value)
			if _gbdgdc != nil {
				return _gbdgdc
			}
			_edaab.MdxSubqueriesAttr = &_dfdbag
			continue
		}
		if _acfcad.Name.Local == "errorCaption" {
			_dgfea, _cfdbc := _acfcad.Value, error(nil)
			if _cfdbc != nil {
				return _cfdbc
			}
			_edaab.ErrorCaptionAttr = &_dgfea
			continue
		}
		if _acfcad.Name.Local == "colGrandTotals" {
			_eeddff, _dcadc := _g.ParseBool(_acfcad.Value)
			if _dcadc != nil {
				return _dcadc
			}
			_edaab.ColGrandTotalsAttr = &_eeddff
			continue
		}
		if _acfcad.Name.Local == "printDrill" {
			_gcagf, _eacdd := _g.ParseBool(_acfcad.Value)
			if _eacdd != nil {
				return _eacdd
			}
			_edaab.PrintDrillAttr = &_gcagf
			continue
		}
		if _acfcad.Name.Local == "itemPrintTitles" {
			_cddafb, _gfbdae := _g.ParseBool(_acfcad.Value)
			if _gfbdae != nil {
				return _gfbdae
			}
			_edaab.ItemPrintTitlesAttr = &_cddafb
			continue
		}
		if _acfcad.Name.Local == "name" {
			_eaccf, _gdbaf := _acfcad.Value, error(nil)
			if _gdbaf != nil {
				return _gdbaf
			}
			_edaab.NameAttr = _eaccf
			continue
		}
		if _acfcad.Name.Local == "showDropZones" {
			_gcbgdc, _dfcdc := _g.ParseBool(_acfcad.Value)
			if _dfcdc != nil {
				return _dfcdc
			}
			_edaab.ShowDropZonesAttr = &_gcbgdc
			continue
		}
		if _acfcad.Name.Local == "showDataTips" {
			_beaee, _ebagca := _g.ParseBool(_acfcad.Value)
			if _ebagca != nil {
				return _ebagca
			}
			_edaab.ShowDataTipsAttr = &_beaee
			continue
		}
		if _acfcad.Name.Local == "vacatedStyle" {
			_aaebf, _bfcfg := _acfcad.Value, error(nil)
			if _bfcfg != nil {
				return _bfcfg
			}
			_edaab.VacatedStyleAttr = &_aaebf
			continue
		}
		if _acfcad.Name.Local == "grandTotalCaption" {
			_aedfc, _cgffge := _acfcad.Value, error(nil)
			if _cgffge != nil {
				return _cgffge
			}
			_edaab.GrandTotalCaptionAttr = &_aedfc
			continue
		}
		if _acfcad.Name.Local == "applyNumberFormats" {
			_ffgfgc, _bdbfdd := _g.ParseBool(_acfcad.Value)
			if _bdbfdd != nil {
				return _bdbfdd
			}
			_edaab.ApplyNumberFormatsAttr = &_ffgfgc
			continue
		}
		if _acfcad.Name.Local == "enableDrill" {
			_cdedbe, _abege := _g.ParseBool(_acfcad.Value)
			if _abege != nil {
				return _abege
			}
			_edaab.EnableDrillAttr = &_cdedbe
			continue
		}
		if _acfcad.Name.Local == "applyFontFormats" {
			_cgfecc, _cggefc := _g.ParseBool(_acfcad.Value)
			if _cggefc != nil {
				return _cggefc
			}
			_edaab.ApplyFontFormatsAttr = &_cgfecc
			continue
		}
		if _acfcad.Name.Local == "disableFieldList" {
			_cceeda, _bgdgc := _g.ParseBool(_acfcad.Value)
			if _bgdgc != nil {
				return _bgdgc
			}
			_edaab.DisableFieldListAttr = &_cceeda
			continue
		}
		if _acfcad.Name.Local == "applyAlignmentFormats" {
			_faecgf, _fgece := _g.ParseBool(_acfcad.Value)
			if _fgece != nil {
				return _fgece
			}
			_edaab.ApplyAlignmentFormatsAttr = &_faecgf
			continue
		}
		if _acfcad.Name.Local == "dataOnRows" {
			_ecfff, _bgbda := _g.ParseBool(_acfcad.Value)
			if _bgbda != nil {
				return _bgbda
			}
			_edaab.DataOnRowsAttr = &_ecfff
			continue
		}
		if _acfcad.Name.Local == "dataCaption" {
			_edbefb, _fbdbe := _acfcad.Value, error(nil)
			if _fbdbe != nil {
				return _fbdbe
			}
			_edaab.DataCaptionAttr = _edbefb
			continue
		}
		if _acfcad.Name.Local == "showError" {
			_eeccb, _afebca := _g.ParseBool(_acfcad.Value)
			if _afebca != nil {
				return _afebca
			}
			_edaab.ShowErrorAttr = &_eeccb
			continue
		}
		if _acfcad.Name.Local == "cacheId" {
			_abfbd, _ebefbc := _g.ParseUint(_acfcad.Value, 10, 32)
			if _ebefbc != nil {
				return _ebefbc
			}
			_edaab.CacheIdAttr = uint32(_abfbd)
			continue
		}
		if _acfcad.Name.Local == "enableWizard" {
			_cgaeg, _cdcfeb := _g.ParseBool(_acfcad.Value)
			if _cdcfeb != nil {
				return _cdcfeb
			}
			_edaab.EnableWizardAttr = &_cgaeg
			continue
		}
		if _acfcad.Name.Local == "updatedVersion" {
			_gaadd, _edecb := _g.ParseUint(_acfcad.Value, 10, 8)
			if _edecb != nil {
				return _edecb
			}
			_cegfd := uint8(_gaadd)
			_edaab.UpdatedVersionAttr = &_cegfd
			continue
		}
	}
_eggdgba:
	for {
		_eaadec, _egbdgd := d.Token()
		if _egbdgd != nil {
			return _egbdgd
		}
		switch _cagda := _eaadec.(type) {
		case _f.StartElement:
			switch _cagda.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "location"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "location"}:
				if _ebecc := d.DecodeElement(_edaab.Location, &_cagda); _ebecc != nil {
					return _ebecc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotFields"}:
				_edaab.PivotFields = NewCT_PivotFields()
				if _gbfcc := d.DecodeElement(_edaab.PivotFields, &_cagda); _gbfcc != nil {
					return _gbfcc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rowFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rowFields"}:
				_edaab.RowFields = NewCT_RowFields()
				if _fgadc := d.DecodeElement(_edaab.RowFields, &_cagda); _fgadc != nil {
					return _fgadc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rowItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rowItems"}:
				_edaab.RowItems = NewCT_rowItems()
				if _fddfd := d.DecodeElement(_edaab.RowItems, &_cagda); _fddfd != nil {
					return _fddfd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colFields"}:
				_edaab.ColFields = NewCT_ColFields()
				if _abdaac := d.DecodeElement(_edaab.ColFields, &_cagda); _abdaac != nil {
					return _abdaac
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colItems"}:
				_edaab.ColItems = NewCT_colItems()
				if _baecfe := d.DecodeElement(_edaab.ColItems, &_cagda); _baecfe != nil {
					return _baecfe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageFields"}:
				_edaab.PageFields = NewCT_PageFields()
				if _gccdd := d.DecodeElement(_edaab.PageFields, &_cagda); _gccdd != nil {
					return _gccdd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataFields"}:
				_edaab.DataFields = NewCT_DataFields()
				if _gaegg := d.DecodeElement(_edaab.DataFields, &_cagda); _gaegg != nil {
					return _gaegg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "formats"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "formats"}:
				_edaab.Formats = NewCT_Formats()
				if _fceaaa := d.DecodeElement(_edaab.Formats, &_cagda); _fceaaa != nil {
					return _fceaaa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "conditionalFormats"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "conditionalFormats"}:
				_edaab.ConditionalFormats = NewCT_ConditionalFormats()
				if _aggagd := d.DecodeElement(_edaab.ConditionalFormats, &_cagda); _aggagd != nil {
					return _aggagd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "chartFormats"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "chartFormats"}:
				_edaab.ChartFormats = NewCT_ChartFormats()
				if _abccc := d.DecodeElement(_edaab.ChartFormats, &_cagda); _abccc != nil {
					return _abccc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotHierarchies"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotHierarchies"}:
				_edaab.PivotHierarchies = NewCT_PivotHierarchies()
				if _cbffc := d.DecodeElement(_edaab.PivotHierarchies, &_cagda); _cbffc != nil {
					return _cbffc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotTableStyleInfo"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotTableStyleInfo"}:
				_edaab.PivotTableStyleInfo = NewCT_PivotTableStyle()
				if _eceea := d.DecodeElement(_edaab.PivotTableStyleInfo, &_cagda); _eceea != nil {
					return _eceea
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "filters"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "filters"}:
				_edaab.Filters = NewCT_PivotFilters()
				if _aecga := d.DecodeElement(_edaab.Filters, &_cagda); _aecga != nil {
					return _aecga
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rowHierarchiesUsage"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rowHierarchiesUsage"}:
				_edaab.RowHierarchiesUsage = NewCT_RowHierarchiesUsage()
				if _gbaed := d.DecodeElement(_edaab.RowHierarchiesUsage, &_cagda); _gbaed != nil {
					return _gbaed
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colHierarchiesUsage"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colHierarchiesUsage"}:
				_edaab.ColHierarchiesUsage = NewCT_ColHierarchiesUsage()
				if _dfgde := d.DecodeElement(_edaab.ColHierarchiesUsage, &_cagda); _dfgde != nil {
					return _dfgde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_edaab.ExtLst = NewCT_ExtensionList()
				if _gbecf := d.DecodeElement(_edaab.ExtLst, &_cagda); _gbecf != nil {
					return _gbecf
				}
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_pivotTableDefinition \u0025v", _cagda.Name)
				if _fbbdb := d.Skip(); _fbbdb != nil {
					return _fbbdb
				}
			}
		case _f.EndElement:
			break _eggdgba
		case _f.CharData:
		}
	}
	return nil
}
func (_deafg ST_CellSpans) String() string { return _fd.Join(_deafg, "\u0020") }

type CT_colItems struct {

	// Column Item Count
	CountAttr *uint32

	// Column Items
	I []*CT_I
}

// ValidateWithPath validates the SingleXmlCells and its children, prefixing error messages with path
func (_bcgdce *SingleXmlCells) ValidateWithPath(path string) error {
	if _egfee := _bcgdce.CT_SingleXmlCells.ValidateWithPath(path); _egfee != nil {
		return _egfee
	}
	return nil
}

// ValidateWithPath validates the CT_Parameters and its children, prefixing error messages with path
func (_ffbge *CT_Parameters) ValidateWithPath(path string) error {
	for _abedd, _agbeg := range _ffbge.Parameter {
		if _cfgcd := _agbeg.ValidateWithPath(_bg.Sprintf("\u0025s/Parameter\u005b\u0025d\u005d", path, _abedd)); _cfgcd != nil {
			return _cfgcd
		}
	}
	return nil
}

type CT_OleObject struct {

	// Embedded Object ProgId
	ProgIdAttr *string

	// Data or View Aspect
	DvAspectAttr ST_DvAspect

	// Embedded Object's Link Moniker
	LinkAttr *string

	// Linked Embedded Object Update
	OleUpdateAttr ST_OleUpdate

	// Auto Load
	AutoLoadAttr *bool

	// Shape Id
	ShapeIdAttr uint32
	IdAttr      *string

	// Embedded Object Properties
	ObjectPr *CT_ObjectPr
}

func (_ggbd *CT_MRUColors) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_bfffg := _f.StartElement{Name: _f.Name{Local: "ma:color"}}
	for _, _dgeab := range _ggbd.Color {
		e.EncodeElement(_dgeab, _bfffg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_aafce *CT_PageSetUpPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aafce.AutoPageBreaksAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoPageBreaks"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aafce.AutoPageBreaksAttr))})
	}
	if _aafce.FitToPageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fitToPage"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aafce.FitToPageAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_CalculatedMembers struct {

	// Calculated Members Count
	CountAttr *uint32

	// Calculated Member
	CalculatedMember []*CT_CalculatedMember
}
type CT_RevisionHeader struct {

	// GUID
	GuidAttr string

	// Date Time
	DateTimeAttr _b.Time

	// Last Sheet Id
	MaxSheetIdAttr uint32

	// User Name
	UserNameAttr string
	IdAttr       string

	// Minimum Revision Id
	MinRIdAttr *uint32

	// Max Revision Id
	MaxRIdAttr *uint32

	// Sheet Id Map
	SheetIdMap *CT_SheetIdMap

	// Reviewed List
	ReviewedList *CT_ReviewedRevisions
	ExtLst       *CT_ExtensionList
}

func (_ddfcb ST_DdeValueType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_ddfcb.String(), start)
}
func (_bfeff *CT_Sst) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ccedc := range start.Attr {
		if _ccedc.Name.Local == "count" {
			_fcbfc, _bddedb := _g.ParseUint(_ccedc.Value, 10, 32)
			if _bddedb != nil {
				return _bddedb
			}
			_gdcegg := uint32(_fcbfc)
			_bfeff.CountAttr = &_gdcegg
			continue
		}
		if _ccedc.Name.Local == "uniqueCount" {
			_afeac, _edegd := _g.ParseUint(_ccedc.Value, 10, 32)
			if _edegd != nil {
				return _edegd
			}
			_ccgga := uint32(_afeac)
			_bfeff.UniqueCountAttr = &_ccgga
			continue
		}
	}
_cbbdaf:
	for {
		_cbbfe, _bfaed := d.Token()
		if _bfaed != nil {
			return _bfaed
		}
		switch _fffae := _cbbfe.(type) {
		case _f.StartElement:
			switch _fffae.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "si"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "si"}:
				_bafaab := NewCT_Rst()
				if _gaaga := d.DecodeElement(_bafaab, &_fffae); _gaaga != nil {
					return _gaaga
				}
				_bfeff.Si = append(_bfeff.Si, _bafaab)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bfeff.ExtLst = NewCT_ExtensionList()
				if _ccgbd := d.DecodeElement(_bfeff.ExtLst, &_fffae); _ccgbd != nil {
					return _ccgbd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Sst\u0020\u0025v", _fffae.Name)
				if _fddcd := d.Skip(); _fddcd != nil {
					return _fddcd
				}
			}
		case _f.EndElement:
			break _cbbdaf
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CustomProperty and its children, prefixing error messages with path
func (_dbdgg *CT_CustomProperty) ValidateWithPath(path string) error { return nil }

type CT_OlapPr struct {

	// Local Cube
	LocalAttr *bool

	// Local Cube Connection
	LocalConnectionAttr *string

	// Local Refresh
	LocalRefreshAttr *bool

	// Send Locale to OLAP
	SendLocaleAttr *bool

	// Drill Through Count
	RowDrillCountAttr *uint32

	// OLAP Fill Formatting
	ServerFillAttr *bool

	// OLAP Number Format
	ServerNumberFormatAttr *bool

	// OLAP Server Font
	ServerFontAttr *bool

	// OLAP Font Formatting
	ServerFontColorAttr *bool
}

func (_cdabbga *ST_RevisionAction) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_cdabbga = 0
	case "add":
		*_cdabbga = 1
	case "delete":
		*_cdabbga = 2
	}
	return nil
}

// ValidateWithPath validates the CT_WorkbookProtection and its children, prefixing error messages with path
func (_bcaabc *CT_WorkbookProtection) ValidateWithPath(path string) error { return nil }
func (_gee *CT_CellAlignment) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cbbg := range start.Attr {
		if _cbbg.Name.Local == "horizontal" {
			_gee.HorizontalAttr.UnmarshalXMLAttr(_cbbg)
			continue
		}
		if _cbbg.Name.Local == "vertical" {
			_gee.VerticalAttr.UnmarshalXMLAttr(_cbbg)
			continue
		}
		if _cbbg.Name.Local == "textRotation" {
			_cfd, _gbcda := _g.ParseUint(_cbbg.Value, 10, 8)
			if _gbcda != nil {
				return _gbcda
			}
			_beb := uint8(_cfd)
			_gee.TextRotationAttr = &_beb
			continue
		}
		if _cbbg.Name.Local == "wrapText" {
			_adag, _fdca := _g.ParseBool(_cbbg.Value)
			if _fdca != nil {
				return _fdca
			}
			_gee.WrapTextAttr = &_adag
			continue
		}
		if _cbbg.Name.Local == "indent" {
			_cbad, _bfda := _g.ParseUint(_cbbg.Value, 10, 32)
			if _bfda != nil {
				return _bfda
			}
			_bbeg := uint32(_cbad)
			_gee.IndentAttr = &_bbeg
			continue
		}
		if _cbbg.Name.Local == "relativeIndent" {
			_fcgae, _feed := _g.ParseInt(_cbbg.Value, 10, 32)
			if _feed != nil {
				return _feed
			}
			_bdea := int32(_fcgae)
			_gee.RelativeIndentAttr = &_bdea
			continue
		}
		if _cbbg.Name.Local == "justifyLastLine" {
			_gfd, _bebc := _g.ParseBool(_cbbg.Value)
			if _bebc != nil {
				return _bebc
			}
			_gee.JustifyLastLineAttr = &_gfd
			continue
		}
		if _cbbg.Name.Local == "shrinkToFit" {
			_ffgc, _dgea := _g.ParseBool(_cbbg.Value)
			if _dgea != nil {
				return _dgea
			}
			_gee.ShrinkToFitAttr = &_ffgc
			continue
		}
		if _cbbg.Name.Local == "readingOrder" {
			_bbab, _fgf := _g.ParseUint(_cbbg.Value, 10, 32)
			if _fgf != nil {
				return _fgf
			}
			_fccd := uint32(_bbab)
			_gee.ReadingOrderAttr = &_fccd
			continue
		}
	}
	for {
		_ccg, _ccea := d.Token()
		if _ccea != nil {
			return _bg.Errorf("parsing\u0020CT_CellAlignment: \u0025s", _ccea)
		}
		if _efe, _gdbfd := _ccg.(_f.EndElement); _gdbfd && _efe.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Col and its children, prefixing error messages with path
func (_caefg *CT_Col) ValidateWithPath(path string) error { return nil }
func (_cgaff *ST_HtmlFmt) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_febdf, _bcecg := d.Token()
	if _bcecg != nil {
		return _bcecg
	}
	if _agdd, _egabcf := _febdf.(_f.EndElement); _egabcf && _agdd.Name == start.Name {
		*_cgaff = 1
		return nil
	}
	if _geefb, _fdeea := _febdf.(_f.CharData); !_fdeea {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _febdf)
	} else {
		switch string(_geefb) {
		case "":
			*_cgaff = 0
		case "none":
			*_cgaff = 1
		case "rtf":
			*_cgaff = 2
		case "all":
			*_cgaff = 3
		}
	}
	_febdf, _bcecg = d.Token()
	if _bcecg != nil {
		return _bcecg
	}
	if _cfbaa, _edbfd := _febdf.(_f.EndElement); _edbfd && _cfbaa.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _febdf)
}

// ValidateWithPath validates the CT_FileVersion and its children, prefixing error messages with path
func (_ceda *CT_FileVersion) ValidateWithPath(path string) error {
	if _ceda.CodeNameAttr != nil {
		if !_e.ST_GuidPatternRe.MatchString(*_ceda.CodeNameAttr) {
			return _bg.Errorf("\u0025s\u002fm\u002eCodeNameAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_GuidPatternRe, *_ceda.CodeNameAttr)
		}
	}
	return nil
}
func NewCT_CommentPr() *CT_CommentPr {
	_efeb := &CT_CommentPr{}
	_efeb.Anchor = NewCT_ObjectAnchor()
	return _efeb
}

type CT_PivotDimension struct {

	// Measure
	MeasureAttr *bool

	// Dimension Name
	NameAttr string

	// Dimension Unique Name
	UniqueNameAttr string

	// Dimension Display Name
	CaptionAttr string
}

func (_cbecd ST_TextVAlign) Validate() error { return _cbecd.ValidateWithPath("") }
func (_dbega ST_DataValidationOperator) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_dbega.String(), start)
}

// Validate validates the Headers and its children
func (_acfabg *Headers) Validate() error { return _acfabg.ValidateWithPath("Headers") }
func (_cfeaaff *ST_UpdateLinks) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_cfeaaff = 0
	case "userSet":
		*_cfeaaff = 1
	case "never":
		*_cfeaaff = 2
	case "always":
		*_cfeaaff = 3
	}
	return nil
}

// ValidateWithPath validates the CT_FieldsUsage and its children, prefixing error messages with path
func (_begb *CT_FieldsUsage) ValidateWithPath(path string) error {
	for _bebef, _gefe := range _begb.FieldUsage {
		if _fggbg := _gefe.ValidateWithPath(_bg.Sprintf("\u0025s\u002fFieldUsage\u005b\u0025d\u005d", path, _bebef)); _fggbg != nil {
			return _fggbg
		}
	}
	return nil
}

// Validate validates the Users and its children
func (_beeaa *Users) Validate() error { return _beeaa.ValidateWithPath("Users") }
func (_ggcddf ST_CredMethod) String() string {
	switch _ggcddf {
	case 0:
		return ""
	case 1:
		return "integrated"
	case 2:
		return "none"
	case 3:
		return "stored"
	case 4:
		return "prompt"
	}
	return ""
}
func (_cbfcde *CT_SmartTagPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fcdde := range start.Attr {
		if _fcdde.Name.Local == "embed" {
			_dfddb, _bcfda := _g.ParseBool(_fcdde.Value)
			if _bcfda != nil {
				return _bcfda
			}
			_cbfcde.EmbedAttr = &_dfddb
			continue
		}
		if _fcdde.Name.Local == "show" {
			_cbfcde.ShowAttr.UnmarshalXMLAttr(_fcdde)
			continue
		}
	}
	for {
		_bbgffe, _ecdfcca := d.Token()
		if _ecdfcca != nil {
			return _bg.Errorf("parsing\u0020CT_SmartTagPr:\u0020\u0025s", _ecdfcca)
		}
		if _edecff, _afcaa := _bbgffe.(_f.EndElement); _afcaa && _edecff.Name == start.Name {
			break
		}
	}
	return nil
}
func (_beadbb ST_HtmlFmt) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_aaddf := _f.Attr{}
	_aaddf.Name = name
	switch _beadbb {
	case ST_HtmlFmtUnset:
		_aaddf.Value = ""
	case ST_HtmlFmtNone:
		_aaddf.Value = "none"
	case ST_HtmlFmtRtf:
		_aaddf.Value = "rtf"
	case ST_HtmlFmtAll:
		_aaddf.Value = "all"
	}
	return _aaddf, nil
}

// ValidateWithPath validates the CT_Sst and its children, prefixing error messages with path
func (_aegdd *CT_Sst) ValidateWithPath(path string) error {
	for _dbbfc, _gdfccb := range _aegdd.Si {
		if _efdce := _gdfccb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fSi\u005b\u0025d]", path, _dbbfc)); _efdce != nil {
			return _efdce
		}
	}
	if _aegdd.ExtLst != nil {
		if _fdbbc := _aegdd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fdbbc != nil {
			return _fdbbc
		}
	}
	return nil
}
func NewCT_WebPublishing() *CT_WebPublishing { _gdbbe := &CT_WebPublishing{}; return _gdbbe }

type CT_String struct {

	// Value
	VAttr string

	// Unused Item
	UAttr *bool

	// Calculated Item
	FAttr *bool

	// Item Caption
	CAttr *string

	// Member Property Count
	CpAttr *uint32

	// Format Index
	InAttr *uint32

	// Background Color
	BcAttr *string

	// Foreground Color
	FcAttr *string

	// Italic
	IAttr *bool

	// Underline
	UnAttr *bool

	// Strikethrough
	StAttr *bool

	// Bold
	BAttr *bool

	// Tuples
	Tpls []*CT_Tuples

	// Member Property Index
	X []*CT_X
}

// ValidateWithPath validates the CT_XmlPr and its children, prefixing error messages with path
func (_caafe *CT_XmlPr) ValidateWithPath(path string) error {
	if _caafe.ExtLst != nil {
		if _ggadb := _caafe.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ggadb != nil {
			return _ggadb
		}
	}
	return nil
}

// Validate validates the CT_WebPublishing and its children
func (_fgbea *CT_WebPublishing) Validate() error { return _fgbea.ValidateWithPath("CT_WebPublishing") }
func (_fgdea *CT_DdeLink) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cead := range start.Attr {
		if _cead.Name.Local == "ddeService" {
			_eegc, _fcdec := _cead.Value, error(nil)
			if _fcdec != nil {
				return _fcdec
			}
			_fgdea.DdeServiceAttr = _eegc
			continue
		}
		if _cead.Name.Local == "ddeTopic" {
			_acfddg, _dfda := _cead.Value, error(nil)
			if _dfda != nil {
				return _dfda
			}
			_fgdea.DdeTopicAttr = _acfddg
			continue
		}
	}
_gfddg:
	for {
		_gcda, _fbacae := d.Token()
		if _fbacae != nil {
			return _fbacae
		}
		switch _decff := _gcda.(type) {
		case _f.StartElement:
			switch _decff.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ddeItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ddeItems"}:
				_fgdea.DdeItems = NewCT_DdeItems()
				if _daegf := d.DecodeElement(_fgdea.DdeItems, &_decff); _daegf != nil {
					return _daegf
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_DdeLink\u0020\u0025v", _decff.Name)
				if _ecadg := d.Skip(); _ecadg != nil {
					return _ecadg
				}
			}
		case _f.EndElement:
			break _gfddg
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SheetData and its children, prefixing error messages with path
func (_geddf *CT_SheetData) ValidateWithPath(path string) error {
	for _cbbda, _dcbab := range _geddf.Row {
		if _bdfdcb := _dcbab.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRow\u005b\u0025d\u005d", path, _cbbda)); _bdfdcb != nil {
			return _bdfdcb
		}
	}
	return nil
}

type Users struct{ CT_Users }

func (_cabdc ST_CellFormulaType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_cabdc.String(), start)
}

// Validate validates the CT_ChartFormats and its children
func (_gecf *CT_ChartFormats) Validate() error { return _gecf.ValidateWithPath("CT_ChartFormats") }
func (_beba *CT_Location) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _beba.RefAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "firstHeaderRow"}, Value: _bg.Sprintf("\u0025v", _beba.FirstHeaderRowAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "firstDataRow"}, Value: _bg.Sprintf("\u0025v", _beba.FirstDataRowAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "firstDataCol"}, Value: _bg.Sprintf("\u0025v", _beba.FirstDataColAttr)})
	if _beba.RowPageCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rowPageCount"}, Value: _bg.Sprintf("\u0025v", *_beba.RowPageCountAttr)})
	}
	if _beba.ColPageCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "colPageCount"}, Value: _bg.Sprintf("\u0025v", *_beba.ColPageCountAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cgeaf *CT_FunctionGroup) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cgeaf.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_cgeaf.NameAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cdc *CT_CalculatedMember) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dfdfd := range start.Attr {
		if _dfdfd.Name.Local == "name" {
			_gfea, _dcb := _dfdfd.Value, error(nil)
			if _dcb != nil {
				return _dcb
			}
			_cdc.NameAttr = _gfea
			continue
		}
		if _dfdfd.Name.Local == "mdx" {
			_ccfda, _cacb := _dfdfd.Value, error(nil)
			if _cacb != nil {
				return _cacb
			}
			_cdc.MdxAttr = _ccfda
			continue
		}
		if _dfdfd.Name.Local == "memberName" {
			_decdg, _faeg := _dfdfd.Value, error(nil)
			if _faeg != nil {
				return _faeg
			}
			_cdc.MemberNameAttr = &_decdg
			continue
		}
		if _dfdfd.Name.Local == "hierarchy" {
			_beea, _acfe := _dfdfd.Value, error(nil)
			if _acfe != nil {
				return _acfe
			}
			_cdc.HierarchyAttr = &_beea
			continue
		}
		if _dfdfd.Name.Local == "parent" {
			_baec, _adg := _dfdfd.Value, error(nil)
			if _adg != nil {
				return _adg
			}
			_cdc.ParentAttr = &_baec
			continue
		}
		if _dfdfd.Name.Local == "solveOrder" {
			_afeaa, _bed := _g.ParseInt(_dfdfd.Value, 10, 32)
			if _bed != nil {
				return _bed
			}
			_cbb := int32(_afeaa)
			_cdc.SolveOrderAttr = &_cbb
			continue
		}
		if _dfdfd.Name.Local == "set" {
			_cbdf, _adbd := _g.ParseBool(_dfdfd.Value)
			if _adbd != nil {
				return _adbd
			}
			_cdc.SetAttr = &_cbdf
			continue
		}
	}
_egdd:
	for {
		_cbba, _bgga := d.Token()
		if _bgga != nil {
			return _bgga
		}
		switch _gfba := _cbba.(type) {
		case _f.StartElement:
			switch _gfba.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_cdc.ExtLst = NewCT_ExtensionList()
				if _gfbae := d.DecodeElement(_cdc.ExtLst, &_gfba); _gfbae != nil {
					return _gfbae
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CalculatedMember\u0020\u0025v", _gfba.Name)
				if _bfgb := d.Skip(); _bfgb != nil {
					return _bfgb
				}
			}
		case _f.EndElement:
			break _egdd
		case _f.CharData:
		}
	}
	return nil
}
func (_gecbe *CT_Macrosheet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gecbe.SheetData = NewCT_SheetData()
_eccdaf:
	for {
		_aegca, _gbbaa := d.Token()
		if _gbbaa != nil {
			return _gbbaa
		}
		switch _acdgd := _aegca.(type) {
		case _f.StartElement:
			switch _acdgd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetPr"}:
				_gecbe.SheetPr = NewCT_SheetPr()
				if _gdaf := d.DecodeElement(_gecbe.SheetPr, &_acdgd); _gdaf != nil {
					return _gdaf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dimension"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dimension"}:
				_gecbe.Dimension = NewCT_SheetDimension()
				if _fcdef := d.DecodeElement(_gecbe.Dimension, &_acdgd); _fcdef != nil {
					return _fcdef
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetViews"}:
				_gecbe.SheetViews = NewCT_SheetViews()
				if _aeccb := d.DecodeElement(_gecbe.SheetViews, &_acdgd); _aeccb != nil {
					return _aeccb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetFormatPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetFormatPr"}:
				_gecbe.SheetFormatPr = NewCT_SheetFormatPr()
				if _gaagb := d.DecodeElement(_gecbe.SheetFormatPr, &_acdgd); _gaagb != nil {
					return _gaagb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cols"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cols"}:
				_bedc := NewCT_Cols()
				if _dggfa := d.DecodeElement(_bedc, &_acdgd); _dggfa != nil {
					return _dggfa
				}
				_gecbe.Cols = append(_gecbe.Cols, _bedc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetData"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetData"}:
				if _cfcee := d.DecodeElement(_gecbe.SheetData, &_acdgd); _cfcee != nil {
					return _cfcee
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetProtection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetProtection"}:
				_gecbe.SheetProtection = NewCT_SheetProtection()
				if _bfcga := d.DecodeElement(_gecbe.SheetProtection, &_acdgd); _bfcga != nil {
					return _bfcga
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "autoFilter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "autoFilter"}:
				_gecbe.AutoFilter = NewCT_AutoFilter()
				if _dgdea := d.DecodeElement(_gecbe.AutoFilter, &_acdgd); _dgdea != nil {
					return _dgdea
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sortState"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sortState"}:
				_gecbe.SortState = NewCT_SortState()
				if _bgcdde := d.DecodeElement(_gecbe.SortState, &_acdgd); _bgcdde != nil {
					return _bgcdde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataConsolidate"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataConsolidate"}:
				_gecbe.DataConsolidate = NewCT_DataConsolidate()
				if _eaddc := d.DecodeElement(_gecbe.DataConsolidate, &_acdgd); _eaddc != nil {
					return _eaddc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customSheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customSheetViews"}:
				_gecbe.CustomSheetViews = NewCT_CustomSheetViews()
				if _fcgdd := d.DecodeElement(_gecbe.CustomSheetViews, &_acdgd); _fcgdd != nil {
					return _fcgdd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "phoneticPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "phoneticPr"}:
				_gecbe.PhoneticPr = NewCT_PhoneticPr()
				if _efgea := d.DecodeElement(_gecbe.PhoneticPr, &_acdgd); _efgea != nil {
					return _efgea
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "conditionalFormatting"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "conditionalFormatting"}:
				_cfdgg := NewCT_ConditionalFormatting()
				if _gadcg := d.DecodeElement(_cfdgg, &_acdgd); _gadcg != nil {
					return _gadcg
				}
				_gecbe.ConditionalFormatting = append(_gecbe.ConditionalFormatting, _cfdgg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "printOptions"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "printOptions"}:
				_gecbe.PrintOptions = NewCT_PrintOptions()
				if _egff := d.DecodeElement(_gecbe.PrintOptions, &_acdgd); _egff != nil {
					return _egff
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageMargins"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageMargins"}:
				_gecbe.PageMargins = NewCT_PageMargins()
				if _eddeb := d.DecodeElement(_gecbe.PageMargins, &_acdgd); _eddeb != nil {
					return _eddeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageSetup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageSetup"}:
				_gecbe.PageSetup = NewCT_PageSetup()
				if _cddfaf := d.DecodeElement(_gecbe.PageSetup, &_acdgd); _cddfaf != nil {
					return _cddfaf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "headerFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "headerFooter"}:
				_gecbe.HeaderFooter = NewCT_HeaderFooter()
				if _geba := d.DecodeElement(_gecbe.HeaderFooter, &_acdgd); _geba != nil {
					return _geba
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rowBreaks"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rowBreaks"}:
				_gecbe.RowBreaks = NewCT_PageBreak()
				if _dbgbcf := d.DecodeElement(_gecbe.RowBreaks, &_acdgd); _dbgbcf != nil {
					return _dbgbcf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colBreaks"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colBreaks"}:
				_gecbe.ColBreaks = NewCT_PageBreak()
				if _faceg := d.DecodeElement(_gecbe.ColBreaks, &_acdgd); _faceg != nil {
					return _faceg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customProperties"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customProperties"}:
				_gecbe.CustomProperties = NewCT_CustomProperties()
				if _dgfbe := d.DecodeElement(_gecbe.CustomProperties, &_acdgd); _dgfbe != nil {
					return _dgfbe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawing"}:
				_gecbe.Drawing = NewCT_Drawing()
				if _cfcad := d.DecodeElement(_gecbe.Drawing, &_acdgd); _cfcad != nil {
					return _cfcad
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawing"}:
				_gecbe.LegacyDrawing = NewCT_LegacyDrawing()
				if _agcae := d.DecodeElement(_gecbe.LegacyDrawing, &_acdgd); _agcae != nil {
					return _agcae
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawingHF"}:
				_gecbe.LegacyDrawingHF = NewCT_LegacyDrawing()
				if _efgdd := d.DecodeElement(_gecbe.LegacyDrawingHF, &_acdgd); _efgdd != nil {
					return _efgdd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawingHF"}:
				_gecbe.DrawingHF = NewCT_DrawingHF()
				if _ddgd := d.DecodeElement(_gecbe.DrawingHF, &_acdgd); _ddgd != nil {
					return _ddgd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "picture"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "picture"}:
				_gecbe.Picture = NewCT_SheetBackgroundPicture()
				if _ccbbd := d.DecodeElement(_gecbe.Picture, &_acdgd); _ccbbd != nil {
					return _ccbbd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleObjects"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleObjects"}:
				_gecbe.OleObjects = NewCT_OleObjects()
				if _eaaaa := d.DecodeElement(_gecbe.OleObjects, &_acdgd); _eaaaa != nil {
					return _eaaaa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gecbe.ExtLst = NewCT_ExtensionList()
				if _ffbfd := d.DecodeElement(_gecbe.ExtLst, &_acdgd); _ffbfd != nil {
					return _ffbfd
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_Macrosheet \u0025v", _acdgd.Name)
				if _addd := d.Skip(); _addd != nil {
					return _addd
				}
			}
		case _f.EndElement:
			break _eccdaf
		case _f.CharData:
		}
	}
	return nil
}
func (_cfgg *CT_ColFields) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fcfdb := range start.Attr {
		if _fcfdb.Name.Local == "count" {
			_adafd, _fbce := _g.ParseUint(_fcfdb.Value, 10, 32)
			if _fbce != nil {
				return _fbce
			}
			_gggae := uint32(_adafd)
			_cfgg.CountAttr = &_gggae
			continue
		}
	}
_dagac:
	for {
		_dedf, _cbcc := d.Token()
		if _cbcc != nil {
			return _cbcc
		}
		switch _gcgc := _dedf.(type) {
		case _f.StartElement:
			switch _gcgc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "field"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "field"}:
				_eaad := NewCT_Field()
				if _abbe := d.DecodeElement(_eaad, &_gcgc); _abbe != nil {
					return _abbe
				}
				_cfgg.Field = append(_cfgg.Field, _eaad)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ColFields\u0020\u0025v", _gcgc.Name)
				if _ccde := d.Skip(); _ccde != nil {
					return _ccde
				}
			}
		case _f.EndElement:
			break _dagac
		case _f.CharData:
		}
	}
	return nil
}
func (_feeeea *CT_PageField) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fld"}, Value: _bg.Sprintf("\u0025v", _feeeea.FldAttr)})
	if _feeeea.ItemAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "item"}, Value: _bg.Sprintf("\u0025v", *_feeeea.ItemAttr)})
	}
	if _feeeea.HierAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hier"}, Value: _bg.Sprintf("\u0025v", *_feeeea.HierAttr)})
	}
	if _feeeea.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_feeeea.NameAttr)})
	}
	if _feeeea.CapAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cap"}, Value: _bg.Sprintf("\u0025v", *_feeeea.CapAttr)})
	}
	e.EncodeToken(start)
	if _feeeea.ExtLst != nil {
		_adaff := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_feeeea.ExtLst, _adaff)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gcgdcc ST_ConditionalFormattingOperator) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_faeee := _f.Attr{}
	_faeee.Name = name
	switch _gcgdcc {
	case ST_ConditionalFormattingOperatorUnset:
		_faeee.Value = ""
	case ST_ConditionalFormattingOperatorLessThan:
		_faeee.Value = "lessThan"
	case ST_ConditionalFormattingOperatorLessThanOrEqual:
		_faeee.Value = "lessThanOrEqual"
	case ST_ConditionalFormattingOperatorEqual:
		_faeee.Value = "equal"
	case ST_ConditionalFormattingOperatorNotEqual:
		_faeee.Value = "notEqual"
	case ST_ConditionalFormattingOperatorGreaterThanOrEqual:
		_faeee.Value = "greaterThanOrEqual"
	case ST_ConditionalFormattingOperatorGreaterThan:
		_faeee.Value = "greaterThan"
	case ST_ConditionalFormattingOperatorBetween:
		_faeee.Value = "between"
	case ST_ConditionalFormattingOperatorNotBetween:
		_faeee.Value = "notBetween"
	case ST_ConditionalFormattingOperatorContainsText:
		_faeee.Value = "containsText"
	case ST_ConditionalFormattingOperatorNotContains:
		_faeee.Value = "notContains"
	case ST_ConditionalFormattingOperatorBeginsWith:
		_faeee.Value = "beginsWith"
	case ST_ConditionalFormattingOperatorEndsWith:
		_faeee.Value = "endsWith"
	}
	return _faeee, nil
}

// Validate validates the CT_ExternalLinkChoice and its children
func (_ecfcf *CT_ExternalLinkChoice) Validate() error {
	return _ecfcf.ValidateWithPath("CT_ExternalLinkChoice")
}

// Validate validates the CT_Borders and its children
func (_baee *CT_Borders) Validate() error  { return _baee.ValidateWithPath("CT_Borders") }
func NewCT_PrintOptions() *CT_PrintOptions { _deedc := &CT_PrintOptions{}; return _deedc }

type CT_Format struct {

	// Format Action
	ActionAttr ST_FormatAction

	// Format Id
	DxfIdAttr *uint32

	// Pivot Table Location
	PivotArea *CT_PivotArea

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

// ValidateWithPath validates the CT_MemberProperties and its children, prefixing error messages with path
func (_ffdfda *CT_MemberProperties) ValidateWithPath(path string) error {
	for _fgaee, _eega := range _ffdfda.Mp {
		if _ggaeda := _eega.ValidateWithPath(_bg.Sprintf("\u0025s\u002fMp\u005b\u0025d]", path, _fgaee)); _ggaeda != nil {
			return _ggaeda
		}
	}
	return nil
}
func (_dgege ST_Objects) String() string {
	switch _dgege {
	case 0:
		return ""
	case 1:
		return "all"
	case 2:
		return "placeholders"
	case 3:
		return "none"
	}
	return ""
}
func (_aeebe *CT_Fonts) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ebbeg := range start.Attr {
		if _ebbeg.Name.Local == "count" {
			_bcagd, _bacae := _g.ParseUint(_ebbeg.Value, 10, 32)
			if _bacae != nil {
				return _bacae
			}
			_aebca := uint32(_bcagd)
			_aeebe.CountAttr = &_aebca
			continue
		}
	}
_cgeed:
	for {
		_gdeb, _fcdce := d.Token()
		if _fcdce != nil {
			return _fcdce
		}
		switch _ddeee := _gdeb.(type) {
		case _f.StartElement:
			switch _ddeee.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "font"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "font"}:
				_bggcga := NewCT_Font()
				if _fcbgb := d.DecodeElement(_bggcga, &_ddeee); _fcbgb != nil {
					return _fcbgb
				}
				_aeebe.Font = append(_aeebe.Font, _bggcga)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Fonts\u0020\u0025v", _ddeee.Name)
				if _egebd := d.Skip(); _egebd != nil {
					return _egebd
				}
			}
		case _f.EndElement:
			break _cgeed
		case _f.CharData:
		}
	}
	return nil
}

type CT_Groups struct {

	// Level Group Count
	CountAttr *uint32

	// OLAP Group
	Group []*CT_LevelGroup
}

func (_gbfefc ST_Comments) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_fafdcf := _f.Attr{}
	_fafdcf.Name = name
	switch _gbfefc {
	case ST_CommentsUnset:
		_fafdcf.Value = ""
	case ST_CommentsCommNone:
		_fafdcf.Value = "commNone"
	case ST_CommentsCommIndicator:
		_fafdcf.Value = "commIndicator"
	case ST_CommentsCommIndAndComment:
		_fafdcf.Value = "commIndAndComment"
	}
	return _fafdcf, nil
}
func (_dgca *CT_ControlPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dgca.LockedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "locked"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgca.LockedAttr))})
	}
	if _dgca.DefaultSizeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultSize"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgca.DefaultSizeAttr))})
	}
	if _dgca.PrintAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "print"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgca.PrintAttr))})
	}
	if _dgca.DisabledAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "disabled"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgca.DisabledAttr))})
	}
	if _dgca.RecalcAlwaysAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "recalcAlways"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgca.RecalcAlwaysAttr))})
	}
	if _dgca.UiObjectAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uiObject"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgca.UiObjectAttr))})
	}
	if _dgca.AutoFillAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoFill"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgca.AutoFillAttr))})
	}
	if _dgca.AutoLineAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoLine"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgca.AutoLineAttr))})
	}
	if _dgca.AutoPictAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoPict"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgca.AutoPictAttr))})
	}
	if _dgca.MacroAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "macro"}, Value: _bg.Sprintf("\u0025v", *_dgca.MacroAttr)})
	}
	if _dgca.AltTextAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "altText"}, Value: _bg.Sprintf("\u0025v", *_dgca.AltTextAttr)})
	}
	if _dgca.LinkedCellAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "linkedCell"}, Value: _bg.Sprintf("\u0025v", *_dgca.LinkedCellAttr)})
	}
	if _dgca.ListFillRangeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "listFillRange"}, Value: _bg.Sprintf("\u0025v", *_dgca.ListFillRangeAttr)})
	}
	if _dgca.CfAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cf"}, Value: _bg.Sprintf("\u0025v", *_dgca.CfAttr)})
	}
	if _dgca.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", *_dgca.IdAttr)})
	}
	e.EncodeToken(start)
	_agfg := _f.StartElement{Name: _f.Name{Local: "ma:anchor"}}
	e.EncodeElement(_dgca.Anchor, _agfg)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_acdce *CT_RPrElt) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_cdcbe:
	for {
		_eedca, _daeff := d.Token()
		if _daeff != nil {
			return _daeff
		}
		switch _fcdbe := _eedca.(type) {
		case _f.StartElement:
			switch _fcdbe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rFont"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rFont"}:
				_acdce.RFont = NewCT_FontName()
				if _ecccfe := d.DecodeElement(_acdce.RFont, &_fcdbe); _ecccfe != nil {
					return _ecccfe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "charset"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "charset"}:
				_acdce.Charset = NewCT_IntProperty()
				if _daege := d.DecodeElement(_acdce.Charset, &_fcdbe); _daege != nil {
					return _daege
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "family"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "family"}:
				_acdce.Family = NewCT_IntProperty()
				if _dgecgf := d.DecodeElement(_acdce.Family, &_fcdbe); _dgecgf != nil {
					return _dgecgf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "b"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "b"}:
				_acdce.B = NewCT_BooleanProperty()
				if _bfecg := d.DecodeElement(_acdce.B, &_fcdbe); _bfecg != nil {
					return _bfecg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "i"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "i"}:
				_acdce.I = NewCT_BooleanProperty()
				if _bgfga := d.DecodeElement(_acdce.I, &_fcdbe); _bgfga != nil {
					return _bgfga
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "strike"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "strike"}:
				_acdce.Strike = NewCT_BooleanProperty()
				if _edcca := d.DecodeElement(_acdce.Strike, &_fcdbe); _edcca != nil {
					return _edcca
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "outline"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "outline"}:
				_acdce.Outline = NewCT_BooleanProperty()
				if _daceef := d.DecodeElement(_acdce.Outline, &_fcdbe); _daceef != nil {
					return _daceef
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "shadow"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "shadow"}:
				_acdce.Shadow = NewCT_BooleanProperty()
				if _dfdfa := d.DecodeElement(_acdce.Shadow, &_fcdbe); _dfdfa != nil {
					return _dfdfa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "condense"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "condense"}:
				_acdce.Condense = NewCT_BooleanProperty()
				if _acbea := d.DecodeElement(_acdce.Condense, &_fcdbe); _acbea != nil {
					return _acbea
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extend"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extend"}:
				_acdce.Extend = NewCT_BooleanProperty()
				if _fdfed := d.DecodeElement(_acdce.Extend, &_fcdbe); _fdfed != nil {
					return _fdfed
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "color"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "color"}:
				_acdce.Color = NewCT_Color()
				if _fbdbb := d.DecodeElement(_acdce.Color, &_fcdbe); _fbdbb != nil {
					return _fbdbb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sz"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sz"}:
				_acdce.Sz = NewCT_FontSize()
				if _cgfcb := d.DecodeElement(_acdce.Sz, &_fcdbe); _cgfcb != nil {
					return _cgfcb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "u"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "u"}:
				_acdce.U = NewCT_UnderlineProperty()
				if _bdfef := d.DecodeElement(_acdce.U, &_fcdbe); _bdfef != nil {
					return _bdfef
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "vertAlign"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "vertAlign"}:
				_acdce.VertAlign = NewCT_VerticalAlignFontProperty()
				if _gadeg := d.DecodeElement(_acdce.VertAlign, &_fcdbe); _gadeg != nil {
					return _gadeg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "scheme"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "scheme"}:
				_acdce.Scheme = NewCT_FontScheme()
				if _ecgbgg := d.DecodeElement(_acdce.Scheme, &_fcdbe); _ecgbgg != nil {
					return _ecgbgg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_RPrElt \u0025v", _fcdbe.Name)
				if _fefgd := d.Skip(); _fefgd != nil {
					return _fefgd
				}
			}
		case _f.EndElement:
			break _cdcbe
		case _f.CharData:
		}
	}
	return nil
}

type ST_CellComments byte

// Validate validates the CT_AutoSortScope and its children
func (_fbb *CT_AutoSortScope) Validate() error { return _fbb.ValidateWithPath("CT_AutoSortScope") }

type CT_GroupLevels struct {

	// Grouping Level Count
	CountAttr *uint32

	// OLAP Grouping Levels
	GroupLevel []*CT_GroupLevel
}

const (
	ST_FormatActionUnset      ST_FormatAction = 0
	ST_FormatActionBlank      ST_FormatAction = 1
	ST_FormatActionFormatting ST_FormatAction = 2
	ST_FormatActionDrill      ST_FormatAction = 3
	ST_FormatActionFormula    ST_FormatAction = 4
)

func (_fgbbge *CT_RevisionInsertSheet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fbcee := range start.Attr {
		if _fbcee.Name.Local == "sheetId" {
			_ffgdg, _defeb := _g.ParseUint(_fbcee.Value, 10, 32)
			if _defeb != nil {
				return _defeb
			}
			_fgbbge.SheetIdAttr = uint32(_ffgdg)
			continue
		}
		if _fbcee.Name.Local == "name" {
			_abgdg, _bdfaf := _fbcee.Value, error(nil)
			if _bdfaf != nil {
				return _bdfaf
			}
			_fgbbge.NameAttr = _abgdg
			continue
		}
		if _fbcee.Name.Local == "sheetPosition" {
			_bgaee, _bcaeg := _g.ParseUint(_fbcee.Value, 10, 32)
			if _bcaeg != nil {
				return _bcaeg
			}
			_fgbbge.SheetPositionAttr = uint32(_bgaee)
			continue
		}
		if _fbcee.Name.Local == "rId" {
			_fdacag, _fbeeg := _g.ParseUint(_fbcee.Value, 10, 32)
			if _fbeeg != nil {
				return _fbeeg
			}
			_fdaag := uint32(_fdacag)
			_fgbbge.RIdAttr = &_fdaag
			continue
		}
		if _fbcee.Name.Local == "ua" {
			_gaaaa, _bgdaf := _g.ParseBool(_fbcee.Value)
			if _bgdaf != nil {
				return _bgdaf
			}
			_fgbbge.UaAttr = &_gaaaa
			continue
		}
		if _fbcee.Name.Local == "ra" {
			_bcgge, _efdbdf := _g.ParseBool(_fbcee.Value)
			if _efdbdf != nil {
				return _efdbdf
			}
			_fgbbge.RaAttr = &_bcgge
			continue
		}
	}
	for {
		_beed, _bgggf := d.Token()
		if _bgggf != nil {
			return _bg.Errorf("parsing\u0020CT_RevisionInsertSheet:\u0020\u0025s", _bgggf)
		}
		if _aaaegd, _abfde := _beed.(_f.EndElement); _abfde && _aaaegd.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_pivotTableDefinition() *CT_pivotTableDefinition {
	_bcdef := &CT_pivotTableDefinition{}
	_bcdef.Location = NewCT_Location()
	return _bcdef
}
func (_aefc *CT_ChartsheetProtection) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ebeg := range start.Attr {
		if _ebeg.Name.Local == "password" {
			_gfbb, _effd := _ebeg.Value, error(nil)
			if _effd != nil {
				return _effd
			}
			_aefc.PasswordAttr = &_gfbb
			continue
		}
		if _ebeg.Name.Local == "algorithmName" {
			_fbac, _degbg := _ebeg.Value, error(nil)
			if _degbg != nil {
				return _degbg
			}
			_aefc.AlgorithmNameAttr = &_fbac
			continue
		}
		if _ebeg.Name.Local == "hashValue" {
			_efba, _edba := _ebeg.Value, error(nil)
			if _edba != nil {
				return _edba
			}
			_aefc.HashValueAttr = &_efba
			continue
		}
		if _ebeg.Name.Local == "saltValue" {
			_dgcc, _geaae := _ebeg.Value, error(nil)
			if _geaae != nil {
				return _geaae
			}
			_aefc.SaltValueAttr = &_dgcc
			continue
		}
		if _ebeg.Name.Local == "spinCount" {
			_bgdc, _aeccg := _g.ParseUint(_ebeg.Value, 10, 32)
			if _aeccg != nil {
				return _aeccg
			}
			_acad := uint32(_bgdc)
			_aefc.SpinCountAttr = &_acad
			continue
		}
		if _ebeg.Name.Local == "content" {
			_eeg, _eaagc := _g.ParseBool(_ebeg.Value)
			if _eaagc != nil {
				return _eaagc
			}
			_aefc.ContentAttr = &_eeg
			continue
		}
		if _ebeg.Name.Local == "objects" {
			_ccag, _ggff := _g.ParseBool(_ebeg.Value)
			if _ggff != nil {
				return _ggff
			}
			_aefc.ObjectsAttr = &_ccag
			continue
		}
	}
	for {
		_eegb, _ddce := d.Token()
		if _ddce != nil {
			return _bg.Errorf("parsing CT_ChartsheetProtection:\u0020%s", _ddce)
		}
		if _cbadd, _ecaad := _eegb.(_f.EndElement); _ecaad && _cbadd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cbefcb *CT_Table) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cbefcb.TableColumns = NewCT_TableColumns()
	for _, _dccag := range start.Attr {
		if _dccag.Name.Local == "dataDxfId" {
			_bdagac, _ebdef := _g.ParseUint(_dccag.Value, 10, 32)
			if _ebdef != nil {
				return _ebdef
			}
			_ebadf := uint32(_bdagac)
			_cbefcb.DataDxfIdAttr = &_ebadf
			continue
		}
		if _dccag.Name.Local == "totalsRowDxfId" {
			_cbcbef, _ddegde := _g.ParseUint(_dccag.Value, 10, 32)
			if _ddegde != nil {
				return _ddegde
			}
			_geegb := uint32(_cbcbef)
			_cbefcb.TotalsRowDxfIdAttr = &_geegb
			continue
		}
		if _dccag.Name.Local == "name" {
			_fgegb, _cbcgc := _dccag.Value, error(nil)
			if _cbcgc != nil {
				return _cbcgc
			}
			_cbefcb.NameAttr = &_fgegb
			continue
		}
		if _dccag.Name.Local == "headerRowBorderDxfId" {
			_ceefg, _ccgaf := _g.ParseUint(_dccag.Value, 10, 32)
			if _ccgaf != nil {
				return _ccgaf
			}
			_bafge := uint32(_ceefg)
			_cbefcb.HeaderRowBorderDxfIdAttr = &_bafge
			continue
		}
		if _dccag.Name.Local == "comment" {
			_edfbe, _egeega := _dccag.Value, error(nil)
			if _egeega != nil {
				return _egeega
			}
			_cbefcb.CommentAttr = &_edfbe
			continue
		}
		if _dccag.Name.Local == "tableBorderDxfId" {
			_abbeff, _dbaec := _g.ParseUint(_dccag.Value, 10, 32)
			if _dbaec != nil {
				return _dbaec
			}
			_eeggd := uint32(_abbeff)
			_cbefcb.TableBorderDxfIdAttr = &_eeggd
			continue
		}
		if _dccag.Name.Local == "tableType" {
			_cbefcb.TableTypeAttr.UnmarshalXMLAttr(_dccag)
			continue
		}
		if _dccag.Name.Local == "totalsRowBorderDxfId" {
			_afafg, _dfafec := _g.ParseUint(_dccag.Value, 10, 32)
			if _dfafec != nil {
				return _dfafec
			}
			_acggb := uint32(_afafg)
			_cbefcb.TotalsRowBorderDxfIdAttr = &_acggb
			continue
		}
		if _dccag.Name.Local == "insertRow" {
			_aadab, _bdgbd := _g.ParseBool(_dccag.Value)
			if _bdgbd != nil {
				return _bdgbd
			}
			_cbefcb.InsertRowAttr = &_aadab
			continue
		}
		if _dccag.Name.Local == "headerRowCellStyle" {
			_agegf, _gffcb := _dccag.Value, error(nil)
			if _gffcb != nil {
				return _gffcb
			}
			_cbefcb.HeaderRowCellStyleAttr = &_agegf
			continue
		}
		if _dccag.Name.Local == "totalsRowCount" {
			_cecdce, _gecfce := _g.ParseUint(_dccag.Value, 10, 32)
			if _gecfce != nil {
				return _gecfce
			}
			_fddba := uint32(_cecdce)
			_cbefcb.TotalsRowCountAttr = &_fddba
			continue
		}
		if _dccag.Name.Local == "totalsRowCellStyle" {
			_bcdcg, _aceea := _dccag.Value, error(nil)
			if _aceea != nil {
				return _aceea
			}
			_cbefcb.TotalsRowCellStyleAttr = &_bcdcg
			continue
		}
		if _dccag.Name.Local == "displayName" {
			_caegf, _faadec := _dccag.Value, error(nil)
			if _faadec != nil {
				return _faadec
			}
			_cbefcb.DisplayNameAttr = _caegf
			continue
		}
		if _dccag.Name.Local == "id" {
			_fafae, _fabaf := _g.ParseUint(_dccag.Value, 10, 32)
			if _fabaf != nil {
				return _fabaf
			}
			_cbefcb.IdAttr = uint32(_fafae)
			continue
		}
		if _dccag.Name.Local == "dataCellStyle" {
			_dbgfc, _gbggc := _dccag.Value, error(nil)
			if _gbggc != nil {
				return _gbggc
			}
			_cbefcb.DataCellStyleAttr = &_dbgfc
			continue
		}
		if _dccag.Name.Local == "published" {
			_efaed, _adedfc := _g.ParseBool(_dccag.Value)
			if _adedfc != nil {
				return _adedfc
			}
			_cbefcb.PublishedAttr = &_efaed
			continue
		}
		if _dccag.Name.Local == "connectionId" {
			_fcdbf, _bcaae := _g.ParseUint(_dccag.Value, 10, 32)
			if _bcaae != nil {
				return _bcaae
			}
			_cedeb := uint32(_fcdbf)
			_cbefcb.ConnectionIdAttr = &_cedeb
			continue
		}
		if _dccag.Name.Local == "ref" {
			_dggfc, _fgbbb := _dccag.Value, error(nil)
			if _fgbbb != nil {
				return _fgbbb
			}
			_cbefcb.RefAttr = _dggfc
			continue
		}
		if _dccag.Name.Local == "insertRowShift" {
			_dgfed, _dggccc := _g.ParseBool(_dccag.Value)
			if _dggccc != nil {
				return _dggccc
			}
			_cbefcb.InsertRowShiftAttr = &_dgfed
			continue
		}
		if _dccag.Name.Local == "totalsRowShown" {
			_ccgaaf, _afcedb := _g.ParseBool(_dccag.Value)
			if _afcedb != nil {
				return _afcedb
			}
			_cbefcb.TotalsRowShownAttr = &_ccgaaf
			continue
		}
		if _dccag.Name.Local == "headerRowDxfId" {
			_facdf, _febdee := _g.ParseUint(_dccag.Value, 10, 32)
			if _febdee != nil {
				return _febdee
			}
			_dabge := uint32(_facdf)
			_cbefcb.HeaderRowDxfIdAttr = &_dabge
			continue
		}
		if _dccag.Name.Local == "headerRowCount" {
			_cfeaaf, _aadbaf := _g.ParseUint(_dccag.Value, 10, 32)
			if _aadbaf != nil {
				return _aadbaf
			}
			_dbaegd := uint32(_cfeaaf)
			_cbefcb.HeaderRowCountAttr = &_dbaegd
			continue
		}
	}
_agedd:
	for {
		_beedg, _bbggbe := d.Token()
		if _bbggbe != nil {
			return _bbggbe
		}
		switch _dgbdb := _beedg.(type) {
		case _f.StartElement:
			switch _dgbdb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "autoFilter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "autoFilter"}:
				_cbefcb.AutoFilter = NewCT_AutoFilter()
				if _agfgc := d.DecodeElement(_cbefcb.AutoFilter, &_dgbdb); _agfgc != nil {
					return _agfgc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sortState"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sortState"}:
				_cbefcb.SortState = NewCT_SortState()
				if _dcaec := d.DecodeElement(_cbefcb.SortState, &_dgbdb); _dcaec != nil {
					return _dcaec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tableColumns"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tableColumns"}:
				if _abfac := d.DecodeElement(_cbefcb.TableColumns, &_dgbdb); _abfac != nil {
					return _abfac
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tableStyleInfo"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tableStyleInfo"}:
				_cbefcb.TableStyleInfo = NewCT_TableStyleInfo()
				if _ebcfe := d.DecodeElement(_cbefcb.TableStyleInfo, &_dgbdb); _ebcfe != nil {
					return _ebcfe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_cbefcb.ExtLst = NewCT_ExtensionList()
				if _edbba := d.DecodeElement(_cbefcb.ExtLst, &_dgbdb); _edbba != nil {
					return _edbba
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Table\u0020\u0025v", _dgbdb.Name)
				if _ggcda := d.Skip(); _ggcda != nil {
					return _ggcda
				}
			}
		case _f.EndElement:
			break _agedd
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_ExternalDefinedName and its children
func (_ebfae *CT_ExternalDefinedName) Validate() error {
	return _ebfae.ValidateWithPath("CT_ExternalDefinedName")
}

// ValidateWithPath validates the CT_PageSetup and its children, prefixing error messages with path
func (_cfcff *CT_PageSetup) ValidateWithPath(path string) error {
	if _cfcff.PaperHeightAttr != nil {
		if !_e.ST_PositiveUniversalMeasurePatternRe.MatchString(*_cfcff.PaperHeightAttr) {
			return _bg.Errorf("\u0025s/m\u002ePaperHeightAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_PositiveUniversalMeasurePatternRe, *_cfcff.PaperHeightAttr)
		}
	}
	if _cfcff.PaperHeightAttr != nil {
		if !_e.ST_UniversalMeasurePatternRe.MatchString(*_cfcff.PaperHeightAttr) {
			return _bg.Errorf("\u0025s/m\u002ePaperHeightAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_UniversalMeasurePatternRe, *_cfcff.PaperHeightAttr)
		}
	}
	if _cfcff.PaperWidthAttr != nil {
		if !_e.ST_PositiveUniversalMeasurePatternRe.MatchString(*_cfcff.PaperWidthAttr) {
			return _bg.Errorf("\u0025s\u002fm.PaperWidthAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027 \u0028have\u0020\u0025v\u0029", path, _e.ST_PositiveUniversalMeasurePatternRe, *_cfcff.PaperWidthAttr)
		}
	}
	if _cfcff.PaperWidthAttr != nil {
		if !_e.ST_UniversalMeasurePatternRe.MatchString(*_cfcff.PaperWidthAttr) {
			return _bg.Errorf("\u0025s\u002fm.PaperWidthAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027 \u0028have\u0020\u0025v\u0029", path, _e.ST_UniversalMeasurePatternRe, *_cfcff.PaperWidthAttr)
		}
	}
	if _efcgfc := _cfcff.PageOrderAttr.ValidateWithPath(path + "\u002fPageOrderAttr"); _efcgfc != nil {
		return _efcgfc
	}
	if _faefgf := _cfcff.OrientationAttr.ValidateWithPath(path + "\u002fOrientationAttr"); _faefgf != nil {
		return _faefgf
	}
	if _abecg := _cfcff.CellCommentsAttr.ValidateWithPath(path + "\u002fCellCommentsAttr"); _abecg != nil {
		return _abecg
	}
	if _efeeb := _cfcff.ErrorsAttr.ValidateWithPath(path + "/ErrorsAttr"); _efeeb != nil {
		return _efeeb
	}
	return nil
}

type CT_CalcChain struct {

	// Cell
	C      []*CT_CalcCell
	ExtLst *CT_ExtensionList
}

func (_defed *CT_VolMain) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _degac := range start.Attr {
		if _degac.Name.Local == "first" {
			_bcadae, _dgabgf := _degac.Value, error(nil)
			if _dgabgf != nil {
				return _dgabgf
			}
			_defed.FirstAttr = _bcadae
			continue
		}
	}
_gfeda:
	for {
		_aaccb, _bfbgc := d.Token()
		if _bfbgc != nil {
			return _bfbgc
		}
		switch _dadec := _aaccb.(type) {
		case _f.StartElement:
			switch _dadec.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tp"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tp"}:
				_gedccd := NewCT_VolTopic()
				if _dfccg := d.DecodeElement(_gedccd, &_dadec); _dfccg != nil {
					return _dfccg
				}
				_defed.Tp = append(_defed.Tp, _gedccd)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_VolMain\u0020\u0025v", _dadec.Name)
				if _abbfcc := d.Skip(); _abbfcc != nil {
					return _abbfcc
				}
			}
		case _f.EndElement:
			break _gfeda
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_RevisionMove and its children
func (_fdbfe *CT_RevisionMove) Validate() error { return _fdbfe.ValidateWithPath("CT_RevisionMove") }
func NewCT_PageItem() *CT_PageItem              { _ffbcc := &CT_PageItem{}; return _ffbcc }

// Validate validates the CT_Record and its children
func (_egfec *CT_Record) Validate() error { return _egfec.ValidateWithPath("CT_Record") }

// ValidateWithPath validates the CT_CellWatch and its children, prefixing error messages with path
func (_acag *CT_CellWatch) ValidateWithPath(path string) error { return nil }
func NewCT_X() *CT_X                                           { _gaagc := &CT_X{}; return _gaagc }
func NewCT_OutlinePr() *CT_OutlinePr                           { _gcce := &CT_OutlinePr{}; return _gcce }

// Validate validates the CT_Boolean and its children
func (_eca *CT_Boolean) Validate() error { return _eca.ValidateWithPath("CT_Boolean") }

// ValidateWithPath validates the CT_OleObject and its children, prefixing error messages with path
func (_eegbg *CT_OleObject) ValidateWithPath(path string) error {
	if _dcfcf := _eegbg.DvAspectAttr.ValidateWithPath(path + "\u002fDvAspectAttr"); _dcfcf != nil {
		return _dcfcf
	}
	if _gecfd := _eegbg.OleUpdateAttr.ValidateWithPath(path + "\u002fOleUpdateAttr"); _gecfd != nil {
		return _gecfd
	}
	if _eegbg.ObjectPr != nil {
		if _fcaee := _eegbg.ObjectPr.ValidateWithPath(path + "\u002fObjectPr"); _fcaee != nil {
			return _fcaee
		}
	}
	return nil
}

// ValidateWithPath validates the CT_String and its children, prefixing error messages with path
func (_bbcd *CT_String) ValidateWithPath(path string) error {
	for _eedce, _bdefb := range _bbcd.Tpls {
		if _aceddd := _bdefb.ValidateWithPath(_bg.Sprintf("%s\u002fTpls\u005b\u0025d\u005d", path, _eedce)); _aceddd != nil {
			return _aceddd
		}
	}
	for _ffgdfg, _ccgee := range _bbcd.X {
		if _bedfed := _ccgee.ValidateWithPath(_bg.Sprintf("\u0025s\u002fX\u005b\u0025d\u005d", path, _ffgdfg)); _bedfed != nil {
			return _bedfed
		}
	}
	return nil
}
func NewCT_rowItems() *CT_rowItems { _abacg := &CT_rowItems{}; return _abacg }
func (_agfga *CT_DataBinding) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _agfga.DataBindingNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "DataBindingName"}, Value: _bg.Sprintf("\u0025v", *_agfga.DataBindingNameAttr)})
	}
	if _agfga.FileBindingAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "FileBinding"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_agfga.FileBindingAttr))})
	}
	if _agfga.ConnectionIDAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ConnectionID"}, Value: _bg.Sprintf("\u0025v", *_agfga.ConnectionIDAttr)})
	}
	if _agfga.FileBindingNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "FileBindingName"}, Value: _bg.Sprintf("\u0025v", *_agfga.FileBindingNameAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "DataBindingLoadMode"}, Value: _bg.Sprintf("\u0025v", _agfga.DataBindingLoadModeAttr)})
	e.EncodeToken(start)
	if _agfga.Any != nil {
		_agfga.Any.MarshalXML(e, _f.StartElement{})
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cfbcf ST_SheetViewType) Validate() error { return _cfbcf.ValidateWithPath("") }
func (_daddd *CT_ChartFormat) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "chart"}, Value: _bg.Sprintf("\u0025v", _daddd.ChartAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "format"}, Value: _bg.Sprintf("\u0025v", _daddd.FormatAttr)})
	if _daddd.SeriesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "series"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_daddd.SeriesAttr))})
	}
	e.EncodeToken(start)
	_cbfcd := _f.StartElement{Name: _f.Name{Local: "ma:pivotArea"}}
	e.EncodeElement(_daddd.PivotArea, _cbfcd)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gfggfc ST_DataValidationOperator) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_efdgec := _f.Attr{}
	_efdgec.Name = name
	switch _gfggfc {
	case ST_DataValidationOperatorUnset:
		_efdgec.Value = ""
	case ST_DataValidationOperatorBetween:
		_efdgec.Value = "between"
	case ST_DataValidationOperatorNotBetween:
		_efdgec.Value = "notBetween"
	case ST_DataValidationOperatorEqual:
		_efdgec.Value = "equal"
	case ST_DataValidationOperatorNotEqual:
		_efdgec.Value = "notEqual"
	case ST_DataValidationOperatorLessThan:
		_efdgec.Value = "lessThan"
	case ST_DataValidationOperatorLessThanOrEqual:
		_efdgec.Value = "lessThanOrEqual"
	case ST_DataValidationOperatorGreaterThan:
		_efdgec.Value = "greaterThan"
	case ST_DataValidationOperatorGreaterThanOrEqual:
		_efdgec.Value = "greaterThanOrEqual"
	}
	return _efdgec, nil
}

const (
	ST_HtmlFmtUnset ST_HtmlFmt = 0
	ST_HtmlFmtNone  ST_HtmlFmt = 1
	ST_HtmlFmtRtf   ST_HtmlFmt = 2
	ST_HtmlFmtAll   ST_HtmlFmt = 3
)

func (_facbd ST_UpdateLinks) ValidateWithPath(path string) error {
	switch _facbd {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_facbd))
	}
	return nil
}

// Validate validates the CT_ColFields and its children
func (_gcgb *CT_ColFields) Validate() error { return _gcgb.ValidateWithPath("CT_ColFields") }

// Validate validates the CT_VolTypes and its children
func (_aaaedcb *CT_VolTypes) Validate() error { return _aaaedcb.ValidateWithPath("CT_VolTypes") }
func NewCT_TableColumns() *CT_TableColumns    { _gfgdbb := &CT_TableColumns{}; return _gfgdbb }

type CT_XStringElement struct {

	// Value
	VAttr string
}

func NewCT_BookViews() *CT_BookViews { _aff := &CT_BookViews{}; return _aff }
func NewCT_PivotFilter() *CT_PivotFilter {
	_efcgg := &CT_PivotFilter{}
	_efcgg.TypeAttr = ST_PivotFilterType(1)
	_efcgg.AutoFilter = NewCT_AutoFilter()
	return _efcgg
}

// Validate validates the CT_RowFields and its children
func (_fbacee *CT_RowFields) Validate() error { return _fbacee.ValidateWithPath("CT_RowFields") }
func (_cgcad ST_Comments) String() string {
	switch _cgcad {
	case 0:
		return ""
	case 1:
		return "commNone"
	case 2:
		return "commIndicator"
	case 3:
		return "commIndAndComment"
	}
	return ""
}

// ValidateWithPath validates the CT_ExternalReference and its children, prefixing error messages with path
func (_cdaag *CT_ExternalReference) ValidateWithPath(path string) error { return nil }
func NewSingleXmlCells() *SingleXmlCells {
	_bgdge := &SingleXmlCells{}
	_bgdge.CT_SingleXmlCells = *NewCT_SingleXmlCells()
	return _bgdge
}
func (_bebba *CT_PivotCache) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _agadca := range start.Attr {
		if _agadca.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _agadca.Name.Local == "id" || _agadca.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _agadca.Name.Local == "id" {
			_edgeb, _dbfdb := _agadca.Value, error(nil)
			if _dbfdb != nil {
				return _dbfdb
			}
			_bebba.IdAttr = _edgeb
			continue
		}
		if _agadca.Name.Local == "cacheId" {
			_bcffe, _dagbg := _g.ParseUint(_agadca.Value, 10, 32)
			if _dagbg != nil {
				return _dagbg
			}
			_bebba.CacheIdAttr = uint32(_bcffe)
			continue
		}
	}
	for {
		_afebg, _edbbd := d.Token()
		if _edbbd != nil {
			return _bg.Errorf("parsing\u0020CT_PivotCache:\u0020\u0025s", _edbbd)
		}
		if _gcbbc, _bcgbg := _afebg.(_f.EndElement); _bcgbg && _gcbbc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cbea *CT_Location) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bddbg := range start.Attr {
		if _bddbg.Name.Local == "ref" {
			_ebdcgd, _ccdcf := _bddbg.Value, error(nil)
			if _ccdcf != nil {
				return _ccdcf
			}
			_cbea.RefAttr = _ebdcgd
			continue
		}
		if _bddbg.Name.Local == "firstHeaderRow" {
			_dcegd, _fddb := _g.ParseUint(_bddbg.Value, 10, 32)
			if _fddb != nil {
				return _fddb
			}
			_cbea.FirstHeaderRowAttr = uint32(_dcegd)
			continue
		}
		if _bddbg.Name.Local == "firstDataRow" {
			_dgafga, _adced := _g.ParseUint(_bddbg.Value, 10, 32)
			if _adced != nil {
				return _adced
			}
			_cbea.FirstDataRowAttr = uint32(_dgafga)
			continue
		}
		if _bddbg.Name.Local == "firstDataCol" {
			_cbfbe, _ccca := _g.ParseUint(_bddbg.Value, 10, 32)
			if _ccca != nil {
				return _ccca
			}
			_cbea.FirstDataColAttr = uint32(_cbfbe)
			continue
		}
		if _bddbg.Name.Local == "rowPageCount" {
			_fcacf, _bacaf := _g.ParseUint(_bddbg.Value, 10, 32)
			if _bacaf != nil {
				return _bacaf
			}
			_fgbbd := uint32(_fcacf)
			_cbea.RowPageCountAttr = &_fgbbd
			continue
		}
		if _bddbg.Name.Local == "colPageCount" {
			_gfbgd, _edffdf := _g.ParseUint(_bddbg.Value, 10, 32)
			if _edffdf != nil {
				return _edffdf
			}
			_egbbb := uint32(_gfbgd)
			_cbea.ColPageCountAttr = &_egbbb
			continue
		}
	}
	for {
		_cbebf, _aeef := d.Token()
		if _aeef != nil {
			return _bg.Errorf("parsing\u0020CT_Location:\u0020\u0025s", _aeef)
		}
		if _cgce, _egdfg := _cbebf.(_f.EndElement); _egdfg && _cgce.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Error() *CT_Error { _eeff := &CT_Error{}; return _eeff }

// Validate validates the CT_HierarchyUsage and its children
func (_bdbfdf *CT_HierarchyUsage) Validate() error {
	return _bdbfdf.ValidateWithPath("CT_HierarchyUsage")
}

// ValidateWithPath validates the CT_DiscretePr and its children, prefixing error messages with path
func (_gfbba *CT_DiscretePr) ValidateWithPath(path string) error {
	for _cbcfc, _adab := range _gfbba.X {
		if _cfafcg := _adab.ValidateWithPath(_bg.Sprintf("\u0025s\u002fX\u005b\u0025d\u005d", path, _cbcfc)); _cfafcg != nil {
			return _cfafcg
		}
	}
	return nil
}

type CT_Stylesheet struct {

	// Number Formats
	NumFmts *CT_NumFmts

	// Fonts
	Fonts *CT_Fonts

	// Fills
	Fills *CT_Fills

	// Borders
	Borders *CT_Borders

	// Formatting Records
	CellStyleXfs *CT_CellStyleXfs

	// Cell Formats
	CellXfs *CT_CellXfs

	// Cell Styles
	CellStyles *CT_CellStyles

	// Formats
	Dxfs *CT_Dxfs

	// Table Styles
	TableStyles *CT_TableStyles

	// Colors
	Colors *CT_Colors

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func NewCT_DataBar() *CT_DataBar {
	_gedff := &CT_DataBar{}
	_gedff.Color = NewCT_Color()
	return _gedff
}
func (_bccbe *ST_DataValidationErrorStyle) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bccbe = 0
	case "stop":
		*_bccbe = 1
	case "warning":
		*_bccbe = 2
	case "information":
		*_bccbe = 3
	}
	return nil
}

type CT_CellSmartTagPr struct {

	// Key Name
	KeyAttr string

	// Value
	ValAttr string
}

// Validate validates the Revisions and its children
func (_cegcgf *Revisions) Validate() error { return _cegcgf.ValidateWithPath("Revisions") }
func (_cddbb *CT_TableMissing) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for {
		_daagd, _fbfdb := d.Token()
		if _fbfdb != nil {
			return _bg.Errorf("parsing CT_TableMissing:\u0020\u0025s", _fbfdb)
		}
		if _aabbfc, _egdbgg := _daagd.(_f.EndElement); _egdbgg && _aabbfc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dfgdeb ST_CellComments) ValidateWithPath(path string) error {
	switch _dfgdeb {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dfgdeb))
	}
	return nil
}
func (_eeae *CT_Field) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "x"}, Value: _bg.Sprintf("\u0025v", _eeae.XAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_PivotSelection() *CT_PivotSelection {
	_decfg := &CT_PivotSelection{}
	_decfg.PivotArea = NewCT_PivotArea()
	return _decfg
}
func (_gfab ST_DataValidationImeMode) ValidateWithPath(path string) error {
	switch _gfab {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gfab))
	}
	return nil
}
func (_ceegec ST_TimePeriod) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_ceegec.String(), start)
}

type ST_PaneState byte

func (_dgdbca ST_DdeValueType) String() string {
	switch _dgdbca {
	case 0:
		return ""
	case 1:
		return "nil"
	case 2:
		return "b"
	case 3:
		return "n"
	case 4:
		return "e"
	case 5:
		return "str"
	}
	return ""
}
func (_bfedg ST_CfvoType) ValidateWithPath(path string) error {
	switch _bfedg {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bfedg))
	}
	return nil
}

const (
	ST_CellCommentsUnset       ST_CellComments = 0
	ST_CellCommentsNone        ST_CellComments = 1
	ST_CellCommentsAsDisplayed ST_CellComments = 2
	ST_CellCommentsAtEnd       ST_CellComments = 3
)

// ValidateWithPath validates the CT_MdxTuple and its children, prefixing error messages with path
func (_fbfbe *CT_MdxTuple) ValidateWithPath(path string) error {
	for _edgfb, _acbbd := range _fbfbe.N {
		if _ddaab := _acbbd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fN\u005b\u0025d\u005d", path, _edgfb)); _ddaab != nil {
			return _ddaab
		}
	}
	return nil
}
func (_gbbgg *CT_Mdx) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "n"}, Value: _bg.Sprintf("\u0025v", _gbbgg.NAttr)})
	_dagaa, _effbe := _gbbgg.FAttr.MarshalXMLAttr(_f.Name{Local: "f"})
	if _effbe != nil {
		return _effbe
	}
	start.Attr = append(start.Attr, _dagaa)
	e.EncodeToken(start)
	if _gbbgg.T != nil {
		_gafaag := _f.StartElement{Name: _f.Name{Local: "ma:t"}}
		e.EncodeElement(_gbbgg.T, _gafaag)
	}
	if _gbbgg.Ms != nil {
		_eagf := _f.StartElement{Name: _f.Name{Local: "ma:ms"}}
		e.EncodeElement(_gbbgg.Ms, _eagf)
	}
	if _gbbgg.P != nil {
		_eefba := _f.StartElement{Name: _f.Name{Local: "ma:p"}}
		e.EncodeElement(_gbbgg.P, _eefba)
	}
	if _gbbgg.K != nil {
		_fbbbb := _f.StartElement{Name: _f.Name{Local: "ma:k"}}
		e.EncodeElement(_gbbgg.K, _fbbbb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Schema and its children
func (_ecaccd *CT_Schema) Validate() error { return _ecaccd.ValidateWithPath("CT_Schema") }

type CalcChain struct{ CT_CalcChain }

func (_bdfab *CT_ServerFormats) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ebbbgc := range start.Attr {
		if _ebbbgc.Name.Local == "count" {
			_ebdde, _agdab := _g.ParseUint(_ebbbgc.Value, 10, 32)
			if _agdab != nil {
				return _agdab
			}
			_gfadc := uint32(_ebdde)
			_bdfab.CountAttr = &_gfadc
			continue
		}
	}
_dedfd:
	for {
		_egbbf, _gedae := d.Token()
		if _gedae != nil {
			return _gedae
		}
		switch _adbcgc := _egbbf.(type) {
		case _f.StartElement:
			switch _adbcgc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "serverFormat"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "serverFormat"}:
				_ffcgg := NewCT_ServerFormat()
				if _efbff := d.DecodeElement(_ffcgg, &_adbcgc); _efbff != nil {
					return _efbff
				}
				_bdfab.ServerFormat = append(_bdfab.ServerFormat, _ffcgg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ServerFormats\u0020\u0025v", _adbcgc.Name)
				if _bcaaa := d.Skip(); _bcaaa != nil {
					return _bcaaa
				}
			}
		case _f.EndElement:
			break _dedfd
		case _f.CharData:
		}
	}
	return nil
}
func (_gdde *CT_CfRule) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gdde.TypeAttr != ST_CfTypeUnset {
		_ccbe, _cdgdf := _gdde.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
		if _cdgdf != nil {
			return _cdgdf
		}
		start.Attr = append(start.Attr, _ccbe)
	}
	if _gdde.DxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dxfId"}, Value: _bg.Sprintf("\u0025v", *_gdde.DxfIdAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "priority"}, Value: _bg.Sprintf("\u0025v", _gdde.PriorityAttr)})
	if _gdde.StopIfTrueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "stopIfTrue"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdde.StopIfTrueAttr))})
	}
	if _gdde.AboveAverageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "aboveAverage"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdde.AboveAverageAttr))})
	}
	if _gdde.PercentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "percent"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdde.PercentAttr))})
	}
	if _gdde.BottomAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "bottom"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdde.BottomAttr))})
	}
	if _gdde.OperatorAttr != ST_ConditionalFormattingOperatorUnset {
		_ceef, _dbg := _gdde.OperatorAttr.MarshalXMLAttr(_f.Name{Local: "operator"})
		if _dbg != nil {
			return _dbg
		}
		start.Attr = append(start.Attr, _ceef)
	}
	if _gdde.TextAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "text"}, Value: _bg.Sprintf("\u0025v", *_gdde.TextAttr)})
	}
	if _gdde.TimePeriodAttr != ST_TimePeriodUnset {
		_cbddf, _bbege := _gdde.TimePeriodAttr.MarshalXMLAttr(_f.Name{Local: "timePeriod"})
		if _bbege != nil {
			return _bbege
		}
		start.Attr = append(start.Attr, _cbddf)
	}
	if _gdde.RankAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rank"}, Value: _bg.Sprintf("\u0025v", *_gdde.RankAttr)})
	}
	if _gdde.StdDevAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "stdDev"}, Value: _bg.Sprintf("\u0025v", *_gdde.StdDevAttr)})
	}
	if _gdde.EqualAverageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "equalAverage"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdde.EqualAverageAttr))})
	}
	e.EncodeToken(start)
	if _gdde.Formula != nil {
		_ecfe := _f.StartElement{Name: _f.Name{Local: "ma:formula"}}
		for _, _fgag := range _gdde.Formula {
			e.EncodeElement(_fgag, _ecfe)
		}
	}
	if _gdde.ColorScale != nil {
		_efdc := _f.StartElement{Name: _f.Name{Local: "ma:colorScale"}}
		e.EncodeElement(_gdde.ColorScale, _efdc)
	}
	if _gdde.DataBar != nil {
		_dfcd := _f.StartElement{Name: _f.Name{Local: "ma:dataBar"}}
		e.EncodeElement(_gdde.DataBar, _dfcd)
	}
	if _gdde.IconSet != nil {
		_dbcg := _f.StartElement{Name: _f.Name{Local: "ma:iconSet"}}
		e.EncodeElement(_gdde.IconSet, _dbcg)
	}
	if _gdde.ExtLst != nil {
		_bafe := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_gdde.ExtLst, _bafe)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_afage ST_CellType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_afage.String(), start)
}

type AG_RevData struct {
	RIdAttr *uint32
	UaAttr  *bool
	RaAttr  *bool
}

const (
	ST_VerticalAlignmentUnset       ST_VerticalAlignment = 0
	ST_VerticalAlignmentTop         ST_VerticalAlignment = 1
	ST_VerticalAlignmentCenter      ST_VerticalAlignment = 2
	ST_VerticalAlignmentBottom      ST_VerticalAlignment = 3
	ST_VerticalAlignmentJustify     ST_VerticalAlignment = 4
	ST_VerticalAlignmentDistributed ST_VerticalAlignment = 5
)

func (_ddgga *CT_Formats) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aagbg := range start.Attr {
		if _aagbg.Name.Local == "count" {
			_cdagcd, _aefaab := _g.ParseUint(_aagbg.Value, 10, 32)
			if _aefaab != nil {
				return _aefaab
			}
			_afcab := uint32(_cdagcd)
			_ddgga.CountAttr = &_afcab
			continue
		}
	}
_dabff:
	for {
		_ecdde, _ffdg := d.Token()
		if _ffdg != nil {
			return _ffdg
		}
		switch _fefcg := _ecdde.(type) {
		case _f.StartElement:
			switch _fefcg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "format"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "format"}:
				_cagde := NewCT_Format()
				if _aabg := d.DecodeElement(_cagde, &_fefcg); _aabg != nil {
					return _aabg
				}
				_ddgga.Format = append(_ddgga.Format, _cagde)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_Formats\u0020\u0025v", _fefcg.Name)
				if _cbbgc := d.Skip(); _cbbgc != nil {
					return _cbbgc
				}
			}
		case _f.EndElement:
			break _dabff
		case _f.CharData:
		}
	}
	return nil
}
func (_acefgg ST_CfType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_acefgg.String(), start)
}
func (_ggafd *CT_ExternalSheetData) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetId"}, Value: _bg.Sprintf("\u0025v", _ggafd.SheetIdAttr)})
	if _ggafd.RefreshErrorAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refreshError"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ggafd.RefreshErrorAttr))})
	}
	e.EncodeToken(start)
	if _ggafd.Row != nil {
		_bfbbg := _f.StartElement{Name: _f.Name{Local: "ma:row"}}
		for _, _aabc := range _ggafd.Row {
			e.EncodeElement(_aabc, _bfbbg)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_UnderlineProperty struct {

	// Underline Value
	ValAttr ST_UnderlineValues
}

func (_cceaa *CT_DataValidations) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cceaa.DisablePromptsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "disablePrompts"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cceaa.DisablePromptsAttr))})
	}
	if _cceaa.XWindowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xWindow"}, Value: _bg.Sprintf("\u0025v", *_cceaa.XWindowAttr)})
	}
	if _cceaa.YWindowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "yWindow"}, Value: _bg.Sprintf("\u0025v", *_cceaa.YWindowAttr)})
	}
	if _cceaa.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_cceaa.CountAttr)})
	}
	e.EncodeToken(start)
	_ggfge := _f.StartElement{Name: _f.Name{Local: "ma:dataValidation"}}
	for _, _acedg := range _cceaa.DataValidation {
		e.EncodeElement(_acedg, _ggfge)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_aaceb *ST_PrintError) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_aacdfc, _gfefa := d.Token()
	if _gfefa != nil {
		return _gfefa
	}
	if _efdcf, _aggcb := _aacdfc.(_f.EndElement); _aggcb && _efdcf.Name == start.Name {
		*_aaceb = 1
		return nil
	}
	if _dedcbb, _gggfb := _aacdfc.(_f.CharData); !_gggfb {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aacdfc)
	} else {
		switch string(_dedcbb) {
		case "":
			*_aaceb = 0
		case "displayed":
			*_aaceb = 1
		case "blank":
			*_aaceb = 2
		case "dash":
			*_aaceb = 3
		case "NA":
			*_aaceb = 4
		}
	}
	_aacdfc, _gfefa = d.Token()
	if _gfefa != nil {
		return _gfefa
	}
	if _gddega, _ccdca := _aacdfc.(_f.EndElement); _ccdca && _gddega.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aacdfc)
}

// Validate validates the CT_PivotSelection and its children
func (_fdecf *CT_PivotSelection) Validate() error {
	return _fdecf.ValidateWithPath("CT_PivotSelection")
}

const (
	ST_PhoneticTypeUnset             ST_PhoneticType = 0
	ST_PhoneticTypeHalfwidthKatakana ST_PhoneticType = 1
	ST_PhoneticTypeFullwidthKatakana ST_PhoneticType = 2
	ST_PhoneticTypeHiragana          ST_PhoneticType = 3
	ST_PhoneticTypeNoConversion      ST_PhoneticType = 4
)

func (_eeacc *ST_BorderStyle) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bacefe, _ceefbf := d.Token()
	if _ceefbf != nil {
		return _ceefbf
	}
	if _cbagb, _fggeb := _bacefe.(_f.EndElement); _fggeb && _cbagb.Name == start.Name {
		*_eeacc = 1
		return nil
	}
	if _abgcf, _gcacc := _bacefe.(_f.CharData); !_gcacc {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bacefe)
	} else {
		switch string(_abgcf) {
		case "":
			*_eeacc = 0
		case "none":
			*_eeacc = 1
		case "thin":
			*_eeacc = 2
		case "medium":
			*_eeacc = 3
		case "dashed":
			*_eeacc = 4
		case "dotted":
			*_eeacc = 5
		case "thick":
			*_eeacc = 6
		case "double":
			*_eeacc = 7
		case "hair":
			*_eeacc = 8
		case "mediumDashed":
			*_eeacc = 9
		case "dashDot":
			*_eeacc = 10
		case "mediumDashDot":
			*_eeacc = 11
		case "dashDotDot":
			*_eeacc = 12
		case "mediumDashDotDot":
			*_eeacc = 13
		case "slantDashDot":
			*_eeacc = 14
		}
	}
	_bacefe, _ceefbf = d.Token()
	if _ceefbf != nil {
		return _ceefbf
	}
	if _ffdffb, _ggebf := _bacefe.(_f.EndElement); _ggebf && _ffdffb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bacefe)
}

const (
	ST_FormulaExpressionUnset        ST_FormulaExpression = 0
	ST_FormulaExpressionRef          ST_FormulaExpression = 1
	ST_FormulaExpressionRefError     ST_FormulaExpression = 2
	ST_FormulaExpressionArea         ST_FormulaExpression = 3
	ST_FormulaExpressionAreaError    ST_FormulaExpression = 4
	ST_FormulaExpressionComputedArea ST_FormulaExpression = 5
)

func (_egcbe *CT_ExternalReference) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _egcbe.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_fgbdb ST_TextVAlign) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_fgbdb.String(), start)
}

// Validate validates the CT_X and its children
func (_bedfac *CT_X) Validate() error             { return _bedfac.ValidateWithPath("CT_X") }
func (_caecd ST_MdxFunctionType) Validate() error { return _caecd.ValidateWithPath("") }

// ValidateWithPath validates the CT_X and its children, prefixing error messages with path
func (_fgdcgd *CT_X) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_WebPublishObject and its children
func (_befccc *CT_WebPublishObject) Validate() error {
	return _befccc.ValidateWithPath("CT_WebPublishObject")
}
func NewCT_ExtensionList() *CT_ExtensionList { _ebgd := &CT_ExtensionList{}; return _ebgd }

type ST_RefMode byte
type CT_FunctionGroups struct {

	// Built-in Function Group Count
	BuiltInGroupCountAttr *uint32

	// Function Group
	FunctionGroup []*CT_FunctionGroup
}

const (
	ST_CommentsUnset             ST_Comments = 0
	ST_CommentsCommNone          ST_Comments = 1
	ST_CommentsCommIndicator     ST_Comments = 2
	ST_CommentsCommIndAndComment ST_Comments = 3
)

func (_ccff *CT_CsPageSetup) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ccff.PaperSizeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "paperSize"}, Value: _bg.Sprintf("\u0025v", *_ccff.PaperSizeAttr)})
	}
	if _ccff.PaperHeightAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "paperHeight"}, Value: _bg.Sprintf("\u0025v", *_ccff.PaperHeightAttr)})
	}
	if _ccff.PaperWidthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "paperWidth"}, Value: _bg.Sprintf("\u0025v", *_ccff.PaperWidthAttr)})
	}
	if _ccff.FirstPageNumberAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "firstPageNumber"}, Value: _bg.Sprintf("\u0025v", *_ccff.FirstPageNumberAttr)})
	}
	if _ccff.OrientationAttr != ST_OrientationUnset {
		_ddfc, _ddccf := _ccff.OrientationAttr.MarshalXMLAttr(_f.Name{Local: "orientation"})
		if _ddccf != nil {
			return _ddccf
		}
		start.Attr = append(start.Attr, _ddfc)
	}
	if _ccff.UsePrinterDefaultsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "usePrinterDefaults"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ccff.UsePrinterDefaultsAttr))})
	}
	if _ccff.BlackAndWhiteAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "blackAndWhite"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ccff.BlackAndWhiteAttr))})
	}
	if _ccff.DraftAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "draft"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ccff.DraftAttr))})
	}
	if _ccff.UseFirstPageNumberAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "useFirstPageNumber"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ccff.UseFirstPageNumberAttr))})
	}
	if _ccff.HorizontalDpiAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "horizontalDpi"}, Value: _bg.Sprintf("\u0025v", *_ccff.HorizontalDpiAttr)})
	}
	if _ccff.VerticalDpiAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "verticalDpi"}, Value: _bg.Sprintf("\u0025v", *_ccff.VerticalDpiAttr)})
	}
	if _ccff.CopiesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "copies"}, Value: _bg.Sprintf("\u0025v", *_ccff.CopiesAttr)})
	}
	if _ccff.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", *_ccff.IdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ddadfe ST_CredMethod) Validate() error { return _ddadfe.ValidateWithPath("") }
func (_ddgecc ST_VolValueType) String() string {
	switch _ddgecc {
	case 0:
		return ""
	case 1:
		return "b"
	case 2:
		return "n"
	case 3:
		return "e"
	case 4:
		return "s"
	}
	return ""
}
func (_afeba *ST_ItemType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gfaeb, _bacef := d.Token()
	if _bacef != nil {
		return _bacef
	}
	if _eddce, _gdeedb := _gfaeb.(_f.EndElement); _gdeedb && _eddce.Name == start.Name {
		*_afeba = 1
		return nil
	}
	if _aacdf, _abdggd := _gfaeb.(_f.CharData); !_abdggd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gfaeb)
	} else {
		switch string(_aacdf) {
		case "":
			*_afeba = 0
		case "data":
			*_afeba = 1
		case "default":
			*_afeba = 2
		case "sum":
			*_afeba = 3
		case "countA":
			*_afeba = 4
		case "avg":
			*_afeba = 5
		case "max":
			*_afeba = 6
		case "min":
			*_afeba = 7
		case "product":
			*_afeba = 8
		case "count":
			*_afeba = 9
		case "stdDev":
			*_afeba = 10
		case "stdDevP":
			*_afeba = 11
		case "var":
			*_afeba = 12
		case "varP":
			*_afeba = 13
		case "grand":
			*_afeba = 14
		case "blank":
			*_afeba = 15
		}
	}
	_gfaeb, _bacef = d.Token()
	if _bacef != nil {
		return _bacef
	}
	if _bggaa, _fcffb := _gfaeb.(_f.EndElement); _fcffb && _bggaa.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gfaeb)
}

type CT_VolTypes struct {

	// Volatile Dependency Type
	VolType []*CT_VolType
	ExtLst  *CT_ExtensionList
}

func NewCT_RevisionMove() *CT_RevisionMove { _adedg := &CT_RevisionMove{}; return _adedg }
func (_ddgcbb ST_VolDepType) String() string {
	switch _ddgcbb {
	case 0:
		return ""
	case 1:
		return "realTimeData"
	case 2:
		return "olapFunctions"
	}
	return ""
}
func (_fgcebd ST_SortBy) Validate() error { return _fgcebd.ValidateWithPath("") }
func (_bgfgfa *CT_OutlinePr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _addg := range start.Attr {
		if _addg.Name.Local == "applyStyles" {
			_acddg, _faecc := _g.ParseBool(_addg.Value)
			if _faecc != nil {
				return _faecc
			}
			_bgfgfa.ApplyStylesAttr = &_acddg
			continue
		}
		if _addg.Name.Local == "summaryBelow" {
			_acda, _gbab := _g.ParseBool(_addg.Value)
			if _gbab != nil {
				return _gbab
			}
			_bgfgfa.SummaryBelowAttr = &_acda
			continue
		}
		if _addg.Name.Local == "summaryRight" {
			_eceaa, _cdbce := _g.ParseBool(_addg.Value)
			if _cdbce != nil {
				return _cdbce
			}
			_bgfgfa.SummaryRightAttr = &_eceaa
			continue
		}
		if _addg.Name.Local == "showOutlineSymbols" {
			_cefcc, _ceebd := _g.ParseBool(_addg.Value)
			if _ceebd != nil {
				return _ceebd
			}
			_bgfgfa.ShowOutlineSymbolsAttr = &_cefcc
			continue
		}
	}
	for {
		_gfbdb, _edbge := d.Token()
		if _edbge != nil {
			return _bg.Errorf("parsing\u0020CT_OutlinePr:\u0020\u0025s", _edbge)
		}
		if _facgec, _gcaec := _gfbdb.(_f.EndElement); _gcaec && _facgec.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_DdeItem and its children, prefixing error messages with path
func (_bgdca *CT_DdeItem) ValidateWithPath(path string) error {
	if _bgdca.Values != nil {
		if _dccbf := _bgdca.Values.ValidateWithPath(path + "\u002fValues"); _dccbf != nil {
			return _dccbf
		}
	}
	return nil
}
func (_bggde *CT_CustomProperties) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_cadg := _f.StartElement{Name: _f.Name{Local: "ma:customPr"}}
	for _, _eafdb := range _bggde.CustomPr {
		e.EncodeElement(_eafdb, _cadg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Rst and its children, prefixing error messages with path
func (_dagcce *CT_Rst) ValidateWithPath(path string) error {
	for _edbbb, _aegde := range _dagcce.R {
		if _acea := _aegde.ValidateWithPath(_bg.Sprintf("\u0025s\u002fR\u005b\u0025d\u005d", path, _edbbb)); _acea != nil {
			return _acea
		}
	}
	for _efcbda, _acacda := range _dagcce.RPh {
		if _afaae := _acacda.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRPh\u005b\u0025d\u005d", path, _efcbda)); _afaae != nil {
			return _afaae
		}
	}
	if _dagcce.PhoneticPr != nil {
		if _cfffa := _dagcce.PhoneticPr.ValidateWithPath(path + "/PhoneticPr"); _cfffa != nil {
			return _cfffa
		}
	}
	return nil
}
func (_geged *CT_MeasureDimensionMap) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _geged.MeasureGroupAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "measureGroup"}, Value: _bg.Sprintf("\u0025v", *_geged.MeasureGroupAttr)})
	}
	if _geged.DimensionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dimension"}, Value: _bg.Sprintf("\u0025v", *_geged.DimensionAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bbgcg *CT_Workbook) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bbgcg.ConformanceAttr != _e.ST_ConformanceClassUnset {
		_cdcfe, _gffaf := _bbgcg.ConformanceAttr.MarshalXMLAttr(_f.Name{Local: "conformance"})
		if _gffaf != nil {
			return _gffaf
		}
		start.Attr = append(start.Attr, _cdcfe)
	}
	e.EncodeToken(start)
	if _bbgcg.FileVersion != nil {
		_ffgce := _f.StartElement{Name: _f.Name{Local: "ma:fileVersion"}}
		e.EncodeElement(_bbgcg.FileVersion, _ffgce)
	}
	if _bbgcg.FileSharing != nil {
		_gegbc := _f.StartElement{Name: _f.Name{Local: "ma:fileSharing"}}
		e.EncodeElement(_bbgcg.FileSharing, _gegbc)
	}
	if _bbgcg.WorkbookPr != nil {
		_fafacbe := _f.StartElement{Name: _f.Name{Local: "ma:workbookPr"}}
		e.EncodeElement(_bbgcg.WorkbookPr, _fafacbe)
	}
	if _bbgcg.WorkbookProtection != nil {
		_acddb := _f.StartElement{Name: _f.Name{Local: "ma:workbookProtection"}}
		e.EncodeElement(_bbgcg.WorkbookProtection, _acddb)
	}
	if _bbgcg.BookViews != nil {
		_gfcgc := _f.StartElement{Name: _f.Name{Local: "ma:bookViews"}}
		e.EncodeElement(_bbgcg.BookViews, _gfcgc)
	}
	_eegaeg := _f.StartElement{Name: _f.Name{Local: "ma:sheets"}}
	e.EncodeElement(_bbgcg.Sheets, _eegaeg)
	if _bbgcg.FunctionGroups != nil {
		_beedf := _f.StartElement{Name: _f.Name{Local: "ma:functionGroups"}}
		e.EncodeElement(_bbgcg.FunctionGroups, _beedf)
	}
	if _bbgcg.ExternalReferences != nil {
		_fegegc := _f.StartElement{Name: _f.Name{Local: "ma:externalReferences"}}
		e.EncodeElement(_bbgcg.ExternalReferences, _fegegc)
	}
	if _bbgcg.DefinedNames != nil {
		_dfbbc := _f.StartElement{Name: _f.Name{Local: "ma:definedNames"}}
		e.EncodeElement(_bbgcg.DefinedNames, _dfbbc)
	}
	if _bbgcg.CalcPr != nil {
		_abfaa := _f.StartElement{Name: _f.Name{Local: "ma:calcPr"}}
		e.EncodeElement(_bbgcg.CalcPr, _abfaa)
	}
	if _bbgcg.OleSize != nil {
		_edgdae := _f.StartElement{Name: _f.Name{Local: "ma:oleSize"}}
		e.EncodeElement(_bbgcg.OleSize, _edgdae)
	}
	if _bbgcg.CustomWorkbookViews != nil {
		_egegd := _f.StartElement{Name: _f.Name{Local: "ma:customWorkbookViews"}}
		e.EncodeElement(_bbgcg.CustomWorkbookViews, _egegd)
	}
	if _bbgcg.PivotCaches != nil {
		_ccdfae := _f.StartElement{Name: _f.Name{Local: "ma:pivotCaches"}}
		e.EncodeElement(_bbgcg.PivotCaches, _ccdfae)
	}
	if _bbgcg.SmartTagPr != nil {
		_daecg := _f.StartElement{Name: _f.Name{Local: "ma:smartTagPr"}}
		e.EncodeElement(_bbgcg.SmartTagPr, _daecg)
	}
	if _bbgcg.SmartTagTypes != nil {
		_adeab := _f.StartElement{Name: _f.Name{Local: "ma:smartTagTypes"}}
		e.EncodeElement(_bbgcg.SmartTagTypes, _adeab)
	}
	if _bbgcg.WebPublishing != nil {
		_dadgdc := _f.StartElement{Name: _f.Name{Local: "ma:webPublishing"}}
		e.EncodeElement(_bbgcg.WebPublishing, _dadgdc)
	}
	if _bbgcg.FileRecoveryPr != nil {
		_eeaed := _f.StartElement{Name: _f.Name{Local: "ma:fileRecoveryPr"}}
		for _, _bdccg := range _bbgcg.FileRecoveryPr {
			e.EncodeElement(_bdccg, _eeaed)
		}
	}
	if _bbgcg.WebPublishObjects != nil {
		_ceeefb := _f.StartElement{Name: _f.Name{Local: "ma:webPublishObjects"}}
		e.EncodeElement(_bbgcg.WebPublishObjects, _ceeefb)
	}
	if _bbgcg.ExtLst != nil {
		_gfegb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_bbgcg.ExtLst, _gfegb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SheetView and its children
func (_cgbgfg *CT_SheetView) Validate() error { return _cgbgfg.ValidateWithPath("CT_SheetView") }
func NewCT_SheetId() *CT_SheetId              { _ceabf := &CT_SheetId{}; return _ceabf }

// Validate validates the CT_BookViews and its children
func (_fgb *CT_BookViews) Validate() error { return _fgb.ValidateWithPath("CT_BookViews") }

// Validate validates the CT_DataFields and its children
func (_ffebg *CT_DataFields) Validate() error { return _ffebg.ValidateWithPath("CT_DataFields") }
func (_egfde *CT_ServerFormat) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _egfde.CultureAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "culture"}, Value: _bg.Sprintf("\u0025v", *_egfde.CultureAttr)})
	}
	if _egfde.FormatAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "format"}, Value: _bg.Sprintf("\u0025v", *_egfde.FormatAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_PCDKPI and its children, prefixing error messages with path
func (_beade *CT_PCDKPI) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_WebPublishItems and its children
func (_daafbd *CT_WebPublishItems) Validate() error {
	return _daafbd.ValidateWithPath("CT_WebPublishItems")
}
func (_fded *CT_BookViews) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_agff:
	for {
		_fab, _aea := d.Token()
		if _aea != nil {
			return _aea
		}
		switch _ac := _fab.(type) {
		case _f.StartElement:
			switch _ac.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "workbookView"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "workbookView"}:
				_afff := NewCT_BookView()
				if _bfc := d.DecodeElement(_afff, &_ac); _bfc != nil {
					return _bfc
				}
				_fded.WorkbookView = append(_fded.WorkbookView, _afff)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BookViews\u0020\u0025v", _ac.Name)
				if _cggf := d.Skip(); _cggf != nil {
					return _cggf
				}
			}
		case _f.EndElement:
			break _agff
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ChartFormats and its children, prefixing error messages with path
func (_efggg *CT_ChartFormats) ValidateWithPath(path string) error {
	for _cdgf, _dfcdg := range _efggg.ChartFormat {
		if _aeagf := _dfcdg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fChartFormat\u005b\u0025d\u005d", path, _cdgf)); _aeagf != nil {
			return _aeagf
		}
	}
	return nil
}

type CT_ExternalDefinedNames struct {

	// Defined Name
	DefinedName []*CT_ExternalDefinedName
}

// Validate validates the CT_ExternalDefinedNames and its children
func (_agfgd *CT_ExternalDefinedNames) Validate() error {
	return _agfgd.ValidateWithPath("CT_ExternalDefinedNames")
}

// Validate validates the CT_Tables and its children
func (_cadcf *CT_Tables) Validate() error { return _cadcf.ValidateWithPath("CT_Tables") }
func (_facbc ST_PivotAreaType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_facbc.String(), start)
}
func (_bgae *CT_Controls) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_gedfa:
	for {
		_ebcgd, _aded := d.Token()
		if _aded != nil {
			return _aded
		}
		switch _ebbgg := _ebcgd.(type) {
		case _f.StartElement:
			switch _ebbgg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "control"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "control"}:
				_cacbc := NewCT_Control()
				if _acgg := d.DecodeElement(_cacbc, &_ebbgg); _acgg != nil {
					return _acgg
				}
				_bgae.Control = append(_bgae.Control, _cacbc)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Controls\u0020\u0025v", _ebbgg.Name)
				if _gfece := d.Skip(); _gfece != nil {
					return _gfece
				}
			}
		case _f.EndElement:
			break _gedfa
		case _f.CharData:
		}
	}
	return nil
}
func (_ceaad ST_VolValueType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_agdbd := _f.Attr{}
	_agdbd.Name = name
	switch _ceaad {
	case ST_VolValueTypeUnset:
		_agdbd.Value = ""
	case ST_VolValueTypeB:
		_agdbd.Value = "b"
	case ST_VolValueTypeN:
		_agdbd.Value = "n"
	case ST_VolValueTypeE:
		_agdbd.Value = "e"
	case ST_VolValueTypeS:
		_agdbd.Value = "s"
	}
	return _agdbd, nil
}
func (_gdfga *CT_VolMain) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "first"}, Value: _bg.Sprintf("\u0025v", _gdfga.FirstAttr)})
	e.EncodeToken(start)
	_dbbcd := _f.StartElement{Name: _f.Name{Local: "ma:tp"}}
	for _, _aacaa := range _gdfga.Tp {
		e.EncodeElement(_aacaa, _dbbcd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_faeccb *CT_TableColumns) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bdgcg := range start.Attr {
		if _bdgcg.Name.Local == "count" {
			_bgaeag, _ecdfaa := _g.ParseUint(_bdgcg.Value, 10, 32)
			if _ecdfaa != nil {
				return _ecdfaa
			}
			_cbabb := uint32(_bgaeag)
			_faeccb.CountAttr = &_cbabb
			continue
		}
	}
_geagcc:
	for {
		_caagg, _adcgc := d.Token()
		if _adcgc != nil {
			return _adcgc
		}
		switch _dbdged := _caagg.(type) {
		case _f.StartElement:
			switch _dbdged.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tableColumn"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tableColumn"}:
				_fgcg := NewCT_TableColumn()
				if _cbdfge := d.DecodeElement(_fgcg, &_dbdged); _cbdfge != nil {
					return _cbdfge
				}
				_faeccb.TableColumn = append(_faeccb.TableColumn, _fgcg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TableColumns\u0020\u0025v", _dbdged.Name)
				if _gacga := d.Skip(); _gacga != nil {
					return _gacga
				}
			}
		case _f.EndElement:
			break _geagcc
		case _f.CharData:
		}
	}
	return nil
}
func (_eagea *CT_MdxKPI) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_eagea.PAttr = ST_MdxKPIProperty(1)
	for _, _cfefc := range start.Attr {
		if _cfefc.Name.Local == "n" {
			_edfea, _gaefe := _g.ParseUint(_cfefc.Value, 10, 32)
			if _gaefe != nil {
				return _gaefe
			}
			_eagea.NAttr = uint32(_edfea)
			continue
		}
		if _cfefc.Name.Local == "np" {
			_cfeb, _fbaef := _g.ParseUint(_cfefc.Value, 10, 32)
			if _fbaef != nil {
				return _fbaef
			}
			_eagea.NpAttr = uint32(_cfeb)
			continue
		}
		if _cfefc.Name.Local == "p" {
			_eagea.PAttr.UnmarshalXMLAttr(_cfefc)
			continue
		}
	}
	for {
		_afae, _gaefa := d.Token()
		if _gaefa != nil {
			return _bg.Errorf("parsing\u0020CT_MdxKPI:\u0020\u0025s", _gaefa)
		}
		if _effaf, _ebbce := _afae.(_f.EndElement); _ebbce && _effaf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_geb *CT_BooleanProperty) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _geb.ValAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_geb.ValAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Parameter and its children
func (_gceff *CT_Parameter) Validate() error { return _gceff.ValidateWithPath("CT_Parameter") }

// Validate validates the CT_MdxMemeberProp and its children
func (_dgdbaf *CT_MdxMemeberProp) Validate() error {
	return _dgdbaf.ValidateWithPath("CT_MdxMemeberProp")
}

// Validate validates the CT_TextPr and its children
func (_cegceb *CT_TextPr) Validate() error { return _cegceb.ValidateWithPath("CT_TextPr") }

type CT_Cols struct {

	// Column Width & Formatting
	Col []*CT_Col
}
type CT_FileVersion struct {

	// Application Name
	AppNameAttr *string

	// Last Edited Version
	LastEditedAttr *string

	// Lowest Edited Version
	LowestEditedAttr *string

	// Build Version
	RupBuildAttr *string

	// Code Name
	CodeNameAttr *string
}
type CT_Dimensions struct {

	// OLAP Dimensions Count
	CountAttr *uint32

	// OLAP Dimension
	Dimension []*CT_PivotDimension
}
type CT_OutlinePr struct {

	// Apply Styles in Outline
	ApplyStylesAttr *bool

	// Summary Below
	SummaryBelowAttr *bool

	// Summary Right
	SummaryRightAttr *bool

	// Show Outline Symbols
	ShowOutlineSymbolsAttr *bool
}
type CT_NumFmts struct {

	// Number Format Count
	CountAttr *uint32

	// Number Formats
	NumFmt []*CT_NumFmt
}

func NewCT_GroupLevel() *CT_GroupLevel { _geaab := &CT_GroupLevel{}; return _geaab }

type CT_Colors struct {

	// Color Indexes
	IndexedColors *CT_IndexedColors

	// MRU Colors
	MruColors *CT_MRUColors
}

// ValidateWithPath validates the CT_Break and its children, prefixing error messages with path
func (_fgc *CT_Break) ValidateWithPath(path string) error { return nil }
func (_afcgc ST_MdxKPIProperty) Validate() error          { return _afcgc.ValidateWithPath("") }
func NewCT_MetadataTypes() *CT_MetadataTypes              { _bcgec := &CT_MetadataTypes{}; return _bcgec }
func NewCT_CellWatches() *CT_CellWatches                  { _gebc := &CT_CellWatches{}; return _gebc }
func (_ecbbc *ST_GrowShrinkType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_eebea, _gdbeg := d.Token()
	if _gdbeg != nil {
		return _gdbeg
	}
	if _ecefg, _aaccad := _eebea.(_f.EndElement); _aaccad && _ecefg.Name == start.Name {
		*_ecbbc = 1
		return nil
	}
	if _bdega, _ccgcb := _eebea.(_f.CharData); !_ccgcb {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eebea)
	} else {
		switch string(_bdega) {
		case "":
			*_ecbbc = 0
		case "insertDelete":
			*_ecbbc = 1
		case "insertClear":
			*_ecbbc = 2
		case "overwriteClear":
			*_ecbbc = 3
		}
	}
	_eebea, _gdbeg = d.Token()
	if _gdbeg != nil {
		return _gdbeg
	}
	if _fcddd, _bbggf := _eebea.(_f.EndElement); _bbggf && _fcddd.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eebea)
}
func (_babec *CT_MergeCell) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _babec.RefAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TableStyleInfo and its children
func (_agaeag *CT_TableStyleInfo) Validate() error {
	return _agaeag.ValidateWithPath("CT_TableStyleInfo")
}

const (
	ST_CellFormulaTypeUnset     ST_CellFormulaType = 0
	ST_CellFormulaTypeNormal    ST_CellFormulaType = 1
	ST_CellFormulaTypeArray     ST_CellFormulaType = 2
	ST_CellFormulaTypeDataTable ST_CellFormulaType = 3
	ST_CellFormulaTypeShared    ST_CellFormulaType = 4
)

func (_ddcabc *CT_TableParts) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ddcabc.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_ddcabc.CountAttr)})
	}
	e.EncodeToken(start)
	if _ddcabc.TablePart != nil {
		_ffgea := _f.StartElement{Name: _f.Name{Local: "ma:tablePart"}}
		for _, _ebead := range _ddcabc.TablePart {
			e.EncodeElement(_ebead, _ffgea)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_RangeSet and its children
func (_bgdff *CT_RangeSet) Validate() error { return _bgdff.ValidateWithPath("CT_RangeSet") }

type CT_ColFields struct {

	// Repeated Items Count
	CountAttr *uint32

	// Field
	Field []*CT_Field
}

func (_abgbcf ST_TargetScreenSize) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_abgbcf.String(), start)
}
func (_fcaaad *ST_SmartTagShow) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_fcaaad = 0
	case "all":
		*_fcaaad = 1
	case "none":
		*_fcaaad = 2
	case "noIndicator":
		*_fcaaad = 3
	}
	return nil
}
func NewCT_RangePr() *CT_RangePr { _beaef := &CT_RangePr{}; return _beaef }

// ValidateWithPath validates the CT_QueryTableField and its children, prefixing error messages with path
func (_ageea *CT_QueryTableField) ValidateWithPath(path string) error {
	if _ageea.ExtLst != nil {
		if _ggbce := _ageea.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ggbce != nil {
			return _ggbce
		}
	}
	return nil
}
func (_eeefb *ST_CfvoType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dgcgcc, _dggdd := d.Token()
	if _dggdd != nil {
		return _dggdd
	}
	if _cddfac, _cbgac := _dgcgcc.(_f.EndElement); _cbgac && _cddfac.Name == start.Name {
		*_eeefb = 1
		return nil
	}
	if _fffeeb, _afceb := _dgcgcc.(_f.CharData); !_afceb {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dgcgcc)
	} else {
		switch string(_fffeeb) {
		case "":
			*_eeefb = 0
		case "num":
			*_eeefb = 1
		case "percent":
			*_eeefb = 2
		case "max":
			*_eeefb = 3
		case "min":
			*_eeefb = 4
		case "formula":
			*_eeefb = 5
		case "percentile":
			*_eeefb = 6
		}
	}
	_dgcgcc, _dggdd = d.Token()
	if _dggdd != nil {
		return _dggdd
	}
	if _gcdbfb, _cggbaa := _dgcgcc.(_f.EndElement); _cggbaa && _gcdbfb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dgcgcc)
}

const (
	ST_BorderStyleUnset            ST_BorderStyle = 0
	ST_BorderStyleNone             ST_BorderStyle = 1
	ST_BorderStyleThin             ST_BorderStyle = 2
	ST_BorderStyleMedium           ST_BorderStyle = 3
	ST_BorderStyleDashed           ST_BorderStyle = 4
	ST_BorderStyleDotted           ST_BorderStyle = 5
	ST_BorderStyleThick            ST_BorderStyle = 6
	ST_BorderStyleDouble           ST_BorderStyle = 7
	ST_BorderStyleHair             ST_BorderStyle = 8
	ST_BorderStyleMediumDashed     ST_BorderStyle = 9
	ST_BorderStyleDashDot          ST_BorderStyle = 10
	ST_BorderStyleMediumDashDot    ST_BorderStyle = 11
	ST_BorderStyleDashDotDot       ST_BorderStyle = 12
	ST_BorderStyleMediumDashDotDot ST_BorderStyle = 13
	ST_BorderStyleSlantDashDot     ST_BorderStyle = 14
)

func NewCT_WorkbookProtection() *CT_WorkbookProtection {
	_eaffeg := &CT_WorkbookProtection{}
	return _eaffeg
}
func (_bbegeg *CT_MdxKPI) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "n"}, Value: _bg.Sprintf("\u0025v", _bbegeg.NAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "np"}, Value: _bg.Sprintf("\u0025v", _bbegeg.NpAttr)})
	_baagae, _daeec := _bbegeg.PAttr.MarshalXMLAttr(_f.Name{Local: "p"})
	if _daeec != nil {
		return _daeec
	}
	start.Attr = append(start.Attr, _baagae)
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_RowFields() *CT_RowFields                            { _fgceg := &CT_RowFields{}; return _fgceg }
func (_egaad ST_ConditionalFormattingOperator) Validate() error { return _egaad.ValidateWithPath("") }
func NewQueryTable() *QueryTable {
	_bcdadc := &QueryTable{}
	_bcdadc.CT_QueryTable = *NewCT_QueryTable()
	return _bcdadc
}

type CT_TableStyles struct {

	// Table Style Count
	CountAttr *uint32

	// Default Table Style
	DefaultTableStyleAttr *string

	// Default Pivot Style
	DefaultPivotStyleAttr *string

	// Table Style
	TableStyle []*CT_TableStyle
}

func (_fecccc ST_SortMethod) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_fecccc.String(), start)
}
func NewCT_FileSharing() *CT_FileSharing { _bggcaf := &CT_FileSharing{}; return _bggcaf }

// Validate validates the CT_SmartTagTypes and its children
func (_edecg *CT_SmartTagTypes) Validate() error { return _edecg.ValidateWithPath("CT_SmartTagTypes") }

// Validate validates the CT_CacheField and its children
func (_gabc *CT_CacheField) Validate() error { return _gabc.ValidateWithPath("CT_CacheField") }
func NewCT_RevisionDefinedName() *CT_RevisionDefinedName {
	_cdfec := &CT_RevisionDefinedName{}
	return _cdfec
}

type CT_SheetIdMap struct {

	// Sheet Count
	CountAttr *uint32

	// Sheet Id
	SheetId []*CT_SheetId
}

func (_eff *CT_BooleanProperty) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dgfg := range start.Attr {
		if _dgfg.Name.Local == "val" {
			_edge, _gdda := _g.ParseBool(_dgfg.Value)
			if _gdda != nil {
				return _gdda
			}
			_eff.ValAttr = &_edge
			continue
		}
	}
	for {
		_dece, _cbg := d.Token()
		if _cbg != nil {
			return _bg.Errorf("parsing\u0020CT_BooleanProperty:\u0020\u0025s", _cbg)
		}
		if _bdd, _fdfg := _dece.(_f.EndElement); _fdfg && _bdd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bfbedc *CT_ExternalSheetNames) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_fccdf := _f.StartElement{Name: _f.Name{Local: "ma:sheetName"}}
	for _, _cebage := range _bfbedc.SheetName {
		e.EncodeElement(_cebage, _fccdf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Workbook and its children, prefixing error messages with path
func (_cdbdca *Workbook) ValidateWithPath(path string) error {
	if _eafcbf := _cdbdca.CT_Workbook.ValidateWithPath(path); _eafcbf != nil {
		return _eafcbf
	}
	return nil
}
func (_beggg *CT_Cfvo) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	_deead, _beeae := _beggg.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
	if _beeae != nil {
		return _beeae
	}
	start.Attr = append(start.Attr, _deead)
	if _beggg.ValAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", *_beggg.ValAttr)})
	}
	if _beggg.GteAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "gte"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_beggg.GteAttr))})
	}
	e.EncodeToken(start)
	if _beggg.ExtLst != nil {
		_ceba := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_beggg.ExtLst, _ceba)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_OleItem and its children
func (_dbedb *CT_OleItem) Validate() error        { return _dbedb.ValidateWithPath("CT_OleItem") }
func NewCT_CacheField() *CT_CacheField            { _addc := &CT_CacheField{}; return _addc }
func NewCT_IntProperty() *CT_IntProperty          { _dbbbb := &CT_IntProperty{}; return _dbbbb }
func (_fdcdf ST_PivotFilterType) Validate() error { return _fdcdf.ValidateWithPath("") }

type CT_CalculatedItems struct {

	// Calculated Item Formula Count
	CountAttr *uint32

	// Calculated Item
	CalculatedItem []*CT_CalculatedItem
}

func (_cfdbff ST_DvAspect) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bfgdac := _f.Attr{}
	_bfgdac.Name = name
	switch _cfdbff {
	case ST_DvAspectUnset:
		_bfgdac.Value = ""
	case ST_DvAspectDVASPECT_CONTENT:
		_bfgdac.Value = "DVASPECT_CONTENT"
	case ST_DvAspectDVASPECT_ICON:
		_bfgdac.Value = "DVASPECT_ICON"
	}
	return _bfgdac, nil
}
func NewCT_MdxSet() *CT_MdxSet { _afgga := &CT_MdxSet{}; return _afgga }
func (_gcecf *CT_RevisionHeader) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gcecf.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	_gcecf.SheetIdMap = NewCT_SheetIdMap()
	for _, _gebadd := range start.Attr {
		if _gebadd.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _gebadd.Name.Local == "id" || _gebadd.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _gebadd.Name.Local == "id" {
			_gdfac, _dcea := _gebadd.Value, error(nil)
			if _dcea != nil {
				return _dcea
			}
			_gcecf.IdAttr = _gdfac
			continue
		}
		if _gebadd.Name.Local == "guid" {
			_gcbbg, _bbfgb := _gebadd.Value, error(nil)
			if _bbfgb != nil {
				return _bbfgb
			}
			_gcecf.GuidAttr = _gcbbg
			continue
		}
		if _gebadd.Name.Local == "dateTime" {
			_bdcag, _ededg := ParseStdlibTime(_gebadd.Value)
			if _ededg != nil {
				return _ededg
			}
			_gcecf.DateTimeAttr = _bdcag
			continue
		}
		if _gebadd.Name.Local == "maxSheetId" {
			_bfdea, _cfgcde := _g.ParseUint(_gebadd.Value, 10, 32)
			if _cfgcde != nil {
				return _cfgcde
			}
			_gcecf.MaxSheetIdAttr = uint32(_bfdea)
			continue
		}
		if _gebadd.Name.Local == "userName" {
			_bbdebf, _fgced := _gebadd.Value, error(nil)
			if _fgced != nil {
				return _fgced
			}
			_gcecf.UserNameAttr = _bbdebf
			continue
		}
		if _gebadd.Name.Local == "minRId" {
			_afcfc, _bbgfaf := _g.ParseUint(_gebadd.Value, 10, 32)
			if _bbgfaf != nil {
				return _bbgfaf
			}
			_fcaae := uint32(_afcfc)
			_gcecf.MinRIdAttr = &_fcaae
			continue
		}
		if _gebadd.Name.Local == "maxRId" {
			_aadb, _geed := _g.ParseUint(_gebadd.Value, 10, 32)
			if _geed != nil {
				return _geed
			}
			_eddge := uint32(_aadb)
			_gcecf.MaxRIdAttr = &_eddge
			continue
		}
	}
_ecadd:
	for {
		_cfbfb, _cffbbg := d.Token()
		if _cffbbg != nil {
			return _cffbbg
		}
		switch _dgeea := _cfbfb.(type) {
		case _f.StartElement:
			switch _dgeea.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetIdMap"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetIdMap"}:
				if _babbg := d.DecodeElement(_gcecf.SheetIdMap, &_dgeea); _babbg != nil {
					return _babbg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "reviewedList"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "reviewedList"}:
				_gcecf.ReviewedList = NewCT_ReviewedRevisions()
				if _ffcbc := d.DecodeElement(_gcecf.ReviewedList, &_dgeea); _ffcbc != nil {
					return _ffcbc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gcecf.ExtLst = NewCT_ExtensionList()
				if _gfdade := d.DecodeElement(_gcecf.ExtLst, &_dgeea); _gfdade != nil {
					return _gfdade
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_RevisionHeader\u0020\u0025v", _dgeea.Name)
				if _geeff := d.Skip(); _geeff != nil {
					return _geeff
				}
			}
		case _f.EndElement:
			break _ecadd
		case _f.CharData:
		}
	}
	return nil
}
func (_dbfdcee ST_DataConsolidateFunction) String() string {
	switch _dbfdcee {
	case 0:
		return ""
	case 1:
		return "average"
	case 2:
		return "count"
	case 3:
		return "countNums"
	case 4:
		return "max"
	case 5:
		return "min"
	case 6:
		return "product"
	case 7:
		return "stdDev"
	case 8:
		return "stdDevp"
	case 9:
		return "sum"
	case 10:
		return "var"
	case 11:
		return "varp"
	}
	return ""
}
func (_geddfe ST_DynamicFilterType) Validate() error { return _geddfe.ValidateWithPath("") }
func (_bcafg ST_WebSourceType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bcafg.String(), start)
}
func NewCT_PivotCaches() *CT_PivotCaches { _eefbe := &CT_PivotCaches{}; return _eefbe }
func (_bbdag ST_FormatAction) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bbdag.String(), start)
}

// ValidateWithPath validates the CT_CustomFilters and its children, prefixing error messages with path
func (_gfef *CT_CustomFilters) ValidateWithPath(path string) error {
	for _baddd, _edeg := range _gfef.CustomFilter {
		if _gdcb := _edeg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCustomFilter\u005b\u0025d\u005d", path, _baddd)); _gdcb != nil {
			return _gdcb
		}
	}
	return nil
}
func NewCT_SheetFormatPr() *CT_SheetFormatPr { _cbaga := &CT_SheetFormatPr{}; return _cbaga }

type ST_TextVAlign byte

func (_dgfag *CT_CustomChartsheetViews) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _dgfag.CustomSheetView != nil {
		_bddda := _f.StartElement{Name: _f.Name{Local: "ma:customSheetView"}}
		for _, _dcfc := range _dgfag.CustomSheetView {
			e.EncodeElement(_dcfc, _bddda)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_VolTopicRef() *CT_VolTopicRef { _debcb := &CT_VolTopicRef{}; return _debcb }

type CT_Worksheet struct {

	// Worksheet Properties
	SheetPr *CT_SheetPr

	// Worksheet Dimensions
	Dimension *CT_SheetDimension

	// Sheet Views
	SheetViews *CT_SheetViews

	// Sheet Format Properties
	SheetFormatPr *CT_SheetFormatPr

	// Column Information
	Cols []*CT_Cols

	// Sheet Data
	SheetData *CT_SheetData

	// Sheet Calculation Properties
	SheetCalcPr *CT_SheetCalcPr

	// Sheet Protection
	SheetProtection *CT_SheetProtection

	// Protected Ranges
	ProtectedRanges *CT_ProtectedRanges

	// Scenarios
	Scenarios *CT_Scenarios

	// AutoFilter
	AutoFilter *CT_AutoFilter

	// Sort State
	SortState *CT_SortState

	// Data Consolidate
	DataConsolidate *CT_DataConsolidate

	// Custom Sheet Views
	CustomSheetViews *CT_CustomSheetViews

	// Merge Cells
	MergeCells *CT_MergeCells

	// Phonetic Properties
	PhoneticPr *CT_PhoneticPr

	// Conditional Formatting
	ConditionalFormatting []*CT_ConditionalFormatting

	// Data Validations
	DataValidations *CT_DataValidations

	// Hyperlinks
	Hyperlinks *CT_Hyperlinks

	// Print Options
	PrintOptions *CT_PrintOptions

	// Page Margins
	PageMargins *CT_PageMargins

	// Page Setup Settings
	PageSetup *CT_PageSetup

	// Header and Footer Settings
	HeaderFooter *CT_HeaderFooter

	// Horizontal Page Breaks
	RowBreaks *CT_PageBreak

	// Vertical Page Breaks
	ColBreaks *CT_PageBreak

	// Custom Properties
	CustomProperties *CT_CustomProperties

	// Cell Watch Items
	CellWatches *CT_CellWatches

	// Ignored Errors
	IgnoredErrors *CT_IgnoredErrors

	// Smart Tags
	SmartTags *CT_SmartTags

	// Drawing
	Drawing *CT_Drawing

	// Legacy Drawing
	LegacyDrawing *CT_LegacyDrawing

	// Legacy Drawing Header Footer
	LegacyDrawingHF *CT_LegacyDrawing
	DrawingHF       *CT_DrawingHF

	// Background Image
	Picture    *CT_SheetBackgroundPicture
	OleObjects *CT_OleObjects

	// Embedded Controls
	Controls *CT_Controls

	// Web Publishing Items
	WebPublishItems *CT_WebPublishItems

	// Table Parts
	TableParts *CT_TableParts

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

// ValidateWithPath validates the CT_ExternalSheetData and its children, prefixing error messages with path
func (_dgfb *CT_ExternalSheetData) ValidateWithPath(path string) error {
	for _dfgbg, _eedg := range _dgfb.Row {
		if _gebd := _eedg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRow\u005b\u0025d\u005d", path, _dfgbg)); _gebd != nil {
			return _gebd
		}
	}
	return nil
}
func (_adbgd *CT_Set) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _adbgd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_adbgd.CountAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "maxRank"}, Value: _bg.Sprintf("\u0025v", _adbgd.MaxRankAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "setDefinition"}, Value: _bg.Sprintf("\u0025v", _adbgd.SetDefinitionAttr)})
	if _adbgd.SortTypeAttr != ST_SortTypeUnset {
		_cdbac, _fdfdd := _adbgd.SortTypeAttr.MarshalXMLAttr(_f.Name{Local: "sortType"})
		if _fdfdd != nil {
			return _fdfdd
		}
		start.Attr = append(start.Attr, _cdbac)
	}
	if _adbgd.QueryFailedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "queryFailed"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_adbgd.QueryFailedAttr))})
	}
	e.EncodeToken(start)
	if _adbgd.Tpls != nil {
		_aggab := _f.StartElement{Name: _f.Name{Local: "ma:tpls"}}
		for _, _fdfb := range _adbgd.Tpls {
			e.EncodeElement(_fdfb, _aggab)
		}
	}
	if _adbgd.SortByTuple != nil {
		_acece := _f.StartElement{Name: _f.Name{Local: "ma:sortByTuple"}}
		e.EncodeElement(_adbgd.SortByTuple, _acece)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_CellStyles and its children
func (_fce *CT_CellStyles) Validate() error { return _fce.ValidateWithPath("CT_CellStyles") }
func (_dgeff ST_FieldSortType) ValidateWithPath(path string) error {
	switch _dgeff {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dgeff))
	}
	return nil
}
func (_cdcab *CT_RevisionComment) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetId"}, Value: _bg.Sprintf("\u0025v", _cdcab.SheetIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cell"}, Value: _bg.Sprintf("\u0025v", _cdcab.CellAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "guid"}, Value: _bg.Sprintf("\u0025v", _cdcab.GuidAttr)})
	if _cdcab.ActionAttr != ST_RevisionActionUnset {
		_efbbge, _abbdbd := _cdcab.ActionAttr.MarshalXMLAttr(_f.Name{Local: "action"})
		if _abbdbd != nil {
			return _abbdbd
		}
		start.Attr = append(start.Attr, _efbbge)
	}
	if _cdcab.AlwaysShowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "alwaysShow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cdcab.AlwaysShowAttr))})
	}
	if _cdcab.OldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "old"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cdcab.OldAttr))})
	}
	if _cdcab.HiddenRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hiddenRow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cdcab.HiddenRowAttr))})
	}
	if _cdcab.HiddenColumnAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hiddenColumn"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cdcab.HiddenColumnAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "author"}, Value: _bg.Sprintf("\u0025v", _cdcab.AuthorAttr)})
	if _cdcab.OldLengthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldLength"}, Value: _bg.Sprintf("\u0025v", *_cdcab.OldLengthAttr)})
	}
	if _cdcab.NewLengthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "newLength"}, Value: _bg.Sprintf("\u0025v", *_cdcab.NewLengthAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ffdbd *ST_FieldSortType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dcbcbc, _egffbb := d.Token()
	if _egffbb != nil {
		return _egffbb
	}
	if _acbef, _dbbfdg := _dcbcbc.(_f.EndElement); _dbbfdg && _acbef.Name == start.Name {
		*_ffdbd = 1
		return nil
	}
	if _fbdag, _afaaf := _dcbcbc.(_f.CharData); !_afaaf {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dcbcbc)
	} else {
		switch string(_fbdag) {
		case "":
			*_ffdbd = 0
		case "manual":
			*_ffdbd = 1
		case "ascending":
			*_ffdbd = 2
		case "descending":
			*_ffdbd = 3
		}
	}
	_dcbcbc, _egffbb = d.Token()
	if _egffbb != nil {
		return _egffbb
	}
	if _badgdd, _gffdd := _dcbcbc.(_f.EndElement); _gffdd && _badgdd.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dcbcbc)
}

// Validate validates the CT_FontScheme and its children
func (_fcfcfe *CT_FontScheme) Validate() error { return _fcfcfe.ValidateWithPath("CT_FontScheme") }

const (
	ST_VisibilityUnset      ST_Visibility = 0
	ST_VisibilityVisible    ST_Visibility = 1
	ST_VisibilityHidden     ST_Visibility = 2
	ST_VisibilityVeryHidden ST_Visibility = 3
)

func (_ccabdd ST_ExternalConnectionType) String() string {
	switch _ccabdd {
	case 0:
		return ""
	case 1:
		return "general"
	case 2:
		return "text"
	case 3:
		return "MDY"
	case 4:
		return "DMY"
	case 5:
		return "YMD"
	case 6:
		return "MYD"
	case 7:
		return "DYM"
	case 8:
		return "YDM"
	case 9:
		return "skip"
	case 10:
		return "EMD"
	}
	return ""
}
func NewCT_CustomProperty() *CT_CustomProperty { _debe := &CT_CustomProperty{}; return _debe }
func NewCT_MdxMemeberProp() *CT_MdxMemeberProp { _dagag := &CT_MdxMemeberProp{}; return _dagag }

// ValidateWithPath validates the CT_PivotFields and its children, prefixing error messages with path
func (_ggbeg *CT_PivotFields) ValidateWithPath(path string) error {
	for _fcffc, _bfcc := range _ggbeg.PivotField {
		if _dgfgg := _bfcc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fPivotField\u005b\u0025d\u005d", path, _fcffc)); _dgfgg != nil {
			return _dgfgg
		}
	}
	return nil
}
func (_gacd *CT_PageItem) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dafdf := range start.Attr {
		if _dafdf.Name.Local == "name" {
			_aebce, _adgce := _dafdf.Value, error(nil)
			if _adgce != nil {
				return _adgce
			}
			_gacd.NameAttr = _aebce
			continue
		}
	}
	for {
		_faaagc, _ggdege := d.Token()
		if _ggdege != nil {
			return _bg.Errorf("parsing\u0020CT_PageItem:\u0020\u0025s", _ggdege)
		}
		if _edggf, _agbdd := _faaagc.(_f.EndElement); _agbdd && _edggf.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_ExternalReferences and its children
func (_ecedb *CT_ExternalReferences) Validate() error {
	return _ecedb.ValidateWithPath("CT_ExternalReferences")
}
func (_egge *CT_MdxSet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abdaa := range start.Attr {
		if _abdaa.Name.Local == "ns" {
			_eecb, _aefae := _g.ParseUint(_abdaa.Value, 10, 32)
			if _aefae != nil {
				return _aefae
			}
			_egge.NsAttr = uint32(_eecb)
			continue
		}
		if _abdaa.Name.Local == "c" {
			_dgbg, _dgcga := _g.ParseUint(_abdaa.Value, 10, 32)
			if _dgcga != nil {
				return _dgcga
			}
			_fbadd := uint32(_dgbg)
			_egge.CAttr = &_fbadd
			continue
		}
		if _abdaa.Name.Local == "o" {
			_egge.OAttr.UnmarshalXMLAttr(_abdaa)
			continue
		}
	}
_ffgga:
	for {
		_dagfb, _gbecg := d.Token()
		if _gbecg != nil {
			return _gbecg
		}
		switch _dfdbf := _dagfb.(type) {
		case _f.StartElement:
			switch _dfdbf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "n"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "n"}:
				_fdbeeda := NewCT_MetadataStringIndex()
				if _aaeba := d.DecodeElement(_fdbeeda, &_dfdbf); _aaeba != nil {
					return _aaeba
				}
				_egge.N = append(_egge.N, _fdbeeda)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_MdxSet \u0025v", _dfdbf.Name)
				if _gdfe := d.Skip(); _gdfe != nil {
					return _gdfe
				}
			}
		case _f.EndElement:
			break _ffgga
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Font and its children
func (_fgdc *CT_Font) Validate() error { return _fgdc.ValidateWithPath("CT_Font") }

// ValidateWithPath validates the CT_ExternalLink and its children, prefixing error messages with path
func (_ffda *CT_ExternalLink) ValidateWithPath(path string) error {
	if _ffda.Choice != nil {
		if _gaadc := _ffda.Choice.ValidateWithPath(path + "\u002fChoice"); _gaadc != nil {
			return _gaadc
		}
	}
	if _ffda.ExtLst != nil {
		if _egbgea := _ffda.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _egbgea != nil {
			return _egbgea
		}
	}
	return nil
}
func NewMetadata() *Metadata {
	_dfecc := &Metadata{}
	_dfecc.CT_Metadata = *NewCT_Metadata()
	return _dfecc
}

// ValidateWithPath validates the CT_WorksheetSource and its children, prefixing error messages with path
func (_ddcffed *CT_WorksheetSource) ValidateWithPath(path string) error { return nil }
func (_ccebbc ST_CredMethod) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_ccebbc.String(), start)
}

// Validate validates the CT_ExternalSheetName and its children
func (_cfcbf *CT_ExternalSheetName) Validate() error {
	return _cfcbf.ValidateWithPath("CT_ExternalSheetName")
}
func (_gbbaaa *CT_Scenarios) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gbbaaa.CurrentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "current"}, Value: _bg.Sprintf("\u0025v", *_gbbaaa.CurrentAttr)})
	}
	if _gbbaaa.ShowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "show"}, Value: _bg.Sprintf("\u0025v", *_gbbaaa.ShowAttr)})
	}
	if _gbbaaa.SqrefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sqref"}, Value: _bg.Sprintf("\u0025v", *_gbbaaa.SqrefAttr)})
	}
	e.EncodeToken(start)
	_baagb := _f.StartElement{Name: _f.Name{Local: "ma:scenario"}}
	for _, _bfaae := range _gbbaaa.Scenario {
		e.EncodeElement(_bfaae, _baagb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_DefinedNames and its children
func (_acdbd *CT_DefinedNames) Validate() error { return _acdbd.ValidateWithPath("CT_DefinedNames") }

// ValidateWithPath validates the CT_PatternFill and its children, prefixing error messages with path
func (_eeac *CT_PatternFill) ValidateWithPath(path string) error {
	if _ccbga := _eeac.PatternTypeAttr.ValidateWithPath(path + "\u002fPatternTypeAttr"); _ccbga != nil {
		return _ccbga
	}
	if _eeac.FgColor != nil {
		if _eddfg := _eeac.FgColor.ValidateWithPath(path + "\u002fFgColor"); _eddfg != nil {
			return _eddfg
		}
	}
	if _eeac.BgColor != nil {
		if _dbdbd := _eeac.BgColor.ValidateWithPath(path + "\u002fBgColor"); _dbdbd != nil {
			return _dbdbd
		}
	}
	return nil
}
func NewConnections() *Connections {
	_bdgcb := &Connections{}
	_bdgcb.CT_Connections = *NewCT_Connections()
	return _bdgcb
}
func (_ebcge *ST_SheetState) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fdcdc, _agbace := d.Token()
	if _agbace != nil {
		return _agbace
	}
	if _gcfef, _adafa := _fdcdc.(_f.EndElement); _adafa && _gcfef.Name == start.Name {
		*_ebcge = 1
		return nil
	}
	if _fbffd, _aegaf := _fdcdc.(_f.CharData); !_aegaf {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fdcdc)
	} else {
		switch string(_fbffd) {
		case "":
			*_ebcge = 0
		case "visible":
			*_ebcge = 1
		case "hidden":
			*_ebcge = 2
		case "veryHidden":
			*_ebcge = 3
		}
	}
	_fdcdc, _agbace = d.Token()
	if _agbace != nil {
		return _agbace
	}
	if _agfab, _geafc := _fdcdc.(_f.EndElement); _geafc && _agfab.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fdcdc)
}
func (_bacgc *CT_WebPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bacgc.XmlAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xml"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bacgc.XmlAttr))})
	}
	if _bacgc.SourceDataAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sourceData"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bacgc.SourceDataAttr))})
	}
	if _bacgc.ParsePreAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "parsePre"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bacgc.ParsePreAttr))})
	}
	if _bacgc.ConsecutiveAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "consecutive"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bacgc.ConsecutiveAttr))})
	}
	if _bacgc.FirstRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "firstRow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bacgc.FirstRowAttr))})
	}
	if _bacgc.Xl97Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xl97"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bacgc.Xl97Attr))})
	}
	if _bacgc.TextDatesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "textDates"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bacgc.TextDatesAttr))})
	}
	if _bacgc.Xl2000Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xl2000"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bacgc.Xl2000Attr))})
	}
	if _bacgc.UrlAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "url"}, Value: _bg.Sprintf("\u0025v", *_bacgc.UrlAttr)})
	}
	if _bacgc.PostAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "post"}, Value: _bg.Sprintf("\u0025v", *_bacgc.PostAttr)})
	}
	if _bacgc.HtmlTablesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "htmlTables"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bacgc.HtmlTablesAttr))})
	}
	if _bacgc.HtmlFormatAttr != ST_HtmlFmtUnset {
		_baccb, _ffcca := _bacgc.HtmlFormatAttr.MarshalXMLAttr(_f.Name{Local: "htmlFormat"})
		if _ffcca != nil {
			return _ffcca
		}
		start.Attr = append(start.Attr, _baccb)
	}
	if _bacgc.EditPageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "editPage"}, Value: _bg.Sprintf("\u0025v", *_bacgc.EditPageAttr)})
	}
	e.EncodeToken(start)
	if _bacgc.Tables != nil {
		_fegef := _f.StartElement{Name: _f.Name{Local: "ma:tables"}}
		e.EncodeElement(_bacgc.Tables, _fegef)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gaggb *ST_PivotAreaType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fcfcc, _dcece := d.Token()
	if _dcece != nil {
		return _dcece
	}
	if _aaccg, _fbbda := _fcfcc.(_f.EndElement); _fbbda && _aaccg.Name == start.Name {
		*_gaggb = 1
		return nil
	}
	if _dccgee, _gfacc := _fcfcc.(_f.CharData); !_gfacc {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fcfcc)
	} else {
		switch string(_dccgee) {
		case "":
			*_gaggb = 0
		case "none":
			*_gaggb = 1
		case "normal":
			*_gaggb = 2
		case "data":
			*_gaggb = 3
		case "all":
			*_gaggb = 4
		case "origin":
			*_gaggb = 5
		case "button":
			*_gaggb = 6
		case "topEnd":
			*_gaggb = 7
		case "topRight":
			*_gaggb = 8
		}
	}
	_fcfcc, _dcece = d.Token()
	if _dcece != nil {
		return _dcece
	}
	if _ecbadg, _gecgd := _fcfcc.(_f.EndElement); _gecgd && _ecbadg.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fcfcc)
}
func (_cegbf ST_DataConsolidateFunction) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_cegbf.String(), start)
}
func (_bccfd *ST_GradientType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bccfd = 0
	case "linear":
		*_bccfd = 1
	case "path":
		*_bccfd = 2
	}
	return nil
}

type CT_CalcCell struct {

	// Cell Reference
	RAttr   *string
	RefAttr *string

	// Sheet Id
	IAttr *int32

	// Child Chain
	SAttr *bool

	// New Dependency Level
	LAttr *bool

	// New Thread
	TAttr *bool

	// Array
	AAttr *bool
}

func (_ggd *CT_CacheField) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ggde := range start.Attr {
		if _ggde.Name.Local == "hierarchy" {
			_beac, _affe := _g.ParseInt(_ggde.Value, 10, 32)
			if _affe != nil {
				return _affe
			}
			_dgb := int32(_beac)
			_ggd.HierarchyAttr = &_dgb
			continue
		}
		if _ggde.Name.Local == "level" {
			_gab, _aeba := _g.ParseUint(_ggde.Value, 10, 32)
			if _aeba != nil {
				return _aeba
			}
			_caegc := uint32(_gab)
			_ggd.LevelAttr = &_caegc
			continue
		}
		if _ggde.Name.Local == "caption" {
			_fgea, _baa := _ggde.Value, error(nil)
			if _baa != nil {
				return _baa
			}
			_ggd.CaptionAttr = &_fgea
			continue
		}
		if _ggde.Name.Local == "databaseField" {
			_gbeae, _fcc := _g.ParseBool(_ggde.Value)
			if _fcc != nil {
				return _fcc
			}
			_ggd.DatabaseFieldAttr = &_gbeae
			continue
		}
		if _ggde.Name.Local == "serverField" {
			_bgc, _dbf := _g.ParseBool(_ggde.Value)
			if _dbf != nil {
				return _dbf
			}
			_ggd.ServerFieldAttr = &_bgc
			continue
		}
		if _ggde.Name.Local == "numFmtId" {
			_acb, _daeg := _g.ParseUint(_ggde.Value, 10, 32)
			if _daeg != nil {
				return _daeg
			}
			_aae := uint32(_acb)
			_ggd.NumFmtIdAttr = &_aae
			continue
		}
		if _ggde.Name.Local == "formula" {
			_gbd, _bec := _ggde.Value, error(nil)
			if _bec != nil {
				return _bec
			}
			_ggd.FormulaAttr = &_gbd
			continue
		}
		if _ggde.Name.Local == "sqlType" {
			_fba, _cef := _g.ParseInt(_ggde.Value, 10, 32)
			if _cef != nil {
				return _cef
			}
			_baag := int32(_fba)
			_ggd.SqlTypeAttr = &_baag
			continue
		}
		if _ggde.Name.Local == "name" {
			_dff, _dgge := _ggde.Value, error(nil)
			if _dgge != nil {
				return _dgge
			}
			_ggd.NameAttr = _dff
			continue
		}
		if _ggde.Name.Local == "propertyName" {
			_egb, _bgg := _ggde.Value, error(nil)
			if _bgg != nil {
				return _bgg
			}
			_ggd.PropertyNameAttr = &_egb
			continue
		}
		if _ggde.Name.Local == "uniqueList" {
			_badf, _cfb := _g.ParseBool(_ggde.Value)
			if _cfb != nil {
				return _cfb
			}
			_ggd.UniqueListAttr = &_badf
			continue
		}
		if _ggde.Name.Local == "mappingCount" {
			_ggece, _fbbb := _g.ParseUint(_ggde.Value, 10, 32)
			if _fbbb != nil {
				return _fbbb
			}
			_aebd := uint32(_ggece)
			_ggd.MappingCountAttr = &_aebd
			continue
		}
		if _ggde.Name.Local == "memberPropertyField" {
			_fec, _dada := _g.ParseBool(_ggde.Value)
			if _dada != nil {
				return _dada
			}
			_ggd.MemberPropertyFieldAttr = &_fec
			continue
		}
	}
_abed:
	for {
		_cec, _cefd := d.Token()
		if _cefd != nil {
			return _cefd
		}
		switch _dbae := _cec.(type) {
		case _f.StartElement:
			switch _dbae.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sharedItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sharedItems"}:
				_ggd.SharedItems = NewCT_SharedItems()
				if _aaeg := d.DecodeElement(_ggd.SharedItems, &_dbae); _aaeg != nil {
					return _aaeg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fieldGroup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fieldGroup"}:
				_ggd.FieldGroup = NewCT_FieldGroup()
				if _ddcc := d.DecodeElement(_ggd.FieldGroup, &_dbae); _ddcc != nil {
					return _ddcc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "mpMap"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "mpMap"}:
				_baea := NewCT_X()
				if _beg := d.DecodeElement(_baea, &_dbae); _beg != nil {
					return _beg
				}
				_ggd.MpMap = append(_ggd.MpMap, _baea)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ggd.ExtLst = NewCT_ExtensionList()
				if _fdbd := d.DecodeElement(_ggd.ExtLst, &_dbae); _fdbd != nil {
					return _fdbd
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_CacheField \u0025v", _dbae.Name)
				if _cac := d.Skip(); _cac != nil {
					return _cac
				}
			}
		case _f.EndElement:
			break _abed
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_ServerFormats() *CT_ServerFormats { _efcabc := &CT_ServerFormats{}; return _efcabc }

const (
	ST_IconSetTypeUnset           ST_IconSetType = 0
	ST_IconSetType3Arrows         ST_IconSetType = 1
	ST_IconSetType3ArrowsGray     ST_IconSetType = 2
	ST_IconSetType3Flags          ST_IconSetType = 3
	ST_IconSetType3TrafficLights1 ST_IconSetType = 4
	ST_IconSetType3TrafficLights2 ST_IconSetType = 5
	ST_IconSetType3Signs          ST_IconSetType = 6
	ST_IconSetType3Symbols        ST_IconSetType = 7
	ST_IconSetType3Symbols2       ST_IconSetType = 8
	ST_IconSetType4Arrows         ST_IconSetType = 9
	ST_IconSetType4ArrowsGray     ST_IconSetType = 10
	ST_IconSetType4RedToBlack     ST_IconSetType = 11
	ST_IconSetType4Rating         ST_IconSetType = 12
	ST_IconSetType4TrafficLights  ST_IconSetType = 13
	ST_IconSetType5Arrows         ST_IconSetType = 14
	ST_IconSetType5ArrowsGray     ST_IconSetType = 15
	ST_IconSetType5Rating         ST_IconSetType = 16
	ST_IconSetType5Quarters       ST_IconSetType = 17
)

func NewCT_Number() *CT_Number { _affag := &CT_Number{}; return _affag }
func (_eddbe ST_Scope) String() string {
	switch _eddbe {
	case 0:
		return ""
	case 1:
		return "selection"
	case 2:
		return "data"
	case 3:
		return "field"
	}
	return ""
}
func (_dgecc ST_PhoneticAlignment) Validate() error { return _dgecc.ValidateWithPath("") }
func (_gfeff *CT_DynamicFilter) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gfeff.TypeAttr = ST_DynamicFilterType(1)
	for _, _fcdgd := range start.Attr {
		if _fcdgd.Name.Local == "type" {
			_gfeff.TypeAttr.UnmarshalXMLAttr(_fcdgd)
			continue
		}
		if _fcdgd.Name.Local == "val" {
			_cebgf, _ddaaca := _g.ParseFloat(_fcdgd.Value, 64)
			if _ddaaca != nil {
				return _ddaaca
			}
			_gfeff.ValAttr = &_cebgf
			continue
		}
		if _fcdgd.Name.Local == "valIso" {
			_ebbb, _cbedg := ParseStdlibTime(_fcdgd.Value)
			if _cbedg != nil {
				return _cbedg
			}
			_gfeff.ValIsoAttr = &_ebbb
			continue
		}
		if _fcdgd.Name.Local == "maxVal" {
			_bfdcc, _cggce := _g.ParseFloat(_fcdgd.Value, 64)
			if _cggce != nil {
				return _cggce
			}
			_gfeff.MaxValAttr = &_bfdcc
			continue
		}
		if _fcdgd.Name.Local == "maxValIso" {
			_deffe, _afece := ParseStdlibTime(_fcdgd.Value)
			if _afece != nil {
				return _afece
			}
			_gfeff.MaxValIsoAttr = &_deffe
			continue
		}
	}
	for {
		_agcf, _aefg := d.Token()
		if _aefg != nil {
			return _bg.Errorf("parsing\u0020CT_DynamicFilter: \u0025s", _aefg)
		}
		if _fgafd, _gbcf := _agcf.(_f.EndElement); _gbcf && _fgafd.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_RevisionAutoFormatting and its children
func (_edfbf *CT_RevisionAutoFormatting) Validate() error {
	return _edfbf.ValidateWithPath("CT_RevisionAutoFormatting")
}
func (_cgfeg *CT_PageSetup) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cgfeg.PaperSizeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "paperSize"}, Value: _bg.Sprintf("\u0025v", *_cgfeg.PaperSizeAttr)})
	}
	if _cgfeg.PaperHeightAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "paperHeight"}, Value: _bg.Sprintf("\u0025v", *_cgfeg.PaperHeightAttr)})
	}
	if _cgfeg.PaperWidthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "paperWidth"}, Value: _bg.Sprintf("\u0025v", *_cgfeg.PaperWidthAttr)})
	}
	if _cgfeg.ScaleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "scale"}, Value: _bg.Sprintf("\u0025v", *_cgfeg.ScaleAttr)})
	}
	if _cgfeg.FirstPageNumberAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "firstPageNumber"}, Value: _bg.Sprintf("\u0025v", *_cgfeg.FirstPageNumberAttr)})
	}
	if _cgfeg.FitToWidthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fitToWidth"}, Value: _bg.Sprintf("\u0025v", *_cgfeg.FitToWidthAttr)})
	}
	if _cgfeg.FitToHeightAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fitToHeight"}, Value: _bg.Sprintf("\u0025v", *_cgfeg.FitToHeightAttr)})
	}
	if _cgfeg.PageOrderAttr != ST_PageOrderUnset {
		_eddfc, _cbdgf := _cgfeg.PageOrderAttr.MarshalXMLAttr(_f.Name{Local: "pageOrder"})
		if _cbdgf != nil {
			return _cbdgf
		}
		start.Attr = append(start.Attr, _eddfc)
	}
	if _cgfeg.OrientationAttr != ST_OrientationUnset {
		_deggc, _abefg := _cgfeg.OrientationAttr.MarshalXMLAttr(_f.Name{Local: "orientation"})
		if _abefg != nil {
			return _abefg
		}
		start.Attr = append(start.Attr, _deggc)
	}
	if _cgfeg.UsePrinterDefaultsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "usePrinterDefaults"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cgfeg.UsePrinterDefaultsAttr))})
	}
	if _cgfeg.BlackAndWhiteAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "blackAndWhite"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cgfeg.BlackAndWhiteAttr))})
	}
	if _cgfeg.DraftAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "draft"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cgfeg.DraftAttr))})
	}
	if _cgfeg.CellCommentsAttr != ST_CellCommentsUnset {
		_fcaaf, _cegag := _cgfeg.CellCommentsAttr.MarshalXMLAttr(_f.Name{Local: "cellComments"})
		if _cegag != nil {
			return _cegag
		}
		start.Attr = append(start.Attr, _fcaaf)
	}
	if _cgfeg.UseFirstPageNumberAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "useFirstPageNumber"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cgfeg.UseFirstPageNumberAttr))})
	}
	if _cgfeg.ErrorsAttr != ST_PrintErrorUnset {
		_beca, _eeeggd := _cgfeg.ErrorsAttr.MarshalXMLAttr(_f.Name{Local: "errors"})
		if _eeeggd != nil {
			return _eeeggd
		}
		start.Attr = append(start.Attr, _beca)
	}
	if _cgfeg.HorizontalDpiAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "horizontalDpi"}, Value: _bg.Sprintf("\u0025v", *_cgfeg.HorizontalDpiAttr)})
	}
	if _cgfeg.VerticalDpiAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "verticalDpi"}, Value: _bg.Sprintf("\u0025v", *_cgfeg.VerticalDpiAttr)})
	}
	if _cgfeg.CopiesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "copies"}, Value: _bg.Sprintf("\u0025v", *_cgfeg.CopiesAttr)})
	}
	if _cgfeg.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", *_cgfeg.IdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_PivotArea and its children
func (_dgfe *CT_PivotArea) Validate() error { return _dgfe.ValidateWithPath("CT_PivotArea") }
func (_adbge ST_FileType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bfdfaa := _f.Attr{}
	_bfdfaa.Name = name
	switch _adbge {
	case ST_FileTypeUnset:
		_bfdfaa.Value = ""
	case ST_FileTypeMac:
		_bfdfaa.Value = "mac"
	case ST_FileTypeWin:
		_bfdfaa.Value = "win"
	case ST_FileTypeDos:
		_bfdfaa.Value = "dos"
	case ST_FileTypeLin:
		_bfdfaa.Value = "lin"
	case ST_FileTypeOther:
		_bfdfaa.Value = "other"
	}
	return _bfdfaa, nil
}
func NewCT_Dxfs() *CT_Dxfs { _ggbgb := &CT_Dxfs{}; return _ggbgb }
func (_bcccc ST_DynamicFilterType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bcccc.String(), start)
}

// ValidateWithPath validates the CT_FilterColumn and its children, prefixing error messages with path
func (_dbff *CT_FilterColumn) ValidateWithPath(path string) error {
	if _dbff.Filters != nil {
		if _dggbd := _dbff.Filters.ValidateWithPath(path + "\u002fFilters"); _dggbd != nil {
			return _dggbd
		}
	}
	if _dbff.Top10 != nil {
		if _ceead := _dbff.Top10.ValidateWithPath(path + "\u002fTop10"); _ceead != nil {
			return _ceead
		}
	}
	if _dbff.CustomFilters != nil {
		if _cadce := _dbff.CustomFilters.ValidateWithPath(path + "\u002fCustomFilters"); _cadce != nil {
			return _cadce
		}
	}
	if _dbff.DynamicFilter != nil {
		if _dbdc := _dbff.DynamicFilter.ValidateWithPath(path + "\u002fDynamicFilter"); _dbdc != nil {
			return _dbdc
		}
	}
	if _dbff.ColorFilter != nil {
		if _cgbe := _dbff.ColorFilter.ValidateWithPath(path + "\u002fColorFilter"); _cgbe != nil {
			return _cgbe
		}
	}
	if _dbff.IconFilter != nil {
		if _ggbgd := _dbff.IconFilter.ValidateWithPath(path + "/IconFilter"); _ggbgd != nil {
			return _ggbgd
		}
	}
	if _dbff.ExtLst != nil {
		if _cfbb := _dbff.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cfbb != nil {
			return _cfbb
		}
	}
	return nil
}
func (_aaaega *CT_Record) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_fdbfd:
	for {
		_cageae, _dcfab := d.Token()
		if _dcfab != nil {
			return _dcfab
		}
		switch _cgfge := _cageae.(type) {
		case _f.StartElement:
			switch _cgfge.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "m"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "m"}:
				_fgddc := NewCT_Missing()
				if _efeccg := d.DecodeElement(_fgddc, &_cgfge); _efeccg != nil {
					return _efeccg
				}
				_aaaega.M = append(_aaaega.M, _fgddc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "n"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "n"}:
				_ggadc := NewCT_Number()
				if _abbed := d.DecodeElement(_ggadc, &_cgfge); _abbed != nil {
					return _abbed
				}
				_aaaega.N = append(_aaaega.N, _ggadc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "b"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "b"}:
				_fbbbf := NewCT_Boolean()
				if _beecb := d.DecodeElement(_fbbbf, &_cgfge); _beecb != nil {
					return _beecb
				}
				_aaaega.B = append(_aaaega.B, _fbbbf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "e"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "e"}:
				_egcab := NewCT_Error()
				if _fffga := d.DecodeElement(_egcab, &_cgfge); _fffga != nil {
					return _fffga
				}
				_aaaega.E = append(_aaaega.E, _egcab)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "s"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "s"}:
				_fggec := NewCT_String()
				if _bdcdc := d.DecodeElement(_fggec, &_cgfge); _bdcdc != nil {
					return _bdcdc
				}
				_aaaega.S = append(_aaaega.S, _fggec)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "d"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "d"}:
				_ggedb := NewCT_DateTime()
				if _bbeaf := d.DecodeElement(_ggedb, &_cgfge); _bbeaf != nil {
					return _bbeaf
				}
				_aaaega.D = append(_aaaega.D, _ggedb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "x"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "x"}:
				_cafdb := NewCT_Index()
				if _gcfea := d.DecodeElement(_cafdb, &_cgfge); _gcfea != nil {
					return _gcfea
				}
				_aaaega.X = append(_aaaega.X, _cafdb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_Record \u0025v", _cgfge.Name)
				if _dafbb := d.Skip(); _dafbb != nil {
					return _dafbb
				}
			}
		case _f.EndElement:
			break _fdbfd
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_Parameters() *CT_Parameters { _eeabd := &CT_Parameters{}; return _eeabd }
func (_dgfge *ST_Qualifier) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bbfag, _cfgfae := d.Token()
	if _cfgfae != nil {
		return _cfgfae
	}
	if _dbgee, _decag := _bbfag.(_f.EndElement); _decag && _dbgee.Name == start.Name {
		*_dgfge = 1
		return nil
	}
	if _eegefc, _dcbdb := _bbfag.(_f.CharData); !_dcbdb {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bbfag)
	} else {
		switch string(_eegefc) {
		case "":
			*_dgfge = 0
		case "doubleQuote":
			*_dgfge = 1
		case "singleQuote":
			*_dgfge = 2
		case "none":
			*_dgfge = 3
		}
	}
	_bbfag, _cfgfae = d.Token()
	if _cfgfae != nil {
		return _cfgfae
	}
	if _bcaed, _dbcca := _bbfag.(_f.EndElement); _dbcca && _bcaed.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bbfag)
}
func NewCT_SmartTagType() *CT_SmartTagType { _eddae := &CT_SmartTagType{}; return _eddae }

// Validate validates the CT_CommentList and its children
func (_ffebe *CT_CommentList) Validate() error { return _ffebe.ValidateWithPath("CT_CommentList") }
func NewCalcChain() *CalcChain {
	_fadaa := &CalcChain{}
	_fadaa.CT_CalcChain = *NewCT_CalcChain()
	return _fadaa
}
func (_fdea *CT_MdxMetadata) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ggaeg := range start.Attr {
		if _ggaeg.Name.Local == "count" {
			_agcga, _aaba := _g.ParseUint(_ggaeg.Value, 10, 32)
			if _aaba != nil {
				return _aaba
			}
			_gdbed := uint32(_agcga)
			_fdea.CountAttr = &_gdbed
			continue
		}
	}
_gbbed:
	for {
		_cabac, _edefa := d.Token()
		if _edefa != nil {
			return _edefa
		}
		switch _gbbeb := _cabac.(type) {
		case _f.StartElement:
			switch _gbbeb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "mdx"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "mdx"}:
				_gffag := NewCT_Mdx()
				if _cefab := d.DecodeElement(_gffag, &_gbbeb); _cefab != nil {
					return _cefab
				}
				_fdea.Mdx = append(_fdea.Mdx, _gffag)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_MdxMetadata\u0020\u0025v", _gbbeb.Name)
				if _cdce := d.Skip(); _cdce != nil {
					return _cdce
				}
			}
		case _f.EndElement:
			break _gbbed
		case _f.CharData:
		}
	}
	return nil
}

const (
	ST_GrowShrinkTypeUnset          ST_GrowShrinkType = 0
	ST_GrowShrinkTypeInsertDelete   ST_GrowShrinkType = 1
	ST_GrowShrinkTypeInsertClear    ST_GrowShrinkType = 2
	ST_GrowShrinkTypeOverwriteClear ST_GrowShrinkType = 3
)

type CT_Xf struct {

	// Number Format Id
	NumFmtIdAttr *uint32

	// Font Id
	FontIdAttr *uint32

	// Fill Id
	FillIdAttr *uint32

	// Border Id
	BorderIdAttr *uint32

	// Format Id
	XfIdAttr *uint32

	// Quote Prefix
	QuotePrefixAttr *bool

	// Pivot Button
	PivotButtonAttr *bool

	// Apply Number Format
	ApplyNumberFormatAttr *bool

	// Apply Font
	ApplyFontAttr *bool

	// Apply Fill
	ApplyFillAttr *bool

	// Apply Border
	ApplyBorderAttr *bool

	// Apply Alignment
	ApplyAlignmentAttr *bool

	// Apply Protection
	ApplyProtectionAttr *bool

	// Alignment
	Alignment *CT_CellAlignment

	// Protection
	Protection *CT_CellProtection

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_begac *CT_PageMargins) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "left"}, Value: _bg.Sprintf("\u0025v", _begac.LeftAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "right"}, Value: _bg.Sprintf("\u0025v", _begac.RightAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "top"}, Value: _bg.Sprintf("\u0025v", _begac.TopAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "bottom"}, Value: _bg.Sprintf("\u0025v", _begac.BottomAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "header"}, Value: _bg.Sprintf("\u0025v", _begac.HeaderAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "footer"}, Value: _bg.Sprintf("\u0025v", _begac.FooterAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ReviewedRevisions and its children, prefixing error messages with path
func (_eeaee *CT_ReviewedRevisions) ValidateWithPath(path string) error {
	for _bgdb, _ccbed := range _eeaee.Reviewed {
		if _gbga := _ccbed.ValidateWithPath(_bg.Sprintf("\u0025s\u002fReviewed\u005b\u0025d\u005d", path, _bgdb)); _gbga != nil {
			return _gbga
		}
	}
	return nil
}
func (_cge *CT_Consolidation) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cge.AutoPageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoPage"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cge.AutoPageAttr))})
	}
	e.EncodeToken(start)
	if _cge.Pages != nil {
		_ebcf := _f.StartElement{Name: _f.Name{Local: "ma:pages"}}
		e.EncodeElement(_cge.Pages, _ebcf)
	}
	_aaegf := _f.StartElement{Name: _f.Name{Local: "ma:rangeSets"}}
	e.EncodeElement(_cge.RangeSets, _aaegf)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cgbfa *CT_PivotCaches) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_ffecb:
	for {
		_cgeda, _gefaeg := d.Token()
		if _gefaeg != nil {
			return _gefaeg
		}
		switch _gfcgf := _cgeda.(type) {
		case _f.StartElement:
			switch _gfcgf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotCache"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotCache"}:
				_edege := NewCT_PivotCache()
				if _agacc := d.DecodeElement(_edege, &_gfcgf); _agacc != nil {
					return _agacc
				}
				_cgbfa.PivotCache = append(_cgbfa.PivotCache, _edege)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PivotCaches\u0020\u0025v", _gfcgf.Name)
				if _ggbc := d.Skip(); _ggbc != nil {
					return _ggbc
				}
			}
		case _f.EndElement:
			break _ffecb
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_Field() *CT_Field { _gdbb := &CT_Field{}; return _gdbb }
func (_cfbgf *CT_PCDSCPage) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aafega := range start.Attr {
		if _aafega.Name.Local == "count" {
			_aeda, _ffggd := _g.ParseUint(_aafega.Value, 10, 32)
			if _ffggd != nil {
				return _ffggd
			}
			_aedgd := uint32(_aeda)
			_cfbgf.CountAttr = &_aedgd
			continue
		}
	}
_gdgde:
	for {
		_aedeg, _adabc := d.Token()
		if _adabc != nil {
			return _adabc
		}
		switch _ffcefg := _aedeg.(type) {
		case _f.StartElement:
			switch _ffcefg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageItem"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageItem"}:
				_cfbddg := NewCT_PageItem()
				if _agdb := d.DecodeElement(_cfbddg, &_ffcefg); _agdb != nil {
					return _agdb
				}
				_cfbgf.PageItem = append(_cfbgf.PageItem, _cfbddg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PCDSCPage\u0020\u0025v", _ffcefg.Name)
				if _cgdba := d.Skip(); _cgdba != nil {
					return _cgdba
				}
			}
		case _f.EndElement:
			break _gdgde
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CacheSource and its children, prefixing error messages with path
func (_eefa *CT_CacheSource) ValidateWithPath(path string) error {
	if _eefa.TypeAttr == ST_SourceTypeUnset {
		return _bg.Errorf("\u0025s\u002fTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _ada := _eefa.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _ada != nil {
		return _ada
	}
	if _eefa.WorksheetSource != nil {
		if _faad := _eefa.WorksheetSource.ValidateWithPath(path + "\u002fWorksheetSource"); _faad != nil {
			return _faad
		}
	}
	if _eefa.Consolidation != nil {
		if _cdfc := _eefa.Consolidation.ValidateWithPath(path + "\u002fConsolidation"); _cdfc != nil {
			return _cdfc
		}
	}
	if _eefa.ExtLst != nil {
		if _fbag := _eefa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fbag != nil {
			return _fbag
		}
	}
	return nil
}

// ValidateWithPath validates the CT_DataRefs and its children, prefixing error messages with path
func (_abfef *CT_DataRefs) ValidateWithPath(path string) error {
	for _deaa, _gccf := range _abfef.DataRef {
		if _deda := _gccf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fDataRef\u005b\u0025d\u005d", path, _deaa)); _deda != nil {
			return _deda
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ControlPr and its children, prefixing error messages with path
func (_eceb *CT_ControlPr) ValidateWithPath(path string) error {
	if _fdgdf := _eceb.Anchor.ValidateWithPath(path + "\u002fAnchor"); _fdgdf != nil {
		return _fdgdf
	}
	return nil
}
func (_bgafbd *ST_OleUpdate) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_egecg, _caeab := d.Token()
	if _caeab != nil {
		return _caeab
	}
	if _ccdge, _decbg := _egecg.(_f.EndElement); _decbg && _ccdge.Name == start.Name {
		*_bgafbd = 1
		return nil
	}
	if _fabgd, _dafgbe := _egecg.(_f.CharData); !_dafgbe {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _egecg)
	} else {
		switch string(_fabgd) {
		case "":
			*_bgafbd = 0
		case "OLEUPDATE_ALWAYS":
			*_bgafbd = 1
		case "OLEUPDATE_ONCALL":
			*_bgafbd = 2
		}
	}
	_egecg, _caeab = d.Token()
	if _caeab != nil {
		return _caeab
	}
	if _fbabg, _egaea := _egecg.(_f.EndElement); _egaea && _fbabg.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _egecg)
}

type CT_IndexedColors struct {

	// RGB Color
	RgbColor []*CT_RgbColor
}

// ValidateWithPath validates the CT_MeasureDimensionMap and its children, prefixing error messages with path
func (_bfecdb *CT_MeasureDimensionMap) ValidateWithPath(path string) error { return nil }

type CT_MapInfo struct {

	// Prefix Mappings for XPath Expressions
	SelectionNamespacesAttr string

	// XML Schema
	Schema []*CT_Schema

	// XML Mapping Properties
	Map []*CT_Map
}

// Validate validates the CT_TableColumn and its children
func (_geffd *CT_TableColumn) Validate() error { return _geffd.ValidateWithPath("CT_TableColumn") }

type CT_CsPageSetup struct {

	// Paper Size
	PaperSizeAttr *uint32

	// Paper Height
	PaperHeightAttr *string

	// Paper Width
	PaperWidthAttr *string

	// First Page Number
	FirstPageNumberAttr *uint32

	// Orientation
	OrientationAttr ST_Orientation

	// Use Printer Defaults
	UsePrinterDefaultsAttr *bool

	// Black And White
	BlackAndWhiteAttr *bool

	// Draft
	DraftAttr *bool

	// Use First Page Number
	UseFirstPageNumberAttr *bool

	// Horizontal DPI
	HorizontalDpiAttr *uint32

	// Vertical DPI
	VerticalDpiAttr *uint32

	// Number Of Copies
	CopiesAttr *uint32
	IdAttr     *string
}
type CT_InputCells struct {

	// Reference
	RAttr string

	// Deleted
	DeletedAttr *bool

	// Undone
	UndoneAttr *bool

	// Value
	ValAttr string

	// Number Format Id
	NumFmtIdAttr *uint32
}

// ValidateWithPath validates the CT_Dxf and its children, prefixing error messages with path
func (_bfagb *CT_Dxf) ValidateWithPath(path string) error {
	if _bfagb.Font != nil {
		if _adfdf := _bfagb.Font.ValidateWithPath(path + "\u002fFont"); _adfdf != nil {
			return _adfdf
		}
	}
	if _bfagb.NumFmt != nil {
		if _dfbeg := _bfagb.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _dfbeg != nil {
			return _dfbeg
		}
	}
	if _bfagb.Fill != nil {
		if _egaf := _bfagb.Fill.ValidateWithPath(path + "\u002fFill"); _egaf != nil {
			return _egaf
		}
	}
	if _bfagb.Alignment != nil {
		if _bacde := _bfagb.Alignment.ValidateWithPath(path + "\u002fAlignment"); _bacde != nil {
			return _bacde
		}
	}
	if _bfagb.Border != nil {
		if _bbce := _bfagb.Border.ValidateWithPath(path + "\u002fBorder"); _bbce != nil {
			return _bbce
		}
	}
	if _bfagb.Protection != nil {
		if _ffeca := _bfagb.Protection.ValidateWithPath(path + "/Protection"); _ffeca != nil {
			return _ffeca
		}
	}
	if _bfagb.ExtLst != nil {
		if _gegf := _bfagb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gegf != nil {
			return _gegf
		}
	}
	return nil
}

// Validate validates the CT_WorksheetSource and its children
func (_bacgfd *CT_WorksheetSource) Validate() error {
	return _bacgfd.ValidateWithPath("CT_WorksheetSource")
}
func (_dggad *CT_ExternalBook) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gcgdg := range start.Attr {
		if _gcgdg.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _gcgdg.Name.Local == "id" || _gcgdg.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _gcgdg.Name.Local == "id" {
			_fcdba, _cfcbg := _gcgdg.Value, error(nil)
			if _cfcbg != nil {
				return _cfcbg
			}
			_dggad.IdAttr = _fcdba
			continue
		}
	}
_efaaa:
	for {
		_cdadb, _edeaa := d.Token()
		if _edeaa != nil {
			return _edeaa
		}
		switch _gacg := _cdadb.(type) {
		case _f.StartElement:
			switch _gacg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetNames"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetNames"}:
				_dggad.SheetNames = NewCT_ExternalSheetNames()
				if _gdcace := d.DecodeElement(_dggad.SheetNames, &_gacg); _gdcace != nil {
					return _gdcace
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "definedNames"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "definedNames"}:
				_dggad.DefinedNames = NewCT_ExternalDefinedNames()
				if _ffff := d.DecodeElement(_dggad.DefinedNames, &_gacg); _ffff != nil {
					return _ffff
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetDataSet"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetDataSet"}:
				_dggad.SheetDataSet = NewCT_ExternalSheetDataSet()
				if _afgg := d.DecodeElement(_dggad.SheetDataSet, &_gacg); _afgg != nil {
					return _afgg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ExternalBook\u0020\u0025v", _gacg.Name)
				if _eabgc := d.Skip(); _eabgc != nil {
					return _eabgc
				}
			}
		case _f.EndElement:
			break _efaaa
		case _f.CharData:
		}
	}
	return nil
}

type CT_PageSetUpPr struct {

	// Show Auto Page Breaks
	AutoPageBreaksAttr *bool

	// Fit To Page
	FitToPageAttr *bool
}

func (_facca ST_Scope) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_fcaaag := _f.Attr{}
	_fcaaag.Name = name
	switch _facca {
	case ST_ScopeUnset:
		_fcaaag.Value = ""
	case ST_ScopeSelection:
		_fcaaag.Value = "selection"
	case ST_ScopeData:
		_fcaaag.Value = "data"
	case ST_ScopeField:
		_fcaaag.Value = "field"
	}
	return _fcaaag, nil
}
func (_bbagd ST_VerticalAlignment) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bbagd.String(), start)
}
func (_aegdcd ST_DataValidationErrorStyle) Validate() error { return _aegdcd.ValidateWithPath("") }

// Validate validates the CT_Drawing and its children
func (_beacd *CT_Drawing) Validate() error { return _beacd.ValidateWithPath("CT_Drawing") }

// Validate validates the CT_OleItems and its children
func (_aaaeb *CT_OleItems) Validate() error { return _aaaeb.ValidateWithPath("CT_OleItems") }

// Validate validates the Workbook and its children
func (_aggaba *Workbook) Validate() error { return _aggaba.ValidateWithPath("Workbook") }

// ValidateWithPath validates the CT_TupleCache and its children, prefixing error messages with path
func (_gdeae *CT_TupleCache) ValidateWithPath(path string) error {
	if _gdeae.Entries != nil {
		if _fcdff := _gdeae.Entries.ValidateWithPath(path + "\u002fEntries"); _fcdff != nil {
			return _fcdff
		}
	}
	if _gdeae.Sets != nil {
		if _fbagdc := _gdeae.Sets.ValidateWithPath(path + "\u002fSets"); _fbagdc != nil {
			return _fbagdc
		}
	}
	if _gdeae.QueryCache != nil {
		if _ebfef := _gdeae.QueryCache.ValidateWithPath(path + "/QueryCache"); _ebfef != nil {
			return _ebfef
		}
	}
	if _gdeae.ServerFormats != nil {
		if _afebec := _gdeae.ServerFormats.ValidateWithPath(path + "\u002fServerFormats"); _afebec != nil {
			return _afebec
		}
	}
	if _gdeae.ExtLst != nil {
		if _fffebc := _gdeae.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fffebc != nil {
			return _fffebc
		}
	}
	return nil
}
func (_fegggd *PivotCacheDefinition) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:pivotCacheDefinition"
	return _fegggd.CT_PivotCacheDefinition.MarshalXML(e, start)
}

const (
	ST_rwColActionTypeUnset     ST_rwColActionType = 0
	ST_rwColActionTypeInsertRow ST_rwColActionType = 1
	ST_rwColActionTypeDeleteRow ST_rwColActionType = 2
	ST_rwColActionTypeInsertCol ST_rwColActionType = 3
	ST_rwColActionTypeDeleteCol ST_rwColActionType = 4
)

func NewCT_Missing() *CT_Missing { _aaebc := &CT_Missing{}; return _aaebc }

type ST_GradientType byte

func (_ddeed *ST_PageOrder) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_ddeed = 0
	case "downThenOver":
		*_ddeed = 1
	case "overThenDown":
		*_ddeed = 2
	}
	return nil
}
func (_bcabab ST_TimePeriod) ValidateWithPath(path string) error {
	switch _bcabab {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bcabab))
	}
	return nil
}
func NewCT_Location() *CT_Location { _ffcfb := &CT_Location{}; return _ffcfb }

type CT_PivotSelection struct {

	// Pane
	PaneAttr ST_Pane

	// Show Header
	ShowHeaderAttr *bool

	// Label
	LabelAttr *bool

	// Data Selection
	DataAttr *bool

	// Extendable
	ExtendableAttr *bool

	// Selection Count
	CountAttr *uint32

	// Axis
	AxisAttr ST_Axis

	// Dimension
	DimensionAttr *uint32

	// Start
	StartAttr *uint32

	// Minimum
	MinAttr *uint32

	// Maximum
	MaxAttr *uint32

	// Active Row
	ActiveRowAttr *uint32

	// Active Column
	ActiveColAttr *uint32

	// Previous Row
	PreviousRowAttr *uint32

	// Previous Column Selection
	PreviousColAttr *uint32

	// Click Count
	ClickAttr *uint32
	IdAttr    *string

	// Pivot Area
	PivotArea *CT_PivotArea
}

// Validate validates the CT_CacheHierarchies and its children
func (_dfcg *CT_CacheHierarchies) Validate() error {
	return _dfcg.ValidateWithPath("CT_CacheHierarchies")
}
func (_aafdgg *CT_FieldUsage) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "x"}, Value: _bg.Sprintf("\u0025v", _aafdgg.XAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ccffb *CT_DataFields) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _geafb := range start.Attr {
		if _geafb.Name.Local == "count" {
			_acggg, _facgd := _g.ParseUint(_geafb.Value, 10, 32)
			if _facgd != nil {
				return _facgd
			}
			_dbaee := uint32(_acggg)
			_ccffb.CountAttr = &_dbaee
			continue
		}
	}
_cafe:
	for {
		_cgcb, _cfbg := d.Token()
		if _cfbg != nil {
			return _cfbg
		}
		switch _degcc := _cgcb.(type) {
		case _f.StartElement:
			switch _degcc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataField"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataField"}:
				_cfdb := NewCT_DataField()
				if _egde := d.DecodeElement(_cfdb, &_degcc); _egde != nil {
					return _egde
				}
				_ccffb.DataField = append(_ccffb.DataField, _cfdb)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_DataFields \u0025v", _degcc.Name)
				if _cdcf := d.Skip(); _cdcf != nil {
					return _cdcf
				}
			}
		case _f.EndElement:
			break _cafe
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_OlapPr() *CT_OlapPr { _ececa := &CT_OlapPr{}; return _ececa }
func (_bbbe *CT_CellWatches) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_agce:
	for {
		_gcbf, _egcac := d.Token()
		if _egcac != nil {
			return _egcac
		}
		switch _eeef := _gcbf.(type) {
		case _f.StartElement:
			switch _eeef.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellWatch"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellWatch"}:
				_ggdbd := NewCT_CellWatch()
				if _ddfe := d.DecodeElement(_ggdbd, &_eeef); _ddfe != nil {
					return _ddfe
				}
				_bbbe.CellWatch = append(_bbbe.CellWatch, _ggdbd)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CellWatches\u0020\u0025v", _eeef.Name)
				if _beeb := d.Skip(); _beeb != nil {
					return _beeb
				}
			}
		case _f.EndElement:
			break _agce
		case _f.CharData:
		}
	}
	return nil
}
func (_dfcea *CT_OleLink) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _dfcea.IdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "progId"}, Value: _bg.Sprintf("\u0025v", _dfcea.ProgIdAttr)})
	e.EncodeToken(start)
	if _dfcea.OleItems != nil {
		_ebcdf := _f.StartElement{Name: _f.Name{Local: "ma:oleItems"}}
		e.EncodeElement(_dfcea.OleItems, _ebcdf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dgfcc ST_SortType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_dgfcc.String(), start)
}
func (_cegffba ST_SortType) Validate() error { return _cegffba.ValidateWithPath("") }

type ST_ConditionalFormattingOperator byte

// Validate validates the CT_MdxKPI and its children
func (_bgebg *CT_MdxKPI) Validate() error { return _bgebg.ValidateWithPath("CT_MdxKPI") }

// ValidateWithPath validates the CT_Control and its children, prefixing error messages with path
func (_adbe *CT_Control) ValidateWithPath(path string) error {
	if _adbe.ControlPr != nil {
		if _bbda := _adbe.ControlPr.ValidateWithPath(path + "\u002fControlPr"); _bbda != nil {
			return _bbda
		}
	}
	return nil
}

type ST_PrintError byte

// Validate validates the CT_UnderlineProperty and its children
func (_gdddd *CT_UnderlineProperty) Validate() error {
	return _gdddd.ValidateWithPath("CT_UnderlineProperty")
}
func (_cacf *CT_CustomProperty) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _cacf.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _cacf.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type ST_DynamicFilterType byte

func NewCT_Worksheet() *CT_Worksheet {
	_fbaff := &CT_Worksheet{}
	_fbaff.SheetData = NewCT_SheetData()
	return _fbaff
}
func (_befba ST_CfvoType) Validate() error { return _befba.ValidateWithPath("") }

// Validate validates the CT_VolMain and its children
func (_cfddf *CT_VolMain) Validate() error { return _cfddf.ValidateWithPath("CT_VolMain") }

// ValidateWithPath validates the CT_GroupLevel and its children, prefixing error messages with path
func (_ddbea *CT_GroupLevel) ValidateWithPath(path string) error {
	if _ddbea.Groups != nil {
		if _dcabdb := _ddbea.Groups.ValidateWithPath(path + "\u002fGroups"); _dcabdb != nil {
			return _dcabdb
		}
	}
	if _ddbea.ExtLst != nil {
		if _baaeg := _ddbea.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _baaeg != nil {
			return _baaeg
		}
	}
	return nil
}
func (_adddgc ST_SmartTagShow) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_adddgc.String(), start)
}

// ValidateWithPath validates the CT_PivotDimension and its children, prefixing error messages with path
func (_gbeg *CT_PivotDimension) ValidateWithPath(path string) error { return nil }
func (_addgce *CT_PivotAreas) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ddfedd := range start.Attr {
		if _ddfedd.Name.Local == "count" {
			_efbbg, _ffecag := _g.ParseUint(_ddfedd.Value, 10, 32)
			if _ffecag != nil {
				return _ffecag
			}
			_dfbed := uint32(_efbbg)
			_addgce.CountAttr = &_dfbed
			continue
		}
	}
_cbgda:
	for {
		_bcca, _ddbga := d.Token()
		if _ddbga != nil {
			return _ddbga
		}
		switch _abgbd := _bcca.(type) {
		case _f.StartElement:
			switch _abgbd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotArea"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotArea"}:
				_baaba := NewCT_PivotArea()
				if _bffgg := d.DecodeElement(_baaba, &_abgbd); _bffgg != nil {
					return _bffgg
				}
				_addgce.PivotArea = append(_addgce.PivotArea, _baaba)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_PivotAreas \u0025v", _abgbd.Name)
				if _bbebb := d.Skip(); _bbebb != nil {
					return _bbebb
				}
			}
		case _f.EndElement:
			break _cbgda
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Record and its children, prefixing error messages with path
func (_dbcda *CT_Record) ValidateWithPath(path string) error {
	for _gdgdf, _cgcae := range _dbcda.M {
		if _beddc := _cgcae.ValidateWithPath(_bg.Sprintf("\u0025s\u002fM\u005b\u0025d\u005d", path, _gdgdf)); _beddc != nil {
			return _beddc
		}
	}
	for _dgbfa, _bcdbef := range _dbcda.N {
		if _abbfee := _bcdbef.ValidateWithPath(_bg.Sprintf("\u0025s\u002fN\u005b\u0025d\u005d", path, _dgbfa)); _abbfee != nil {
			return _abbfee
		}
	}
	for _bffde, _gggcg := range _dbcda.B {
		if _cbggg := _gggcg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fB\u005b\u0025d\u005d", path, _bffde)); _cbggg != nil {
			return _cbggg
		}
	}
	for _cefdde, _faafd := range _dbcda.E {
		if _abcfb := _faafd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fE\u005b\u0025d\u005d", path, _cefdde)); _abcfb != nil {
			return _abcfb
		}
	}
	for _gbef, _eacce := range _dbcda.S {
		if _agdae := _eacce.ValidateWithPath(_bg.Sprintf("\u0025s\u002fS\u005b\u0025d\u005d", path, _gbef)); _agdae != nil {
			return _agdae
		}
	}
	for _adbea, _acbfb := range _dbcda.D {
		if _ffgac := _acbfb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fD\u005b\u0025d\u005d", path, _adbea)); _ffgac != nil {
			return _ffgac
		}
	}
	for _cbgbc, _fdddg := range _dbcda.X {
		if _bbcaf := _fdddg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fX\u005b\u0025d\u005d", path, _cbgbc)); _bbcaf != nil {
			return _bbcaf
		}
	}
	return nil
}

type CT_OleLink struct {
	IdAttr string

	// Object Link Identifier
	ProgIdAttr string

	// Object Link Items
	OleItems *CT_OleItems
}

func NewCT_TablePart() *CT_TablePart { _fffeed := &CT_TablePart{}; return _fffeed }
func (_ffcfcb *Table) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ffcfcb.CT_Table = *NewCT_Table()
	for _, _efaca := range start.Attr {
		if _efaca.Name.Local == "dataDxfId" {
			_efacd, _egdaeb := _g.ParseUint(_efaca.Value, 10, 32)
			if _egdaeb != nil {
				return _egdaeb
			}
			_fabcea := uint32(_efacd)
			_ffcfcb.DataDxfIdAttr = &_fabcea
			continue
		}
		if _efaca.Name.Local == "totalsRowDxfId" {
			_dcefg, _badbd := _g.ParseUint(_efaca.Value, 10, 32)
			if _badbd != nil {
				return _badbd
			}
			_cedgcc := uint32(_dcefg)
			_ffcfcb.TotalsRowDxfIdAttr = &_cedgcc
			continue
		}
		if _efaca.Name.Local == "name" {
			_ddcbb, _dccbgb := _efaca.Value, error(nil)
			if _dccbgb != nil {
				return _dccbgb
			}
			_ffcfcb.NameAttr = &_ddcbb
			continue
		}
		if _efaca.Name.Local == "headerRowBorderDxfId" {
			_gffcdf, _adbcf := _g.ParseUint(_efaca.Value, 10, 32)
			if _adbcf != nil {
				return _adbcf
			}
			_eeaga := uint32(_gffcdf)
			_ffcfcb.HeaderRowBorderDxfIdAttr = &_eeaga
			continue
		}
		if _efaca.Name.Local == "comment" {
			_bbdec, _abcab := _efaca.Value, error(nil)
			if _abcab != nil {
				return _abcab
			}
			_ffcfcb.CommentAttr = &_bbdec
			continue
		}
		if _efaca.Name.Local == "tableBorderDxfId" {
			_cbcbgg, _cdgbgd := _g.ParseUint(_efaca.Value, 10, 32)
			if _cdgbgd != nil {
				return _cdgbgd
			}
			_ffgcgg := uint32(_cbcbgg)
			_ffcfcb.TableBorderDxfIdAttr = &_ffgcgg
			continue
		}
		if _efaca.Name.Local == "tableType" {
			_ffcfcb.TableTypeAttr.UnmarshalXMLAttr(_efaca)
			continue
		}
		if _efaca.Name.Local == "totalsRowBorderDxfId" {
			_cbcfg, _ffefcg := _g.ParseUint(_efaca.Value, 10, 32)
			if _ffefcg != nil {
				return _ffefcg
			}
			_gcdagf := uint32(_cbcfg)
			_ffcfcb.TotalsRowBorderDxfIdAttr = &_gcdagf
			continue
		}
		if _efaca.Name.Local == "insertRow" {
			_aagef, _bcgeg := _g.ParseBool(_efaca.Value)
			if _bcgeg != nil {
				return _bcgeg
			}
			_ffcfcb.InsertRowAttr = &_aagef
			continue
		}
		if _efaca.Name.Local == "headerRowCellStyle" {
			_beddd, _caeggc := _efaca.Value, error(nil)
			if _caeggc != nil {
				return _caeggc
			}
			_ffcfcb.HeaderRowCellStyleAttr = &_beddd
			continue
		}
		if _efaca.Name.Local == "totalsRowCount" {
			_eaccd, _dbfea := _g.ParseUint(_efaca.Value, 10, 32)
			if _dbfea != nil {
				return _dbfea
			}
			_ffefe := uint32(_eaccd)
			_ffcfcb.TotalsRowCountAttr = &_ffefe
			continue
		}
		if _efaca.Name.Local == "totalsRowCellStyle" {
			_cedag, _abfff := _efaca.Value, error(nil)
			if _abfff != nil {
				return _abfff
			}
			_ffcfcb.TotalsRowCellStyleAttr = &_cedag
			continue
		}
		if _efaca.Name.Local == "displayName" {
			_ddggf, _faddd := _efaca.Value, error(nil)
			if _faddd != nil {
				return _faddd
			}
			_ffcfcb.DisplayNameAttr = _ddggf
			continue
		}
		if _efaca.Name.Local == "id" {
			_geggd, _dacbc := _g.ParseUint(_efaca.Value, 10, 32)
			if _dacbc != nil {
				return _dacbc
			}
			_ffcfcb.IdAttr = uint32(_geggd)
			continue
		}
		if _efaca.Name.Local == "dataCellStyle" {
			_bbfefe, _febef := _efaca.Value, error(nil)
			if _febef != nil {
				return _febef
			}
			_ffcfcb.DataCellStyleAttr = &_bbfefe
			continue
		}
		if _efaca.Name.Local == "published" {
			_aaeda, _bcbdde := _g.ParseBool(_efaca.Value)
			if _bcbdde != nil {
				return _bcbdde
			}
			_ffcfcb.PublishedAttr = &_aaeda
			continue
		}
		if _efaca.Name.Local == "connectionId" {
			_adceg, _fcaecc := _g.ParseUint(_efaca.Value, 10, 32)
			if _fcaecc != nil {
				return _fcaecc
			}
			_bdgca := uint32(_adceg)
			_ffcfcb.ConnectionIdAttr = &_bdgca
			continue
		}
		if _efaca.Name.Local == "ref" {
			_ccfed, _fddeg := _efaca.Value, error(nil)
			if _fddeg != nil {
				return _fddeg
			}
			_ffcfcb.RefAttr = _ccfed
			continue
		}
		if _efaca.Name.Local == "insertRowShift" {
			_agefge, _cefcff := _g.ParseBool(_efaca.Value)
			if _cefcff != nil {
				return _cefcff
			}
			_ffcfcb.InsertRowShiftAttr = &_agefge
			continue
		}
		if _efaca.Name.Local == "totalsRowShown" {
			_fbaebc, _effgf := _g.ParseBool(_efaca.Value)
			if _effgf != nil {
				return _effgf
			}
			_ffcfcb.TotalsRowShownAttr = &_fbaebc
			continue
		}
		if _efaca.Name.Local == "headerRowDxfId" {
			_dfdfce, _dcggga := _g.ParseUint(_efaca.Value, 10, 32)
			if _dcggga != nil {
				return _dcggga
			}
			_ebceec := uint32(_dfdfce)
			_ffcfcb.HeaderRowDxfIdAttr = &_ebceec
			continue
		}
		if _efaca.Name.Local == "headerRowCount" {
			_feedg, _ddbeaf := _g.ParseUint(_efaca.Value, 10, 32)
			if _ddbeaf != nil {
				return _ddbeaf
			}
			_ebeafa := uint32(_feedg)
			_ffcfcb.HeaderRowCountAttr = &_ebeafa
			continue
		}
	}
_efegea:
	for {
		_gcgee, _ffdafd := d.Token()
		if _ffdafd != nil {
			return _ffdafd
		}
		switch _fbffgf := _gcgee.(type) {
		case _f.StartElement:
			switch _fbffgf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "autoFilter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "autoFilter"}:
				_ffcfcb.AutoFilter = NewCT_AutoFilter()
				if _ecbbeb := d.DecodeElement(_ffcfcb.AutoFilter, &_fbffgf); _ecbbeb != nil {
					return _ecbbeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sortState"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sortState"}:
				_ffcfcb.SortState = NewCT_SortState()
				if _bbaab := d.DecodeElement(_ffcfcb.SortState, &_fbffgf); _bbaab != nil {
					return _bbaab
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tableColumns"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tableColumns"}:
				if _aaacc := d.DecodeElement(_ffcfcb.TableColumns, &_fbffgf); _aaacc != nil {
					return _aaacc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tableStyleInfo"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tableStyleInfo"}:
				_ffcfcb.TableStyleInfo = NewCT_TableStyleInfo()
				if _edgfgb := d.DecodeElement(_ffcfcb.TableStyleInfo, &_fbffgf); _edgfgb != nil {
					return _edgfgb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ffcfcb.ExtLst = NewCT_ExtensionList()
				if _ffbag := d.DecodeElement(_ffcfcb.ExtLst, &_fbffgf); _ffbag != nil {
					return _ffbag
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on Table \u0025v", _fbffgf.Name)
				if _gfcggc := d.Skip(); _gfcggc != nil {
					return _gfcggc
				}
			}
		case _f.EndElement:
			break _efegea
		case _f.CharData:
		}
	}
	return nil
}

type CT_Map struct {

	// XML Mapping ID
	IDAttr uint32

	// XML Mapping Name
	NameAttr string

	// Root Element Name
	RootElementAttr string

	// Schema Name
	SchemaIDAttr string

	// Show Validation Errors
	ShowImportExportValidationErrorsAttr bool

	// AutoFit Table on Refresh
	AutoFitAttr bool

	// Append Data to Table
	AppendAttr bool

	// Preserve AutoFilter State
	PreserveSortAFLayoutAttr bool

	// Preserve Cell Formatting
	PreserveFormatAttr bool

	// XML Mapping
	DataBinding *CT_DataBinding
}

func (_aacfdg ST_IconSetType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_aacfdg.String(), start)
}
func (_ccabd *CT_IgnoredErrors) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_agfgb:
	for {
		_fbbcb, _cbeea := d.Token()
		if _cbeea != nil {
			return _cbeea
		}
		switch _eegbe := _fbbcb.(type) {
		case _f.StartElement:
			switch _eegbe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ignoredError"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ignoredError"}:
				_fcgaa := NewCT_IgnoredError()
				if _gfdf := d.DecodeElement(_fcgaa, &_eegbe); _gfdf != nil {
					return _gfdf
				}
				_ccabd.IgnoredError = append(_ccabd.IgnoredError, _fcgaa)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ccabd.ExtLst = NewCT_ExtensionList()
				if _cgedg := d.DecodeElement(_ccabd.ExtLst, &_eegbe); _cgedg != nil {
					return _cgedg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_IgnoredErrors\u0020\u0025v", _eegbe.Name)
				if _aacef := d.Skip(); _aacef != nil {
					return _aacef
				}
			}
		case _f.EndElement:
			break _agfgb
		case _f.CharData:
		}
	}
	return nil
}
func (_badaba *CT_TextField) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _badaba.TypeAttr != ST_ExternalConnectionTypeUnset {
		_bfdbg, _cfcgb := _badaba.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
		if _cfcgb != nil {
			return _cfcgb
		}
		start.Attr = append(start.Attr, _bfdbg)
	}
	if _badaba.PositionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "position"}, Value: _bg.Sprintf("\u0025v", *_badaba.PositionAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_OleSize and its children
func (_bdcea *CT_OleSize) Validate() error { return _bdcea.ValidateWithPath("CT_OleSize") }

type ST_CfvoType byte

// ValidateWithPath validates the CT_DataConsolidate and its children, prefixing error messages with path
func (_dded *CT_DataConsolidate) ValidateWithPath(path string) error {
	if _dccfb := _dded.FunctionAttr.ValidateWithPath(path + "\u002fFunctionAttr"); _dccfb != nil {
		return _dccfb
	}
	if _dded.DataRefs != nil {
		if _ceeagd := _dded.DataRefs.ValidateWithPath(path + "\u002fDataRefs"); _ceeagd != nil {
			return _ceeagd
		}
	}
	return nil
}
func NewCT_Break() *CT_Break { _fefb := &CT_Break{}; return _fefb }

type ST_WebSourceType byte

func NewCT_Sheet() *CT_Sheet { _eeaba := &CT_Sheet{}; return _eeaba }
func (_gdadf *ST_Visibility) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cbage, _dccbc := d.Token()
	if _dccbc != nil {
		return _dccbc
	}
	if _ffbga, _bfedf := _cbage.(_f.EndElement); _bfedf && _ffbga.Name == start.Name {
		*_gdadf = 1
		return nil
	}
	if _aeffgc, _beddg := _cbage.(_f.CharData); !_beddg {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cbage)
	} else {
		switch string(_aeffgc) {
		case "":
			*_gdadf = 0
		case "visible":
			*_gdadf = 1
		case "hidden":
			*_gdadf = 2
		case "veryHidden":
			*_gdadf = 3
		}
	}
	_cbage, _dccbc = d.Token()
	if _dccbc != nil {
		return _dccbc
	}
	if _gaggdd, _dcbgf := _cbage.(_f.EndElement); _dcbgf && _gaggdd.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cbage)
}
func (_gbfdf ST_IconSetType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_efade := _f.Attr{}
	_efade.Name = name
	switch _gbfdf {
	case ST_IconSetTypeUnset:
		_efade.Value = ""
	case ST_IconSetType3Arrows:
		_efade.Value = "3Arrows"
	case ST_IconSetType3ArrowsGray:
		_efade.Value = "3ArrowsGray"
	case ST_IconSetType3Flags:
		_efade.Value = "3Flags"
	case ST_IconSetType3TrafficLights1:
		_efade.Value = "3TrafficLights1"
	case ST_IconSetType3TrafficLights2:
		_efade.Value = "3TrafficLights2"
	case ST_IconSetType3Signs:
		_efade.Value = "3Signs"
	case ST_IconSetType3Symbols:
		_efade.Value = "3Symbols"
	case ST_IconSetType3Symbols2:
		_efade.Value = "3Symbols2"
	case ST_IconSetType4Arrows:
		_efade.Value = "4Arrows"
	case ST_IconSetType4ArrowsGray:
		_efade.Value = "4ArrowsGray"
	case ST_IconSetType4RedToBlack:
		_efade.Value = "4RedToBlack"
	case ST_IconSetType4Rating:
		_efade.Value = "4Rating"
	case ST_IconSetType4TrafficLights:
		_efade.Value = "4TrafficLights"
	case ST_IconSetType5Arrows:
		_efade.Value = "5Arrows"
	case ST_IconSetType5ArrowsGray:
		_efade.Value = "5ArrowsGray"
	case ST_IconSetType5Rating:
		_efade.Value = "5Rating"
	case ST_IconSetType5Quarters:
		_efade.Value = "5Quarters"
	}
	return _efade, nil
}

type CT_DeletedField struct {

	// Deleted Fields Name
	NameAttr string
}

func NewCT_RPrElt() *CT_RPrElt { _cbbbg := &CT_RPrElt{}; return _cbbbg }
func NewCT_ExternalSheetDataSet() *CT_ExternalSheetDataSet {
	_aceeb := &CT_ExternalSheetDataSet{}
	return _aceeb
}
func NewCT_QueryCache() *CT_QueryCache { _cfeca := &CT_QueryCache{}; return _cfeca }

type CT_ControlPr struct {

	// Locked Flag
	LockedAttr *bool

	// Default Size Flag
	DefaultSizeAttr *bool

	// Print Flag
	PrintAttr *bool

	// Disabled Flag
	DisabledAttr *bool

	// Recalculation Flag
	RecalcAlwaysAttr *bool

	// UI Object Flag
	UiObjectAttr *bool

	// Automatic Fill Flag
	AutoFillAttr *bool

	// Automatic Line Flag
	AutoLineAttr *bool

	// Automatic Size Flag
	AutoPictAttr *bool

	// Custom Function
	MacroAttr *string

	// Alternative Text
	AltTextAttr *string

	// Linked Formula
	LinkedCellAttr *string

	// List Items Source Range
	ListFillRangeAttr *string

	// Image Format
	CfAttr *string
	IdAttr *string

	// Object Cell Anchor
	Anchor *CT_ObjectAnchor
}

func (_bcdgc ST_PageOrder) String() string {
	switch _bcdgc {
	case 0:
		return ""
	case 1:
		return "downThenOver"
	case 2:
		return "overThenDown"
	}
	return ""
}
func (_gbgeab *CT_WorkbookPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gbgeab.Date1904Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "date1904"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.Date1904Attr))})
	}
	if _gbgeab.ShowObjectsAttr != ST_ObjectsUnset {
		_fcee, _bcddbg := _gbgeab.ShowObjectsAttr.MarshalXMLAttr(_f.Name{Local: "showObjects"})
		if _bcddbg != nil {
			return _bcddbg
		}
		start.Attr = append(start.Attr, _fcee)
	}
	if _gbgeab.ShowBorderUnselectedTablesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showBorderUnselectedTables"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.ShowBorderUnselectedTablesAttr))})
	}
	if _gbgeab.FilterPrivacyAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "filterPrivacy"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.FilterPrivacyAttr))})
	}
	if _gbgeab.PromptedSolutionsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "promptedSolutions"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.PromptedSolutionsAttr))})
	}
	if _gbgeab.ShowInkAnnotationAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showInkAnnotation"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.ShowInkAnnotationAttr))})
	}
	if _gbgeab.BackupFileAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "backupFile"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.BackupFileAttr))})
	}
	if _gbgeab.SaveExternalLinkValuesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "saveExternalLinkValues"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.SaveExternalLinkValuesAttr))})
	}
	if _gbgeab.UpdateLinksAttr != ST_UpdateLinksUnset {
		_cbcec, _dddgd := _gbgeab.UpdateLinksAttr.MarshalXMLAttr(_f.Name{Local: "updateLinks"})
		if _dddgd != nil {
			return _dddgd
		}
		start.Attr = append(start.Attr, _cbcec)
	}
	if _gbgeab.CodeNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "codeName"}, Value: _bg.Sprintf("\u0025v", *_gbgeab.CodeNameAttr)})
	}
	if _gbgeab.HidePivotFieldListAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hidePivotFieldList"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.HidePivotFieldListAttr))})
	}
	if _gbgeab.ShowPivotChartFilterAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showPivotChartFilter"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.ShowPivotChartFilterAttr))})
	}
	if _gbgeab.AllowRefreshQueryAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "allowRefreshQuery"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.AllowRefreshQueryAttr))})
	}
	if _gbgeab.PublishItemsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "publishItems"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.PublishItemsAttr))})
	}
	if _gbgeab.CheckCompatibilityAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "checkCompatibility"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.CheckCompatibilityAttr))})
	}
	if _gbgeab.AutoCompressPicturesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoCompressPictures"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.AutoCompressPicturesAttr))})
	}
	if _gbgeab.RefreshAllConnectionsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refreshAllConnections"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gbgeab.RefreshAllConnectionsAttr))})
	}
	if _gbgeab.DefaultThemeVersionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultThemeVersion"}, Value: _bg.Sprintf("\u0025v", *_gbgeab.DefaultThemeVersionAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

const (
	ST_VolDepTypeUnset         ST_VolDepType = 0
	ST_VolDepTypeRealTimeData  ST_VolDepType = 1
	ST_VolDepTypeOlapFunctions ST_VolDepType = 2
)

type CT_Record struct {

	// No Value
	M []*CT_Missing

	// Numeric Value
	N []*CT_Number

	// Boolean
	B []*CT_Boolean

	// Error Value
	E []*CT_Error

	// Character Value
	S []*CT_String

	// Date Time
	D []*CT_DateTime

	// Shared Items Index
	X []*CT_Index
}

func (_gcdfed *ST_FormatAction) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_afddgg, _bbfeb := d.Token()
	if _bbfeb != nil {
		return _bbfeb
	}
	if _gbdcf, _gabgf := _afddgg.(_f.EndElement); _gabgf && _gbdcf.Name == start.Name {
		*_gcdfed = 1
		return nil
	}
	if _bccbc, _gdcdcd := _afddgg.(_f.CharData); !_gdcdcd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _afddgg)
	} else {
		switch string(_bccbc) {
		case "":
			*_gcdfed = 0
		case "blank":
			*_gcdfed = 1
		case "formatting":
			*_gcdfed = 2
		case "drill":
			*_gcdfed = 3
		case "formula":
			*_gcdfed = 4
		}
	}
	_afddgg, _bbfeb = d.Token()
	if _bbfeb != nil {
		return _bbfeb
	}
	if _bccfe, _bfgcga := _afddgg.(_f.EndElement); _bfgcga && _bccfe.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _afddgg)
}
func (_cabfb ST_ParameterType) ValidateWithPath(path string) error {
	switch _cabfb {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cabfb))
	}
	return nil
}
func NewVolTypes() *VolTypes {
	_bcbcdg := &VolTypes{}
	_bcbcdg.CT_VolTypes = *NewCT_VolTypes()
	return _bcbcdg
}
func (_dgbcfd *CT_SheetPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dgbcfd.SyncHorizontalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "syncHorizontal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgbcfd.SyncHorizontalAttr))})
	}
	if _dgbcfd.SyncVerticalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "syncVertical"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgbcfd.SyncVerticalAttr))})
	}
	if _dgbcfd.SyncRefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "syncRef"}, Value: _bg.Sprintf("\u0025v", *_dgbcfd.SyncRefAttr)})
	}
	if _dgbcfd.TransitionEvaluationAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "transitionEvaluation"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgbcfd.TransitionEvaluationAttr))})
	}
	if _dgbcfd.TransitionEntryAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "transitionEntry"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgbcfd.TransitionEntryAttr))})
	}
	if _dgbcfd.PublishedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "published"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgbcfd.PublishedAttr))})
	}
	if _dgbcfd.CodeNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "codeName"}, Value: _bg.Sprintf("\u0025v", *_dgbcfd.CodeNameAttr)})
	}
	if _dgbcfd.FilterModeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "filterMode"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgbcfd.FilterModeAttr))})
	}
	if _dgbcfd.EnableFormatConditionsCalculationAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "enableFormatConditionsCalculation"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgbcfd.EnableFormatConditionsCalculationAttr))})
	}
	e.EncodeToken(start)
	if _dgbcfd.TabColor != nil {
		_dfaead := _f.StartElement{Name: _f.Name{Local: "ma:tabColor"}}
		e.EncodeElement(_dgbcfd.TabColor, _dfaead)
	}
	if _dgbcfd.OutlinePr != nil {
		_egcgc := _f.StartElement{Name: _f.Name{Local: "ma:outlinePr"}}
		e.EncodeElement(_dgbcfd.OutlinePr, _egcgc)
	}
	if _dgbcfd.PageSetUpPr != nil {
		_fefa := _f.StartElement{Name: _f.Name{Local: "ma:pageSetUpPr"}}
		e.EncodeElement(_dgbcfd.PageSetUpPr, _fefa)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ccbgfc *ST_RefMode) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_ccbgfc = 0
	case "A1":
		*_ccbgfc = 1
	case "R1C1":
		*_ccbgfc = 2
	}
	return nil
}

// Validate validates the CT_PCDSCPage and its children
func (_cdaga *CT_PCDSCPage) Validate() error { return _cdaga.ValidateWithPath("CT_PCDSCPage") }

// ValidateWithPath validates the CT_PivotCacheRecords and its children, prefixing error messages with path
func (_dgeec *CT_PivotCacheRecords) ValidateWithPath(path string) error {
	for _abafcc, _dcbbf := range _dgeec.R {
		if _fafac := _dcbbf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fR\u005b\u0025d\u005d", path, _abafcc)); _fafac != nil {
			return _fafac
		}
	}
	if _dgeec.ExtLst != nil {
		if _baegd := _dgeec.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _baegd != nil {
			return _baegd
		}
	}
	return nil
}

// Validate validates the CT_SharedItems and its children
func (_bcaffb *CT_SharedItems) Validate() error { return _bcaffb.ValidateWithPath("CT_SharedItems") }
func (_bbfdg *CT_Tables) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fegfbe := range start.Attr {
		if _fegfbe.Name.Local == "count" {
			_cgfce, _bdbfc := _g.ParseUint(_fegfbe.Value, 10, 32)
			if _bdbfc != nil {
				return _bdbfc
			}
			_ggffeg := uint32(_cgfce)
			_bbfdg.CountAttr = &_ggffeg
			continue
		}
	}
_ebabc:
	for {
		_gebcb, _gddba := d.Token()
		if _gddba != nil {
			return _gddba
		}
		switch _bfgdfb := _gebcb.(type) {
		case _f.StartElement:
			switch _bfgdfb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "m"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "m"}:
				_gafab := NewCT_TableMissing()
				if _cagfb := d.DecodeElement(_gafab, &_bfgdfb); _cagfb != nil {
					return _cagfb
				}
				_bbfdg.M = append(_bbfdg.M, _gafab)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "s"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "s"}:
				_abbfa := NewCT_XStringElement()
				if _cggdf := d.DecodeElement(_abbfa, &_bfgdfb); _cggdf != nil {
					return _cggdf
				}
				_bbfdg.S = append(_bbfdg.S, _abbfa)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "x"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "x"}:
				_aeeed := NewCT_Index()
				if _gcaba := d.DecodeElement(_aeeed, &_bfgdfb); _gcaba != nil {
					return _gcaba
				}
				_bbfdg.X = append(_bbfdg.X, _aeeed)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_Tables \u0025v", _bfgdfb.Name)
				if _edcdcg := d.Skip(); _edcdcg != nil {
					return _edcdcg
				}
			}
		case _f.EndElement:
			break _ebabc
		case _f.CharData:
		}
	}
	return nil
}
func (_cfcfgf ST_PhoneticAlignment) String() string {
	switch _cfcfgf {
	case 0:
		return ""
	case 1:
		return "noControl"
	case 2:
		return "left"
	case 3:
		return "center"
	case 4:
		return "distributed"
	}
	return ""
}

// ValidateWithPath validates the CT_MergeCells and its children, prefixing error messages with path
func (_gbfaa *CT_MergeCells) ValidateWithPath(path string) error {
	for _bcfaa, _fggef := range _gbfaa.MergeCell {
		if _abadc := _fggef.ValidateWithPath(_bg.Sprintf("\u0025s/MergeCell\u005b\u0025d\u005d", path, _bcfaa)); _abadc != nil {
			return _abadc
		}
	}
	return nil
}
func (_fcaca ST_CellType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_dffae := _f.Attr{}
	_dffae.Name = name
	switch _fcaca {
	case ST_CellTypeUnset:
		_dffae.Value = ""
	case ST_CellTypeB:
		_dffae.Value = "b"
	case ST_CellTypeN:
		_dffae.Value = "n"
	case ST_CellTypeE:
		_dffae.Value = "e"
	case ST_CellTypeS:
		_dffae.Value = "s"
	case ST_CellTypeStr:
		_dffae.Value = "str"
	case ST_CellTypeInlineStr:
		_dffae.Value = "inlineStr"
	}
	return _dffae, nil
}
func (_cdgea *ST_DataValidationImeMode) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_cdgea = 0
	case "noControl":
		*_cdgea = 1
	case "off":
		*_cdgea = 2
	case "on":
		*_cdgea = 3
	case "disabled":
		*_cdgea = 4
	case "hiragana":
		*_cdgea = 5
	case "fullKatakana":
		*_cdgea = 6
	case "halfKatakana":
		*_cdgea = 7
	case "fullAlpha":
		*_cdgea = 8
	case "halfAlpha":
		*_cdgea = 9
	case "fullHangul":
		*_cdgea = 10
	case "halfHangul":
		*_cdgea = 11
	}
	return nil
}
func (_efgc *CT_CommentPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _efgc.LockedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "locked"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_efgc.LockedAttr))})
	}
	if _efgc.DefaultSizeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultSize"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_efgc.DefaultSizeAttr))})
	}
	if _efgc.PrintAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "print"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_efgc.PrintAttr))})
	}
	if _efgc.DisabledAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "disabled"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_efgc.DisabledAttr))})
	}
	if _efgc.AutoFillAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoFill"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_efgc.AutoFillAttr))})
	}
	if _efgc.AutoLineAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoLine"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_efgc.AutoLineAttr))})
	}
	if _efgc.AltTextAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "altText"}, Value: _bg.Sprintf("\u0025v", *_efgc.AltTextAttr)})
	}
	if _efgc.TextHAlignAttr != ST_TextHAlignUnset {
		_cbagf, _cdbb := _efgc.TextHAlignAttr.MarshalXMLAttr(_f.Name{Local: "textHAlign"})
		if _cdbb != nil {
			return _cdbb
		}
		start.Attr = append(start.Attr, _cbagf)
	}
	if _efgc.TextVAlignAttr != ST_TextVAlignUnset {
		_abdd, _adcg := _efgc.TextVAlignAttr.MarshalXMLAttr(_f.Name{Local: "textVAlign"})
		if _adcg != nil {
			return _adcg
		}
		start.Attr = append(start.Attr, _abdd)
	}
	if _efgc.LockTextAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lockText"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_efgc.LockTextAttr))})
	}
	if _efgc.JustLastXAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "justLastX"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_efgc.JustLastXAttr))})
	}
	if _efgc.AutoScaleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoScale"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_efgc.AutoScaleAttr))})
	}
	e.EncodeToken(start)
	_aedd := _f.StartElement{Name: _f.Name{Local: "ma:anchor"}}
	e.EncodeElement(_efgc.Anchor, _aedd)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_CellSmartTagPr() *CT_CellSmartTagPr { _fagd := &CT_CellSmartTagPr{}; return _fagd }

// ValidateWithPath validates the CT_PivotFilters and its children, prefixing error messages with path
func (_cfdcb *CT_PivotFilters) ValidateWithPath(path string) error {
	for _fadbe, _deaea := range _cfdcb.Filter {
		if _bcbfeb := _deaea.ValidateWithPath(_bg.Sprintf("\u0025s\u002fFilter\u005b\u0025d\u005d", path, _fadbe)); _bcbfeb != nil {
			return _bcbfeb
		}
	}
	return nil
}
func (_dgffg *CT_Chartsheet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _dgffg.SheetPr != nil {
		_cdaa := _f.StartElement{Name: _f.Name{Local: "ma:sheetPr"}}
		e.EncodeElement(_dgffg.SheetPr, _cdaa)
	}
	_dbaf := _f.StartElement{Name: _f.Name{Local: "ma:sheetViews"}}
	e.EncodeElement(_dgffg.SheetViews, _dbaf)
	if _dgffg.SheetProtection != nil {
		_eaegf := _f.StartElement{Name: _f.Name{Local: "ma:sheetProtection"}}
		e.EncodeElement(_dgffg.SheetProtection, _eaegf)
	}
	if _dgffg.CustomSheetViews != nil {
		_dabf := _f.StartElement{Name: _f.Name{Local: "ma:customSheetViews"}}
		e.EncodeElement(_dgffg.CustomSheetViews, _dabf)
	}
	if _dgffg.PageMargins != nil {
		_feacg := _f.StartElement{Name: _f.Name{Local: "ma:pageMargins"}}
		e.EncodeElement(_dgffg.PageMargins, _feacg)
	}
	if _dgffg.PageSetup != nil {
		_bagga := _f.StartElement{Name: _f.Name{Local: "ma:pageSetup"}}
		e.EncodeElement(_dgffg.PageSetup, _bagga)
	}
	if _dgffg.HeaderFooter != nil {
		_bcbb := _f.StartElement{Name: _f.Name{Local: "ma:headerFooter"}}
		e.EncodeElement(_dgffg.HeaderFooter, _bcbb)
	}
	_eefd := _f.StartElement{Name: _f.Name{Local: "ma:drawing"}}
	e.EncodeElement(_dgffg.Drawing, _eefd)
	if _dgffg.LegacyDrawing != nil {
		_dgeagc := _f.StartElement{Name: _f.Name{Local: "ma:legacyDrawing"}}
		e.EncodeElement(_dgffg.LegacyDrawing, _dgeagc)
	}
	if _dgffg.LegacyDrawingHF != nil {
		_ebcg := _f.StartElement{Name: _f.Name{Local: "ma:legacyDrawingHF"}}
		e.EncodeElement(_dgffg.LegacyDrawingHF, _ebcg)
	}
	if _dgffg.DrawingHF != nil {
		_bcbc := _f.StartElement{Name: _f.Name{Local: "ma:drawingHF"}}
		e.EncodeElement(_dgffg.DrawingHF, _bcbc)
	}
	if _dgffg.Picture != nil {
		_addca := _f.StartElement{Name: _f.Name{Local: "ma:picture"}}
		e.EncodeElement(_dgffg.Picture, _addca)
	}
	if _dgffg.WebPublishItems != nil {
		_acbf := _f.StartElement{Name: _f.Name{Local: "ma:webPublishItems"}}
		e.EncodeElement(_dgffg.WebPublishItems, _acbf)
	}
	if _dgffg.ExtLst != nil {
		_cdfb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_dgffg.ExtLst, _cdfb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gebbd *CT_rowItems) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _faddf := range start.Attr {
		if _faddf.Name.Local == "count" {
			_fdeffa, _gdedcc := _g.ParseUint(_faddf.Value, 10, 32)
			if _gdedcc != nil {
				return _gdedcc
			}
			_egffb := uint32(_fdeffa)
			_gebbd.CountAttr = &_egffb
			continue
		}
	}
_eebcb:
	for {
		_geaag, _fffcb := d.Token()
		if _fffcb != nil {
			return _fffcb
		}
		switch _ebbaf := _geaag.(type) {
		case _f.StartElement:
			switch _ebbaf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "i"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "i"}:
				_dgeaa := NewCT_I()
				if _fcada := d.DecodeElement(_dgeaa, &_ebbaf); _fcada != nil {
					return _fcada
				}
				_gebbd.I = append(_gebbd.I, _dgeaa)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_rowItems\u0020\u0025v", _ebbaf.Name)
				if _eedeb := d.Skip(); _eedeb != nil {
					return _eedeb
				}
			}
		case _f.EndElement:
			break _eebcb
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_CustomFilters() *CT_CustomFilters { _fdgcd := &CT_CustomFilters{}; return _fdgcd }

type CT_Row struct {

	// Row Index
	RAttr *uint32

	// Spans
	SpansAttr *ST_CellSpans

	// Style Index
	SAttr *uint32

	// Custom Format
	CustomFormatAttr *bool

	// Row Height
	HtAttr *float64

	// Hidden
	HiddenAttr *bool

	// Custom Height
	CustomHeightAttr *bool

	// Outline Level
	OutlineLevelAttr *uint8

	// Collapsed
	CollapsedAttr *bool

	// Thick Top Border
	ThickTopAttr *bool

	// Thick Bottom
	ThickBotAttr *bool

	// Show Phonetic
	PhAttr *bool

	// Cell
	C []*CT_Cell

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_fefd *CT_OleObjects) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_caaee:
	for {
		_dbgbe, _abbae := d.Token()
		if _abbae != nil {
			return _abbae
		}
		switch _dfced := _dbgbe.(type) {
		case _f.StartElement:
			switch _dfced.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleObject"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleObject"}:
				_ddcbe := NewCT_OleObject()
				if _bfed := d.DecodeElement(_ddcbe, &_dfced); _bfed != nil {
					return _bfed
				}
				_fefd.OleObject = append(_fefd.OleObject, _ddcbe)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_OleObjects \u0025v", _dfced.Name)
				if _ebeca := d.Skip(); _ebeca != nil {
					return _ebeca
				}
			}
		case _f.EndElement:
			break _caaee
		case _f.CharData:
		}
	}
	return nil
}
func (_bdedbd ST_CellComments) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bdedbd.String(), start)
}
func (_cceec ST_TimePeriod) Validate() error { return _cceec.ValidateWithPath("") }

type CT_Set struct {

	// Number of Tuples
	CountAttr *uint32

	// Maximum Rank Requested
	MaxRankAttr int32

	// MDX Set Definition
	SetDefinitionAttr string

	// Set Sort Order
	SortTypeAttr ST_SortType

	// Query Failed
	QueryFailedAttr *bool

	// Tuples
	Tpls []*CT_Tuples

	// Sort By Tuple
	SortByTuple *CT_Tuples
}

// Validate validates the CT_QueryTableFields and its children
func (_eaceb *CT_QueryTableFields) Validate() error {
	return _eaceb.ValidateWithPath("CT_QueryTableFields")
}

// Validate validates the CT_ExternalCell and its children
func (_adccf *CT_ExternalCell) Validate() error { return _adccf.ValidateWithPath("CT_ExternalCell") }

// Validate validates the CT_RevisionSheetRename and its children
func (_dcafb *CT_RevisionSheetRename) Validate() error {
	return _dcafb.ValidateWithPath("CT_RevisionSheetRename")
}

// Validate validates the Dialogsheet and its children
func (_eecab *Dialogsheet) Validate() error { return _eecab.ValidateWithPath("Dialogsheet") }

// ValidateWithPath validates the CT_MetadataStringIndex and its children, prefixing error messages with path
func (_cfged *CT_MetadataStringIndex) ValidateWithPath(path string) error { return nil }

type CT_SortState struct {

	// Sort by Columns
	ColumnSortAttr *bool

	// Case Sensitive
	CaseSensitiveAttr *bool

	// Sort Method
	SortMethodAttr ST_SortMethod

	// Sort Range
	RefAttr string

	// Sort Condition
	SortCondition []*CT_SortCondition
	ExtLst        *CT_ExtensionList
}
type CT_FileSharing struct {

	// Read Only Recommended
	ReadOnlyRecommendedAttr *bool

	// User Name
	UserNameAttr *string

	// Write Reservation Password
	ReservationPasswordAttr *string

	// Cryptographic Algorithm Name
	AlgorithmNameAttr *string

	// Password Hash Value
	HashValueAttr *string

	// Salt Value for Password Verifier
	SaltValueAttr *string

	// Iterations to Run Hashing Algorithm
	SpinCountAttr *uint32
}

func (_eacg *CT_CalcPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cedd := range start.Attr {
		if _cedd.Name.Local == "iterateDelta" {
			_edda, _ccae := _g.ParseFloat(_cedd.Value, 64)
			if _ccae != nil {
				return _ccae
			}
			_eacg.IterateDeltaAttr = &_edda
			continue
		}
		if _cedd.Name.Local == "calcMode" {
			_eacg.CalcModeAttr.UnmarshalXMLAttr(_cedd)
			continue
		}
		if _cedd.Name.Local == "fullCalcOnLoad" {
			_fdga, _fedec := _g.ParseBool(_cedd.Value)
			if _fedec != nil {
				return _fedec
			}
			_eacg.FullCalcOnLoadAttr = &_fdga
			continue
		}
		if _cedd.Name.Local == "refMode" {
			_eacg.RefModeAttr.UnmarshalXMLAttr(_cedd)
			continue
		}
		if _cedd.Name.Local == "iterate" {
			_gbf, _dadgd := _g.ParseBool(_cedd.Value)
			if _dadgd != nil {
				return _dadgd
			}
			_eacg.IterateAttr = &_gbf
			continue
		}
		if _cedd.Name.Local == "iterateCount" {
			_bfeg, _aga := _g.ParseUint(_cedd.Value, 10, 32)
			if _aga != nil {
				return _aga
			}
			_abdf := uint32(_bfeg)
			_eacg.IterateCountAttr = &_abdf
			continue
		}
		if _cedd.Name.Local == "calcId" {
			_ggadf, _aeeb := _g.ParseUint(_cedd.Value, 10, 32)
			if _aeeb != nil {
				return _aeeb
			}
			_dac := uint32(_ggadf)
			_eacg.CalcIdAttr = &_dac
			continue
		}
		if _cedd.Name.Local == "fullPrecision" {
			_fefce, _aaefc := _g.ParseBool(_cedd.Value)
			if _aaefc != nil {
				return _aaefc
			}
			_eacg.FullPrecisionAttr = &_fefce
			continue
		}
		if _cedd.Name.Local == "calcCompleted" {
			_edb, _cfa := _g.ParseBool(_cedd.Value)
			if _cfa != nil {
				return _cfa
			}
			_eacg.CalcCompletedAttr = &_edb
			continue
		}
		if _cedd.Name.Local == "calcOnSave" {
			_bege, _ddfdg := _g.ParseBool(_cedd.Value)
			if _ddfdg != nil {
				return _ddfdg
			}
			_eacg.CalcOnSaveAttr = &_bege
			continue
		}
		if _cedd.Name.Local == "concurrentCalc" {
			_cdb, _daga := _g.ParseBool(_cedd.Value)
			if _daga != nil {
				return _daga
			}
			_eacg.ConcurrentCalcAttr = &_cdb
			continue
		}
		if _cedd.Name.Local == "concurrentManualCount" {
			_dddb, _abbf := _g.ParseUint(_cedd.Value, 10, 32)
			if _abbf != nil {
				return _abbf
			}
			_gfce := uint32(_dddb)
			_eacg.ConcurrentManualCountAttr = &_gfce
			continue
		}
		if _cedd.Name.Local == "forceFullCalc" {
			_bce, _gce := _g.ParseBool(_cedd.Value)
			if _gce != nil {
				return _gce
			}
			_eacg.ForceFullCalcAttr = &_bce
			continue
		}
	}
	for {
		_cecb, _dccb := d.Token()
		if _dccb != nil {
			return _bg.Errorf("parsing\u0020CT_CalcPr:\u0020\u0025s", _dccb)
		}
		if _dege, _efgd := _cecb.(_f.EndElement); _efgd && _dege.Name == start.Name {
			break
		}
	}
	return nil
}
func (_aadbed *CT_Table) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", _aadbed.IdAttr)})
	if _aadbed.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_aadbed.NameAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "displayName"}, Value: _bg.Sprintf("\u0025v", _aadbed.DisplayNameAttr)})
	if _aadbed.CommentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "comment"}, Value: _bg.Sprintf("\u0025v", *_aadbed.CommentAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _aadbed.RefAttr)})
	if _aadbed.TableTypeAttr != ST_TableTypeUnset {
		_aeccfb, _efefd := _aadbed.TableTypeAttr.MarshalXMLAttr(_f.Name{Local: "tableType"})
		if _efefd != nil {
			return _efefd
		}
		start.Attr = append(start.Attr, _aeccfb)
	}
	if _aadbed.HeaderRowCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "headerRowCount"}, Value: _bg.Sprintf("\u0025v", *_aadbed.HeaderRowCountAttr)})
	}
	if _aadbed.InsertRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "insertRow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aadbed.InsertRowAttr))})
	}
	if _aadbed.InsertRowShiftAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "insertRowShift"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aadbed.InsertRowShiftAttr))})
	}
	if _aadbed.TotalsRowCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "totalsRowCount"}, Value: _bg.Sprintf("\u0025v", *_aadbed.TotalsRowCountAttr)})
	}
	if _aadbed.TotalsRowShownAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "totalsRowShown"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aadbed.TotalsRowShownAttr))})
	}
	if _aadbed.PublishedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "published"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aadbed.PublishedAttr))})
	}
	if _aadbed.HeaderRowDxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "headerRowDxfId"}, Value: _bg.Sprintf("\u0025v", *_aadbed.HeaderRowDxfIdAttr)})
	}
	if _aadbed.DataDxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataDxfId"}, Value: _bg.Sprintf("\u0025v", *_aadbed.DataDxfIdAttr)})
	}
	if _aadbed.TotalsRowDxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "totalsRowDxfId"}, Value: _bg.Sprintf("\u0025v", *_aadbed.TotalsRowDxfIdAttr)})
	}
	if _aadbed.HeaderRowBorderDxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "headerRowBorderDxfId"}, Value: _bg.Sprintf("\u0025v", *_aadbed.HeaderRowBorderDxfIdAttr)})
	}
	if _aadbed.TableBorderDxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "tableBorderDxfId"}, Value: _bg.Sprintf("\u0025v", *_aadbed.TableBorderDxfIdAttr)})
	}
	if _aadbed.TotalsRowBorderDxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "totalsRowBorderDxfId"}, Value: _bg.Sprintf("\u0025v", *_aadbed.TotalsRowBorderDxfIdAttr)})
	}
	if _aadbed.HeaderRowCellStyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "headerRowCellStyle"}, Value: _bg.Sprintf("\u0025v", *_aadbed.HeaderRowCellStyleAttr)})
	}
	if _aadbed.DataCellStyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataCellStyle"}, Value: _bg.Sprintf("\u0025v", *_aadbed.DataCellStyleAttr)})
	}
	if _aadbed.TotalsRowCellStyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "totalsRowCellStyle"}, Value: _bg.Sprintf("\u0025v", *_aadbed.TotalsRowCellStyleAttr)})
	}
	if _aadbed.ConnectionIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "connectionId"}, Value: _bg.Sprintf("\u0025v", *_aadbed.ConnectionIdAttr)})
	}
	e.EncodeToken(start)
	if _aadbed.AutoFilter != nil {
		_ddcge := _f.StartElement{Name: _f.Name{Local: "ma:autoFilter"}}
		e.EncodeElement(_aadbed.AutoFilter, _ddcge)
	}
	if _aadbed.SortState != nil {
		_bgbgdf := _f.StartElement{Name: _f.Name{Local: "ma:sortState"}}
		e.EncodeElement(_aadbed.SortState, _bgbgdf)
	}
	_bcbdc := _f.StartElement{Name: _f.Name{Local: "ma:tableColumns"}}
	e.EncodeElement(_aadbed.TableColumns, _bcbdc)
	if _aadbed.TableStyleInfo != nil {
		_accfb := _f.StartElement{Name: _f.Name{Local: "ma:tableStyleInfo"}}
		e.EncodeElement(_aadbed.TableStyleInfo, _accfb)
	}
	if _aadbed.ExtLst != nil {
		_beadf := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_aadbed.ExtLst, _beadf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ColorScale and its children, prefixing error messages with path
func (_cdca *CT_ColorScale) ValidateWithPath(path string) error {
	for _aeaac, _afdca := range _cdca.Cfvo {
		if _dggf := _afdca.ValidateWithPath(_bg.Sprintf("%s\u002fCfvo\u005b\u0025d\u005d", path, _aeaac)); _dggf != nil {
			return _dggf
		}
	}
	for _dgddc, _feca := range _cdca.Color {
		if _cedg := _feca.ValidateWithPath(_bg.Sprintf("\u0025s\u002fColor\u005b\u0025d\u005d", path, _dgddc)); _cedg != nil {
			return _cedg
		}
	}
	return nil
}
func (_abfbf *CT_ExtensionList) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _abfbf.Ext != nil {
		_aaca := _f.StartElement{Name: _f.Name{Local: "ma:ext"}}
		for _, _bddbc := range _abfbf.Ext {
			e.EncodeElement(_bddbc, _aaca)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bgbae *CT_Row) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bgbae.RAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", *_bgbae.RAttr)})
	}
	if _bgbae.SpansAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "spans"}, Value: _bg.Sprintf("\u0025v", *_bgbae.SpansAttr)})
	}
	if _bgbae.SAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "s"}, Value: _bg.Sprintf("\u0025v", *_bgbae.SAttr)})
	}
	if _bgbae.CustomFormatAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "customFormat"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgbae.CustomFormatAttr))})
	}
	if _bgbae.HtAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ht"}, Value: _bg.Sprintf("\u0025v", *_bgbae.HtAttr)})
	}
	if _bgbae.HiddenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hidden"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgbae.HiddenAttr))})
	}
	if _bgbae.CustomHeightAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "customHeight"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgbae.CustomHeightAttr))})
	}
	if _bgbae.OutlineLevelAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "outlineLevel"}, Value: _bg.Sprintf("\u0025v", *_bgbae.OutlineLevelAttr)})
	}
	if _bgbae.CollapsedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "collapsed"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgbae.CollapsedAttr))})
	}
	if _bgbae.ThickTopAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "thickTop"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgbae.ThickTopAttr))})
	}
	if _bgbae.ThickBotAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "thickBot"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgbae.ThickBotAttr))})
	}
	if _bgbae.PhAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ph"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgbae.PhAttr))})
	}
	e.EncodeToken(start)
	if _bgbae.C != nil {
		_abbfdc := _f.StartElement{Name: _f.Name{Local: "ma:c"}}
		for _, _efcf := range _bgbae.C {
			e.EncodeElement(_efcf, _abbfdc)
		}
	}
	if _bgbae.ExtLst != nil {
		_dbdcf := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_bgbae.ExtLst, _dbdcf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bdgdb *CT_Macrosheet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Name.Local = "ma:CT_Macrosheet"
	e.EncodeToken(start)
	if _bdgdb.SheetPr != nil {
		_afdga := _f.StartElement{Name: _f.Name{Local: "ma:sheetPr"}}
		e.EncodeElement(_bdgdb.SheetPr, _afdga)
	}
	if _bdgdb.Dimension != nil {
		_fcdd := _f.StartElement{Name: _f.Name{Local: "ma:dimension"}}
		e.EncodeElement(_bdgdb.Dimension, _fcdd)
	}
	if _bdgdb.SheetViews != nil {
		_ddbg := _f.StartElement{Name: _f.Name{Local: "ma:sheetViews"}}
		e.EncodeElement(_bdgdb.SheetViews, _ddbg)
	}
	if _bdgdb.SheetFormatPr != nil {
		_ccegg := _f.StartElement{Name: _f.Name{Local: "ma:sheetFormatPr"}}
		e.EncodeElement(_bdgdb.SheetFormatPr, _ccegg)
	}
	if _bdgdb.Cols != nil {
		_gdfcf := _f.StartElement{Name: _f.Name{Local: "ma:cols"}}
		for _, _bbfeg := range _bdgdb.Cols {
			e.EncodeElement(_bbfeg, _gdfcf)
		}
	}
	_caceb := _f.StartElement{Name: _f.Name{Local: "ma:sheetData"}}
	e.EncodeElement(_bdgdb.SheetData, _caceb)
	if _bdgdb.SheetProtection != nil {
		_cbccf := _f.StartElement{Name: _f.Name{Local: "ma:sheetProtection"}}
		e.EncodeElement(_bdgdb.SheetProtection, _cbccf)
	}
	if _bdgdb.AutoFilter != nil {
		_gage := _f.StartElement{Name: _f.Name{Local: "ma:autoFilter"}}
		e.EncodeElement(_bdgdb.AutoFilter, _gage)
	}
	if _bdgdb.SortState != nil {
		_bcge := _f.StartElement{Name: _f.Name{Local: "ma:sortState"}}
		e.EncodeElement(_bdgdb.SortState, _bcge)
	}
	if _bdgdb.DataConsolidate != nil {
		_cdee := _f.StartElement{Name: _f.Name{Local: "ma:dataConsolidate"}}
		e.EncodeElement(_bdgdb.DataConsolidate, _cdee)
	}
	if _bdgdb.CustomSheetViews != nil {
		_gdgddd := _f.StartElement{Name: _f.Name{Local: "ma:customSheetViews"}}
		e.EncodeElement(_bdgdb.CustomSheetViews, _gdgddd)
	}
	if _bdgdb.PhoneticPr != nil {
		_daddcg := _f.StartElement{Name: _f.Name{Local: "ma:phoneticPr"}}
		e.EncodeElement(_bdgdb.PhoneticPr, _daddcg)
	}
	if _bdgdb.ConditionalFormatting != nil {
		_bcce := _f.StartElement{Name: _f.Name{Local: "ma:conditionalFormatting"}}
		for _, _dfbab := range _bdgdb.ConditionalFormatting {
			e.EncodeElement(_dfbab, _bcce)
		}
	}
	if _bdgdb.PrintOptions != nil {
		_geaad := _f.StartElement{Name: _f.Name{Local: "ma:printOptions"}}
		e.EncodeElement(_bdgdb.PrintOptions, _geaad)
	}
	if _bdgdb.PageMargins != nil {
		_bfgcb := _f.StartElement{Name: _f.Name{Local: "ma:pageMargins"}}
		e.EncodeElement(_bdgdb.PageMargins, _bfgcb)
	}
	if _bdgdb.PageSetup != nil {
		_abbfe := _f.StartElement{Name: _f.Name{Local: "ma:pageSetup"}}
		e.EncodeElement(_bdgdb.PageSetup, _abbfe)
	}
	if _bdgdb.HeaderFooter != nil {
		_dgdag := _f.StartElement{Name: _f.Name{Local: "ma:headerFooter"}}
		e.EncodeElement(_bdgdb.HeaderFooter, _dgdag)
	}
	if _bdgdb.RowBreaks != nil {
		_fcff := _f.StartElement{Name: _f.Name{Local: "ma:rowBreaks"}}
		e.EncodeElement(_bdgdb.RowBreaks, _fcff)
	}
	if _bdgdb.ColBreaks != nil {
		_aeade := _f.StartElement{Name: _f.Name{Local: "ma:colBreaks"}}
		e.EncodeElement(_bdgdb.ColBreaks, _aeade)
	}
	if _bdgdb.CustomProperties != nil {
		_bcegf := _f.StartElement{Name: _f.Name{Local: "ma:customProperties"}}
		e.EncodeElement(_bdgdb.CustomProperties, _bcegf)
	}
	if _bdgdb.Drawing != nil {
		_dcbff := _f.StartElement{Name: _f.Name{Local: "ma:drawing"}}
		e.EncodeElement(_bdgdb.Drawing, _dcbff)
	}
	if _bdgdb.LegacyDrawing != nil {
		_ggaed := _f.StartElement{Name: _f.Name{Local: "ma:legacyDrawing"}}
		e.EncodeElement(_bdgdb.LegacyDrawing, _ggaed)
	}
	if _bdgdb.LegacyDrawingHF != nil {
		_dbbdgf := _f.StartElement{Name: _f.Name{Local: "ma:legacyDrawingHF"}}
		e.EncodeElement(_bdgdb.LegacyDrawingHF, _dbbdgf)
	}
	if _bdgdb.DrawingHF != nil {
		_ecaff := _f.StartElement{Name: _f.Name{Local: "ma:drawingHF"}}
		e.EncodeElement(_bdgdb.DrawingHF, _ecaff)
	}
	if _bdgdb.Picture != nil {
		_dgfbf := _f.StartElement{Name: _f.Name{Local: "ma:picture"}}
		e.EncodeElement(_bdgdb.Picture, _dgfbf)
	}
	if _bdgdb.OleObjects != nil {
		_dfgc := _f.StartElement{Name: _f.Name{Local: "ma:oleObjects"}}
		e.EncodeElement(_bdgdb.OleObjects, _dfgc)
	}
	if _bdgdb.ExtLst != nil {
		_cacca := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_bdgdb.ExtLst, _cacca)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_IconSet and its children
func (_gbbdd *CT_IconSet) Validate() error { return _gbbdd.ValidateWithPath("CT_IconSet") }
func (_gfcff *CT_OleLink) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ddggb := range start.Attr {
		if _ddggb.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _ddggb.Name.Local == "id" || _ddggb.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _ddggb.Name.Local == "id" {
			_fggbbd, _bbgad := _ddggb.Value, error(nil)
			if _bbgad != nil {
				return _bbgad
			}
			_gfcff.IdAttr = _fggbbd
			continue
		}
		if _ddggb.Name.Local == "progId" {
			_cbede, _cfgaac := _ddggb.Value, error(nil)
			if _cfgaac != nil {
				return _cfgaac
			}
			_gfcff.ProgIdAttr = _cbede
			continue
		}
	}
_gffgee:
	for {
		_badfg, _bcdgb := d.Token()
		if _bcdgb != nil {
			return _bcdgb
		}
		switch _egbaa := _badfg.(type) {
		case _f.StartElement:
			switch _egbaa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleItems"}:
				_gfcff.OleItems = NewCT_OleItems()
				if _feedb := d.DecodeElement(_gfcff.OleItems, &_egbaa); _feedb != nil {
					return _feedb
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_OleLink\u0020\u0025v", _egbaa.Name)
				if _egggd := d.Skip(); _egggd != nil {
					return _egggd
				}
			}
		case _f.EndElement:
			break _gffgee
		case _f.CharData:
		}
	}
	return nil
}

type CT_PageFields struct {

	// Page Item Count
	CountAttr *uint32

	// Page Field
	PageField []*CT_PageField
}

func (_abdgg *CT_RowFields) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aaaegb := range start.Attr {
		if _aaaegb.Name.Local == "count" {
			_dcadg, _ddbd := _g.ParseUint(_aaaegb.Value, 10, 32)
			if _ddbd != nil {
				return _ddbd
			}
			_gddef := uint32(_dcadg)
			_abdgg.CountAttr = &_gddef
			continue
		}
	}
_ffcga:
	for {
		_bfgfd, _abgfd := d.Token()
		if _abgfd != nil {
			return _abgfd
		}
		switch _ebcbf := _bfgfd.(type) {
		case _f.StartElement:
			switch _ebcbf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "field"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "field"}:
				_egdbg := NewCT_Field()
				if _egfce := d.DecodeElement(_egdbg, &_ebcbf); _egfce != nil {
					return _egfce
				}
				_abdgg.Field = append(_abdgg.Field, _egdbg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RowFields\u0020\u0025v", _ebcbf.Name)
				if _ffdec := d.Skip(); _ffdec != nil {
					return _ffdec
				}
			}
		case _f.EndElement:
			break _ffcga
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_XStringElement and its children, prefixing error messages with path
func (_ggggf *CT_XStringElement) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_ExternalCell and its children, prefixing error messages with path
func (_gdga *CT_ExternalCell) ValidateWithPath(path string) error {
	if _cefe := _gdga.TAttr.ValidateWithPath(path + "\u002fTAttr"); _cefe != nil {
		return _cefe
	}
	return nil
}
func (_dbcfc ST_DataValidationType) Validate() error { return _dbcfc.ValidateWithPath("") }
func NewCT_ChartsheetViews() *CT_ChartsheetViews     { _fbbbg := &CT_ChartsheetViews{}; return _fbbbg }

type CT_ExternalBook struct {
	IdAttr string

	// Supporting Workbook Sheet Names
	SheetNames *CT_ExternalSheetNames

	// Named Links
	DefinedNames *CT_ExternalDefinedNames

	// Cached Worksheet Data
	SheetDataSet *CT_ExternalSheetDataSet
}

func _fdbfb(_ffcebd bool) uint8 {
	if _ffcebd {
		return 1
	}
	return 0
}
func (_ggdge *CT_Dxf) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _ggdge.Font != nil {
		_ffbed := _f.StartElement{Name: _f.Name{Local: "ma:font"}}
		e.EncodeElement(_ggdge.Font, _ffbed)
	}
	if _ggdge.NumFmt != nil {
		_dbcd := _f.StartElement{Name: _f.Name{Local: "ma:numFmt"}}
		e.EncodeElement(_ggdge.NumFmt, _dbcd)
	}
	if _ggdge.Fill != nil {
		_ffbb := _f.StartElement{Name: _f.Name{Local: "ma:fill"}}
		e.EncodeElement(_ggdge.Fill, _ffbb)
	}
	if _ggdge.Alignment != nil {
		_facee := _f.StartElement{Name: _f.Name{Local: "ma:alignment"}}
		e.EncodeElement(_ggdge.Alignment, _facee)
	}
	if _ggdge.Border != nil {
		_cfcca := _f.StartElement{Name: _f.Name{Local: "ma:border"}}
		e.EncodeElement(_ggdge.Border, _cfcca)
	}
	if _ggdge.Protection != nil {
		_dcbc := _f.StartElement{Name: _f.Name{Local: "ma:protection"}}
		e.EncodeElement(_ggdge.Protection, _dcbc)
	}
	if _ggdge.ExtLst != nil {
		_daedb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_ggdge.ExtLst, _daedb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_acff *CT_DdeValues) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fgfgf := range start.Attr {
		if _fgfgf.Name.Local == "rows" {
			_acbgf, _cfegc := _g.ParseUint(_fgfgf.Value, 10, 32)
			if _cfegc != nil {
				return _cfegc
			}
			_eead := uint32(_acbgf)
			_acff.RowsAttr = &_eead
			continue
		}
		if _fgfgf.Name.Local == "cols" {
			_fdbbg, _gbcdc := _g.ParseUint(_fgfgf.Value, 10, 32)
			if _gbcdc != nil {
				return _gbcdc
			}
			_ggceed := uint32(_fdbbg)
			_acff.ColsAttr = &_ggceed
			continue
		}
	}
_cagd:
	for {
		_febc, _feda := d.Token()
		if _feda != nil {
			return _feda
		}
		switch _cede := _febc.(type) {
		case _f.StartElement:
			switch _cede.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "value"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "value"}:
				_ebac := NewCT_DdeValue()
				if _dbdd := d.DecodeElement(_ebac, &_cede); _dbdd != nil {
					return _dbdd
				}
				_acff.Value = append(_acff.Value, _ebac)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DdeValues\u0020\u0025v", _cede.Name)
				if _acedf := d.Skip(); _acedf != nil {
					return _acedf
				}
			}
		case _f.EndElement:
			break _cagd
		case _f.CharData:
		}
	}
	return nil
}
func (_gdggc *CT_XmlColumnPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "mapId"}, Value: _bg.Sprintf("\u0025v", _gdggc.MapIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xpath"}, Value: _bg.Sprintf("\u0025v", _gdggc.XpathAttr)})
	if _gdggc.DenormalizedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "denormalized"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdggc.DenormalizedAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlDataType"}, Value: _bg.Sprintf("\u0025v", _gdggc.XmlDataTypeAttr)})
	e.EncodeToken(start)
	if _gdggc.ExtLst != nil {
		_ebgce := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_gdggc.ExtLst, _ebgce)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dcbcca *ST_Orientation) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_dcbcca = 0
	case "default":
		*_dcbcca = 1
	case "portrait":
		*_dcbcca = 2
	case "landscape":
		*_dcbcca = 3
	}
	return nil
}
func (_ffgde *CT_TableColumn) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", _ffgde.IdAttr)})
	if _ffgde.UniqueNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueName"}, Value: _bg.Sprintf("\u0025v", *_ffgde.UniqueNameAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _ffgde.NameAttr)})
	if _ffgde.TotalsRowFunctionAttr != ST_TotalsRowFunctionUnset {
		_bdfag, _cccgf := _ffgde.TotalsRowFunctionAttr.MarshalXMLAttr(_f.Name{Local: "totalsRowFunction"})
		if _cccgf != nil {
			return _cccgf
		}
		start.Attr = append(start.Attr, _bdfag)
	}
	if _ffgde.TotalsRowLabelAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "totalsRowLabel"}, Value: _bg.Sprintf("\u0025v", *_ffgde.TotalsRowLabelAttr)})
	}
	if _ffgde.QueryTableFieldIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "queryTableFieldId"}, Value: _bg.Sprintf("\u0025v", *_ffgde.QueryTableFieldIdAttr)})
	}
	if _ffgde.HeaderRowDxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "headerRowDxfId"}, Value: _bg.Sprintf("\u0025v", *_ffgde.HeaderRowDxfIdAttr)})
	}
	if _ffgde.DataDxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataDxfId"}, Value: _bg.Sprintf("\u0025v", *_ffgde.DataDxfIdAttr)})
	}
	if _ffgde.TotalsRowDxfIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "totalsRowDxfId"}, Value: _bg.Sprintf("\u0025v", *_ffgde.TotalsRowDxfIdAttr)})
	}
	if _ffgde.HeaderRowCellStyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "headerRowCellStyle"}, Value: _bg.Sprintf("\u0025v", *_ffgde.HeaderRowCellStyleAttr)})
	}
	if _ffgde.DataCellStyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataCellStyle"}, Value: _bg.Sprintf("\u0025v", *_ffgde.DataCellStyleAttr)})
	}
	if _ffgde.TotalsRowCellStyleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "totalsRowCellStyle"}, Value: _bg.Sprintf("\u0025v", *_ffgde.TotalsRowCellStyleAttr)})
	}
	e.EncodeToken(start)
	if _ffgde.CalculatedColumnFormula != nil {
		_gfgba := _f.StartElement{Name: _f.Name{Local: "ma:calculatedColumnFormula"}}
		e.EncodeElement(_ffgde.CalculatedColumnFormula, _gfgba)
	}
	if _ffgde.TotalsRowFormula != nil {
		_ebedd := _f.StartElement{Name: _f.Name{Local: "ma:totalsRowFormula"}}
		e.EncodeElement(_ffgde.TotalsRowFormula, _ebedd)
	}
	if _ffgde.XmlColumnPr != nil {
		_gddaf := _f.StartElement{Name: _f.Name{Local: "ma:xmlColumnPr"}}
		e.EncodeElement(_ffgde.XmlColumnPr, _gddaf)
	}
	if _ffgde.ExtLst != nil {
		_abeaca := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_ffgde.ExtLst, _abeaca)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_InputCells() *CT_InputCells { _bcdb := &CT_InputCells{}; return _bcdb }

// ValidateWithPath validates the CT_CellXfs and its children, prefixing error messages with path
func (_fbeed *CT_CellXfs) ValidateWithPath(path string) error {
	for _ageg, _bfbe := range _fbeed.Xf {
		if _fgeab := _bfbe.ValidateWithPath(_bg.Sprintf("\u0025s\u002fXf\u005b\u0025d]", path, _ageg)); _fgeab != nil {
			return _fgeab
		}
	}
	return nil
}

type CT_QueryTableRefresh struct {

	// Preserve Sort & Filter Layout
	PreserveSortFilterLayoutAttr *bool

	// Next Field Id Wrapped
	FieldIdWrappedAttr *bool

	// Headers In Last Refresh
	HeadersInLastRefreshAttr *bool

	// Minimum Refresh Version
	MinimumVersionAttr *uint8

	// Next field id
	NextIdAttr *uint32

	// Columns Left
	UnboundColumnsLeftAttr *uint32

	// Columns Right
	UnboundColumnsRightAttr *uint32

	// Query table fields
	QueryTableFields *CT_QueryTableFields

	// Deleted Fields
	QueryTableDeletedFields *CT_QueryTableDeletedFields

	// Sort State
	SortState *CT_SortState

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_fcgedf *CT_Member) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cbbgcg := range start.Attr {
		if _cbbgcg.Name.Local == "name" {
			_eefcc, _bgfcd := _cbbgcg.Value, error(nil)
			if _bgfcd != nil {
				return _bgfcd
			}
			_fcgedf.NameAttr = _eefcc
			continue
		}
	}
	for {
		_fcdda, _aagce := d.Token()
		if _aagce != nil {
			return _bg.Errorf("parsing\u0020CT_Member:\u0020\u0025s", _aagce)
		}
		if _bgcede, _cgggcd := _fcdda.(_f.EndElement); _cgggcd && _bgcede.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dfeag ST_CellFormulaType) ValidateWithPath(path string) error {
	switch _dfeag {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dfeag))
	}
	return nil
}
func NewCT_DrawingHF() *CT_DrawingHF { _cgaca := &CT_DrawingHF{}; return _cgaca }
func (_cbaf *CT_AutoSortScope) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cbaf.PivotArea = NewCT_PivotArea()
_ggf:
	for {
		_gaa, _fb := d.Token()
		if _fb != nil {
			return _fb
		}
		switch _adb := _gaa.(type) {
		case _f.StartElement:
			switch _adb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotArea"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotArea"}:
				if _eb := d.DecodeElement(_cbaf.PivotArea, &_adb); _eb != nil {
					return _eb
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_AutoSortScope\u0020\u0025v", _adb.Name)
				if _cae := d.Skip(); _cae != nil {
					return _cae
				}
			}
		case _f.EndElement:
			break _ggf
		case _f.CharData:
		}
	}
	return nil
}
func (_gdecd *CT_ExternalDefinedName) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _gdecd.NameAttr)})
	if _gdecd.RefersToAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refersTo"}, Value: _bg.Sprintf("\u0025v", *_gdecd.RefersToAttr)})
	}
	if _gdecd.SheetIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetId"}, Value: _bg.Sprintf("\u0025v", *_gdecd.SheetIdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_deaad *CT_PivotField) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _deaad.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_deaad.NameAttr)})
	}
	if _deaad.AxisAttr != ST_AxisUnset {
		_afda, _dacbb := _deaad.AxisAttr.MarshalXMLAttr(_f.Name{Local: "axis"})
		if _dacbb != nil {
			return _dacbb
		}
		start.Attr = append(start.Attr, _afda)
	}
	if _deaad.DataFieldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataField"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.DataFieldAttr))})
	}
	if _deaad.SubtotalCaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "subtotalCaption"}, Value: _bg.Sprintf("\u0025v", *_deaad.SubtotalCaptionAttr)})
	}
	if _deaad.ShowDropDownsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showDropDowns"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.ShowDropDownsAttr))})
	}
	if _deaad.HiddenLevelAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hiddenLevel"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.HiddenLevelAttr))})
	}
	if _deaad.UniqueMemberPropertyAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueMemberProperty"}, Value: _bg.Sprintf("\u0025v", *_deaad.UniqueMemberPropertyAttr)})
	}
	if _deaad.CompactAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "compact"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.CompactAttr))})
	}
	if _deaad.AllDrilledAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "allDrilled"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.AllDrilledAttr))})
	}
	if _deaad.NumFmtIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "numFmtId"}, Value: _bg.Sprintf("\u0025v", *_deaad.NumFmtIdAttr)})
	}
	if _deaad.OutlineAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "outline"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.OutlineAttr))})
	}
	if _deaad.SubtotalTopAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "subtotalTop"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.SubtotalTopAttr))})
	}
	if _deaad.DragToRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dragToRow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.DragToRowAttr))})
	}
	if _deaad.DragToColAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dragToCol"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.DragToColAttr))})
	}
	if _deaad.MultipleItemSelectionAllowedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "multipleItemSelectionAllowed"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.MultipleItemSelectionAllowedAttr))})
	}
	if _deaad.DragToPageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dragToPage"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.DragToPageAttr))})
	}
	if _deaad.DragToDataAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dragToData"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.DragToDataAttr))})
	}
	if _deaad.DragOffAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dragOff"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.DragOffAttr))})
	}
	if _deaad.ShowAllAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showAll"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.ShowAllAttr))})
	}
	if _deaad.InsertBlankRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "insertBlankRow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.InsertBlankRowAttr))})
	}
	if _deaad.ServerFieldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "serverField"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.ServerFieldAttr))})
	}
	if _deaad.InsertPageBreakAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "insertPageBreak"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.InsertPageBreakAttr))})
	}
	if _deaad.AutoShowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoShow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.AutoShowAttr))})
	}
	if _deaad.TopAutoShowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "topAutoShow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.TopAutoShowAttr))})
	}
	if _deaad.HideNewItemsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hideNewItems"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.HideNewItemsAttr))})
	}
	if _deaad.MeasureFilterAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "measureFilter"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.MeasureFilterAttr))})
	}
	if _deaad.IncludeNewItemsInFilterAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "includeNewItemsInFilter"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.IncludeNewItemsInFilterAttr))})
	}
	if _deaad.ItemPageCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "itemPageCount"}, Value: _bg.Sprintf("\u0025v", *_deaad.ItemPageCountAttr)})
	}
	if _deaad.SortTypeAttr != ST_FieldSortTypeUnset {
		_deeaa, _bcgf := _deaad.SortTypeAttr.MarshalXMLAttr(_f.Name{Local: "sortType"})
		if _bcgf != nil {
			return _bcgf
		}
		start.Attr = append(start.Attr, _deeaa)
	}
	if _deaad.DataSourceSortAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dataSourceSort"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.DataSourceSortAttr))})
	}
	if _deaad.NonAutoSortDefaultAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "nonAutoSortDefault"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.NonAutoSortDefaultAttr))})
	}
	if _deaad.RankByAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rankBy"}, Value: _bg.Sprintf("\u0025v", *_deaad.RankByAttr)})
	}
	if _deaad.DefaultSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.DefaultSubtotalAttr))})
	}
	if _deaad.SumSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sumSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.SumSubtotalAttr))})
	}
	if _deaad.CountASubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "countASubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.CountASubtotalAttr))})
	}
	if _deaad.AvgSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "avgSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.AvgSubtotalAttr))})
	}
	if _deaad.MaxSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "maxSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.MaxSubtotalAttr))})
	}
	if _deaad.MinSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.MinSubtotalAttr))})
	}
	if _deaad.ProductSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "productSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.ProductSubtotalAttr))})
	}
	if _deaad.CountSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "countSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.CountSubtotalAttr))})
	}
	if _deaad.StdDevSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "stdDevSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.StdDevSubtotalAttr))})
	}
	if _deaad.StdDevPSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "stdDevPSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.StdDevPSubtotalAttr))})
	}
	if _deaad.VarSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "varSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.VarSubtotalAttr))})
	}
	if _deaad.VarPSubtotalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "varPSubtotal"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.VarPSubtotalAttr))})
	}
	if _deaad.ShowPropCellAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showPropCell"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.ShowPropCellAttr))})
	}
	if _deaad.ShowPropTipAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showPropTip"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.ShowPropTipAttr))})
	}
	if _deaad.ShowPropAsCaptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showPropAsCaption"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.ShowPropAsCaptionAttr))})
	}
	if _deaad.DefaultAttributeDrillStateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "defaultAttributeDrillState"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_deaad.DefaultAttributeDrillStateAttr))})
	}
	e.EncodeToken(start)
	if _deaad.Items != nil {
		_acabg := _f.StartElement{Name: _f.Name{Local: "ma:items"}}
		e.EncodeElement(_deaad.Items, _acabg)
	}
	if _deaad.AutoSortScope != nil {
		_fbffc := _f.StartElement{Name: _f.Name{Local: "ma:autoSortScope"}}
		e.EncodeElement(_deaad.AutoSortScope, _fbffc)
	}
	if _deaad.ExtLst != nil {
		_fbegg := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_deaad.ExtLst, _fbegg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_ExternalDefinedNames() *CT_ExternalDefinedNames {
	_dfaaee := &CT_ExternalDefinedNames{}
	return _dfaaee
}
func (_ecgebe ST_PageOrder) ValidateWithPath(path string) error {
	switch _ecgebe {
	case 0, 1, 2:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ecgebe))
	}
	return nil
}
func (_afebe *CT_FieldGroup) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bgag := range start.Attr {
		if _bgag.Name.Local == "par" {
			_fcaf, _ggggaf := _g.ParseUint(_bgag.Value, 10, 32)
			if _ggggaf != nil {
				return _ggggaf
			}
			_fdcd := uint32(_fcaf)
			_afebe.ParAttr = &_fdcd
			continue
		}
		if _bgag.Name.Local == "base" {
			_adcf, _feeac := _g.ParseUint(_bgag.Value, 10, 32)
			if _feeac != nil {
				return _feeac
			}
			_egcf := uint32(_adcf)
			_afebe.BaseAttr = &_egcf
			continue
		}
	}
_bead:
	for {
		_aade, _aaafb := d.Token()
		if _aaafb != nil {
			return _aaafb
		}
		switch _dfaeg := _aade.(type) {
		case _f.StartElement:
			switch _dfaeg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rangePr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rangePr"}:
				_afebe.RangePr = NewCT_RangePr()
				if _faddb := d.DecodeElement(_afebe.RangePr, &_dfaeg); _faddb != nil {
					return _faddb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "discretePr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "discretePr"}:
				_afebe.DiscretePr = NewCT_DiscretePr()
				if _abcee := d.DecodeElement(_afebe.DiscretePr, &_dfaeg); _abcee != nil {
					return _abcee
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "groupItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "groupItems"}:
				_afebe.GroupItems = NewCT_GroupItems()
				if _egbece := d.DecodeElement(_afebe.GroupItems, &_dfaeg); _egbece != nil {
					return _egbece
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_FieldGroup \u0025v", _dfaeg.Name)
				if _cffe := d.Skip(); _cffe != nil {
					return _cffe
				}
			}
		case _f.EndElement:
			break _bead
		case _f.CharData:
		}
	}
	return nil
}

type ST_TotalsRowFunction byte

func NewCT_MergeCells() *CT_MergeCells      { _abfdd := &CT_MergeCells{}; return _abfdd }
func NewCT_CustomFilter() *CT_CustomFilter  { _cfcbb := &CT_CustomFilter{}; return _cfcbb }
func (_gfeag ST_Qualifier) Validate() error { return _gfeag.ValidateWithPath("") }

// ValidateWithPath validates the CT_ExternalSheetDataSet and its children, prefixing error messages with path
func (_bcffg *CT_ExternalSheetDataSet) ValidateWithPath(path string) error {
	for _aaefg, _baacg := range _bcffg.SheetData {
		if _gcefa := _baacg.ValidateWithPath(_bg.Sprintf("\u0025s/SheetData\u005b\u0025d\u005d", path, _aaefg)); _gcefa != nil {
			return _gcefa
		}
	}
	return nil
}

type ST_VolDepType byte

func (_agaae ST_PivotAreaType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_aaega := _f.Attr{}
	_aaega.Name = name
	switch _agaae {
	case ST_PivotAreaTypeUnset:
		_aaega.Value = ""
	case ST_PivotAreaTypeNone:
		_aaega.Value = "none"
	case ST_PivotAreaTypeNormal:
		_aaega.Value = "normal"
	case ST_PivotAreaTypeData:
		_aaega.Value = "data"
	case ST_PivotAreaTypeAll:
		_aaega.Value = "all"
	case ST_PivotAreaTypeOrigin:
		_aaega.Value = "origin"
	case ST_PivotAreaTypeButton:
		_aaega.Value = "button"
	case ST_PivotAreaTypeTopEnd:
		_aaega.Value = "topEnd"
	case ST_PivotAreaTypeTopRight:
		_aaega.Value = "topRight"
	}
	return _aaega, nil
}
func (_gfaabd ST_CalcMode) Validate() error { return _gfaabd.ValidateWithPath("") }
func (_babbd ST_TotalsRowFunction) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_cedfc := _f.Attr{}
	_cedfc.Name = name
	switch _babbd {
	case ST_TotalsRowFunctionUnset:
		_cedfc.Value = ""
	case ST_TotalsRowFunctionNone:
		_cedfc.Value = "none"
	case ST_TotalsRowFunctionSum:
		_cedfc.Value = "sum"
	case ST_TotalsRowFunctionMin:
		_cedfc.Value = "min"
	case ST_TotalsRowFunctionMax:
		_cedfc.Value = "max"
	case ST_TotalsRowFunctionAverage:
		_cedfc.Value = "average"
	case ST_TotalsRowFunctionCount:
		_cedfc.Value = "count"
	case ST_TotalsRowFunctionCountNums:
		_cedfc.Value = "countNums"
	case ST_TotalsRowFunctionStdDev:
		_cedfc.Value = "stdDev"
	case ST_TotalsRowFunctionVar:
		_cedfc.Value = "var"
	case ST_TotalsRowFunctionCustom:
		_cedfc.Value = "custom"
	}
	return _cedfc, nil
}
func (_gedgc *CT_TableStyleInfo) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ecbceba := range start.Attr {
		if _ecbceba.Name.Local == "name" {
			_bebae, _gcbfec := _ecbceba.Value, error(nil)
			if _gcbfec != nil {
				return _gcbfec
			}
			_gedgc.NameAttr = &_bebae
			continue
		}
		if _ecbceba.Name.Local == "showFirstColumn" {
			_fecga, _dadbba := _g.ParseBool(_ecbceba.Value)
			if _dadbba != nil {
				return _dadbba
			}
			_gedgc.ShowFirstColumnAttr = &_fecga
			continue
		}
		if _ecbceba.Name.Local == "showLastColumn" {
			_bgggdc, _fdcdg := _g.ParseBool(_ecbceba.Value)
			if _fdcdg != nil {
				return _fdcdg
			}
			_gedgc.ShowLastColumnAttr = &_bgggdc
			continue
		}
		if _ecbceba.Name.Local == "showRowStripes" {
			_degge, _dggec := _g.ParseBool(_ecbceba.Value)
			if _dggec != nil {
				return _dggec
			}
			_gedgc.ShowRowStripesAttr = &_degge
			continue
		}
		if _ecbceba.Name.Local == "showColumnStripes" {
			_aefef, _cdgfc := _g.ParseBool(_ecbceba.Value)
			if _cdgfc != nil {
				return _cdgfc
			}
			_gedgc.ShowColumnStripesAttr = &_aefef
			continue
		}
	}
	for {
		_agfeb, _adffg := d.Token()
		if _adffg != nil {
			return _bg.Errorf("parsing\u0020CT_TableStyleInfo: \u0025s", _adffg)
		}
		if _ecebd, _fbegca := _agfeb.(_f.EndElement); _fbegca && _ecebd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_eabd *ST_MdxSetOrder) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_eabd = 0
	case "u":
		*_eabd = 1
	case "a":
		*_eabd = 2
	case "d":
		*_eabd = 3
	case "aa":
		*_eabd = 4
	case "ad":
		*_eabd = 5
	case "na":
		*_eabd = 6
	case "nd":
		*_eabd = 7
	}
	return nil
}

// ValidateWithPath validates the CT_NumFmt and its children, prefixing error messages with path
func (_eefge *CT_NumFmt) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_DateTime and its children
func (_feefb *CT_DateTime) Validate() error { return _feefb.ValidateWithPath("CT_DateTime") }
func NewCT_CellStyle() *CT_CellStyle        { _fgeaf := &CT_CellStyle{}; return _fgeaf }
func NewCT_Borders() *CT_Borders            { _afb := &CT_Borders{}; return _afb }

// Validate validates the CT_Worksheet and its children
func (_dcbccd *CT_Worksheet) Validate() error { return _dcbccd.ValidateWithPath("CT_Worksheet") }
func (_bdb *CT_Authors) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _bdb.Author != nil {
		_bdc := _f.StartElement{Name: _f.Name{Local: "ma:author"}}
		for _, _cgg := range _bdb.Author {
			e.EncodeElement(_cgg, _bdc)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_ExternalLinkChoice() *CT_ExternalLinkChoice {
	_ebfcf := &CT_ExternalLinkChoice{}
	return _ebfcf
}
func (_fgec *CT_PageField) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cefce := range start.Attr {
		if _cefce.Name.Local == "fld" {
			_cebdff, _bdage := _g.ParseInt(_cefce.Value, 10, 32)
			if _bdage != nil {
				return _bdage
			}
			_fgec.FldAttr = int32(_cebdff)
			continue
		}
		if _cefce.Name.Local == "item" {
			_dfbeb, _ccdfac := _g.ParseUint(_cefce.Value, 10, 32)
			if _ccdfac != nil {
				return _ccdfac
			}
			_fdebe := uint32(_dfbeb)
			_fgec.ItemAttr = &_fdebe
			continue
		}
		if _cefce.Name.Local == "hier" {
			_begbg, _cecdf := _g.ParseInt(_cefce.Value, 10, 32)
			if _cecdf != nil {
				return _cecdf
			}
			_aaaedc := int32(_begbg)
			_fgec.HierAttr = &_aaaedc
			continue
		}
		if _cefce.Name.Local == "name" {
			_cacbb, _cgbed := _cefce.Value, error(nil)
			if _cgbed != nil {
				return _cgbed
			}
			_fgec.NameAttr = &_cacbb
			continue
		}
		if _cefce.Name.Local == "cap" {
			_adfbgb, _aadfae := _cefce.Value, error(nil)
			if _aadfae != nil {
				return _aadfae
			}
			_fgec.CapAttr = &_adfbgb
			continue
		}
	}
_ecece:
	for {
		_aacab, _acafa := d.Token()
		if _acafa != nil {
			return _acafa
		}
		switch _dbfeb := _aacab.(type) {
		case _f.StartElement:
			switch _dbfeb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_fgec.ExtLst = NewCT_ExtensionList()
				if _gfgf := d.DecodeElement(_fgec.ExtLst, &_dbfeb); _gfgf != nil {
					return _gfgf
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PageField\u0020\u0025v", _dbfeb.Name)
				if _accgb := d.Skip(); _accgb != nil {
					return _accgb
				}
			}
		case _f.EndElement:
			break _ecece
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_CalculatedItem() *CT_CalculatedItem {
	_gabe := &CT_CalculatedItem{}
	_gabe.PivotArea = NewCT_PivotArea()
	return _gabe
}

const (
	ST_GroupByUnset    ST_GroupBy = 0
	ST_GroupByRange    ST_GroupBy = 1
	ST_GroupBySeconds  ST_GroupBy = 2
	ST_GroupByMinutes  ST_GroupBy = 3
	ST_GroupByHours    ST_GroupBy = 4
	ST_GroupByDays     ST_GroupBy = 5
	ST_GroupByMonths   ST_GroupBy = 6
	ST_GroupByQuarters ST_GroupBy = 7
	ST_GroupByYears    ST_GroupBy = 8
)

func (_egdaf ST_DataConsolidateFunction) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_dfecgd := _f.Attr{}
	_dfecgd.Name = name
	switch _egdaf {
	case ST_DataConsolidateFunctionUnset:
		_dfecgd.Value = ""
	case ST_DataConsolidateFunctionAverage:
		_dfecgd.Value = "average"
	case ST_DataConsolidateFunctionCount:
		_dfecgd.Value = "count"
	case ST_DataConsolidateFunctionCountNums:
		_dfecgd.Value = "countNums"
	case ST_DataConsolidateFunctionMax:
		_dfecgd.Value = "max"
	case ST_DataConsolidateFunctionMin:
		_dfecgd.Value = "min"
	case ST_DataConsolidateFunctionProduct:
		_dfecgd.Value = "product"
	case ST_DataConsolidateFunctionStdDev:
		_dfecgd.Value = "stdDev"
	case ST_DataConsolidateFunctionStdDevp:
		_dfecgd.Value = "stdDevp"
	case ST_DataConsolidateFunctionSum:
		_dfecgd.Value = "sum"
	case ST_DataConsolidateFunctionVar:
		_dfecgd.Value = "var"
	case ST_DataConsolidateFunctionVarp:
		_dfecgd.Value = "varp"
	}
	return _dfecgd, nil
}
func (_gfafc *ST_ParameterType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_acgcdg, _dbbef := d.Token()
	if _dbbef != nil {
		return _dbbef
	}
	if _egdcc, _ddbag := _acgcdg.(_f.EndElement); _ddbag && _egdcc.Name == start.Name {
		*_gfafc = 1
		return nil
	}
	if _gecggc, _bbggc := _acgcdg.(_f.CharData); !_bbggc {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _acgcdg)
	} else {
		switch string(_gecggc) {
		case "":
			*_gfafc = 0
		case "prompt":
			*_gfafc = 1
		case "value":
			*_gfafc = 2
		case "cell":
			*_gfafc = 3
		}
	}
	_acgcdg, _dbbef = d.Token()
	if _dbbef != nil {
		return _dbbef
	}
	if _aaaae, _dfbfcf := _acgcdg.(_f.EndElement); _dfbfcf && _aaaae.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _acgcdg)
}

type CT_PivotHierarchy struct {

	// Outline New Levels
	OutlineAttr *bool

	// Multiple Field Filters
	MultipleItemSelectionAllowedAttr *bool

	// New Levels Subtotals At Top
	SubtotalTopAttr *bool

	// Show In Field List
	ShowInFieldListAttr *bool

	// Drag To Row
	DragToRowAttr *bool

	// Drag To Column
	DragToColAttr *bool

	// Drag to Page
	DragToPageAttr *bool

	// Drag To Data
	DragToDataAttr *bool

	// Drag Off
	DragOffAttr *bool

	// Inclusive Manual Filter
	IncludeNewItemsInFilterAttr *bool

	// Hierarchy Caption
	CaptionAttr *string

	// OLAP Member Properties
	Mps *CT_MemberProperties

	// Members
	Members []*CT_Members

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func NewCT_PageBreak() *CT_PageBreak { _bedba := &CT_PageBreak{}; return _bedba }

type CT_Dxf struct {

	// Font Properties
	Font *CT_Font

	// Number Format
	NumFmt *CT_NumFmt

	// Fill
	Fill *CT_Fill

	// Alignment
	Alignment *CT_CellAlignment

	// Border Properties
	Border *CT_Border

	// Protection Properties
	Protection *CT_CellProtection

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

const (
	ST_DataConsolidateFunctionUnset     ST_DataConsolidateFunction = 0
	ST_DataConsolidateFunctionAverage   ST_DataConsolidateFunction = 1
	ST_DataConsolidateFunctionCount     ST_DataConsolidateFunction = 2
	ST_DataConsolidateFunctionCountNums ST_DataConsolidateFunction = 3
	ST_DataConsolidateFunctionMax       ST_DataConsolidateFunction = 4
	ST_DataConsolidateFunctionMin       ST_DataConsolidateFunction = 5
	ST_DataConsolidateFunctionProduct   ST_DataConsolidateFunction = 6
	ST_DataConsolidateFunctionStdDev    ST_DataConsolidateFunction = 7
	ST_DataConsolidateFunctionStdDevp   ST_DataConsolidateFunction = 8
	ST_DataConsolidateFunctionSum       ST_DataConsolidateFunction = 9
	ST_DataConsolidateFunctionVar       ST_DataConsolidateFunction = 10
	ST_DataConsolidateFunctionVarp      ST_DataConsolidateFunction = 11
)

func (_gcdfc *CT_Error) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "v"}, Value: _bg.Sprintf("\u0025v", _gcdfc.VAttr)})
	if _gcdfc.UAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "u"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdfc.UAttr))})
	}
	if _gcdfc.FAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "f"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdfc.FAttr))})
	}
	if _gcdfc.CAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "c"}, Value: _bg.Sprintf("\u0025v", *_gcdfc.CAttr)})
	}
	if _gcdfc.CpAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cp"}, Value: _bg.Sprintf("\u0025v", *_gcdfc.CpAttr)})
	}
	if _gcdfc.InAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "in"}, Value: _bg.Sprintf("\u0025v", *_gcdfc.InAttr)})
	}
	if _gcdfc.BcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "bc"}, Value: _bg.Sprintf("\u0025v", *_gcdfc.BcAttr)})
	}
	if _gcdfc.FcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fc"}, Value: _bg.Sprintf("\u0025v", *_gcdfc.FcAttr)})
	}
	if _gcdfc.IAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "i"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdfc.IAttr))})
	}
	if _gcdfc.UnAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "un"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdfc.UnAttr))})
	}
	if _gcdfc.StAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "st"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdfc.StAttr))})
	}
	if _gcdfc.BAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "b"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdfc.BAttr))})
	}
	e.EncodeToken(start)
	if _gcdfc.Tpls != nil {
		_eefe := _f.StartElement{Name: _f.Name{Local: "ma:tpls"}}
		e.EncodeElement(_gcdfc.Tpls, _eefe)
	}
	if _gcdfc.X != nil {
		_gaeb := _f.StartElement{Name: _f.Name{Local: "ma:x"}}
		for _, _baed := range _gcdfc.X {
			e.EncodeElement(_baed, _gaeb)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_feeaeg ST_PivotFilterType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_feeaeg.String(), start)
}
func (_dcecc *ST_Comments) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_dcecc = 0
	case "commNone":
		*_dcecc = 1
	case "commIndicator":
		*_dcecc = 2
	case "commIndAndComment":
		*_dcecc = 3
	}
	return nil
}
func (_eagcc *CT_Fills) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dffa := range start.Attr {
		if _dffa.Name.Local == "count" {
			_dddg, _bggce := _g.ParseUint(_dffa.Value, 10, 32)
			if _bggce != nil {
				return _bggce
			}
			_eafdc := uint32(_dddg)
			_eagcc.CountAttr = &_eafdc
			continue
		}
	}
_afdbe:
	for {
		_baagaa, _caec := d.Token()
		if _caec != nil {
			return _caec
		}
		switch _gdbfc := _baagaa.(type) {
		case _f.StartElement:
			switch _gdbfc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fill"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fill"}:
				_bbgce := NewCT_Fill()
				if _beggde := d.DecodeElement(_bbgce, &_gdbfc); _beggde != nil {
					return _beggde
				}
				_eagcc.Fill = append(_eagcc.Fill, _bbgce)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Fills\u0020\u0025v", _gdbfc.Name)
				if _gfbf := d.Skip(); _gfbf != nil {
					return _gfbf
				}
			}
		case _f.EndElement:
			break _afdbe
		case _f.CharData:
		}
	}
	return nil
}
func (_ggbee *CT_Metadata) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _ggbee.MetadataTypes != nil {
		_ebcfc := _f.StartElement{Name: _f.Name{Local: "ma:metadataTypes"}}
		e.EncodeElement(_ggbee.MetadataTypes, _ebcfc)
	}
	if _ggbee.MetadataStrings != nil {
		_ggfad := _f.StartElement{Name: _f.Name{Local: "ma:metadataStrings"}}
		e.EncodeElement(_ggbee.MetadataStrings, _ggfad)
	}
	if _ggbee.MdxMetadata != nil {
		_dadgg := _f.StartElement{Name: _f.Name{Local: "ma:mdxMetadata"}}
		e.EncodeElement(_ggbee.MdxMetadata, _dadgg)
	}
	if _ggbee.FutureMetadata != nil {
		_dedgc := _f.StartElement{Name: _f.Name{Local: "ma:futureMetadata"}}
		for _, _fcacb := range _ggbee.FutureMetadata {
			e.EncodeElement(_fcacb, _dedgc)
		}
	}
	if _ggbee.CellMetadata != nil {
		_ebddd := _f.StartElement{Name: _f.Name{Local: "ma:cellMetadata"}}
		e.EncodeElement(_ggbee.CellMetadata, _ebddd)
	}
	if _ggbee.ValueMetadata != nil {
		_agfbd := _f.StartElement{Name: _f.Name{Local: "ma:valueMetadata"}}
		e.EncodeElement(_ggbee.ValueMetadata, _agfbd)
	}
	if _ggbee.ExtLst != nil {
		_egfcb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_ggbee.ExtLst, _egfcb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_faec *CT_MetadataType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _faec.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minSupportedVersion"}, Value: _bg.Sprintf("\u0025v", _faec.MinSupportedVersionAttr)})
	if _faec.GhostRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ghostRow"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.GhostRowAttr))})
	}
	if _faec.GhostColAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ghostCol"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.GhostColAttr))})
	}
	if _faec.EditAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "edit"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.EditAttr))})
	}
	if _faec.DeleteAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "delete"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.DeleteAttr))})
	}
	if _faec.CopyAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "copy"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.CopyAttr))})
	}
	if _faec.PasteAllAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pasteAll"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.PasteAllAttr))})
	}
	if _faec.PasteFormulasAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pasteFormulas"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.PasteFormulasAttr))})
	}
	if _faec.PasteValuesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pasteValues"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.PasteValuesAttr))})
	}
	if _faec.PasteFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pasteFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.PasteFormatsAttr))})
	}
	if _faec.PasteCommentsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pasteComments"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.PasteCommentsAttr))})
	}
	if _faec.PasteDataValidationAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pasteDataValidation"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.PasteDataValidationAttr))})
	}
	if _faec.PasteBordersAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pasteBorders"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.PasteBordersAttr))})
	}
	if _faec.PasteColWidthsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pasteColWidths"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.PasteColWidthsAttr))})
	}
	if _faec.PasteNumberFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pasteNumberFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.PasteNumberFormatsAttr))})
	}
	if _faec.MergeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "merge"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.MergeAttr))})
	}
	if _faec.SplitFirstAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "splitFirst"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.SplitFirstAttr))})
	}
	if _faec.SplitAllAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "splitAll"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.SplitAllAttr))})
	}
	if _faec.RowColShiftAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rowColShift"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.RowColShiftAttr))})
	}
	if _faec.ClearAllAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "clearAll"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.ClearAllAttr))})
	}
	if _faec.ClearFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "clearFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.ClearFormatsAttr))})
	}
	if _faec.ClearContentsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "clearContents"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.ClearContentsAttr))})
	}
	if _faec.ClearCommentsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "clearComments"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.ClearCommentsAttr))})
	}
	if _faec.AssignAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "assign"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.AssignAttr))})
	}
	if _faec.CoerceAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "coerce"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.CoerceAttr))})
	}
	if _faec.AdjustAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "adjust"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.AdjustAttr))})
	}
	if _faec.CellMetaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cellMeta"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_faec.CellMetaAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_CustomSheetView and its children, prefixing error messages with path
func (_bcaec *CT_CustomSheetView) ValidateWithPath(path string) error {
	if !_e.ST_GuidPatternRe.MatchString(_bcaec.GuidAttr) {
		return _bg.Errorf("\u0025s\u002fm\u002eGuidAttr must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_GuidPatternRe, _bcaec.GuidAttr)
	}
	if _fadb := _bcaec.StateAttr.ValidateWithPath(path + "\u002fStateAttr"); _fadb != nil {
		return _fadb
	}
	if _cgfc := _bcaec.ViewAttr.ValidateWithPath(path + "\u002fViewAttr"); _cgfc != nil {
		return _cgfc
	}
	if _bcaec.Pane != nil {
		if _fbgc := _bcaec.Pane.ValidateWithPath(path + "\u002fPane"); _fbgc != nil {
			return _fbgc
		}
	}
	if _bcaec.Selection != nil {
		if _bade := _bcaec.Selection.ValidateWithPath(path + "\u002fSelection"); _bade != nil {
			return _bade
		}
	}
	if _bcaec.RowBreaks != nil {
		if _gcad := _bcaec.RowBreaks.ValidateWithPath(path + "\u002fRowBreaks"); _gcad != nil {
			return _gcad
		}
	}
	if _bcaec.ColBreaks != nil {
		if _egbf := _bcaec.ColBreaks.ValidateWithPath(path + "\u002fColBreaks"); _egbf != nil {
			return _egbf
		}
	}
	if _bcaec.PageMargins != nil {
		if _fcaab := _bcaec.PageMargins.ValidateWithPath(path + "\u002fPageMargins"); _fcaab != nil {
			return _fcaab
		}
	}
	if _bcaec.PrintOptions != nil {
		if _cbeb := _bcaec.PrintOptions.ValidateWithPath(path + "\u002fPrintOptions"); _cbeb != nil {
			return _cbeb
		}
	}
	if _bcaec.PageSetup != nil {
		if _begf := _bcaec.PageSetup.ValidateWithPath(path + "\u002fPageSetup"); _begf != nil {
			return _begf
		}
	}
	if _bcaec.HeaderFooter != nil {
		if _afac := _bcaec.HeaderFooter.ValidateWithPath(path + "\u002fHeaderFooter"); _afac != nil {
			return _afac
		}
	}
	if _bcaec.AutoFilter != nil {
		if _bcba := _bcaec.AutoFilter.ValidateWithPath(path + "/AutoFilter"); _bcba != nil {
			return _bcba
		}
	}
	if _bcaec.ExtLst != nil {
		if _ebdd := _bcaec.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ebdd != nil {
			return _ebdd
		}
	}
	return nil
}
func (_faaef ST_FilterOperator) Validate() error { return _faaef.ValidateWithPath("") }
func (_dbbaf *CT_DateTime) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "v"}, Value: _bg.Sprintf("\u0025v", _dbbaf.VAttr)})
	if _dbbaf.UAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "u"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dbbaf.UAttr))})
	}
	if _dbbaf.FAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "f"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dbbaf.FAttr))})
	}
	if _dbbaf.CAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "c"}, Value: _bg.Sprintf("\u0025v", *_dbbaf.CAttr)})
	}
	if _dbbaf.CpAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cp"}, Value: _bg.Sprintf("\u0025v", *_dbbaf.CpAttr)})
	}
	e.EncodeToken(start)
	if _dbbaf.X != nil {
		_decb := _f.StartElement{Name: _f.Name{Local: "ma:x"}}
		for _, _acedgd := range _dbbaf.X {
			e.EncodeElement(_acedgd, _decb)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_edcfc ST_FontScheme) String() string {
	switch _edcfc {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "major"
	case 3:
		return "minor"
	}
	return ""
}
func NewCT_Border() *CT_Border { _gfe := &CT_Border{}; return _gfe }

// ValidateWithPath validates the CT_PivotArea and its children, prefixing error messages with path
func (_faacb *CT_PivotArea) ValidateWithPath(path string) error {
	if _gfaed := _faacb.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _gfaed != nil {
		return _gfaed
	}
	if _bgbaf := _faacb.AxisAttr.ValidateWithPath(path + "\u002fAxisAttr"); _bgbaf != nil {
		return _bgbaf
	}
	if _faacb.References != nil {
		if _fgdbd := _faacb.References.ValidateWithPath(path + "/References"); _fgdbd != nil {
			return _fgdbd
		}
	}
	if _faacb.ExtLst != nil {
		if _cfeea := _faacb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cfeea != nil {
			return _cfeea
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Border and its children, prefixing error messages with path
func (_ccfd *CT_Border) ValidateWithPath(path string) error {
	if _ccfd.Start != nil {
		if _bad := _ccfd.Start.ValidateWithPath(path + "\u002fStart"); _bad != nil {
			return _bad
		}
	}
	if _ccfd.End != nil {
		if _cde := _ccfd.End.ValidateWithPath(path + "\u002fEnd"); _cde != nil {
			return _cde
		}
	}
	if _ccfd.Left != nil {
		if _ffd := _ccfd.Left.ValidateWithPath(path + "\u002fLeft"); _ffd != nil {
			return _ffd
		}
	}
	if _ccfd.Right != nil {
		if _cggg := _ccfd.Right.ValidateWithPath(path + "\u002fRight"); _cggg != nil {
			return _cggg
		}
	}
	if _ccfd.Top != nil {
		if _gdc := _ccfd.Top.ValidateWithPath(path + "\u002fTop"); _gdc != nil {
			return _gdc
		}
	}
	if _ccfd.Bottom != nil {
		if _cbdd := _ccfd.Bottom.ValidateWithPath(path + "\u002fBottom"); _cbdd != nil {
			return _cbdd
		}
	}
	if _ccfd.Diagonal != nil {
		if _fcb := _ccfd.Diagonal.ValidateWithPath(path + "\u002fDiagonal"); _fcb != nil {
			return _fcb
		}
	}
	if _ccfd.Vertical != nil {
		if _ebg := _ccfd.Vertical.ValidateWithPath(path + "\u002fVertical"); _ebg != nil {
			return _ebg
		}
	}
	if _ccfd.Horizontal != nil {
		if _gdg := _ccfd.Horizontal.ValidateWithPath(path + "/Horizontal"); _gdg != nil {
			return _gdg
		}
	}
	return nil
}
func (_dbdggc ST_PageOrder) Validate() error { return _dbdggc.ValidateWithPath("") }
func (_eaccb *CT_RevisionQueryTableField) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ccgadd := range start.Attr {
		if _ccgadd.Name.Local == "sheetId" {
			_dbfdac, _ccaea := _g.ParseUint(_ccgadd.Value, 10, 32)
			if _ccaea != nil {
				return _ccaea
			}
			_eaccb.SheetIdAttr = uint32(_dbfdac)
			continue
		}
		if _ccgadd.Name.Local == "ref" {
			_cfafa, _cafcba := _ccgadd.Value, error(nil)
			if _cafcba != nil {
				return _cafcba
			}
			_eaccb.RefAttr = _cfafa
			continue
		}
		if _ccgadd.Name.Local == "fieldId" {
			_egaeeg, _debed := _g.ParseUint(_ccgadd.Value, 10, 32)
			if _debed != nil {
				return _debed
			}
			_eaccb.FieldIdAttr = uint32(_egaeeg)
			continue
		}
	}
	for {
		_facdg, _aedegf := d.Token()
		if _aedegf != nil {
			return _bg.Errorf("parsing\u0020CT_RevisionQueryTableField:\u0020\u0025s", _aedegf)
		}
		if _ebbddb, _fbfdf := _facdg.(_f.EndElement); _fbfdf && _ebbddb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gcdg *CT_PrintOptions) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gcdg.HorizontalCenteredAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "horizontalCentered"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdg.HorizontalCenteredAttr))})
	}
	if _gcdg.VerticalCenteredAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "verticalCentered"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdg.VerticalCenteredAttr))})
	}
	if _gcdg.HeadingsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "headings"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdg.HeadingsAttr))})
	}
	if _gcdg.GridLinesAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "gridLines"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdg.GridLinesAttr))})
	}
	if _gcdg.GridLinesSetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "gridLinesSet"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gcdg.GridLinesSetAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_egede *ST_SourceType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_daeed, _efddc := d.Token()
	if _efddc != nil {
		return _efddc
	}
	if _aafeb, _ffegb := _daeed.(_f.EndElement); _ffegb && _aafeb.Name == start.Name {
		*_egede = 1
		return nil
	}
	if _gagaec, _dadddd := _daeed.(_f.CharData); !_dadddd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _daeed)
	} else {
		switch string(_gagaec) {
		case "":
			*_egede = 0
		case "worksheet":
			*_egede = 1
		case "external":
			*_egede = 2
		case "consolidation":
			*_egede = 3
		case "scenario":
			*_egede = 4
		}
	}
	_daeed, _efddc = d.Token()
	if _efddc != nil {
		return _efddc
	}
	if _edfcbd, _bgcca := _daeed.(_f.EndElement); _bgcca && _edfcbd.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _daeed)
}

type CT_CacheHierarchies struct {

	// Hierarchy Count
	CountAttr *uint32

	// PivotCache Hierarchy
	CacheHierarchy []*CT_CacheHierarchy
}

func (_gfdda *CT_RevisionConflict) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gfdda.SheetIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetId"}, Value: _bg.Sprintf("\u0025v", *_gfdda.SheetIdAttr)})
	}
	if _gfdda.RIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rId"}, Value: _bg.Sprintf("\u0025v", *_gfdda.RIdAttr)})
	}
	if _gfdda.UaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ua"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gfdda.UaAttr))})
	}
	if _gfdda.RaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ra"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gfdda.RaAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_afbgg *CT_Map) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ID"}, Value: _bg.Sprintf("\u0025v", _afbgg.IDAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "Name"}, Value: _bg.Sprintf("\u0025v", _afbgg.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "RootElement"}, Value: _bg.Sprintf("\u0025v", _afbgg.RootElementAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "SchemaID"}, Value: _bg.Sprintf("\u0025v", _afbgg.SchemaIDAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ShowImportExportValidationErrors"}, Value: _bg.Sprintf("\u0025d", _fdbfb(_afbgg.ShowImportExportValidationErrorsAttr))})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "AutoFit"}, Value: _bg.Sprintf("\u0025d", _fdbfb(_afbgg.AutoFitAttr))})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "Append"}, Value: _bg.Sprintf("\u0025d", _fdbfb(_afbgg.AppendAttr))})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "PreserveSortAFLayout"}, Value: _bg.Sprintf("\u0025d", _fdbfb(_afbgg.PreserveSortAFLayoutAttr))})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "PreserveFormat"}, Value: _bg.Sprintf("\u0025d", _fdbfb(_afbgg.PreserveFormatAttr))})
	e.EncodeToken(start)
	if _afbgg.DataBinding != nil {
		_dfbad := _f.StartElement{Name: _f.Name{Local: "ma:DataBinding"}}
		e.EncodeElement(_afbgg.DataBinding, _dfbad)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_CellSmartTag and its children
func (_ggdc *CT_CellSmartTag) Validate() error { return _ggdc.ValidateWithPath("CT_CellSmartTag") }

type ST_DataValidationType byte

func (_aacefb *CT_Sets) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aacefb.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_aacefb.CountAttr)})
	}
	e.EncodeToken(start)
	_ggcde := _f.StartElement{Name: _f.Name{Local: "ma:set"}}
	for _, _bcbde := range _aacefb.Set {
		e.EncodeElement(_bcbde, _ggcde)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cafgd ST_SortBy) ValidateWithPath(path string) error {
	switch _cafgd {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cafgd))
	}
	return nil
}

type CT_CellXfs struct {

	// Format Count
	CountAttr *uint32

	// Format
	Xf []*CT_Xf
}

func (_faece *CT_rowItems) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _faece.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_faece.CountAttr)})
	}
	e.EncodeToken(start)
	_fdcbag := _f.StartElement{Name: _f.Name{Local: "ma:i"}}
	for _, _eecgc := range _faece.I {
		e.EncodeElement(_eecgc, _fdcbag)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cgece ST_FilterOperator) ValidateWithPath(path string) error {
	switch _cgece {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cgece))
	}
	return nil
}

const (
	ST_MdxKPIPropertyUnset ST_MdxKPIProperty = 0
	ST_MdxKPIPropertyV     ST_MdxKPIProperty = 1
	ST_MdxKPIPropertyG     ST_MdxKPIProperty = 2
	ST_MdxKPIPropertyS     ST_MdxKPIProperty = 3
	ST_MdxKPIPropertyT     ST_MdxKPIProperty = 4
	ST_MdxKPIPropertyW     ST_MdxKPIProperty = 5
	ST_MdxKPIPropertyM     ST_MdxKPIProperty = 6
)

// ValidateWithPath validates the CT_QueryTableDeletedFields and its children, prefixing error messages with path
func (_bedega *CT_QueryTableDeletedFields) ValidateWithPath(path string) error {
	for _bcffef, _fgaff := range _bedega.DeletedField {
		if _gbcag := _fgaff.ValidateWithPath(_bg.Sprintf("\u0025s\u002fDeletedField\u005b\u0025d\u005d", path, _bcffef)); _gbcag != nil {
			return _gbcag
		}
	}
	return nil
}
func (_efccdd *ExternalLink) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_efccdd.CT_ExternalLink = *NewCT_ExternalLink()
_aabaca:
	for {
		_gffebe, _eeefgg := d.Token()
		if _eeefgg != nil {
			return _eeefgg
		}
		switch _bdgfe := _gffebe.(type) {
		case _f.StartElement:
			switch _bdgfe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "externalBook"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "externalBook"}:
				_efccdd.Choice = NewCT_ExternalLinkChoice()
				if _edfcbg := d.DecodeElement(&_efccdd.Choice.ExternalBook, &_bdgfe); _edfcbg != nil {
					return _edfcbg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ddeLink"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ddeLink"}:
				_efccdd.Choice = NewCT_ExternalLinkChoice()
				if _ecffd := d.DecodeElement(&_efccdd.Choice.DdeLink, &_bdgfe); _ecffd != nil {
					return _ecffd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleLink"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleLink"}:
				_efccdd.Choice = NewCT_ExternalLinkChoice()
				if _adgeb := d.DecodeElement(&_efccdd.Choice.OleLink, &_bdgfe); _adgeb != nil {
					return _adgeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_efccdd.ExtLst = NewCT_ExtensionList()
				if _ebaeac := d.DecodeElement(_efccdd.ExtLst, &_bdgfe); _ebaeac != nil {
					return _ebaeac
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020ExternalLink\u0020\u0025v", _bdgfe.Name)
				if _cfgbdd := d.Skip(); _cfgbdd != nil {
					return _cfgbdd
				}
			}
		case _f.EndElement:
			break _aabaca
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_CellWatch and its children
func (_affc *CT_CellWatch) Validate() error { return _affc.ValidateWithPath("CT_CellWatch") }

// ValidateWithPath validates the Users and its children, prefixing error messages with path
func (_gdaca *Users) ValidateWithPath(path string) error {
	if _fbccb := _gdaca.CT_Users.ValidateWithPath(path); _fbccb != nil {
		return _fbccb
	}
	return nil
}
func (_bcdeg *CT_VolTypes) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_bebad:
	for {
		_ebfed, _dfggb := d.Token()
		if _dfggb != nil {
			return _dfggb
		}
		switch _deebfc := _ebfed.(type) {
		case _f.StartElement:
			switch _deebfc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "volType"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "volType"}:
				_daefd := NewCT_VolType()
				if _ggabc := d.DecodeElement(_daefd, &_deebfc); _ggabc != nil {
					return _ggabc
				}
				_bcdeg.VolType = append(_bcdeg.VolType, _daefd)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bcdeg.ExtLst = NewCT_ExtensionList()
				if _gcaca := d.DecodeElement(_bcdeg.ExtLst, &_deebfc); _gcaca != nil {
					return _gcaca
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_VolTypes\u0020\u0025v", _deebfc.Name)
				if _bgdffe := d.Skip(); _bgdffe != nil {
					return _bgdffe
				}
			}
		case _f.EndElement:
			break _bebad
		case _f.CharData:
		}
	}
	return nil
}
func (_bcddg *ST_FieldSortType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bcddg = 0
	case "manual":
		*_bcddg = 1
	case "ascending":
		*_bcddg = 2
	case "descending":
		*_bcddg = 3
	}
	return nil
}

// Validate validates the AG_AutoFormat and its children
func (_ccf *AG_AutoFormat) Validate() error { return _ccf.ValidateWithPath("AG_AutoFormat") }

// ValidateWithPath validates the CT_RangeSet and its children, prefixing error messages with path
func (_dcedb *CT_RangeSet) ValidateWithPath(path string) error { return nil }
func (_ebbcc *CT_Extension) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ebbcc.UriAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uri"}, Value: _bg.Sprintf("\u0025v", *_ebbcc.UriAttr)})
	}
	e.EncodeToken(start)
	if _ebbcc.Any != nil {
		_ebbcc.Any.MarshalXML(e, _f.StartElement{})
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_ProtectedRanges() *CT_ProtectedRanges { _eeeca := &CT_ProtectedRanges{}; return _eeeca }
func (_feccd *CT_DataFields) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _feccd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_feccd.CountAttr)})
	}
	e.EncodeToken(start)
	_geegd := _f.StartElement{Name: _f.Name{Local: "ma:dataField"}}
	for _, _ffgfg := range _feccd.DataField {
		e.EncodeElement(_ffgfg, _geegd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_ChartFormat() *CT_ChartFormat {
	_geaa := &CT_ChartFormat{}
	_geaa.PivotArea = NewCT_PivotArea()
	return _geaa
}
func (_eaeea *CT_CustomChartsheetViews) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_aaad:
	for {
		_bagd, _bdeg := d.Token()
		if _bdeg != nil {
			return _bdeg
		}
		switch _ffec := _bagd.(type) {
		case _f.StartElement:
			switch _ffec.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customSheetView"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customSheetView"}:
				_dffbb := NewCT_CustomChartsheetView()
				if _cbca := d.DecodeElement(_dffbb, &_ffec); _cbca != nil {
					return _cbca
				}
				_eaeea.CustomSheetView = append(_eaeea.CustomSheetView, _dffbb)
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_CustomChartsheetViews\u0020%v", _ffec.Name)
				if _cebe := d.Skip(); _cebe != nil {
					return _cebe
				}
			}
		case _f.EndElement:
			break _aaad
		case _f.CharData:
		}
	}
	return nil
}

type ST_VerticalAlignment byte

func (_ebdgf *CT_DbPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abbba := range start.Attr {
		if _abbba.Name.Local == "connection" {
			_eabcd, _gcef := _abbba.Value, error(nil)
			if _gcef != nil {
				return _gcef
			}
			_ebdgf.ConnectionAttr = _eabcd
			continue
		}
		if _abbba.Name.Local == "command" {
			_gabeb, _fbbae := _abbba.Value, error(nil)
			if _fbbae != nil {
				return _fbbae
			}
			_ebdgf.CommandAttr = &_gabeb
			continue
		}
		if _abbba.Name.Local == "serverCommand" {
			_eebfc, _fcfde := _abbba.Value, error(nil)
			if _fcfde != nil {
				return _fcfde
			}
			_ebdgf.ServerCommandAttr = &_eebfc
			continue
		}
		if _abbba.Name.Local == "commandType" {
			_gece, _edaf := _g.ParseUint(_abbba.Value, 10, 32)
			if _edaf != nil {
				return _edaf
			}
			_efae := uint32(_gece)
			_ebdgf.CommandTypeAttr = &_efae
			continue
		}
	}
	for {
		_gadd, _deffg := d.Token()
		if _deffg != nil {
			return _bg.Errorf("parsing\u0020CT_DbPr:\u0020\u0025s", _deffg)
		}
		if _fcgf, _bfad := _gadd.(_f.EndElement); _bfad && _fcgf.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_PivotCacheDefinition and its children
func (_fadegd *CT_PivotCacheDefinition) Validate() error {
	return _fadegd.ValidateWithPath("CT_PivotCacheDefinition")
}
func (_gadde *CT_Record) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _gadde.M != nil {
		_eaaba := _f.StartElement{Name: _f.Name{Local: "ma:m"}}
		for _, _fggff := range _gadde.M {
			e.EncodeElement(_fggff, _eaaba)
		}
	}
	if _gadde.N != nil {
		_cafgbf := _f.StartElement{Name: _f.Name{Local: "ma:n"}}
		for _, _fdaca := range _gadde.N {
			e.EncodeElement(_fdaca, _cafgbf)
		}
	}
	if _gadde.B != nil {
		_bggcb := _f.StartElement{Name: _f.Name{Local: "ma:b"}}
		for _, _agbbeg := range _gadde.B {
			e.EncodeElement(_agbbeg, _bggcb)
		}
	}
	if _gadde.E != nil {
		_gbccd := _f.StartElement{Name: _f.Name{Local: "ma:e"}}
		for _, _bcaad := range _gadde.E {
			e.EncodeElement(_bcaad, _gbccd)
		}
	}
	if _gadde.S != nil {
		_gdbgb := _f.StartElement{Name: _f.Name{Local: "ma:s"}}
		for _, _fefff := range _gadde.S {
			e.EncodeElement(_fefff, _gdbgb)
		}
	}
	if _gadde.D != nil {
		_dgcfa := _f.StartElement{Name: _f.Name{Local: "ma:d"}}
		for _, _cdefb := range _gadde.D {
			e.EncodeElement(_cdefb, _dgcfa)
		}
	}
	if _gadde.X != nil {
		_fcbed := _f.StartElement{Name: _f.Name{Local: "ma:x"}}
		for _, _caadd := range _gadde.X {
			e.EncodeElement(_caadd, _fcbed)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_egbafg ST_FormulaExpression) String() string {
	switch _egbafg {
	case 0:
		return ""
	case 1:
		return "ref"
	case 2:
		return "refError"
	case 3:
		return "area"
	case 4:
		return "areaError"
	case 5:
		return "computedArea"
	}
	return ""
}
func (_efcgb *CT_GroupLevel) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ggbe := range start.Attr {
		if _ggbe.Name.Local == "uniqueName" {
			_aaabf, _fbec := _ggbe.Value, error(nil)
			if _fbec != nil {
				return _fbec
			}
			_efcgb.UniqueNameAttr = _aaabf
			continue
		}
		if _ggbe.Name.Local == "caption" {
			_bdeeb, _gfbg := _ggbe.Value, error(nil)
			if _gfbg != nil {
				return _gfbg
			}
			_efcgb.CaptionAttr = _bdeeb
			continue
		}
		if _ggbe.Name.Local == "user" {
			_efca, _eadfc := _g.ParseBool(_ggbe.Value)
			if _eadfc != nil {
				return _eadfc
			}
			_efcgb.UserAttr = &_efca
			continue
		}
		if _ggbe.Name.Local == "customRollUp" {
			_ebdgfa, _edebf := _g.ParseBool(_ggbe.Value)
			if _edebf != nil {
				return _edebf
			}
			_efcgb.CustomRollUpAttr = &_ebdgfa
			continue
		}
	}
_eafc:
	for {
		_addfg, _beadc := d.Token()
		if _beadc != nil {
			return _beadc
		}
		switch _fgfda := _addfg.(type) {
		case _f.StartElement:
			switch _fgfda.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "groups"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "groups"}:
				_efcgb.Groups = NewCT_Groups()
				if _acgbc := d.DecodeElement(_efcgb.Groups, &_fgfda); _acgbc != nil {
					return _acgbc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_efcgb.ExtLst = NewCT_ExtensionList()
				if _bbaa := d.DecodeElement(_efcgb.ExtLst, &_fgfda); _bbaa != nil {
					return _bbaa
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_GroupLevel \u0025v", _fgfda.Name)
				if _bbae := d.Skip(); _bbae != nil {
					return _bbae
				}
			}
		case _f.EndElement:
			break _eafc
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_TupleCache and its children
func (_eafad *CT_TupleCache) Validate() error { return _eafad.ValidateWithPath("CT_TupleCache") }
func (_geace *CT_CacheSource) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	_fdfga, _fbee := _geace.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
	if _fbee != nil {
		return _fbee
	}
	start.Attr = append(start.Attr, _fdfga)
	if _geace.ConnectionIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "connectionId"}, Value: _bg.Sprintf("\u0025v", *_geace.ConnectionIdAttr)})
	}
	e.EncodeToken(start)
	if _geace.WorksheetSource != nil {
		_dag := _f.StartElement{Name: _f.Name{Local: "ma:worksheetSource"}}
		e.EncodeElement(_geace.WorksheetSource, _dag)
	}
	if _geace.Consolidation != nil {
		_fdff := _f.StartElement{Name: _f.Name{Local: "ma:consolidation"}}
		e.EncodeElement(_geace.Consolidation, _fdff)
	}
	if _geace.ExtLst != nil {
		_bcfg := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_geace.ExtLst, _bcfg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_RPrElt and its children, prefixing error messages with path
func (_gebfgf *CT_RPrElt) ValidateWithPath(path string) error {
	if _gebfgf.RFont != nil {
		if _eebec := _gebfgf.RFont.ValidateWithPath(path + "\u002fRFont"); _eebec != nil {
			return _eebec
		}
	}
	if _gebfgf.Charset != nil {
		if _baggb := _gebfgf.Charset.ValidateWithPath(path + "\u002fCharset"); _baggb != nil {
			return _baggb
		}
	}
	if _gebfgf.Family != nil {
		if _dgaae := _gebfgf.Family.ValidateWithPath(path + "\u002fFamily"); _dgaae != nil {
			return _dgaae
		}
	}
	if _gebfgf.B != nil {
		if _gedef := _gebfgf.B.ValidateWithPath(path + "\u002fB"); _gedef != nil {
			return _gedef
		}
	}
	if _gebfgf.I != nil {
		if _bdaab := _gebfgf.I.ValidateWithPath(path + "\u002fI"); _bdaab != nil {
			return _bdaab
		}
	}
	if _gebfgf.Strike != nil {
		if _fdadda := _gebfgf.Strike.ValidateWithPath(path + "\u002fStrike"); _fdadda != nil {
			return _fdadda
		}
	}
	if _gebfgf.Outline != nil {
		if _cggge := _gebfgf.Outline.ValidateWithPath(path + "\u002fOutline"); _cggge != nil {
			return _cggge
		}
	}
	if _gebfgf.Shadow != nil {
		if _acegea := _gebfgf.Shadow.ValidateWithPath(path + "\u002fShadow"); _acegea != nil {
			return _acegea
		}
	}
	if _gebfgf.Condense != nil {
		if _bbgga := _gebfgf.Condense.ValidateWithPath(path + "\u002fCondense"); _bbgga != nil {
			return _bbgga
		}
	}
	if _gebfgf.Extend != nil {
		if _fgdad := _gebfgf.Extend.ValidateWithPath(path + "\u002fExtend"); _fgdad != nil {
			return _fgdad
		}
	}
	if _gebfgf.Color != nil {
		if _acbced := _gebfgf.Color.ValidateWithPath(path + "\u002fColor"); _acbced != nil {
			return _acbced
		}
	}
	if _gebfgf.Sz != nil {
		if _aacgc := _gebfgf.Sz.ValidateWithPath(path + "\u002fSz"); _aacgc != nil {
			return _aacgc
		}
	}
	if _gebfgf.U != nil {
		if _dafaf := _gebfgf.U.ValidateWithPath(path + "\u002fU"); _dafaf != nil {
			return _dafaf
		}
	}
	if _gebfgf.VertAlign != nil {
		if _fcbdc := _gebfgf.VertAlign.ValidateWithPath(path + "\u002fVertAlign"); _fcbdc != nil {
			return _fcbdc
		}
	}
	if _gebfgf.Scheme != nil {
		if _befef := _gebfgf.Scheme.ValidateWithPath(path + "\u002fScheme"); _befef != nil {
			return _befef
		}
	}
	return nil
}

// Validate validates the CT_FileVersion and its children
func (_dccbe *CT_FileVersion) Validate() error { return _dccbe.ValidateWithPath("CT_FileVersion") }
func (_ecbadcf *ST_CredMethod) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_ecbadcf = 0
	case "integrated":
		*_ecbadcf = 1
	case "none":
		*_ecbadcf = 2
	case "stored":
		*_ecbadcf = 3
	case "prompt":
		*_ecbadcf = 4
	}
	return nil
}

// ValidateWithPath validates the CT_RevisionCustomView and its children, prefixing error messages with path
func (_deccc *CT_RevisionCustomView) ValidateWithPath(path string) error {
	if !_e.ST_GuidPatternRe.MatchString(_deccc.GuidAttr) {
		return _bg.Errorf("\u0025s\u002fm\u002eGuidAttr must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_GuidPatternRe, _deccc.GuidAttr)
	}
	if _deccc.ActionAttr == ST_RevisionActionUnset {
		return _bg.Errorf("\u0025s\u002fActionAttr\u0020is a mandatory\u0020field", path)
	}
	if _agbgf := _deccc.ActionAttr.ValidateWithPath(path + "/ActionAttr"); _agbgf != nil {
		return _agbgf
	}
	return nil
}
func (_bdaed *CT_Dxfs) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bdaed.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bdaed.CountAttr)})
	}
	e.EncodeToken(start)
	if _bdaed.Dxf != nil {
		_ccgad := _f.StartElement{Name: _f.Name{Local: "ma:dxf"}}
		for _, _bdcae := range _bdaed.Dxf {
			e.EncodeElement(_bdcae, _ccgad)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_adeagd *ST_CfType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_adeagd = 0
	case "expression":
		*_adeagd = 1
	case "cellIs":
		*_adeagd = 2
	case "colorScale":
		*_adeagd = 3
	case "dataBar":
		*_adeagd = 4
	case "iconSet":
		*_adeagd = 5
	case "top10":
		*_adeagd = 6
	case "uniqueValues":
		*_adeagd = 7
	case "duplicateValues":
		*_adeagd = 8
	case "containsText":
		*_adeagd = 9
	case "notContainsText":
		*_adeagd = 10
	case "beginsWith":
		*_adeagd = 11
	case "endsWith":
		*_adeagd = 12
	case "containsBlanks":
		*_adeagd = 13
	case "notContainsBlanks":
		*_adeagd = 14
	case "containsErrors":
		*_adeagd = 15
	case "notContainsErrors":
		*_adeagd = 16
	case "timePeriod":
		*_adeagd = 17
	case "aboveAverage":
		*_adeagd = 18
	}
	return nil
}

// ValidateWithPath validates the AG_RevData and its children, prefixing error messages with path
func (_eag *AG_RevData) ValidateWithPath(path string) error { return nil }
func (_eafdag *CT_NumFmts) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _egggf := range start.Attr {
		if _egggf.Name.Local == "count" {
			_fgfb, _afbade := _g.ParseUint(_egggf.Value, 10, 32)
			if _afbade != nil {
				return _afbade
			}
			_bfggc := uint32(_fgfb)
			_eafdag.CountAttr = &_bfggc
			continue
		}
	}
_gaaae:
	for {
		_eecbg, _dbfab := d.Token()
		if _dbfab != nil {
			return _dbfab
		}
		switch _aegge := _eecbg.(type) {
		case _f.StartElement:
			switch _aegge.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "numFmt"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "numFmt"}:
				_fbbed := NewCT_NumFmt()
				if _fgfba := d.DecodeElement(_fbbed, &_aegge); _fgfba != nil {
					return _fgfba
				}
				_eafdag.NumFmt = append(_eafdag.NumFmt, _fbbed)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_NumFmts\u0020\u0025v", _aegge.Name)
				if _dacgb := d.Skip(); _dacgb != nil {
					return _dacgb
				}
			}
		case _f.EndElement:
			break _gaaae
		case _f.CharData:
		}
	}
	return nil
}

const (
	ST_CellTypeUnset     ST_CellType = 0
	ST_CellTypeB         ST_CellType = 1
	ST_CellTypeN         ST_CellType = 2
	ST_CellTypeE         ST_CellType = 3
	ST_CellTypeS         ST_CellType = 4
	ST_CellTypeStr       ST_CellType = 5
	ST_CellTypeInlineStr ST_CellType = 6
)

func NewCT_DataConsolidate() *CT_DataConsolidate { _fgfgc := &CT_DataConsolidate{}; return _fgfgc }
func (_bebffc *ST_CellType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bebffc = 0
	case "b":
		*_bebffc = 1
	case "n":
		*_bebffc = 2
	case "e":
		*_bebffc = 3
	case "s":
		*_bebffc = 4
	case "str":
		*_bebffc = 5
	case "inlineStr":
		*_bebffc = 6
	}
	return nil
}

// ValidateWithPath validates the CT_ConditionalFormat and its children, prefixing error messages with path
func (_facd *CT_ConditionalFormat) ValidateWithPath(path string) error {
	if _dcag := _facd.ScopeAttr.ValidateWithPath(path + "\u002fScopeAttr"); _dcag != nil {
		return _dcag
	}
	if _gcee := _facd.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _gcee != nil {
		return _gcee
	}
	if _becce := _facd.PivotAreas.ValidateWithPath(path + "/PivotAreas"); _becce != nil {
		return _becce
	}
	if _facd.ExtLst != nil {
		if _ebfg := _facd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ebfg != nil {
			return _ebfg
		}
	}
	return nil
}
func (_ecbff ST_TableStyleType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_ecbff.String(), start)
}
func NewCT_Dialogsheet() *CT_Dialogsheet { _beeba := &CT_Dialogsheet{}; return _beeba }

type CT_Schema struct {

	// Schema ID
	IDAttr string

	// Schema Reference
	SchemaRefAttr *string

	// Schema Root Namespace
	NamespaceAttr *string

	// Schema Language
	SchemaLanguageAttr *string
	Any                _cb.Any
}

func (_gegef *CT_I) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ddbf := range start.Attr {
		if _ddbf.Name.Local == "t" {
			_gegef.TAttr.UnmarshalXMLAttr(_ddbf)
			continue
		}
		if _ddbf.Name.Local == "r" {
			_cgabe, _egeba := _g.ParseUint(_ddbf.Value, 10, 32)
			if _egeba != nil {
				return _egeba
			}
			_ccffcb := uint32(_cgabe)
			_gegef.RAttr = &_ccffcb
			continue
		}
		if _ddbf.Name.Local == "i" {
			_fggg, _fbada := _g.ParseUint(_ddbf.Value, 10, 32)
			if _fbada != nil {
				return _fbada
			}
			_bcgdc := uint32(_fggg)
			_gegef.IAttr = &_bcgdc
			continue
		}
	}
_fbfe:
	for {
		_aecede, _gdfbd := d.Token()
		if _gdfbd != nil {
			return _gdfbd
		}
		switch _bffgb := _aecede.(type) {
		case _f.StartElement:
			switch _bffgb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "x"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "x"}:
				_dffc := NewCT_X()
				if _fadgb := d.DecodeElement(_dffc, &_bffgb); _fadgb != nil {
					return _fadgb
				}
				_gegef.X = append(_gegef.X, _dffc)
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_I\u0020\u0025v", _bffgb.Name)
				if _bbbae := d.Skip(); _bbbae != nil {
					return _bbbae
				}
			}
		case _f.EndElement:
			break _fbfe
		case _f.CharData:
		}
	}
	return nil
}

type Table struct{ CT_Table }

func (_abeg *CT_Chartsheet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_abeg.SheetViews = NewCT_ChartsheetViews()
	_abeg.Drawing = NewCT_Drawing()
_cecd:
	for {
		_edgc, _ffb := d.Token()
		if _ffb != nil {
			return _ffb
		}
		switch _gaed := _edgc.(type) {
		case _f.StartElement:
			switch _gaed.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetPr"}:
				_abeg.SheetPr = NewCT_ChartsheetPr()
				if _dgde := d.DecodeElement(_abeg.SheetPr, &_gaed); _dgde != nil {
					return _dgde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetViews"}:
				if _bcfa := d.DecodeElement(_abeg.SheetViews, &_gaed); _bcfa != nil {
					return _bcfa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetProtection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetProtection"}:
				_abeg.SheetProtection = NewCT_ChartsheetProtection()
				if _fbcag := d.DecodeElement(_abeg.SheetProtection, &_gaed); _fbcag != nil {
					return _fbcag
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customSheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customSheetViews"}:
				_abeg.CustomSheetViews = NewCT_CustomChartsheetViews()
				if _fbeeb := d.DecodeElement(_abeg.CustomSheetViews, &_gaed); _fbeeb != nil {
					return _fbeeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageMargins"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageMargins"}:
				_abeg.PageMargins = NewCT_PageMargins()
				if _bcbfe := d.DecodeElement(_abeg.PageMargins, &_gaed); _bcbfe != nil {
					return _bcbfe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageSetup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageSetup"}:
				_abeg.PageSetup = NewCT_CsPageSetup()
				if _eage := d.DecodeElement(_abeg.PageSetup, &_gaed); _eage != nil {
					return _eage
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "headerFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "headerFooter"}:
				_abeg.HeaderFooter = NewCT_HeaderFooter()
				if _adffc := d.DecodeElement(_abeg.HeaderFooter, &_gaed); _adffc != nil {
					return _adffc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawing"}:
				if _ebab := d.DecodeElement(_abeg.Drawing, &_gaed); _ebab != nil {
					return _ebab
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawing"}:
				_abeg.LegacyDrawing = NewCT_LegacyDrawing()
				if _edeb := d.DecodeElement(_abeg.LegacyDrawing, &_gaed); _edeb != nil {
					return _edeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawingHF"}:
				_abeg.LegacyDrawingHF = NewCT_LegacyDrawing()
				if _effa := d.DecodeElement(_abeg.LegacyDrawingHF, &_gaed); _effa != nil {
					return _effa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawingHF"}:
				_abeg.DrawingHF = NewCT_DrawingHF()
				if _cdda := d.DecodeElement(_abeg.DrawingHF, &_gaed); _cdda != nil {
					return _cdda
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "picture"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "picture"}:
				_abeg.Picture = NewCT_SheetBackgroundPicture()
				if _cfcb := d.DecodeElement(_abeg.Picture, &_gaed); _cfcb != nil {
					return _cfcb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "webPublishItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "webPublishItems"}:
				_abeg.WebPublishItems = NewCT_WebPublishItems()
				if _fdgg := d.DecodeElement(_abeg.WebPublishItems, &_gaed); _fdgg != nil {
					return _fdgg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_abeg.ExtLst = NewCT_ExtensionList()
				if _fbff := d.DecodeElement(_abeg.ExtLst, &_gaed); _fbff != nil {
					return _fbff
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_Chartsheet \u0025v", _gaed.Name)
				if _daee := d.Skip(); _daee != nil {
					return _daee
				}
			}
		case _f.EndElement:
			break _cecd
		case _f.CharData:
		}
	}
	return nil
}
func (_cgadc *CT_Comment) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _cgadc.RefAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "authorId"}, Value: _bg.Sprintf("\u0025v", _cgadc.AuthorIdAttr)})
	if _cgadc.GuidAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "guid"}, Value: _bg.Sprintf("\u0025v", *_cgadc.GuidAttr)})
	}
	if _cgadc.ShapeIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "shapeId"}, Value: _bg.Sprintf("\u0025v", *_cgadc.ShapeIdAttr)})
	}
	e.EncodeToken(start)
	_bebca := _f.StartElement{Name: _f.Name{Local: "ma:text"}}
	e.EncodeElement(_cgadc.Text, _bebca)
	if _cgadc.CommentPr != nil {
		_ebec := _f.StartElement{Name: _f.Name{Local: "ma:commentPr"}}
		e.EncodeElement(_cgadc.CommentPr, _ebec)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cagac *ST_HorizontalAlignment) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cgecb, _edaga := d.Token()
	if _edaga != nil {
		return _edaga
	}
	if _dgbbg, _fafcgg := _cgecb.(_f.EndElement); _fafcgg && _dgbbg.Name == start.Name {
		*_cagac = 1
		return nil
	}
	if _feafgc, _bbgceg := _cgecb.(_f.CharData); !_bbgceg {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cgecb)
	} else {
		switch string(_feafgc) {
		case "":
			*_cagac = 0
		case "general":
			*_cagac = 1
		case "left":
			*_cagac = 2
		case "center":
			*_cagac = 3
		case "right":
			*_cagac = 4
		case "fill":
			*_cagac = 5
		case "justify":
			*_cagac = 6
		case "centerContinuous":
			*_cagac = 7
		case "distributed":
			*_cagac = 8
		}
	}
	_cgecb, _edaga = d.Token()
	if _edaga != nil {
		return _edaga
	}
	if _gcgga, _cfcbbg := _cgecb.(_f.EndElement); _cfcbbg && _gcgga.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cgecb)
}

type CT_Item struct {

	// Item User Caption
	NAttr *string

	// Item Type
	TAttr ST_ItemType

	// Hidden
	HAttr *bool

	// Character
	SAttr *bool

	// Hide Details
	SdAttr *bool

	// Calculated Member
	FAttr *bool

	// Missing
	MAttr *bool

	// Child Items
	CAttr *bool

	// Item Index
	XAttr *uint32

	// Expanded
	DAttr *bool

	// Drill Across Attributes
	EAttr *bool
}
type CT_PivotAreaReferences struct {

	// Pivot Filter Count
	CountAttr *uint32

	// Reference
	Reference []*CT_PivotAreaReference
}

func (_ababc ST_SmartTagShow) Validate() error { return _ababc.ValidateWithPath("") }
func (_cefggf ST_CellFormulaType) String() string {
	switch _cefggf {
	case 0:
		return ""
	case 1:
		return "normal"
	case 2:
		return "array"
	case 3:
		return "dataTable"
	case 4:
		return "shared"
	}
	return ""
}
func (_dfbege *CT_RElt) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_dgbfg:
	for {
		_accef, _dccbfc := d.Token()
		if _dccbfc != nil {
			return _dccbfc
		}
		switch _dcfcb := _accef.(type) {
		case _f.StartElement:
			switch _dcfcb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rPr"}:
				_dfbege.RPr = NewCT_RPrElt()
				if _dfbgb := d.DecodeElement(_dfbege.RPr, &_dcfcb); _dfbgb != nil {
					return _dfbgb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "t"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "t"}:
				if _cadde := d.DecodeElement(&_dfbege.T, &_dcfcb); _cadde != nil {
					return _cadde
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RElt\u0020\u0025v", _dcfcb.Name)
				if _edeffd := d.Skip(); _edeffd != nil {
					return _edeffd
				}
			}
		case _f.EndElement:
			break _dgbfg
		case _f.CharData:
		}
	}
	return nil
}
func (_bagfc *CT_Connection) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bgeg := range start.Attr {
		if _bgeg.Name.Local == "deleted" {
			_eddef, _facc := _g.ParseBool(_bgeg.Value)
			if _facc != nil {
				return _facc
			}
			_bagfc.DeletedAttr = &_eddef
			continue
		}
		if _bgeg.Name.Local == "id" {
			_geg, _fbae := _g.ParseUint(_bgeg.Value, 10, 32)
			if _fbae != nil {
				return _fbae
			}
			_bagfc.IdAttr = uint32(_geg)
			continue
		}
		if _bgeg.Name.Local == "onlyUseConnectionFile" {
			_ebdcg, _dgcgb := _g.ParseBool(_bgeg.Value)
			if _dgcgb != nil {
				return _dgcgb
			}
			_bagfc.OnlyUseConnectionFileAttr = &_ebdcg
			continue
		}
		if _bgeg.Name.Local == "odcFile" {
			_gcff, _bddea := _bgeg.Value, error(nil)
			if _bddea != nil {
				return _bddea
			}
			_bagfc.OdcFileAttr = &_gcff
			continue
		}
		if _bgeg.Name.Local == "background" {
			_eafd, _eddda := _g.ParseBool(_bgeg.Value)
			if _eddda != nil {
				return _eddda
			}
			_bagfc.BackgroundAttr = &_eafd
			continue
		}
		if _bgeg.Name.Local == "interval" {
			_daff, _beffc := _g.ParseUint(_bgeg.Value, 10, 32)
			if _beffc != nil {
				return _beffc
			}
			_gaea := uint32(_daff)
			_bagfc.IntervalAttr = &_gaea
			continue
		}
		if _bgeg.Name.Local == "refreshOnLoad" {
			_bbgfa, _fabfc := _g.ParseBool(_bgeg.Value)
			if _fabfc != nil {
				return _fabfc
			}
			_bagfc.RefreshOnLoadAttr = &_bbgfa
			continue
		}
		if _bgeg.Name.Local == "description" {
			_fbde, _agec := _bgeg.Value, error(nil)
			if _agec != nil {
				return _agec
			}
			_bagfc.DescriptionAttr = &_fbde
			continue
		}
		if _bgeg.Name.Local == "saveData" {
			_gdfb, _eda := _g.ParseBool(_bgeg.Value)
			if _eda != nil {
				return _eda
			}
			_bagfc.SaveDataAttr = &_gdfb
			continue
		}
		if _bgeg.Name.Local == "reconnectionMethod" {
			_befbe, _fcce := _g.ParseUint(_bgeg.Value, 10, 32)
			if _fcce != nil {
				return _fcce
			}
			_bdbba := uint32(_befbe)
			_bagfc.ReconnectionMethodAttr = &_bdbba
			continue
		}
		if _bgeg.Name.Local == "credentials" {
			_bagfc.CredentialsAttr.UnmarshalXMLAttr(_bgeg)
			continue
		}
		if _bgeg.Name.Local == "keepAlive" {
			_fdbf, _gcfad := _g.ParseBool(_bgeg.Value)
			if _gcfad != nil {
				return _gcfad
			}
			_bagfc.KeepAliveAttr = &_fdbf
			continue
		}
		if _bgeg.Name.Local == "sourceFile" {
			_ffba, _fceg := _bgeg.Value, error(nil)
			if _fceg != nil {
				return _fceg
			}
			_bagfc.SourceFileAttr = &_ffba
			continue
		}
		if _bgeg.Name.Local == "singleSignOnId" {
			_eeec, _bffcf := _bgeg.Value, error(nil)
			if _bffcf != nil {
				return _bffcf
			}
			_bagfc.SingleSignOnIdAttr = &_eeec
			continue
		}
		if _bgeg.Name.Local == "savePassword" {
			_ddcaf, _baab := _g.ParseBool(_bgeg.Value)
			if _baab != nil {
				return _baab
			}
			_bagfc.SavePasswordAttr = &_ddcaf
			continue
		}
		if _bgeg.Name.Local == "name" {
			_cebgg, _cgcg := _bgeg.Value, error(nil)
			if _cgcg != nil {
				return _cgcg
			}
			_bagfc.NameAttr = &_cebgg
			continue
		}
		if _bgeg.Name.Local == "refreshedVersion" {
			_bfdd, _beacf := _g.ParseUint(_bgeg.Value, 10, 8)
			if _beacf != nil {
				return _beacf
			}
			_bagfc.RefreshedVersionAttr = uint8(_bfdd)
			continue
		}
		if _bgeg.Name.Local == "minRefreshableVersion" {
			_egad, _gbaf := _g.ParseUint(_bgeg.Value, 10, 8)
			if _gbaf != nil {
				return _gbaf
			}
			_bcae := uint8(_egad)
			_bagfc.MinRefreshableVersionAttr = &_bcae
			continue
		}
		if _bgeg.Name.Local == "new" {
			_dfae, _ddbba := _g.ParseBool(_bgeg.Value)
			if _ddbba != nil {
				return _ddbba
			}
			_bagfc.NewAttr = &_dfae
			continue
		}
		if _bgeg.Name.Local == "type" {
			_cacbd, _fcdg := _g.ParseUint(_bgeg.Value, 10, 32)
			if _fcdg != nil {
				return _fcdg
			}
			_eeefd := uint32(_cacbd)
			_bagfc.TypeAttr = &_eeefd
			continue
		}
	}
_fefcb:
	for {
		_bfegg, _fcde := d.Token()
		if _fcde != nil {
			return _fcde
		}
		switch _ecbd := _bfegg.(type) {
		case _f.StartElement:
			switch _ecbd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dbPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dbPr"}:
				_bagfc.DbPr = NewCT_DbPr()
				if _fcfc := d.DecodeElement(_bagfc.DbPr, &_ecbd); _fcfc != nil {
					return _fcfc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "olapPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "olapPr"}:
				_bagfc.OlapPr = NewCT_OlapPr()
				if _gdded := d.DecodeElement(_bagfc.OlapPr, &_ecbd); _gdded != nil {
					return _gdded
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "webPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "webPr"}:
				_bagfc.WebPr = NewCT_WebPr()
				if _ceca := d.DecodeElement(_bagfc.WebPr, &_ecbd); _ceca != nil {
					return _ceca
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "textPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "textPr"}:
				_bagfc.TextPr = NewCT_TextPr()
				if _bbbee := d.DecodeElement(_bagfc.TextPr, &_ecbd); _bbbee != nil {
					return _bbbee
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "parameters"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "parameters"}:
				_bagfc.Parameters = NewCT_Parameters()
				if _geec := d.DecodeElement(_bagfc.Parameters, &_ecbd); _geec != nil {
					return _geec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bagfc.ExtLst = NewCT_ExtensionList()
				if _eaeee := d.DecodeElement(_bagfc.ExtLst, &_ecbd); _eaeee != nil {
					return _eaeee
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_Connection \u0025v", _ecbd.Name)
				if _cdgg := d.Skip(); _cdgg != nil {
					return _cdgg
				}
			}
		case _f.EndElement:
			break _fefcb
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Pages and its children
func (_dafgb *CT_Pages) Validate() error { return _dafgb.ValidateWithPath("CT_Pages") }

type CT_Tuples struct {

	// Member Name Count
	CAttr *uint32

	// Tuple
	Tpl []*CT_Tuple
}

// Validate validates the SingleXmlCells and its children
func (_bdddaf *SingleXmlCells) Validate() error { return _bdddaf.ValidateWithPath("SingleXmlCells") }
func (_efegcb *Table) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:table"
	return _efegcb.CT_Table.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_Row and its children, prefixing error messages with path
func (_dfefa *CT_Row) ValidateWithPath(path string) error {
	for _fecbc, _daagc := range _dfefa.C {
		if _becdc := _daagc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fC\u005b\u0025d\u005d", path, _fecbc)); _becdc != nil {
			return _becdc
		}
	}
	if _dfefa.ExtLst != nil {
		if _dbbde := _dfefa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dbbde != nil {
			return _dbbde
		}
	}
	return nil
}
func (_dda *CT_Boolean) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "v"}, Value: _bg.Sprintf("\u0025d", _fdbfb(_dda.VAttr))})
	if _dda.UAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "u"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dda.UAttr))})
	}
	if _dda.FAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "f"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dda.FAttr))})
	}
	if _dda.CAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "c"}, Value: _bg.Sprintf("\u0025v", *_dda.CAttr)})
	}
	if _dda.CpAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cp"}, Value: _bg.Sprintf("\u0025v", *_dda.CpAttr)})
	}
	e.EncodeToken(start)
	if _dda.X != nil {
		_agfa := _f.StartElement{Name: _f.Name{Local: "ma:x"}}
		for _, _faa := range _dda.X {
			e.EncodeElement(_faa, _agfa)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TextFields and its children, prefixing error messages with path
func (_dageee *CT_TextFields) ValidateWithPath(path string) error {
	for _aaacf, _efefda := range _dageee.TextField {
		if _ecgba := _efefda.ValidateWithPath(_bg.Sprintf("\u0025s/TextField\u005b\u0025d\u005d", path, _aaacf)); _ecgba != nil {
			return _ecgba
		}
	}
	return nil
}

// Validate validates the CT_Filter and its children
func (_cgadd *CT_Filter) Validate() error { return _cgadd.ValidateWithPath("CT_Filter") }
func (_gabfdg ST_MdxFunctionType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_gabfdg.String(), start)
}

// ValidateWithPath validates the Revisions and its children, prefixing error messages with path
func (_ddaegf *Revisions) ValidateWithPath(path string) error {
	if _aabgb := _ddaegf.CT_Revisions.ValidateWithPath(path); _aabgb != nil {
		return _aabgb
	}
	return nil
}
func (_gfbade ST_TextHAlign) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_gfbade.String(), start)
}
func (_cbgcf *SingleXmlCells) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:singleXmlCells"
	return _cbgcf.CT_SingleXmlCells.MarshalXML(e, start)
}
func (_fccgcg ST_Axis) Validate() error { return _fccgcg.ValidateWithPath("") }

type CT_TextField struct {

	// Field Type
	TypeAttr ST_ExternalConnectionType

	// Position
	PositionAttr *uint32
}

// Validate validates the CT_WebPr and its children
func (_caeed *CT_WebPr) Validate() error { return _caeed.ValidateWithPath("CT_WebPr") }

type CT_I struct {

	// Item Type
	TAttr ST_ItemType

	// Repeated Items Count
	RAttr *uint32

	// Data Field Index
	IAttr *uint32

	// Row / Column Item Index
	X []*CT_X
}

// ValidateWithPath validates the CT_ChartsheetView and its children, prefixing error messages with path
func (_gcfa *CT_ChartsheetView) ValidateWithPath(path string) error {
	if _gcfa.ExtLst != nil {
		if _fcbga := _gcfa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fcbga != nil {
			return _fcbga
		}
	}
	return nil
}
func NewCT_PivotFields() *CT_PivotFields { _bfcb := &CT_PivotFields{}; return _bfcb }
func (_acdea *CT_MetadataStringIndex) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _efbaf := range start.Attr {
		if _efbaf.Name.Local == "x" {
			_bcdag, _dacfe := _g.ParseUint(_efbaf.Value, 10, 32)
			if _dacfe != nil {
				return _dacfe
			}
			_acdea.XAttr = uint32(_bcdag)
			continue
		}
		if _efbaf.Name.Local == "s" {
			_dcggd, _bdcg := _g.ParseBool(_efbaf.Value)
			if _bdcg != nil {
				return _bdcg
			}
			_acdea.SAttr = &_dcggd
			continue
		}
	}
	for {
		_dcbag, _fdaad := d.Token()
		if _fdaad != nil {
			return _bg.Errorf("parsing\u0020CT_MetadataStringIndex:\u0020\u0025s", _fdaad)
		}
		if _bbbfg, _fgabc := _dcbag.(_f.EndElement); _fgabc && _bbbfg.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_TableStyle struct {

	// Table Style Name
	NameAttr string

	// Pivot Style
	PivotAttr *bool

	// Table
	TableAttr *bool

	// Table Style Count
	CountAttr *uint32

	// Table Style
	TableStyleElement []*CT_TableStyleElement
}

func NewCT_MetadataRecord() *CT_MetadataRecord { _gcbd := &CT_MetadataRecord{}; return _gcbd }

// Validate validates the CT_PhoneticPr and its children
func (_dffdd *CT_PhoneticPr) Validate() error { return _dffdd.ValidateWithPath("CT_PhoneticPr") }
func (_cgec *CT_MdxTuple) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cgec.CAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "c"}, Value: _bg.Sprintf("\u0025v", *_cgec.CAttr)})
	}
	if _cgec.CtAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ct"}, Value: _bg.Sprintf("\u0025v", *_cgec.CtAttr)})
	}
	if _cgec.SiAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "si"}, Value: _bg.Sprintf("\u0025v", *_cgec.SiAttr)})
	}
	if _cgec.FiAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fi"}, Value: _bg.Sprintf("\u0025v", *_cgec.FiAttr)})
	}
	if _cgec.BcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "bc"}, Value: _bg.Sprintf("\u0025v", *_cgec.BcAttr)})
	}
	if _cgec.FcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fc"}, Value: _bg.Sprintf("\u0025v", *_cgec.FcAttr)})
	}
	if _cgec.IAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "i"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cgec.IAttr))})
	}
	if _cgec.UAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "u"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cgec.UAttr))})
	}
	if _cgec.StAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "st"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cgec.StAttr))})
	}
	if _cgec.BAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "b"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cgec.BAttr))})
	}
	e.EncodeToken(start)
	if _cgec.N != nil {
		_ebaec := _f.StartElement{Name: _f.Name{Local: "ma:n"}}
		for _, _bcddb := range _cgec.N {
			e.EncodeElement(_bcddb, _ebaec)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dddag ST_SheetState) String() string {
	switch _dddag {
	case 0:
		return ""
	case 1:
		return "visible"
	case 2:
		return "hidden"
	case 3:
		return "veryHidden"
	}
	return ""
}
func (_fgefe *ST_DvAspect) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fdcdfd, _aaacfg := d.Token()
	if _aaacfg != nil {
		return _aaacfg
	}
	if _fcead, _cbgee := _fdcdfd.(_f.EndElement); _cbgee && _fcead.Name == start.Name {
		*_fgefe = 1
		return nil
	}
	if _befebc, _degcab := _fdcdfd.(_f.CharData); !_degcab {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fdcdfd)
	} else {
		switch string(_befebc) {
		case "":
			*_fgefe = 0
		case "DVASPECT_CONTENT":
			*_fgefe = 1
		case "DVASPECT_ICON":
			*_fgefe = 2
		}
	}
	_fdcdfd, _aaacfg = d.Token()
	if _aaacfg != nil {
		return _aaacfg
	}
	if _fbedcf, _acbgfa := _fdcdfd.(_f.EndElement); _acbgfa && _fbedcf.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fdcdfd)
}
func NewCT_SharedUser() *CT_SharedUser {
	_daabc := &CT_SharedUser{}
	_daabc.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	return _daabc
}
func (_fdeab *CT_PivotAreaReferences) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gbafa := range start.Attr {
		if _gbafa.Name.Local == "count" {
			_fabbc, _gadae := _g.ParseUint(_gbafa.Value, 10, 32)
			if _gadae != nil {
				return _gadae
			}
			_aebebc := uint32(_fabbc)
			_fdeab.CountAttr = &_aebebc
			continue
		}
	}
_acgd:
	for {
		_ggcaa, _cegba := d.Token()
		if _cegba != nil {
			return _cegba
		}
		switch _cbgfa := _ggcaa.(type) {
		case _f.StartElement:
			switch _cbgfa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "reference"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "reference"}:
				_fbcea := NewCT_PivotAreaReference()
				if _acaag := d.DecodeElement(_fbcea, &_cbgfa); _acaag != nil {
					return _acaag
				}
				_fdeab.Reference = append(_fdeab.Reference, _fbcea)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PivotAreaReferences\u0020\u0025v", _cbgfa.Name)
				if _gfbfca := d.Skip(); _gfbfca != nil {
					return _gfbfca
				}
			}
		case _f.EndElement:
			break _acgd
		case _f.CharData:
		}
	}
	return nil
}

type CT_QueryTableDeletedFields struct {

	// Deleted Fields Count
	CountAttr *uint32

	// Deleted Field
	DeletedField []*CT_DeletedField
}

// ValidateWithPath validates the CT_MRUColors and its children, prefixing error messages with path
func (_bgaeb *CT_MRUColors) ValidateWithPath(path string) error {
	for _acaga, _dadf := range _bgaeb.Color {
		if _geffb := _dadf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fColor\u005b\u0025d\u005d", path, _acaga)); _geffb != nil {
			return _geffb
		}
	}
	return nil
}
func (_egcbb *ST_FilterOperator) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cecad, _dddgdg := d.Token()
	if _dddgdg != nil {
		return _dddgdg
	}
	if _gabcd, _adecgb := _cecad.(_f.EndElement); _adecgb && _gabcd.Name == start.Name {
		*_egcbb = 1
		return nil
	}
	if _agfbgg, _bbdbcd := _cecad.(_f.CharData); !_bbdbcd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cecad)
	} else {
		switch string(_agfbgg) {
		case "":
			*_egcbb = 0
		case "equal":
			*_egcbb = 1
		case "lessThan":
			*_egcbb = 2
		case "lessThanOrEqual":
			*_egcbb = 3
		case "notEqual":
			*_egcbb = 4
		case "greaterThanOrEqual":
			*_egcbb = 5
		case "greaterThan":
			*_egcbb = 6
		}
	}
	_cecad, _dddgdg = d.Token()
	if _dddgdg != nil {
		return _dddgdg
	}
	if _fafba, _gbgf := _cecad.(_f.EndElement); _gbgf && _fafba.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cecad)
}
func (_fdagae ST_VolDepType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_fdagae.String(), start)
}

// Validate validates the CT_PCDKPIs and its children
func (_gcbde *CT_PCDKPIs) Validate() error { return _gcbde.ValidateWithPath("CT_PCDKPIs") }
func (_cacgg *Chartsheet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cacgg.CT_Chartsheet = *NewCT_Chartsheet()
_gcfged:
	for {
		_fdecb, _bagdgde := d.Token()
		if _bagdgde != nil {
			return _bagdgde
		}
		switch _ebbdb := _fdecb.(type) {
		case _f.StartElement:
			switch _ebbdb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetPr"}:
				_cacgg.SheetPr = NewCT_ChartsheetPr()
				if _fecbgc := d.DecodeElement(_cacgg.SheetPr, &_ebbdb); _fecbgc != nil {
					return _fecbgc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetViews"}:
				if _bdggg := d.DecodeElement(_cacgg.SheetViews, &_ebbdb); _bdggg != nil {
					return _bdggg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetProtection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetProtection"}:
				_cacgg.SheetProtection = NewCT_ChartsheetProtection()
				if _fdebb := d.DecodeElement(_cacgg.SheetProtection, &_ebbdb); _fdebb != nil {
					return _fdebb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customSheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customSheetViews"}:
				_cacgg.CustomSheetViews = NewCT_CustomChartsheetViews()
				if _cgeabd := d.DecodeElement(_cacgg.CustomSheetViews, &_ebbdb); _cgeabd != nil {
					return _cgeabd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageMargins"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageMargins"}:
				_cacgg.PageMargins = NewCT_PageMargins()
				if _dfgfb := d.DecodeElement(_cacgg.PageMargins, &_ebbdb); _dfgfb != nil {
					return _dfgfb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageSetup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageSetup"}:
				_cacgg.PageSetup = NewCT_CsPageSetup()
				if _fdffe := d.DecodeElement(_cacgg.PageSetup, &_ebbdb); _fdffe != nil {
					return _fdffe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "headerFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "headerFooter"}:
				_cacgg.HeaderFooter = NewCT_HeaderFooter()
				if _gdcfc := d.DecodeElement(_cacgg.HeaderFooter, &_ebbdb); _gdcfc != nil {
					return _gdcfc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawing"}:
				if _abcde := d.DecodeElement(_cacgg.Drawing, &_ebbdb); _abcde != nil {
					return _abcde
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawing"}:
				_cacgg.LegacyDrawing = NewCT_LegacyDrawing()
				if _aceee := d.DecodeElement(_cacgg.LegacyDrawing, &_ebbdb); _aceee != nil {
					return _aceee
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawingHF"}:
				_cacgg.LegacyDrawingHF = NewCT_LegacyDrawing()
				if _eafbd := d.DecodeElement(_cacgg.LegacyDrawingHF, &_ebbdb); _eafbd != nil {
					return _eafbd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawingHF"}:
				_cacgg.DrawingHF = NewCT_DrawingHF()
				if _bedbb := d.DecodeElement(_cacgg.DrawingHF, &_ebbdb); _bedbb != nil {
					return _bedbb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "picture"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "picture"}:
				_cacgg.Picture = NewCT_SheetBackgroundPicture()
				if _dfagb := d.DecodeElement(_cacgg.Picture, &_ebbdb); _dfagb != nil {
					return _dfagb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "webPublishItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "webPublishItems"}:
				_cacgg.WebPublishItems = NewCT_WebPublishItems()
				if _eafbb := d.DecodeElement(_cacgg.WebPublishItems, &_ebbdb); _eafbb != nil {
					return _eafbb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_cacgg.ExtLst = NewCT_ExtensionList()
				if _eadabb := d.DecodeElement(_cacgg.ExtLst, &_ebbdb); _eadabb != nil {
					return _eadabb
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020Chartsheet\u0020\u0025v", _ebbdb.Name)
				if _acfda := d.Skip(); _acfda != nil {
					return _acfda
				}
			}
		case _f.EndElement:
			break _gcfged
		case _f.CharData:
		}
	}
	return nil
}

type CT_ServerFormats struct {

	// Format Count
	CountAttr *uint32

	// Server Format
	ServerFormat []*CT_ServerFormat
}

// ValidateWithPath validates the CT_MetadataType and its children, prefixing error messages with path
func (_ggca *CT_MetadataType) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_PageItem and its children, prefixing error messages with path
func (_fbffg *CT_PageItem) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_Field and its children
func (_bdbbe *CT_Field) Validate() error { return _bdbbe.ValidateWithPath("CT_Field") }
func (_aebdc ST_FormulaExpression) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_aebdc.String(), start)
}
func (_ggcac *ST_MdxKPIProperty) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fafbcg, _bdbfcg := d.Token()
	if _bdbfcg != nil {
		return _bdbfcg
	}
	if _bgfcf, _fcgff := _fafbcg.(_f.EndElement); _fcgff && _bgfcf.Name == start.Name {
		*_ggcac = 1
		return nil
	}
	if _bgaff, _bgffd := _fafbcg.(_f.CharData); !_bgffd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fafbcg)
	} else {
		switch string(_bgaff) {
		case "":
			*_ggcac = 0
		case "v":
			*_ggcac = 1
		case "g":
			*_ggcac = 2
		case "s":
			*_ggcac = 3
		case "t":
			*_ggcac = 4
		case "w":
			*_ggcac = 5
		case "m":
			*_ggcac = 6
		}
	}
	_fafbcg, _bdbfcg = d.Token()
	if _bdbfcg != nil {
		return _bdbfcg
	}
	if _bfbac, _aggeg := _fafbcg.(_f.EndElement); _aggeg && _bfbac.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fafbcg)
}

type CT_Sets struct {

	// Tuple Set Count
	CountAttr *uint32

	// OLAP Set
	Set []*CT_Set
}
type ST_Orientation byte
type PivotCacheRecords struct{ CT_PivotCacheRecords }

func (_agaeba *PivotCacheRecords) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:pivotCacheRecords"
	return _agaeba.CT_PivotCacheRecords.MarshalXML(e, start)
}
func NewCT_Schema() *CT_Schema { _cfegb := &CT_Schema{}; return _cfegb }
func (_aebage ST_TotalsRowFunction) String() string {
	switch _aebage {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "sum"
	case 3:
		return "min"
	case 4:
		return "max"
	case 5:
		return "average"
	case 6:
		return "count"
	case 7:
		return "countNums"
	case 8:
		return "stdDev"
	case 9:
		return "var"
	case 10:
		return "custom"
	}
	return ""
}
func (_dccg *CT_CellXfs) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dccg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_dccg.CountAttr)})
	}
	e.EncodeToken(start)
	_bfdb := _f.StartElement{Name: _f.Name{Local: "ma:xf"}}
	for _, _adcd := range _dccg.Xf {
		e.EncodeElement(_adcd, _bfdb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_PageField() *CT_PageField { _fedgb := &CT_PageField{}; return _fedgb }
func (_begacb ST_OleUpdate) String() string {
	switch _begacb {
	case 0:
		return ""
	case 1:
		return "OLEUPDATE_ALWAYS"
	case 2:
		return "OLEUPDATE_ONCALL"
	}
	return ""
}

type CT_MemberProperty struct {

	// OLAP Member Property Unique Name
	NameAttr *string

	// Show Cell
	ShowCellAttr *bool

	// Show Tooltip
	ShowTipAttr *bool

	// Show As Caption
	ShowAsCaptionAttr *bool

	// Name Length
	NameLenAttr *uint32

	// Property Name Character Index
	PPosAttr *uint32

	// Property Name Length
	PLenAttr *uint32

	// Level Index
	LevelAttr *uint32

	// Field Index
	FieldAttr uint32
}

func (_dgfd *CT_BookView) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dcd := range start.Attr {
		if _dcd.Name.Local == "windowWidth" {
			_dbe, _ef := _g.ParseUint(_dcd.Value, 10, 32)
			if _ef != nil {
				return _ef
			}
			_fdg := uint32(_dbe)
			_dgfd.WindowWidthAttr = &_fdg
			continue
		}
		if _dcd.Name.Local == "visibility" {
			_dgfd.VisibilityAttr.UnmarshalXMLAttr(_dcd)
			continue
		}
		if _dcd.Name.Local == "showHorizontalScroll" {
			_abg, _edg := _g.ParseBool(_dcd.Value)
			if _edg != nil {
				return _edg
			}
			_dgfd.ShowHorizontalScrollAttr = &_abg
			continue
		}
		if _dcd.Name.Local == "showVerticalScroll" {
			_cad, _egf := _g.ParseBool(_dcd.Value)
			if _egf != nil {
				return _egf
			}
			_dgfd.ShowVerticalScrollAttr = &_cad
			continue
		}
		if _dcd.Name.Local == "showSheetTabs" {
			_cag, _cgb := _g.ParseBool(_dcd.Value)
			if _cgb != nil {
				return _cgb
			}
			_dgfd.ShowSheetTabsAttr = &_cag
			continue
		}
		if _dcd.Name.Local == "xWindow" {
			_cf, _fcd := _g.ParseInt(_dcd.Value, 10, 32)
			if _fcd != nil {
				return _fcd
			}
			_dgc := int32(_cf)
			_dgfd.XWindowAttr = &_dgc
			continue
		}
		if _dcd.Name.Local == "yWindow" {
			_dae, _dabg := _g.ParseInt(_dcd.Value, 10, 32)
			if _dabg != nil {
				return _dabg
			}
			_fbc := int32(_dae)
			_dgfd.YWindowAttr = &_fbc
			continue
		}
		if _dcd.Name.Local == "minimized" {
			_dgfc, _caeg := _g.ParseBool(_dcd.Value)
			if _caeg != nil {
				return _caeg
			}
			_dgfd.MinimizedAttr = &_dgfc
			continue
		}
		if _dcd.Name.Local == "windowHeight" {
			_gbe, _fbd := _g.ParseUint(_dcd.Value, 10, 32)
			if _fbd != nil {
				return _fbd
			}
			_daf := uint32(_gbe)
			_dgfd.WindowHeightAttr = &_daf
			continue
		}
		if _dcd.Name.Local == "tabRatio" {
			_gad, _gaad := _g.ParseUint(_dcd.Value, 10, 32)
			if _gaad != nil {
				return _gaad
			}
			_agb := uint32(_gad)
			_dgfd.TabRatioAttr = &_agb
			continue
		}
		if _dcd.Name.Local == "firstSheet" {
			_bab, _fgg := _g.ParseUint(_dcd.Value, 10, 32)
			if _fgg != nil {
				return _fgg
			}
			_cgbc := uint32(_bab)
			_dgfd.FirstSheetAttr = &_cgbc
			continue
		}
		if _dcd.Name.Local == "activeTab" {
			_dbd, _bda := _g.ParseUint(_dcd.Value, 10, 32)
			if _bda != nil {
				return _bda
			}
			_eef := uint32(_dbd)
			_dgfd.ActiveTabAttr = &_eef
			continue
		}
		if _dcd.Name.Local == "autoFilterDateGrouping" {
			_fcf, _edgb := _g.ParseBool(_dcd.Value)
			if _edgb != nil {
				return _edgb
			}
			_dgfd.AutoFilterDateGroupingAttr = &_fcf
			continue
		}
	}
_dcc:
	for {
		_aef, _bgd := d.Token()
		if _bgd != nil {
			return _bgd
		}
		switch _gf := _aef.(type) {
		case _f.StartElement:
			switch _gf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_dgfd.ExtLst = NewCT_ExtensionList()
				if _ffe := d.DecodeElement(_dgfd.ExtLst, &_gf); _ffe != nil {
					return _ffe
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BookView\u0020\u0025v", _gf.Name)
				if _gff := d.Skip(); _gff != nil {
					return _gff
				}
			}
		case _f.EndElement:
			break _dcc
		case _f.CharData:
		}
	}
	return nil
}
func (_edcf *CT_ExternalSheetDataSet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_geeeb := _f.StartElement{Name: _f.Name{Local: "ma:sheetData"}}
	for _, _baeefc := range _edcf.SheetData {
		e.EncodeElement(_baeefc, _geeeb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_MetadataBlocks() *CT_MetadataBlocks { _cdbfcd := &CT_MetadataBlocks{}; return _cdbfcd }

type ST_PhoneticType byte

func (_adbece *CT_RevisionAutoFormatting) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetId"}, Value: _bg.Sprintf("\u0025v", _adbece.SheetIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _adbece.RefAttr)})
	if _adbece.AutoFormatIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoFormatId"}, Value: _bg.Sprintf("\u0025v", *_adbece.AutoFormatIdAttr)})
	}
	if _adbece.ApplyNumberFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyNumberFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_adbece.ApplyNumberFormatsAttr))})
	}
	if _adbece.ApplyBorderFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyBorderFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_adbece.ApplyBorderFormatsAttr))})
	}
	if _adbece.ApplyFontFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyFontFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_adbece.ApplyFontFormatsAttr))})
	}
	if _adbece.ApplyPatternFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyPatternFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_adbece.ApplyPatternFormatsAttr))})
	}
	if _adbece.ApplyAlignmentFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyAlignmentFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_adbece.ApplyAlignmentFormatsAttr))})
	}
	if _adbece.ApplyWidthHeightFormatsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "applyWidthHeightFormats"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_adbece.ApplyWidthHeightFormatsAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_eabff *CT_MeasureGroups) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _eabff.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_eabff.CountAttr)})
	}
	e.EncodeToken(start)
	if _eabff.MeasureGroup != nil {
		_ebdff := _f.StartElement{Name: _f.Name{Local: "ma:measureGroup"}}
		for _, _bgffe := range _eabff.MeasureGroup {
			e.EncodeElement(_bgffe, _ebdff)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bbcde ST_Orientation) String() string {
	switch _bbcde {
	case 0:
		return ""
	case 1:
		return "default"
	case 2:
		return "portrait"
	case 3:
		return "landscape"
	}
	return ""
}

// Validate validates the CT_PivotFields and its children
func (_cfbda *CT_PivotFields) Validate() error { return _cfbda.ValidateWithPath("CT_PivotFields") }

const (
	ST_DataValidationImeModeUnset        ST_DataValidationImeMode = 0
	ST_DataValidationImeModeNoControl    ST_DataValidationImeMode = 1
	ST_DataValidationImeModeOff          ST_DataValidationImeMode = 2
	ST_DataValidationImeModeOn           ST_DataValidationImeMode = 3
	ST_DataValidationImeModeDisabled     ST_DataValidationImeMode = 4
	ST_DataValidationImeModeHiragana     ST_DataValidationImeMode = 5
	ST_DataValidationImeModeFullKatakana ST_DataValidationImeMode = 6
	ST_DataValidationImeModeHalfKatakana ST_DataValidationImeMode = 7
	ST_DataValidationImeModeFullAlpha    ST_DataValidationImeMode = 8
	ST_DataValidationImeModeHalfAlpha    ST_DataValidationImeMode = 9
	ST_DataValidationImeModeFullHangul   ST_DataValidationImeMode = 10
	ST_DataValidationImeModeHalfHangul   ST_DataValidationImeMode = 11
)

type CT_AutoSortScope struct {

	// Auto Sort Scope
	PivotArea *CT_PivotArea
}

func (_edccbe ST_GrowShrinkType) String() string {
	switch _edccbe {
	case 0:
		return ""
	case 1:
		return "insertDelete"
	case 2:
		return "insertClear"
	case 3:
		return "overwriteClear"
	}
	return ""
}
func (_cdacae ST_CfType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_faegc := _f.Attr{}
	_faegc.Name = name
	switch _cdacae {
	case ST_CfTypeUnset:
		_faegc.Value = ""
	case ST_CfTypeExpression:
		_faegc.Value = "expression"
	case ST_CfTypeCellIs:
		_faegc.Value = "cellIs"
	case ST_CfTypeColorScale:
		_faegc.Value = "colorScale"
	case ST_CfTypeDataBar:
		_faegc.Value = "dataBar"
	case ST_CfTypeIconSet:
		_faegc.Value = "iconSet"
	case ST_CfTypeTop10:
		_faegc.Value = "top10"
	case ST_CfTypeUniqueValues:
		_faegc.Value = "uniqueValues"
	case ST_CfTypeDuplicateValues:
		_faegc.Value = "duplicateValues"
	case ST_CfTypeContainsText:
		_faegc.Value = "containsText"
	case ST_CfTypeNotContainsText:
		_faegc.Value = "notContainsText"
	case ST_CfTypeBeginsWith:
		_faegc.Value = "beginsWith"
	case ST_CfTypeEndsWith:
		_faegc.Value = "endsWith"
	case ST_CfTypeContainsBlanks:
		_faegc.Value = "containsBlanks"
	case ST_CfTypeNotContainsBlanks:
		_faegc.Value = "notContainsBlanks"
	case ST_CfTypeContainsErrors:
		_faegc.Value = "containsErrors"
	case ST_CfTypeNotContainsErrors:
		_faegc.Value = "notContainsErrors"
	case ST_CfTypeTimePeriod:
		_faegc.Value = "timePeriod"
	case ST_CfTypeAboveAverage:
		_faegc.Value = "aboveAverage"
	}
	return _faegc, nil
}

type ST_SortBy byte

func (_fdcgd *CT_Revisions) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_adfae:
	for {
		_accgba, _ccccec := d.Token()
		if _ccccec != nil {
			return _ccccec
		}
		switch _fbgge := _accgba.(type) {
		case _f.StartElement:
			switch _fbgge.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rrc"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rrc"}:
				_ggbfdb := NewCT_RevisionRowColumn()
				if _eaeed := d.DecodeElement(_ggbfdb, &_fbgge); _eaeed != nil {
					return _eaeed
				}
				_fdcgd.Rrc = append(_fdcgd.Rrc, _ggbfdb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rm"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rm"}:
				_ecbae := NewCT_RevisionMove()
				if _ffcg := d.DecodeElement(_ecbae, &_fbgge); _ffcg != nil {
					return _ffcg
				}
				_fdcgd.Rm = append(_fdcgd.Rm, _ecbae)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rcv"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rcv"}:
				_daadb := NewCT_RevisionCustomView()
				if _gdbba := d.DecodeElement(_daadb, &_fbgge); _gdbba != nil {
					return _gdbba
				}
				_fdcgd.Rcv = append(_fdcgd.Rcv, _daadb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rsnm"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rsnm"}:
				_fbebg := NewCT_RevisionSheetRename()
				if _fabbf := d.DecodeElement(_fbebg, &_fbgge); _fabbf != nil {
					return _fabbf
				}
				_fdcgd.Rsnm = append(_fdcgd.Rsnm, _fbebg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ris"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ris"}:
				_fbaedf := NewCT_RevisionInsertSheet()
				if _begadd := d.DecodeElement(_fbaedf, &_fbgge); _begadd != nil {
					return _begadd
				}
				_fdcgd.Ris = append(_fdcgd.Ris, _fbaedf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rcc"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rcc"}:
				_ceaaf := NewCT_RevisionCellChange()
				if _aebfa := d.DecodeElement(_ceaaf, &_fbgge); _aebfa != nil {
					return _aebfa
				}
				_fdcgd.Rcc = append(_fdcgd.Rcc, _ceaaf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rfmt"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rfmt"}:
				_egacf := NewCT_RevisionFormatting()
				if _bcgae := d.DecodeElement(_egacf, &_fbgge); _bcgae != nil {
					return _bcgae
				}
				_fdcgd.Rfmt = append(_fdcgd.Rfmt, _egacf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "raf"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "raf"}:
				_bcaabe := NewCT_RevisionAutoFormatting()
				if _fbebd := d.DecodeElement(_bcaabe, &_fbgge); _fbebd != nil {
					return _fbebd
				}
				_fdcgd.Raf = append(_fdcgd.Raf, _bcaabe)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rdn"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rdn"}:
				_ceegf := NewCT_RevisionDefinedName()
				if _gabca := d.DecodeElement(_ceegf, &_fbgge); _gabca != nil {
					return _gabca
				}
				_fdcgd.Rdn = append(_fdcgd.Rdn, _ceegf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rcmt"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rcmt"}:
				_ffbdfb := NewCT_RevisionComment()
				if _fgbge := d.DecodeElement(_ffbdfb, &_fbgge); _fgbge != nil {
					return _fgbge
				}
				_fdcgd.Rcmt = append(_fdcgd.Rcmt, _ffbdfb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rqt"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rqt"}:
				_aafcb := NewCT_RevisionQueryTableField()
				if _aadba := d.DecodeElement(_aafcb, &_fbgge); _aadba != nil {
					return _aadba
				}
				_fdcgd.Rqt = append(_fdcgd.Rqt, _aafcb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rcft"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rcft"}:
				_cddd := NewCT_RevisionConflict()
				if _dgbfgb := d.DecodeElement(_cddd, &_fbgge); _dgbfgb != nil {
					return _dgbfgb
				}
				_fdcgd.Rcft = append(_fdcgd.Rcft, _cddd)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Revisions\u0020\u0025v", _fbgge.Name)
				if _fabeae := d.Skip(); _fabeae != nil {
					return _fabeae
				}
			}
		case _f.EndElement:
			break _adfae
		case _f.CharData:
		}
	}
	return nil
}

type CT_CustomProperty struct {

	// Custom Property Name
	NameAttr string
	IdAttr   string
}

// ValidateWithPath validates the CT_HeaderFooter and its children, prefixing error messages with path
func (_bebec *CT_HeaderFooter) ValidateWithPath(path string) error { return nil }

const (
	ST_SheetViewTypeUnset            ST_SheetViewType = 0
	ST_SheetViewTypeNormal           ST_SheetViewType = 1
	ST_SheetViewTypePageBreakPreview ST_SheetViewType = 2
	ST_SheetViewTypePageLayout       ST_SheetViewType = 3
)

// ValidateWithPath validates the CT_Map and its children, prefixing error messages with path
func (_afcfa *CT_Map) ValidateWithPath(path string) error {
	if _afcfa.DataBinding != nil {
		if _fafda := _afcfa.DataBinding.ValidateWithPath(path + "\u002fDataBinding"); _fafda != nil {
			return _fafda
		}
	}
	return nil
}

const (
	ST_DataValidationTypeUnset      ST_DataValidationType = 0
	ST_DataValidationTypeNone       ST_DataValidationType = 1
	ST_DataValidationTypeWhole      ST_DataValidationType = 2
	ST_DataValidationTypeDecimal    ST_DataValidationType = 3
	ST_DataValidationTypeList       ST_DataValidationType = 4
	ST_DataValidationTypeDate       ST_DataValidationType = 5
	ST_DataValidationTypeTime       ST_DataValidationType = 6
	ST_DataValidationTypeTextLength ST_DataValidationType = 7
	ST_DataValidationTypeCustom     ST_DataValidationType = 8
)

// ValidateWithPath validates the CT_GroupMembers and its children, prefixing error messages with path
func (_daabd *CT_GroupMembers) ValidateWithPath(path string) error {
	for _deagg, _fadeg := range _daabd.GroupMember {
		if _fgeec := _fadeg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fGroupMember\u005b\u0025d\u005d", path, _deagg)); _fgeec != nil {
			return _fgeec
		}
	}
	return nil
}
func (_gecdd *CT_DataConsolidate) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gecdd.FunctionAttr != ST_DataConsolidateFunctionUnset {
		_bdfcd, _efbd := _gecdd.FunctionAttr.MarshalXMLAttr(_f.Name{Local: "function"})
		if _efbd != nil {
			return _efbd
		}
		start.Attr = append(start.Attr, _bdfcd)
	}
	if _gecdd.StartLabelsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "startLabels"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gecdd.StartLabelsAttr))})
	}
	if _gecdd.LeftLabelsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "leftLabels"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gecdd.LeftLabelsAttr))})
	}
	if _gecdd.TopLabelsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "topLabels"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gecdd.TopLabelsAttr))})
	}
	if _gecdd.LinkAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "link"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gecdd.LinkAttr))})
	}
	e.EncodeToken(start)
	if _gecdd.DataRefs != nil {
		_feff := _f.StartElement{Name: _f.Name{Local: "ma:dataRefs"}}
		e.EncodeElement(_gecdd.DataRefs, _feff)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_DateTime() *CT_DateTime { _acfece := &CT_DateTime{}; return _acfece }

// Validate validates the CT_Scenarios and its children
func (_cfafag *CT_Scenarios) Validate() error { return _cfafag.ValidateWithPath("CT_Scenarios") }
func NewSst() *Sst                            { _cggeaa := &Sst{}; _cggeaa.CT_Sst = *NewCT_Sst(); return _cggeaa }

type ST_TableType byte

// Validate validates the CT_Mdx and its children
func (_gabebd *CT_Mdx) Validate() error { return _gabebd.ValidateWithPath("CT_Mdx") }

// Validate validates the CT_TableFormula and its children
func (_ebcgg *CT_TableFormula) Validate() error { return _ebcgg.ValidateWithPath("CT_TableFormula") }
func (_gfacee *ST_FontScheme) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_gfacee = 0
	case "none":
		*_gfacee = 1
	case "major":
		*_gfacee = 2
	case "minor":
		*_gfacee = 3
	}
	return nil
}
func (_bdfe *CT_MeasureGroup) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _bdfe.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "caption"}, Value: _bg.Sprintf("\u0025v", _bdfe.CaptionAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_PhoneticRun() *CT_PhoneticRun { _feceag := &CT_PhoneticRun{}; return _feceag }
func (_fbaeb *CT_VolTypes) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_bcgbe := _f.StartElement{Name: _f.Name{Local: "ma:volType"}}
	for _, _acdgg := range _fbaeb.VolType {
		e.EncodeElement(_acdgg, _bcgbe)
	}
	if _fbaeb.ExtLst != nil {
		_dbded := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_fbaeb.ExtLst, _dbded)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_TableStyleElement struct {

	// Table Style Type
	TypeAttr ST_TableStyleType

	// Band Size
	SizeAttr *uint32

	// Formatting Id
	DxfIdAttr *uint32
}

func (_cdegge *ST_PhoneticType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_cdegge = 0
	case "halfwidthKatakana":
		*_cdegge = 1
	case "fullwidthKatakana":
		*_cdegge = 2
	case "Hiragana":
		*_cdegge = 3
	case "noConversion":
		*_cdegge = 4
	}
	return nil
}
func (_abdgb *CT_ExternalLink) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _abdgb.Choice != nil {
		_abdgb.Choice.MarshalXML(e, _f.StartElement{})
	}
	if _abdgb.ExtLst != nil {
		_acbdg := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_abdgb.ExtLst, _acbdg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_acfada ST_CellComments) String() string {
	switch _acfada {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "asDisplayed"
	case 3:
		return "atEnd"
	}
	return ""
}
func NewCT_GroupMember() *CT_GroupMember { _edcag := &CT_GroupMember{}; return _edcag }
func (_eebgdc ST_GradientType) String() string {
	switch _eebgdc {
	case 0:
		return ""
	case 1:
		return "linear"
	case 2:
		return "path"
	}
	return ""
}
func (_fbadb ST_PhoneticAlignment) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_fbadb.String(), start)
}

// Validate validates the CT_FileSharing and its children
func (_aagf *CT_FileSharing) Validate() error { return _aagf.ValidateWithPath("CT_FileSharing") }

const (
	ST_DataValidationOperatorUnset              ST_DataValidationOperator = 0
	ST_DataValidationOperatorBetween            ST_DataValidationOperator = 1
	ST_DataValidationOperatorNotBetween         ST_DataValidationOperator = 2
	ST_DataValidationOperatorEqual              ST_DataValidationOperator = 3
	ST_DataValidationOperatorNotEqual           ST_DataValidationOperator = 4
	ST_DataValidationOperatorLessThan           ST_DataValidationOperator = 5
	ST_DataValidationOperatorLessThanOrEqual    ST_DataValidationOperator = 6
	ST_DataValidationOperatorGreaterThan        ST_DataValidationOperator = 7
	ST_DataValidationOperatorGreaterThanOrEqual ST_DataValidationOperator = 8
)

type CT_CustomSheetView struct {

	// GUID
	GuidAttr string

	// Print Scale
	ScaleAttr *uint32

	// Color Id
	ColorIdAttr *uint32

	// Show Page Breaks
	ShowPageBreaksAttr *bool

	// Show Formulas
	ShowFormulasAttr *bool

	// Show Grid Lines
	ShowGridLinesAttr *bool

	// Show Headers
	ShowRowColAttr *bool

	// Show Outline Symbols
	OutlineSymbolsAttr *bool

	// Show Zero Values
	ZeroValuesAttr *bool

	// Fit To Page
	FitToPageAttr *bool

	// Print Area Defined
	PrintAreaAttr *bool

	// Filtered List
	FilterAttr *bool

	// Show AutoFitler Drop Down Controls
	ShowAutoFilterAttr *bool

	// Hidden Rows
	HiddenRowsAttr *bool

	// Hidden Columns
	HiddenColumnsAttr *bool

	// Visible State
	StateAttr ST_SheetState

	// Filter
	FilterUniqueAttr *bool

	// View Type
	ViewAttr ST_SheetViewType

	// Show Ruler
	ShowRulerAttr *bool

	// Top Left Visible Cell
	TopLeftCellAttr *string

	// Pane Split Information
	Pane *CT_Pane

	// Selection
	Selection *CT_Selection

	// Horizontal Page Breaks
	RowBreaks *CT_PageBreak

	// Vertical Page Breaks
	ColBreaks *CT_PageBreak

	// Page Margins
	PageMargins *CT_PageMargins

	// Print Options
	PrintOptions *CT_PrintOptions

	// Page Setup Settings
	PageSetup *CT_PageSetup

	// Header Footer Settings
	HeaderFooter *CT_HeaderFooter

	// AutoFilter Settings
	AutoFilter *CT_AutoFilter
	ExtLst     *CT_ExtensionList
}
type ST_HorizontalAlignment byte

func NewCT_VolTopic() *CT_VolTopic { _dceec := &CT_VolTopic{}; return _dceec }
func (_bcagg *CT_TextPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bcagg.PromptAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "prompt"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bcagg.PromptAttr))})
	}
	if _bcagg.FileTypeAttr != ST_FileTypeUnset {
		_acedfb, _aacdc := _bcagg.FileTypeAttr.MarshalXMLAttr(_f.Name{Local: "fileType"})
		if _aacdc != nil {
			return _aacdc
		}
		start.Attr = append(start.Attr, _acedfb)
	}
	if _bcagg.CodePageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "codePage"}, Value: _bg.Sprintf("\u0025v", *_bcagg.CodePageAttr)})
	}
	if _bcagg.CharacterSetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "characterSet"}, Value: _bg.Sprintf("\u0025v", *_bcagg.CharacterSetAttr)})
	}
	if _bcagg.FirstRowAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "firstRow"}, Value: _bg.Sprintf("\u0025v", *_bcagg.FirstRowAttr)})
	}
	if _bcagg.SourceFileAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sourceFile"}, Value: _bg.Sprintf("\u0025v", *_bcagg.SourceFileAttr)})
	}
	if _bcagg.DelimitedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "delimited"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bcagg.DelimitedAttr))})
	}
	if _bcagg.DecimalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "decimal"}, Value: _bg.Sprintf("\u0025v", *_bcagg.DecimalAttr)})
	}
	if _bcagg.ThousandsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "thousands"}, Value: _bg.Sprintf("\u0025v", *_bcagg.ThousandsAttr)})
	}
	if _bcagg.TabAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "tab"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bcagg.TabAttr))})
	}
	if _bcagg.SpaceAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "space"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bcagg.SpaceAttr))})
	}
	if _bcagg.CommaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "comma"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bcagg.CommaAttr))})
	}
	if _bcagg.SemicolonAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "semicolon"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bcagg.SemicolonAttr))})
	}
	if _bcagg.ConsecutiveAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "consecutive"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bcagg.ConsecutiveAttr))})
	}
	if _bcagg.QualifierAttr != ST_QualifierUnset {
		_badgab, _aceb := _bcagg.QualifierAttr.MarshalXMLAttr(_f.Name{Local: "qualifier"})
		if _aceb != nil {
			return _aceb
		}
		start.Attr = append(start.Attr, _badgab)
	}
	if _bcagg.DelimiterAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "delimiter"}, Value: _bg.Sprintf("\u0025v", *_bcagg.DelimiterAttr)})
	}
	e.EncodeToken(start)
	if _bcagg.TextFields != nil {
		_cbged := _f.StartElement{Name: _f.Name{Local: "ma:textFields"}}
		e.EncodeElement(_bcagg.TextFields, _cbged)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_SheetView struct {

	// Window Protection
	WindowProtectionAttr *bool

	// Show Formulas
	ShowFormulasAttr *bool

	// Show Grid Lines
	ShowGridLinesAttr *bool

	// Show Headers
	ShowRowColHeadersAttr *bool

	// Show Zero Values
	ShowZerosAttr *bool

	// Right To Left
	RightToLeftAttr *bool

	// Sheet Tab Selected
	TabSelectedAttr *bool

	// Show Ruler
	ShowRulerAttr *bool

	// Show Outline Symbols
	ShowOutlineSymbolsAttr *bool

	// Default Grid Color
	DefaultGridColorAttr *bool

	// Show White Space
	ShowWhiteSpaceAttr *bool

	// View Type
	ViewAttr ST_SheetViewType

	// Top Left Visible Cell
	TopLeftCellAttr *string

	// Color Id
	ColorIdAttr *uint32

	// Zoom Scale
	ZoomScaleAttr *uint32

	// Zoom Scale Normal View
	ZoomScaleNormalAttr *uint32

	// Zoom Scale Page Break Preview
	ZoomScaleSheetLayoutViewAttr *uint32

	// Zoom Scale Page Layout View
	ZoomScalePageLayoutViewAttr *uint32

	// Workbook View Index
	WorkbookViewIdAttr uint32

	// View Pane
	Pane *CT_Pane

	// Selection
	Selection []*CT_Selection

	// PivotTable Selection
	PivotSelection []*CT_PivotSelection

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

// Validate validates the CT_CalcCell and its children
func (_babb *CT_CalcCell) Validate() error { return _babb.ValidateWithPath("CT_CalcCell") }
func (_gefea *ST_ExternalConnectionType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_gefea = 0
	case "general":
		*_gefea = 1
	case "text":
		*_gefea = 2
	case "MDY":
		*_gefea = 3
	case "DMY":
		*_gefea = 4
	case "YMD":
		*_gefea = 5
	case "MYD":
		*_gefea = 6
	case "DYM":
		*_gefea = 7
	case "YDM":
		*_gefea = 8
	case "skip":
		*_gefea = 9
	case "EMD":
		*_gefea = 10
	}
	return nil
}
func NewCT_DdeLink() *CT_DdeLink { _baece := &CT_DdeLink{}; return _baece }

// Validate validates the CT_MeasureGroups and its children
func (_gbfde *CT_MeasureGroups) Validate() error { return _gbfde.ValidateWithPath("CT_MeasureGroups") }

const (
	ST_RevisionActionUnset  ST_RevisionAction = 0
	ST_RevisionActionAdd    ST_RevisionAction = 1
	ST_RevisionActionDelete ST_RevisionAction = 2
)

type CT_HeaderFooter struct {

	// Different Odd Even Header Footer
	DifferentOddEvenAttr *bool

	// Different First Page
	DifferentFirstAttr *bool

	// Scale Header & Footer With Document
	ScaleWithDocAttr *bool

	// Align Margins
	AlignWithMarginsAttr *bool

	// Odd Header
	OddHeader *string

	// Odd Page Footer
	OddFooter *string

	// Even Page Header
	EvenHeader *string

	// Even Page Footer
	EvenFooter *string

	// First Page Header
	FirstHeader *string

	// First Page Footer
	FirstFooter *string
}

// ValidateWithPath validates the CT_SharedItems and its children, prefixing error messages with path
func (_ecgbf *CT_SharedItems) ValidateWithPath(path string) error {
	for _cecbe, _gaafga := range _ecgbf.M {
		if _cfcadf := _gaafga.ValidateWithPath(_bg.Sprintf("\u0025s\u002fM\u005b\u0025d\u005d", path, _cecbe)); _cfcadf != nil {
			return _cfcadf
		}
	}
	for _ebbde, _dafdg := range _ecgbf.N {
		if _egddd := _dafdg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fN\u005b\u0025d\u005d", path, _ebbde)); _egddd != nil {
			return _egddd
		}
	}
	for _gegeb, _afebge := range _ecgbf.B {
		if _eagfc := _afebge.ValidateWithPath(_bg.Sprintf("\u0025s\u002fB\u005b\u0025d\u005d", path, _gegeb)); _eagfc != nil {
			return _eagfc
		}
	}
	for _bfaeb, _gdece := range _ecgbf.E {
		if _bfade := _gdece.ValidateWithPath(_bg.Sprintf("\u0025s\u002fE\u005b\u0025d\u005d", path, _bfaeb)); _bfade != nil {
			return _bfade
		}
	}
	for _ecbccc, _ebfge := range _ecgbf.S {
		if _aafee := _ebfge.ValidateWithPath(_bg.Sprintf("\u0025s\u002fS\u005b\u0025d\u005d", path, _ecbccc)); _aafee != nil {
			return _aafee
		}
	}
	for _fdcef, _edfad := range _ecgbf.D {
		if _gfcbf := _edfad.ValidateWithPath(_bg.Sprintf("\u0025s\u002fD\u005b\u0025d\u005d", path, _fdcef)); _gfcbf != nil {
			return _gfcbf
		}
	}
	return nil
}

type CT_PivotField struct {

	// Field Name
	NameAttr *string

	// Axis
	AxisAttr ST_Axis

	// Data Field
	DataFieldAttr *bool

	// Custom Subtotal Caption
	SubtotalCaptionAttr *string

	// Show PivotField Header Drop Downs
	ShowDropDownsAttr *bool

	// Hidden Level
	HiddenLevelAttr *bool

	// Unique Member Property
	UniqueMemberPropertyAttr *string

	// Compact
	CompactAttr *bool

	// All Items Expanded
	AllDrilledAttr *bool

	// Number Format Id
	NumFmtIdAttr *uint32

	// Outline Items
	OutlineAttr *bool

	// Subtotals At Top
	SubtotalTopAttr *bool

	// Drag To Row
	DragToRowAttr *bool

	// Drag To Column
	DragToColAttr *bool

	// Multiple Field Filters
	MultipleItemSelectionAllowedAttr *bool

	// Drag Field to Page
	DragToPageAttr *bool

	// Field Can Drag to Data
	DragToDataAttr *bool

	// Drag Off
	DragOffAttr *bool

	// Show All Items
	ShowAllAttr *bool

	// Insert Blank Row
	InsertBlankRowAttr *bool

	// Server-based Page Field
	ServerFieldAttr *bool

	// Insert Item Page Break
	InsertPageBreakAttr *bool

	// Auto Show
	AutoShowAttr *bool

	// Top Auto Show
	TopAutoShowAttr *bool

	// Hide New Items
	HideNewItemsAttr *bool

	// Measure Filter
	MeasureFilterAttr *bool

	// Inclusive Manual Filter
	IncludeNewItemsInFilterAttr *bool

	// Items Per Page Count
	ItemPageCountAttr *uint32

	// Auto Sort Type
	SortTypeAttr ST_FieldSortType

	// Data Source Sort
	DataSourceSortAttr *bool

	// Auto Sort
	NonAutoSortDefaultAttr *bool

	// Auto Show Rank By
	RankByAttr *uint32

	// Show Default Subtotal
	DefaultSubtotalAttr *bool

	// Sum Subtotal
	SumSubtotalAttr *bool

	// CountA
	CountASubtotalAttr *bool

	// Average
	AvgSubtotalAttr *bool

	// Max Subtotal
	MaxSubtotalAttr *bool

	// Min Subtotal
	MinSubtotalAttr *bool

	// Product Subtotal
	ProductSubtotalAttr *bool

	// Count
	CountSubtotalAttr *bool

	// StdDev Subtotal
	StdDevSubtotalAttr *bool

	// StdDevP Subtotal
	StdDevPSubtotalAttr *bool

	// Variance Subtotal
	VarSubtotalAttr *bool

	// VarP Subtotal
	VarPSubtotalAttr *bool

	// Show Member Property in Cell
	ShowPropCellAttr *bool

	// Show Member Property ToolTip
	ShowPropTipAttr *bool

	// Show As Caption
	ShowPropAsCaptionAttr *bool

	// Drill State
	DefaultAttributeDrillStateAttr *bool

	// Field Items
	Items *CT_Items

	// AutoSort Scope
	AutoSortScope *CT_AutoSortScope

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_dfadg ST_rwColActionType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_ecedd := _f.Attr{}
	_ecedd.Name = name
	switch _dfadg {
	case ST_rwColActionTypeUnset:
		_ecedd.Value = ""
	case ST_rwColActionTypeInsertRow:
		_ecedd.Value = "insertRow"
	case ST_rwColActionTypeDeleteRow:
		_ecedd.Value = "deleteRow"
	case ST_rwColActionTypeInsertCol:
		_ecedd.Value = "insertCol"
	case ST_rwColActionTypeDeleteCol:
		_ecedd.Value = "deleteCol"
	}
	return _ecedd, nil
}

// Validate validates the CT_SortCondition and its children
func (_dcdfa *CT_SortCondition) Validate() error { return _dcdfa.ValidateWithPath("CT_SortCondition") }
func (_cbcbg *CT_ServerFormat) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _eaabag := range start.Attr {
		if _eaabag.Name.Local == "culture" {
			_fedae, _bbbd := _eaabag.Value, error(nil)
			if _bbbd != nil {
				return _bbbd
			}
			_cbcbg.CultureAttr = &_fedae
			continue
		}
		if _eaabag.Name.Local == "format" {
			_acfbb, _fffce := _eaabag.Value, error(nil)
			if _fffce != nil {
				return _fffce
			}
			_cbcbg.FormatAttr = &_acfbb
			continue
		}
	}
	for {
		_bacfg, _febec := d.Token()
		if _febec != nil {
			return _bg.Errorf("parsing CT_ServerFormat:\u0020\u0025s", _febec)
		}
		if _bfaga, _dbab := _bacfg.(_f.EndElement); _dbab && _bfaga.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TextField and its children, prefixing error messages with path
func (_adfef *CT_TextField) ValidateWithPath(path string) error {
	if _edgfg := _adfef.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _edgfg != nil {
		return _edgfg
	}
	return nil
}
func (_bceeed ST_FilterOperator) String() string {
	switch _bceeed {
	case 0:
		return ""
	case 1:
		return "equal"
	case 2:
		return "lessThan"
	case 3:
		return "lessThanOrEqual"
	case 4:
		return "notEqual"
	case 5:
		return "greaterThanOrEqual"
	case 6:
		return "greaterThan"
	}
	return ""
}
func (_eeeddg ST_DateTimeGrouping) Validate() error { return _eeeddg.ValidateWithPath("") }
func (_abefdg *ST_ParameterType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_abefdg = 0
	case "prompt":
		*_abefdg = 1
	case "value":
		*_abefdg = 2
	case "cell":
		*_abefdg = 3
	}
	return nil
}

type CT_CfRule struct {

	// Type
	TypeAttr ST_CfType

	// Differential Formatting Id
	DxfIdAttr *uint32

	// Priority
	PriorityAttr int32

	// Stop If True
	StopIfTrueAttr *bool

	// Above Or Below Average
	AboveAverageAttr *bool

	// Top 10 Percent
	PercentAttr *bool

	// Bottom N
	BottomAttr *bool

	// Operator
	OperatorAttr ST_ConditionalFormattingOperator

	// Text
	TextAttr *string

	// Time Period
	TimePeriodAttr ST_TimePeriod

	// Rank
	RankAttr *uint32

	// StdDev
	StdDevAttr *int32

	// Equal Average
	EqualAverageAttr *bool

	// Formula
	Formula []string

	// Color Scale
	ColorScale *CT_ColorScale

	// Data Bar
	DataBar *CT_DataBar

	// Icon Set
	IconSet *CT_IconSet
	ExtLst  *CT_ExtensionList
}

// ValidateWithPath validates the CT_WorkbookPr and its children, prefixing error messages with path
func (_bgfbf *CT_WorkbookPr) ValidateWithPath(path string) error {
	if _aafbd := _bgfbf.ShowObjectsAttr.ValidateWithPath(path + "\u002fShowObjectsAttr"); _aafbd != nil {
		return _aafbd
	}
	if _cabbf := _bgfbf.UpdateLinksAttr.ValidateWithPath(path + "\u002fUpdateLinksAttr"); _cabbf != nil {
		return _cabbf
	}
	return nil
}
func (_fbacd *CT_DefinedNames) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _fbacd.DefinedName != nil {
		_acgc := _f.StartElement{Name: _f.Name{Local: "ma:definedName"}}
		for _, _dfad := range _fbacd.DefinedName {
			e.EncodeElement(_dfad, _acgc)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bgad *CT_CellFormula) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bgad.TAttr != ST_CellFormulaTypeUnset {
		_cdfe, _aegcf := _bgad.TAttr.MarshalXMLAttr(_f.Name{Local: "t"})
		if _aegcf != nil {
			return _aegcf
		}
		start.Attr = append(start.Attr, _cdfe)
	}
	if _bgad.AcaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "aca"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgad.AcaAttr))})
	}
	if _bgad.RefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", *_bgad.RefAttr)})
	}
	if _bgad.Dt2DAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dt2D"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgad.Dt2DAttr))})
	}
	if _bgad.DtrAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dtr"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgad.DtrAttr))})
	}
	if _bgad.Del1Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "del1"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgad.Del1Attr))})
	}
	if _bgad.Del2Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "del2"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgad.Del2Attr))})
	}
	if _bgad.R1Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r1"}, Value: _bg.Sprintf("\u0025v", *_bgad.R1Attr)})
	}
	if _bgad.R2Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r2"}, Value: _bg.Sprintf("\u0025v", *_bgad.R2Attr)})
	}
	if _bgad.CaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ca"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgad.CaAttr))})
	}
	if _bgad.SiAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "si"}, Value: _bg.Sprintf("\u0025v", *_bgad.SiAttr)})
	}
	if _bgad.BxAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "bx"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bgad.BxAttr))})
	}
	e.EncodeElement(_bgad.Content, start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ffdgf ST_SortType) ValidateWithPath(path string) error {
	switch _ffdgf {
	case 0, 1, 2, 3, 4, 5, 6, 7:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ffdgf))
	}
	return nil
}
func NewCT_Extension() *CT_Extension { _agca := &CT_Extension{}; return _agca }
func (_aafcc ST_ConditionalFormattingOperator) ValidateWithPath(path string) error {
	switch _aafcc {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aafcc))
	}
	return nil
}

// ValidateWithPath validates the CT_CalcChain and its children, prefixing error messages with path
func (_ffgf *CT_CalcChain) ValidateWithPath(path string) error {
	for _ebgf, _fca := range _ffgf.C {
		if _begg := _fca.ValidateWithPath(_bg.Sprintf("\u0025s\u002fC\u005b\u0025d\u005d", path, _ebgf)); _begg != nil {
			return _begg
		}
	}
	if _ffgf.ExtLst != nil {
		if _ecad := _ffgf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ecad != nil {
			return _ecad
		}
	}
	return nil
}
func (_begdb *CT_Fill) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _begdb.PatternFill != nil {
		_ccffc := _f.StartElement{Name: _f.Name{Local: "ma:patternFill"}}
		e.EncodeElement(_begdb.PatternFill, _ccffc)
	}
	if _begdb.GradientFill != nil {
		_bcbd := _f.StartElement{Name: _f.Name{Local: "ma:gradientFill"}}
		e.EncodeElement(_begdb.GradientFill, _bcbd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_edbdc *ST_ShowDataAs) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_aebbda, _ggcbf := d.Token()
	if _ggcbf != nil {
		return _ggcbf
	}
	if _fdbeef, _debbe := _aebbda.(_f.EndElement); _debbe && _fdbeef.Name == start.Name {
		*_edbdc = 1
		return nil
	}
	if _ggecee, _bbadfff := _aebbda.(_f.CharData); !_bbadfff {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aebbda)
	} else {
		switch string(_ggecee) {
		case "":
			*_edbdc = 0
		case "normal":
			*_edbdc = 1
		case "difference":
			*_edbdc = 2
		case "percent":
			*_edbdc = 3
		case "percentDiff":
			*_edbdc = 4
		case "runTotal":
			*_edbdc = 5
		case "percentOfRow":
			*_edbdc = 6
		case "percentOfCol":
			*_edbdc = 7
		case "percentOfTotal":
			*_edbdc = 8
		case "index":
			*_edbdc = 9
		}
	}
	_aebbda, _ggcbf = d.Token()
	if _ggcbf != nil {
		return _ggcbf
	}
	if _gffagg, _cbddg := _aebbda.(_f.EndElement); _cbddg && _gffagg.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aebbda)
}
func (_bedgab ST_Visibility) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bedddf := _f.Attr{}
	_bedddf.Name = name
	switch _bedgab {
	case ST_VisibilityUnset:
		_bedddf.Value = ""
	case ST_VisibilityVisible:
		_bedddf.Value = "visible"
	case ST_VisibilityHidden:
		_bedddf.Value = "hidden"
	case ST_VisibilityVeryHidden:
		_bedddf.Value = "veryHidden"
	}
	return _bedddf, nil
}
func NewCT_WebPr() *CT_WebPr { _egbda := &CT_WebPr{}; return _egbda }

// ValidateWithPath validates the CT_ObjectAnchor and its children, prefixing error messages with path
func (_cgadg *CT_ObjectAnchor) ValidateWithPath(path string) error {
	if _bgecc := _cgadg.From.ValidateWithPath(path + "\u002fFrom"); _bgecc != nil {
		return _bgecc
	}
	if _ebefg := _cgadg.To.ValidateWithPath(path + "\u002fTo"); _ebefg != nil {
		return _ebefg
	}
	return nil
}
func (_dcfeea ST_PatternType) ValidateWithPath(path string) error {
	switch _dcfeea {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dcfeea))
	}
	return nil
}

// Validate validates the CT_Missing and its children
func (_gegd *CT_Missing) Validate() error { return _gegd.ValidateWithPath("CT_Missing") }
func (_degca ST_Pane) ValidateWithPath(path string) error {
	switch _degca {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_degca))
	}
	return nil
}
func (_agbbg *CT_ServerFormats) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _agbbg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_agbbg.CountAttr)})
	}
	e.EncodeToken(start)
	if _agbbg.ServerFormat != nil {
		_eagdf := _f.StartElement{Name: _f.Name{Local: "ma:serverFormat"}}
		for _, _febdg := range _agbbg.ServerFormat {
			e.EncodeElement(_febdg, _eagdf)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Cfvo and its children
func (_ceaa *CT_Cfvo) Validate() error { return _ceaa.ValidateWithPath("CT_Cfvo") }
func (_ggab *CT_FutureMetadataBlock) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_bgggd:
	for {
		_deace, _dcbdf := d.Token()
		if _dcbdf != nil {
			return _dcbdf
		}
		switch _begea := _deace.(type) {
		case _f.StartElement:
			switch _begea.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ggab.ExtLst = NewCT_ExtensionList()
				if _bfcg := d.DecodeElement(_ggab.ExtLst, &_begea); _bfcg != nil {
					return _bfcg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_FutureMetadataBlock\u0020\u0025v", _begea.Name)
				if _caee := d.Skip(); _caee != nil {
					return _caee
				}
			}
		case _f.EndElement:
			break _bgggd
		case _f.CharData:
		}
	}
	return nil
}
func (_agfc *CT_AutoSortScope) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_fdc := _f.StartElement{Name: _f.Name{Local: "ma:pivotArea"}}
	e.EncodeElement(_agfc.PivotArea, _fdc)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_DdeValue() *CT_DdeValue { _bcfb := &CT_DdeValue{}; return _bcfb }

type CT_FieldUsage struct {

	// Field Index
	XAttr int32
}

// ValidateWithPath validates the StyleSheet and its children, prefixing error messages with path
func (_fggefg *StyleSheet) ValidateWithPath(path string) error {
	if _bfcdc := _fggefg.CT_Stylesheet.ValidateWithPath(path); _bfcdc != nil {
		return _bfcdc
	}
	return nil
}

type CT_SmartTagPr struct {

	// Embed SmartTags
	EmbedAttr *bool

	// Show Smart Tags
	ShowAttr ST_SmartTagShow
}

// ValidateWithPath validates the CT_ExternalSheetName and its children, prefixing error messages with path
func (_gagd *CT_ExternalSheetName) ValidateWithPath(path string) error { return nil }
func (_egcfg ST_DataValidationErrorStyle) String() string {
	switch _egcfg {
	case 0:
		return ""
	case 1:
		return "stop"
	case 2:
		return "warning"
	case 3:
		return "information"
	}
	return ""
}

// ValidateWithPath validates the CT_CsPageSetup and its children, prefixing error messages with path
func (_abcf *CT_CsPageSetup) ValidateWithPath(path string) error {
	if _abcf.PaperHeightAttr != nil {
		if !_e.ST_PositiveUniversalMeasurePatternRe.MatchString(*_abcf.PaperHeightAttr) {
			return _bg.Errorf("\u0025s/m\u002ePaperHeightAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_PositiveUniversalMeasurePatternRe, *_abcf.PaperHeightAttr)
		}
	}
	if _abcf.PaperHeightAttr != nil {
		if !_e.ST_UniversalMeasurePatternRe.MatchString(*_abcf.PaperHeightAttr) {
			return _bg.Errorf("\u0025s/m\u002ePaperHeightAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_UniversalMeasurePatternRe, *_abcf.PaperHeightAttr)
		}
	}
	if _abcf.PaperWidthAttr != nil {
		if !_e.ST_PositiveUniversalMeasurePatternRe.MatchString(*_abcf.PaperWidthAttr) {
			return _bg.Errorf("\u0025s\u002fm.PaperWidthAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027 \u0028have\u0020\u0025v\u0029", path, _e.ST_PositiveUniversalMeasurePatternRe, *_abcf.PaperWidthAttr)
		}
	}
	if _abcf.PaperWidthAttr != nil {
		if !_e.ST_UniversalMeasurePatternRe.MatchString(*_abcf.PaperWidthAttr) {
			return _bg.Errorf("\u0025s\u002fm.PaperWidthAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027 \u0028have\u0020\u0025v\u0029", path, _e.ST_UniversalMeasurePatternRe, *_abcf.PaperWidthAttr)
		}
	}
	if _cdde := _abcf.OrientationAttr.ValidateWithPath(path + "\u002fOrientationAttr"); _cdde != nil {
		return _cdde
	}
	return nil
}
func NewCT_PhoneticPr() *CT_PhoneticPr { _caab := &CT_PhoneticPr{}; return _caab }
func (_gdfba *CT_PivotCacheDefinition) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gdfba.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", *_gdfba.IdAttr)})
	}
	if _gdfba.InvalidAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "invalid"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdfba.InvalidAttr))})
	}
	if _gdfba.SaveDataAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "saveData"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdfba.SaveDataAttr))})
	}
	if _gdfba.RefreshOnLoadAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refreshOnLoad"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdfba.RefreshOnLoadAttr))})
	}
	if _gdfba.OptimizeMemoryAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "optimizeMemory"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdfba.OptimizeMemoryAttr))})
	}
	if _gdfba.EnableRefreshAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "enableRefresh"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdfba.EnableRefreshAttr))})
	}
	if _gdfba.RefreshedByAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refreshedBy"}, Value: _bg.Sprintf("\u0025v", *_gdfba.RefreshedByAttr)})
	}
	if _gdfba.RefreshedDateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refreshedDate"}, Value: _bg.Sprintf("\u0025v", *_gdfba.RefreshedDateAttr)})
	}
	if _gdfba.RefreshedDateIsoAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refreshedDateIso"}, Value: _bg.Sprintf("\u0025v", *_gdfba.RefreshedDateIsoAttr)})
	}
	if _gdfba.BackgroundQueryAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "backgroundQuery"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdfba.BackgroundQueryAttr))})
	}
	if _gdfba.MissingItemsLimitAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "missingItemsLimit"}, Value: _bg.Sprintf("\u0025v", *_gdfba.MissingItemsLimitAttr)})
	}
	if _gdfba.CreatedVersionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "createdVersion"}, Value: _bg.Sprintf("\u0025v", *_gdfba.CreatedVersionAttr)})
	}
	if _gdfba.RefreshedVersionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refreshedVersion"}, Value: _bg.Sprintf("\u0025v", *_gdfba.RefreshedVersionAttr)})
	}
	if _gdfba.MinRefreshableVersionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minRefreshableVersion"}, Value: _bg.Sprintf("\u0025v", *_gdfba.MinRefreshableVersionAttr)})
	}
	if _gdfba.RecordCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "recordCount"}, Value: _bg.Sprintf("\u0025v", *_gdfba.RecordCountAttr)})
	}
	if _gdfba.UpgradeOnRefreshAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "upgradeOnRefresh"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdfba.UpgradeOnRefreshAttr))})
	}
	if _gdfba.TupleCacheAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "tupleCache"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdfba.TupleCacheAttr))})
	}
	if _gdfba.SupportSubqueryAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "supportSubquery"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdfba.SupportSubqueryAttr))})
	}
	if _gdfba.SupportAdvancedDrillAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "supportAdvancedDrill"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gdfba.SupportAdvancedDrillAttr))})
	}
	e.EncodeToken(start)
	_dbedg := _f.StartElement{Name: _f.Name{Local: "ma:cacheSource"}}
	e.EncodeElement(_gdfba.CacheSource, _dbedg)
	_ddbfd := _f.StartElement{Name: _f.Name{Local: "ma:cacheFields"}}
	e.EncodeElement(_gdfba.CacheFields, _ddbfd)
	if _gdfba.CacheHierarchies != nil {
		_eddfgg := _f.StartElement{Name: _f.Name{Local: "ma:cacheHierarchies"}}
		e.EncodeElement(_gdfba.CacheHierarchies, _eddfgg)
	}
	if _gdfba.Kpis != nil {
		_ecfac := _f.StartElement{Name: _f.Name{Local: "ma:kpis"}}
		e.EncodeElement(_gdfba.Kpis, _ecfac)
	}
	if _gdfba.TupleCache != nil {
		_gfdfc := _f.StartElement{Name: _f.Name{Local: "ma:tupleCache"}}
		e.EncodeElement(_gdfba.TupleCache, _gfdfc)
	}
	if _gdfba.CalculatedItems != nil {
		_bcebg := _f.StartElement{Name: _f.Name{Local: "ma:calculatedItems"}}
		e.EncodeElement(_gdfba.CalculatedItems, _bcebg)
	}
	if _gdfba.CalculatedMembers != nil {
		_ecacc := _f.StartElement{Name: _f.Name{Local: "ma:calculatedMembers"}}
		e.EncodeElement(_gdfba.CalculatedMembers, _ecacc)
	}
	if _gdfba.Dimensions != nil {
		_caca := _f.StartElement{Name: _f.Name{Local: "ma:dimensions"}}
		e.EncodeElement(_gdfba.Dimensions, _caca)
	}
	if _gdfba.MeasureGroups != nil {
		_cbaae := _f.StartElement{Name: _f.Name{Local: "ma:measureGroups"}}
		e.EncodeElement(_gdfba.MeasureGroups, _cbaae)
	}
	if _gdfba.Maps != nil {
		_gbadg := _f.StartElement{Name: _f.Name{Local: "ma:maps"}}
		e.EncodeElement(_gdfba.Maps, _gbadg)
	}
	if _gdfba.ExtLst != nil {
		_abfdc := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_gdfba.ExtLst, _abfdc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Stylesheet and its children, prefixing error messages with path
func (_bfefe *CT_Stylesheet) ValidateWithPath(path string) error {
	if _bfefe.NumFmts != nil {
		if _bfecff := _bfefe.NumFmts.ValidateWithPath(path + "\u002fNumFmts"); _bfecff != nil {
			return _bfecff
		}
	}
	if _bfefe.Fonts != nil {
		if _aeage := _bfefe.Fonts.ValidateWithPath(path + "\u002fFonts"); _aeage != nil {
			return _aeage
		}
	}
	if _bfefe.Fills != nil {
		if _ccgaa := _bfefe.Fills.ValidateWithPath(path + "\u002fFills"); _ccgaa != nil {
			return _ccgaa
		}
	}
	if _bfefe.Borders != nil {
		if _ggabgc := _bfefe.Borders.ValidateWithPath(path + "\u002fBorders"); _ggabgc != nil {
			return _ggabgc
		}
	}
	if _bfefe.CellStyleXfs != nil {
		if _abdgbaf := _bfefe.CellStyleXfs.ValidateWithPath(path + "\u002fCellStyleXfs"); _abdgbaf != nil {
			return _abdgbaf
		}
	}
	if _bfefe.CellXfs != nil {
		if _fdefd := _bfefe.CellXfs.ValidateWithPath(path + "\u002fCellXfs"); _fdefd != nil {
			return _fdefd
		}
	}
	if _bfefe.CellStyles != nil {
		if _fcebg := _bfefe.CellStyles.ValidateWithPath(path + "/CellStyles"); _fcebg != nil {
			return _fcebg
		}
	}
	if _bfefe.Dxfs != nil {
		if _gbcded := _bfefe.Dxfs.ValidateWithPath(path + "\u002fDxfs"); _gbcded != nil {
			return _gbcded
		}
	}
	if _bfefe.TableStyles != nil {
		if _ffebea := _bfefe.TableStyles.ValidateWithPath(path + "\u002fTableStyles"); _ffebea != nil {
			return _ffebea
		}
	}
	if _bfefe.Colors != nil {
		if _acfab := _bfefe.Colors.ValidateWithPath(path + "\u002fColors"); _acfab != nil {
			return _acfab
		}
	}
	if _bfefe.ExtLst != nil {
		if _ccgedd := _bfefe.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ccgedd != nil {
			return _ccgedd
		}
	}
	return nil
}
func (_ccgebd *ST_TimePeriod) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_ccgebd = 0
	case "today":
		*_ccgebd = 1
	case "yesterday":
		*_ccgebd = 2
	case "tomorrow":
		*_ccgebd = 3
	case "last7Days":
		*_ccgebd = 4
	case "thisMonth":
		*_ccgebd = 5
	case "lastMonth":
		*_ccgebd = 6
	case "nextMonth":
		*_ccgebd = 7
	case "thisWeek":
		*_ccgebd = 8
	case "lastWeek":
		*_ccgebd = 9
	case "nextWeek":
		*_ccgebd = 10
	}
	return nil
}
func (_fbegcd ST_DataValidationImeMode) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_debgb := _f.Attr{}
	_debgb.Name = name
	switch _fbegcd {
	case ST_DataValidationImeModeUnset:
		_debgb.Value = ""
	case ST_DataValidationImeModeNoControl:
		_debgb.Value = "noControl"
	case ST_DataValidationImeModeOff:
		_debgb.Value = "off"
	case ST_DataValidationImeModeOn:
		_debgb.Value = "on"
	case ST_DataValidationImeModeDisabled:
		_debgb.Value = "disabled"
	case ST_DataValidationImeModeHiragana:
		_debgb.Value = "hiragana"
	case ST_DataValidationImeModeFullKatakana:
		_debgb.Value = "fullKatakana"
	case ST_DataValidationImeModeHalfKatakana:
		_debgb.Value = "halfKatakana"
	case ST_DataValidationImeModeFullAlpha:
		_debgb.Value = "fullAlpha"
	case ST_DataValidationImeModeHalfAlpha:
		_debgb.Value = "halfAlpha"
	case ST_DataValidationImeModeFullHangul:
		_debgb.Value = "fullHangul"
	case ST_DataValidationImeModeHalfHangul:
		_debgb.Value = "halfHangul"
	}
	return _debgb, nil
}
func NewCT_PivotFilters() *CT_PivotFilters { _ffbafe := &CT_PivotFilters{}; return _ffbafe }
func (_aagad *ST_SourceType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_aagad = 0
	case "worksheet":
		*_aagad = 1
	case "external":
		*_aagad = 2
	case "consolidation":
		*_aagad = 3
	case "scenario":
		*_aagad = 4
	}
	return nil
}

// Validate validates the CT_PCDSDTCEntries and its children
func (_fbfgd *CT_PCDSDTCEntries) Validate() error {
	return _fbfgd.ValidateWithPath("CT_PCDSDTCEntries")
}

type CT_Scenario struct {

	// Scenario Name
	NameAttr string

	// Scenario Locked
	LockedAttr *bool

	// Hidden Scenario
	HiddenAttr *bool

	// Changing Cell Count
	CountAttr *uint32

	// User Name
	UserAttr *string

	// Scenario Comment
	CommentAttr *string

	// Input Cells
	InputCells []*CT_InputCells
}

// ValidateWithPath validates the CT_MetadataTypes and its children, prefixing error messages with path
func (_bcgca *CT_MetadataTypes) ValidateWithPath(path string) error {
	for _ddgce, _deecb := range _bcgca.MetadataType {
		if _dadaf := _deecb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fMetadataType\u005b\u0025d\u005d", path, _ddgce)); _dadaf != nil {
			return _dadaf
		}
	}
	return nil
}
func (_bgcdb ST_HorizontalAlignment) Validate() error    { return _bgcdb.ValidateWithPath("") }
func (_ddgcbg ST_DataValidationImeMode) Validate() error { return _ddgcbg.ValidateWithPath("") }
func (_dbaabg ST_UpdateLinks) Validate() error           { return _dbaabg.ValidateWithPath("") }

// ValidateWithPath validates the CT_Dialogsheet and its children, prefixing error messages with path
func (_ccbf *CT_Dialogsheet) ValidateWithPath(path string) error {
	if _ccbf.SheetPr != nil {
		if _ggfb := _ccbf.SheetPr.ValidateWithPath(path + "\u002fSheetPr"); _ggfb != nil {
			return _ggfb
		}
	}
	if _ccbf.SheetViews != nil {
		if _dcbb := _ccbf.SheetViews.ValidateWithPath(path + "/SheetViews"); _dcbb != nil {
			return _dcbb
		}
	}
	if _ccbf.SheetFormatPr != nil {
		if _ffgd := _ccbf.SheetFormatPr.ValidateWithPath(path + "\u002fSheetFormatPr"); _ffgd != nil {
			return _ffgd
		}
	}
	if _ccbf.SheetProtection != nil {
		if _fedcf := _ccbf.SheetProtection.ValidateWithPath(path + "\u002fSheetProtection"); _fedcf != nil {
			return _fedcf
		}
	}
	if _ccbf.CustomSheetViews != nil {
		if _adbce := _ccbf.CustomSheetViews.ValidateWithPath(path + "\u002fCustomSheetViews"); _adbce != nil {
			return _adbce
		}
	}
	if _ccbf.PrintOptions != nil {
		if _eedc := _ccbf.PrintOptions.ValidateWithPath(path + "\u002fPrintOptions"); _eedc != nil {
			return _eedc
		}
	}
	if _ccbf.PageMargins != nil {
		if _eded := _ccbf.PageMargins.ValidateWithPath(path + "\u002fPageMargins"); _eded != nil {
			return _eded
		}
	}
	if _ccbf.PageSetup != nil {
		if _cebca := _ccbf.PageSetup.ValidateWithPath(path + "\u002fPageSetup"); _cebca != nil {
			return _cebca
		}
	}
	if _ccbf.HeaderFooter != nil {
		if _affa := _ccbf.HeaderFooter.ValidateWithPath(path + "\u002fHeaderFooter"); _affa != nil {
			return _affa
		}
	}
	if _ccbf.Drawing != nil {
		if _gefcf := _ccbf.Drawing.ValidateWithPath(path + "\u002fDrawing"); _gefcf != nil {
			return _gefcf
		}
	}
	if _ccbf.LegacyDrawing != nil {
		if _cgggg := _ccbf.LegacyDrawing.ValidateWithPath(path + "\u002fLegacyDrawing"); _cgggg != nil {
			return _cgggg
		}
	}
	if _ccbf.LegacyDrawingHF != nil {
		if _edcbe := _ccbf.LegacyDrawingHF.ValidateWithPath(path + "\u002fLegacyDrawingHF"); _edcbe != nil {
			return _edcbe
		}
	}
	if _ccbf.DrawingHF != nil {
		if _gdcac := _ccbf.DrawingHF.ValidateWithPath(path + "\u002fDrawingHF"); _gdcac != nil {
			return _gdcac
		}
	}
	if _ccbf.OleObjects != nil {
		if _gaaf := _ccbf.OleObjects.ValidateWithPath(path + "/OleObjects"); _gaaf != nil {
			return _gaaf
		}
	}
	if _ccbf.Controls != nil {
		if _adea := _ccbf.Controls.ValidateWithPath(path + "\u002fControls"); _adea != nil {
			return _adea
		}
	}
	if _ccbf.ExtLst != nil {
		if _gfecea := _ccbf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gfecea != nil {
			return _gfecea
		}
	}
	return nil
}
func (_bebd *CT_ColorScale) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_ecbc:
	for {
		_affce, _gdege := d.Token()
		if _gdege != nil {
			return _gdege
		}
		switch _gbbb := _affce.(type) {
		case _f.StartElement:
			switch _gbbb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cfvo"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cfvo"}:
				_dagf := NewCT_Cfvo()
				if _feee := d.DecodeElement(_dagf, &_gbbb); _feee != nil {
					return _feee
				}
				_bebd.Cfvo = append(_bebd.Cfvo, _dagf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "color"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "color"}:
				_cafb := NewCT_Color()
				if _fgadg := d.DecodeElement(_cafb, &_gbbb); _fgadg != nil {
					return _fgadg
				}
				_bebd.Color = append(_bebd.Color, _cafb)
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_ColorScale \u0025v", _gbbb.Name)
				if _edbde := d.Skip(); _edbde != nil {
					return _edbde
				}
			}
		case _f.EndElement:
			break _ecbc
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_DataBar and its children, prefixing error messages with path
func (_cgaag *CT_DataBar) ValidateWithPath(path string) error {
	for _dfeb, _ecee := range _cgaag.Cfvo {
		if _dfbcg := _ecee.ValidateWithPath(_bg.Sprintf("%s\u002fCfvo\u005b\u0025d\u005d", path, _dfeb)); _dfbcg != nil {
			return _dfbcg
		}
	}
	if _cabf := _cgaag.Color.ValidateWithPath(path + "\u002fColor"); _cabf != nil {
		return _cabf
	}
	return nil
}
func (_abcfe ST_WebSourceType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_egecad := _f.Attr{}
	_egecad.Name = name
	switch _abcfe {
	case ST_WebSourceTypeUnset:
		_egecad.Value = ""
	case ST_WebSourceTypeSheet:
		_egecad.Value = "sheet"
	case ST_WebSourceTypePrintArea:
		_egecad.Value = "printArea"
	case ST_WebSourceTypeAutoFilter:
		_egecad.Value = "autoFilter"
	case ST_WebSourceTypeRange:
		_egecad.Value = "range"
	case ST_WebSourceTypeChart:
		_egecad.Value = "chart"
	case ST_WebSourceTypePivotTable:
		_egecad.Value = "pivotTable"
	case ST_WebSourceTypeQuery:
		_egecad.Value = "query"
	case ST_WebSourceTypeLabel:
		_egecad.Value = "label"
	}
	return _egecad, nil
}

type CT_pivotTableDefinition struct {

	// Name
	NameAttr string

	// PivotCache Definition Id
	CacheIdAttr uint32

	// Data On Rows
	DataOnRowsAttr *bool

	// Default Data Field Position
	DataPositionAttr *uint32

	// Data Field Header Name
	DataCaptionAttr string

	// Grand Totals Caption
	GrandTotalCaptionAttr *string

	// Error Caption
	ErrorCaptionAttr *string

	// Show Error
	ShowErrorAttr *bool

	// Caption for Missing Values
	MissingCaptionAttr *string

	// Show Missing
	ShowMissingAttr *bool

	// Page Header Style Name
	PageStyleAttr *string

	// Table Style Name
	PivotTableStyleAttr *string

	// Vacated Style
	VacatedStyleAttr *string

	// PivotTable Custom String
	TagAttr *string

	// PivotTable Last Updated Version
	UpdatedVersionAttr *uint8

	// Minimum Refreshable Version
	MinRefreshableVersionAttr *uint8

	// Asterisk Totals
	AsteriskTotalsAttr *bool

	// Show Item Names
	ShowItemsAttr *bool

	// Allow Edit Data
	EditDataAttr *bool

	// Disable Field List
	DisableFieldListAttr *bool

	// Show Calculated Members
	ShowCalcMbrsAttr *bool

	// Total Visual Data
	VisualTotalsAttr *bool

	// Show Multiple Labels
	ShowMultipleLabelAttr *bool

	// Show Drop Down
	ShowDataDropDownAttr *bool

	// Show Expand Collapse
	ShowDrillAttr *bool

	// Print Drill Indicators
	PrintDrillAttr *bool

	// Show Member Property ToolTips
	ShowMemberPropertyTipsAttr *bool

	// Show ToolTips on Data
	ShowDataTipsAttr *bool

	// Enable PivotTable Wizard
	EnableWizardAttr *bool

	// Enable Drill Down
	EnableDrillAttr *bool

	// Enable Field Properties
	EnableFieldPropertiesAttr *bool

	// Preserve Formatting
	PreserveFormattingAttr *bool

	// Auto Formatting
	UseAutoFormattingAttr *bool

	// Page Wrap
	PageWrapAttr *uint32

	// Page Over Then Down
	PageOverThenDownAttr *bool

	// Subtotal Hidden Items
	SubtotalHiddenItemsAttr *bool

	// Row Grand Totals
	RowGrandTotalsAttr *bool

	// Grand Totals On Columns
	ColGrandTotalsAttr *bool

	// Field Print Titles
	FieldPrintTitlesAttr *bool

	// Item Print Titles
	ItemPrintTitlesAttr *bool

	// Merge Titles
	MergeItemAttr *bool

	// Show Drop Zones
	ShowDropZonesAttr *bool

	// PivotCache Created Version
	CreatedVersionAttr *uint8

	// Indentation for Compact Axis
	IndentAttr *uint32

	// Show Empty Row
	ShowEmptyRowAttr *bool

	// Show Empty Column
	ShowEmptyColAttr *bool

	// Show Field Headers
	ShowHeadersAttr *bool

	// Compact New Fields
	CompactAttr *bool

	// Outline New Fields
	OutlineAttr *bool

	// Outline Data Fields
	OutlineDataAttr *bool

	// Compact Data
	CompactDataAttr *bool

	// Data Fields Published
	PublishedAttr *bool

	// Enable Drop Zones
	GridDropZonesAttr *bool

	// Stop Immersive UI
	ImmersiveAttr *bool

	// Multiple Field Filters
	MultipleFieldFiltersAttr *bool

	// Chart Format Id
	ChartFormatAttr *uint32

	// Row Header Caption
	RowHeaderCaptionAttr *string

	// Column Header Caption
	ColHeaderCaptionAttr *string

	// Default Sort Order
	FieldListSortAscendingAttr *bool

	// MDX Subqueries Supported
	MdxSubqueriesAttr *bool

	// Custom List AutoSort
	CustomListSortAttr *bool

	// PivotTable Location
	Location *CT_Location

	// PivotTable Fields
	PivotFields *CT_PivotFields

	// Row Fields
	RowFields *CT_RowFields

	// Row Items
	RowItems *CT_rowItems

	// Column Fields
	ColFields *CT_ColFields

	// Column Items
	ColItems *CT_colItems

	// Page Field Items
	PageFields *CT_PageFields

	// Data Fields
	DataFields *CT_DataFields

	// PivotTable Formats
	Formats *CT_Formats

	// Conditional Formats
	ConditionalFormats *CT_ConditionalFormats

	// PivotChart Formats
	ChartFormats *CT_ChartFormats

	// PivotTable OLAP Hierarchies
	PivotHierarchies *CT_PivotHierarchies

	// PivotTable Style
	PivotTableStyleInfo *CT_PivotTableStyle

	// Filters
	Filters *CT_PivotFilters

	// Row OLAP Hierarchy References
	RowHierarchiesUsage *CT_RowHierarchiesUsage

	// Column OLAP Hierarchy References
	ColHierarchiesUsage *CT_ColHierarchiesUsage

	// Future Feature Data Storage Area
	ExtLst                      *CT_ExtensionList
	AutoFormatIdAttr            *uint32
	ApplyNumberFormatsAttr      *bool
	ApplyBorderFormatsAttr      *bool
	ApplyFontFormatsAttr        *bool
	ApplyPatternFormatsAttr     *bool
	ApplyAlignmentFormatsAttr   *bool
	ApplyWidthHeightFormatsAttr *bool
}

func (_adfa *CT_CsPageSetup) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dfac := range start.Attr {
		if _dfac.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _dfac.Name.Local == "id" || _dfac.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _dfac.Name.Local == "id" {
			_bbfg, _gafb := _dfac.Value, error(nil)
			if _gafb != nil {
				return _gafb
			}
			_adfa.IdAttr = &_bbfg
			continue
		}
		if _dfac.Name.Local == "paperSize" {
			_cacde, _gdfd := _g.ParseUint(_dfac.Value, 10, 32)
			if _gdfd != nil {
				return _gdfd
			}
			_ccded := uint32(_cacde)
			_adfa.PaperSizeAttr = &_ccded
			continue
		}
		if _dfac.Name.Local == "paperWidth" {
			_acec, _gacac := _dfac.Value, error(nil)
			if _gacac != nil {
				return _gacac
			}
			_adfa.PaperWidthAttr = &_acec
			continue
		}
		if _dfac.Name.Local == "firstPageNumber" {
			_fffb, _gcbae := _g.ParseUint(_dfac.Value, 10, 32)
			if _gcbae != nil {
				return _gcbae
			}
			_gcecc := uint32(_fffb)
			_adfa.FirstPageNumberAttr = &_gcecc
			continue
		}
		if _dfac.Name.Local == "orientation" {
			_adfa.OrientationAttr.UnmarshalXMLAttr(_dfac)
			continue
		}
		if _dfac.Name.Local == "usePrinterDefaults" {
			_ffdcd, _egga := _g.ParseBool(_dfac.Value)
			if _egga != nil {
				return _egga
			}
			_adfa.UsePrinterDefaultsAttr = &_ffdcd
			continue
		}
		if _dfac.Name.Local == "paperHeight" {
			_fdace, _adebg := _dfac.Value, error(nil)
			if _adebg != nil {
				return _adebg
			}
			_adfa.PaperHeightAttr = &_fdace
			continue
		}
		if _dfac.Name.Local == "draft" {
			_dgae, _geaf := _g.ParseBool(_dfac.Value)
			if _geaf != nil {
				return _geaf
			}
			_adfa.DraftAttr = &_dgae
			continue
		}
		if _dfac.Name.Local == "useFirstPageNumber" {
			_dbbc, _gdaa := _g.ParseBool(_dfac.Value)
			if _gdaa != nil {
				return _gdaa
			}
			_adfa.UseFirstPageNumberAttr = &_dbbc
			continue
		}
		if _dfac.Name.Local == "horizontalDpi" {
			_faede, _bgdef := _g.ParseUint(_dfac.Value, 10, 32)
			if _bgdef != nil {
				return _bgdef
			}
			_dfgdg := uint32(_faede)
			_adfa.HorizontalDpiAttr = &_dfgdg
			continue
		}
		if _dfac.Name.Local == "verticalDpi" {
			_eabe, _cafa := _g.ParseUint(_dfac.Value, 10, 32)
			if _cafa != nil {
				return _cafa
			}
			_gecb := uint32(_eabe)
			_adfa.VerticalDpiAttr = &_gecb
			continue
		}
		if _dfac.Name.Local == "copies" {
			_feeg, _bedda := _g.ParseUint(_dfac.Value, 10, 32)
			if _bedda != nil {
				return _bedda
			}
			_egbgd := uint32(_feeg)
			_adfa.CopiesAttr = &_egbgd
			continue
		}
		if _dfac.Name.Local == "blackAndWhite" {
			_ffbe, _dcfd := _g.ParseBool(_dfac.Value)
			if _dcfd != nil {
				return _dcfd
			}
			_adfa.BlackAndWhiteAttr = &_ffbe
			continue
		}
	}
	for {
		_gagae, _eafdf := d.Token()
		if _eafdf != nil {
			return _bg.Errorf("parsing\u0020CT_CsPageSetup:\u0020\u0025s", _eafdf)
		}
		if _ffdf, _efeg := _gagae.(_f.EndElement); _efeg && _ffdf.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_BorderPr() *CT_BorderPr { _efd := &CT_BorderPr{}; return _efd }

type CT_Missing struct {

	// Unused Item
	UAttr *bool

	// Calculated Item
	FAttr *bool

	// Caption
	CAttr *string

	// Member Property Count
	CpAttr *uint32

	// Format Index
	InAttr *uint32

	// background Color
	BcAttr *string

	// Foreground Color
	FcAttr *string

	// Italic
	IAttr *bool

	// Underline
	UnAttr *bool

	// Strikethrough
	StAttr *bool

	// Bold
	BAttr *bool

	// Tuples
	Tpls []*CT_Tuples

	// Member Property Indexes
	X []*CT_X
}

// ValidateWithPath validates the CT_NumFmts and its children, prefixing error messages with path
func (_cbcag *CT_NumFmts) ValidateWithPath(path string) error {
	for _bdfda, _cgcbg := range _cbcag.NumFmt {
		if _egebag := _cgcbg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fNumFmt\u005b\u0025d\u005d", path, _bdfda)); _egebag != nil {
			return _egebag
		}
	}
	return nil
}
func (_gaadgf *CT_Xf) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dafdgg := range start.Attr {
		if _dafdgg.Name.Local == "applyFont" {
			_geadg, _eccbfd := _g.ParseBool(_dafdgg.Value)
			if _eccbfd != nil {
				return _eccbfd
			}
			_gaadgf.ApplyFontAttr = &_geadg
			continue
		}
		if _dafdgg.Name.Local == "numFmtId" {
			_ccagg, _cgcffa := _g.ParseUint(_dafdgg.Value, 10, 32)
			if _cgcffa != nil {
				return _cgcffa
			}
			_aafef := uint32(_ccagg)
			_gaadgf.NumFmtIdAttr = &_aafef
			continue
		}
		if _dafdgg.Name.Local == "applyFill" {
			_ebfgf, _dfddfa := _g.ParseBool(_dafdgg.Value)
			if _dfddfa != nil {
				return _dfddfa
			}
			_gaadgf.ApplyFillAttr = &_ebfgf
			continue
		}
		if _dafdgg.Name.Local == "fillId" {
			_dacfee, _acacc := _g.ParseUint(_dafdgg.Value, 10, 32)
			if _acacc != nil {
				return _acacc
			}
			_fcaeb := uint32(_dacfee)
			_gaadgf.FillIdAttr = &_fcaeb
			continue
		}
		if _dafdgg.Name.Local == "xfId" {
			_dccee, _fecbcb := _g.ParseUint(_dafdgg.Value, 10, 32)
			if _fecbcb != nil {
				return _fecbcb
			}
			_agdaa := uint32(_dccee)
			_gaadgf.XfIdAttr = &_agdaa
			continue
		}
		if _dafdgg.Name.Local == "quotePrefix" {
			_gacfg, _agfec := _g.ParseBool(_dafdgg.Value)
			if _agfec != nil {
				return _agfec
			}
			_gaadgf.QuotePrefixAttr = &_gacfg
			continue
		}
		if _dafdgg.Name.Local == "pivotButton" {
			_aeefdg, _bgdcg := _g.ParseBool(_dafdgg.Value)
			if _bgdcg != nil {
				return _bgdcg
			}
			_gaadgf.PivotButtonAttr = &_aeefdg
			continue
		}
		if _dafdgg.Name.Local == "applyNumberFormat" {
			_eefcb, _egece := _g.ParseBool(_dafdgg.Value)
			if _egece != nil {
				return _egece
			}
			_gaadgf.ApplyNumberFormatAttr = &_eefcb
			continue
		}
		if _dafdgg.Name.Local == "fontId" {
			_cgfdf, _fgeddb := _g.ParseUint(_dafdgg.Value, 10, 32)
			if _fgeddb != nil {
				return _fgeddb
			}
			_ddbaab := uint32(_cgfdf)
			_gaadgf.FontIdAttr = &_ddbaab
			continue
		}
		if _dafdgg.Name.Local == "borderId" {
			_cabfd, _ecddb := _g.ParseUint(_dafdgg.Value, 10, 32)
			if _ecddb != nil {
				return _ecddb
			}
			_bgeefe := uint32(_cabfd)
			_gaadgf.BorderIdAttr = &_bgeefe
			continue
		}
		if _dafdgg.Name.Local == "applyBorder" {
			_cbegb, _efgbb := _g.ParseBool(_dafdgg.Value)
			if _efgbb != nil {
				return _efgbb
			}
			_gaadgf.ApplyBorderAttr = &_cbegb
			continue
		}
		if _dafdgg.Name.Local == "applyAlignment" {
			_bdeda, _begdff := _g.ParseBool(_dafdgg.Value)
			if _begdff != nil {
				return _begdff
			}
			_gaadgf.ApplyAlignmentAttr = &_bdeda
			continue
		}
		if _dafdgg.Name.Local == "applyProtection" {
			_abaee, _bbfdc := _g.ParseBool(_dafdgg.Value)
			if _bbfdc != nil {
				return _bbfdc
			}
			_gaadgf.ApplyProtectionAttr = &_abaee
			continue
		}
	}
_bbbgg:
	for {
		_fbab, _bbcaff := d.Token()
		if _bbcaff != nil {
			return _bbcaff
		}
		switch _gabccd := _fbab.(type) {
		case _f.StartElement:
			switch _gabccd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "alignment"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "alignment"}:
				_gaadgf.Alignment = NewCT_CellAlignment()
				if _gbbea := d.DecodeElement(_gaadgf.Alignment, &_gabccd); _gbbea != nil {
					return _gbbea
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "protection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "protection"}:
				_gaadgf.Protection = NewCT_CellProtection()
				if _gcgef := d.DecodeElement(_gaadgf.Protection, &_gabccd); _gcgef != nil {
					return _gcgef
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gaadgf.ExtLst = NewCT_ExtensionList()
				if _eefcbe := d.DecodeElement(_gaadgf.ExtLst, &_gabccd); _eefcbe != nil {
					return _eefcbe
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on CT_Xf \u0025v", _gabccd.Name)
				if _fcagd := d.Skip(); _fcagd != nil {
					return _fcagd
				}
			}
		case _f.EndElement:
			break _bbbgg
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_DynamicFilter() *CT_DynamicFilter {
	_cgef := &CT_DynamicFilter{}
	_cgef.TypeAttr = ST_DynamicFilterType(1)
	return _cgef
}
func (_cdfbe ST_DateTimeGrouping) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_cdfbe.String(), start)
}
func (_cdecg ST_PatternType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_aecbac := _f.Attr{}
	_aecbac.Name = name
	switch _cdecg {
	case ST_PatternTypeUnset:
		_aecbac.Value = ""
	case ST_PatternTypeNone:
		_aecbac.Value = "none"
	case ST_PatternTypeSolid:
		_aecbac.Value = "solid"
	case ST_PatternTypeMediumGray:
		_aecbac.Value = "mediumGray"
	case ST_PatternTypeDarkGray:
		_aecbac.Value = "darkGray"
	case ST_PatternTypeLightGray:
		_aecbac.Value = "lightGray"
	case ST_PatternTypeDarkHorizontal:
		_aecbac.Value = "darkHorizontal"
	case ST_PatternTypeDarkVertical:
		_aecbac.Value = "darkVertical"
	case ST_PatternTypeDarkDown:
		_aecbac.Value = "darkDown"
	case ST_PatternTypeDarkUp:
		_aecbac.Value = "darkUp"
	case ST_PatternTypeDarkGrid:
		_aecbac.Value = "darkGrid"
	case ST_PatternTypeDarkTrellis:
		_aecbac.Value = "darkTrellis"
	case ST_PatternTypeLightHorizontal:
		_aecbac.Value = "lightHorizontal"
	case ST_PatternTypeLightVertical:
		_aecbac.Value = "lightVertical"
	case ST_PatternTypeLightDown:
		_aecbac.Value = "lightDown"
	case ST_PatternTypeLightUp:
		_aecbac.Value = "lightUp"
	case ST_PatternTypeLightGrid:
		_aecbac.Value = "lightGrid"
	case ST_PatternTypeLightTrellis:
		_aecbac.Value = "lightTrellis"
	case ST_PatternTypeGray125:
		_aecbac.Value = "gray125"
	case ST_PatternTypeGray0625:
		_aecbac.Value = "gray0625"
	}
	return _aecbac, nil
}

type ST_ShowDataAs byte

func (_cgbeb *ST_TotalsRowFunction) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bfgfac, _ebfad := d.Token()
	if _ebfad != nil {
		return _ebfad
	}
	if _fbgdb, _ceegd := _bfgfac.(_f.EndElement); _ceegd && _fbgdb.Name == start.Name {
		*_cgbeb = 1
		return nil
	}
	if _gaeef, _bagagg := _bfgfac.(_f.CharData); !_bagagg {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bfgfac)
	} else {
		switch string(_gaeef) {
		case "":
			*_cgbeb = 0
		case "none":
			*_cgbeb = 1
		case "sum":
			*_cgbeb = 2
		case "min":
			*_cgbeb = 3
		case "max":
			*_cgbeb = 4
		case "average":
			*_cgbeb = 5
		case "count":
			*_cgbeb = 6
		case "countNums":
			*_cgbeb = 7
		case "stdDev":
			*_cgbeb = 8
		case "var":
			*_cgbeb = 9
		case "custom":
			*_cgbeb = 10
		}
	}
	_bfgfac, _ebfad = d.Token()
	if _ebfad != nil {
		return _ebfad
	}
	if _baaee, _cbffg := _bfgfac.(_f.EndElement); _cbffg && _baaee.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bfgfac)
}
func (_dffdf *ST_DynamicFilterType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_dffdf = 0
	case "null":
		*_dffdf = 1
	case "aboveAverage":
		*_dffdf = 2
	case "belowAverage":
		*_dffdf = 3
	case "tomorrow":
		*_dffdf = 4
	case "today":
		*_dffdf = 5
	case "yesterday":
		*_dffdf = 6
	case "nextWeek":
		*_dffdf = 7
	case "thisWeek":
		*_dffdf = 8
	case "lastWeek":
		*_dffdf = 9
	case "nextMonth":
		*_dffdf = 10
	case "thisMonth":
		*_dffdf = 11
	case "lastMonth":
		*_dffdf = 12
	case "nextQuarter":
		*_dffdf = 13
	case "thisQuarter":
		*_dffdf = 14
	case "lastQuarter":
		*_dffdf = 15
	case "nextYear":
		*_dffdf = 16
	case "thisYear":
		*_dffdf = 17
	case "lastYear":
		*_dffdf = 18
	case "yearToDate":
		*_dffdf = 19
	case "Q1":
		*_dffdf = 20
	case "Q2":
		*_dffdf = 21
	case "Q3":
		*_dffdf = 22
	case "Q4":
		*_dffdf = 23
	case "M1":
		*_dffdf = 24
	case "M2":
		*_dffdf = 25
	case "M3":
		*_dffdf = 26
	case "M4":
		*_dffdf = 27
	case "M5":
		*_dffdf = 28
	case "M6":
		*_dffdf = 29
	case "M7":
		*_dffdf = 30
	case "M8":
		*_dffdf = 31
	case "M9":
		*_dffdf = 32
	case "M10":
		*_dffdf = 33
	case "M11":
		*_dffdf = 34
	case "M12":
		*_dffdf = 35
	}
	return nil
}

// ValidateWithPath validates the CalcChain and its children, prefixing error messages with path
func (_bfgdad *CalcChain) ValidateWithPath(path string) error {
	if _cgaabb := _bfgdad.CT_CalcChain.ValidateWithPath(path); _cgaabb != nil {
		return _cgaabb
	}
	return nil
}
func (_cbbdda ST_TextHAlign) Validate() error { return _cbbdda.ValidateWithPath("") }
func (_gdead *CT_SheetProtection) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bedfb := range start.Attr {
		if _bedfb.Name.Local == "formatRows" {
			_aeffgf, _cddca := _g.ParseBool(_bedfb.Value)
			if _cddca != nil {
				return _cddca
			}
			_gdead.FormatRowsAttr = &_aeffgf
			continue
		}
		if _bedfb.Name.Local == "insertColumns" {
			_bcedb, _dcabdba := _g.ParseBool(_bedfb.Value)
			if _dcabdba != nil {
				return _dcabdba
			}
			_gdead.InsertColumnsAttr = &_bcedb
			continue
		}
		if _bedfb.Name.Local == "algorithmName" {
			_bcbffe, _bgfdf := _bedfb.Value, error(nil)
			if _bgfdf != nil {
				return _bgfdf
			}
			_gdead.AlgorithmNameAttr = &_bcbffe
			continue
		}
		if _bedfb.Name.Local == "insertRows" {
			_eefeg, _decbdc := _g.ParseBool(_bedfb.Value)
			if _decbdc != nil {
				return _decbdc
			}
			_gdead.InsertRowsAttr = &_eefeg
			continue
		}
		if _bedfb.Name.Local == "saltValue" {
			_bagdgd, _efbeg := _bedfb.Value, error(nil)
			if _efbeg != nil {
				return _efbeg
			}
			_gdead.SaltValueAttr = &_bagdgd
			continue
		}
		if _bedfb.Name.Local == "insertHyperlinks" {
			_becacf, _abged := _g.ParseBool(_bedfb.Value)
			if _abged != nil {
				return _abged
			}
			_gdead.InsertHyperlinksAttr = &_becacf
			continue
		}
		if _bedfb.Name.Local == "sheet" {
			_baecfg, _fcedgf := _g.ParseBool(_bedfb.Value)
			if _fcedgf != nil {
				return _fcedgf
			}
			_gdead.SheetAttr = &_baecfg
			continue
		}
		if _bedfb.Name.Local == "deleteColumns" {
			_ccdaga, _gbcab := _g.ParseBool(_bedfb.Value)
			if _gbcab != nil {
				return _gbcab
			}
			_gdead.DeleteColumnsAttr = &_ccdaga
			continue
		}
		if _bedfb.Name.Local == "scenarios" {
			_dgaeg, _cbbeb := _g.ParseBool(_bedfb.Value)
			if _cbbeb != nil {
				return _cbbeb
			}
			_gdead.ScenariosAttr = &_dgaeg
			continue
		}
		if _bedfb.Name.Local == "formatColumns" {
			_dgddgdb, _cgadbf := _g.ParseBool(_bedfb.Value)
			if _cgadbf != nil {
				return _cgadbf
			}
			_gdead.FormatColumnsAttr = &_dgddgdb
			continue
		}
		if _bedfb.Name.Local == "password" {
			_bfedb, _dcccd := _bedfb.Value, error(nil)
			if _dcccd != nil {
				return _dcccd
			}
			_gdead.PasswordAttr = &_bfedb
			continue
		}
		if _bedfb.Name.Local == "hashValue" {
			_dddaa, _adebde := _bedfb.Value, error(nil)
			if _adebde != nil {
				return _adebde
			}
			_gdead.HashValueAttr = &_dddaa
			continue
		}
		if _bedfb.Name.Local == "spinCount" {
			_gdcbf, _dbbfb := _g.ParseUint(_bedfb.Value, 10, 32)
			if _dbbfb != nil {
				return _dbbfb
			}
			_cgcaff := uint32(_gdcbf)
			_gdead.SpinCountAttr = &_cgcaff
			continue
		}
		if _bedfb.Name.Local == "objects" {
			_dbfagf, _daeaab := _g.ParseBool(_bedfb.Value)
			if _daeaab != nil {
				return _daeaab
			}
			_gdead.ObjectsAttr = &_dbfagf
			continue
		}
		if _bedfb.Name.Local == "formatCells" {
			_gbdeb, _ceecef := _g.ParseBool(_bedfb.Value)
			if _ceecef != nil {
				return _ceecef
			}
			_gdead.FormatCellsAttr = &_gbdeb
			continue
		}
		if _bedfb.Name.Local == "deleteRows" {
			_fdgfg, _dfaegg := _g.ParseBool(_bedfb.Value)
			if _dfaegg != nil {
				return _dfaegg
			}
			_gdead.DeleteRowsAttr = &_fdgfg
			continue
		}
		if _bedfb.Name.Local == "selectLockedCells" {
			_gfbcf, _ccbba := _g.ParseBool(_bedfb.Value)
			if _ccbba != nil {
				return _ccbba
			}
			_gdead.SelectLockedCellsAttr = &_gfbcf
			continue
		}
		if _bedfb.Name.Local == "sort" {
			_facfg, _abbeb := _g.ParseBool(_bedfb.Value)
			if _abbeb != nil {
				return _abbeb
			}
			_gdead.SortAttr = &_facfg
			continue
		}
		if _bedfb.Name.Local == "autoFilter" {
			_dbecc, _aagaef := _g.ParseBool(_bedfb.Value)
			if _aagaef != nil {
				return _aagaef
			}
			_gdead.AutoFilterAttr = &_dbecc
			continue
		}
		if _bedfb.Name.Local == "pivotTables" {
			_eeacd, _gadag := _g.ParseBool(_bedfb.Value)
			if _gadag != nil {
				return _gadag
			}
			_gdead.PivotTablesAttr = &_eeacd
			continue
		}
		if _bedfb.Name.Local == "selectUnlockedCells" {
			_bgafb, _dbcaa := _g.ParseBool(_bedfb.Value)
			if _dbcaa != nil {
				return _dbcaa
			}
			_gdead.SelectUnlockedCellsAttr = &_bgafb
			continue
		}
	}
	for {
		_cegagc, _cbeffa := d.Token()
		if _cbeffa != nil {
			return _bg.Errorf("parsing\u0020CT_SheetProtection:\u0020\u0025s", _cbeffa)
		}
		if _eebcgf, _fcfe := _cegagc.(_f.EndElement); _fcfe && _eebcgf.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_RevisionQueryTableField and its children
func (_dffbae *CT_RevisionQueryTableField) Validate() error {
	return _dffbae.ValidateWithPath("CT_RevisionQueryTableField")
}
func (_geefd *CT_SortState) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _geefd.ColumnSortAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "columnSort"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_geefd.ColumnSortAttr))})
	}
	if _geefd.CaseSensitiveAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "caseSensitive"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_geefd.CaseSensitiveAttr))})
	}
	if _geefd.SortMethodAttr != ST_SortMethodUnset {
		_gfgcb, _adcgd := _geefd.SortMethodAttr.MarshalXMLAttr(_f.Name{Local: "sortMethod"})
		if _adcgd != nil {
			return _adcgd
		}
		start.Attr = append(start.Attr, _gfgcb)
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", _geefd.RefAttr)})
	e.EncodeToken(start)
	if _geefd.SortCondition != nil {
		_gffdb := _f.StartElement{Name: _f.Name{Local: "ma:sortCondition"}}
		for _, _dabed := range _geefd.SortCondition {
			e.EncodeElement(_dabed, _gffdb)
		}
	}
	if _geefd.ExtLst != nil {
		_eedcgb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_geefd.ExtLst, _eedcgb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ddaegb ST_Orientation) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_cffegd := _f.Attr{}
	_cffegd.Name = name
	switch _ddaegb {
	case ST_OrientationUnset:
		_cffegd.Value = ""
	case ST_OrientationDefault:
		_cffegd.Value = "default"
	case ST_OrientationPortrait:
		_cffegd.Value = "portrait"
	case ST_OrientationLandscape:
		_cffegd.Value = "landscape"
	}
	return _cffegd, nil
}
func NewCT_PivotHierarchy() *CT_PivotHierarchy { _dcfcd := &CT_PivotHierarchy{}; return _dcfcd }
func (_dgbd *CT_CellSmartTags) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cbff := range start.Attr {
		if _cbff.Name.Local == "r" {
			_cegc, _dbbf := _cbff.Value, error(nil)
			if _dbbf != nil {
				return _dbbf
			}
			_dgbd.RAttr = _cegc
			continue
		}
	}
_ccdg:
	for {
		_dffbc, _egce := d.Token()
		if _egce != nil {
			return _egce
		}
		switch _fabd := _dffbc.(type) {
		case _f.StartElement:
			switch _fabd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellSmartTag"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellSmartTag"}:
				_ccgg := NewCT_CellSmartTag()
				if _bgda := d.DecodeElement(_ccgg, &_fabd); _bgda != nil {
					return _bgda
				}
				_dgbd.CellSmartTag = append(_dgbd.CellSmartTag, _ccgg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CellSmartTags\u0020\u0025v", _fabd.Name)
				if _beag := d.Skip(); _beag != nil {
					return _beag
				}
			}
		case _f.EndElement:
			break _ccdg
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_OleItems() *CT_OleItems { _facge := &CT_OleItems{}; return _facge }
func (_afcef ST_HtmlFmt) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_afcef.String(), start)
}
func (_adceb ST_PhoneticType) ValidateWithPath(path string) error {
	switch _adceb {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_adceb))
	}
	return nil
}
func NewCT_UndoInfo() *CT_UndoInfo {
	_egcggc := &CT_UndoInfo{}
	_egcggc.ExpAttr = ST_FormulaExpression(1)
	return _egcggc
}
func (_gbbbd ST_MdxSetOrder) Validate() error { return _gbbbd.ValidateWithPath("") }

const (
	ST_DynamicFilterTypeUnset        ST_DynamicFilterType = 0
	ST_DynamicFilterTypeNull         ST_DynamicFilterType = 1
	ST_DynamicFilterTypeAboveAverage ST_DynamicFilterType = 2
	ST_DynamicFilterTypeBelowAverage ST_DynamicFilterType = 3
	ST_DynamicFilterTypeTomorrow     ST_DynamicFilterType = 4
	ST_DynamicFilterTypeToday        ST_DynamicFilterType = 5
	ST_DynamicFilterTypeYesterday    ST_DynamicFilterType = 6
	ST_DynamicFilterTypeNextWeek     ST_DynamicFilterType = 7
	ST_DynamicFilterTypeThisWeek     ST_DynamicFilterType = 8
	ST_DynamicFilterTypeLastWeek     ST_DynamicFilterType = 9
	ST_DynamicFilterTypeNextMonth    ST_DynamicFilterType = 10
	ST_DynamicFilterTypeThisMonth    ST_DynamicFilterType = 11
	ST_DynamicFilterTypeLastMonth    ST_DynamicFilterType = 12
	ST_DynamicFilterTypeNextQuarter  ST_DynamicFilterType = 13
	ST_DynamicFilterTypeThisQuarter  ST_DynamicFilterType = 14
	ST_DynamicFilterTypeLastQuarter  ST_DynamicFilterType = 15
	ST_DynamicFilterTypeNextYear     ST_DynamicFilterType = 16
	ST_DynamicFilterTypeThisYear     ST_DynamicFilterType = 17
	ST_DynamicFilterTypeLastYear     ST_DynamicFilterType = 18
	ST_DynamicFilterTypeYearToDate   ST_DynamicFilterType = 19
	ST_DynamicFilterTypeQ1           ST_DynamicFilterType = 20
	ST_DynamicFilterTypeQ2           ST_DynamicFilterType = 21
	ST_DynamicFilterTypeQ3           ST_DynamicFilterType = 22
	ST_DynamicFilterTypeQ4           ST_DynamicFilterType = 23
	ST_DynamicFilterTypeM1           ST_DynamicFilterType = 24
	ST_DynamicFilterTypeM2           ST_DynamicFilterType = 25
	ST_DynamicFilterTypeM3           ST_DynamicFilterType = 26
	ST_DynamicFilterTypeM4           ST_DynamicFilterType = 27
	ST_DynamicFilterTypeM5           ST_DynamicFilterType = 28
	ST_DynamicFilterTypeM6           ST_DynamicFilterType = 29
	ST_DynamicFilterTypeM7           ST_DynamicFilterType = 30
	ST_DynamicFilterTypeM8           ST_DynamicFilterType = 31
	ST_DynamicFilterTypeM9           ST_DynamicFilterType = 32
	ST_DynamicFilterTypeM10          ST_DynamicFilterType = 33
	ST_DynamicFilterTypeM11          ST_DynamicFilterType = 34
	ST_DynamicFilterTypeM12          ST_DynamicFilterType = 35
)
const (
	ST_FileTypeUnset ST_FileType = 0
	ST_FileTypeMac   ST_FileType = 1
	ST_FileTypeWin   ST_FileType = 2
	ST_FileTypeDos   ST_FileType = 3
	ST_FileTypeLin   ST_FileType = 4
	ST_FileTypeOther ST_FileType = 5
)

func (_bedfedf ST_Comments) ValidateWithPath(path string) error {
	switch _bedfedf {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bedfedf))
	}
	return nil
}

// Validate validates the CT_MeasureDimensionMap and its children
func (_abcfd *CT_MeasureDimensionMap) Validate() error {
	return _abcfd.ValidateWithPath("CT_MeasureDimensionMap")
}
func (_ggabcc *ST_Orientation) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fbdee, _ebeefc := d.Token()
	if _ebeefc != nil {
		return _ebeefc
	}
	if _dfacc, _ccdaf := _fbdee.(_f.EndElement); _ccdaf && _dfacc.Name == start.Name {
		*_ggabcc = 1
		return nil
	}
	if _ggcfa, _bfdeg := _fbdee.(_f.CharData); !_bfdeg {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fbdee)
	} else {
		switch string(_ggcfa) {
		case "":
			*_ggabcc = 0
		case "default":
			*_ggabcc = 1
		case "portrait":
			*_ggabcc = 2
		case "landscape":
			*_ggabcc = 3
		}
	}
	_fbdee, _ebeefc = d.Token()
	if _ebeefc != nil {
		return _ebeefc
	}
	if _efed, _aeaeb := _fbdee.(_f.EndElement); _aeaeb && _efed.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fbdee)
}
func (_fcbbe *CT_TextPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cacegcb := range start.Attr {
		if _cacegcb.Name.Local == "thousands" {
			_feaegc, _ddccb := _cacegcb.Value, error(nil)
			if _ddccb != nil {
				return _ddccb
			}
			_fcbbe.ThousandsAttr = &_feaegc
			continue
		}
		if _cacegcb.Name.Local == "tab" {
			_cdefc, _bacab := _g.ParseBool(_cacegcb.Value)
			if _bacab != nil {
				return _bacab
			}
			_fcbbe.TabAttr = &_cdefc
			continue
		}
		if _cacegcb.Name.Local == "fileType" {
			_fcbbe.FileTypeAttr.UnmarshalXMLAttr(_cacegcb)
			continue
		}
		if _cacegcb.Name.Local == "space" {
			_ecbba, _dgcff := _g.ParseBool(_cacegcb.Value)
			if _dgcff != nil {
				return _dgcff
			}
			_fcbbe.SpaceAttr = &_ecbba
			continue
		}
		if _cacegcb.Name.Local == "characterSet" {
			_ebdga, _deabb := _cacegcb.Value, error(nil)
			if _deabb != nil {
				return _deabb
			}
			_fcbbe.CharacterSetAttr = &_ebdga
			continue
		}
		if _cacegcb.Name.Local == "sourceFile" {
			_bbbaef, _fagbdb := _cacegcb.Value, error(nil)
			if _fagbdb != nil {
				return _fagbdb
			}
			_fcbbe.SourceFileAttr = &_bbbaef
			continue
		}
		if _cacegcb.Name.Local == "delimited" {
			_adfcee, _abaed := _g.ParseBool(_cacegcb.Value)
			if _abaed != nil {
				return _abaed
			}
			_fcbbe.DelimitedAttr = &_adfcee
			continue
		}
		if _cacegcb.Name.Local == "decimal" {
			_ggecec, _dbfdce := _cacegcb.Value, error(nil)
			if _dbfdce != nil {
				return _dbfdce
			}
			_fcbbe.DecimalAttr = &_ggecec
			continue
		}
		if _cacegcb.Name.Local == "prompt" {
			_edggfd, _cbbcd := _g.ParseBool(_cacegcb.Value)
			if _cbbcd != nil {
				return _cbbcd
			}
			_fcbbe.PromptAttr = &_edggfd
			continue
		}
		if _cacegcb.Name.Local == "codePage" {
			_gagec, _gfbaa := _g.ParseUint(_cacegcb.Value, 10, 32)
			if _gfbaa != nil {
				return _gfbaa
			}
			_cdfbc := uint32(_gagec)
			_fcbbe.CodePageAttr = &_cdfbc
			continue
		}
		if _cacegcb.Name.Local == "firstRow" {
			_ddgcb, _gdabf := _g.ParseUint(_cacegcb.Value, 10, 32)
			if _gdabf != nil {
				return _gdabf
			}
			_bgfad := uint32(_ddgcb)
			_fcbbe.FirstRowAttr = &_bgfad
			continue
		}
		if _cacegcb.Name.Local == "comma" {
			_cgfdg, _bcbgb := _g.ParseBool(_cacegcb.Value)
			if _bcbgb != nil {
				return _bcbgb
			}
			_fcbbe.CommaAttr = &_cgfdg
			continue
		}
		if _cacegcb.Name.Local == "semicolon" {
			_deddbgg, _cedabd := _g.ParseBool(_cacegcb.Value)
			if _cedabd != nil {
				return _cedabd
			}
			_fcbbe.SemicolonAttr = &_deddbgg
			continue
		}
		if _cacegcb.Name.Local == "consecutive" {
			_fdcba, _aebdbg := _g.ParseBool(_cacegcb.Value)
			if _aebdbg != nil {
				return _aebdbg
			}
			_fcbbe.ConsecutiveAttr = &_fdcba
			continue
		}
		if _cacegcb.Name.Local == "qualifier" {
			_fcbbe.QualifierAttr.UnmarshalXMLAttr(_cacegcb)
			continue
		}
		if _cacegcb.Name.Local == "delimiter" {
			_dbfge, _dbdbded := _cacegcb.Value, error(nil)
			if _dbdbded != nil {
				return _dbdbded
			}
			_fcbbe.DelimiterAttr = &_dbfge
			continue
		}
	}
_bcbaf:
	for {
		_aeefb, _bfbgg := d.Token()
		if _bfbgg != nil {
			return _bfbgg
		}
		switch _agcdg := _aeefb.(type) {
		case _f.StartElement:
			switch _agcdg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "textFields"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "textFields"}:
				_fcbbe.TextFields = NewCT_TextFields()
				if _bgegg := d.DecodeElement(_fcbbe.TextFields, &_agcdg); _bgegg != nil {
					return _bgegg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_TextPr \u0025v", _agcdg.Name)
				if _bceef := d.Skip(); _bceef != nil {
					return _bceef
				}
			}
		case _f.EndElement:
			break _bcbaf
		case _f.CharData:
		}
	}
	return nil
}

const (
	ST_TextVAlignUnset       ST_TextVAlign = 0
	ST_TextVAlignTop         ST_TextVAlign = 1
	ST_TextVAlignCenter      ST_TextVAlign = 2
	ST_TextVAlignBottom      ST_TextVAlign = 3
	ST_TextVAlignJustify     ST_TextVAlign = 4
	ST_TextVAlignDistributed ST_TextVAlign = 5
)

func (_dgaga *CT_TableStyleElement) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dgaga.TypeAttr = ST_TableStyleType(1)
	for _, _eagcgb := range start.Attr {
		if _eagcgb.Name.Local == "type" {
			_dgaga.TypeAttr.UnmarshalXMLAttr(_eagcgb)
			continue
		}
		if _eagcgb.Name.Local == "size" {
			_faeccc, _edfgcb := _g.ParseUint(_eagcgb.Value, 10, 32)
			if _edfgcb != nil {
				return _edfgcb
			}
			_cbafd := uint32(_faeccc)
			_dgaga.SizeAttr = &_cbafd
			continue
		}
		if _eagcgb.Name.Local == "dxfId" {
			_aabee, _bdecd := _g.ParseUint(_eagcgb.Value, 10, 32)
			if _bdecd != nil {
				return _bdecd
			}
			_gecea := uint32(_aabee)
			_dgaga.DxfIdAttr = &_gecea
			continue
		}
	}
	for {
		_fadff, _bbdba := d.Token()
		if _bbdba != nil {
			return _bg.Errorf("parsing\u0020CT_TableStyleElement:\u0020\u0025s", _bbdba)
		}
		if _abgbca, _gbfgbg := _fadff.(_f.EndElement); _gbfgbg && _abgbca.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PhoneticRun and its children, prefixing error messages with path
func (_fcbfg *CT_PhoneticRun) ValidateWithPath(path string) error { return nil }
func NewAG_RevData() *AG_RevData                                  { _dgf := &AG_RevData{}; return _dgf }
func (_gdgeb ST_TotalsRowFunction) Validate() error               { return _gdgeb.ValidateWithPath("") }
func (_gebbg ST_RefMode) Validate() error                         { return _gebbg.ValidateWithPath("") }

// Validate validates the CT_XmlColumnPr and its children
func (_ffbcdc *CT_XmlColumnPr) Validate() error { return _ffbcdc.ValidateWithPath("CT_XmlColumnPr") }

type CT_VolTopic struct {

	// Type
	TAttr ST_VolValueType

	// Topic Value
	V string

	// Strings in Subtopic
	Stp []string

	// References
	Tr []*CT_VolTopicRef
}

func (_adbcaf *CT_TupleCache) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _adbcaf.Entries != nil {
		_dfeab := _f.StartElement{Name: _f.Name{Local: "ma:entries"}}
		e.EncodeElement(_adbcaf.Entries, _dfeab)
	}
	if _adbcaf.Sets != nil {
		_eacgef := _f.StartElement{Name: _f.Name{Local: "ma:sets"}}
		e.EncodeElement(_adbcaf.Sets, _eacgef)
	}
	if _adbcaf.QueryCache != nil {
		_cgccbd := _f.StartElement{Name: _f.Name{Local: "ma:queryCache"}}
		e.EncodeElement(_adbcaf.QueryCache, _cgccbd)
	}
	if _adbcaf.ServerFormats != nil {
		_bbdae := _f.StartElement{Name: _f.Name{Local: "ma:serverFormats"}}
		e.EncodeElement(_adbcaf.ServerFormats, _bbdae)
	}
	if _adbcaf.ExtLst != nil {
		_bcedge := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_adbcaf.ExtLst, _bcedge)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ffcagd ST_FormatAction) ValidateWithPath(path string) error {
	switch _ffcagd {
	case 0, 1, 2, 3, 4:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ffcagd))
	}
	return nil
}
func NewPivotCacheRecords() *PivotCacheRecords {
	_bdgba := &PivotCacheRecords{}
	_bdgba.CT_PivotCacheRecords = *NewCT_PivotCacheRecords()
	return _bdgba
}
func NewCT_WorksheetSource() *CT_WorksheetSource { _gacgd := &CT_WorksheetSource{}; return _gacgd }
func NewCT_CellSmartTags() *CT_CellSmartTags     { _gcba := &CT_CellSmartTags{}; return _gcba }

const (
	ST_UnderlineValuesUnset            ST_UnderlineValues = 0
	ST_UnderlineValuesSingle           ST_UnderlineValues = 1
	ST_UnderlineValuesDouble           ST_UnderlineValues = 2
	ST_UnderlineValuesSingleAccounting ST_UnderlineValues = 3
	ST_UnderlineValuesDoubleAccounting ST_UnderlineValues = 4
	ST_UnderlineValuesNone             ST_UnderlineValues = 5
)

func (_abade *CT_Drawing) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _debf := range start.Attr {
		if _debf.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _debf.Name.Local == "id" || _debf.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _debf.Name.Local == "id" {
			_gcgdd, _caffb := _debf.Value, error(nil)
			if _caffb != nil {
				return _caffb
			}
			_abade.IdAttr = _gcgdd
			continue
		}
	}
	for {
		_cfdgcc, _gbbd := d.Token()
		if _gbbd != nil {
			return _bg.Errorf("parsing\u0020CT_Drawing:\u0020%s", _gbbd)
		}
		if _cdbfd, _cgcgb := _cfdgcc.(_f.EndElement); _cgcgb && _cdbfd.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_I and its children, prefixing error messages with path
func (_ggdgg *CT_I) ValidateWithPath(path string) error {
	if _bbbce := _ggdgg.TAttr.ValidateWithPath(path + "\u002fTAttr"); _bbbce != nil {
		return _bbbce
	}
	for _aecag, _eddfb := range _ggdgg.X {
		if _gbbgf := _eddfb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fX\u005b\u0025d\u005d", path, _aecag)); _gbbgf != nil {
			return _gbbgf
		}
	}
	return nil
}

// Validate validates the CT_IgnoredError and its children
func (_gcbffb *CT_IgnoredError) Validate() error { return _gcbffb.ValidateWithPath("CT_IgnoredError") }
func (_ggdbdg ST_CellFormulaType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bagcc := _f.Attr{}
	_bagcc.Name = name
	switch _ggdbdg {
	case ST_CellFormulaTypeUnset:
		_bagcc.Value = ""
	case ST_CellFormulaTypeNormal:
		_bagcc.Value = "normal"
	case ST_CellFormulaTypeArray:
		_bagcc.Value = "array"
	case ST_CellFormulaTypeDataTable:
		_bagcc.Value = "dataTable"
	case ST_CellFormulaTypeShared:
		_bagcc.Value = "shared"
	}
	return _bagcc, nil
}

// ValidateWithPath validates the CT_SmartTagType and its children, prefixing error messages with path
func (_ggfged *CT_SmartTagType) ValidateWithPath(path string) error { return nil }
func (_abadd *CT_Field) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _eebb := range start.Attr {
		if _eebb.Name.Local == "x" {
			_cdbad, _cbedfc := _g.ParseInt(_eebb.Value, 10, 32)
			if _cbedfc != nil {
				return _cbedfc
			}
			_abadd.XAttr = int32(_cdbad)
			continue
		}
	}
	for {
		_ddaef, _cfec := d.Token()
		if _cfec != nil {
			return _bg.Errorf("parsing\u0020CT_Field: \u0025s", _cfec)
		}
		if _eababc, _gbfb := _ddaef.(_f.EndElement); _gbfb && _eababc.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_PivotAreaReferences and its children
func (_febg *CT_PivotAreaReferences) Validate() error {
	return _febg.ValidateWithPath("CT_PivotAreaReferences")
}
func (_bdbeg *Headers) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bdbeg.CT_RevisionHeaders = *NewCT_RevisionHeaders()
	for _, _gefec := range start.Attr {
		if _gefec.Name.Local == "exclusive" {
			_gfadd, _cgfgag := _g.ParseBool(_gefec.Value)
			if _cgfgag != nil {
				return _cgfgag
			}
			_bdbeg.ExclusiveAttr = &_gfadd
			continue
		}
		if _gefec.Name.Local == "lastGuid" {
			_cfefg, _agaaa := _gefec.Value, error(nil)
			if _agaaa != nil {
				return _agaaa
			}
			_bdbeg.LastGuidAttr = &_cfefg
			continue
		}
		if _gefec.Name.Local == "shared" {
			_fedbf, _dddgcg := _g.ParseBool(_gefec.Value)
			if _dddgcg != nil {
				return _dddgcg
			}
			_bdbeg.SharedAttr = &_fedbf
			continue
		}
		if _gefec.Name.Local == "diskRevisions" {
			_gfaab, _cfbfe := _g.ParseBool(_gefec.Value)
			if _cfbfe != nil {
				return _cfbfe
			}
			_bdbeg.DiskRevisionsAttr = &_gfaab
			continue
		}
		if _gefec.Name.Local == "history" {
			_bgdaed, _cbgab := _g.ParseBool(_gefec.Value)
			if _cbgab != nil {
				return _cbgab
			}
			_bdbeg.HistoryAttr = &_bgdaed
			continue
		}
		if _gefec.Name.Local == "trackRevisions" {
			_ddcdg, _cfdfc := _g.ParseBool(_gefec.Value)
			if _cfdfc != nil {
				return _cfdfc
			}
			_bdbeg.TrackRevisionsAttr = &_ddcdg
			continue
		}
		if _gefec.Name.Local == "guid" {
			_gebdf, _ffedg := _gefec.Value, error(nil)
			if _ffedg != nil {
				return _ffedg
			}
			_bdbeg.GuidAttr = _gebdf
			continue
		}
		if _gefec.Name.Local == "revisionId" {
			_cgacfd, _bfedc := _g.ParseUint(_gefec.Value, 10, 32)
			if _bfedc != nil {
				return _bfedc
			}
			_bdcgd := uint32(_cgacfd)
			_bdbeg.RevisionIdAttr = &_bdcgd
			continue
		}
		if _gefec.Name.Local == "version" {
			_eecec, _cacee := _g.ParseInt(_gefec.Value, 10, 32)
			if _cacee != nil {
				return _cacee
			}
			_aeecc := int32(_eecec)
			_bdbeg.VersionAttr = &_aeecc
			continue
		}
		if _gefec.Name.Local == "keepChangeHistory" {
			_gdffd, _adggf := _g.ParseBool(_gefec.Value)
			if _adggf != nil {
				return _adggf
			}
			_bdbeg.KeepChangeHistoryAttr = &_gdffd
			continue
		}
		if _gefec.Name.Local == "protected" {
			_cgecdg, _dbdfd := _g.ParseBool(_gefec.Value)
			if _dbdfd != nil {
				return _dbdfd
			}
			_bdbeg.ProtectedAttr = &_cgecdg
			continue
		}
		if _gefec.Name.Local == "preserveHistory" {
			_abedda, _cbfbb := _g.ParseUint(_gefec.Value, 10, 32)
			if _cbfbb != nil {
				return _cbfbb
			}
			_dcggb := uint32(_abedda)
			_bdbeg.PreserveHistoryAttr = &_dcggb
			continue
		}
	}
_cgade:
	for {
		_ceccf, _ebgcff := d.Token()
		if _ebgcff != nil {
			return _ebgcff
		}
		switch _eeebd := _ceccf.(type) {
		case _f.StartElement:
			switch _eeebd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "header"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "header"}:
				_ebega := NewCT_RevisionHeader()
				if _bfdcb := d.DecodeElement(_ebega, &_eeebd); _bfdcb != nil {
					return _bfdcb
				}
				_bdbeg.Header = append(_bdbeg.Header, _ebega)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Headers\u0020\u0025v", _eeebd.Name)
				if _cfbdb := d.Skip(); _cfbdb != nil {
					return _cfbdb
				}
			}
		case _f.EndElement:
			break _cgade
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_MetadataBlock() *CT_MetadataBlock { _aabga := &CT_MetadataBlock{}; return _aabga }

// ValidateWithPath validates the CT_CustomFilter and its children, prefixing error messages with path
func (_cbgbb *CT_CustomFilter) ValidateWithPath(path string) error {
	if _gfcbe := _cbgbb.OperatorAttr.ValidateWithPath(path + "\u002fOperatorAttr"); _gfcbe != nil {
		return _gfcbe
	}
	return nil
}
func (_gbbcf *ST_SheetState) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_gbbcf = 0
	case "visible":
		*_gbbcf = 1
	case "hidden":
		*_gbbcf = 2
	case "veryHidden":
		*_gbbcf = 3
	}
	return nil
}

// ValidateWithPath validates the CT_FieldUsage and its children, prefixing error messages with path
func (_edeff *CT_FieldUsage) ValidateWithPath(path string) error { return nil }
func (_gccac *CT_SheetData) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_agcde:
	for {
		_affdgb, _gegdf := d.Token()
		if _gegdf != nil {
			return _gegdf
		}
		switch _bcgfc := _affdgb.(type) {
		case _f.StartElement:
			switch _bcgfc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "row"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "row"}:
				_edaag := NewCT_Row()
				if _fcfbb := d.DecodeElement(_edaag, &_bcgfc); _fcfbb != nil {
					return _fcfbb
				}
				_gccac.Row = append(_gccac.Row, _edaag)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SheetData\u0020\u0025v", _bcgfc.Name)
				if _bgbbca := d.Skip(); _bgbbca != nil {
					return _bgbbca
				}
			}
		case _f.EndElement:
			break _agcde
		case _f.CharData:
		}
	}
	return nil
}
func (_efcca ST_MdxKPIProperty) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_efefe := _f.Attr{}
	_efefe.Name = name
	switch _efcca {
	case ST_MdxKPIPropertyUnset:
		_efefe.Value = ""
	case ST_MdxKPIPropertyV:
		_efefe.Value = "v"
	case ST_MdxKPIPropertyG:
		_efefe.Value = "g"
	case ST_MdxKPIPropertyS:
		_efefe.Value = "s"
	case ST_MdxKPIPropertyT:
		_efefe.Value = "t"
	case ST_MdxKPIPropertyW:
		_efefe.Value = "w"
	case ST_MdxKPIPropertyM:
		_efefe.Value = "m"
	}
	return _efefe, nil
}
func NewCT_SheetPr() *CT_SheetPr { _cbbfc := &CT_SheetPr{}; return _cbbfc }
func (_dcabde *CT_FunctionGroups) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gdcfg := range start.Attr {
		if _gdcfg.Name.Local == "builtInGroupCount" {
			_gabfe, _effae := _g.ParseUint(_gdcfg.Value, 10, 32)
			if _effae != nil {
				return _effae
			}
			_daebf := uint32(_gabfe)
			_dcabde.BuiltInGroupCountAttr = &_daebf
			continue
		}
	}
_agbd:
	for {
		_addfb, _fgge := d.Token()
		if _fgge != nil {
			return _fgge
		}
		switch _beabf := _addfb.(type) {
		case _f.StartElement:
			switch _beabf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "functionGroup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "functionGroup"}:
				_cbedge := NewCT_FunctionGroup()
				if _ecgd := d.DecodeElement(_cbedge, &_beabf); _ecgd != nil {
					return _ecgd
				}
				_dcabde.FunctionGroup = append(_dcabde.FunctionGroup, _cbedge)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_FunctionGroups\u0020\u0025v", _beabf.Name)
				if _gdgca := d.Skip(); _gdgca != nil {
					return _gdgca
				}
			}
		case _f.EndElement:
			break _agbd
		case _f.CharData:
		}
	}
	return nil
}

type CT_TableFormula struct {
	ArrayAttr bool
	Content   string
}

func (_cbabcd *Revisions) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:revisions"
	return _cbabcd.CT_Revisions.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_PivotAreaReference and its children, prefixing error messages with path
func (_fbbfg *CT_PivotAreaReference) ValidateWithPath(path string) error {
	for _egade, _aafae := range _fbbfg.X {
		if _accgf := _aafae.ValidateWithPath(_bg.Sprintf("\u0025s\u002fX\u005b\u0025d\u005d", path, _egade)); _accgf != nil {
			return _accgf
		}
	}
	if _fbbfg.ExtLst != nil {
		if _afgdc := _fbbfg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _afgdc != nil {
			return _afgdc
		}
	}
	return nil
}
func (_dbdgeg ST_ShowDataAs) String() string {
	switch _dbdgeg {
	case 0:
		return ""
	case 1:
		return "normal"
	case 2:
		return "difference"
	case 3:
		return "percent"
	case 4:
		return "percentDiff"
	case 5:
		return "runTotal"
	case 6:
		return "percentOfRow"
	case 7:
		return "percentOfCol"
	case 8:
		return "percentOfTotal"
	case 9:
		return "index"
	}
	return ""
}

// Validate validates the CT_MetadataRecord and its children
func (_egddb *CT_MetadataRecord) Validate() error {
	return _egddb.ValidateWithPath("CT_MetadataRecord")
}

// Validate validates the CT_ColorScale and its children
func (_fgcd *CT_ColorScale) Validate() error { return _fgcd.ValidateWithPath("CT_ColorScale") }
func (_fafce *CT_VolType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	_fcgga, _gfead := _fafce.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
	if _gfead != nil {
		return _gfead
	}
	start.Attr = append(start.Attr, _fcgga)
	e.EncodeToken(start)
	_eaedfc := _f.StartElement{Name: _f.Name{Local: "ma:main"}}
	for _, _aebae := range _fafce.Main {
		e.EncodeElement(_aebae, _eaedfc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gdgga *ST_TableStyleType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_gdgga = 0
	case "wholeTable":
		*_gdgga = 1
	case "headerRow":
		*_gdgga = 2
	case "totalRow":
		*_gdgga = 3
	case "firstColumn":
		*_gdgga = 4
	case "lastColumn":
		*_gdgga = 5
	case "firstRowStripe":
		*_gdgga = 6
	case "secondRowStripe":
		*_gdgga = 7
	case "firstColumnStripe":
		*_gdgga = 8
	case "secondColumnStripe":
		*_gdgga = 9
	case "firstHeaderCell":
		*_gdgga = 10
	case "lastHeaderCell":
		*_gdgga = 11
	case "firstTotalCell":
		*_gdgga = 12
	case "lastTotalCell":
		*_gdgga = 13
	case "firstSubtotalColumn":
		*_gdgga = 14
	case "secondSubtotalColumn":
		*_gdgga = 15
	case "thirdSubtotalColumn":
		*_gdgga = 16
	case "firstSubtotalRow":
		*_gdgga = 17
	case "secondSubtotalRow":
		*_gdgga = 18
	case "thirdSubtotalRow":
		*_gdgga = 19
	case "blankRow":
		*_gdgga = 20
	case "firstColumnSubheading":
		*_gdgga = 21
	case "secondColumnSubheading":
		*_gdgga = 22
	case "thirdColumnSubheading":
		*_gdgga = 23
	case "firstRowSubheading":
		*_gdgga = 24
	case "secondRowSubheading":
		*_gdgga = 25
	case "thirdRowSubheading":
		*_gdgga = 26
	case "pageFieldLabels":
		*_gdgga = 27
	case "pageFieldValues":
		*_gdgga = 28
	}
	return nil
}
func (_adgab *CT_WorkbookProtection) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _adgab.WorkbookPasswordAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "workbookPassword"}, Value: _bg.Sprintf("\u0025v", *_adgab.WorkbookPasswordAttr)})
	}
	if _adgab.WorkbookPasswordCharacterSetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "workbookPasswordCharacterSet"}, Value: _bg.Sprintf("\u0025v", *_adgab.WorkbookPasswordCharacterSetAttr)})
	}
	if _adgab.RevisionsPasswordAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "revisionsPassword"}, Value: _bg.Sprintf("\u0025v", *_adgab.RevisionsPasswordAttr)})
	}
	if _adgab.RevisionsPasswordCharacterSetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "revisionsPasswordCharacterSet"}, Value: _bg.Sprintf("\u0025v", *_adgab.RevisionsPasswordCharacterSetAttr)})
	}
	if _adgab.LockStructureAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lockStructure"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_adgab.LockStructureAttr))})
	}
	if _adgab.LockWindowsAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lockWindows"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_adgab.LockWindowsAttr))})
	}
	if _adgab.LockRevisionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lockRevision"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_adgab.LockRevisionAttr))})
	}
	if _adgab.RevisionsAlgorithmNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "revisionsAlgorithmName"}, Value: _bg.Sprintf("\u0025v", *_adgab.RevisionsAlgorithmNameAttr)})
	}
	if _adgab.RevisionsHashValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "revisionsHashValue"}, Value: _bg.Sprintf("\u0025v", *_adgab.RevisionsHashValueAttr)})
	}
	if _adgab.RevisionsSaltValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "revisionsSaltValue"}, Value: _bg.Sprintf("\u0025v", *_adgab.RevisionsSaltValueAttr)})
	}
	if _adgab.RevisionsSpinCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "revisionsSpinCount"}, Value: _bg.Sprintf("\u0025v", *_adgab.RevisionsSpinCountAttr)})
	}
	if _adgab.WorkbookAlgorithmNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "workbookAlgorithmName"}, Value: _bg.Sprintf("\u0025v", *_adgab.WorkbookAlgorithmNameAttr)})
	}
	if _adgab.WorkbookHashValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "workbookHashValue"}, Value: _bg.Sprintf("\u0025v", *_adgab.WorkbookHashValueAttr)})
	}
	if _adgab.WorkbookSaltValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "workbookSaltValue"}, Value: _bg.Sprintf("\u0025v", *_adgab.WorkbookSaltValueAttr)})
	}
	if _adgab.WorkbookSpinCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "workbookSpinCount"}, Value: _bg.Sprintf("\u0025v", *_adgab.WorkbookSpinCountAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_ExternalLink() *CT_ExternalLink { _afbfd := &CT_ExternalLink{}; return _afbfd }

type CT_ColorScale struct {

	// Conditional Format Value Object
	Cfvo []*CT_Cfvo

	// Color Gradiant Interpolation
	Color []*CT_Color
}

// ValidateWithPath validates the CT_Fills and its children, prefixing error messages with path
func (_fdfad *CT_Fills) ValidateWithPath(path string) error {
	for _bbfefb, _eegf := range _fdfad.Fill {
		if _baaf := _eegf.ValidateWithPath(_bg.Sprintf("%s\u002fFill\u005b\u0025d\u005d", path, _bbfefb)); _baaf != nil {
			return _baaf
		}
	}
	return nil
}
func (_bbbgc ST_IconSetType) ValidateWithPath(path string) error {
	switch _bbbgc {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bbbgc))
	}
	return nil
}
func (_cfade ST_FileType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_cfade.String(), start)
}

type ST_SheetViewType byte
type CT_Revisions struct {

	// Revision Row Column Insert Delete
	Rrc []*CT_RevisionRowColumn

	// Revision Cell Move
	Rm []*CT_RevisionMove

	// Revision Custom View
	Rcv []*CT_RevisionCustomView

	// Revision Sheet Name
	Rsnm []*CT_RevisionSheetRename

	// Revision Insert Sheet
	Ris []*CT_RevisionInsertSheet

	// Revision Cell Change
	Rcc []*CT_RevisionCellChange

	// Revision Format
	Rfmt []*CT_RevisionFormatting

	// Revision AutoFormat
	Raf []*CT_RevisionAutoFormatting

	// Revision Defined Name
	Rdn []*CT_RevisionDefinedName

	// Revision Cell Comment
	Rcmt []*CT_RevisionComment

	// Revision Query Table
	Rqt []*CT_RevisionQueryTableField

	// Revision Merge Conflict
	Rcft []*CT_RevisionConflict
}
type CT_LegacyDrawing struct{ IdAttr string }
type CT_Dialogsheet struct {

	// Sheet Properties
	SheetPr *CT_SheetPr

	// Dialog Sheet Views
	SheetViews *CT_SheetViews

	// Dialog Sheet Format Properties
	SheetFormatPr *CT_SheetFormatPr

	// Sheet Protection
	SheetProtection *CT_SheetProtection

	// Custom Sheet Views
	CustomSheetViews *CT_CustomSheetViews

	// Print Options
	PrintOptions *CT_PrintOptions

	// Page Margins
	PageMargins *CT_PageMargins

	// Page Setup Settings
	PageSetup *CT_PageSetup

	// Header & Footer Settings
	HeaderFooter *CT_HeaderFooter

	// Drawing
	Drawing *CT_Drawing

	// Legacy Drawing
	LegacyDrawing *CT_LegacyDrawing

	// Legacy Drawing Header Footer
	LegacyDrawingHF *CT_LegacyDrawing
	DrawingHF       *CT_DrawingHF
	OleObjects      *CT_OleObjects
	Controls        *CT_Controls

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_fcda *CT_WebPublishObject) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abgaae := range start.Attr {
		if _abgaae.Name.Local == "id" {
			_bdgeb, _bggba := _g.ParseUint(_abgaae.Value, 10, 32)
			if _bggba != nil {
				return _bggba
			}
			_fcda.IdAttr = uint32(_bdgeb)
			continue
		}
		if _abgaae.Name.Local == "divId" {
			_efege, _eeege := _abgaae.Value, error(nil)
			if _eeege != nil {
				return _eeege
			}
			_fcda.DivIdAttr = _efege
			continue
		}
		if _abgaae.Name.Local == "sourceObject" {
			_bfgbad, _fdfce := _abgaae.Value, error(nil)
			if _fdfce != nil {
				return _fdfce
			}
			_fcda.SourceObjectAttr = &_bfgbad
			continue
		}
		if _abgaae.Name.Local == "destinationFile" {
			_dabfgb, _ddffg := _abgaae.Value, error(nil)
			if _ddffg != nil {
				return _ddffg
			}
			_fcda.DestinationFileAttr = _dabfgb
			continue
		}
		if _abgaae.Name.Local == "title" {
			_adcea, _ceaff := _abgaae.Value, error(nil)
			if _ceaff != nil {
				return _ceaff
			}
			_fcda.TitleAttr = &_adcea
			continue
		}
		if _abgaae.Name.Local == "autoRepublish" {
			_dabgfa, _bbddgg := _g.ParseBool(_abgaae.Value)
			if _bbddgg != nil {
				return _bbddgg
			}
			_fcda.AutoRepublishAttr = &_dabgfa
			continue
		}
	}
	for {
		_dbefd, _fbcba := d.Token()
		if _fbcba != nil {
			return _bg.Errorf("parsing\u0020CT_WebPublishObject:\u0020\u0025s", _fbcba)
		}
		if _cfaga, _eebbce := _dbefd.(_f.EndElement); _eebbce && _cfaga.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_OrientationUnset     ST_Orientation = 0
	ST_OrientationDefault   ST_Orientation = 1
	ST_OrientationPortrait  ST_Orientation = 2
	ST_OrientationLandscape ST_Orientation = 3
)

func (_gefaa *CT_ExternalCell) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _eafgg := range start.Attr {
		if _eafgg.Name.Local == "r" {
			_gabbda, _bfbed := _eafgg.Value, error(nil)
			if _bfbed != nil {
				return _bfbed
			}
			_gefaa.RAttr = &_gabbda
			continue
		}
		if _eafgg.Name.Local == "t" {
			_gefaa.TAttr.UnmarshalXMLAttr(_eafgg)
			continue
		}
		if _eafgg.Name.Local == "vm" {
			_adaef, _dace := _g.ParseUint(_eafgg.Value, 10, 32)
			if _dace != nil {
				return _dace
			}
			_cgdgf := uint32(_adaef)
			_gefaa.VmAttr = &_cgdgf
			continue
		}
	}
_fcca:
	for {
		_gcgad, _fefgg := d.Token()
		if _fefgg != nil {
			return _fefgg
		}
		switch _egdee := _gcgad.(type) {
		case _f.StartElement:
			switch _egdee.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "v"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "v"}:
				_gefaa.V = new(string)
				if _fcdcb := d.DecodeElement(_gefaa.V, &_egdee); _fcdcb != nil {
					return _fcdcb
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ExternalCell\u0020\u0025v", _egdee.Name)
				if _gebfg := d.Skip(); _gebfg != nil {
					return _gebfg
				}
			}
		case _f.EndElement:
			break _fcca
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_ExternalSheetNames() *CT_ExternalSheetNames {
	_ecada := &CT_ExternalSheetNames{}
	return _ecada
}
func (_de *CT_AutoFilter) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gag := range start.Attr {
		if _gag.Name.Local == "ref" {
			_cbd, _dec := _gag.Value, error(nil)
			if _dec != nil {
				return _dec
			}
			_de.RefAttr = &_cbd
			continue
		}
	}
_bdbc:
	for {
		_fef, _aad := d.Token()
		if _aad != nil {
			return _aad
		}
		switch _cba := _fef.(type) {
		case _f.StartElement:
			switch _cba.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "filterColumn"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "filterColumn"}:
				_ff := NewCT_FilterColumn()
				if _cgf := d.DecodeElement(_ff, &_cba); _cgf != nil {
					return _cgf
				}
				_de.FilterColumn = append(_de.FilterColumn, _ff)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sortState"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sortState"}:
				_de.SortState = NewCT_SortState()
				if _fged := d.DecodeElement(_de.SortState, &_cba); _fged != nil {
					return _fged
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_de.ExtLst = NewCT_ExtensionList()
				if _fea := d.DecodeElement(_de.ExtLst, &_cba); _fea != nil {
					return _fea
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_AutoFilter \u0025v", _cba.Name)
				if _cbfa := d.Skip(); _cbfa != nil {
					return _cbfa
				}
			}
		case _f.EndElement:
			break _bdbc
		case _f.CharData:
		}
	}
	return nil
}
func (_caebgc ST_CellFormulaType) Validate() error { return _caebgc.ValidateWithPath("") }
func (_gcebe *ST_OleUpdate) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_gcebe = 0
	case "OLEUPDATE_ALWAYS":
		*_gcebe = 1
	case "OLEUPDATE_ONCALL":
		*_gcebe = 2
	}
	return nil
}
func NewCT_Fills() *CT_Fills { _afaac := &CT_Fills{}; return _afaac }

// ValidateWithPath validates the CT_MemberProperty and its children, prefixing error messages with path
func (_ecacd *CT_MemberProperty) ValidateWithPath(path string) error { return nil }
func NewCT_Consolidation() *CT_Consolidation {
	_bfeb := &CT_Consolidation{}
	_bfeb.RangeSets = NewCT_RangeSets()
	return _bfeb
}
func (_babdca *CT_PivotAreas) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _babdca.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_babdca.CountAttr)})
	}
	e.EncodeToken(start)
	if _babdca.PivotArea != nil {
		_eeeee := _f.StartElement{Name: _f.Name{Local: "ma:pivotArea"}}
		for _, _aagg := range _babdca.PivotArea {
			e.EncodeElement(_aagg, _eeeee)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cgdge *CT_colItems) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cbgbea := range start.Attr {
		if _cbgbea.Name.Local == "count" {
			_becfc, _cbbca := _g.ParseUint(_cbgbea.Value, 10, 32)
			if _cbbca != nil {
				return _cbbca
			}
			_cfcbga := uint32(_becfc)
			_cgdge.CountAttr = &_cfcbga
			continue
		}
	}
_fbgcd:
	for {
		_ggfdad, _fcfcgg := d.Token()
		if _fcfcgg != nil {
			return _fcfcgg
		}
		switch _gaggc := _ggfdad.(type) {
		case _f.StartElement:
			switch _gaggc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "i"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "i"}:
				_adegf := NewCT_I()
				if _effbf := d.DecodeElement(_adegf, &_gaggc); _effbf != nil {
					return _effbf
				}
				_cgdge.I = append(_cgdge.I, _adegf)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_colItems\u0020\u0025v", _gaggc.Name)
				if _acccc := d.Skip(); _acccc != nil {
					return _acccc
				}
			}
		case _f.EndElement:
			break _fbgcd
		case _f.CharData:
		}
	}
	return nil
}
func (_gfecf ST_TargetScreenSize) String() string {
	switch _gfecf {
	case 0:
		return ""
	case 1:
		return "544x376"
	case 2:
		return "640x480"
	case 3:
		return "720x512"
	case 4:
		return "800x600"
	case 5:
		return "1024x768"
	case 6:
		return "1152x882"
	case 7:
		return "1152x900"
	case 8:
		return "1280x1024"
	case 9:
		return "1600x1200"
	case 10:
		return "1800x1440"
	case 11:
		return "1920x1200"
	}
	return ""
}
func (_fece *CT_CellProtection) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dabe := range start.Attr {
		if _dabe.Name.Local == "locked" {
			_febd, _agag := _g.ParseBool(_dabe.Value)
			if _agag != nil {
				return _agag
			}
			_fece.LockedAttr = &_febd
			continue
		}
		if _dabe.Name.Local == "hidden" {
			_efdb, _eaedg := _g.ParseBool(_dabe.Value)
			if _eaedg != nil {
				return _eaedg
			}
			_fece.HiddenAttr = &_efdb
			continue
		}
	}
	for {
		_cbbag, _gec := d.Token()
		if _gec != nil {
			return _bg.Errorf("parsing\u0020CT_CellProtection: \u0025s", _gec)
		}
		if _daddc, _cebd := _cbbag.(_f.EndElement); _cebd && _daddc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gaggeb *ST_VerticalAlignment) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_gaggeb = 0
	case "top":
		*_gaggeb = 1
	case "center":
		*_gaggeb = 2
	case "bottom":
		*_gaggeb = 3
	case "justify":
		*_gaggeb = 4
	case "distributed":
		*_gaggeb = 5
	}
	return nil
}
func (_ceeec *CT_MemberProperties) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ceeec.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_ceeec.CountAttr)})
	}
	e.EncodeToken(start)
	_adgbb := _f.StartElement{Name: _f.Name{Local: "ma:mp"}}
	for _, _cfcf := range _ceeec.Mp {
		e.EncodeElement(_cfcf, _adgbb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cgcaffe ST_VolValueType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_cgcaffe.String(), start)
}
func (_bdgcbb ST_DdeValueType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_dcaab := _f.Attr{}
	_dcaab.Name = name
	switch _bdgcbb {
	case ST_DdeValueTypeUnset:
		_dcaab.Value = ""
	case ST_DdeValueTypeNil:
		_dcaab.Value = "nil"
	case ST_DdeValueTypeB:
		_dcaab.Value = "b"
	case ST_DdeValueTypeN:
		_dcaab.Value = "n"
	case ST_DdeValueTypeE:
		_dcaab.Value = "e"
	case ST_DdeValueTypeStr:
		_dcaab.Value = "str"
	}
	return _dcaab, nil
}
func NewCT_DataValidation() *CT_DataValidation { _eeea := &CT_DataValidation{}; return _eeea }
func (_dgfaeg *CT_RevisionCellChange) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sId"}, Value: _bg.Sprintf("\u0025v", _dgfaeg.SIdAttr)})
	if _dgfaeg.OdxfAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "odxf"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgfaeg.OdxfAttr))})
	}
	if _dgfaeg.XfDxfAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xfDxf"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgfaeg.XfDxfAttr))})
	}
	if _dgfaeg.SAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "s"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgfaeg.SAttr))})
	}
	if _dgfaeg.DxfAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "dxf"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgfaeg.DxfAttr))})
	}
	if _dgfaeg.NumFmtIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "numFmtId"}, Value: _bg.Sprintf("\u0025v", *_dgfaeg.NumFmtIdAttr)})
	}
	if _dgfaeg.QuotePrefixAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "quotePrefix"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgfaeg.QuotePrefixAttr))})
	}
	if _dgfaeg.OldQuotePrefixAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldQuotePrefix"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgfaeg.OldQuotePrefixAttr))})
	}
	if _dgfaeg.PhAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ph"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgfaeg.PhAttr))})
	}
	if _dgfaeg.OldPhAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldPh"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgfaeg.OldPhAttr))})
	}
	if _dgfaeg.EndOfListFormulaUpdateAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "endOfListFormulaUpdate"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgfaeg.EndOfListFormulaUpdateAttr))})
	}
	if _dgfaeg.RIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rId"}, Value: _bg.Sprintf("\u0025v", *_dgfaeg.RIdAttr)})
	}
	if _dgfaeg.UaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ua"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgfaeg.UaAttr))})
	}
	if _dgfaeg.RaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ra"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_dgfaeg.RaAttr))})
	}
	e.EncodeToken(start)
	if _dgfaeg.Oc != nil {
		_fffbd := _f.StartElement{Name: _f.Name{Local: "ma:oc"}}
		e.EncodeElement(_dgfaeg.Oc, _fffbd)
	}
	_fdecd := _f.StartElement{Name: _f.Name{Local: "ma:nc"}}
	e.EncodeElement(_dgfaeg.Nc, _fdecd)
	if _dgfaeg.Odxf != nil {
		_dbecd := _f.StartElement{Name: _f.Name{Local: "ma:odxf"}}
		e.EncodeElement(_dgfaeg.Odxf, _dbecd)
	}
	if _dgfaeg.Ndxf != nil {
		_afgbb := _f.StartElement{Name: _f.Name{Local: "ma:ndxf"}}
		e.EncodeElement(_dgfaeg.Ndxf, _afgbb)
	}
	if _dgfaeg.ExtLst != nil {
		_fcbaa := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_dgfaeg.ExtLst, _fcbaa)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_agbeed ST_TableStyleType) String() string {
	switch _agbeed {
	case 0:
		return ""
	case 1:
		return "wholeTable"
	case 2:
		return "headerRow"
	case 3:
		return "totalRow"
	case 4:
		return "firstColumn"
	case 5:
		return "lastColumn"
	case 6:
		return "firstRowStripe"
	case 7:
		return "secondRowStripe"
	case 8:
		return "firstColumnStripe"
	case 9:
		return "secondColumnStripe"
	case 10:
		return "firstHeaderCell"
	case 11:
		return "lastHeaderCell"
	case 12:
		return "firstTotalCell"
	case 13:
		return "lastTotalCell"
	case 14:
		return "firstSubtotalColumn"
	case 15:
		return "secondSubtotalColumn"
	case 16:
		return "thirdSubtotalColumn"
	case 17:
		return "firstSubtotalRow"
	case 18:
		return "secondSubtotalRow"
	case 19:
		return "thirdSubtotalRow"
	case 20:
		return "blankRow"
	case 21:
		return "firstColumnSubheading"
	case 22:
		return "secondColumnSubheading"
	case 23:
		return "thirdColumnSubheading"
	case 24:
		return "firstRowSubheading"
	case 25:
		return "secondRowSubheading"
	case 26:
		return "thirdRowSubheading"
	case 27:
		return "pageFieldLabels"
	case 28:
		return "pageFieldValues"
	}
	return ""
}
func (_bcadaa *CT_SheetBackgroundPicture) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _egebage := range start.Attr {
		if _egebage.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _egebage.Name.Local == "id" || _egebage.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _egebage.Name.Local == "id" {
			_eafgb, _cfbafa := _egebage.Value, error(nil)
			if _cfbafa != nil {
				return _cfbafa
			}
			_bcadaa.IdAttr = _eafgb
			continue
		}
	}
	for {
		_acdfdc, _dfdgf := d.Token()
		if _dfdgf != nil {
			return _bg.Errorf("parsing CT_SheetBackgroundPicture:\u0020\u0025s", _dfdgf)
		}
		if _beegf, _acbed := _acdfdc.(_f.EndElement); _acbed && _beegf.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_CommentList() *CT_CommentList { _bddb := &CT_CommentList{}; return _bddb }
func (_bbddcd *CT_Number) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fcag := range start.Attr {
		if _fcag.Name.Local == "fc" {
			_feabc, _baddda := _fcag.Value, error(nil)
			if _baddda != nil {
				return _baddda
			}
			_bbddcd.FcAttr = &_feabc
			continue
		}
		if _fcag.Name.Local == "v" {
			_agccc, _daebc := _g.ParseFloat(_fcag.Value, 64)
			if _daebc != nil {
				return _daebc
			}
			_bbddcd.VAttr = _agccc
			continue
		}
		if _fcag.Name.Local == "f" {
			_bbbfe, _fcfdba := _g.ParseBool(_fcag.Value)
			if _fcfdba != nil {
				return _fcfdba
			}
			_bbddcd.FAttr = &_bbbfe
			continue
		}
		if _fcag.Name.Local == "c" {
			_caccc, _gbffc := _fcag.Value, error(nil)
			if _gbffc != nil {
				return _gbffc
			}
			_bbddcd.CAttr = &_caccc
			continue
		}
		if _fcag.Name.Local == "cp" {
			_gfgeg, _ebffa := _g.ParseUint(_fcag.Value, 10, 32)
			if _ebffa != nil {
				return _ebffa
			}
			_feceg := uint32(_gfgeg)
			_bbddcd.CpAttr = &_feceg
			continue
		}
		if _fcag.Name.Local == "in" {
			_bacgg, _cbgbe := _g.ParseUint(_fcag.Value, 10, 32)
			if _cbgbe != nil {
				return _cbgbe
			}
			_eaced := uint32(_bacgg)
			_bbddcd.InAttr = &_eaced
			continue
		}
		if _fcag.Name.Local == "bc" {
			_gafdd, _edade := _fcag.Value, error(nil)
			if _edade != nil {
				return _edade
			}
			_bbddcd.BcAttr = &_gafdd
			continue
		}
		if _fcag.Name.Local == "u" {
			_eegg, _egaeb := _g.ParseBool(_fcag.Value)
			if _egaeb != nil {
				return _egaeb
			}
			_bbddcd.UAttr = &_eegg
			continue
		}
		if _fcag.Name.Local == "i" {
			_daeae, _acccf := _g.ParseBool(_fcag.Value)
			if _acccf != nil {
				return _acccf
			}
			_bbddcd.IAttr = &_daeae
			continue
		}
		if _fcag.Name.Local == "un" {
			_bedag, _bfgae := _g.ParseBool(_fcag.Value)
			if _bfgae != nil {
				return _bfgae
			}
			_bbddcd.UnAttr = &_bedag
			continue
		}
		if _fcag.Name.Local == "st" {
			_eegae, _dfadf := _g.ParseBool(_fcag.Value)
			if _dfadf != nil {
				return _dfadf
			}
			_bbddcd.StAttr = &_eegae
			continue
		}
		if _fcag.Name.Local == "b" {
			_facad, _aedcf := _g.ParseBool(_fcag.Value)
			if _aedcf != nil {
				return _aedcf
			}
			_bbddcd.BAttr = &_facad
			continue
		}
	}
_bgcc:
	for {
		_beeed, _ffdcfc := d.Token()
		if _ffdcfc != nil {
			return _ffdcfc
		}
		switch _fcddae := _beeed.(type) {
		case _f.StartElement:
			switch _fcddae.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tpls"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tpls"}:
				_acbc := NewCT_Tuples()
				if _adged := d.DecodeElement(_acbc, &_fcddae); _adged != nil {
					return _adged
				}
				_bbddcd.Tpls = append(_bbddcd.Tpls, _acbc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "x"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "x"}:
				_gaabdf := NewCT_X()
				if _gegcg := d.DecodeElement(_gaabdf, &_fcddae); _gegcg != nil {
					return _gegcg
				}
				_bbddcd.X = append(_bbddcd.X, _gaabdf)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_Number \u0025v", _fcddae.Name)
				if _ddbge := d.Skip(); _ddbge != nil {
					return _ddbge
				}
			}
		case _f.EndElement:
			break _bgcc
		case _f.CharData:
		}
	}
	return nil
}
func (_bebab *CT_SharedUser) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bebab.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	for _, _cagfdd := range start.Attr {
		if _cagfdd.Name.Local == "guid" {
			_eedcaa, _baefb := _cagfdd.Value, error(nil)
			if _baefb != nil {
				return _baefb
			}
			_bebab.GuidAttr = _eedcaa
			continue
		}
		if _cagfdd.Name.Local == "name" {
			_debgc, _bffe := _cagfdd.Value, error(nil)
			if _bffe != nil {
				return _bffe
			}
			_bebab.NameAttr = _debgc
			continue
		}
		if _cagfdd.Name.Local == "id" {
			_agcag, _ecbceb := _g.ParseInt(_cagfdd.Value, 10, 32)
			if _ecbceb != nil {
				return _ecbceb
			}
			_bebab.IdAttr = int32(_agcag)
			continue
		}
		if _cagfdd.Name.Local == "dateTime" {
			_ggfcb, _cgdbe := ParseStdlibTime(_cagfdd.Value)
			if _cgdbe != nil {
				return _cgdbe
			}
			_bebab.DateTimeAttr = _ggfcb
			continue
		}
	}
_befcfc:
	for {
		_gcgbc, _dcefa := d.Token()
		if _dcefa != nil {
			return _dcefa
		}
		switch _fefefe := _gcgbc.(type) {
		case _f.StartElement:
			switch _fefefe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bebab.ExtLst = NewCT_ExtensionList()
				if _afbag := d.DecodeElement(_bebab.ExtLst, &_fefefe); _afbag != nil {
					return _afbag
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_SharedUser \u0025v", _fefefe.Name)
				if _ebdaca := d.Skip(); _ebdaca != nil {
					return _ebdaca
				}
			}
		case _f.EndElement:
			break _befcfc
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_OlapPr and its children
func (_dfecga *CT_OlapPr) Validate() error { return _dfecga.ValidateWithPath("CT_OlapPr") }
func (_cedf *CT_MetadataBlock) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_bbeef:
	for {
		_bdaaa, _dgacb := d.Token()
		if _dgacb != nil {
			return _dgacb
		}
		switch _adedf := _bdaaa.(type) {
		case _f.StartElement:
			switch _adedf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rc"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rc"}:
				_gffge := NewCT_MetadataRecord()
				if _becb := d.DecodeElement(_gffge, &_adedf); _becb != nil {
					return _becb
				}
				_cedf.Rc = append(_cedf.Rc, _gffge)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_MetadataBlock\u0020\u0025v", _adedf.Name)
				if _bgfcgb := d.Skip(); _bgfcgb != nil {
					return _bgfcgb
				}
			}
		case _f.EndElement:
			break _bbeef
		case _f.CharData:
		}
	}
	return nil
}
func (_gggbb *ST_DataConsolidateFunction) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_facaa, _bacfd := d.Token()
	if _bacfd != nil {
		return _bacfd
	}
	if _ccadea, _affgfc := _facaa.(_f.EndElement); _affgfc && _ccadea.Name == start.Name {
		*_gggbb = 1
		return nil
	}
	if _eaeag, _begfge := _facaa.(_f.CharData); !_begfge {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _facaa)
	} else {
		switch string(_eaeag) {
		case "":
			*_gggbb = 0
		case "average":
			*_gggbb = 1
		case "count":
			*_gggbb = 2
		case "countNums":
			*_gggbb = 3
		case "max":
			*_gggbb = 4
		case "min":
			*_gggbb = 5
		case "product":
			*_gggbb = 6
		case "stdDev":
			*_gggbb = 7
		case "stdDevp":
			*_gggbb = 8
		case "sum":
			*_gggbb = 9
		case "var":
			*_gggbb = 10
		case "varp":
			*_gggbb = 11
		}
	}
	_facaa, _bacfd = d.Token()
	if _bacfd != nil {
		return _bacfd
	}
	if _aecce, _adgabd := _facaa.(_f.EndElement); _adgabd && _aecce.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _facaa)
}
func (_cfbfda *ST_VolDepType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_cfbfda = 0
	case "realTimeData":
		*_cfbfda = 1
	case "olapFunctions":
		*_cfbfda = 2
	}
	return nil
}
func (_degdd *CT_TableStyle) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _degdd.NameAttr)})
	if _degdd.PivotAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "pivot"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_degdd.PivotAttr))})
	}
	if _degdd.TableAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "table"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_degdd.TableAttr))})
	}
	if _degdd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_degdd.CountAttr)})
	}
	e.EncodeToken(start)
	if _degdd.TableStyleElement != nil {
		_bgeec := _f.StartElement{Name: _f.Name{Local: "ma:tableStyleElement"}}
		for _, _dbgad := range _degdd.TableStyleElement {
			e.EncodeElement(_dbgad, _bgeec)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dddde *ST_DdeValueType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cgegce, _cacbbe := d.Token()
	if _cacbbe != nil {
		return _cacbbe
	}
	if _adadc, _ebdddc := _cgegce.(_f.EndElement); _ebdddc && _adadc.Name == start.Name {
		*_dddde = 1
		return nil
	}
	if _gacbfc, _ebdfb := _cgegce.(_f.CharData); !_ebdfb {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cgegce)
	} else {
		switch string(_gacbfc) {
		case "":
			*_dddde = 0
		case "nil":
			*_dddde = 1
		case "b":
			*_dddde = 2
		case "n":
			*_dddde = 3
		case "e":
			*_dddde = 4
		case "str":
			*_dddde = 5
		}
	}
	_cgegce, _cacbbe = d.Token()
	if _cacbbe != nil {
		return _cacbbe
	}
	if _bdbff, _cdbcgc := _cgegce.(_f.EndElement); _cdbcgc && _bdbff.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cgegce)
}

// ValidateWithPath validates the CT_LegacyDrawing and its children, prefixing error messages with path
func (_aeffgb *CT_LegacyDrawing) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_Sheet and its children, prefixing error messages with path
func (_dagda *CT_Sheet) ValidateWithPath(path string) error {
	if _fagba := _dagda.StateAttr.ValidateWithPath(path + "\u002fStateAttr"); _fagba != nil {
		return _fagba
	}
	return nil
}

type CT_DdeItems struct {

	// DDE Item definition
	DdeItem []*CT_DdeItem
}

func (_bddba *CT_Extension) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aedcb := range start.Attr {
		if _aedcb.Name.Local == "uri" {
			_baef, _gefg := _aedcb.Value, error(nil)
			if _gefg != nil {
				return _gefg
			}
			_bddba.UriAttr = &_baef
			continue
		}
	}
_bddbab:
	for {
		_gbbga, _dcaa := d.Token()
		if _dcaa != nil {
			return _dcaa
		}
		switch _cbgcb := _gbbga.(type) {
		case _f.StartElement:
			switch _cbgcb.Name {
			default:
				if _cdgce, _ebdcc := _cb.CreateElement(_cbgcb); _ebdcc != nil {
					return _ebdcc
				} else {
					if _gcfg := d.DecodeElement(_cdgce, &_cbgcb); _gcfg != nil {
						return _gcfg
					}
					_bddba.Any = _cdgce
				}
			}
		case _f.EndElement:
			break _bddbab
		case _f.CharData:
		}
	}
	return nil
}
func (_aefcbd *CT_RowHierarchiesUsage) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aefcbd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_aefcbd.CountAttr)})
	}
	e.EncodeToken(start)
	_ggcdc := _f.StartElement{Name: _f.Name{Local: "ma:rowHierarchyUsage"}}
	for _, _effegb := range _aefcbd.RowHierarchyUsage {
		e.EncodeElement(_effegb, _ggcdc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_Member struct {

	// Hidden Item Name
	NameAttr string
}

func NewCT_Hyperlinks() *CT_Hyperlinks { _bccdf := &CT_Hyperlinks{}; return _bccdf }

// Validate validates the CT_FieldUsage and its children
func (_ebaga *CT_FieldUsage) Validate() error { return _ebaga.ValidateWithPath("CT_FieldUsage") }
func (_abead ST_PaneState) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_gaacea := _f.Attr{}
	_gaacea.Name = name
	switch _abead {
	case ST_PaneStateUnset:
		_gaacea.Value = ""
	case ST_PaneStateSplit:
		_gaacea.Value = "split"
	case ST_PaneStateFrozen:
		_gaacea.Value = "frozen"
	case ST_PaneStateFrozenSplit:
		_gaacea.Value = "frozenSplit"
	}
	return _gaacea, nil
}
func (_ddbdf *ST_DataValidationOperator) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_aebfae, _abafe := d.Token()
	if _abafe != nil {
		return _abafe
	}
	if _gddcde, _fbbad := _aebfae.(_f.EndElement); _fbbad && _gddcde.Name == start.Name {
		*_ddbdf = 1
		return nil
	}
	if _cgfcae, _ebfcgg := _aebfae.(_f.CharData); !_ebfcgg {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aebfae)
	} else {
		switch string(_cgfcae) {
		case "":
			*_ddbdf = 0
		case "between":
			*_ddbdf = 1
		case "notBetween":
			*_ddbdf = 2
		case "equal":
			*_ddbdf = 3
		case "notEqual":
			*_ddbdf = 4
		case "lessThan":
			*_ddbdf = 5
		case "lessThanOrEqual":
			*_ddbdf = 6
		case "greaterThan":
			*_ddbdf = 7
		case "greaterThanOrEqual":
			*_ddbdf = 8
		}
	}
	_aebfae, _abafe = d.Token()
	if _abafe != nil {
		return _abafe
	}
	if _gfcaa, _cddgb := _aebfae.(_f.EndElement); _cddgb && _gfcaa.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aebfae)
}
func (_gedebd *CT_WorksheetSource) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gedebd.RefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", *_gedebd.RefAttr)})
	}
	if _gedebd.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_gedebd.NameAttr)})
	}
	if _gedebd.SheetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheet"}, Value: _bg.Sprintf("\u0025v", *_gedebd.SheetAttr)})
	}
	if _gedebd.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", *_gedebd.IdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_effbc ST_CfvoType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_effbc.String(), start)
}
func (_ecgac *CT_SheetData) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _ecgac.Row != nil {
		_ffdab := _f.StartElement{Name: _f.Name{Local: "ma:row"}}
		for _, _eefeda := range _ecgac.Row {
			e.EncodeElement(_eefeda, _ffdab)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

const (
	ST_ScopeUnset     ST_Scope = 0
	ST_ScopeSelection ST_Scope = 1
	ST_ScopeData      ST_Scope = 2
	ST_ScopeField     ST_Scope = 3
)

// Validate validates the CT_Formats and its children
func (_bdfde *CT_Formats) Validate() error { return _bdfde.ValidateWithPath("CT_Formats") }
func (_cacegg *CT_DataField) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aadfa := range start.Attr {
		if _aadfa.Name.Local == "name" {
			_acfec, _debc := _aadfa.Value, error(nil)
			if _debc != nil {
				return _debc
			}
			_cacegg.NameAttr = &_acfec
			continue
		}
		if _aadfa.Name.Local == "fld" {
			_dbfd, _gddea := _g.ParseUint(_aadfa.Value, 10, 32)
			if _gddea != nil {
				return _gddea
			}
			_cacegg.FldAttr = uint32(_dbfd)
			continue
		}
		if _aadfa.Name.Local == "subtotal" {
			_cacegg.SubtotalAttr.UnmarshalXMLAttr(_aadfa)
			continue
		}
		if _aadfa.Name.Local == "showDataAs" {
			_cacegg.ShowDataAsAttr.UnmarshalXMLAttr(_aadfa)
			continue
		}
		if _aadfa.Name.Local == "baseField" {
			_bbdd, _ccge := _g.ParseInt(_aadfa.Value, 10, 32)
			if _ccge != nil {
				return _ccge
			}
			_adeee := int32(_bbdd)
			_cacegg.BaseFieldAttr = &_adeee
			continue
		}
		if _aadfa.Name.Local == "baseItem" {
			_ccfff, _eade := _g.ParseUint(_aadfa.Value, 10, 32)
			if _eade != nil {
				return _eade
			}
			_eaaa := uint32(_ccfff)
			_cacegg.BaseItemAttr = &_eaaa
			continue
		}
		if _aadfa.Name.Local == "numFmtId" {
			_addag, _bgce := _g.ParseUint(_aadfa.Value, 10, 32)
			if _bgce != nil {
				return _bgce
			}
			_geacf := uint32(_addag)
			_cacegg.NumFmtIdAttr = &_geacf
			continue
		}
	}
_dgcb:
	for {
		_cacdg, _ddgg := d.Token()
		if _ddgg != nil {
			return _ddgg
		}
		switch _gaec := _cacdg.(type) {
		case _f.StartElement:
			switch _gaec.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_cacegg.ExtLst = NewCT_ExtensionList()
				if _agba := d.DecodeElement(_cacegg.ExtLst, &_gaec); _agba != nil {
					return _agba
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DataField\u0020\u0025v", _gaec.Name)
				if _beggd := d.Skip(); _beggd != nil {
					return _beggd
				}
			}
		case _f.EndElement:
			break _dgcb
		case _f.CharData:
		}
	}
	return nil
}
func (_aceefa ST_SheetState) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_gccbfd := _f.Attr{}
	_gccbfd.Name = name
	switch _aceefa {
	case ST_SheetStateUnset:
		_gccbfd.Value = ""
	case ST_SheetStateVisible:
		_gccbfd.Value = "visible"
	case ST_SheetStateHidden:
		_gccbfd.Value = "hidden"
	case ST_SheetStateVeryHidden:
		_gccbfd.Value = "veryHidden"
	}
	return _gccbfd, nil
}

// Validate validates the Connections and its children
func (_cgegd *Connections) Validate() error { return _cgegd.ValidateWithPath("Connections") }
func (_ccaaac ST_CfType) String() string {
	switch _ccaaac {
	case 0:
		return ""
	case 1:
		return "expression"
	case 2:
		return "cellIs"
	case 3:
		return "colorScale"
	case 4:
		return "dataBar"
	case 5:
		return "iconSet"
	case 6:
		return "top10"
	case 7:
		return "uniqueValues"
	case 8:
		return "duplicateValues"
	case 9:
		return "containsText"
	case 10:
		return "notContainsText"
	case 11:
		return "beginsWith"
	case 12:
		return "endsWith"
	case 13:
		return "containsBlanks"
	case 14:
		return "notContainsBlanks"
	case 15:
		return "containsErrors"
	case 16:
		return "notContainsErrors"
	case 17:
		return "timePeriod"
	case 18:
		return "aboveAverage"
	}
	return ""
}
func (_dffbg *ST_DvAspect) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_dffbg = 0
	case "DVASPECT_CONTENT":
		*_dffbg = 1
	case "DVASPECT_ICON":
		*_dffbg = 2
	}
	return nil
}
func NewCT_VolType() *CT_VolType {
	_ggacbb := &CT_VolType{}
	_ggacbb.TypeAttr = ST_VolDepType(1)
	return _ggacbb
}

// Validate validates the CT_Workbook and its children
func (_bddafa *CT_Workbook) Validate() error { return _bddafa.ValidateWithPath("CT_Workbook") }
func (_facag ST_CredMethod) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_gacgaa := _f.Attr{}
	_gacgaa.Name = name
	switch _facag {
	case ST_CredMethodUnset:
		_gacgaa.Value = ""
	case ST_CredMethodIntegrated:
		_gacgaa.Value = "integrated"
	case ST_CredMethodNone:
		_gacgaa.Value = "none"
	case ST_CredMethodStored:
		_gacgaa.Value = "stored"
	case ST_CredMethodPrompt:
		_gacgaa.Value = "prompt"
	}
	return _gacgaa, nil
}
func (_gddag *CT_ChartsheetViews) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_geae := _f.StartElement{Name: _f.Name{Local: "ma:sheetView"}}
	for _, _edgd := range _gddag.SheetView {
		e.EncodeElement(_edgd, _geae)
	}
	if _gddag.ExtLst != nil {
		_bdaa := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_gddag.ExtLst, _bdaa)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bcgg *CT_IconSet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _daec := range start.Attr {
		if _daec.Name.Local == "iconSet" {
			_bcgg.IconSetAttr.UnmarshalXMLAttr(_daec)
			continue
		}
		if _daec.Name.Local == "showValue" {
			_afgef, _baecf := _g.ParseBool(_daec.Value)
			if _baecf != nil {
				return _baecf
			}
			_bcgg.ShowValueAttr = &_afgef
			continue
		}
		if _daec.Name.Local == "percent" {
			_abceeg, _caddg := _g.ParseBool(_daec.Value)
			if _caddg != nil {
				return _caddg
			}
			_bcgg.PercentAttr = &_abceeg
			continue
		}
		if _daec.Name.Local == "reverse" {
			_fcbag, _begeg := _g.ParseBool(_daec.Value)
			if _begeg != nil {
				return _begeg
			}
			_bcgg.ReverseAttr = &_fcbag
			continue
		}
	}
_faacd:
	for {
		_gabfdd, _abbef := d.Token()
		if _abbef != nil {
			return _abbef
		}
		switch _gaeeb := _gabfdd.(type) {
		case _f.StartElement:
			switch _gaeeb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cfvo"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cfvo"}:
				_gdbe := NewCT_Cfvo()
				if _ddfac := d.DecodeElement(_gdbe, &_gaeeb); _ddfac != nil {
					return _ddfac
				}
				_bcgg.Cfvo = append(_bcgg.Cfvo, _gdbe)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_IconSet\u0020\u0025v", _gaeeb.Name)
				if _caedf := d.Skip(); _caedf != nil {
					return _caedf
				}
			}
		case _f.EndElement:
			break _faacd
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_ChartsheetView() *CT_ChartsheetView { _ecca := &CT_ChartsheetView{}; return _ecca }
func (_dgbee *CT_RangeSets) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ccefe := range start.Attr {
		if _ccefe.Name.Local == "count" {
			_cdfcd, _aeece := _g.ParseUint(_ccefe.Value, 10, 32)
			if _aeece != nil {
				return _aeece
			}
			_edbabe := uint32(_cdfcd)
			_dgbee.CountAttr = &_edbabe
			continue
		}
	}
_cgfaff:
	for {
		_ddadbe, _ggfaa := d.Token()
		if _ggfaa != nil {
			return _ggfaa
		}
		switch _eafeb := _ddadbe.(type) {
		case _f.StartElement:
			switch _eafeb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rangeSet"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rangeSet"}:
				_gagfe := NewCT_RangeSet()
				if _effaff := d.DecodeElement(_gagfe, &_eafeb); _effaff != nil {
					return _effaff
				}
				_dgbee.RangeSet = append(_dgbee.RangeSet, _gagfe)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RangeSets\u0020\u0025v", _eafeb.Name)
				if _egeec := d.Skip(); _egeec != nil {
					return _egeec
				}
			}
		case _f.EndElement:
			break _cgfaff
		case _f.CharData:
		}
	}
	return nil
}
func (_cfab *CT_CalculatedItems) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dffb := range start.Attr {
		if _dffb.Name.Local == "count" {
			_acee, _bag := _g.ParseUint(_dffb.Value, 10, 32)
			if _bag != nil {
				return _bag
			}
			_ffgg := uint32(_acee)
			_cfab.CountAttr = &_ffgg
			continue
		}
	}
_cfc:
	for {
		_ddca, _deecd := d.Token()
		if _deecd != nil {
			return _deecd
		}
		switch _cdgc := _ddca.(type) {
		case _f.StartElement:
			switch _cdgc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "calculatedItem"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "calculatedItem"}:
				_afa := NewCT_CalculatedItem()
				if _ecff := d.DecodeElement(_afa, &_cdgc); _ecff != nil {
					return _ecff
				}
				_cfab.CalculatedItem = append(_cfab.CalculatedItem, _afa)
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_CalculatedItems\u0020\u0025v", _cdgc.Name)
				if _agfca := d.Skip(); _agfca != nil {
					return _agfca
				}
			}
		case _f.EndElement:
			break _cfc
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Scenario and its children
func (_bffceb *CT_Scenario) Validate() error { return _bffceb.ValidateWithPath("CT_Scenario") }
func (_gbfcg *CT_TupleCache) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_bdfgg:
	for {
		_bfbafa, _fecae := d.Token()
		if _fecae != nil {
			return _fecae
		}
		switch _beaggb := _bfbafa.(type) {
		case _f.StartElement:
			switch _beaggb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "entries"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "entries"}:
				_gbfcg.Entries = NewCT_PCDSDTCEntries()
				if _bgdae := d.DecodeElement(_gbfcg.Entries, &_beaggb); _bgdae != nil {
					return _bgdae
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sets"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sets"}:
				_gbfcg.Sets = NewCT_Sets()
				if _bdbda := d.DecodeElement(_gbfcg.Sets, &_beaggb); _bdbda != nil {
					return _bdbda
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "queryCache"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "queryCache"}:
				_gbfcg.QueryCache = NewCT_QueryCache()
				if _dfccb := d.DecodeElement(_gbfcg.QueryCache, &_beaggb); _dfccb != nil {
					return _dfccb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "serverFormats"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "serverFormats"}:
				_gbfcg.ServerFormats = NewCT_ServerFormats()
				if _bgfba := d.DecodeElement(_gbfcg.ServerFormats, &_beaggb); _bgfba != nil {
					return _bgfba
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gbfcg.ExtLst = NewCT_ExtensionList()
				if _afbfc := d.DecodeElement(_gbfcg.ExtLst, &_beaggb); _afbfc != nil {
					return _afbfc
				}
			default:
				_cb.Log("skipping unsupported element\u0020on\u0020CT_TupleCache \u0025v", _beaggb.Name)
				if _gbeaea := d.Skip(); _gbeaea != nil {
					return _gbeaea
				}
			}
		case _f.EndElement:
			break _bdfgg
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_CalculatedMembers and its children
func (_eed *CT_CalculatedMembers) Validate() error {
	return _eed.ValidateWithPath("CT_CalculatedMembers")
}
func (_ddff *CT_Dxf) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_daab:
	for {
		_geecc, _dcddf := d.Token()
		if _dcddf != nil {
			return _dcddf
		}
		switch _aedea := _geecc.(type) {
		case _f.StartElement:
			switch _aedea.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "font"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "font"}:
				_ddff.Font = NewCT_Font()
				if _adfbf := d.DecodeElement(_ddff.Font, &_aedea); _adfbf != nil {
					return _adfbf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "numFmt"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "numFmt"}:
				_ddff.NumFmt = NewCT_NumFmt()
				if _cecg := d.DecodeElement(_ddff.NumFmt, &_aedea); _cecg != nil {
					return _cecg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fill"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fill"}:
				_ddff.Fill = NewCT_Fill()
				if _fccec := d.DecodeElement(_ddff.Fill, &_aedea); _fccec != nil {
					return _fccec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "alignment"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "alignment"}:
				_ddff.Alignment = NewCT_CellAlignment()
				if _aeaec := d.DecodeElement(_ddff.Alignment, &_aedea); _aeaec != nil {
					return _aeaec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "border"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "border"}:
				_ddff.Border = NewCT_Border()
				if _ddabd := d.DecodeElement(_ddff.Border, &_aedea); _ddabd != nil {
					return _ddabd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "protection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "protection"}:
				_ddff.Protection = NewCT_CellProtection()
				if _cggec := d.DecodeElement(_ddff.Protection, &_aedea); _cggec != nil {
					return _cggec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ddff.ExtLst = NewCT_ExtensionList()
				if _ddfee := d.DecodeElement(_ddff.ExtLst, &_aedea); _ddfee != nil {
					return _ddfee
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Dxf\u0020\u0025v", _aedea.Name)
				if _cfge := d.Skip(); _cfge != nil {
					return _cfge
				}
			}
		case _f.EndElement:
			break _daab
		case _f.CharData:
		}
	}
	return nil
}
func (_abfa *CT_FontName) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fdad := range start.Attr {
		if _fdad.Name.Local == "val" {
			_egcacc, _ggecf := _fdad.Value, error(nil)
			if _ggecf != nil {
				return _ggecf
			}
			_abfa.ValAttr = _egcacc
			continue
		}
	}
	for {
		_ebcgf, _debge := d.Token()
		if _debge != nil {
			return _bg.Errorf("parsing\u0020CT_FontName:\u0020\u0025s", _debge)
		}
		if _ecdfd, _gaabb := _ebcgf.(_f.EndElement); _gaabb && _ecdfd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fdcbgd *CT_FontSize) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", _fdcbgd.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_fdgc *CT_CellSmartTag) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "type"}, Value: _bg.Sprintf("\u0025v", _fdgc.TypeAttr)})
	if _fdgc.DeletedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "deleted"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fdgc.DeletedAttr))})
	}
	if _fdgc.XmlBasedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlBased"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fdgc.XmlBasedAttr))})
	}
	e.EncodeToken(start)
	if _fdgc.CellSmartTagPr != nil {
		_faca := _f.StartElement{Name: _f.Name{Local: "ma:cellSmartTagPr"}}
		for _, _bagg := range _fdgc.CellSmartTagPr {
			e.EncodeElement(_bagg, _faca)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Fill and its children
func (_bcfc *CT_Fill) Validate() error { return _bcfc.ValidateWithPath("CT_Fill") }

const (
	ST_MdxFunctionTypeUnset ST_MdxFunctionType = 0
	ST_MdxFunctionTypeM     ST_MdxFunctionType = 1
	ST_MdxFunctionTypeV     ST_MdxFunctionType = 2
	ST_MdxFunctionTypeS     ST_MdxFunctionType = 3
	ST_MdxFunctionTypeC     ST_MdxFunctionType = 4
	ST_MdxFunctionTypeR     ST_MdxFunctionType = 5
	ST_MdxFunctionTypeP     ST_MdxFunctionType = 6
	ST_MdxFunctionTypeK     ST_MdxFunctionType = 7
)

type CT_PhoneticRun struct {

	// Base Text Start Index
	SbAttr uint32

	// Base Text End Index
	EbAttr uint32

	// Text
	T string
}

func (_egbed ST_BorderStyle) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_egbed.String(), start)
}

type CT_QueryCache struct {

	// Cached Query Count
	CountAttr *uint32

	// Query
	Query []*CT_Query
}

func (_eggeea ST_PhoneticType) Validate() error { return _eggeea.ValidateWithPath("") }

// Validate validates the CT_CfRule and its children
func (_gfdb *CT_CfRule) Validate() error { return _gfdb.ValidateWithPath("CT_CfRule") }

// ValidateWithPath validates the CT_Comments and its children, prefixing error messages with path
func (_fbeg *CT_Comments) ValidateWithPath(path string) error {
	if _dcbg := _fbeg.Authors.ValidateWithPath(path + "\u002fAuthors"); _dcbg != nil {
		return _dcbg
	}
	if _daae := _fbeg.CommentList.ValidateWithPath(path + "\u002fCommentList"); _daae != nil {
		return _daae
	}
	if _fbeg.ExtLst != nil {
		if _gfcb := _fbeg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gfcb != nil {
			return _gfcb
		}
	}
	return nil
}
func (_gacag *ST_CalcMode) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_gacag = 0
	case "manual":
		*_gacag = 1
	case "auto":
		*_gacag = 2
	case "autoNoTable":
		*_gacag = 3
	}
	return nil
}
func (_cfcec *CT_DataConsolidate) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cebdfc := range start.Attr {
		if _cebdfc.Name.Local == "function" {
			_cfcec.FunctionAttr.UnmarshalXMLAttr(_cebdfc)
			continue
		}
		if _cebdfc.Name.Local == "startLabels" {
			_cebaf, _deef := _g.ParseBool(_cebdfc.Value)
			if _deef != nil {
				return _deef
			}
			_cfcec.StartLabelsAttr = &_cebaf
			continue
		}
		if _cebdfc.Name.Local == "leftLabels" {
			_bdgfg, _aecdcb := _g.ParseBool(_cebdfc.Value)
			if _aecdcb != nil {
				return _aecdcb
			}
			_cfcec.LeftLabelsAttr = &_bdgfg
			continue
		}
		if _cebdfc.Name.Local == "topLabels" {
			_cgdd, _dbge := _g.ParseBool(_cebdfc.Value)
			if _dbge != nil {
				return _dbge
			}
			_cfcec.TopLabelsAttr = &_cgdd
			continue
		}
		if _cebdfc.Name.Local == "link" {
			_egbge, _gaee := _g.ParseBool(_cebdfc.Value)
			if _gaee != nil {
				return _gaee
			}
			_cfcec.LinkAttr = &_egbge
			continue
		}
	}
_fgcad:
	for {
		_degd, _fabff := d.Token()
		if _fabff != nil {
			return _fabff
		}
		switch _daade := _degd.(type) {
		case _f.StartElement:
			switch _daade.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataRefs"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataRefs"}:
				_cfcec.DataRefs = NewCT_DataRefs()
				if _gfeced := d.DecodeElement(_cfcec.DataRefs, &_daade); _gfeced != nil {
					return _gfeced
				}
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_DataConsolidate\u0020\u0025v", _daade.Name)
				if _fccg := d.Skip(); _fccg != nil {
					return _fccg
				}
			}
		case _f.EndElement:
			break _fgcad
		case _f.CharData:
		}
	}
	return nil
}

type QueryTable struct{ CT_QueryTable }
type ST_CfType byte

func (_egfaa ST_Qualifier) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_egfaa.String(), start)
}

// Validate validates the CT_MdxTuple and its children
func (_gefae *CT_MdxTuple) Validate() error { return _gefae.ValidateWithPath("CT_MdxTuple") }

type CT_OleObjects struct {

	// Embedded Object
	OleObject []*CT_OleObject
}

func (_acbgg *CT_DeletedField) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _acbgg.NameAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_TableStyleInfo struct {

	// Style Name
	NameAttr *string

	// Show First Column
	ShowFirstColumnAttr *bool

	// Show Last Column
	ShowLastColumnAttr *bool

	// Show Row Stripes
	ShowRowStripesAttr *bool

	// Show Column Stripes
	ShowColumnStripesAttr *bool
}

func (_bcdddd ST_MdxSetOrder) String() string {
	switch _bcdddd {
	case 0:
		return ""
	case 1:
		return "u"
	case 2:
		return "a"
	case 3:
		return "d"
	case 4:
		return "aa"
	case 5:
		return "ad"
	case 6:
		return "na"
	case 7:
		return "nd"
	}
	return ""
}
func (_cafaa *CT_DefinedName) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _cafaa.NameAttr)})
	if _cafaa.CommentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "comment"}, Value: _bg.Sprintf("\u0025v", *_cafaa.CommentAttr)})
	}
	if _cafaa.CustomMenuAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "customMenu"}, Value: _bg.Sprintf("\u0025v", *_cafaa.CustomMenuAttr)})
	}
	if _cafaa.DescriptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "description"}, Value: _bg.Sprintf("\u0025v", *_cafaa.DescriptionAttr)})
	}
	if _cafaa.HelpAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "help"}, Value: _bg.Sprintf("\u0025v", *_cafaa.HelpAttr)})
	}
	if _cafaa.StatusBarAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "statusBar"}, Value: _bg.Sprintf("\u0025v", *_cafaa.StatusBarAttr)})
	}
	if _cafaa.LocalSheetIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "localSheetId"}, Value: _bg.Sprintf("\u0025v", *_cafaa.LocalSheetIdAttr)})
	}
	if _cafaa.HiddenAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hidden"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cafaa.HiddenAttr))})
	}
	if _cafaa.FunctionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "function"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cafaa.FunctionAttr))})
	}
	if _cafaa.VbProcedureAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "vbProcedure"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cafaa.VbProcedureAttr))})
	}
	if _cafaa.XlmAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xlm"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cafaa.XlmAttr))})
	}
	if _cafaa.FunctionGroupIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "functionGroupId"}, Value: _bg.Sprintf("\u0025v", *_cafaa.FunctionGroupIdAttr)})
	}
	if _cafaa.ShortcutKeyAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "shortcutKey"}, Value: _bg.Sprintf("\u0025v", *_cafaa.ShortcutKeyAttr)})
	}
	if _cafaa.PublishToServerAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "publishToServer"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cafaa.PublishToServerAttr))})
	}
	if _cafaa.WorkbookParameterAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "workbookParameter"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_cafaa.WorkbookParameterAttr))})
	}
	e.EncodeElement(_cafaa.Content, start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_OleSize() *CT_OleSize { _aaeefa := &CT_OleSize{}; return _aaeefa }
func (_ffdad ST_TableType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_ffdad.String(), start)
}

// Validate validates the CT_Controls and its children
func (_bffcc *CT_Controls) Validate() error { return _bffcc.ValidateWithPath("CT_Controls") }
func (_dffdag ST_BorderStyle) String() string {
	switch _dffdag {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "thin"
	case 3:
		return "medium"
	case 4:
		return "dashed"
	case 5:
		return "dotted"
	case 6:
		return "thick"
	case 7:
		return "double"
	case 8:
		return "hair"
	case 9:
		return "mediumDashed"
	case 10:
		return "dashDot"
	case 11:
		return "mediumDashDot"
	case 12:
		return "dashDotDot"
	case 13:
		return "mediumDashDotDot"
	case 14:
		return "slantDashDot"
	}
	return ""
}

// ValidateWithPath validates the CT_Sheets and its children, prefixing error messages with path
func (_debcd *CT_Sheets) ValidateWithPath(path string) error {
	for _cfeccf, _degcb := range _debcd.Sheet {
		if _gcded := _degcb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fSheet\u005b\u0025d\u005d", path, _cfeccf)); _gcded != nil {
			return _gcded
		}
	}
	return nil
}
func (_cdaeg ST_FormatAction) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_caadcc := _f.Attr{}
	_caadcc.Name = name
	switch _cdaeg {
	case ST_FormatActionUnset:
		_caadcc.Value = ""
	case ST_FormatActionBlank:
		_caadcc.Value = "blank"
	case ST_FormatActionFormatting:
		_caadcc.Value = "formatting"
	case ST_FormatActionDrill:
		_caadcc.Value = "drill"
	case ST_FormatActionFormula:
		_caadcc.Value = "formula"
	}
	return _caadcc, nil
}
func (_faefdd *CT_MapInfo) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _eaeb := range start.Attr {
		if _eaeb.Name.Local == "SelectionNamespaces" {
			_dbada, _ecafa := _eaeb.Value, error(nil)
			if _ecafa != nil {
				return _ecafa
			}
			_faefdd.SelectionNamespacesAttr = _dbada
			continue
		}
	}
_faabe:
	for {
		_eaddg, _cfgdc := d.Token()
		if _cfgdc != nil {
			return _cfgdc
		}
		switch _cbgdd := _eaddg.(type) {
		case _f.StartElement:
			switch _cbgdd.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "Schema"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "Schema"}:
				_efbac := NewCT_Schema()
				if _egbea := d.DecodeElement(_efbac, &_cbgdd); _egbea != nil {
					return _egbea
				}
				_faefdd.Schema = append(_faefdd.Schema, _efbac)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "Map"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "Map"}:
				_babef := NewCT_Map()
				if _dacc := d.DecodeElement(_babef, &_cbgdd); _dacc != nil {
					return _dacc
				}
				_faefdd.Map = append(_faefdd.Map, _babef)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_MapInfo\u0020\u0025v", _cbgdd.Name)
				if _dffcg := d.Skip(); _dffcg != nil {
					return _dffcg
				}
			}
		case _f.EndElement:
			break _faabe
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_Comments() *CT_Comments {
	_cbcbad := &CT_Comments{}
	_cbcbad.Authors = NewCT_Authors()
	_cbcbad.CommentList = NewCT_CommentList()
	return _cbcbad
}

// ValidateWithPath validates the ExternalLink and its children, prefixing error messages with path
func (_eagcaa *ExternalLink) ValidateWithPath(path string) error {
	if _ffdac := _eagcaa.CT_ExternalLink.ValidateWithPath(path); _ffdac != nil {
		return _ffdac
	}
	return nil
}
func (_dccdc *CT_VolType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dccdc.TypeAttr = ST_VolDepType(1)
	for _, _faaeac := range start.Attr {
		if _faaeac.Name.Local == "type" {
			_dccdc.TypeAttr.UnmarshalXMLAttr(_faaeac)
			continue
		}
	}
_eggde:
	for {
		_afefe, _bgbfe := d.Token()
		if _bgbfe != nil {
			return _bgbfe
		}
		switch _gfedac := _afefe.(type) {
		case _f.StartElement:
			switch _gfedac.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "main"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "main"}:
				_fcdgdf := NewCT_VolMain()
				if _cfgdd := d.DecodeElement(_fcdgdf, &_gfedac); _cfgdd != nil {
					return _cfgdd
				}
				_dccdc.Main = append(_dccdc.Main, _fcdgdf)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_VolType\u0020\u0025v", _gfedac.Name)
				if _dfacg := d.Skip(); _dfacg != nil {
					return _dfacg
				}
			}
		case _f.EndElement:
			break _eggde
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_Filter() *CT_Filter           { _aeebg := &CT_Filter{}; return _aeebg }
func NewCT_PatternFill() *CT_PatternFill { _dggc := &CT_PatternFill{}; return _dggc }

// Validate validates the CT_CustomChartsheetViews and its children
func (_cfcg *CT_CustomChartsheetViews) Validate() error {
	return _cfcg.ValidateWithPath("CT_CustomChartsheetViews")
}
func (_acdda *ST_Pane) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fefceb, _bfcegfa := d.Token()
	if _bfcegfa != nil {
		return _bfcegfa
	}
	if _dgbga, _degdgf := _fefceb.(_f.EndElement); _degdgf && _dgbga.Name == start.Name {
		*_acdda = 1
		return nil
	}
	if _bgfcda, _dfcgd := _fefceb.(_f.CharData); !_dfcgd {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fefceb)
	} else {
		switch string(_bgfcda) {
		case "":
			*_acdda = 0
		case "bottomRight":
			*_acdda = 1
		case "topRight":
			*_acdda = 2
		case "bottomLeft":
			*_acdda = 3
		case "topLeft":
			*_acdda = 4
		}
	}
	_fefceb, _bfcegfa = d.Token()
	if _bfcegfa != nil {
		return _bfcegfa
	}
	if _gcffb, _fbagg := _fefceb.(_f.EndElement); _fbagg && _gcffb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fefceb)
}

// Validate validates the CT_QueryCache and its children
func (_bdddc *CT_QueryCache) Validate() error { return _bdddc.ValidateWithPath("CT_QueryCache") }
func (_aeddbg ST_OleUpdate) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_gfdac := _f.Attr{}
	_gfdac.Name = name
	switch _aeddbg {
	case ST_OleUpdateUnset:
		_gfdac.Value = ""
	case ST_OleUpdateOLEUPDATE_ALWAYS:
		_gfdac.Value = "OLEUPDATE_ALWAYS"
	case ST_OleUpdateOLEUPDATE_ONCALL:
		_gfdac.Value = "OLEUPDATE_ONCALL"
	}
	return _gfdac, nil
}
func (_cfca *CT_Font) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _cfca.Name != nil {
		_dggaea := _f.StartElement{Name: _f.Name{Local: "ma:name"}}
		for _, _bcbac := range _cfca.Name {
			e.EncodeElement(_bcbac, _dggaea)
		}
	}
	if _cfca.Charset != nil {
		_ageaf := _f.StartElement{Name: _f.Name{Local: "ma:charset"}}
		for _, _bgcd := range _cfca.Charset {
			e.EncodeElement(_bgcd, _ageaf)
		}
	}
	if _cfca.Family != nil {
		_ceebg := _f.StartElement{Name: _f.Name{Local: "ma:family"}}
		for _, _bbffb := range _cfca.Family {
			e.EncodeElement(_bbffb, _ceebg)
		}
	}
	if _cfca.B != nil {
		_fecaf := _f.StartElement{Name: _f.Name{Local: "ma:b"}}
		for _, _cbde := range _cfca.B {
			e.EncodeElement(_cbde, _fecaf)
		}
	}
	if _cfca.I != nil {
		_dgfgd := _f.StartElement{Name: _f.Name{Local: "ma:i"}}
		for _, _bbbf := range _cfca.I {
			e.EncodeElement(_bbbf, _dgfgd)
		}
	}
	if _cfca.Strike != nil {
		_eacc := _f.StartElement{Name: _f.Name{Local: "ma:strike"}}
		for _, _afcdf := range _cfca.Strike {
			e.EncodeElement(_afcdf, _eacc)
		}
	}
	if _cfca.Outline != nil {
		_eaea := _f.StartElement{Name: _f.Name{Local: "ma:outline"}}
		for _, _dgdda := range _cfca.Outline {
			e.EncodeElement(_dgdda, _eaea)
		}
	}
	if _cfca.Shadow != nil {
		_bfaeg := _f.StartElement{Name: _f.Name{Local: "ma:shadow"}}
		for _, _bgffa := range _cfca.Shadow {
			e.EncodeElement(_bgffa, _bfaeg)
		}
	}
	if _cfca.Condense != nil {
		_cgfee := _f.StartElement{Name: _f.Name{Local: "ma:condense"}}
		for _, _fbaed := range _cfca.Condense {
			e.EncodeElement(_fbaed, _cgfee)
		}
	}
	if _cfca.Extend != nil {
		_deab := _f.StartElement{Name: _f.Name{Local: "ma:extend"}}
		for _, _bfbbgb := range _cfca.Extend {
			e.EncodeElement(_bfbbgb, _deab)
		}
	}
	if _cfca.Color != nil {
		_ebbeb := _f.StartElement{Name: _f.Name{Local: "ma:color"}}
		for _, _gcgcf := range _cfca.Color {
			e.EncodeElement(_gcgcf, _ebbeb)
		}
	}
	if _cfca.Sz != nil {
		_gafbaf := _f.StartElement{Name: _f.Name{Local: "ma:sz"}}
		for _, _gecgg := range _cfca.Sz {
			e.EncodeElement(_gecgg, _gafbaf)
		}
	}
	if _cfca.U != nil {
		_bdgd := _f.StartElement{Name: _f.Name{Local: "ma:u"}}
		for _, _dcbfb := range _cfca.U {
			e.EncodeElement(_dcbfb, _bdgd)
		}
	}
	if _cfca.VertAlign != nil {
		_bfgf := _f.StartElement{Name: _f.Name{Local: "ma:vertAlign"}}
		for _, _ceaab := range _cfca.VertAlign {
			e.EncodeElement(_ceaab, _bfgf)
		}
	}
	if _cfca.Scheme != nil {
		_deddb := _f.StartElement{Name: _f.Name{Local: "ma:scheme"}}
		for _, _ccdfa := range _cfca.Scheme {
			e.EncodeElement(_ccdfa, _deddb)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_ExternalReference() *CT_ExternalReference { _beee := &CT_ExternalReference{}; return _beee }
func (_bgggca ST_RefMode) ValidateWithPath(path string) error {
	switch _bgggca {
	case 0, 1, 2:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bgggca))
	}
	return nil
}

type CT_PivotAreas struct {

	// Pivot Area Count
	CountAttr *uint32

	// Pivot Area
	PivotArea []*CT_PivotArea
}

func (_fadd *CT_Controls) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_edffe := _f.StartElement{Name: _f.Name{Local: "ma:control"}}
	for _, _eebc := range _fadd.Control {
		e.EncodeElement(_eebc, _edffe)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_eaefb ST_PivotFilterType) String() string {
	switch _eaefb {
	case 0:
		return ""
	case 1:
		return "unknown"
	case 2:
		return "count"
	case 3:
		return "percent"
	case 4:
		return "sum"
	case 5:
		return "captionEqual"
	case 6:
		return "captionNotEqual"
	case 7:
		return "captionBeginsWith"
	case 8:
		return "captionNotBeginsWith"
	case 9:
		return "captionEndsWith"
	case 10:
		return "captionNotEndsWith"
	case 11:
		return "captionContains"
	case 12:
		return "captionNotContains"
	case 13:
		return "captionGreaterThan"
	case 14:
		return "captionGreaterThanOrEqual"
	case 15:
		return "captionLessThan"
	case 16:
		return "captionLessThanOrEqual"
	case 17:
		return "captionBetween"
	case 18:
		return "captionNotBetween"
	case 19:
		return "valueEqual"
	case 20:
		return "valueNotEqual"
	case 21:
		return "valueGreaterThan"
	case 22:
		return "valueGreaterThanOrEqual"
	case 23:
		return "valueLessThan"
	case 24:
		return "valueLessThanOrEqual"
	case 25:
		return "valueBetween"
	case 26:
		return "valueNotBetween"
	case 27:
		return "dateEqual"
	case 28:
		return "dateNotEqual"
	case 29:
		return "dateOlderThan"
	case 30:
		return "dateOlderThanOrEqual"
	case 31:
		return "dateNewerThan"
	case 32:
		return "dateNewerThanOrEqual"
	case 33:
		return "dateBetween"
	case 34:
		return "dateNotBetween"
	case 35:
		return "tomorrow"
	case 36:
		return "today"
	case 37:
		return "yesterday"
	case 38:
		return "nextWeek"
	case 39:
		return "thisWeek"
	case 40:
		return "lastWeek"
	case 41:
		return "nextMonth"
	case 42:
		return "thisMonth"
	case 43:
		return "lastMonth"
	case 44:
		return "nextQuarter"
	case 45:
		return "thisQuarter"
	case 46:
		return "lastQuarter"
	case 47:
		return "nextYear"
	case 48:
		return "thisYear"
	case 49:
		return "lastYear"
	case 50:
		return "yearToDate"
	case 51:
		return "Q1"
	case 52:
		return "Q2"
	case 53:
		return "Q3"
	case 54:
		return "Q4"
	case 55:
		return "M1"
	case 56:
		return "M2"
	case 57:
		return "M3"
	case 58:
		return "M4"
	case 59:
		return "M5"
	case 60:
		return "M6"
	case 61:
		return "M7"
	case 62:
		return "M8"
	case 63:
		return "M9"
	case 64:
		return "M10"
	case 65:
		return "M11"
	case 66:
		return "M12"
	}
	return ""
}
func (_beff *CT_CellSmartTags) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r"}, Value: _bg.Sprintf("\u0025v", _beff.RAttr)})
	e.EncodeToken(start)
	_cebf := _f.StartElement{Name: _f.Name{Local: "ma:cellSmartTag"}}
	for _, _gggg := range _beff.CellSmartTag {
		e.EncodeElement(_gggg, _cebf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cfcgd *CT_WebPublishObjects) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cfcgd.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_cfcgd.CountAttr)})
	}
	e.EncodeToken(start)
	_cdecbf := _f.StartElement{Name: _f.Name{Local: "ma:webPublishObject"}}
	for _, _acdfe := range _cfcgd.WebPublishObject {
		e.EncodeElement(_acdfe, _cdecbf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_SmartTagPr() *CT_SmartTagPr { _gfbgb := &CT_SmartTagPr{}; return _gfbgb }
func NewCT_RevisionFormatting() *CT_RevisionFormatting {
	_cgcaf := &CT_RevisionFormatting{}
	return _cgcaf
}

// Validate validates the CT_PivotTableStyle and its children
func (_adedfa *CT_PivotTableStyle) Validate() error {
	return _adedfa.ValidateWithPath("CT_PivotTableStyle")
}
func (_cefeb ST_CalcMode) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_cefeb.String(), start)
}
func (_gedfg *CT_DdeLink) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ddeService"}, Value: _bg.Sprintf("\u0025v", _gedfg.DdeServiceAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ddeTopic"}, Value: _bg.Sprintf("\u0025v", _gedfg.DdeTopicAttr)})
	e.EncodeToken(start)
	if _gedfg.DdeItems != nil {
		_gedaf := _f.StartElement{Name: _f.Name{Local: "ma:ddeItems"}}
		e.EncodeElement(_gedfg.DdeItems, _gedaf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bddf *CT_Format) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bddf.PivotArea = NewCT_PivotArea()
	for _, _addeg := range start.Attr {
		if _addeg.Name.Local == "action" {
			_bddf.ActionAttr.UnmarshalXMLAttr(_addeg)
			continue
		}
		if _addeg.Name.Local == "dxfId" {
			_fdba, _bgee := _g.ParseUint(_addeg.Value, 10, 32)
			if _bgee != nil {
				return _bgee
			}
			_fbded := uint32(_fdba)
			_bddf.DxfIdAttr = &_fbded
			continue
		}
	}
_edbda:
	for {
		_bdceb, _cecdc := d.Token()
		if _cecdc != nil {
			return _cecdc
		}
		switch _fcggb := _bdceb.(type) {
		case _f.StartElement:
			switch _fcggb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pivotArea"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pivotArea"}:
				if _aacda := d.DecodeElement(_bddf.PivotArea, &_fcggb); _aacda != nil {
					return _aacda
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bddf.ExtLst = NewCT_ExtensionList()
				if _bbbbc := d.DecodeElement(_bddf.ExtLst, &_fcggb); _bbbbc != nil {
					return _bbbbc
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_Format \u0025v", _fcggb.Name)
				if _adfde := d.Skip(); _adfde != nil {
					return _adfde
				}
			}
		case _f.EndElement:
			break _edbda
		case _f.CharData:
		}
	}
	return nil
}
func (_gafeed *ST_SmartTagShow) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gafdg, _gfdcg := d.Token()
	if _gfdcg != nil {
		return _gfdcg
	}
	if _gbagb, _efacdc := _gafdg.(_f.EndElement); _efacdc && _gbagb.Name == start.Name {
		*_gafeed = 1
		return nil
	}
	if _bdeee, _bbgda := _gafdg.(_f.CharData); !_bbgda {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gafdg)
	} else {
		switch string(_bdeee) {
		case "":
			*_gafeed = 0
		case "all":
			*_gafeed = 1
		case "none":
			*_gafeed = 2
		case "noIndicator":
			*_gafeed = 3
		}
	}
	_gafdg, _gfdcg = d.Token()
	if _gfdcg != nil {
		return _gfdcg
	}
	if _cafag, _bbfbb := _gafdg.(_f.EndElement); _bbfbb && _cafag.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gafdg)
}

// Validate validates the CT_WebPublishItem and its children
func (_faagg *CT_WebPublishItem) Validate() error {
	return _faagg.ValidateWithPath("CT_WebPublishItem")
}
func (_dfabc *CT_Top10) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _effcb := range start.Attr {
		if _effcb.Name.Local == "top" {
			_ggdbeg, _dccge := _g.ParseBool(_effcb.Value)
			if _dccge != nil {
				return _dccge
			}
			_dfabc.TopAttr = &_ggdbeg
			continue
		}
		if _effcb.Name.Local == "percent" {
			_badabc, _fbaee := _g.ParseBool(_effcb.Value)
			if _fbaee != nil {
				return _fbaee
			}
			_dfabc.PercentAttr = &_badabc
			continue
		}
		if _effcb.Name.Local == "val" {
			_egeca, _ecfabd := _g.ParseFloat(_effcb.Value, 64)
			if _ecfabd != nil {
				return _ecfabd
			}
			_dfabc.ValAttr = _egeca
			continue
		}
		if _effcb.Name.Local == "filterVal" {
			_ecfce, _eagcbe := _g.ParseFloat(_effcb.Value, 64)
			if _eagcbe != nil {
				return _eagcbe
			}
			_dfabc.FilterValAttr = &_ecfce
			continue
		}
	}
	for {
		_fcfbe, _cbaec := d.Token()
		if _cbaec != nil {
			return _bg.Errorf("parsing\u0020CT_Top10: \u0025s", _cbaec)
		}
		if _eecdda, _ecdbc := _fcfbe.(_f.EndElement); _ecdbc && _eecdda.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_CustomWorkbookViews() *CT_CustomWorkbookViews {
	_eeed := &CT_CustomWorkbookViews{}
	return _eeed
}
func (_gddfb *CT_QueryTableDeletedFields) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gddfb.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_gddfb.CountAttr)})
	}
	e.EncodeToken(start)
	_eaaef := _f.StartElement{Name: _f.Name{Local: "ma:deletedField"}}
	for _, _bbfeed := range _gddfb.DeletedField {
		e.EncodeElement(_bbfeed, _eaaef)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_Colors() *CT_Colors { _efffc := &CT_Colors{}; return _efffc }
func (_eacdf ST_DataValidationType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bgbba := _f.Attr{}
	_bgbba.Name = name
	switch _eacdf {
	case ST_DataValidationTypeUnset:
		_bgbba.Value = ""
	case ST_DataValidationTypeNone:
		_bgbba.Value = "none"
	case ST_DataValidationTypeWhole:
		_bgbba.Value = "whole"
	case ST_DataValidationTypeDecimal:
		_bgbba.Value = "decimal"
	case ST_DataValidationTypeList:
		_bgbba.Value = "list"
	case ST_DataValidationTypeDate:
		_bgbba.Value = "date"
	case ST_DataValidationTypeTime:
		_bgbba.Value = "time"
	case ST_DataValidationTypeTextLength:
		_bgbba.Value = "textLength"
	case ST_DataValidationTypeCustom:
		_bgbba.Value = "custom"
	}
	return _bgbba, nil
}

// ValidateWithPath validates the CT_FileRecoveryPr and its children, prefixing error messages with path
func (_dgbcb *CT_FileRecoveryPr) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_RevisionHeaders and its children, prefixing error messages with path
func (_ddfae *CT_RevisionHeaders) ValidateWithPath(path string) error {
	if !_e.ST_GuidPatternRe.MatchString(_ddfae.GuidAttr) {
		return _bg.Errorf("\u0025s\u002fm\u002eGuidAttr must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_GuidPatternRe, _ddfae.GuidAttr)
	}
	if _ddfae.LastGuidAttr != nil {
		if !_e.ST_GuidPatternRe.MatchString(*_ddfae.LastGuidAttr) {
			return _bg.Errorf("\u0025s\u002fm\u002eLastGuidAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_GuidPatternRe, *_ddfae.LastGuidAttr)
		}
	}
	for _cagba, _gabfa := range _ddfae.Header {
		if _cegfbf := _gabfa.ValidateWithPath(_bg.Sprintf("\u0025s\u002fHeader\u005b\u0025d\u005d", path, _cagba)); _cegfbf != nil {
			return _cegfbf
		}
	}
	return nil
}
func (_ffcff *ST_SortBy) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_ffcff = 0
	case "value":
		*_ffcff = 1
	case "cellColor":
		*_ffcff = 2
	case "fontColor":
		*_ffcff = 3
	case "icon":
		*_ffcff = 4
	}
	return nil
}
func (_aedae ST_MdxSetOrder) ValidateWithPath(path string) error {
	switch _aedae {
	case 0, 1, 2, 3, 4, 5, 6, 7:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aedae))
	}
	return nil
}

const (
	ST_TextHAlignUnset       ST_TextHAlign = 0
	ST_TextHAlignLeft        ST_TextHAlign = 1
	ST_TextHAlignCenter      ST_TextHAlign = 2
	ST_TextHAlignRight       ST_TextHAlign = 3
	ST_TextHAlignJustify     ST_TextHAlign = 4
	ST_TextHAlignDistributed ST_TextHAlign = 5
)

func (_bcbcf ST_PageOrder) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bcbcf.String(), start)
}

// ValidateWithPath validates the CT_MergeCell and its children, prefixing error messages with path
func (_cdbcd *CT_MergeCell) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_Macrosheet and its children
func (_ecedbe *CT_Macrosheet) Validate() error { return _ecedbe.ValidateWithPath("CT_Macrosheet") }

type MapInfo struct{ CT_MapInfo }

// ValidateWithPath validates the CT_GroupMember and its children, prefixing error messages with path
func (_fbddd *CT_GroupMember) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_TableMissing and its children, prefixing error messages with path
func (_dagde *CT_TableMissing) ValidateWithPath(path string) error { return nil }

type CT_MergeCell struct {

	// Reference
	RefAttr string
}

func (_bdfffc *ST_TextHAlign) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ffece, _abcff := d.Token()
	if _abcff != nil {
		return _abcff
	}
	if _efeeg, _ggegf := _ffece.(_f.EndElement); _ggegf && _efeeg.Name == start.Name {
		*_bdfffc = 1
		return nil
	}
	if _agcedf, _bafabg := _ffece.(_f.CharData); !_bafabg {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ffece)
	} else {
		switch string(_agcedf) {
		case "":
			*_bdfffc = 0
		case "left":
			*_bdfffc = 1
		case "center":
			*_bdfffc = 2
		case "right":
			*_bdfffc = 3
		case "justify":
			*_bdfffc = 4
		case "distributed":
			*_bdfffc = 5
		}
	}
	_ffece, _abcff = d.Token()
	if _abcff != nil {
		return _abcff
	}
	if _gbdgg, _adfbd := _ffece.(_f.EndElement); _adfbd && _gbdgg.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ffece)
}
func (_gccacea *ST_VolValueType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fffedc, _ffdea := d.Token()
	if _ffdea != nil {
		return _ffdea
	}
	if _fcafbc, _dcbac := _fffedc.(_f.EndElement); _dcbac && _fcafbc.Name == start.Name {
		*_gccacea = 1
		return nil
	}
	if _eagce, _edddg := _fffedc.(_f.CharData); !_edddg {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fffedc)
	} else {
		switch string(_eagce) {
		case "":
			*_gccacea = 0
		case "b":
			*_gccacea = 1
		case "n":
			*_gccacea = 2
		case "e":
			*_gccacea = 3
		case "s":
			*_gccacea = 4
		}
	}
	_fffedc, _ffdea = d.Token()
	if _ffdea != nil {
		return _ffdea
	}
	if _bebfgd, _dfgcc := _fffedc.(_f.EndElement); _dfgcc && _bebfgd.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fffedc)
}
func NewCT_Connection() *CT_Connection { _faebf := &CT_Connection{}; return _faebf }

type CT_SingleXmlCell struct {

	// Table Id
	IdAttr uint32

	// Reference
	RAttr string

	// Connection ID
	ConnectionIdAttr uint32

	// Cell Properties
	XmlCellPr *CT_XmlCellPr

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_gecgb *Metadata) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:metadata"
	return _gecgb.CT_Metadata.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_SheetFormatPr and its children, prefixing error messages with path
func (_eeeff *CT_SheetFormatPr) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_DataConsolidate and its children
func (_abecd *CT_DataConsolidate) Validate() error {
	return _abecd.ValidateWithPath("CT_DataConsolidate")
}
func NewCT_FilterColumn() *CT_FilterColumn { _gabcc := &CT_FilterColumn{}; return _gabcc }

const (
	ST_HorizontalAlignmentUnset            ST_HorizontalAlignment = 0
	ST_HorizontalAlignmentGeneral          ST_HorizontalAlignment = 1
	ST_HorizontalAlignmentLeft             ST_HorizontalAlignment = 2
	ST_HorizontalAlignmentCenter           ST_HorizontalAlignment = 3
	ST_HorizontalAlignmentRight            ST_HorizontalAlignment = 4
	ST_HorizontalAlignmentFill             ST_HorizontalAlignment = 5
	ST_HorizontalAlignmentJustify          ST_HorizontalAlignment = 6
	ST_HorizontalAlignmentCenterContinuous ST_HorizontalAlignment = 7
	ST_HorizontalAlignmentDistributed      ST_HorizontalAlignment = 8
)

// ValidateWithPath validates the CT_RElt and its children, prefixing error messages with path
func (_debfb *CT_RElt) ValidateWithPath(path string) error {
	if _debfb.RPr != nil {
		if _cccae := _debfb.RPr.ValidateWithPath(path + "\u002fRPr"); _cccae != nil {
			return _cccae
		}
	}
	return nil
}

type CT_RevisionConflict struct {

	// Sheet Id
	SheetIdAttr *uint32
	RIdAttr     *uint32
	UaAttr      *bool
	RaAttr      *bool
}
type ExternalLink struct{ CT_ExternalLink }

func (_ddebd *CT_Dialogsheet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_fedc:
	for {
		_afec, _fccbd := d.Token()
		if _fccbd != nil {
			return _fccbd
		}
		switch _bcff := _afec.(type) {
		case _f.StartElement:
			switch _bcff.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetPr"}:
				_ddebd.SheetPr = NewCT_SheetPr()
				if _bfadg := d.DecodeElement(_ddebd.SheetPr, &_bcff); _bfadg != nil {
					return _bfadg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetViews"}:
				_ddebd.SheetViews = NewCT_SheetViews()
				if _fcbbga := d.DecodeElement(_ddebd.SheetViews, &_bcff); _fcbbga != nil {
					return _fcbbga
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetFormatPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetFormatPr"}:
				_ddebd.SheetFormatPr = NewCT_SheetFormatPr()
				if _fbcac := d.DecodeElement(_ddebd.SheetFormatPr, &_bcff); _fbcac != nil {
					return _fbcac
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetProtection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetProtection"}:
				_ddebd.SheetProtection = NewCT_SheetProtection()
				if _afag := d.DecodeElement(_ddebd.SheetProtection, &_bcff); _afag != nil {
					return _afag
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customSheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customSheetViews"}:
				_ddebd.CustomSheetViews = NewCT_CustomSheetViews()
				if _egbga := d.DecodeElement(_ddebd.CustomSheetViews, &_bcff); _egbga != nil {
					return _egbga
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "printOptions"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "printOptions"}:
				_ddebd.PrintOptions = NewCT_PrintOptions()
				if _fabg := d.DecodeElement(_ddebd.PrintOptions, &_bcff); _fabg != nil {
					return _fabg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageMargins"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageMargins"}:
				_ddebd.PageMargins = NewCT_PageMargins()
				if _bfdfa := d.DecodeElement(_ddebd.PageMargins, &_bcff); _bfdfa != nil {
					return _bfdfa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageSetup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageSetup"}:
				_ddebd.PageSetup = NewCT_PageSetup()
				if _deed := d.DecodeElement(_ddebd.PageSetup, &_bcff); _deed != nil {
					return _deed
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "headerFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "headerFooter"}:
				_ddebd.HeaderFooter = NewCT_HeaderFooter()
				if _dega := d.DecodeElement(_ddebd.HeaderFooter, &_bcff); _dega != nil {
					return _dega
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawing"}:
				_ddebd.Drawing = NewCT_Drawing()
				if _degcgb := d.DecodeElement(_ddebd.Drawing, &_bcff); _degcgb != nil {
					return _degcgb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawing"}:
				_ddebd.LegacyDrawing = NewCT_LegacyDrawing()
				if _ddabf := d.DecodeElement(_ddebd.LegacyDrawing, &_bcff); _ddabf != nil {
					return _ddabf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawingHF"}:
				_ddebd.LegacyDrawingHF = NewCT_LegacyDrawing()
				if _eabg := d.DecodeElement(_ddebd.LegacyDrawingHF, &_bcff); _eabg != nil {
					return _eabg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawingHF"}:
				_ddebd.DrawingHF = NewCT_DrawingHF()
				if _ggef := d.DecodeElement(_ddebd.DrawingHF, &_bcff); _ggef != nil {
					return _ggef
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleObjects"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleObjects"}:
				_ddebd.OleObjects = NewCT_OleObjects()
				if _bdga := d.DecodeElement(_ddebd.OleObjects, &_bcff); _bdga != nil {
					return _bdga
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "controls"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "controls"}:
				_ddebd.Controls = NewCT_Controls()
				if _aefaa := d.DecodeElement(_ddebd.Controls, &_bcff); _aefaa != nil {
					return _aefaa
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ddebd.ExtLst = NewCT_ExtensionList()
				if _ccga := d.DecodeElement(_ddebd.ExtLst, &_bcff); _ccga != nil {
					return _ccga
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Dialogsheet\u0020\u0025v", _bcff.Name)
				if _eege := d.Skip(); _eege != nil {
					return _eege
				}
			}
		case _f.EndElement:
			break _fedc
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_ConditionalFormats and its children
func (_dbdeg *CT_ConditionalFormats) Validate() error {
	return _dbdeg.ValidateWithPath("CT_ConditionalFormats")
}

type CT_FieldsUsage struct {

	// Field Count
	CountAttr *uint32

	// PivotCache Field Id
	FieldUsage []*CT_FieldUsage
}

func NewEG_ExtensionList() *EG_ExtensionList { _dbddfg := &EG_ExtensionList{}; return _dbddfg }
func (_bfac *CT_ColFields) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bfac.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bfac.CountAttr)})
	}
	e.EncodeToken(start)
	_ecfc := _f.StartElement{Name: _f.Name{Local: "ma:field"}}
	for _, _adga := range _bfac.Field {
		e.EncodeElement(_adga, _ecfc)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cgdad *CT_FontName) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", _cgdad.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_Hyperlink() *CT_Hyperlink { _eccadg := &CT_Hyperlink{}; return _eccadg }
func (_cbgce *ST_RefMode) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_edcafa, _fcdbab := d.Token()
	if _fcdbab != nil {
		return _fcdbab
	}
	if _ceecg, _bbdafc := _edcafa.(_f.EndElement); _bbdafc && _ceecg.Name == start.Name {
		*_cbgce = 1
		return nil
	}
	if _cegdc, _cefbec := _edcafa.(_f.CharData); !_cefbec {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _edcafa)
	} else {
		switch string(_cegdc) {
		case "":
			*_cbgce = 0
		case "A1":
			*_cbgce = 1
		case "R1C1":
			*_cbgce = 2
		}
	}
	_edcafa, _fcdbab = d.Token()
	if _fcdbab != nil {
		return _fcdbab
	}
	if _gdddad, _fgecd := _edcafa.(_f.EndElement); _fgecd && _gdddad.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _edcafa)
}

// Validate validates the CT_Dialogsheet and its children
func (_bgcbc *CT_Dialogsheet) Validate() error { return _bgcbc.ValidateWithPath("CT_Dialogsheet") }
func NewCT_MetadataType() *CT_MetadataType     { _geaegg := &CT_MetadataType{}; return _geaegg }
func (_dbbge *CT_Item) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _efecb := range start.Attr {
		if _efecb.Name.Local == "n" {
			_ffde, _fegfd := _efecb.Value, error(nil)
			if _fegfd != nil {
				return _fegfd
			}
			_dbbge.NAttr = &_ffde
			continue
		}
		if _efecb.Name.Local == "t" {
			_dbbge.TAttr.UnmarshalXMLAttr(_efecb)
			continue
		}
		if _efecb.Name.Local == "h" {
			_dbcge, _cfff := _g.ParseBool(_efecb.Value)
			if _cfff != nil {
				return _cfff
			}
			_dbbge.HAttr = &_dbcge
			continue
		}
		if _efecb.Name.Local == "s" {
			_bdbae, _eccb := _g.ParseBool(_efecb.Value)
			if _eccb != nil {
				return _eccb
			}
			_dbbge.SAttr = &_bdbae
			continue
		}
		if _efecb.Name.Local == "sd" {
			_dbbdg, _cedgf := _g.ParseBool(_efecb.Value)
			if _cedgf != nil {
				return _cedgf
			}
			_dbbge.SdAttr = &_dbbdg
			continue
		}
		if _efecb.Name.Local == "f" {
			_ccdef, _ddaf := _g.ParseBool(_efecb.Value)
			if _ddaf != nil {
				return _ddaf
			}
			_dbbge.FAttr = &_ccdef
			continue
		}
		if _efecb.Name.Local == "m" {
			_ceeca, _egcae := _g.ParseBool(_efecb.Value)
			if _egcae != nil {
				return _egcae
			}
			_dbbge.MAttr = &_ceeca
			continue
		}
		if _efecb.Name.Local == "c" {
			_acde, _cgdac := _g.ParseBool(_efecb.Value)
			if _cgdac != nil {
				return _cgdac
			}
			_dbbge.CAttr = &_acde
			continue
		}
		if _efecb.Name.Local == "x" {
			_cfabe, _deeeca := _g.ParseUint(_efecb.Value, 10, 32)
			if _deeeca != nil {
				return _deeeca
			}
			_egfc := uint32(_cfabe)
			_dbbge.XAttr = &_egfc
			continue
		}
		if _efecb.Name.Local == "d" {
			_gbccc, _afefb := _g.ParseBool(_efecb.Value)
			if _afefb != nil {
				return _afefb
			}
			_dbbge.DAttr = &_gbccc
			continue
		}
		if _efecb.Name.Local == "e" {
			_dafad, _bbecb := _g.ParseBool(_efecb.Value)
			if _bbecb != nil {
				return _bbecb
			}
			_dbbge.EAttr = &_dafad
			continue
		}
	}
	for {
		_bgdg, _fabe := d.Token()
		if _fabe != nil {
			return _bg.Errorf("parsing\u0020CT_Item:\u0020\u0025s", _fabe)
		}
		if _faebd, _ebbf := _bgdg.(_f.EndElement); _ebbf && _faebd.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Top10 and its children, prefixing error messages with path
func (_dedec *CT_Top10) ValidateWithPath(path string) error { return nil }
func NewCT_ProtectedRange() *CT_ProtectedRange              { _deeee := &CT_ProtectedRange{}; return _deeee }

// ValidateWithPath validates the CT_Sets and its children, prefixing error messages with path
func (_fbaad *CT_Sets) ValidateWithPath(path string) error {
	for _cggbbc, _cgebe := range _fbaad.Set {
		if _cafdf := _cgebe.ValidateWithPath(_bg.Sprintf("\u0025s\u002fSet\u005b\u0025d\u005d", path, _cggbbc)); _cafdf != nil {
			return _cafdf
		}
	}
	return nil
}

// Validate validates the CT_VolTopicRef and its children
func (_cfabf *CT_VolTopicRef) Validate() error { return _cfabf.ValidateWithPath("CT_VolTopicRef") }
func NewCT_TextField() *CT_TextField           { _eccefg := &CT_TextField{}; return _eccefg }

// ValidateWithPath validates the CT_DdeItems and its children, prefixing error messages with path
func (_dgdee *CT_DdeItems) ValidateWithPath(path string) error {
	for _eacfc, _aefb := range _dgdee.DdeItem {
		if _ccbcg := _aefb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fDdeItem\u005b\u0025d\u005d", path, _eacfc)); _ccbcg != nil {
			return _ccbcg
		}
	}
	return nil
}
func NewCT_SheetIdMap() *CT_SheetIdMap { _ebaeg := &CT_SheetIdMap{}; return _ebaeg }

type ST_VolValueType byte

// Validate validates the CT_TableStyle and its children
func (_aaaecf *CT_TableStyle) Validate() error { return _aaaecf.ValidateWithPath("CT_TableStyle") }

const (
	ST_SourceTypeUnset         ST_SourceType = 0
	ST_SourceTypeWorksheet     ST_SourceType = 1
	ST_SourceTypeExternal      ST_SourceType = 2
	ST_SourceTypeConsolidation ST_SourceType = 3
	ST_SourceTypeScenario      ST_SourceType = 4
)

type CT_RevisionFormatting struct {

	// Sheet Id
	SheetIdAttr uint32

	// Row or Column Formatting Change
	XfDxfAttr *bool

	// Style
	SAttr *bool

	// Sequence Of References
	SqrefAttr ST_Sqref

	// Start index
	StartAttr *uint32

	// Length
	LengthAttr *uint32

	// Formatting
	Dxf    *CT_Dxf
	ExtLst *CT_ExtensionList
}

// Validate validates the CT_ExternalSheetDataSet and its children
func (_aaaec *CT_ExternalSheetDataSet) Validate() error {
	return _aaaec.ValidateWithPath("CT_ExternalSheetDataSet")
}

// Validate validates the CT_ChartsheetProtection and its children
func (_gbaa *CT_ChartsheetProtection) Validate() error {
	return _gbaa.ValidateWithPath("CT_ChartsheetProtection")
}

// Validate validates the CT_Dxf and its children
func (_abdde *CT_Dxf) Validate() error { return _abdde.ValidateWithPath("CT_Dxf") }
func (_cbgad *Comments) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:comments"
	return _cbgad.CT_Comments.MarshalXML(e, start)
}
func (_bdcdbf *ST_VerticalAlignment) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cgddf, _efbcb := d.Token()
	if _efbcb != nil {
		return _efbcb
	}
	if _bddedf, _bdcbd := _cgddf.(_f.EndElement); _bdcbd && _bddedf.Name == start.Name {
		*_bdcdbf = 1
		return nil
	}
	if _bbddd, _eaccde := _cgddf.(_f.CharData); !_eaccde {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cgddf)
	} else {
		switch string(_bbddd) {
		case "":
			*_bdcdbf = 0
		case "top":
			*_bdcdbf = 1
		case "center":
			*_bdcdbf = 2
		case "bottom":
			*_bdcdbf = 3
		case "justify":
			*_bdcdbf = 4
		case "distributed":
			*_bdcdbf = 5
		}
	}
	_cgddf, _efbcb = d.Token()
	if _efbcb != nil {
		return _efbcb
	}
	if _dgcffb, _ebcce := _cgddf.(_f.EndElement); _ebcce && _dgcffb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cgddf)
}

// Validate validates the CT_FontSize and its children
func (_befgdd *CT_FontSize) Validate() error { return _befgdd.ValidateWithPath("CT_FontSize") }

// Validate validates the CT_PivotAreas and its children
func (_ebbba *CT_PivotAreas) Validate() error  { return _ebbba.ValidateWithPath("CT_PivotAreas") }
func NewCT_SheetDimension() *CT_SheetDimension { _ccefg := &CT_SheetDimension{}; return _ccefg }
func (_aaff *CT_Connection) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", _aaff.IdAttr)})
	if _aaff.SourceFileAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sourceFile"}, Value: _bg.Sprintf("\u0025v", *_aaff.SourceFileAttr)})
	}
	if _aaff.OdcFileAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "odcFile"}, Value: _bg.Sprintf("\u0025v", *_aaff.OdcFileAttr)})
	}
	if _aaff.KeepAliveAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "keepAlive"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aaff.KeepAliveAttr))})
	}
	if _aaff.IntervalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "interval"}, Value: _bg.Sprintf("\u0025v", *_aaff.IntervalAttr)})
	}
	if _aaff.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_aaff.NameAttr)})
	}
	if _aaff.DescriptionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "description"}, Value: _bg.Sprintf("\u0025v", *_aaff.DescriptionAttr)})
	}
	if _aaff.TypeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "type"}, Value: _bg.Sprintf("\u0025v", *_aaff.TypeAttr)})
	}
	if _aaff.ReconnectionMethodAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "reconnectionMethod"}, Value: _bg.Sprintf("\u0025v", *_aaff.ReconnectionMethodAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refreshedVersion"}, Value: _bg.Sprintf("\u0025v", _aaff.RefreshedVersionAttr)})
	if _aaff.MinRefreshableVersionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minRefreshableVersion"}, Value: _bg.Sprintf("\u0025v", *_aaff.MinRefreshableVersionAttr)})
	}
	if _aaff.SavePasswordAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "savePassword"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aaff.SavePasswordAttr))})
	}
	if _aaff.NewAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "new"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aaff.NewAttr))})
	}
	if _aaff.DeletedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "deleted"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aaff.DeletedAttr))})
	}
	if _aaff.OnlyUseConnectionFileAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "onlyUseConnectionFile"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aaff.OnlyUseConnectionFileAttr))})
	}
	if _aaff.BackgroundAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "background"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aaff.BackgroundAttr))})
	}
	if _aaff.RefreshOnLoadAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refreshOnLoad"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aaff.RefreshOnLoadAttr))})
	}
	if _aaff.SaveDataAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "saveData"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aaff.SaveDataAttr))})
	}
	if _aaff.CredentialsAttr != ST_CredMethodUnset {
		_ggfg, _dcab := _aaff.CredentialsAttr.MarshalXMLAttr(_f.Name{Local: "credentials"})
		if _dcab != nil {
			return _dcab
		}
		start.Attr = append(start.Attr, _ggfg)
	}
	if _aaff.SingleSignOnIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "singleSignOnId"}, Value: _bg.Sprintf("\u0025v", *_aaff.SingleSignOnIdAttr)})
	}
	e.EncodeToken(start)
	if _aaff.DbPr != nil {
		_cfcc := _f.StartElement{Name: _f.Name{Local: "ma:dbPr"}}
		e.EncodeElement(_aaff.DbPr, _cfcc)
	}
	if _aaff.OlapPr != nil {
		_eagad := _f.StartElement{Name: _f.Name{Local: "ma:olapPr"}}
		e.EncodeElement(_aaff.OlapPr, _eagad)
	}
	if _aaff.WebPr != nil {
		_ebfd := _f.StartElement{Name: _f.Name{Local: "ma:webPr"}}
		e.EncodeElement(_aaff.WebPr, _ebfd)
	}
	if _aaff.TextPr != nil {
		_bbgge := _f.StartElement{Name: _f.Name{Local: "ma:textPr"}}
		e.EncodeElement(_aaff.TextPr, _bbgge)
	}
	if _aaff.Parameters != nil {
		_aacbc := _f.StartElement{Name: _f.Name{Local: "ma:parameters"}}
		e.EncodeElement(_aaff.Parameters, _aacbc)
	}
	if _aaff.ExtLst != nil {
		_acdb := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_aaff.ExtLst, _acdb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_geacda ST_Qualifier) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_ebgcea := _f.Attr{}
	_ebgcea.Name = name
	switch _geacda {
	case ST_QualifierUnset:
		_ebgcea.Value = ""
	case ST_QualifierDoubleQuote:
		_ebgcea.Value = "doubleQuote"
	case ST_QualifierSingleQuote:
		_ebgcea.Value = "singleQuote"
	case ST_QualifierNone:
		_ebgcea.Value = "none"
	}
	return _ebgcea, nil
}
func NewCT_XmlCellPr() *CT_XmlCellPr {
	_gffagb := &CT_XmlCellPr{}
	_gffagb.XmlPr = NewCT_XmlPr()
	return _gffagb
}
func (_edeage *CT_MetadataStrings) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fgcb := range start.Attr {
		if _fgcb.Name.Local == "count" {
			_badfb, _dadeb := _g.ParseUint(_fgcb.Value, 10, 32)
			if _dadeb != nil {
				return _dadeb
			}
			_cgfd := uint32(_badfb)
			_edeage.CountAttr = &_cgfd
			continue
		}
	}
_eafdd:
	for {
		_eggcd, _bccea := d.Token()
		if _bccea != nil {
			return _bccea
		}
		switch _dfbb := _eggcd.(type) {
		case _f.StartElement:
			switch _dfbb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "s"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "s"}:
				_bdfdb := NewCT_XStringElement()
				if _ffage := d.DecodeElement(_bdfdb, &_dfbb); _ffage != nil {
					return _ffage
				}
				_edeage.S = append(_edeage.S, _bdfdb)
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_MetadataStrings\u0020\u0025v", _dfbb.Name)
				if _gfaag := d.Skip(); _gfaag != nil {
					return _gfaag
				}
			}
		case _f.EndElement:
			break _eafdd
		case _f.CharData:
		}
	}
	return nil
}
func (_fcgcge ST_CalcMode) String() string {
	switch _fcgcge {
	case 0:
		return ""
	case 1:
		return "manual"
	case 2:
		return "auto"
	case 3:
		return "autoNoTable"
	}
	return ""
}
func NewPivotTableDefinition() *PivotTableDefinition {
	_gbddfb := &PivotTableDefinition{}
	_gbddfb.CT_pivotTableDefinition = *NewCT_pivotTableDefinition()
	return _gbddfb
}

// Validate validates the CT_ServerFormat and its children
func (_cffdbc *CT_ServerFormat) Validate() error { return _cffdbc.ValidateWithPath("CT_ServerFormat") }
func (_ddddg *ST_FormulaExpression) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bceag, _gefbff := d.Token()
	if _gefbff != nil {
		return _gefbff
	}
	if _eccca, _dcgfa := _bceag.(_f.EndElement); _dcgfa && _eccca.Name == start.Name {
		*_ddddg = 1
		return nil
	}
	if _addgcg, _dcdea := _bceag.(_f.CharData); !_dcdea {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bceag)
	} else {
		switch string(_addgcg) {
		case "":
			*_ddddg = 0
		case "ref":
			*_ddddg = 1
		case "refError":
			*_ddddg = 2
		case "area":
			*_ddddg = 3
		case "areaError":
			*_ddddg = 4
		case "computedArea":
			*_ddddg = 5
		}
	}
	_bceag, _gefbff = d.Token()
	if _gefbff != nil {
		return _gefbff
	}
	if _bagefc, _aadbc := _bceag.(_f.EndElement); _aadbc && _bagefc.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bceag)
}
func (_baca *CT_DateGroupItem) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "year"}, Value: _bg.Sprintf("\u0025v", _baca.YearAttr)})
	if _baca.MonthAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "month"}, Value: _bg.Sprintf("\u0025v", *_baca.MonthAttr)})
	}
	if _baca.DayAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "day"}, Value: _bg.Sprintf("\u0025v", *_baca.DayAttr)})
	}
	if _baca.HourAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hour"}, Value: _bg.Sprintf("\u0025v", *_baca.HourAttr)})
	}
	if _baca.MinuteAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "minute"}, Value: _bg.Sprintf("\u0025v", *_baca.MinuteAttr)})
	}
	if _baca.SecondAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "second"}, Value: _bg.Sprintf("\u0025v", *_baca.SecondAttr)})
	}
	_gbgea, _gfbee := _baca.DateTimeGroupingAttr.MarshalXMLAttr(_f.Name{Local: "dateTimeGrouping"})
	if _gfbee != nil {
		return _gfbee
	}
	start.Attr = append(start.Attr, _gbgea)
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gagge *CT_FileSharing) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gagge.ReadOnlyRecommendedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "readOnlyRecommended"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_gagge.ReadOnlyRecommendedAttr))})
	}
	if _gagge.UserNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "userName"}, Value: _bg.Sprintf("\u0025v", *_gagge.UserNameAttr)})
	}
	if _gagge.ReservationPasswordAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "reservationPassword"}, Value: _bg.Sprintf("\u0025v", *_gagge.ReservationPasswordAttr)})
	}
	if _gagge.AlgorithmNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "algorithmName"}, Value: _bg.Sprintf("\u0025v", *_gagge.AlgorithmNameAttr)})
	}
	if _gagge.HashValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "hashValue"}, Value: _bg.Sprintf("\u0025v", *_gagge.HashValueAttr)})
	}
	if _gagge.SaltValueAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "saltValue"}, Value: _bg.Sprintf("\u0025v", *_gagge.SaltValueAttr)})
	}
	if _gagge.SpinCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "spinCount"}, Value: _bg.Sprintf("\u0025v", *_gagge.SpinCountAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_MdxSet and its children, prefixing error messages with path
func (_bfdbbfg *CT_MdxSet) ValidateWithPath(path string) error {
	if _cfbaf := _bfdbbfg.OAttr.ValidateWithPath(path + "\u002fOAttr"); _cfbaf != nil {
		return _cfbaf
	}
	for _ffecg, _ebedf := range _bfdbbfg.N {
		if _dfgcd := _ebedf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fN\u005b\u0025d\u005d", path, _ffecg)); _dfgcd != nil {
			return _dfgcd
		}
	}
	return nil
}
func NewCT_ColorScale() *CT_ColorScale { _bafg := &CT_ColorScale{}; return _bafg }
func NewCT_TableStyleElement() *CT_TableStyleElement {
	_cbcef := &CT_TableStyleElement{}
	_cbcef.TypeAttr = ST_TableStyleType(1)
	return _cbcef
}
func NewCT_FutureMetadata() *CT_FutureMetadata   { _begdf := &CT_FutureMetadata{}; return _begdf }
func (_acddbd ST_FieldSortType) Validate() error { return _acddbd.ValidateWithPath("") }

// Validate validates the CT_PageMargins and its children
func (_cbbdf *CT_PageMargins) Validate() error { return _cbbdf.ValidateWithPath("CT_PageMargins") }
func (_bbdebe *CT_Sheets) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_fbced:
	for {
		_eeebad, _ddcefd := d.Token()
		if _ddcefd != nil {
			return _ddcefd
		}
		switch _egdbb := _eeebad.(type) {
		case _f.StartElement:
			switch _egdbb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheet"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheet"}:
				_egeeg := NewCT_Sheet()
				if _adfdd := d.DecodeElement(_egeeg, &_egdbb); _adfdd != nil {
					return _adfdd
				}
				_bbdebe.Sheet = append(_bbdebe.Sheet, _egeeg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_Sheets \u0025v", _egdbb.Name)
				if _egacg := d.Skip(); _egacg != nil {
					return _egacg
				}
			}
		case _f.EndElement:
			break _fbced
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Mdx and its children, prefixing error messages with path
func (_bbeb *CT_Mdx) ValidateWithPath(path string) error {
	if _bbeb.FAttr == ST_MdxFunctionTypeUnset {
		return _bg.Errorf("\u0025s/FAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _abbcf := _bbeb.FAttr.ValidateWithPath(path + "\u002fFAttr"); _abbcf != nil {
		return _abbcf
	}
	if _bbeb.T != nil {
		if _gebeda := _bbeb.T.ValidateWithPath(path + "\u002fT"); _gebeda != nil {
			return _gebeda
		}
	}
	if _bbeb.Ms != nil {
		if _eefdc := _bbeb.Ms.ValidateWithPath(path + "\u002fMs"); _eefdc != nil {
			return _eefdc
		}
	}
	if _bbeb.P != nil {
		if _afbcfa := _bbeb.P.ValidateWithPath(path + "\u002fP"); _afbcfa != nil {
			return _afbcfa
		}
	}
	if _bbeb.K != nil {
		if _ecaca := _bbeb.K.ValidateWithPath(path + "\u002fK"); _ecaca != nil {
			return _ecaca
		}
	}
	return nil
}

type CT_TableMissing struct{}

func (_cffga *CT_MdxSet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ns"}, Value: _bg.Sprintf("\u0025v", _cffga.NsAttr)})
	if _cffga.CAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "c"}, Value: _bg.Sprintf("\u0025v", *_cffga.CAttr)})
	}
	if _cffga.OAttr != ST_MdxSetOrderUnset {
		_egfaeg, _bfgge := _cffga.OAttr.MarshalXMLAttr(_f.Name{Local: "o"})
		if _bfgge != nil {
			return _bfgge
		}
		start.Attr = append(start.Attr, _egfaeg)
	}
	e.EncodeToken(start)
	if _cffga.N != nil {
		_fbggd := _f.StartElement{Name: _f.Name{Local: "ma:n"}}
		for _, _effce := range _cffga.N {
			e.EncodeElement(_effce, _fbggd)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_fecad *CT_RevisionDefinedName) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aafcg := range start.Attr {
		if _aafcg.Name.Local == "description" {
			_fagbdc, _baede := _aafcg.Value, error(nil)
			if _baede != nil {
				return _baede
			}
			_fecad.DescriptionAttr = &_fagbdc
			continue
		}
		if _aafcg.Name.Local == "oldDescription" {
			_affba, _edegcd := _aafcg.Value, error(nil)
			if _edegcd != nil {
				return _edegcd
			}
			_fecad.OldDescriptionAttr = &_affba
			continue
		}
		if _aafcg.Name.Local == "customView" {
			_dbafd, _dfdag := _g.ParseBool(_aafcg.Value)
			if _dfdag != nil {
				return _dfdag
			}
			_fecad.CustomViewAttr = &_dbafd
			continue
		}
		if _aafcg.Name.Local == "help" {
			_agbdc, _eeebf := _aafcg.Value, error(nil)
			if _eeebf != nil {
				return _eeebf
			}
			_fecad.HelpAttr = &_agbdc
			continue
		}
		if _aafcg.Name.Local == "function" {
			_dggaee, _ddfaa := _g.ParseBool(_aafcg.Value)
			if _ddfaa != nil {
				return _ddfaa
			}
			_fecad.FunctionAttr = &_dggaee
			continue
		}
		if _aafcg.Name.Local == "oldHelp" {
			_cfcea, _cggag := _aafcg.Value, error(nil)
			if _cggag != nil {
				return _cggag
			}
			_fecad.OldHelpAttr = &_cfcea
			continue
		}
		if _aafcg.Name.Local == "functionGroupId" {
			_addbd, _fffbe := _g.ParseUint(_aafcg.Value, 10, 8)
			if _fffbe != nil {
				return _fffbe
			}
			_bbbbcdd := uint8(_addbd)
			_fecad.FunctionGroupIdAttr = &_bbbbcdd
			continue
		}
		if _aafcg.Name.Local == "statusBar" {
			_bffdc, _bcceb := _aafcg.Value, error(nil)
			if _bcceb != nil {
				return _bcceb
			}
			_fecad.StatusBarAttr = &_bffdc
			continue
		}
		if _aafcg.Name.Local == "shortcutKey" {
			_ebdfd, _cdgee := _g.ParseUint(_aafcg.Value, 10, 8)
			if _cdgee != nil {
				return _cdgee
			}
			_abgab := uint8(_ebdfd)
			_fecad.ShortcutKeyAttr = &_abgab
			continue
		}
		if _aafcg.Name.Local == "oldStatusBar" {
			_cagfd, _adebdd := _aafcg.Value, error(nil)
			if _adebdd != nil {
				return _adebdd
			}
			_fecad.OldStatusBarAttr = &_cagfd
			continue
		}
		if _aafcg.Name.Local == "hidden" {
			_ggccf, _gdbaa := _g.ParseBool(_aafcg.Value)
			if _gdbaa != nil {
				return _gdbaa
			}
			_fecad.HiddenAttr = &_ggccf
			continue
		}
		if _aafcg.Name.Local == "oldComment" {
			_gbcde, _dbdfce := _aafcg.Value, error(nil)
			if _dbdfce != nil {
				return _dbdfce
			}
			_fecad.OldCommentAttr = &_gbcde
			continue
		}
		if _aafcg.Name.Local == "name" {
			_cgbbd, _bgaafba := _aafcg.Value, error(nil)
			if _bgaafba != nil {
				return _bgaafba
			}
			_fecad.NameAttr = _cgbbd
			continue
		}
		if _aafcg.Name.Local == "ra" {
			_ggacg, _cfeda := _g.ParseBool(_aafcg.Value)
			if _cfeda != nil {
				return _cfeda
			}
			_fecad.RaAttr = &_ggacg
			continue
		}
		if _aafcg.Name.Local == "localSheetId" {
			_begbc, _gcdge := _g.ParseUint(_aafcg.Value, 10, 32)
			if _gcdge != nil {
				return _gcdge
			}
			_ebfcb := uint32(_begbc)
			_fecad.LocalSheetIdAttr = &_ebfcb
			continue
		}
		if _aafcg.Name.Local == "comment" {
			_cfgfg, _fffdg := _aafcg.Value, error(nil)
			if _fffdg != nil {
				return _fffdg
			}
			_fecad.CommentAttr = &_cfgfg
			continue
		}
		if _aafcg.Name.Local == "customMenu" {
			_acdbg, _cbbbf := _aafcg.Value, error(nil)
			if _cbbbf != nil {
				return _cbbbf
			}
			_fecad.CustomMenuAttr = &_acdbg
			continue
		}
		if _aafcg.Name.Local == "oldFunction" {
			_gebad, _cggbb := _g.ParseBool(_aafcg.Value)
			if _cggbb != nil {
				return _cggbb
			}
			_fecad.OldFunctionAttr = &_gebad
			continue
		}
		if _aafcg.Name.Local == "ua" {
			_agdgbf, _fbaaba := _g.ParseBool(_aafcg.Value)
			if _fbaaba != nil {
				return _fbaaba
			}
			_fecad.UaAttr = &_agdgbf
			continue
		}
		if _aafcg.Name.Local == "oldShortcutKey" {
			_gecggf, _fcabf := _g.ParseUint(_aafcg.Value, 10, 8)
			if _fcabf != nil {
				return _fcabf
			}
			_deeba := uint8(_gecggf)
			_fecad.OldShortcutKeyAttr = &_deeba
			continue
		}
		if _aafcg.Name.Local == "oldHidden" {
			_cddc, _fgabcc := _g.ParseBool(_aafcg.Value)
			if _fgabcc != nil {
				return _fgabcc
			}
			_fecad.OldHiddenAttr = &_cddc
			continue
		}
		if _aafcg.Name.Local == "oldCustomMenu" {
			_gefff, _aabcfg := _aafcg.Value, error(nil)
			if _aabcfg != nil {
				return _aabcfg
			}
			_fecad.OldCustomMenuAttr = &_gefff
			continue
		}
		if _aafcg.Name.Local == "oldFunctionGroupId" {
			_dcgag, _efccdg := _g.ParseUint(_aafcg.Value, 10, 8)
			if _efccdg != nil {
				return _efccdg
			}
			_baagf := uint8(_dcgag)
			_fecad.OldFunctionGroupIdAttr = &_baagf
			continue
		}
		if _aafcg.Name.Local == "rId" {
			_fdcca, _eafgd := _g.ParseUint(_aafcg.Value, 10, 32)
			if _eafgd != nil {
				return _eafgd
			}
			_adgg := uint32(_fdcca)
			_fecad.RIdAttr = &_adgg
			continue
		}
	}
_faabd:
	for {
		_acgcd, _ggefg := d.Token()
		if _ggefg != nil {
			return _ggefg
		}
		switch _gecab := _acgcd.(type) {
		case _f.StartElement:
			switch _gecab.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "formula"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "formula"}:
				_fecad.Formula = new(string)
				if _aeecaab := d.DecodeElement(_fecad.Formula, &_gecab); _aeecaab != nil {
					return _aeecaab
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oldFormula"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oldFormula"}:
				_fecad.OldFormula = new(string)
				if _beeec := d.DecodeElement(_fecad.OldFormula, &_gecab); _beeec != nil {
					return _beeec
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_fecad.ExtLst = NewCT_ExtensionList()
				if _gaeec := d.DecodeElement(_fecad.ExtLst, &_gecab); _gaeec != nil {
					return _gaeec
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RevisionDefinedName\u0020\u0025v", _gecab.Name)
				if _dfaea := d.Skip(); _dfaea != nil {
					return _dfaea
				}
			}
		case _f.EndElement:
			break _faabd
		case _f.CharData:
		}
	}
	return nil
}
func (_fabce *CT_DataValidation) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fabce.TypeAttr != ST_DataValidationTypeUnset {
		_abfcc, _fgbg := _fabce.TypeAttr.MarshalXMLAttr(_f.Name{Local: "type"})
		if _fgbg != nil {
			return _fgbg
		}
		start.Attr = append(start.Attr, _abfcc)
	}
	if _fabce.ErrorStyleAttr != ST_DataValidationErrorStyleUnset {
		_gdcde, _cggdg := _fabce.ErrorStyleAttr.MarshalXMLAttr(_f.Name{Local: "errorStyle"})
		if _cggdg != nil {
			return _cggdg
		}
		start.Attr = append(start.Attr, _gdcde)
	}
	if _fabce.ImeModeAttr != ST_DataValidationImeModeUnset {
		_cdbc, _adcc := _fabce.ImeModeAttr.MarshalXMLAttr(_f.Name{Local: "imeMode"})
		if _adcc != nil {
			return _adcc
		}
		start.Attr = append(start.Attr, _cdbc)
	}
	if _fabce.OperatorAttr != ST_DataValidationOperatorUnset {
		_dbgbc, _gfgae := _fabce.OperatorAttr.MarshalXMLAttr(_f.Name{Local: "operator"})
		if _gfgae != nil {
			return _gfgae
		}
		start.Attr = append(start.Attr, _dbgbc)
	}
	if _fabce.AllowBlankAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "allowBlank"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fabce.AllowBlankAttr))})
	}
	if _fabce.ShowDropDownAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showDropDown"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fabce.ShowDropDownAttr))})
	}
	if _fabce.ShowInputMessageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showInputMessage"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fabce.ShowInputMessageAttr))})
	}
	if _fabce.ShowErrorMessageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "showErrorMessage"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_fabce.ShowErrorMessageAttr))})
	}
	if _fabce.ErrorTitleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "errorTitle"}, Value: _bg.Sprintf("\u0025v", *_fabce.ErrorTitleAttr)})
	}
	if _fabce.ErrorAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "error"}, Value: _bg.Sprintf("\u0025v", *_fabce.ErrorAttr)})
	}
	if _fabce.PromptTitleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "promptTitle"}, Value: _bg.Sprintf("\u0025v", *_fabce.PromptTitleAttr)})
	}
	if _fabce.PromptAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "prompt"}, Value: _bg.Sprintf("\u0025v", *_fabce.PromptAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sqref"}, Value: _bg.Sprintf("\u0025v", _fabce.SqrefAttr)})
	e.EncodeToken(start)
	if _fabce.Formula1 != nil {
		_abda := _f.StartElement{Name: _f.Name{Local: "ma:formula1"}}
		_cb.AddPreserveSpaceAttr(&_abda, *_fabce.Formula1)
		e.EncodeElement(_fabce.Formula1, _abda)
	}
	if _fabce.Formula2 != nil {
		_gbfeg := _f.StartElement{Name: _f.Name{Local: "ma:formula2"}}
		_cb.AddPreserveSpaceAttr(&_gbfeg, *_fabce.Formula2)
		e.EncodeElement(_fabce.Formula2, _gbfeg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

const (
	ST_PivotAreaTypeUnset    ST_PivotAreaType = 0
	ST_PivotAreaTypeNone     ST_PivotAreaType = 1
	ST_PivotAreaTypeNormal   ST_PivotAreaType = 2
	ST_PivotAreaTypeData     ST_PivotAreaType = 3
	ST_PivotAreaTypeAll      ST_PivotAreaType = 4
	ST_PivotAreaTypeOrigin   ST_PivotAreaType = 5
	ST_PivotAreaTypeButton   ST_PivotAreaType = 6
	ST_PivotAreaTypeTopEnd   ST_PivotAreaType = 7
	ST_PivotAreaTypeTopRight ST_PivotAreaType = 8
)

func (_bdbaa *ExternalLink) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:externalLink"
	return _bdbaa.CT_ExternalLink.MarshalXML(e, start)
}

// Validate validates the Sst and its children
func (_ddagf *Sst) Validate() error { return _ddagf.ValidateWithPath("Sst") }

type CT_SheetData struct {

	// Row
	Row []*CT_Row
}

func NewCT_Metadata() *CT_Metadata { _cfagf := &CT_Metadata{}; return _cfagf }
func (_adfad *CT_Fills) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _adfad.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_adfad.CountAttr)})
	}
	e.EncodeToken(start)
	if _adfad.Fill != nil {
		_ffacf := _f.StartElement{Name: _f.Name{Local: "ma:fill"}}
		for _, _ebef := range _adfad.Fill {
			e.EncodeElement(_ebef, _ffacf)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_RevisionRowColumn() *CT_RevisionRowColumn {
	_edebfg := &CT_RevisionRowColumn{}
	_edebfg.ActionAttr = ST_rwColActionType(1)
	return _edebfg
}
func (_accgbf ST_PhoneticType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bfbgcf := _f.Attr{}
	_bfbgcf.Name = name
	switch _accgbf {
	case ST_PhoneticTypeUnset:
		_bfbgcf.Value = ""
	case ST_PhoneticTypeHalfwidthKatakana:
		_bfbgcf.Value = "halfwidthKatakana"
	case ST_PhoneticTypeFullwidthKatakana:
		_bfbgcf.Value = "fullwidthKatakana"
	case ST_PhoneticTypeHiragana:
		_bfbgcf.Value = "Hiragana"
	case ST_PhoneticTypeNoConversion:
		_bfbgcf.Value = "noConversion"
	}
	return _bfbgcf, nil
}
func NewRevisions() *Revisions {
	_faege := &Revisions{}
	_faege.CT_Revisions = *NewCT_Revisions()
	return _faege
}
func (_afbfcb ST_Objects) ValidateWithPath(path string) error {
	switch _afbfcb {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_afbfcb))
	}
	return nil
}
func (_ecbecd ST_CalcMode) ValidateWithPath(path string) error {
	switch _ecbecd {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ecbecd))
	}
	return nil
}
func (_aegad *CT_DrawingHF) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _aegad.IdAttr)})
	if _aegad.LhoAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lho"}, Value: _bg.Sprintf("\u0025v", *_aegad.LhoAttr)})
	}
	if _aegad.LheAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lhe"}, Value: _bg.Sprintf("\u0025v", *_aegad.LheAttr)})
	}
	if _aegad.LhfAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lhf"}, Value: _bg.Sprintf("\u0025v", *_aegad.LhfAttr)})
	}
	if _aegad.ChoAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cho"}, Value: _bg.Sprintf("\u0025v", *_aegad.ChoAttr)})
	}
	if _aegad.CheAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "che"}, Value: _bg.Sprintf("\u0025v", *_aegad.CheAttr)})
	}
	if _aegad.ChfAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "chf"}, Value: _bg.Sprintf("\u0025v", *_aegad.ChfAttr)})
	}
	if _aegad.RhoAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rho"}, Value: _bg.Sprintf("\u0025v", *_aegad.RhoAttr)})
	}
	if _aegad.RheAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rhe"}, Value: _bg.Sprintf("\u0025v", *_aegad.RheAttr)})
	}
	if _aegad.RhfAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rhf"}, Value: _bg.Sprintf("\u0025v", *_aegad.RhfAttr)})
	}
	if _aegad.LfoAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lfo"}, Value: _bg.Sprintf("\u0025v", *_aegad.LfoAttr)})
	}
	if _aegad.LfeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lfe"}, Value: _bg.Sprintf("\u0025v", *_aegad.LfeAttr)})
	}
	if _aegad.LffAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "lff"}, Value: _bg.Sprintf("\u0025v", *_aegad.LffAttr)})
	}
	if _aegad.CfoAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cfo"}, Value: _bg.Sprintf("\u0025v", *_aegad.CfoAttr)})
	}
	if _aegad.CfeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cfe"}, Value: _bg.Sprintf("\u0025v", *_aegad.CfeAttr)})
	}
	if _aegad.CffAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cff"}, Value: _bg.Sprintf("\u0025v", *_aegad.CffAttr)})
	}
	if _aegad.RfoAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rfo"}, Value: _bg.Sprintf("\u0025v", *_aegad.RfoAttr)})
	}
	if _aegad.RfeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rfe"}, Value: _bg.Sprintf("\u0025v", *_aegad.RfeAttr)})
	}
	if _aegad.RffAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rff"}, Value: _bg.Sprintf("\u0025v", *_aegad.RffAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bccdda *CT_MetadataRecord) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "t"}, Value: _bg.Sprintf("\u0025v", _bccdda.TAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "v"}, Value: _bg.Sprintf("\u0025v", _bccdda.VAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_WebPublishObjects and its children
func (_gfedf *CT_WebPublishObjects) Validate() error {
	return _gfedf.ValidateWithPath("CT_WebPublishObjects")
}

type ST_TextHAlign byte

func (_abga *CT_IgnoredErrors) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_ddcef := _f.StartElement{Name: _f.Name{Local: "ma:ignoredError"}}
	for _, _ddbad := range _abga.IgnoredError {
		e.EncodeElement(_ddbad, _ddcef)
	}
	if _abga.ExtLst != nil {
		_efcge := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_abga.ExtLst, _efcge)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

const (
	ST_ShowDataAsUnset          ST_ShowDataAs = 0
	ST_ShowDataAsNormal         ST_ShowDataAs = 1
	ST_ShowDataAsDifference     ST_ShowDataAs = 2
	ST_ShowDataAsPercent        ST_ShowDataAs = 3
	ST_ShowDataAsPercentDiff    ST_ShowDataAs = 4
	ST_ShowDataAsRunTotal       ST_ShowDataAs = 5
	ST_ShowDataAsPercentOfRow   ST_ShowDataAs = 6
	ST_ShowDataAsPercentOfCol   ST_ShowDataAs = 7
	ST_ShowDataAsPercentOfTotal ST_ShowDataAs = 8
	ST_ShowDataAsIndex          ST_ShowDataAs = 9
)

func NewCT_Index() *CT_Index   { _gbgce := &CT_Index{}; return _gbgce }
func NewCT_Record() *CT_Record { _fgcefd := &CT_Record{}; return _fgcefd }
func (_gdfcgg *Revisions) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gdfcgg.CT_Revisions = *NewCT_Revisions()
_eddfcb:
	for {
		_bdbcgg, _dgcgc := d.Token()
		if _dgcgc != nil {
			return _dgcgc
		}
		switch _fcffad := _bdbcgg.(type) {
		case _f.StartElement:
			switch _fcffad.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rrc"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rrc"}:
				_bebce := NewCT_RevisionRowColumn()
				if _dcdda := d.DecodeElement(_bebce, &_fcffad); _dcdda != nil {
					return _dcdda
				}
				_gdfcgg.Rrc = append(_gdfcgg.Rrc, _bebce)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rm"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rm"}:
				_ggdccb := NewCT_RevisionMove()
				if _fdaccbe := d.DecodeElement(_ggdccb, &_fcffad); _fdaccbe != nil {
					return _fdaccbe
				}
				_gdfcgg.Rm = append(_gdfcgg.Rm, _ggdccb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rcv"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rcv"}:
				_ccbbbf := NewCT_RevisionCustomView()
				if _cabfc := d.DecodeElement(_ccbbbf, &_fcffad); _cabfc != nil {
					return _cabfc
				}
				_gdfcgg.Rcv = append(_gdfcgg.Rcv, _ccbbbf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rsnm"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rsnm"}:
				_cbcdc := NewCT_RevisionSheetRename()
				if _ebfbg := d.DecodeElement(_cbcdc, &_fcffad); _ebfbg != nil {
					return _ebfbg
				}
				_gdfcgg.Rsnm = append(_gdfcgg.Rsnm, _cbcdc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ris"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ris"}:
				_acfegd := NewCT_RevisionInsertSheet()
				if _gaeea := d.DecodeElement(_acfegd, &_fcffad); _gaeea != nil {
					return _gaeea
				}
				_gdfcgg.Ris = append(_gdfcgg.Ris, _acfegd)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rcc"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rcc"}:
				_gadcd := NewCT_RevisionCellChange()
				if _accgc := d.DecodeElement(_gadcd, &_fcffad); _accgc != nil {
					return _accgc
				}
				_gdfcgg.Rcc = append(_gdfcgg.Rcc, _gadcd)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rfmt"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rfmt"}:
				_gccbf := NewCT_RevisionFormatting()
				if _dcegf := d.DecodeElement(_gccbf, &_fcffad); _dcegf != nil {
					return _dcegf
				}
				_gdfcgg.Rfmt = append(_gdfcgg.Rfmt, _gccbf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "raf"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "raf"}:
				_bcdbg := NewCT_RevisionAutoFormatting()
				if _ccgf := d.DecodeElement(_bcdbg, &_fcffad); _ccgf != nil {
					return _ccgf
				}
				_gdfcgg.Raf = append(_gdfcgg.Raf, _bcdbg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rdn"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rdn"}:
				_aebag := NewCT_RevisionDefinedName()
				if _bceec := d.DecodeElement(_aebag, &_fcffad); _bceec != nil {
					return _bceec
				}
				_gdfcgg.Rdn = append(_gdfcgg.Rdn, _aebag)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rcmt"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rcmt"}:
				_edgff := NewCT_RevisionComment()
				if _geebb := d.DecodeElement(_edgff, &_fcffad); _geebb != nil {
					return _geebb
				}
				_gdfcgg.Rcmt = append(_gdfcgg.Rcmt, _edgff)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rqt"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rqt"}:
				_gfgeeb := NewCT_RevisionQueryTableField()
				if _dadgca := d.DecodeElement(_gfgeeb, &_fcffad); _dadgca != nil {
					return _dadgca
				}
				_gdfcgg.Rqt = append(_gdfcgg.Rqt, _gfgeeb)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rcft"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rcft"}:
				_badceg := NewCT_RevisionConflict()
				if _dabbcb := d.DecodeElement(_badceg, &_fcffad); _dabbcb != nil {
					return _dabbcb
				}
				_gdfcgg.Rcft = append(_gdfcgg.Rcft, _badceg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on Revisions \u0025v", _fcffad.Name)
				if _bebccb := d.Skip(); _bebccb != nil {
					return _bebccb
				}
			}
		case _f.EndElement:
			break _eddfcb
		case _f.CharData:
		}
	}
	return nil
}
func (_gegag *CT_OleObjects) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_aedgg := _f.StartElement{Name: _f.Name{Local: "ma:oleObject"}}
	for _, _aebfc := range _gegag.OleObject {
		e.EncodeElement(_aebfc, _aedgg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cfagd ST_HorizontalAlignment) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bacbag := _f.Attr{}
	_bacbag.Name = name
	switch _cfagd {
	case ST_HorizontalAlignmentUnset:
		_bacbag.Value = ""
	case ST_HorizontalAlignmentGeneral:
		_bacbag.Value = "general"
	case ST_HorizontalAlignmentLeft:
		_bacbag.Value = "left"
	case ST_HorizontalAlignmentCenter:
		_bacbag.Value = "center"
	case ST_HorizontalAlignmentRight:
		_bacbag.Value = "right"
	case ST_HorizontalAlignmentFill:
		_bacbag.Value = "fill"
	case ST_HorizontalAlignmentJustify:
		_bacbag.Value = "justify"
	case ST_HorizontalAlignmentCenterContinuous:
		_bacbag.Value = "centerContinuous"
	case ST_HorizontalAlignmentDistributed:
		_bacbag.Value = "distributed"
	}
	return _bacbag, nil
}
func (_cgeac *VolTypes) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cgeac.CT_VolTypes = *NewCT_VolTypes()
_egecec:
	for {
		_ebabcc, _dbagd := d.Token()
		if _dbagd != nil {
			return _dbagd
		}
		switch _bgggc := _ebabcc.(type) {
		case _f.StartElement:
			switch _bgggc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "volType"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "volType"}:
				_aafab := NewCT_VolType()
				if _dbfaea := d.DecodeElement(_aafab, &_bgggc); _dbfaea != nil {
					return _dbfaea
				}
				_cgeac.VolType = append(_cgeac.VolType, _aafab)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_cgeac.ExtLst = NewCT_ExtensionList()
				if _gadbg := d.DecodeElement(_cgeac.ExtLst, &_bgggc); _gadbg != nil {
					return _gadbg
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020VolTypes\u0020\u0025v", _bgggc.Name)
				if _fcfgg := d.Skip(); _fcfgg != nil {
					return _fcfgg
				}
			}
		case _f.EndElement:
			break _egecec
		case _f.CharData:
		}
	}
	return nil
}
func (_gbeff ST_TimePeriod) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_gaced := _f.Attr{}
	_gaced.Name = name
	switch _gbeff {
	case ST_TimePeriodUnset:
		_gaced.Value = ""
	case ST_TimePeriodToday:
		_gaced.Value = "today"
	case ST_TimePeriodYesterday:
		_gaced.Value = "yesterday"
	case ST_TimePeriodTomorrow:
		_gaced.Value = "tomorrow"
	case ST_TimePeriodLast7Days:
		_gaced.Value = "last7Days"
	case ST_TimePeriodThisMonth:
		_gaced.Value = "thisMonth"
	case ST_TimePeriodLastMonth:
		_gaced.Value = "lastMonth"
	case ST_TimePeriodNextMonth:
		_gaced.Value = "nextMonth"
	case ST_TimePeriodThisWeek:
		_gaced.Value = "thisWeek"
	case ST_TimePeriodLastWeek:
		_gaced.Value = "lastWeek"
	case ST_TimePeriodNextWeek:
		_gaced.Value = "nextWeek"
	}
	return _gaced, nil
}
func NewCT_NumFmt() *CT_NumFmt { _fdegg := &CT_NumFmt{}; return _fdegg }

// Validate validates the CT_Parameters and its children
func (_dgbfb *CT_Parameters) Validate() error { return _dgbfb.ValidateWithPath("CT_Parameters") }

// ValidateWithPath validates the CT_DeletedField and its children, prefixing error messages with path
func (_dfeaa *CT_DeletedField) ValidateWithPath(path string) error { return nil }
func NewCT_SheetProtection() *CT_SheetProtection                   { _eegee := &CT_SheetProtection{}; return _eegee }

// Validate validates the CT_CalcPr and its children
func (_faac *CT_CalcPr) Validate() error { return _faac.ValidateWithPath("CT_CalcPr") }

// ValidateWithPath validates the CT_MetadataBlocks and its children, prefixing error messages with path
func (_dgagc *CT_MetadataBlocks) ValidateWithPath(path string) error {
	for _ccbce, _caaea := range _dgagc.Bk {
		if _aaaa := _caaea.ValidateWithPath(_bg.Sprintf("\u0025s\u002fBk\u005b\u0025d]", path, _ccbce)); _aaaa != nil {
			return _aaaa
		}
	}
	return nil
}

// Validate validates the CT_PivotFilters and its children
func (_cdgaaa *CT_PivotFilters) Validate() error { return _cdgaaa.ValidateWithPath("CT_PivotFilters") }
func (_bbcga *ST_MdxFunctionType) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gdfced, _cgadgc := d.Token()
	if _cgadgc != nil {
		return _cgadgc
	}
	if _eedcge, _eefdce := _gdfced.(_f.EndElement); _eefdce && _eedcge.Name == start.Name {
		*_bbcga = 1
		return nil
	}
	if _gbdaa, _dbaga := _gdfced.(_f.CharData); !_dbaga {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gdfced)
	} else {
		switch string(_gbdaa) {
		case "":
			*_bbcga = 0
		case "m":
			*_bbcga = 1
		case "v":
			*_bbcga = 2
		case "s":
			*_bbcga = 3
		case "c":
			*_bbcga = 4
		case "r":
			*_bbcga = 5
		case "p":
			*_bbcga = 6
		case "k":
			*_bbcga = 7
		}
	}
	_gdfced, _cgadgc = d.Token()
	if _cgadgc != nil {
		return _cgadgc
	}
	if _adca, _ccgadf := _gdfced.(_f.EndElement); _ccgadf && _adca.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gdfced)
}
func (_aggge *CT_SmartTags) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_dabfa := _f.StartElement{Name: _f.Name{Local: "ma:cellSmartTags"}}
	for _, _cbefc := range _aggge.CellSmartTags {
		e.EncodeElement(_cbefc, _dabfa)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bgadba *CT_Rst) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _bgadba.T != nil {
		_cgbfg := _f.StartElement{Name: _f.Name{Local: "ma:t"}}
		_cb.AddPreserveSpaceAttr(&_cgbfg, *_bgadba.T)
		e.EncodeElement(_bgadba.T, _cgbfg)
	}
	if _bgadba.R != nil {
		_dedee := _f.StartElement{Name: _f.Name{Local: "ma:r"}}
		for _, _gfgdbc := range _bgadba.R {
			e.EncodeElement(_gfgdbc, _dedee)
		}
	}
	if _bgadba.RPh != nil {
		_bgccb := _f.StartElement{Name: _f.Name{Local: "ma:rPh"}}
		for _, _ecadgc := range _bgadba.RPh {
			e.EncodeElement(_ecadgc, _bgccb)
		}
	}
	if _bgadba.PhoneticPr != nil {
		_gcbbf := _f.StartElement{Name: _f.Name{Local: "ma:phoneticPr"}}
		e.EncodeElement(_bgadba.PhoneticPr, _gcbbf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gaebg ST_ShowDataAs) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_deafd := _f.Attr{}
	_deafd.Name = name
	switch _gaebg {
	case ST_ShowDataAsUnset:
		_deafd.Value = ""
	case ST_ShowDataAsNormal:
		_deafd.Value = "normal"
	case ST_ShowDataAsDifference:
		_deafd.Value = "difference"
	case ST_ShowDataAsPercent:
		_deafd.Value = "percent"
	case ST_ShowDataAsPercentDiff:
		_deafd.Value = "percentDiff"
	case ST_ShowDataAsRunTotal:
		_deafd.Value = "runTotal"
	case ST_ShowDataAsPercentOfRow:
		_deafd.Value = "percentOfRow"
	case ST_ShowDataAsPercentOfCol:
		_deafd.Value = "percentOfCol"
	case ST_ShowDataAsPercentOfTotal:
		_deafd.Value = "percentOfTotal"
	case ST_ShowDataAsIndex:
		_deafd.Value = "index"
	}
	return _deafd, nil
}
func (_agdacb *CT_RevisionMove) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ebdaf := range start.Attr {
		if _ebdaf.Name.Local == "sheetId" {
			_cfccd, _adgae := _g.ParseUint(_ebdaf.Value, 10, 32)
			if _adgae != nil {
				return _adgae
			}
			_agdacb.SheetIdAttr = uint32(_cfccd)
			continue
		}
		if _ebdaf.Name.Local == "source" {
			_fcdfb, _bfdef := _ebdaf.Value, error(nil)
			if _bfdef != nil {
				return _bfdef
			}
			_agdacb.SourceAttr = _fcdfb
			continue
		}
		if _ebdaf.Name.Local == "destination" {
			_fgdcd, _ggdgc := _ebdaf.Value, error(nil)
			if _ggdgc != nil {
				return _ggdgc
			}
			_agdacb.DestinationAttr = _fgdcd
			continue
		}
		if _ebdaf.Name.Local == "sourceSheetId" {
			_fdeda, _bceac := _g.ParseUint(_ebdaf.Value, 10, 32)
			if _bceac != nil {
				return _bceac
			}
			_edbfa := uint32(_fdeda)
			_agdacb.SourceSheetIdAttr = &_edbfa
			continue
		}
		if _ebdaf.Name.Local == "rId" {
			_cgdgg, _gafbc := _g.ParseUint(_ebdaf.Value, 10, 32)
			if _gafbc != nil {
				return _gafbc
			}
			_fcgb := uint32(_cgdgg)
			_agdacb.RIdAttr = &_fcgb
			continue
		}
		if _ebdaf.Name.Local == "ua" {
			_bbddg, _cbccb := _g.ParseBool(_ebdaf.Value)
			if _cbccb != nil {
				return _cbccb
			}
			_agdacb.UaAttr = &_bbddg
			continue
		}
		if _ebdaf.Name.Local == "ra" {
			_abefgf, _eafff := _g.ParseBool(_ebdaf.Value)
			if _eafff != nil {
				return _eafff
			}
			_agdacb.RaAttr = &_abefgf
			continue
		}
	}
_fdddf:
	for {
		_ggee, _fabgc := d.Token()
		if _fabgc != nil {
			return _fabgc
		}
		switch _cfefe := _ggee.(type) {
		case _f.StartElement:
			switch _cfefe.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "undo"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "undo"}:
				_fgfaab := NewCT_UndoInfo()
				if _bfdaf := d.DecodeElement(_fgfaab, &_cfefe); _bfdaf != nil {
					return _bfdaf
				}
				_agdacb.Undo = append(_agdacb.Undo, _fgfaab)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rcc"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rcc"}:
				_eedef := NewCT_RevisionCellChange()
				if _ddaadf := d.DecodeElement(_eedef, &_cfefe); _ddaadf != nil {
					return _ddaadf
				}
				_agdacb.Rcc = append(_agdacb.Rcc, _eedef)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rfmt"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rfmt"}:
				_fcfcb := NewCT_RevisionFormatting()
				if _edaea := d.DecodeElement(_fcfcb, &_cfefe); _edaea != nil {
					return _edaea
				}
				_agdacb.Rfmt = append(_agdacb.Rfmt, _fcfcb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RevisionMove\u0020\u0025v", _cfefe.Name)
				if _bdegf := d.Skip(); _bdegf != nil {
					return _bdegf
				}
			}
		case _f.EndElement:
			break _fdddf
		case _f.CharData:
		}
	}
	return nil
}

type CT_CacheSource struct {

	// Cache Type
	TypeAttr ST_SourceType

	// Connection Index
	ConnectionIdAttr *uint32

	// Worksheet PivotCache Source
	WorksheetSource *CT_WorksheetSource

	// Consolidation Source
	Consolidation *CT_Consolidation

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

// Validate validates the CT_Break and its children
func (_bbf *CT_Break) Validate() error { return _bbf.ValidateWithPath("CT_Break") }
func (_ggefa ST_PrintError) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_eddbge := _f.Attr{}
	_eddbge.Name = name
	switch _ggefa {
	case ST_PrintErrorUnset:
		_eddbge.Value = ""
	case ST_PrintErrorDisplayed:
		_eddbge.Value = "displayed"
	case ST_PrintErrorBlank:
		_eddbge.Value = "blank"
	case ST_PrintErrorDash:
		_eddbge.Value = "dash"
	case ST_PrintErrorNA:
		_eddbge.Value = "NA"
	}
	return _eddbge, nil
}

// Validate validates the CT_TextField and its children
func (_gefbg *CT_TextField) Validate() error { return _gefbg.ValidateWithPath("CT_TextField") }
func NewCT_QueryTableDeletedFields() *CT_QueryTableDeletedFields {
	_cbeag := &CT_QueryTableDeletedFields{}
	return _cbeag
}
func NewCT_Comment() *CT_Comment { _bbfe := &CT_Comment{}; _bbfe.Text = NewCT_Rst(); return _bbfe }

// Validate validates the CT_SingleXmlCells and its children
func (_dgace *CT_SingleXmlCells) Validate() error {
	return _dgace.ValidateWithPath("CT_SingleXmlCells")
}

const (
	ST_UpdateLinksUnset   ST_UpdateLinks = 0
	ST_UpdateLinksUserSet ST_UpdateLinks = 1
	ST_UpdateLinksNever   ST_UpdateLinks = 2
	ST_UpdateLinksAlways  ST_UpdateLinks = 3
)

func (_ffceb *CT_PatternFill) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ffceb.PatternTypeAttr != ST_PatternTypeUnset {
		_dbdad, _badcc := _ffceb.PatternTypeAttr.MarshalXMLAttr(_f.Name{Local: "patternType"})
		if _badcc != nil {
			return _badcc
		}
		start.Attr = append(start.Attr, _dbdad)
	}
	e.EncodeToken(start)
	if _ffceb.FgColor != nil {
		_ggaggf := _f.StartElement{Name: _f.Name{Local: "ma:fgColor"}}
		e.EncodeElement(_ffceb.FgColor, _ggaggf)
	}
	if _ffceb.BgColor != nil {
		_baecfa := _f.StartElement{Name: _f.Name{Local: "ma:bgColor"}}
		e.EncodeElement(_ffceb.BgColor, _baecfa)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_dbfgde ST_Type) Validate() error { return _dbfgde.ValidateWithPath("") }
func (_aadcd *CT_OlapPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aadcd.LocalAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "local"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aadcd.LocalAttr))})
	}
	if _aadcd.LocalConnectionAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "localConnection"}, Value: _bg.Sprintf("\u0025v", *_aadcd.LocalConnectionAttr)})
	}
	if _aadcd.LocalRefreshAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "localRefresh"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aadcd.LocalRefreshAttr))})
	}
	if _aadcd.SendLocaleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sendLocale"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aadcd.SendLocaleAttr))})
	}
	if _aadcd.RowDrillCountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rowDrillCount"}, Value: _bg.Sprintf("\u0025v", *_aadcd.RowDrillCountAttr)})
	}
	if _aadcd.ServerFillAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "serverFill"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aadcd.ServerFillAttr))})
	}
	if _aadcd.ServerNumberFormatAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "serverNumberFormat"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aadcd.ServerNumberFormatAttr))})
	}
	if _aadcd.ServerFontAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "serverFont"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aadcd.ServerFontAttr))})
	}
	if _aadcd.ServerFontColorAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "serverFontColor"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aadcd.ServerFontColorAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TableMissing and its children
func (_dacad *CT_TableMissing) Validate() error { return _dacad.ValidateWithPath("CT_TableMissing") }
func (_cged *CT_DdeValue) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _efega := range start.Attr {
		if _efega.Name.Local == "t" {
			_cged.TAttr.UnmarshalXMLAttr(_efega)
			continue
		}
	}
_eaae:
	for {
		_badc, _bdac := d.Token()
		if _bdac != nil {
			return _bdac
		}
		switch _bfbca := _badc.(type) {
		case _f.StartElement:
			switch _bfbca.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "val"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "val"}:
				if _cfad := d.DecodeElement(&_cged.Val, &_bfbca); _cfad != nil {
					return _cfad
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DdeValue\u0020\u0025v", _bfbca.Name)
				if _gcdfg := d.Skip(); _gcdfg != nil {
					return _gcdfg
				}
			}
		case _f.EndElement:
			break _eaae
		case _f.CharData:
		}
	}
	return nil
}
func (_babcd *Worksheet) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_babcd.CT_Worksheet = *NewCT_Worksheet()
_ffffa:
	for {
		_eccceg, _ebgee := d.Token()
		if _ebgee != nil {
			return _ebgee
		}
		switch _dedbaf := _eccceg.(type) {
		case _f.StartElement:
			switch _dedbaf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetPr"}:
				_babcd.SheetPr = NewCT_SheetPr()
				if _dedfga := d.DecodeElement(_babcd.SheetPr, &_dedbaf); _dedfga != nil {
					return _dedfga
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dimension"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dimension"}:
				_babcd.Dimension = NewCT_SheetDimension()
				if _cbccc := d.DecodeElement(_babcd.Dimension, &_dedbaf); _cbccc != nil {
					return _cbccc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetViews"}:
				_babcd.SheetViews = NewCT_SheetViews()
				if _fadgg := d.DecodeElement(_babcd.SheetViews, &_dedbaf); _fadgg != nil {
					return _fadgg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetFormatPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetFormatPr"}:
				_babcd.SheetFormatPr = NewCT_SheetFormatPr()
				if _egedd := d.DecodeElement(_babcd.SheetFormatPr, &_dedbaf); _egedd != nil {
					return _egedd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cols"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cols"}:
				_egdabea := NewCT_Cols()
				if _gdbae := d.DecodeElement(_egdabea, &_dedbaf); _gdbae != nil {
					return _gdbae
				}
				_babcd.Cols = append(_babcd.Cols, _egdabea)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetData"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetData"}:
				if _ddbcfb := d.DecodeElement(_babcd.SheetData, &_dedbaf); _ddbcfb != nil {
					return _ddbcfb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetCalcPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetCalcPr"}:
				_babcd.SheetCalcPr = NewCT_SheetCalcPr()
				if _aadeb := d.DecodeElement(_babcd.SheetCalcPr, &_dedbaf); _aadeb != nil {
					return _aadeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sheetProtection"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sheetProtection"}:
				_babcd.SheetProtection = NewCT_SheetProtection()
				if _gfffbe := d.DecodeElement(_babcd.SheetProtection, &_dedbaf); _gfffbe != nil {
					return _gfffbe
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "protectedRanges"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "protectedRanges"}:
				_babcd.ProtectedRanges = NewCT_ProtectedRanges()
				if _dfcegc := d.DecodeElement(_babcd.ProtectedRanges, &_dedbaf); _dfcegc != nil {
					return _dfcegc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "scenarios"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "scenarios"}:
				_babcd.Scenarios = NewCT_Scenarios()
				if _bffca := d.DecodeElement(_babcd.Scenarios, &_dedbaf); _bffca != nil {
					return _bffca
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "autoFilter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "autoFilter"}:
				_babcd.AutoFilter = NewCT_AutoFilter()
				if _eedfb := d.DecodeElement(_babcd.AutoFilter, &_dedbaf); _eedfb != nil {
					return _eedfb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sortState"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sortState"}:
				_babcd.SortState = NewCT_SortState()
				if _ddgdb := d.DecodeElement(_babcd.SortState, &_dedbaf); _ddgdb != nil {
					return _ddgdb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataConsolidate"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataConsolidate"}:
				_babcd.DataConsolidate = NewCT_DataConsolidate()
				if _fgafg := d.DecodeElement(_babcd.DataConsolidate, &_dedbaf); _fgafg != nil {
					return _fgafg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customSheetViews"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customSheetViews"}:
				_babcd.CustomSheetViews = NewCT_CustomSheetViews()
				if _fcadf := d.DecodeElement(_babcd.CustomSheetViews, &_dedbaf); _fcadf != nil {
					return _fcadf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "mergeCells"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "mergeCells"}:
				_babcd.MergeCells = NewCT_MergeCells()
				if _eedcf := d.DecodeElement(_babcd.MergeCells, &_dedbaf); _eedcf != nil {
					return _eedcf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "phoneticPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "phoneticPr"}:
				_babcd.PhoneticPr = NewCT_PhoneticPr()
				if _ccbab := d.DecodeElement(_babcd.PhoneticPr, &_dedbaf); _ccbab != nil {
					return _ccbab
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "conditionalFormatting"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "conditionalFormatting"}:
				_gdgcg := NewCT_ConditionalFormatting()
				if _fcaecf := d.DecodeElement(_gdgcg, &_dedbaf); _fcaecf != nil {
					return _fcaecf
				}
				_babcd.ConditionalFormatting = append(_babcd.ConditionalFormatting, _gdgcg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataValidations"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataValidations"}:
				_babcd.DataValidations = NewCT_DataValidations()
				if _agcgc := d.DecodeElement(_babcd.DataValidations, &_dedbaf); _agcgc != nil {
					return _agcgc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "hyperlinks"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "hyperlinks"}:
				_babcd.Hyperlinks = NewCT_Hyperlinks()
				if _bffgf := d.DecodeElement(_babcd.Hyperlinks, &_dedbaf); _bffgf != nil {
					return _bffgf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "printOptions"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "printOptions"}:
				_babcd.PrintOptions = NewCT_PrintOptions()
				if _dccdf := d.DecodeElement(_babcd.PrintOptions, &_dedbaf); _dccdf != nil {
					return _dccdf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageMargins"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageMargins"}:
				_babcd.PageMargins = NewCT_PageMargins()
				if _cafdgd := d.DecodeElement(_babcd.PageMargins, &_dedbaf); _cafdgd != nil {
					return _cafdgd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageSetup"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageSetup"}:
				_babcd.PageSetup = NewCT_PageSetup()
				if _eecea := d.DecodeElement(_babcd.PageSetup, &_dedbaf); _eecea != nil {
					return _eecea
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "headerFooter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "headerFooter"}:
				_babcd.HeaderFooter = NewCT_HeaderFooter()
				if _dcdfbd := d.DecodeElement(_babcd.HeaderFooter, &_dedbaf); _dcdfbd != nil {
					return _dcdfbd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "rowBreaks"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "rowBreaks"}:
				_babcd.RowBreaks = NewCT_PageBreak()
				if _cdeadbc := d.DecodeElement(_babcd.RowBreaks, &_dedbaf); _cdeadbc != nil {
					return _cdeadbc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "colBreaks"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "colBreaks"}:
				_babcd.ColBreaks = NewCT_PageBreak()
				if _eaefeg := d.DecodeElement(_babcd.ColBreaks, &_dedbaf); _eaefeg != nil {
					return _eaefeg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "customProperties"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "customProperties"}:
				_babcd.CustomProperties = NewCT_CustomProperties()
				if _befeb := d.DecodeElement(_babcd.CustomProperties, &_dedbaf); _befeb != nil {
					return _befeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellWatches"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellWatches"}:
				_babcd.CellWatches = NewCT_CellWatches()
				if _cfaea := d.DecodeElement(_babcd.CellWatches, &_dedbaf); _cfaea != nil {
					return _cfaea
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "ignoredErrors"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "ignoredErrors"}:
				_babcd.IgnoredErrors = NewCT_IgnoredErrors()
				if _fdcecc := d.DecodeElement(_babcd.IgnoredErrors, &_dedbaf); _fdcecc != nil {
					return _fdcecc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "smartTags"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "smartTags"}:
				_babcd.SmartTags = NewCT_SmartTags()
				if _dabba := d.DecodeElement(_babcd.SmartTags, &_dedbaf); _dabba != nil {
					return _dabba
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawing"}:
				_babcd.Drawing = NewCT_Drawing()
				if _aacbd := d.DecodeElement(_babcd.Drawing, &_dedbaf); _aacbd != nil {
					return _aacbd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawing"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawing"}:
				_babcd.LegacyDrawing = NewCT_LegacyDrawing()
				if _eeccf := d.DecodeElement(_babcd.LegacyDrawing, &_dedbaf); _eeccf != nil {
					return _eeccf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "legacyDrawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "legacyDrawingHF"}:
				_babcd.LegacyDrawingHF = NewCT_LegacyDrawing()
				if _accfbc := d.DecodeElement(_babcd.LegacyDrawingHF, &_dedbaf); _accfbc != nil {
					return _accfbc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "drawingHF"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "drawingHF"}:
				_babcd.DrawingHF = NewCT_DrawingHF()
				if _ccdeg := d.DecodeElement(_babcd.DrawingHF, &_dedbaf); _ccdeg != nil {
					return _ccdeg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "picture"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "picture"}:
				_babcd.Picture = NewCT_SheetBackgroundPicture()
				if _cfac := d.DecodeElement(_babcd.Picture, &_dedbaf); _cfac != nil {
					return _cfac
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "oleObjects"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "oleObjects"}:
				_babcd.OleObjects = NewCT_OleObjects()
				if _cdgba := d.DecodeElement(_babcd.OleObjects, &_dedbaf); _cdgba != nil {
					return _cdgba
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "controls"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "controls"}:
				_babcd.Controls = NewCT_Controls()
				if _babcadg := d.DecodeElement(_babcd.Controls, &_dedbaf); _babcadg != nil {
					return _babcadg
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "webPublishItems"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "webPublishItems"}:
				_babcd.WebPublishItems = NewCT_WebPublishItems()
				if _bcgda := d.DecodeElement(_babcd.WebPublishItems, &_dedbaf); _bcgda != nil {
					return _bcgda
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tableParts"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tableParts"}:
				_babcd.TableParts = NewCT_TableParts()
				if _dddeb := d.DecodeElement(_babcd.TableParts, &_dedbaf); _dddeb != nil {
					return _dddeb
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_babcd.ExtLst = NewCT_ExtensionList()
				if _bedbe := d.DecodeElement(_babcd.ExtLst, &_dedbaf); _bedbe != nil {
					return _bedbe
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on Worksheet \u0025v", _dedbaf.Name)
				if _edafb := d.Skip(); _edafb != nil {
					return _edafb
				}
			}
		case _f.EndElement:
			break _ffffa
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_FieldGroup() *CT_FieldGroup { _fadgf := &CT_FieldGroup{}; return _fadgf }
func (_egd *CT_CalcChain) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_effe := _f.StartElement{Name: _f.Name{Local: "ma:c"}}
	for _, _adee := range _egd.C {
		e.EncodeElement(_adee, _effe)
	}
	if _egd.ExtLst != nil {
		_ecdd := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_egd.ExtLst, _ecdd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_XmlCellPr and its children
func (_cbfgg *CT_XmlCellPr) Validate() error { return _cbfgg.ValidateWithPath("CT_XmlCellPr") }
func (_gdfgb ST_PaneState) String() string {
	switch _gdfgb {
	case 0:
		return ""
	case 1:
		return "split"
	case 2:
		return "frozen"
	case 3:
		return "frozenSplit"
	}
	return ""
}

// ValidateWithPath validates the CT_IndexedColors and its children, prefixing error messages with path
func (_gacbf *CT_IndexedColors) ValidateWithPath(path string) error {
	for _fgccb, _abcbb := range _gacbf.RgbColor {
		if _fgbdg := _abcbb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRgbColor\u005b\u0025d\u005d", path, _fgccb)); _fgbdg != nil {
			return _fgbdg
		}
	}
	return nil
}
func NewCT_CustomChartsheetViews() *CT_CustomChartsheetViews {
	_agfe := &CT_CustomChartsheetViews{}
	return _agfe
}

// Validate validates the CT_DdeItem and its children
func (_gedb *CT_DdeItem) Validate() error { return _gedb.ValidateWithPath("CT_DdeItem") }

// Validate validates the CT_Row and its children
func (_ecbcff *CT_Row) Validate() error { return _ecbcff.ValidateWithPath("CT_Row") }
func (_bcafb *ST_Objects) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_eedbe, _ccaaae := d.Token()
	if _ccaaae != nil {
		return _ccaaae
	}
	if _cbbga, _gdeede := _eedbe.(_f.EndElement); _gdeede && _cbbga.Name == start.Name {
		*_bcafb = 1
		return nil
	}
	if _bedbfb, _ggcgdg := _eedbe.(_f.CharData); !_ggcgdg {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eedbe)
	} else {
		switch string(_bedbfb) {
		case "":
			*_bcafb = 0
		case "all":
			*_bcafb = 1
		case "placeholders":
			*_bcafb = 2
		case "none":
			*_bcafb = 3
		}
	}
	_eedbe, _ccaaae = d.Token()
	if _ccaaae != nil {
		return _ccaaae
	}
	if _dafde, _gfccde := _eedbe.(_f.EndElement); _gfccde && _dafde.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eedbe)
}
func (_bfafe *CT_GroupItems) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bfafe.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_bfafe.CountAttr)})
	}
	e.EncodeToken(start)
	if _bfafe.M != nil {
		_gabeg := _f.StartElement{Name: _f.Name{Local: "ma:m"}}
		for _, _edeef := range _bfafe.M {
			e.EncodeElement(_edeef, _gabeg)
		}
	}
	if _bfafe.N != nil {
		_bafgca := _f.StartElement{Name: _f.Name{Local: "ma:n"}}
		for _, _gdfg := range _bfafe.N {
			e.EncodeElement(_gdfg, _bafgca)
		}
	}
	if _bfafe.B != nil {
		_cfbge := _f.StartElement{Name: _f.Name{Local: "ma:b"}}
		for _, _bbdg := range _bfafe.B {
			e.EncodeElement(_bbdg, _cfbge)
		}
	}
	if _bfafe.E != nil {
		_aceef := _f.StartElement{Name: _f.Name{Local: "ma:e"}}
		for _, _eagbg := range _bfafe.E {
			e.EncodeElement(_eagbg, _aceef)
		}
	}
	if _bfafe.S != nil {
		_fdeg := _f.StartElement{Name: _f.Name{Local: "ma:s"}}
		for _, _fgbb := range _bfafe.S {
			e.EncodeElement(_fgbb, _fdeg)
		}
	}
	if _bfafe.D != nil {
		_acedc := _f.StartElement{Name: _f.Name{Local: "ma:d"}}
		for _, _ecbcc := range _bfafe.D {
			e.EncodeElement(_ecbcc, _acedc)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_fcbb *CT_CalculatedItem) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fcbb.FieldAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "field"}, Value: _bg.Sprintf("\u0025v", *_fcbb.FieldAttr)})
	}
	if _fcbb.FormulaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "formula"}, Value: _bg.Sprintf("\u0025v", *_fcbb.FormulaAttr)})
	}
	e.EncodeToken(start)
	_dbba := _f.StartElement{Name: _f.Name{Local: "ma:pivotArea"}}
	e.EncodeElement(_fcbb.PivotArea, _dbba)
	if _fcbb.ExtLst != nil {
		_gdedg := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_fcbb.ExtLst, _gdedg)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SheetId and its children
func (_efde *CT_SheetId) Validate() error                 { return _efde.ValidateWithPath("CT_SheetId") }
func (_bdbdeb ST_ExternalConnectionType) Validate() error { return _bdbdeb.ValidateWithPath("") }
func (_dbcga *CT_FontScheme) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dbcga.ValAttr = ST_FontScheme(1)
	for _, _eccdd := range start.Attr {
		if _eccdd.Name.Local == "val" {
			_dbcga.ValAttr.UnmarshalXMLAttr(_eccdd)
			continue
		}
	}
	for {
		_gfbde, _cefgc := d.Token()
		if _cefgc != nil {
			return _bg.Errorf("parsing\u0020CT_FontScheme:\u0020\u0025s", _cefgc)
		}
		if _bedg, _accff := _gfbde.(_f.EndElement); _accff && _bedg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gbfdec *CT_PivotDimension) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _faebg := range start.Attr {
		if _faebg.Name.Local == "measure" {
			_bfbeae, _acbgc := _g.ParseBool(_faebg.Value)
			if _acbgc != nil {
				return _acbgc
			}
			_gbfdec.MeasureAttr = &_bfbeae
			continue
		}
		if _faebg.Name.Local == "name" {
			_effac, _dcade := _faebg.Value, error(nil)
			if _dcade != nil {
				return _dcade
			}
			_gbfdec.NameAttr = _effac
			continue
		}
		if _faebg.Name.Local == "uniqueName" {
			_ceeg, _acdfbd := _faebg.Value, error(nil)
			if _acdfbd != nil {
				return _acdfbd
			}
			_gbfdec.UniqueNameAttr = _ceeg
			continue
		}
		if _faebg.Name.Local == "caption" {
			_gddce, _ddfdd := _faebg.Value, error(nil)
			if _ddfdd != nil {
				return _ddfdd
			}
			_gbfdec.CaptionAttr = _gddce
			continue
		}
	}
	for {
		_dagcc, _adefb := d.Token()
		if _adefb != nil {
			return _bg.Errorf("parsing\u0020CT_PivotDimension: \u0025s", _adefb)
		}
		if _ggdag, _gdce := _dagcc.(_f.EndElement); _gdce && _ggdag.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Cell and its children, prefixing error messages with path
func (_ffag *CT_Cell) ValidateWithPath(path string) error {
	if _efcg := _ffag.TAttr.ValidateWithPath(path + "\u002fTAttr"); _efcg != nil {
		return _efcg
	}
	if _ffag.F != nil {
		if _gbfe := _ffag.F.ValidateWithPath(path + "\u002fF"); _gbfe != nil {
			return _gbfe
		}
	}
	if _ffag.Is != nil {
		if _dgdba := _ffag.Is.ValidateWithPath(path + "\u002fIs"); _dgdba != nil {
			return _dgdba
		}
	}
	if _ffag.ExtLst != nil {
		if _fegdf := _ffag.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fegdf != nil {
			return _fegdf
		}
	}
	return nil
}

// ValidateWithPath validates the CT_RowFields and its children, prefixing error messages with path
func (_bfdgbd *CT_RowFields) ValidateWithPath(path string) error {
	for _eaadc, _egeeb := range _bfdgbd.Field {
		if _bcgabd := _egeeb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fField\u005b\u0025d\u005d", path, _eaadc)); _bcgabd != nil {
			return _bcgabd
		}
	}
	return nil
}

// ValidateWithPath validates the Metadata and its children, prefixing error messages with path
func (_gbfcga *Metadata) ValidateWithPath(path string) error {
	if _eggea := _gbfcga.CT_Metadata.ValidateWithPath(path); _eggea != nil {
		return _eggea
	}
	return nil
}

const (
	ST_TimePeriodUnset     ST_TimePeriod = 0
	ST_TimePeriodToday     ST_TimePeriod = 1
	ST_TimePeriodYesterday ST_TimePeriod = 2
	ST_TimePeriodTomorrow  ST_TimePeriod = 3
	ST_TimePeriodLast7Days ST_TimePeriod = 4
	ST_TimePeriodThisMonth ST_TimePeriod = 5
	ST_TimePeriodLastMonth ST_TimePeriod = 6
	ST_TimePeriodNextMonth ST_TimePeriod = 7
	ST_TimePeriodThisWeek  ST_TimePeriod = 8
	ST_TimePeriodLastWeek  ST_TimePeriod = 9
	ST_TimePeriodNextWeek  ST_TimePeriod = 10
)

type CT_RElt struct {

	// Run Properties
	RPr *CT_RPrElt

	// Text
	T string
}

// Validate validates the CT_RevisionConflict and its children
func (_aafaf *CT_RevisionConflict) Validate() error {
	return _aafaf.ValidateWithPath("CT_RevisionConflict")
}

const (
	ST_PivotFilterTypeUnset                     ST_PivotFilterType = 0
	ST_PivotFilterTypeUnknown                   ST_PivotFilterType = 1
	ST_PivotFilterTypeCount                     ST_PivotFilterType = 2
	ST_PivotFilterTypePercent                   ST_PivotFilterType = 3
	ST_PivotFilterTypeSum                       ST_PivotFilterType = 4
	ST_PivotFilterTypeCaptionEqual              ST_PivotFilterType = 5
	ST_PivotFilterTypeCaptionNotEqual           ST_PivotFilterType = 6
	ST_PivotFilterTypeCaptionBeginsWith         ST_PivotFilterType = 7
	ST_PivotFilterTypeCaptionNotBeginsWith      ST_PivotFilterType = 8
	ST_PivotFilterTypeCaptionEndsWith           ST_PivotFilterType = 9
	ST_PivotFilterTypeCaptionNotEndsWith        ST_PivotFilterType = 10
	ST_PivotFilterTypeCaptionContains           ST_PivotFilterType = 11
	ST_PivotFilterTypeCaptionNotContains        ST_PivotFilterType = 12
	ST_PivotFilterTypeCaptionGreaterThan        ST_PivotFilterType = 13
	ST_PivotFilterTypeCaptionGreaterThanOrEqual ST_PivotFilterType = 14
	ST_PivotFilterTypeCaptionLessThan           ST_PivotFilterType = 15
	ST_PivotFilterTypeCaptionLessThanOrEqual    ST_PivotFilterType = 16
	ST_PivotFilterTypeCaptionBetween            ST_PivotFilterType = 17
	ST_PivotFilterTypeCaptionNotBetween         ST_PivotFilterType = 18
	ST_PivotFilterTypeValueEqual                ST_PivotFilterType = 19
	ST_PivotFilterTypeValueNotEqual             ST_PivotFilterType = 20
	ST_PivotFilterTypeValueGreaterThan          ST_PivotFilterType = 21
	ST_PivotFilterTypeValueGreaterThanOrEqual   ST_PivotFilterType = 22
	ST_PivotFilterTypeValueLessThan             ST_PivotFilterType = 23
	ST_PivotFilterTypeValueLessThanOrEqual      ST_PivotFilterType = 24
	ST_PivotFilterTypeValueBetween              ST_PivotFilterType = 25
	ST_PivotFilterTypeValueNotBetween           ST_PivotFilterType = 26
	ST_PivotFilterTypeDateEqual                 ST_PivotFilterType = 27
	ST_PivotFilterTypeDateNotEqual              ST_PivotFilterType = 28
	ST_PivotFilterTypeDateOlderThan             ST_PivotFilterType = 29
	ST_PivotFilterTypeDateOlderThanOrEqual      ST_PivotFilterType = 30
	ST_PivotFilterTypeDateNewerThan             ST_PivotFilterType = 31
	ST_PivotFilterTypeDateNewerThanOrEqual      ST_PivotFilterType = 32
	ST_PivotFilterTypeDateBetween               ST_PivotFilterType = 33
	ST_PivotFilterTypeDateNotBetween            ST_PivotFilterType = 34
	ST_PivotFilterTypeTomorrow                  ST_PivotFilterType = 35
	ST_PivotFilterTypeToday                     ST_PivotFilterType = 36
	ST_PivotFilterTypeYesterday                 ST_PivotFilterType = 37
	ST_PivotFilterTypeNextWeek                  ST_PivotFilterType = 38
	ST_PivotFilterTypeThisWeek                  ST_PivotFilterType = 39
	ST_PivotFilterTypeLastWeek                  ST_PivotFilterType = 40
	ST_PivotFilterTypeNextMonth                 ST_PivotFilterType = 41
	ST_PivotFilterTypeThisMonth                 ST_PivotFilterType = 42
	ST_PivotFilterTypeLastMonth                 ST_PivotFilterType = 43
	ST_PivotFilterTypeNextQuarter               ST_PivotFilterType = 44
	ST_PivotFilterTypeThisQuarter               ST_PivotFilterType = 45
	ST_PivotFilterTypeLastQuarter               ST_PivotFilterType = 46
	ST_PivotFilterTypeNextYear                  ST_PivotFilterType = 47
	ST_PivotFilterTypeThisYear                  ST_PivotFilterType = 48
	ST_PivotFilterTypeLastYear                  ST_PivotFilterType = 49
	ST_PivotFilterTypeYearToDate                ST_PivotFilterType = 50
	ST_PivotFilterTypeQ1                        ST_PivotFilterType = 51
	ST_PivotFilterTypeQ2                        ST_PivotFilterType = 52
	ST_PivotFilterTypeQ3                        ST_PivotFilterType = 53
	ST_PivotFilterTypeQ4                        ST_PivotFilterType = 54
	ST_PivotFilterTypeM1                        ST_PivotFilterType = 55
	ST_PivotFilterTypeM2                        ST_PivotFilterType = 56
	ST_PivotFilterTypeM3                        ST_PivotFilterType = 57
	ST_PivotFilterTypeM4                        ST_PivotFilterType = 58
	ST_PivotFilterTypeM5                        ST_PivotFilterType = 59
	ST_PivotFilterTypeM6                        ST_PivotFilterType = 60
	ST_PivotFilterTypeM7                        ST_PivotFilterType = 61
	ST_PivotFilterTypeM8                        ST_PivotFilterType = 62
	ST_PivotFilterTypeM9                        ST_PivotFilterType = 63
	ST_PivotFilterTypeM10                       ST_PivotFilterType = 64
	ST_PivotFilterTypeM11                       ST_PivotFilterType = 65
	ST_PivotFilterTypeM12                       ST_PivotFilterType = 66
)

func NewCT_PivotCacheRecords() *CT_PivotCacheRecords {
	_fcegfg := &CT_PivotCacheRecords{}
	return _fcegfg
}
func (_eagde *QueryTable) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:queryTable"
	return _eagde.CT_QueryTable.MarshalXML(e, start)
}
func (_fcgaf ST_GradientType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_fcgaf.String(), start)
}
func (_fbefa *CT_PageBreak) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _aecgb := range start.Attr {
		if _aecgb.Name.Local == "count" {
			_ebebdd, _abebd := _g.ParseUint(_aecgb.Value, 10, 32)
			if _abebd != nil {
				return _abebd
			}
			_aagbf := uint32(_ebebdd)
			_fbefa.CountAttr = &_aagbf
			continue
		}
		if _aecgb.Name.Local == "manualBreakCount" {
			_bafca, _ebefb := _g.ParseUint(_aecgb.Value, 10, 32)
			if _ebefb != nil {
				return _ebefb
			}
			_eaaeg := uint32(_bafca)
			_fbefa.ManualBreakCountAttr = &_eaaeg
			continue
		}
	}
_dffce:
	for {
		_dababc, _cbbf := d.Token()
		if _cbbf != nil {
			return _cbbf
		}
		switch _bcfdf := _dababc.(type) {
		case _f.StartElement:
			switch _bcfdf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "brk"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "brk"}:
				_egaeed := NewCT_Break()
				if _bfba := d.DecodeElement(_egaeed, &_bcfdf); _bfba != nil {
					return _bfba
				}
				_fbefa.Brk = append(_fbefa.Brk, _egaeed)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PageBreak\u0020\u0025v", _bcfdf.Name)
				if _facaf := d.Skip(); _facaf != nil {
					return _facaf
				}
			}
		case _f.EndElement:
			break _dffce
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the Chartsheet and its children
func (_cbbfg *Chartsheet) Validate() error { return _cbbfg.ValidateWithPath("Chartsheet") }

// ValidateWithPath validates the CT_ChartFormat and its children, prefixing error messages with path
func (_acga *CT_ChartFormat) ValidateWithPath(path string) error {
	if _dgafc := _acga.PivotArea.ValidateWithPath(path + "\u002fPivotArea"); _dgafc != nil {
		return _dgafc
	}
	return nil
}

const (
	ST_TypeUnset  ST_Type = 0
	ST_TypeNone   ST_Type = 1
	ST_TypeAll    ST_Type = 2
	ST_TypeRow    ST_Type = 3
	ST_TypeColumn ST_Type = 4
)

func (_bfcec *CT_Users) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gdfdc := range start.Attr {
		if _gdfdc.Name.Local == "count" {
			_gefffc, _fdabg := _g.ParseUint(_gdfdc.Value, 10, 32)
			if _fdabg != nil {
				return _fdabg
			}
			_abfee := uint32(_gefffc)
			_bfcec.CountAttr = &_abfee
			continue
		}
	}
_aeacde:
	for {
		_dbgbgc, _afegc := d.Token()
		if _afegc != nil {
			return _afegc
		}
		switch _bcfcb := _dbgbgc.(type) {
		case _f.StartElement:
			switch _bcfcb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "userInfo"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "userInfo"}:
				_beeea := NewCT_SharedUser()
				if _dfceg := d.DecodeElement(_beeea, &_bcfcb); _dfceg != nil {
					return _dfceg
				}
				_bfcec.UserInfo = append(_bfcec.UserInfo, _beeea)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Users\u0020\u0025v", _bcfcb.Name)
				if _efdcg := d.Skip(); _efdcg != nil {
					return _efdcg
				}
			}
		case _f.EndElement:
			break _aeacde
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_QueryTableField and its children
func (_deccd *CT_QueryTableField) Validate() error {
	return _deccd.ValidateWithPath("CT_QueryTableField")
}
func (_fdacf *CT_Index) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _feccdc := range start.Attr {
		if _feccdc.Name.Local == "v" {
			_fgeaff, _fffbc := _g.ParseUint(_feccdc.Value, 10, 32)
			if _fffbc != nil {
				return _fffbc
			}
			_fdacf.VAttr = uint32(_fgeaff)
			continue
		}
	}
	for {
		_eadbb, _abgdf := d.Token()
		if _abgdf != nil {
			return _bg.Errorf("parsing\u0020CT_Index: \u0025s", _abgdf)
		}
		if _fbeec, _dbccc := _eadbb.(_f.EndElement); _dbccc && _fbeec.Name == start.Name {
			break
		}
	}
	return nil
}
func (_acgdf *ST_VolValueType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_acgdf = 0
	case "b":
		*_acgdf = 1
	case "n":
		*_acgdf = 2
	case "e":
		*_acgdf = 3
	case "s":
		*_acgdf = 4
	}
	return nil
}
func (_aefad *CT_CellStyleXfs) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aefad.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_aefad.CountAttr)})
	}
	e.EncodeToken(start)
	_dafecd := _f.StartElement{Name: _f.Name{Local: "ma:xf"}}
	for _, _geda := range _aefad.Xf {
		e.EncodeElement(_geda, _dafecd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_bgef *CT_Sets) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _babcad := range start.Attr {
		if _babcad.Name.Local == "count" {
			_eafab, _gfgbe := _g.ParseUint(_babcad.Value, 10, 32)
			if _gfgbe != nil {
				return _gfgbe
			}
			_afada := uint32(_eafab)
			_bgef.CountAttr = &_afada
			continue
		}
	}
_agedc:
	for {
		_eeefdd, _dfggf := d.Token()
		if _dfggf != nil {
			return _dfggf
		}
		switch _ggbcg := _eeefdd.(type) {
		case _f.StartElement:
			switch _ggbcg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "set"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "set"}:
				_eggdb := NewCT_Set()
				if _fbgccg := d.DecodeElement(_eggdb, &_ggbcg); _fbgccg != nil {
					return _fbgccg
				}
				_bgef.Set = append(_bgef.Set, _eggdb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Sets\u0020\u0025v", _ggbcg.Name)
				if _cgcde := d.Skip(); _cgcde != nil {
					return _cgcde
				}
			}
		case _f.EndElement:
			break _agedc
		case _f.CharData:
		}
	}
	return nil
}
func (_ggfbg ST_UnderlineValues) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_ggfbg.String(), start)
}
func (_cadbb *ST_UpdateLinks) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_gbcea, _dfcccc := d.Token()
	if _dfcccc != nil {
		return _dfcccc
	}
	if _afedb, _ddbfa := _gbcea.(_f.EndElement); _ddbfa && _afedb.Name == start.Name {
		*_cadbb = 1
		return nil
	}
	if _cddbca, _baaec := _gbcea.(_f.CharData); !_baaec {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gbcea)
	} else {
		switch string(_cddbca) {
		case "":
			*_cadbb = 0
		case "userSet":
			*_cadbb = 1
		case "never":
			*_cadbb = 2
		case "always":
			*_cadbb = 3
		}
	}
	_gbcea, _dfcccc = d.Token()
	if _dfcccc != nil {
		return _dfcccc
	}
	if _gedfdb, _fbfdbf := _gbcea.(_f.EndElement); _fbfdbf && _gedfdb.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gbcea)
}

// Validate validates the CT_CalculatedMember and its children
func (_ddccc *CT_CalculatedMember) Validate() error {
	return _ddccc.ValidateWithPath("CT_CalculatedMember")
}

// Validate validates the CT_Users and its children
func (_eabgg *CT_Users) Validate() error { return _eabgg.ValidateWithPath("CT_Users") }
func (_ddedf *CT_WebPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ddbgab := range start.Attr {
		if _ddbgab.Name.Local == "xl2000" {
			_fdaac, _fegff := _g.ParseBool(_ddbgab.Value)
			if _fegff != nil {
				return _fegff
			}
			_ddedf.Xl2000Attr = &_fdaac
			continue
		}
		if _ddbgab.Name.Local == "xml" {
			_cbaag, _fcbgfa := _g.ParseBool(_ddbgab.Value)
			if _fcbgfa != nil {
				return _fcbgfa
			}
			_ddedf.XmlAttr = &_cbaag
			continue
		}
		if _ddbgab.Name.Local == "parsePre" {
			_fcdede, _dfdfc := _g.ParseBool(_ddbgab.Value)
			if _dfdfc != nil {
				return _dfdfc
			}
			_ddedf.ParsePreAttr = &_fcdede
			continue
		}
		if _ddbgab.Name.Local == "consecutive" {
			_aedce, _fbeeed := _g.ParseBool(_ddbgab.Value)
			if _fbeeed != nil {
				return _fbeeed
			}
			_ddedf.ConsecutiveAttr = &_aedce
			continue
		}
		if _ddbgab.Name.Local == "firstRow" {
			_eaedbe, _gggcf := _g.ParseBool(_ddbgab.Value)
			if _gggcf != nil {
				return _gggcf
			}
			_ddedf.FirstRowAttr = &_eaedbe
			continue
		}
		if _ddbgab.Name.Local == "xl97" {
			_adbbf, _fdcbf := _g.ParseBool(_ddbgab.Value)
			if _fdcbf != nil {
				return _fdcbf
			}
			_ddedf.Xl97Attr = &_adbbf
			continue
		}
		if _ddbgab.Name.Local == "textDates" {
			_edcbc, _accdd := _g.ParseBool(_ddbgab.Value)
			if _accdd != nil {
				return _accdd
			}
			_ddedf.TextDatesAttr = &_edcbc
			continue
		}
		if _ddbgab.Name.Local == "sourceData" {
			_bceacb, _caebef := _g.ParseBool(_ddbgab.Value)
			if _caebef != nil {
				return _caebef
			}
			_ddedf.SourceDataAttr = &_bceacb
			continue
		}
		if _ddbgab.Name.Local == "url" {
			_eecgb, _gbaec := _ddbgab.Value, error(nil)
			if _gbaec != nil {
				return _gbaec
			}
			_ddedf.UrlAttr = &_eecgb
			continue
		}
		if _ddbgab.Name.Local == "post" {
			_cbefe, _edefe := _ddbgab.Value, error(nil)
			if _edefe != nil {
				return _edefe
			}
			_ddedf.PostAttr = &_cbefe
			continue
		}
		if _ddbgab.Name.Local == "htmlTables" {
			_gbcdfa, _dfdgd := _g.ParseBool(_ddbgab.Value)
			if _dfdgd != nil {
				return _dfdgd
			}
			_ddedf.HtmlTablesAttr = &_gbcdfa
			continue
		}
		if _ddbgab.Name.Local == "htmlFormat" {
			_ddedf.HtmlFormatAttr.UnmarshalXMLAttr(_ddbgab)
			continue
		}
		if _ddbgab.Name.Local == "editPage" {
			_dbfdd, _fdggfb := _ddbgab.Value, error(nil)
			if _fdggfb != nil {
				return _fdggfb
			}
			_ddedf.EditPageAttr = &_dbfdd
			continue
		}
	}
_bfgbd:
	for {
		_acaeed, _beacb := d.Token()
		if _beacb != nil {
			return _beacb
		}
		switch _ceffb := _acaeed.(type) {
		case _f.StartElement:
			switch _ceffb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tables"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tables"}:
				_ddedf.Tables = NewCT_Tables()
				if _eabec := d.DecodeElement(_ddedf.Tables, &_ceffb); _eabec != nil {
					return _eabec
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_WebPr\u0020\u0025v", _ceffb.Name)
				if _edbfgc := d.Skip(); _edbfgc != nil {
					return _edbfgc
				}
			}
		case _f.EndElement:
			break _bfgbd
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Pane and its children
func (_ccfdc *CT_Pane) Validate() error { return _ccfdc.ValidateWithPath("CT_Pane") }
func (_agfgaa ST_DateTimeGrouping) ValidateWithPath(path string) error {
	switch _agfgaa {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_agfgaa))
	}
	return nil
}

// ValidateWithPath validates the CT_CellStyle and its children, prefixing error messages with path
func (_eaee *CT_CellStyle) ValidateWithPath(path string) error {
	if _eaee.ExtLst != nil {
		if _bac := _eaee.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bac != nil {
			return _bac
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ObjectPr and its children, prefixing error messages with path
func (_aabeg *CT_ObjectPr) ValidateWithPath(path string) error {
	if _edegb := _aabeg.Anchor.ValidateWithPath(path + "\u002fAnchor"); _edegb != nil {
		return _edegb
	}
	return nil
}

// Validate validates the CT_FontFamily and its children
func (_ggagg *CT_FontFamily) Validate() error              { return _ggagg.ValidateWithPath("CT_FontFamily") }
func (_ageafe ST_DataConsolidateFunction) Validate() error { return _ageafe.ValidateWithPath("") }
func NewCT_PivotDimension() *CT_PivotDimension             { _dgbge := &CT_PivotDimension{}; return _dgbge }

// Validate validates the CT_WorkbookPr and its children
func (_ddefd *CT_WorkbookPr) Validate() error { return _ddefd.ValidateWithPath("CT_WorkbookPr") }
func (_cfbef *ST_TableType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_cfbef = 0
	case "worksheet":
		*_cfbef = 1
	case "xml":
		*_cfbef = 2
	case "queryTable":
		*_cfbef = 3
	}
	return nil
}

// ValidateWithPath validates the CT_TextPr and its children, prefixing error messages with path
func (_gcbge *CT_TextPr) ValidateWithPath(path string) error {
	if _gfaca := _gcbge.FileTypeAttr.ValidateWithPath(path + "\u002fFileTypeAttr"); _gfaca != nil {
		return _gfaca
	}
	if _ccdffd := _gcbge.QualifierAttr.ValidateWithPath(path + "\u002fQualifierAttr"); _ccdffd != nil {
		return _ccdffd
	}
	if _gcbge.TextFields != nil {
		if _ffbdg := _gcbge.TextFields.ValidateWithPath(path + "/TextFields"); _ffbdg != nil {
			return _ffbdg
		}
	}
	return nil
}

// Validate validates the CT_VerticalAlignFontProperty and its children
func (_degaeb *CT_VerticalAlignFontProperty) Validate() error {
	return _degaeb.ValidateWithPath("CT_VerticalAlignFontProperty")
}

// ValidateWithPath validates the CT_Selection and its children, prefixing error messages with path
func (_dbcdac *CT_Selection) ValidateWithPath(path string) error {
	if _ageac := _dbcdac.PaneAttr.ValidateWithPath(path + "\u002fPaneAttr"); _ageac != nil {
		return _ageac
	}
	return nil
}
func NewCT_DdeItem() *CT_DdeItem { _faefd := &CT_DdeItem{}; return _faefd }
func (_fdgdfg *ST_ConditionalFormattingOperator) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_bceab, _beaegc := d.Token()
	if _beaegc != nil {
		return _beaegc
	}
	if _dcgfbd, _acdag := _bceab.(_f.EndElement); _acdag && _dcgfbd.Name == start.Name {
		*_fdgdfg = 1
		return nil
	}
	if _aecbc, _ffdcg := _bceab.(_f.CharData); !_ffdcg {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bceab)
	} else {
		switch string(_aecbc) {
		case "":
			*_fdgdfg = 0
		case "lessThan":
			*_fdgdfg = 1
		case "lessThanOrEqual":
			*_fdgdfg = 2
		case "equal":
			*_fdgdfg = 3
		case "notEqual":
			*_fdgdfg = 4
		case "greaterThanOrEqual":
			*_fdgdfg = 5
		case "greaterThan":
			*_fdgdfg = 6
		case "between":
			*_fdgdfg = 7
		case "notBetween":
			*_fdgdfg = 8
		case "containsText":
			*_fdgdfg = 9
		case "notContains":
			*_fdgdfg = 10
		case "beginsWith":
			*_fdgdfg = 11
		case "endsWith":
			*_fdgdfg = 12
		}
	}
	_bceab, _beaegc = d.Token()
	if _beaegc != nil {
		return _beaegc
	}
	if _ebecd, _dfdcf := _bceab.(_f.EndElement); _dfdcf && _ebecd.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bceab)
}
func (_ega *CT_CacheSource) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ega.TypeAttr = ST_SourceType(1)
	for _, _fac := range start.Attr {
		if _fac.Name.Local == "type" {
			_ega.TypeAttr.UnmarshalXMLAttr(_fac)
			continue
		}
		if _fac.Name.Local == "connectionId" {
			_bfag, _befb := _g.ParseUint(_fac.Value, 10, 32)
			if _befb != nil {
				return _befb
			}
			_cdff := uint32(_bfag)
			_ega.ConnectionIdAttr = &_cdff
			continue
		}
	}
_bbb:
	for {
		_fagea, _beab := d.Token()
		if _beab != nil {
			return _beab
		}
		switch _ebaf := _fagea.(type) {
		case _f.StartElement:
			switch _ebaf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "worksheetSource"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "worksheetSource"}:
				_ega.WorksheetSource = NewCT_WorksheetSource()
				if _adc := d.DecodeElement(_ega.WorksheetSource, &_ebaf); _adc != nil {
					return _adc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "consolidation"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "consolidation"}:
				_ega.Consolidation = NewCT_Consolidation()
				if _bga := d.DecodeElement(_ega.Consolidation, &_ebaf); _bga != nil {
					return _bga
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ega.ExtLst = NewCT_ExtensionList()
				if _afef := d.DecodeElement(_ega.ExtLst, &_ebaf); _afef != nil {
					return _afef
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CacheSource\u0020\u0025v", _ebaf.Name)
				if _fbf := d.Skip(); _fbf != nil {
					return _fbf
				}
			}
		case _f.EndElement:
			break _bbb
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the VolTypes and its children, prefixing error messages with path
func (_bbddec *VolTypes) ValidateWithPath(path string) error {
	if _dbeaba := _bbddec.CT_VolTypes.ValidateWithPath(path); _dbeaba != nil {
		return _dbeaba
	}
	return nil
}
func (_fgga *CT_ColorScale) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_dafc := _f.StartElement{Name: _f.Name{Local: "ma:cfvo"}}
	for _, _bddd := range _fgga.Cfvo {
		e.EncodeElement(_bddd, _dafc)
	}
	_abff := _f.StartElement{Name: _f.Name{Local: "ma:color"}}
	for _, _bebf := range _fgga.Color {
		e.EncodeElement(_bebf, _abff)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_eggcg *CT_GroupLevel) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "uniqueName"}, Value: _bg.Sprintf("\u0025v", _eggcg.UniqueNameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "caption"}, Value: _bg.Sprintf("\u0025v", _eggcg.CaptionAttr)})
	if _eggcg.UserAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "user"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eggcg.UserAttr))})
	}
	if _eggcg.CustomRollUpAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "customRollUp"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eggcg.CustomRollUpAttr))})
	}
	e.EncodeToken(start)
	if _eggcg.Groups != nil {
		_gdabe := _f.StartElement{Name: _f.Name{Local: "ma:groups"}}
		e.EncodeElement(_eggcg.Groups, _gdabe)
	}
	if _eggcg.ExtLst != nil {
		_dgad := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_eggcg.ExtLst, _dgad)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_RevisionCellChange and its children
func (_beeeb *CT_RevisionCellChange) Validate() error {
	return _beeeb.ValidateWithPath("CT_RevisionCellChange")
}
func (_fbef *CT_ControlPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fbef.Anchor = NewCT_ObjectAnchor()
	for _, _afbcf := range start.Attr {
		if _afbcf.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _afbcf.Name.Local == "id" || _afbcf.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _afbcf.Name.Local == "id" {
			_ccafd, _ecag := _afbcf.Value, error(nil)
			if _ecag != nil {
				return _ecag
			}
			_fbef.IdAttr = &_ccafd
			continue
		}
		if _afbcf.Name.Local == "autoPict" {
			_bdbeb, _cgbcf := _g.ParseBool(_afbcf.Value)
			if _cgbcf != nil {
				return _cgbcf
			}
			_fbef.AutoPictAttr = &_bdbeb
			continue
		}
		if _afbcf.Name.Local == "macro" {
			_beaed, _aadf := _afbcf.Value, error(nil)
			if _aadf != nil {
				return _aadf
			}
			_fbef.MacroAttr = &_beaed
			continue
		}
		if _afbcf.Name.Local == "print" {
			_eaeef, _cggc := _g.ParseBool(_afbcf.Value)
			if _cggc != nil {
				return _cggc
			}
			_fbef.PrintAttr = &_eaeef
			continue
		}
		if _afbcf.Name.Local == "recalcAlways" {
			_eggd, _cafff := _g.ParseBool(_afbcf.Value)
			if _cafff != nil {
				return _cafff
			}
			_fbef.RecalcAlwaysAttr = &_eggd
			continue
		}
		if _afbcf.Name.Local == "uiObject" {
			_defg, _gcgd := _g.ParseBool(_afbcf.Value)
			if _gcgd != nil {
				return _gcgd
			}
			_fbef.UiObjectAttr = &_defg
			continue
		}
		if _afbcf.Name.Local == "autoFill" {
			_gdgfc, _adae := _g.ParseBool(_afbcf.Value)
			if _adae != nil {
				return _adae
			}
			_fbef.AutoFillAttr = &_gdgfc
			continue
		}
		if _afbcf.Name.Local == "autoLine" {
			_fbaca, _cgggf := _g.ParseBool(_afbcf.Value)
			if _cgggf != nil {
				return _cgggf
			}
			_fbef.AutoLineAttr = &_fbaca
			continue
		}
		if _afbcf.Name.Local == "locked" {
			_gcca, _gggd := _g.ParseBool(_afbcf.Value)
			if _gggd != nil {
				return _gggd
			}
			_fbef.LockedAttr = &_gcca
			continue
		}
		if _afbcf.Name.Local == "disabled" {
			_bcaga, _bffb := _g.ParseBool(_afbcf.Value)
			if _bffb != nil {
				return _bffb
			}
			_fbef.DisabledAttr = &_bcaga
			continue
		}
		if _afbcf.Name.Local == "altText" {
			_ddge, _ecdfa := _afbcf.Value, error(nil)
			if _ecdfa != nil {
				return _ecdfa
			}
			_fbef.AltTextAttr = &_ddge
			continue
		}
		if _afbcf.Name.Local == "linkedCell" {
			_gecd, _daffe := _afbcf.Value, error(nil)
			if _daffe != nil {
				return _daffe
			}
			_fbef.LinkedCellAttr = &_gecd
			continue
		}
		if _afbcf.Name.Local == "listFillRange" {
			_deca, _aeced := _afbcf.Value, error(nil)
			if _aeced != nil {
				return _aeced
			}
			_fbef.ListFillRangeAttr = &_deca
			continue
		}
		if _afbcf.Name.Local == "cf" {
			_acaeb, _afab := _afbcf.Value, error(nil)
			if _afab != nil {
				return _afab
			}
			_fbef.CfAttr = &_acaeb
			continue
		}
		if _afbcf.Name.Local == "defaultSize" {
			_fggc, _bdcb := _g.ParseBool(_afbcf.Value)
			if _bdcb != nil {
				return _bdcb
			}
			_fbef.DefaultSizeAttr = &_fggc
			continue
		}
	}
_fgcc:
	for {
		_gefd, _bccg := d.Token()
		if _bccg != nil {
			return _bccg
		}
		switch _egbdg := _gefd.(type) {
		case _f.StartElement:
			switch _egbdg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "anchor"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "anchor"}:
				if _geca := d.DecodeElement(_fbef.Anchor, &_egbdg); _geca != nil {
					return _geca
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ControlPr\u0020\u0025v", _egbdg.Name)
				if _gcbfe := d.Skip(); _gcbfe != nil {
					return _gcbfe
				}
			}
		case _f.EndElement:
			break _fgcc
		case _f.CharData:
		}
	}
	return nil
}
func (_ffddb ST_MdxFunctionType) String() string {
	switch _ffddb {
	case 0:
		return ""
	case 1:
		return "m"
	case 2:
		return "v"
	case 3:
		return "s"
	case 4:
		return "c"
	case 5:
		return "r"
	case 6:
		return "p"
	case 7:
		return "k"
	}
	return ""
}
func NewCT_MdxTuple() *CT_MdxTuple { _bddbeg := &CT_MdxTuple{}; return _bddbeg }
func (_bfaegg *Sst) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:sst"
	return _bfaegg.CT_Sst.MarshalXML(e, start)
}

type CT_OleItems struct {

	// Object Link Item
	OleItem []*CT_OleItem
}
type CT_OleSize struct {

	// Reference
	RefAttr string
}

// ValidateWithPath validates the CT_ExtensionList and its children, prefixing error messages with path
func (_bdgff *CT_ExtensionList) ValidateWithPath(path string) error {
	for _babd, _fadbd := range _bdgff.Ext {
		if _bcadg := _fadbd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fExt\u005b\u0025d\u005d", path, _babd)); _bcadg != nil {
			return _bcadg
		}
	}
	return nil
}
func NewAG_AutoFormat() *AG_AutoFormat { _gg := &AG_AutoFormat{}; return _gg }
func (_ggcbb *CT_Sheet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", _ggcbb.NameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetId"}, Value: _bg.Sprintf("\u0025v", _ggcbb.SheetIdAttr)})
	if _ggcbb.StateAttr != ST_SheetStateUnset {
		_gadga, _febeb := _ggcbb.StateAttr.MarshalXMLAttr(_f.Name{Local: "state"})
		if _febeb != nil {
			return _febeb
		}
		start.Attr = append(start.Attr, _gadga)
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _ggcbb.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_gbcba *CT_CustomFilter) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gbcba.OperatorAttr != ST_FilterOperatorUnset {
		_aeddc, _eaged := _gbcba.OperatorAttr.MarshalXMLAttr(_f.Name{Local: "operator"})
		if _eaged != nil {
			return _eaged
		}
		start.Attr = append(start.Attr, _aeddc)
	}
	if _gbcba.ValAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", *_gbcba.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cbgcff ST_PatternType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_cbgcff.String(), start)
}
func (_ddaad *CT_CellSmartTagPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gbdb := range start.Attr {
		if _gbdb.Name.Local == "key" {
			_dfb, _fdbe := _gbdb.Value, error(nil)
			if _fdbe != nil {
				return _fdbe
			}
			_ddaad.KeyAttr = _dfb
			continue
		}
		if _gbdb.Name.Local == "val" {
			_agd, _afdc := _gbdb.Value, error(nil)
			if _afdc != nil {
				return _afdc
			}
			_ddaad.ValAttr = _agd
			continue
		}
	}
	for {
		_ebbg, _gfgg := d.Token()
		if _gfgg != nil {
			return _bg.Errorf("parsing\u0020CT_CellSmartTagPr: \u0025s", _gfgg)
		}
		if _ffdd, _aecd := _ebbg.(_f.EndElement); _aecd && _ffdd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ggabgf *CT_RevisionFormatting) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _bafeec := range start.Attr {
		if _bafeec.Name.Local == "sheetId" {
			_cgcbb, _edbgd := _g.ParseUint(_bafeec.Value, 10, 32)
			if _edbgd != nil {
				return _edbgd
			}
			_ggabgf.SheetIdAttr = uint32(_cgcbb)
			continue
		}
		if _bafeec.Name.Local == "xfDxf" {
			_ddgac, _aaffa := _g.ParseBool(_bafeec.Value)
			if _aaffa != nil {
				return _aaffa
			}
			_ggabgf.XfDxfAttr = &_ddgac
			continue
		}
		if _bafeec.Name.Local == "s" {
			_aaegc, _fdgbc := _g.ParseBool(_bafeec.Value)
			if _fdgbc != nil {
				return _fdgbc
			}
			_ggabgf.SAttr = &_aaegc
			continue
		}
		if _bafeec.Name.Local == "sqref" {
			_dfade, _bddge := ParseSliceST_Sqref(_bafeec.Value)
			if _bddge != nil {
				return _bddge
			}
			_ggabgf.SqrefAttr = _dfade
			continue
		}
		if _bafeec.Name.Local == "start" {
			_gafad, _ffaea := _g.ParseUint(_bafeec.Value, 10, 32)
			if _ffaea != nil {
				return _ffaea
			}
			_beebd := uint32(_gafad)
			_ggabgf.StartAttr = &_beebd
			continue
		}
		if _bafeec.Name.Local == "length" {
			_fgaedc, _bggbg := _g.ParseUint(_bafeec.Value, 10, 32)
			if _bggbg != nil {
				return _bggbg
			}
			_dgadg := uint32(_fgaedc)
			_ggabgf.LengthAttr = &_dgadg
			continue
		}
	}
_ddbgaf:
	for {
		_eagaf, _gadba := d.Token()
		if _gadba != nil {
			return _gadba
		}
		switch _cbdad := _eagaf.(type) {
		case _f.StartElement:
			switch _cbdad.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dxf"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dxf"}:
				_ggabgf.Dxf = NewCT_Dxf()
				if _bbbfgf := d.DecodeElement(_ggabgf.Dxf, &_cbdad); _bbbfgf != nil {
					return _bbbfgf
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ggabgf.ExtLst = NewCT_ExtensionList()
				if _ebfe := d.DecodeElement(_ggabgf.ExtLst, &_cbdad); _ebfe != nil {
					return _ebfe
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on CT_RevisionFormatting\u0020\u0025v", _cbdad.Name)
				if _ebfec := d.Skip(); _ebfec != nil {
					return _ebfec
				}
			}
		case _f.EndElement:
			break _ddbgaf
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_CellSmartTag() *CT_CellSmartTag { _bgca := &CT_CellSmartTag{}; return _bgca }
func NewCT_RgbColor() *CT_RgbColor         { _eddgc := &CT_RgbColor{}; return _eddgc }

type CT_CellStyleXfs struct {

	// Style Count
	CountAttr *uint32

	// Formatting Elements
	Xf []*CT_Xf
}

func (_becfcg ST_PaneState) ValidateWithPath(path string) error {
	switch _becfcg {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_becfcg))
	}
	return nil
}

// ValidateWithPath validates the CT_Drawing and its children, prefixing error messages with path
func (_ecbbb *CT_Drawing) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_CalcChain and its children
func (_aeee *CT_CalcChain) Validate() error { return _aeee.ValidateWithPath("CT_CalcChain") }
func NewCT_CustomWorkbookView() *CT_CustomWorkbookView {
	_aegb := &CT_CustomWorkbookView{}
	_aegb.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	return _aegb
}

// Validate validates the CT_FunctionGroup and its children
func (_ddcab *CT_FunctionGroup) Validate() error { return _ddcab.ValidateWithPath("CT_FunctionGroup") }
func (_fbead *CT_UnderlineProperty) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _fbead.ValAttr != ST_UnderlineValuesUnset {
		_fgafcb, _cdfga := _fbead.ValAttr.MarshalXMLAttr(_f.Name{Local: "val"})
		if _cdfga != nil {
			return _cdfga
		}
		start.Attr = append(start.Attr, _fgafcb)
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_MdxMetadata and its children
func (_beabfe *CT_MdxMetadata) Validate() error { return _beabfe.ValidateWithPath("CT_MdxMetadata") }

type CT_Pages struct {

	// Page Item String Count
	CountAttr *uint32

	// Page Items
	Page []*CT_PCDSCPage
}

func (_dbde *CT_Break) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dbee := range start.Attr {
		if _dbee.Name.Local == "id" {
			_gdff, _ebc := _g.ParseUint(_dbee.Value, 10, 32)
			if _ebc != nil {
				return _ebc
			}
			_agc := uint32(_gdff)
			_dbde.IdAttr = &_agc
			continue
		}
		if _dbee.Name.Local == "min" {
			_aaaf, _gea := _g.ParseUint(_dbee.Value, 10, 32)
			if _gea != nil {
				return _gea
			}
			_gcg := uint32(_aaaf)
			_dbde.MinAttr = &_gcg
			continue
		}
		if _dbee.Name.Local == "max" {
			_efgf, _dafe := _g.ParseUint(_dbee.Value, 10, 32)
			if _dafe != nil {
				return _dafe
			}
			_ffc := uint32(_efgf)
			_dbde.MaxAttr = &_ffc
			continue
		}
		if _dbee.Name.Local == "man" {
			_fdb, _gbc := _g.ParseBool(_dbee.Value)
			if _gbc != nil {
				return _gbc
			}
			_dbde.ManAttr = &_fdb
			continue
		}
		if _dbee.Name.Local == "pt" {
			_cga, _bc := _g.ParseBool(_dbee.Value)
			if _bc != nil {
				return _bc
			}
			_dbde.PtAttr = &_cga
			continue
		}
	}
	for {
		_fdac, _afc := d.Token()
		if _afc != nil {
			return _bg.Errorf("parsing\u0020CT_Break: \u0025s", _afc)
		}
		if _cdd, _afe := _fdac.(_f.EndElement); _afe && _cdd.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PCDSDTCEntries and its children, prefixing error messages with path
func (_fafff *CT_PCDSDTCEntries) ValidateWithPath(path string) error {
	for _fdfgbb, _baedf := range _fafff.M {
		if _geegf := _baedf.ValidateWithPath(_bg.Sprintf("\u0025s\u002fM\u005b\u0025d\u005d", path, _fdfgbb)); _geegf != nil {
			return _geegf
		}
	}
	for _afdbd, _bedfa := range _fafff.N {
		if _gbdda := _bedfa.ValidateWithPath(_bg.Sprintf("\u0025s\u002fN\u005b\u0025d\u005d", path, _afdbd)); _gbdda != nil {
			return _gbdda
		}
	}
	for _agfgf, _agdee := range _fafff.E {
		if _eaedgf := _agdee.ValidateWithPath(_bg.Sprintf("\u0025s\u002fE\u005b\u0025d\u005d", path, _agfgf)); _eaedgf != nil {
			return _eaedgf
		}
	}
	for _daeag, _cgebg := range _fafff.S {
		if _dcgac := _cgebg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fS\u005b\u0025d\u005d", path, _daeag)); _dcgac != nil {
			return _dcgac
		}
	}
	return nil
}
func NewCT_Scenarios() *CT_Scenarios   { _bfbdc := &CT_Scenarios{}; return _bfbdc }
func (_dafea ST_Sqref) String() string { return _fd.Join(_dafea, "\u0020") }
func (_eaec *CT_Comments) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_eaeeb := _f.StartElement{Name: _f.Name{Local: "ma:authors"}}
	e.EncodeElement(_eaec.Authors, _eaeeb)
	_adfb := _f.StartElement{Name: _f.Name{Local: "ma:commentList"}}
	e.EncodeElement(_eaec.CommentList, _adfb)
	if _eaec.ExtLst != nil {
		_afdf := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_eaec.ExtLst, _afdf)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type ST_DdeValueType byte
type CT_IconSet struct {

	// Icon Set
	IconSetAttr ST_IconSetType

	// Show Value
	ShowValueAttr *bool

	// Percent
	PercentAttr *bool

	// Reverse Icons
	ReverseAttr *bool

	// Conditional Formatting Object
	Cfvo []*CT_Cfvo
}

func (_ecfbgb ST_FormulaExpression) ValidateWithPath(path string) error {
	switch _ecfbgb {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ecfbgb))
	}
	return nil
}

type CT_MeasureGroup struct {

	// Measure Group Name
	NameAttr string

	// Measure Group Display Name
	CaptionAttr string
}

func NewCT_Scenario() *CT_Scenario { _dbacb := &CT_Scenario{}; return _dbacb }
func (_dfab *CT_Dimensions) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dfab.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_dfab.CountAttr)})
	}
	e.EncodeToken(start)
	if _dfab.Dimension != nil {
		_fgbd := _f.StartElement{Name: _f.Name{Local: "ma:dimension"}}
		for _, _cbcdb := range _dfab.Dimension {
			e.EncodeElement(_cbcdb, _fgbd)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Colors and its children
func (_aacb *CT_Colors) Validate() error { return _aacb.ValidateWithPath("CT_Colors") }
func (_agee *CT_Cols) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_cega:
	for {
		_cegf, _dgec := d.Token()
		if _dgec != nil {
			return _dgec
		}
		switch _afca := _cegf.(type) {
		case _f.StartElement:
			switch _afca.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "col"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "col"}:
				_abcb := NewCT_Col()
				if _gafg := d.DecodeElement(_abcb, &_afca); _gafg != nil {
					return _gafg
				}
				_agee.Col = append(_agee.Col, _abcb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Cols\u0020\u0025v", _afca.Name)
				if _dcfb := d.Skip(); _dcfb != nil {
					return _dcfb
				}
			}
		case _f.EndElement:
			break _cega
		case _f.CharData:
		}
	}
	return nil
}
func (_bfgda *CT_ExternalLinkChoice) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bfgda.ExternalBook != nil {
		_fccae := _f.StartElement{Name: _f.Name{Local: "ma:externalBook"}}
		e.EncodeElement(_bfgda.ExternalBook, _fccae)
	}
	if _bfgda.DdeLink != nil {
		_ddadb := _f.StartElement{Name: _f.Name{Local: "ma:ddeLink"}}
		e.EncodeElement(_bfgda.DdeLink, _ddadb)
	}
	if _bfgda.OleLink != nil {
		_eaace := _f.StartElement{Name: _f.Name{Local: "ma:oleLink"}}
		e.EncodeElement(_bfgda.OleLink, _eaace)
	}
	return nil
}

type CT_ColorFilter struct {

	// Differential Format Record Id
	DxfIdAttr *uint32

	// Filter By Cell Color
	CellColorAttr *bool
}

// Validate validates the CT_IgnoredErrors and its children
func (_cbdg *CT_IgnoredErrors) Validate() error { return _cbdg.ValidateWithPath("CT_IgnoredErrors") }
func NewCT_RevisionComment() *CT_RevisionComment {
	_bgafg := &CT_RevisionComment{}
	_bgafg.GuidAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	return _bgafg
}
func (_caeba ST_SheetViewType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_bfggeab := _f.Attr{}
	_bfggeab.Name = name
	switch _caeba {
	case ST_SheetViewTypeUnset:
		_bfggeab.Value = ""
	case ST_SheetViewTypeNormal:
		_bfggeab.Value = "normal"
	case ST_SheetViewTypePageBreakPreview:
		_bfggeab.Value = "pageBreakPreview"
	case ST_SheetViewTypePageLayout:
		_bfggeab.Value = "pageLayout"
	}
	return _bfggeab, nil
}

// ValidateWithPath validates the CT_SortState and its children, prefixing error messages with path
func (_bcdbc *CT_SortState) ValidateWithPath(path string) error {
	if _gbcbf := _bcdbc.SortMethodAttr.ValidateWithPath(path + "\u002fSortMethodAttr"); _gbcbf != nil {
		return _gbcbf
	}
	for _dbddf, _edbcc := range _bcdbc.SortCondition {
		if _dffga := _edbcc.ValidateWithPath(_bg.Sprintf("%s/SortCondition[%d\u005d", path, _dbddf)); _dffga != nil {
			return _dffga
		}
	}
	if _bcdbc.ExtLst != nil {
		if _bdcge := _bcdbc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bdcge != nil {
			return _bdcge
		}
	}
	return nil
}
func (_caggbf *ST_CellComments) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_caggbf = 0
	case "none":
		*_caggbf = 1
	case "asDisplayed":
		*_caggbf = 2
	case "atEnd":
		*_caggbf = 3
	}
	return nil
}

// ValidateWithPath validates the CT_UndoInfo and its children, prefixing error messages with path
func (_aecgc *CT_UndoInfo) ValidateWithPath(path string) error {
	if _aecgc.ExpAttr == ST_FormulaExpressionUnset {
		return _bg.Errorf("\u0025s\u002fExpAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _ggaa := _aecgc.ExpAttr.ValidateWithPath(path + "\u002fExpAttr"); _ggaa != nil {
		return _ggaa
	}
	return nil
}

// Validate validates the CT_CacheFields and its children
func (_fbca *CT_CacheFields) Validate() error { return _fbca.ValidateWithPath("CT_CacheFields") }
func (_cadgb *CT_PivotCache) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cacheId"}, Value: _bg.Sprintf("\u0025v", _cadgb.CacheIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", _cadgb.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ggbcd *QueryTable) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_ggbcd.CT_QueryTable = *NewCT_QueryTable()
	for _, _bddec := range start.Attr {
		if _bddec.Name.Local == "adjustColumnWidth" {
			_fcgca, _gdebe := _g.ParseBool(_bddec.Value)
			if _gdebe != nil {
				return _gdebe
			}
			_ggbcd.AdjustColumnWidthAttr = &_fcgca
			continue
		}
		if _bddec.Name.Local == "name" {
			_ebacg, _agadfc := _bddec.Value, error(nil)
			if _agadfc != nil {
				return _agadfc
			}
			_ggbcd.NameAttr = _ebacg
			continue
		}
		if _bddec.Name.Local == "intermediate" {
			_dcdeg, _agdcb := _g.ParseBool(_bddec.Value)
			if _agdcb != nil {
				return _agdcb
			}
			_ggbcd.IntermediateAttr = &_dcdeg
			continue
		}
		if _bddec.Name.Local == "rowNumbers" {
			_gafbfd, _cbbea := _g.ParseBool(_bddec.Value)
			if _cbbea != nil {
				return _cbbea
			}
			_ggbcd.RowNumbersAttr = &_gafbfd
			continue
		}
		if _bddec.Name.Local == "connectionId" {
			_fbdfb, _fdedc := _g.ParseUint(_bddec.Value, 10, 32)
			if _fdedc != nil {
				return _fdedc
			}
			_ggbcd.ConnectionIdAttr = uint32(_fbdfb)
			continue
		}
		if _bddec.Name.Local == "backgroundRefresh" {
			_gfcbag, _dacgd := _g.ParseBool(_bddec.Value)
			if _dacgd != nil {
				return _dacgd
			}
			_ggbcd.BackgroundRefreshAttr = &_gfcbag
			continue
		}
		if _bddec.Name.Local == "refreshOnLoad" {
			_cdaff, _eaabg := _g.ParseBool(_bddec.Value)
			if _eaabg != nil {
				return _eaabg
			}
			_ggbcd.RefreshOnLoadAttr = &_cdaff
			continue
		}
		if _bddec.Name.Local == "fillFormulas" {
			_fegdg, _cdacaa := _g.ParseBool(_bddec.Value)
			if _cdacaa != nil {
				return _cdacaa
			}
			_ggbcd.FillFormulasAttr = &_fegdg
			continue
		}
		if _bddec.Name.Local == "applyNumberFormats" {
			_fdcgc, _debdf := _g.ParseBool(_bddec.Value)
			if _debdf != nil {
				return _debdf
			}
			_ggbcd.ApplyNumberFormatsAttr = &_fdcgc
			continue
		}
		if _bddec.Name.Local == "applyFontFormats" {
			_fcgeg, _cbgdfd := _g.ParseBool(_bddec.Value)
			if _cbgdfd != nil {
				return _cbgdfd
			}
			_ggbcd.ApplyFontFormatsAttr = &_fcgeg
			continue
		}
		if _bddec.Name.Local == "firstBackgroundRefresh" {
			_gggfe, _aaaee := _g.ParseBool(_bddec.Value)
			if _aaaee != nil {
				return _aaaee
			}
			_ggbcd.FirstBackgroundRefreshAttr = &_gggfe
			continue
		}
		if _bddec.Name.Local == "autoFormatId" {
			_fbaebg, _fabddb := _g.ParseUint(_bddec.Value, 10, 32)
			if _fabddb != nil {
				return _fabddb
			}
			_gdgea := uint32(_fbaebg)
			_ggbcd.AutoFormatIdAttr = &_gdgea
			continue
		}
		if _bddec.Name.Local == "applyAlignmentFormats" {
			_cgagbg, _afdac := _g.ParseBool(_bddec.Value)
			if _afdac != nil {
				return _afdac
			}
			_ggbcd.ApplyAlignmentFormatsAttr = &_cgagbg
			continue
		}
		if _bddec.Name.Local == "disableRefresh" {
			_cffdbf, _dffgd := _g.ParseBool(_bddec.Value)
			if _dffgd != nil {
				return _dffgd
			}
			_ggbcd.DisableRefreshAttr = &_cffdbf
			continue
		}
		if _bddec.Name.Local == "applyBorderFormats" {
			_adeegb, _dfceag := _g.ParseBool(_bddec.Value)
			if _dfceag != nil {
				return _dfceag
			}
			_ggbcd.ApplyBorderFormatsAttr = &_adeegb
			continue
		}
		if _bddec.Name.Local == "preserveFormatting" {
			_dageb, _aecagb := _g.ParseBool(_bddec.Value)
			if _aecagb != nil {
				return _aecagb
			}
			_ggbcd.PreserveFormattingAttr = &_dageb
			continue
		}
		if _bddec.Name.Local == "applyPatternFormats" {
			_eeebaa, _efbfa := _g.ParseBool(_bddec.Value)
			if _efbfa != nil {
				return _efbfa
			}
			_ggbcd.ApplyPatternFormatsAttr = &_eeebaa
			continue
		}
		if _bddec.Name.Local == "growShrinkType" {
			_ggbcd.GrowShrinkTypeAttr.UnmarshalXMLAttr(_bddec)
			continue
		}
		if _bddec.Name.Local == "disableEdit" {
			_gbbcddf, _ecfgg := _g.ParseBool(_bddec.Value)
			if _ecfgg != nil {
				return _ecfgg
			}
			_ggbcd.DisableEditAttr = &_gbbcddf
			continue
		}
		if _bddec.Name.Local == "headers" {
			_cgaad, _ddgegd := _g.ParseBool(_bddec.Value)
			if _ddgegd != nil {
				return _ddgegd
			}
			_ggbcd.HeadersAttr = &_cgaad
			continue
		}
		if _bddec.Name.Local == "removeDataOnSave" {
			_aaecd, _gcbaag := _g.ParseBool(_bddec.Value)
			if _gcbaag != nil {
				return _gcbaag
			}
			_ggbcd.RemoveDataOnSaveAttr = &_aaecd
			continue
		}
		if _bddec.Name.Local == "applyWidthHeightFormats" {
			_efeba, _gbffgc := _g.ParseBool(_bddec.Value)
			if _gbffgc != nil {
				return _gbffgc
			}
			_ggbcd.ApplyWidthHeightFormatsAttr = &_efeba
			continue
		}
	}
_ffgdfd:
	for {
		_abbbg, _faaaa := d.Token()
		if _faaaa != nil {
			return _faaaa
		}
		switch _cdbdg := _abbbg.(type) {
		case _f.StartElement:
			switch _cdbdg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "queryTableRefresh"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "queryTableRefresh"}:
				_ggbcd.QueryTableRefresh = NewCT_QueryTableRefresh()
				if _dbafc := d.DecodeElement(_ggbcd.QueryTableRefresh, &_cdbdg); _dbafc != nil {
					return _dbafc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_ggbcd.ExtLst = NewCT_ExtensionList()
				if _edcfe := d.DecodeElement(_ggbcd.ExtLst, &_cdbdg); _edcfe != nil {
					return _edcfe
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020QueryTable\u0020\u0025v", _cdbdg.Name)
				if _eaagf := d.Skip(); _eaagf != nil {
					return _eaagf
				}
			}
		case _f.EndElement:
			break _ffgdfd
		case _f.CharData:
		}
	}
	return nil
}

type CT_VolType struct {

	// Type
	TypeAttr ST_VolDepType

	// Main
	Main []*CT_VolMain
}

func NewCT_GroupLevels() *CT_GroupLevels { _gbaae := &CT_GroupLevels{}; return _gbaae }
func NewCT_CalcCell() *CT_CalcCell       { _eadd := &CT_CalcCell{}; return _eadd }
func (_acadd *CT_Hyperlink) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _abbgf := range start.Attr {
		if _abbgf.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _abbgf.Name.Local == "id" || _abbgf.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _abbgf.Name.Local == "id" {
			_efdfc, _agfbb := _abbgf.Value, error(nil)
			if _agfbb != nil {
				return _agfbb
			}
			_acadd.IdAttr = &_efdfc
			continue
		}
		if _abbgf.Name.Local == "ref" {
			_fbeee, _fbcd := _abbgf.Value, error(nil)
			if _fbcd != nil {
				return _fbcd
			}
			_acadd.RefAttr = _fbeee
			continue
		}
		if _abbgf.Name.Local == "location" {
			_abbea, _efegc := _abbgf.Value, error(nil)
			if _efegc != nil {
				return _efegc
			}
			_acadd.LocationAttr = &_abbea
			continue
		}
		if _abbgf.Name.Local == "tooltip" {
			_ebagb, _cfgaa := _abbgf.Value, error(nil)
			if _cfgaa != nil {
				return _cfgaa
			}
			_acadd.TooltipAttr = &_ebagb
			continue
		}
		if _abbgf.Name.Local == "display" {
			_cbffe, _bacgd := _abbgf.Value, error(nil)
			if _bacgd != nil {
				return _bacgd
			}
			_acadd.DisplayAttr = &_cbffe
			continue
		}
	}
	for {
		_fffg, _dbegd := d.Token()
		if _dbegd != nil {
			return _bg.Errorf("parsing\u0020CT_Hyperlink:\u0020\u0025s", _dbegd)
		}
		if _ffeg, _gddg := _fffg.(_f.EndElement); _gddg && _ffeg.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_ReviewedRevisions() *CT_ReviewedRevisions {
	_deeeg := &CT_ReviewedRevisions{}
	return _deeeg
}
func (_dfbcc ST_PivotFilterType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_dbeffd := _f.Attr{}
	_dbeffd.Name = name
	switch _dfbcc {
	case ST_PivotFilterTypeUnset:
		_dbeffd.Value = ""
	case ST_PivotFilterTypeUnknown:
		_dbeffd.Value = "unknown"
	case ST_PivotFilterTypeCount:
		_dbeffd.Value = "count"
	case ST_PivotFilterTypePercent:
		_dbeffd.Value = "percent"
	case ST_PivotFilterTypeSum:
		_dbeffd.Value = "sum"
	case ST_PivotFilterTypeCaptionEqual:
		_dbeffd.Value = "captionEqual"
	case ST_PivotFilterTypeCaptionNotEqual:
		_dbeffd.Value = "captionNotEqual"
	case ST_PivotFilterTypeCaptionBeginsWith:
		_dbeffd.Value = "captionBeginsWith"
	case ST_PivotFilterTypeCaptionNotBeginsWith:
		_dbeffd.Value = "captionNotBeginsWith"
	case ST_PivotFilterTypeCaptionEndsWith:
		_dbeffd.Value = "captionEndsWith"
	case ST_PivotFilterTypeCaptionNotEndsWith:
		_dbeffd.Value = "captionNotEndsWith"
	case ST_PivotFilterTypeCaptionContains:
		_dbeffd.Value = "captionContains"
	case ST_PivotFilterTypeCaptionNotContains:
		_dbeffd.Value = "captionNotContains"
	case ST_PivotFilterTypeCaptionGreaterThan:
		_dbeffd.Value = "captionGreaterThan"
	case ST_PivotFilterTypeCaptionGreaterThanOrEqual:
		_dbeffd.Value = "captionGreaterThanOrEqual"
	case ST_PivotFilterTypeCaptionLessThan:
		_dbeffd.Value = "captionLessThan"
	case ST_PivotFilterTypeCaptionLessThanOrEqual:
		_dbeffd.Value = "captionLessThanOrEqual"
	case ST_PivotFilterTypeCaptionBetween:
		_dbeffd.Value = "captionBetween"
	case ST_PivotFilterTypeCaptionNotBetween:
		_dbeffd.Value = "captionNotBetween"
	case ST_PivotFilterTypeValueEqual:
		_dbeffd.Value = "valueEqual"
	case ST_PivotFilterTypeValueNotEqual:
		_dbeffd.Value = "valueNotEqual"
	case ST_PivotFilterTypeValueGreaterThan:
		_dbeffd.Value = "valueGreaterThan"
	case ST_PivotFilterTypeValueGreaterThanOrEqual:
		_dbeffd.Value = "valueGreaterThanOrEqual"
	case ST_PivotFilterTypeValueLessThan:
		_dbeffd.Value = "valueLessThan"
	case ST_PivotFilterTypeValueLessThanOrEqual:
		_dbeffd.Value = "valueLessThanOrEqual"
	case ST_PivotFilterTypeValueBetween:
		_dbeffd.Value = "valueBetween"
	case ST_PivotFilterTypeValueNotBetween:
		_dbeffd.Value = "valueNotBetween"
	case ST_PivotFilterTypeDateEqual:
		_dbeffd.Value = "dateEqual"
	case ST_PivotFilterTypeDateNotEqual:
		_dbeffd.Value = "dateNotEqual"
	case ST_PivotFilterTypeDateOlderThan:
		_dbeffd.Value = "dateOlderThan"
	case ST_PivotFilterTypeDateOlderThanOrEqual:
		_dbeffd.Value = "dateOlderThanOrEqual"
	case ST_PivotFilterTypeDateNewerThan:
		_dbeffd.Value = "dateNewerThan"
	case ST_PivotFilterTypeDateNewerThanOrEqual:
		_dbeffd.Value = "dateNewerThanOrEqual"
	case ST_PivotFilterTypeDateBetween:
		_dbeffd.Value = "dateBetween"
	case ST_PivotFilterTypeDateNotBetween:
		_dbeffd.Value = "dateNotBetween"
	case ST_PivotFilterTypeTomorrow:
		_dbeffd.Value = "tomorrow"
	case ST_PivotFilterTypeToday:
		_dbeffd.Value = "today"
	case ST_PivotFilterTypeYesterday:
		_dbeffd.Value = "yesterday"
	case ST_PivotFilterTypeNextWeek:
		_dbeffd.Value = "nextWeek"
	case ST_PivotFilterTypeThisWeek:
		_dbeffd.Value = "thisWeek"
	case ST_PivotFilterTypeLastWeek:
		_dbeffd.Value = "lastWeek"
	case ST_PivotFilterTypeNextMonth:
		_dbeffd.Value = "nextMonth"
	case ST_PivotFilterTypeThisMonth:
		_dbeffd.Value = "thisMonth"
	case ST_PivotFilterTypeLastMonth:
		_dbeffd.Value = "lastMonth"
	case ST_PivotFilterTypeNextQuarter:
		_dbeffd.Value = "nextQuarter"
	case ST_PivotFilterTypeThisQuarter:
		_dbeffd.Value = "thisQuarter"
	case ST_PivotFilterTypeLastQuarter:
		_dbeffd.Value = "lastQuarter"
	case ST_PivotFilterTypeNextYear:
		_dbeffd.Value = "nextYear"
	case ST_PivotFilterTypeThisYear:
		_dbeffd.Value = "thisYear"
	case ST_PivotFilterTypeLastYear:
		_dbeffd.Value = "lastYear"
	case ST_PivotFilterTypeYearToDate:
		_dbeffd.Value = "yearToDate"
	case ST_PivotFilterTypeQ1:
		_dbeffd.Value = "Q1"
	case ST_PivotFilterTypeQ2:
		_dbeffd.Value = "Q2"
	case ST_PivotFilterTypeQ3:
		_dbeffd.Value = "Q3"
	case ST_PivotFilterTypeQ4:
		_dbeffd.Value = "Q4"
	case ST_PivotFilterTypeM1:
		_dbeffd.Value = "M1"
	case ST_PivotFilterTypeM2:
		_dbeffd.Value = "M2"
	case ST_PivotFilterTypeM3:
		_dbeffd.Value = "M3"
	case ST_PivotFilterTypeM4:
		_dbeffd.Value = "M4"
	case ST_PivotFilterTypeM5:
		_dbeffd.Value = "M5"
	case ST_PivotFilterTypeM6:
		_dbeffd.Value = "M6"
	case ST_PivotFilterTypeM7:
		_dbeffd.Value = "M7"
	case ST_PivotFilterTypeM8:
		_dbeffd.Value = "M8"
	case ST_PivotFilterTypeM9:
		_dbeffd.Value = "M9"
	case ST_PivotFilterTypeM10:
		_dbeffd.Value = "M10"
	case ST_PivotFilterTypeM11:
		_dbeffd.Value = "M11"
	case ST_PivotFilterTypeM12:
		_dbeffd.Value = "M12"
	}
	return _dbeffd, nil
}
func (_ggded *CT_Schema) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ID"}, Value: _bg.Sprintf("\u0025v", _ggded.IDAttr)})
	if _ggded.SchemaRefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "SchemaRef"}, Value: _bg.Sprintf("\u0025v", *_ggded.SchemaRefAttr)})
	}
	if _ggded.NamespaceAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "Namespace"}, Value: _bg.Sprintf("\u0025v", *_ggded.NamespaceAttr)})
	}
	if _ggded.SchemaLanguageAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "SchemaLanguage"}, Value: _bg.Sprintf("\u0025v", *_ggded.SchemaLanguageAttr)})
	}
	e.EncodeToken(start)
	if _ggded.Any != nil {
		_ggded.Any.MarshalXML(e, _f.StartElement{})
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_adbdd *CT_RevisionSheetRename) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fbfdd := range start.Attr {
		if _fbfdd.Name.Local == "sheetId" {
			_adffb, _bdfdg := _g.ParseUint(_fbfdd.Value, 10, 32)
			if _bdfdg != nil {
				return _bdfdg
			}
			_adbdd.SheetIdAttr = uint32(_adffb)
			continue
		}
		if _fbfdd.Name.Local == "oldName" {
			_dcgdg, _fegfa := _fbfdd.Value, error(nil)
			if _fegfa != nil {
				return _fegfa
			}
			_adbdd.OldNameAttr = _dcgdg
			continue
		}
		if _fbfdd.Name.Local == "newName" {
			_geecg, _dgbab := _fbfdd.Value, error(nil)
			if _dgbab != nil {
				return _dgbab
			}
			_adbdd.NewNameAttr = _geecg
			continue
		}
		if _fbfdd.Name.Local == "rId" {
			_dbfdbg, _bbabe := _g.ParseUint(_fbfdd.Value, 10, 32)
			if _bbabe != nil {
				return _bbabe
			}
			_fdeabe := uint32(_dbfdbg)
			_adbdd.RIdAttr = &_fdeabe
			continue
		}
		if _fbfdd.Name.Local == "ua" {
			_dbfcd, _caaec := _g.ParseBool(_fbfdd.Value)
			if _caaec != nil {
				return _caaec
			}
			_adbdd.UaAttr = &_dbfcd
			continue
		}
		if _fbfdd.Name.Local == "ra" {
			_cebea, _geddd := _g.ParseBool(_fbfdd.Value)
			if _geddd != nil {
				return _geddd
			}
			_adbdd.RaAttr = &_cebea
			continue
		}
	}
_ecgeb:
	for {
		_bbdcc, _cfccac := d.Token()
		if _cfccac != nil {
			return _cfccac
		}
		switch _fgfga := _bbdcc.(type) {
		case _f.StartElement:
			switch _fgfga.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_adbdd.ExtLst = NewCT_ExtensionList()
				if _fdgdd := d.DecodeElement(_adbdd.ExtLst, &_fgfga); _fdgdd != nil {
					return _fdgdd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RevisionSheetRename\u0020\u0025v", _fgfga.Name)
				if _abbfec := d.Skip(); _abbfec != nil {
					return _abbfec
				}
			}
		case _f.EndElement:
			break _ecgeb
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_IconFilter() *CT_IconFilter {
	_gegfe := &CT_IconFilter{}
	_gegfe.IconSetAttr = ST_IconSetType(1)
	return _gegfe
}
func (_cddcag ST_Visibility) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_cddcag.String(), start)
}

// Validate validates the CT_RevisionFormatting and its children
func (_bfddb *CT_RevisionFormatting) Validate() error {
	return _bfddb.ValidateWithPath("CT_RevisionFormatting")
}
func (_eab *CT_Border) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _eab.DiagonalUpAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "diagonalUp"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eab.DiagonalUpAttr))})
	}
	if _eab.DiagonalDownAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "diagonalDown"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eab.DiagonalDownAttr))})
	}
	if _eab.OutlineAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "outline"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_eab.OutlineAttr))})
	}
	e.EncodeToken(start)
	if _eab.Start != nil {
		_bdbb := _f.StartElement{Name: _f.Name{Local: "ma:start"}}
		e.EncodeElement(_eab.Start, _bdbb)
	}
	if _eab.End != nil {
		_fdab := _f.StartElement{Name: _f.Name{Local: "ma:end"}}
		e.EncodeElement(_eab.End, _fdab)
	}
	if _eab.Left != nil {
		_cff := _f.StartElement{Name: _f.Name{Local: "ma:left"}}
		e.EncodeElement(_eab.Left, _cff)
	}
	if _eab.Right != nil {
		_bbd := _f.StartElement{Name: _f.Name{Local: "ma:right"}}
		e.EncodeElement(_eab.Right, _bbd)
	}
	if _eab.Top != nil {
		_eac := _f.StartElement{Name: _f.Name{Local: "ma:top"}}
		e.EncodeElement(_eab.Top, _eac)
	}
	if _eab.Bottom != nil {
		_abbd := _f.StartElement{Name: _f.Name{Local: "ma:bottom"}}
		e.EncodeElement(_eab.Bottom, _abbd)
	}
	if _eab.Diagonal != nil {
		_gdf := _f.StartElement{Name: _f.Name{Local: "ma:diagonal"}}
		e.EncodeElement(_eab.Diagonal, _gdf)
	}
	if _eab.Vertical != nil {
		_ded := _f.StartElement{Name: _f.Name{Local: "ma:vertical"}}
		e.EncodeElement(_eab.Vertical, _ded)
	}
	if _eab.Horizontal != nil {
		_ged := _f.StartElement{Name: _f.Name{Local: "ma:horizontal"}}
		e.EncodeElement(_eab.Horizontal, _ged)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_feba *CT_CalcCell) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cgaa := range start.Attr {
		if _cgaa.Name.Local == "r" {
			_egcc, _gdgg := _cgaa.Value, error(nil)
			if _gdgg != nil {
				return _gdgg
			}
			_feba.RAttr = &_egcc
			continue
		}
		if _cgaa.Name.Local == "ref" {
			_eea, _caad := _cgaa.Value, error(nil)
			if _caad != nil {
				return _caad
			}
			_feba.RefAttr = &_eea
			continue
		}
		if _cgaa.Name.Local == "i" {
			_feace, _gabg := _g.ParseInt(_cgaa.Value, 10, 32)
			if _gabg != nil {
				return _gabg
			}
			_egfg := int32(_feace)
			_feba.IAttr = &_egfg
			continue
		}
		if _cgaa.Name.Local == "s" {
			_daad, _badd := _g.ParseBool(_cgaa.Value)
			if _badd != nil {
				return _badd
			}
			_feba.SAttr = &_daad
			continue
		}
		if _cgaa.Name.Local == "l" {
			_gfc, _cfga := _g.ParseBool(_cgaa.Value)
			if _cfga != nil {
				return _cfga
			}
			_feba.LAttr = &_gfc
			continue
		}
		if _cgaa.Name.Local == "t" {
			_ddfd, _aee := _g.ParseBool(_cgaa.Value)
			if _aee != nil {
				return _aee
			}
			_feba.TAttr = &_ddfd
			continue
		}
		if _cgaa.Name.Local == "a" {
			_bbc, _gbdg := _g.ParseBool(_cgaa.Value)
			if _gbdg != nil {
				return _gbdg
			}
			_feba.AAttr = &_bbc
			continue
		}
	}
	for {
		_bdag, _afed := d.Token()
		if _afed != nil {
			return _bg.Errorf("parsing\u0020CT_CalcCell:\u0020\u0025s", _afed)
		}
		if _cgda, _dgdb := _bdag.(_f.EndElement); _dgdb && _cgda.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dfaed *CT_FontSize) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gfged := range start.Attr {
		if _gfged.Name.Local == "val" {
			_ffca, _abge := _g.ParseFloat(_gfged.Value, 64)
			if _abge != nil {
				return _abge
			}
			_dfaed.ValAttr = _ffca
			continue
		}
	}
	for {
		_fcedg, _adadb := d.Token()
		if _adadb != nil {
			return _bg.Errorf("parsing\u0020CT_FontSize:\u0020\u0025s", _adadb)
		}
		if _cdagc, _cbecc := _fcedg.(_f.EndElement); _cbecc && _cdagc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_acgbe *CT_Members) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _acgbe.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_acgbe.CountAttr)})
	}
	if _acgbe.LevelAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "level"}, Value: _bg.Sprintf("\u0025v", *_acgbe.LevelAttr)})
	}
	e.EncodeToken(start)
	_bcbeb := _f.StartElement{Name: _f.Name{Local: "ma:member"}}
	for _, _aedff := range _acgbe.Member {
		e.EncodeElement(_aedff, _bcbeb)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_Location struct {

	// Reference
	RefAttr string

	// First Header Row
	FirstHeaderRowAttr uint32

	// PivotTable Data First Row
	FirstDataRowAttr uint32

	// First Data Column
	FirstDataColAttr uint32

	// Rows Per Page Count
	RowPageCountAttr *uint32

	// Columns Per Page
	ColPageCountAttr *uint32
}

// ValidateWithPath validates the CT_DataValidations and its children, prefixing error messages with path
func (_bbdbg *CT_DataValidations) ValidateWithPath(path string) error {
	for _aceg, _ggdbg := range _bbdbg.DataValidation {
		if _daeba := _ggdbg.ValidateWithPath(_bg.Sprintf("%s\u002fDataValidation\u005b\u0025d\u005d", path, _aceg)); _daeba != nil {
			return _daeba
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Macrosheet and its children, prefixing error messages with path
func (_adecg *CT_Macrosheet) ValidateWithPath(path string) error {
	if _adecg.SheetPr != nil {
		if _fdfe := _adecg.SheetPr.ValidateWithPath(path + "\u002fSheetPr"); _fdfe != nil {
			return _fdfe
		}
	}
	if _adecg.Dimension != nil {
		if _gceea := _adecg.Dimension.ValidateWithPath(path + "\u002fDimension"); _gceea != nil {
			return _gceea
		}
	}
	if _adecg.SheetViews != nil {
		if _fgbcc := _adecg.SheetViews.ValidateWithPath(path + "/SheetViews"); _fgbcc != nil {
			return _fgbcc
		}
	}
	if _adecg.SheetFormatPr != nil {
		if _fabee := _adecg.SheetFormatPr.ValidateWithPath(path + "\u002fSheetFormatPr"); _fabee != nil {
			return _fabee
		}
	}
	for _cdbfc, _gcfbe := range _adecg.Cols {
		if _fcaagg := _gcfbe.ValidateWithPath(_bg.Sprintf("%s\u002fCols\u005b\u0025d\u005d", path, _cdbfc)); _fcaagg != nil {
			return _fcaagg
		}
	}
	if _ebcac := _adecg.SheetData.ValidateWithPath(path + "\u002fSheetData"); _ebcac != nil {
		return _ebcac
	}
	if _adecg.SheetProtection != nil {
		if _egcba := _adecg.SheetProtection.ValidateWithPath(path + "\u002fSheetProtection"); _egcba != nil {
			return _egcba
		}
	}
	if _adecg.AutoFilter != nil {
		if _eebaga := _adecg.AutoFilter.ValidateWithPath(path + "/AutoFilter"); _eebaga != nil {
			return _eebaga
		}
	}
	if _adecg.SortState != nil {
		if _gbgdf := _adecg.SortState.ValidateWithPath(path + "\u002fSortState"); _gbgdf != nil {
			return _gbgdf
		}
	}
	if _adecg.DataConsolidate != nil {
		if _efcgf := _adecg.DataConsolidate.ValidateWithPath(path + "\u002fDataConsolidate"); _efcgf != nil {
			return _efcgf
		}
	}
	if _adecg.CustomSheetViews != nil {
		if _cgbga := _adecg.CustomSheetViews.ValidateWithPath(path + "\u002fCustomSheetViews"); _cgbga != nil {
			return _cgbga
		}
	}
	if _adecg.PhoneticPr != nil {
		if _debd := _adecg.PhoneticPr.ValidateWithPath(path + "/PhoneticPr"); _debd != nil {
			return _debd
		}
	}
	for _fbcg, _bfeca := range _adecg.ConditionalFormatting {
		if _afcaf := _bfeca.ValidateWithPath(_bg.Sprintf("\u0025s\u002fConditionalFormatting\u005b%d\u005d", path, _fbcg)); _afcaf != nil {
			return _afcaf
		}
	}
	if _adecg.PrintOptions != nil {
		if _fcebd := _adecg.PrintOptions.ValidateWithPath(path + "\u002fPrintOptions"); _fcebd != nil {
			return _fcebd
		}
	}
	if _adecg.PageMargins != nil {
		if _acadc := _adecg.PageMargins.ValidateWithPath(path + "\u002fPageMargins"); _acadc != nil {
			return _acadc
		}
	}
	if _adecg.PageSetup != nil {
		if _gddge := _adecg.PageSetup.ValidateWithPath(path + "\u002fPageSetup"); _gddge != nil {
			return _gddge
		}
	}
	if _adecg.HeaderFooter != nil {
		if _ffcfc := _adecg.HeaderFooter.ValidateWithPath(path + "\u002fHeaderFooter"); _ffcfc != nil {
			return _ffcfc
		}
	}
	if _adecg.RowBreaks != nil {
		if _bbfc := _adecg.RowBreaks.ValidateWithPath(path + "\u002fRowBreaks"); _bbfc != nil {
			return _bbfc
		}
	}
	if _adecg.ColBreaks != nil {
		if _dbgcg := _adecg.ColBreaks.ValidateWithPath(path + "\u002fColBreaks"); _dbgcg != nil {
			return _dbgcg
		}
	}
	if _adecg.CustomProperties != nil {
		if _agbe := _adecg.CustomProperties.ValidateWithPath(path + "\u002fCustomProperties"); _agbe != nil {
			return _agbe
		}
	}
	if _adecg.Drawing != nil {
		if _dffda := _adecg.Drawing.ValidateWithPath(path + "\u002fDrawing"); _dffda != nil {
			return _dffda
		}
	}
	if _adecg.LegacyDrawing != nil {
		if _ffdeg := _adecg.LegacyDrawing.ValidateWithPath(path + "\u002fLegacyDrawing"); _ffdeg != nil {
			return _ffdeg
		}
	}
	if _adecg.LegacyDrawingHF != nil {
		if _bfgad := _adecg.LegacyDrawingHF.ValidateWithPath(path + "\u002fLegacyDrawingHF"); _bfgad != nil {
			return _bfgad
		}
	}
	if _adecg.DrawingHF != nil {
		if _dadda := _adecg.DrawingHF.ValidateWithPath(path + "\u002fDrawingHF"); _dadda != nil {
			return _dadda
		}
	}
	if _adecg.Picture != nil {
		if _egccg := _adecg.Picture.ValidateWithPath(path + "\u002fPicture"); _egccg != nil {
			return _egccg
		}
	}
	if _adecg.OleObjects != nil {
		if _feeed := _adecg.OleObjects.ValidateWithPath(path + "/OleObjects"); _feeed != nil {
			return _feeed
		}
	}
	if _adecg.ExtLst != nil {
		if _eeaeg := _adecg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eeaeg != nil {
			return _eeaeg
		}
	}
	return nil
}

// Validate validates the CT_Top10 and its children
func (_ccadef *CT_Top10) Validate() error        { return _ccadef.ValidateWithPath("CT_Top10") }
func NewCT_BooleanProperty() *CT_BooleanProperty { _ebd := &CT_BooleanProperty{}; return _ebd }

type ST_DataValidationOperator byte

// ValidateWithPath validates the CT_RevisionAutoFormatting and its children, prefixing error messages with path
func (_faaff *CT_RevisionAutoFormatting) ValidateWithPath(path string) error { return nil }

// Validate validates the EG_ExtensionList and its children
func (_gbcfcc *EG_ExtensionList) Validate() error {
	return _gbcfcc.ValidateWithPath("EG_ExtensionList")
}

// Validate validates the CT_ExternalSheetNames and its children
func (_bbfga *CT_ExternalSheetNames) Validate() error {
	return _bbfga.ValidateWithPath("CT_ExternalSheetNames")
}
func (_bcced *CT_XmlPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _acgcdb := range start.Attr {
		if _acgcdb.Name.Local == "mapId" {
			_bfbgb, _acbcb := _g.ParseUint(_acgcdb.Value, 10, 32)
			if _acbcb != nil {
				return _acbcb
			}
			_bcced.MapIdAttr = uint32(_bfbgb)
			continue
		}
		if _acgcdb.Name.Local == "xpath" {
			_egeagg, _aeadd := _acgcdb.Value, error(nil)
			if _aeadd != nil {
				return _aeadd
			}
			_bcced.XpathAttr = _egeagg
			continue
		}
		if _acgcdb.Name.Local == "xmlDataType" {
			_gfgbee, _dbbac := _acgcdb.Value, error(nil)
			if _dbbac != nil {
				return _dbbac
			}
			_bcced.XmlDataTypeAttr = _gfgbee
			continue
		}
	}
_faeda:
	for {
		_fdbea, _bgbccc := d.Token()
		if _bgbccc != nil {
			return _bgbccc
		}
		switch _bgcgcc := _fdbea.(type) {
		case _f.StartElement:
			switch _bgcgcc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_bcced.ExtLst = NewCT_ExtensionList()
				if _edcaccd := d.DecodeElement(_bcced.ExtLst, &_bgcgcc); _edcaccd != nil {
					return _edcaccd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_XmlPr\u0020\u0025v", _bgcgcc.Name)
				if _ccbbdc := d.Skip(); _ccbbdc != nil {
					return _ccbbdc
				}
			}
		case _f.EndElement:
			break _faeda
		case _f.CharData:
		}
	}
	return nil
}
func (_aebabg *CT_String) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "v"}, Value: _bg.Sprintf("\u0025v", _aebabg.VAttr)})
	if _aebabg.UAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "u"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aebabg.UAttr))})
	}
	if _aebabg.FAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "f"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aebabg.FAttr))})
	}
	if _aebabg.CAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "c"}, Value: _bg.Sprintf("\u0025v", *_aebabg.CAttr)})
	}
	if _aebabg.CpAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cp"}, Value: _bg.Sprintf("\u0025v", *_aebabg.CpAttr)})
	}
	if _aebabg.InAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "in"}, Value: _bg.Sprintf("\u0025v", *_aebabg.InAttr)})
	}
	if _aebabg.BcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "bc"}, Value: _bg.Sprintf("\u0025v", *_aebabg.BcAttr)})
	}
	if _aebabg.FcAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fc"}, Value: _bg.Sprintf("\u0025v", *_aebabg.FcAttr)})
	}
	if _aebabg.IAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "i"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aebabg.IAttr))})
	}
	if _aebabg.UnAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "un"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aebabg.UnAttr))})
	}
	if _aebabg.StAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "st"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aebabg.StAttr))})
	}
	if _aebabg.BAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "b"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aebabg.BAttr))})
	}
	e.EncodeToken(start)
	if _aebabg.Tpls != nil {
		_dadced := _f.StartElement{Name: _f.Name{Local: "ma:tpls"}}
		for _, _bdaad := range _aebabg.Tpls {
			e.EncodeElement(_bdaad, _dadced)
		}
	}
	if _aebabg.X != nil {
		_cgcegf := _f.StartElement{Name: _f.Name{Local: "ma:x"}}
		for _, _gbfgb := range _aebabg.X {
			e.EncodeElement(_gbfgb, _cgcegf)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type Comments struct{ CT_Comments }

func (_decadc ST_PivotAreaType) Validate() error { return _decadc.ValidateWithPath("") }
func (_efgfef *CT_QueryCache) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _efgfef.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_efgfef.CountAttr)})
	}
	e.EncodeToken(start)
	_bagcef := _f.StartElement{Name: _f.Name{Local: "ma:query"}}
	for _, _ggcca := range _efgfef.Query {
		e.EncodeElement(_ggcca, _bagcef)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_RowHierarchiesUsage and its children, prefixing error messages with path
func (_deaf *CT_RowHierarchiesUsage) ValidateWithPath(path string) error {
	for _dfgggb, _bccba := range _deaf.RowHierarchyUsage {
		if _gffad := _bccba.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRowHierarchyUsage\u005b\u0025d\u005d", path, _dfgggb)); _gffad != nil {
			return _gffad
		}
	}
	return nil
}
func (_befceb ST_ItemType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_befceb.String(), start)
}

// Validate validates the CT_FunctionGroups and its children
func (_gecfc *CT_FunctionGroups) Validate() error {
	return _gecfc.ValidateWithPath("CT_FunctionGroups")
}

// Validate validates the CT_RevisionInsertSheet and its children
func (_gddagf *CT_RevisionInsertSheet) Validate() error {
	return _gddagf.ValidateWithPath("CT_RevisionInsertSheet")
}

// Validate validates the CT_SingleXmlCell and its children
func (_eebd *CT_SingleXmlCell) Validate() error { return _eebd.ValidateWithPath("CT_SingleXmlCell") }
func (_bedbg ST_TextVAlign) String() string {
	switch _bedbg {
	case 0:
		return ""
	case 1:
		return "top"
	case 2:
		return "center"
	case 3:
		return "bottom"
	case 4:
		return "justify"
	case 5:
		return "distributed"
	}
	return ""
}
func (_bacgf *CT_DataValidations) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fgab := range start.Attr {
		if _fgab.Name.Local == "disablePrompts" {
			_acfdda, _dgcec := _g.ParseBool(_fgab.Value)
			if _dgcec != nil {
				return _dgcec
			}
			_bacgf.DisablePromptsAttr = &_acfdda
			continue
		}
		if _fgab.Name.Local == "xWindow" {
			_bddef, _fgcdc := _g.ParseUint(_fgab.Value, 10, 32)
			if _fgcdc != nil {
				return _fgcdc
			}
			_gfeedc := uint32(_bddef)
			_bacgf.XWindowAttr = &_gfeedc
			continue
		}
		if _fgab.Name.Local == "yWindow" {
			_bdad, _bcdge := _g.ParseUint(_fgab.Value, 10, 32)
			if _bcdge != nil {
				return _bcdge
			}
			_cebag := uint32(_bdad)
			_bacgf.YWindowAttr = &_cebag
			continue
		}
		if _fgab.Name.Local == "count" {
			_dadddc, _fbacc := _g.ParseUint(_fgab.Value, 10, 32)
			if _fbacc != nil {
				return _fbacc
			}
			_aeec := uint32(_dadddc)
			_bacgf.CountAttr = &_aeec
			continue
		}
	}
_dfddg:
	for {
		_edag, _eecd := d.Token()
		if _eecd != nil {
			return _eecd
		}
		switch _fddef := _edag.(type) {
		case _f.StartElement:
			switch _fddef.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "dataValidation"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "dataValidation"}:
				_edcd := NewCT_DataValidation()
				if _ggdcd := d.DecodeElement(_edcd, &_fddef); _ggdcd != nil {
					return _ggdcd
				}
				_bacgf.DataValidation = append(_bacgf.DataValidation, _edcd)
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_DataValidations\u0020\u0025v", _fddef.Name)
				if _fgac := d.Skip(); _fgac != nil {
					return _fgac
				}
			}
		case _f.EndElement:
			break _dfddg
		case _f.CharData:
		}
	}
	return nil
}
func (_dfebdg *CT_SmartTagType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dfebdg.NamespaceUriAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "namespaceUri"}, Value: _bg.Sprintf("\u0025v", *_dfebdg.NamespaceUriAttr)})
	}
	if _dfebdg.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_dfebdg.NameAttr)})
	}
	if _dfebdg.UrlAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "url"}, Value: _bg.Sprintf("\u0025v", *_dfebdg.UrlAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type ST_Scope byte
type CT_QueryTableField struct {

	// Field Id
	IdAttr uint32

	// Name
	NameAttr *string

	// Data Bound Column
	DataBoundAttr *bool

	// Row Numbers
	RowNumbersAttr *bool

	// Fill This Formula On Refresh
	FillFormulasAttr *bool

	// Clipped Column
	ClippedAttr *bool

	// Table Column Id
	TableColumnIdAttr *uint32

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}
type CT_SharedItems struct {

	// Contains Semi Mixed Data Types
	ContainsSemiMixedTypesAttr *bool

	// Contains Non Date
	ContainsNonDateAttr *bool

	// Contains Date
	ContainsDateAttr *bool

	// Contains String
	ContainsStringAttr *bool

	// Contains Blank
	ContainsBlankAttr *bool

	// Contains Mixed Data Types
	ContainsMixedTypesAttr *bool

	// Contains Numbers
	ContainsNumberAttr *bool

	// Contains Integer
	ContainsIntegerAttr *bool

	// Minimum Numeric Value
	MinValueAttr *float64

	// Maximum Numeric Value
	MaxValueAttr *float64

	// Minimum Date Time
	MinDateAttr *_b.Time

	// Maximum Date Time Value
	MaxDateAttr *_b.Time

	// Shared Items Count
	CountAttr *uint32

	// Long Text
	LongTextAttr *bool

	// No Value
	M []*CT_Missing

	// Numeric
	N []*CT_Number

	// Boolean
	B []*CT_Boolean

	// Error Value
	E []*CT_Error

	// Character Value
	S []*CT_String

	// Date Time
	D []*CT_DateTime
}

// Validate validates the CT_DdeValue and its children
func (_eabbc *CT_DdeValue) Validate() error { return _eabbc.ValidateWithPath("CT_DdeValue") }

// Validate validates the CT_MapInfo and its children
func (_aaeef *CT_MapInfo) Validate() error { return _aaeef.ValidateWithPath("CT_MapInfo") }
func NewCT_ConditionalFormats() *CT_ConditionalFormats {
	_fgdg := &CT_ConditionalFormats{}
	return _fgdg
}
func (_dfgdgg *ST_Axis) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_dfgdgg = 0
	case "axisRow":
		*_dfgdgg = 1
	case "axisCol":
		*_dfgdgg = 2
	case "axisPage":
		*_dfgdgg = 3
	case "axisValues":
		*_dfgdgg = 4
	}
	return nil
}
func (_bfbbfe *CT_Top10) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bfbbfe.TopAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "top"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bfbbfe.TopAttr))})
	}
	if _bfbbfe.PercentAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "percent"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bfbbfe.PercentAttr))})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "val"}, Value: _bg.Sprintf("\u0025v", _bfbbfe.ValAttr)})
	if _bfbbfe.FilterValAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "filterVal"}, Value: _bg.Sprintf("\u0025v", *_bfbbfe.FilterValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Extension and its children
func (_dbcb *CT_Extension) Validate() error { return _dbcb.ValidateWithPath("CT_Extension") }

// ValidateWithPath validates the Connections and its children, prefixing error messages with path
func (_addfc *Connections) ValidateWithPath(path string) error {
	if _gbeef := _addfc.CT_Connections.ValidateWithPath(path); _gbeef != nil {
		return _gbeef
	}
	return nil
}

type ST_DvAspect byte
type CT_Border struct {

	// Diagonal Up
	DiagonalUpAttr *bool

	// Diagonal Down
	DiagonalDownAttr *bool

	// Outline
	OutlineAttr *bool

	// Leading Edge Border
	Start *CT_BorderPr

	// Trailing Edge Border
	End *CT_BorderPr

	// Leading Edge Border
	Left *CT_BorderPr

	// Trailing Edge Border
	Right *CT_BorderPr

	// Top Border
	Top *CT_BorderPr

	// Bottom Border
	Bottom *CT_BorderPr

	// Diagonal
	Diagonal *CT_BorderPr

	// Vertical Inner Border
	Vertical *CT_BorderPr

	// Horizontal Inner Borders
	Horizontal *CT_BorderPr
}

// Validate validates the CT_ChartFormat and its children
func (_aabb *CT_ChartFormat) Validate() error { return _aabb.ValidateWithPath("CT_ChartFormat") }
func (_dcccaa *CT_Selection) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _dcccaa.PaneAttr != ST_PaneUnset {
		_abddd, _ecgefd := _dcccaa.PaneAttr.MarshalXMLAttr(_f.Name{Local: "pane"})
		if _ecgefd != nil {
			return _ecgefd
		}
		start.Attr = append(start.Attr, _abddd)
	}
	if _dcccaa.ActiveCellAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "activeCell"}, Value: _bg.Sprintf("\u0025v", *_dcccaa.ActiveCellAttr)})
	}
	if _dcccaa.ActiveCellIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "activeCellId"}, Value: _bg.Sprintf("\u0025v", *_dcccaa.ActiveCellIdAttr)})
	}
	if _dcccaa.SqrefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sqref"}, Value: _bg.Sprintf("\u0025v", *_dcccaa.SqrefAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_cdef *CT_ChartsheetView) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gcbg := range start.Attr {
		if _gcbg.Name.Local == "tabSelected" {
			_bgdd, _bgadbg := _g.ParseBool(_gcbg.Value)
			if _bgadbg != nil {
				return _bgadbg
			}
			_cdef.TabSelectedAttr = &_bgdd
			continue
		}
		if _gcbg.Name.Local == "zoomScale" {
			_fgeb, _ceeb := _g.ParseUint(_gcbg.Value, 10, 32)
			if _ceeb != nil {
				return _ceeb
			}
			_afgd := uint32(_fgeb)
			_cdef.ZoomScaleAttr = &_afgd
			continue
		}
		if _gcbg.Name.Local == "workbookViewId" {
			_egg, _cbgf := _g.ParseUint(_gcbg.Value, 10, 32)
			if _cbgf != nil {
				return _cbgf
			}
			_cdef.WorkbookViewIdAttr = uint32(_egg)
			continue
		}
		if _gcbg.Name.Local == "zoomToFit" {
			_defc, _cbdfg := _g.ParseBool(_gcbg.Value)
			if _cbdfg != nil {
				return _cbdfg
			}
			_cdef.ZoomToFitAttr = &_defc
			continue
		}
	}
_ddga:
	for {
		_fgad, _aabd := d.Token()
		if _aabd != nil {
			return _aabd
		}
		switch _aced := _fgad.(type) {
		case _f.StartElement:
			switch _aced.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_cdef.ExtLst = NewCT_ExtensionList()
				if _bdae := d.DecodeElement(_cdef.ExtLst, &_aced); _bdae != nil {
					return _bdae
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_ChartsheetView\u0020\u0025v", _aced.Name)
				if _gedc := d.Skip(); _gedc != nil {
					return _gedc
				}
			}
		case _f.EndElement:
			break _ddga
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Query and its children
func (_befbd *CT_Query) Validate() error                { return _befbd.ValidateWithPath("CT_Query") }
func (_gafc ST_DataValidationOperator) Validate() error { return _gafc.ValidateWithPath("") }

type CT_X struct {

	// Shared Items Index
	VAttr *int32
}

// ValidateWithPath validates the CT_IconFilter and its children, prefixing error messages with path
func (_edeaaf *CT_IconFilter) ValidateWithPath(path string) error {
	if _edeaaf.IconSetAttr == ST_IconSetTypeUnset {
		return _bg.Errorf("%s\u002fIconSetAttr is\u0020a\u0020mandatory\u0020field", path)
	}
	if _dbfeec := _edeaaf.IconSetAttr.ValidateWithPath(path + "\u002fIconSetAttr"); _dbfeec != nil {
		return _dbfeec
	}
	return nil
}

// Validate validates the CT_GroupItems and its children
func (_efadf *CT_GroupItems) Validate() error { return _efadf.ValidateWithPath("CT_GroupItems") }

// Validate validates the CT_MergeCell and its children
func (_dffg *CT_MergeCell) Validate() error { return _dffg.ValidateWithPath("CT_MergeCell") }

// ValidateWithPath validates the CT_PivotFilter and its children, prefixing error messages with path
func (_gdbg *CT_PivotFilter) ValidateWithPath(path string) error {
	if _gdbg.TypeAttr == ST_PivotFilterTypeUnset {
		return _bg.Errorf("\u0025s\u002fTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bgadd := _gdbg.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _bgadd != nil {
		return _bgadd
	}
	if _fegfde := _gdbg.AutoFilter.ValidateWithPath(path + "/AutoFilter"); _fegfde != nil {
		return _fegfde
	}
	if _gdbg.ExtLst != nil {
		if _dbbed := _gdbg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dbbed != nil {
			return _dbbed
		}
	}
	return nil
}
func NewCT_ExternalSheetName() *CT_ExternalSheetName {
	_aacbf := &CT_ExternalSheetName{}
	return _aacbf
}
func (_feggc *CT_InputCells) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fcbdd := range start.Attr {
		if _fcbdd.Name.Local == "r" {
			_gcfbb, _caggbg := _fcbdd.Value, error(nil)
			if _caggbg != nil {
				return _caggbg
			}
			_feggc.RAttr = _gcfbb
			continue
		}
		if _fcbdd.Name.Local == "deleted" {
			_gfcfd, _cgfef := _g.ParseBool(_fcbdd.Value)
			if _cgfef != nil {
				return _cgfef
			}
			_feggc.DeletedAttr = &_gfcfd
			continue
		}
		if _fcbdd.Name.Local == "undone" {
			_aegffc, _cegae := _g.ParseBool(_fcbdd.Value)
			if _cegae != nil {
				return _cegae
			}
			_feggc.UndoneAttr = &_aegffc
			continue
		}
		if _fcbdd.Name.Local == "val" {
			_gadc, _bbddc := _fcbdd.Value, error(nil)
			if _bbddc != nil {
				return _bbddc
			}
			_feggc.ValAttr = _gadc
			continue
		}
		if _fcbdd.Name.Local == "numFmtId" {
			_fbace, _cffgb := _g.ParseUint(_fcbdd.Value, 10, 32)
			if _cffgb != nil {
				return _cffgb
			}
			_dbfdg := uint32(_fbace)
			_feggc.NumFmtIdAttr = &_dbfdg
			continue
		}
	}
	for {
		_agfbba, _fecec := d.Token()
		if _fecec != nil {
			return _bg.Errorf("parsing\u0020CT_InputCells:\u0020\u0025s", _fecec)
		}
		if _acfgd, _aaac := _agfbba.(_f.EndElement); _aaac && _acfgd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_adgbg *CT_SmartTagTypes) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_edbbf:
	for {
		_bfbbga, _gceac := d.Token()
		if _gceac != nil {
			return _gceac
		}
		switch _aeffc := _bfbbga.(type) {
		case _f.StartElement:
			switch _aeffc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "smartTagType"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "smartTagType"}:
				_fbcbg := NewCT_SmartTagType()
				if _abdae := d.DecodeElement(_fbcbg, &_aeffc); _abdae != nil {
					return _abdae
				}
				_adgbg.SmartTagType = append(_adgbg.SmartTagType, _fbcbg)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SmartTagTypes\u0020\u0025v", _aeffc.Name)
				if _dbbcbb := d.Skip(); _dbbcbb != nil {
					return _dbbcbb
				}
			}
		case _f.EndElement:
			break _edbbf
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_RevisionCellChange and its children, prefixing error messages with path
func (_afgee *CT_RevisionCellChange) ValidateWithPath(path string) error {
	if _afgee.Oc != nil {
		if _edadc := _afgee.Oc.ValidateWithPath(path + "\u002fOc"); _edadc != nil {
			return _edadc
		}
	}
	if _gacee := _afgee.Nc.ValidateWithPath(path + "\u002fNc"); _gacee != nil {
		return _gacee
	}
	if _afgee.Odxf != nil {
		if _dbdce := _afgee.Odxf.ValidateWithPath(path + "\u002fOdxf"); _dbdce != nil {
			return _dbdce
		}
	}
	if _afgee.Ndxf != nil {
		if _ccggd := _afgee.Ndxf.ValidateWithPath(path + "\u002fNdxf"); _ccggd != nil {
			return _ccggd
		}
	}
	if _afgee.ExtLst != nil {
		if _efcab := _afgee.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _efcab != nil {
			return _efcab
		}
	}
	return nil
}
func (_agebe *CT_ExternalReferences) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	_egeag := _f.StartElement{Name: _f.Name{Local: "ma:externalReference"}}
	for _, _bccfc := range _agebe.ExternalReference {
		e.EncodeElement(_bccfc, _egeag)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type ST_BorderStyle byte

// Validate validates the CT_GroupLevels and its children
func (_cgfg *CT_GroupLevels) Validate() error { return _cgfg.ValidateWithPath("CT_GroupLevels") }
func (_gbfge *Connections) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:connections"
	return _gbfge.CT_Connections.MarshalXML(e, start)
}
func (_decba *CT_RevisionSheetRename) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheetId"}, Value: _bg.Sprintf("\u0025v", _decba.SheetIdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "oldName"}, Value: _bg.Sprintf("\u0025v", _decba.OldNameAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "newName"}, Value: _bg.Sprintf("\u0025v", _decba.NewNameAttr)})
	if _decba.RIdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "rId"}, Value: _bg.Sprintf("\u0025v", *_decba.RIdAttr)})
	}
	if _decba.UaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ua"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_decba.UaAttr))})
	}
	if _decba.RaAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ra"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_decba.RaAttr))})
	}
	e.EncodeToken(start)
	if _decba.ExtLst != nil {
		_dfgae := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_decba.ExtLst, _dfgae)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_MetadataBlock and its children, prefixing error messages with path
func (_adccfd *CT_MetadataBlock) ValidateWithPath(path string) error {
	for _cfdc, _abefd := range _adccfd.Rc {
		if _cfebd := _abefd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRc\u005b\u0025d]", path, _cfdc)); _cfebd != nil {
			return _cfebd
		}
	}
	return nil
}
func NewCT_FieldsUsage() *CT_FieldsUsage { _bbca := &CT_FieldsUsage{}; return _bbca }
func (_befdc *CT_RangeSet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _befdc.I1Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "i1"}, Value: _bg.Sprintf("\u0025v", *_befdc.I1Attr)})
	}
	if _befdc.I2Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "i2"}, Value: _bg.Sprintf("\u0025v", *_befdc.I2Attr)})
	}
	if _befdc.I3Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "i3"}, Value: _bg.Sprintf("\u0025v", *_befdc.I3Attr)})
	}
	if _befdc.I4Attr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "i4"}, Value: _bg.Sprintf("\u0025v", *_befdc.I4Attr)})
	}
	if _befdc.RefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "ref"}, Value: _bg.Sprintf("\u0025v", *_befdc.RefAttr)})
	}
	if _befdc.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_befdc.NameAttr)})
	}
	if _befdc.SheetAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sheet"}, Value: _bg.Sprintf("\u0025v", *_befdc.SheetAttr)})
	}
	if _befdc.IdAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "r:id"}, Value: _bg.Sprintf("\u0025v", *_befdc.IdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Item and its children
func (_dgbeb *CT_Item) Validate() error { return _dgbeb.ValidateWithPath("CT_Item") }

// Validate validates the CT_PivotAreaReference and its children
func (_feeaf *CT_PivotAreaReference) Validate() error {
	return _feeaf.ValidateWithPath("CT_PivotAreaReference")
}
func (_baffe *CT_GroupMember) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ddgeg := range start.Attr {
		if _ddgeg.Name.Local == "uniqueName" {
			_ffbdc, _gbca := _ddgeg.Value, error(nil)
			if _gbca != nil {
				return _gbca
			}
			_baffe.UniqueNameAttr = _ffbdc
			continue
		}
		if _ddgeg.Name.Local == "group" {
			_fcbea, _fddca := _g.ParseBool(_ddgeg.Value)
			if _fddca != nil {
				return _fddca
			}
			_baffe.GroupAttr = &_fcbea
			continue
		}
	}
	for {
		_cefa, _bdceg := d.Token()
		if _bdceg != nil {
			return _bg.Errorf("parsing\u0020CT_GroupMember:\u0020\u0025s", _bdceg)
		}
		if _dcffb, _edbdab := _cefa.(_f.EndElement); _edbdab && _dcffb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bffcd ST_PaneState) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bffcd.String(), start)
}
func (_aabdf *CT_Parameter) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aabdf.NameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "name"}, Value: _bg.Sprintf("\u0025v", *_aabdf.NameAttr)})
	}
	if _aabdf.SqlTypeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sqlType"}, Value: _bg.Sprintf("\u0025v", *_aabdf.SqlTypeAttr)})
	}
	if _aabdf.ParameterTypeAttr != ST_ParameterTypeUnset {
		_gfbfc, _caeac := _aabdf.ParameterTypeAttr.MarshalXMLAttr(_f.Name{Local: "parameterType"})
		if _caeac != nil {
			return _caeac
		}
		start.Attr = append(start.Attr, _gfbfc)
	}
	if _aabdf.RefreshOnChangeAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "refreshOnChange"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aabdf.RefreshOnChangeAttr))})
	}
	if _aabdf.PromptAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "prompt"}, Value: _bg.Sprintf("\u0025v", *_aabdf.PromptAttr)})
	}
	if _aabdf.BooleanAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "boolean"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aabdf.BooleanAttr))})
	}
	if _aabdf.DoubleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "double"}, Value: _bg.Sprintf("\u0025v", *_aabdf.DoubleAttr)})
	}
	if _aabdf.IntegerAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "integer"}, Value: _bg.Sprintf("\u0025v", *_aabdf.IntegerAttr)})
	}
	if _aabdf.StringAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "string"}, Value: _bg.Sprintf("\u0025v", *_aabdf.StringAttr)})
	}
	if _aabdf.CellAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "cell"}, Value: _bg.Sprintf("\u0025v", *_aabdf.CellAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_ccbg *CT_ExternalReference) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _eaafb := range start.Attr {
		if _eaafb.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _eaafb.Name.Local == "id" || _eaafb.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _eaafb.Name.Local == "id" {
			_egcgg, _dcagf := _eaafb.Value, error(nil)
			if _dcagf != nil {
				return _dcagf
			}
			_ccbg.IdAttr = _egcgg
			continue
		}
	}
	for {
		_gbfc, _befgg := d.Token()
		if _befgg != nil {
			return _bg.Errorf("parsing\u0020CT_ExternalReference:\u0020\u0025s", _befgg)
		}
		if _geaea, _gffb := _gbfc.(_f.EndElement); _gffb && _geaea.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dadaac ST_ExternalConnectionType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_acccg := _f.Attr{}
	_acccg.Name = name
	switch _dadaac {
	case ST_ExternalConnectionTypeUnset:
		_acccg.Value = ""
	case ST_ExternalConnectionTypeGeneral:
		_acccg.Value = "general"
	case ST_ExternalConnectionTypeText:
		_acccg.Value = "text"
	case ST_ExternalConnectionTypeMDY:
		_acccg.Value = "MDY"
	case ST_ExternalConnectionTypeDMY:
		_acccg.Value = "DMY"
	case ST_ExternalConnectionTypeYMD:
		_acccg.Value = "YMD"
	case ST_ExternalConnectionTypeMYD:
		_acccg.Value = "MYD"
	case ST_ExternalConnectionTypeDYM:
		_acccg.Value = "DYM"
	case ST_ExternalConnectionTypeYDM:
		_acccg.Value = "YDM"
	case ST_ExternalConnectionTypeSkip:
		_acccg.Value = "skip"
	case ST_ExternalConnectionTypeEMD:
		_acccg.Value = "EMD"
	}
	return _acccg, nil
}

type CT_DdeItem struct {

	// DDE Name
	NameAttr *string

	// Object Linking TechnologyE
	OleAttr *bool

	// Advise
	AdviseAttr *bool

	// Data is an Image
	PreferPicAttr *bool

	// DDE Name Values
	Values *CT_DdeValues
}

// Validate validates the CT_Control and its children
func (_daebe *CT_Control) Validate() error { return _daebe.ValidateWithPath("CT_Control") }
func (_cabag *Metadata) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_cabag.CT_Metadata = *NewCT_Metadata()
_effdgcg:
	for {
		_bdaee, _dfdggd := d.Token()
		if _dfdggd != nil {
			return _dfdggd
		}
		switch _fefge := _bdaee.(type) {
		case _f.StartElement:
			switch _fefge.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "metadataTypes"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "metadataTypes"}:
				_cabag.MetadataTypes = NewCT_MetadataTypes()
				if _gbece := d.DecodeElement(_cabag.MetadataTypes, &_fefge); _gbece != nil {
					return _gbece
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "metadataStrings"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "metadataStrings"}:
				_cabag.MetadataStrings = NewCT_MetadataStrings()
				if _abcfba := d.DecodeElement(_cabag.MetadataStrings, &_fefge); _abcfba != nil {
					return _abcfba
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "mdxMetadata"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "mdxMetadata"}:
				_cabag.MdxMetadata = NewCT_MdxMetadata()
				if _caged := d.DecodeElement(_cabag.MdxMetadata, &_fefge); _caged != nil {
					return _caged
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "futureMetadata"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "futureMetadata"}:
				_ccebgf := NewCT_FutureMetadata()
				if _adace := d.DecodeElement(_ccebgf, &_fefge); _adace != nil {
					return _adace
				}
				_cabag.FutureMetadata = append(_cabag.FutureMetadata, _ccebgf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cellMetadata"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cellMetadata"}:
				_cabag.CellMetadata = NewCT_MetadataBlocks()
				if _bgfbc := d.DecodeElement(_cabag.CellMetadata, &_fefge); _bgfbc != nil {
					return _bgfbc
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "valueMetadata"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "valueMetadata"}:
				_cabag.ValueMetadata = NewCT_MetadataBlocks()
				if _egdag := d.DecodeElement(_cabag.ValueMetadata, &_fefge); _egdag != nil {
					return _egdag
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_cabag.ExtLst = NewCT_ExtensionList()
				if _aebgfb := d.DecodeElement(_cabag.ExtLst, &_fefge); _aebgfb != nil {
					return _aebgfb
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Metadata\u0020\u0025v", _fefge.Name)
				if _gaagfc := d.Skip(); _gaagfc != nil {
					return _gaagfc
				}
			}
		case _f.EndElement:
			break _effdgcg
		case _f.CharData:
		}
	}
	return nil
}
func (_ggdb *CT_CacheFields) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fdde := range start.Attr {
		if _fdde.Name.Local == "count" {
			_dfc, _cgfe := _g.ParseUint(_fdde.Value, 10, 32)
			if _cgfe != nil {
				return _cgfe
			}
			_ace := uint32(_dfc)
			_ggdb.CountAttr = &_ace
			continue
		}
	}
_gfga:
	for {
		_dadg, _ggb := d.Token()
		if _ggb != nil {
			return _ggb
		}
		switch _dcee := _dadg.(type) {
		case _f.StartElement:
			switch _dcee.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cacheField"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cacheField"}:
				_bdde := NewCT_CacheField()
				if _aaf := d.DecodeElement(_bdde, &_dcee); _aaf != nil {
					return _aaf
				}
				_ggdb.CacheField = append(_ggdb.CacheField, _bdde)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CacheFields\u0020\u0025v", _dcee.Name)
				if _cggd := d.Skip(); _cggd != nil {
					return _cggd
				}
			}
		case _f.EndElement:
			break _gfga
		case _f.CharData:
		}
	}
	return nil
}
func (_bcfaaa *VolTypes) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:ma"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "ma:volTypes"
	return _bcfaaa.CT_VolTypes.MarshalXML(e, start)
}
func NewCT_Parameter() *CT_Parameter { _cbdcd := &CT_Parameter{}; return _cbdcd }

type CT_Drawing struct{ IdAttr string }
type CT_CellWatches struct {

	// Cell Watch Item
	CellWatch []*CT_CellWatch
}

func (_gcacb *ST_Visibility) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_gcacb = 0
	case "visible":
		*_gcacb = 1
	case "hidden":
		*_gcacb = 2
	case "veryHidden":
		*_gcacb = 3
	}
	return nil
}
func (_gbebe ST_TotalsRowFunction) ValidateWithPath(path string) error {
	switch _gbebe {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gbebe))
	}
	return nil
}
func (_gedaef *CT_colItems) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _gedaef.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_gedaef.CountAttr)})
	}
	e.EncodeToken(start)
	_ceacd := _f.StartElement{Name: _f.Name{Local: "ma:i"}}
	for _, _adcec := range _gedaef.I {
		e.EncodeElement(_adcec, _ceacd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_ChartFormats() *CT_ChartFormats         { _eec := &CT_ChartFormats{}; return _eec }
func (_ecbda ST_TargetScreenSize) Validate() error { return _ecbda.ValidateWithPath("") }
func (_bbcecf ST_FontScheme) Validate() error      { return _bbcecf.ValidateWithPath("") }

type CT_PivotCache struct {

	// PivotCache Id
	CacheIdAttr uint32
	IdAttr      string
}
type CT_Connections struct {

	// Connection
	Connection []*CT_Connection
}

func (_ebgc *CT_CacheFields) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _ebgc.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_ebgc.CountAttr)})
	}
	e.EncodeToken(start)
	if _ebgc.CacheField != nil {
		_adff := _f.StartElement{Name: _f.Name{Local: "ma:cacheField"}}
		for _, _dafec := range _ebgc.CacheField {
			e.EncodeElement(_dafec, _adff)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Consolidation and its children
func (_agdgc *CT_Consolidation) Validate() error { return _agdgc.ValidateWithPath("CT_Consolidation") }

// ValidateWithPath validates the CT_TableStyleInfo and its children, prefixing error messages with path
func (_gefaab *CT_TableStyleInfo) ValidateWithPath(path string) error { return nil }
func (_fgfef *CT_Dialogsheet) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _fgfef.SheetPr != nil {
		_cbgc := _f.StartElement{Name: _f.Name{Local: "ma:sheetPr"}}
		e.EncodeElement(_fgfef.SheetPr, _cbgc)
	}
	if _fgfef.SheetViews != nil {
		_adfg := _f.StartElement{Name: _f.Name{Local: "ma:sheetViews"}}
		e.EncodeElement(_fgfef.SheetViews, _adfg)
	}
	if _fgfef.SheetFormatPr != nil {
		_gedfe := _f.StartElement{Name: _f.Name{Local: "ma:sheetFormatPr"}}
		e.EncodeElement(_fgfef.SheetFormatPr, _gedfe)
	}
	if _fgfef.SheetProtection != nil {
		_efdag := _f.StartElement{Name: _f.Name{Local: "ma:sheetProtection"}}
		e.EncodeElement(_fgfef.SheetProtection, _efdag)
	}
	if _fgfef.CustomSheetViews != nil {
		_fead := _f.StartElement{Name: _f.Name{Local: "ma:customSheetViews"}}
		e.EncodeElement(_fgfef.CustomSheetViews, _fead)
	}
	if _fgfef.PrintOptions != nil {
		_fdaa := _f.StartElement{Name: _f.Name{Local: "ma:printOptions"}}
		e.EncodeElement(_fgfef.PrintOptions, _fdaa)
	}
	if _fgfef.PageMargins != nil {
		_cegac := _f.StartElement{Name: _f.Name{Local: "ma:pageMargins"}}
		e.EncodeElement(_fgfef.PageMargins, _cegac)
	}
	if _fgfef.PageSetup != nil {
		_fffbb := _f.StartElement{Name: _f.Name{Local: "ma:pageSetup"}}
		e.EncodeElement(_fgfef.PageSetup, _fffbb)
	}
	if _fgfef.HeaderFooter != nil {
		_ggceb := _f.StartElement{Name: _f.Name{Local: "ma:headerFooter"}}
		e.EncodeElement(_fgfef.HeaderFooter, _ggceb)
	}
	if _fgfef.Drawing != nil {
		_afefd := _f.StartElement{Name: _f.Name{Local: "ma:drawing"}}
		e.EncodeElement(_fgfef.Drawing, _afefd)
	}
	if _fgfef.LegacyDrawing != nil {
		_debca := _f.StartElement{Name: _f.Name{Local: "ma:legacyDrawing"}}
		e.EncodeElement(_fgfef.LegacyDrawing, _debca)
	}
	if _fgfef.LegacyDrawingHF != nil {
		_gfae := _f.StartElement{Name: _f.Name{Local: "ma:legacyDrawingHF"}}
		e.EncodeElement(_fgfef.LegacyDrawingHF, _gfae)
	}
	if _fgfef.DrawingHF != nil {
		_dcaed := _f.StartElement{Name: _f.Name{Local: "ma:drawingHF"}}
		e.EncodeElement(_fgfef.DrawingHF, _dcaed)
	}
	if _fgfef.OleObjects != nil {
		_ffcd := _f.StartElement{Name: _f.Name{Local: "ma:oleObjects"}}
		e.EncodeElement(_fgfef.OleObjects, _ffcd)
	}
	if _fgfef.Controls != nil {
		_ecea := _f.StartElement{Name: _f.Name{Local: "ma:controls"}}
		e.EncodeElement(_fgfef.Controls, _ecea)
	}
	if _fgfef.ExtLst != nil {
		_bgfca := _f.StartElement{Name: _f.Name{Local: "ma:extLst"}}
		e.EncodeElement(_fgfef.ExtLst, _bgfca)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_DdeValues() *CT_DdeValues { _bgfcg := &CT_DdeValues{}; return _bgfcg }

// ValidateWithPath validates the CT_AutoFilter and its children, prefixing error messages with path
func (_ece *CT_AutoFilter) ValidateWithPath(path string) error {
	for _bea, _aab := range _ece.FilterColumn {
		if _abb := _aab.ValidateWithPath(_bg.Sprintf("\u0025s\u002fFilterColumn\u005b\u0025d\u005d", path, _bea)); _abb != nil {
			return _abb
		}
	}
	if _ece.SortState != nil {
		if _cbc := _ece.SortState.ValidateWithPath(path + "\u002fSortState"); _cbc != nil {
			return _cbc
		}
	}
	if _ece.ExtLst != nil {
		if _decd := _ece.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _decd != nil {
			return _decd
		}
	}
	return nil
}
func (_ceceg *CT_ExternalDefinedNames) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _ceceg.DefinedName != nil {
		_dgccd := _f.StartElement{Name: _f.Name{Local: "ma:definedName"}}
		for _, _eeccg := range _ceceg.DefinedName {
			e.EncodeElement(_eeccg, _dgccd)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_QueryTable and its children, prefixing error messages with path
func (_efcbd *CT_QueryTable) ValidateWithPath(path string) error {
	if _ddeaf := _efcbd.GrowShrinkTypeAttr.ValidateWithPath(path + "\u002fGrowShrinkTypeAttr"); _ddeaf != nil {
		return _ddeaf
	}
	if _efcbd.QueryTableRefresh != nil {
		if _ebbbg := _efcbd.QueryTableRefresh.ValidateWithPath(path + "\u002fQueryTableRefresh"); _ebbbg != nil {
			return _ebbbg
		}
	}
	if _efcbd.ExtLst != nil {
		if _gdagc := _efcbd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gdagc != nil {
			return _gdagc
		}
	}
	return nil
}

// Validate validates the CT_ControlPr and its children
func (_cfeg *CT_ControlPr) Validate() error { return _cfeg.ValidateWithPath("CT_ControlPr") }
func (_gbffdd *ST_PaneState) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_gbffdd = 0
	case "split":
		*_gbffdd = 1
	case "frozen":
		*_gbffdd = 2
	case "frozenSplit":
		*_gbffdd = 3
	}
	return nil
}

// ValidateWithPath validates the CT_Dxfs and its children, prefixing error messages with path
func (_ebgac *CT_Dxfs) ValidateWithPath(path string) error {
	for _gefac, _daac := range _ebgac.Dxf {
		if _ebbga := _daac.ValidateWithPath(_bg.Sprintf("\u0025s\u002fDxf\u005b\u0025d\u005d", path, _gefac)); _ebbga != nil {
			return _ebbga
		}
	}
	return nil
}

// Validate validates the CT_NumFmts and its children
func (_eccdc *CT_NumFmts) Validate() error        { return _eccdc.ValidateWithPath("CT_NumFmts") }
func (_deecdd ST_TableStyleType) Validate() error { return _deecdd.ValidateWithPath("") }

type ST_rwColActionType byte

func NewCT_TableParts() *CT_TableParts { _cdegf := &CT_TableParts{}; return _cdegf }

// Validate validates the CT_FilterColumn and its children
func (_bdaff *CT_FilterColumn) Validate() error { return _bdaff.ValidateWithPath("CT_FilterColumn") }

type ST_ExternalConnectionType byte

func (_abddf *CT_PatternFill) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _fgeeb := range start.Attr {
		if _fgeeb.Name.Local == "patternType" {
			_abddf.PatternTypeAttr.UnmarshalXMLAttr(_fgeeb)
			continue
		}
	}
_eadab:
	for {
		_bddgacb, _gafaf := d.Token()
		if _gafaf != nil {
			return _gafaf
		}
		switch _dbccb := _bddgacb.(type) {
		case _f.StartElement:
			switch _dbccb.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "fgColor"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "fgColor"}:
				_abddf.FgColor = NewCT_Color()
				if _gagac := d.DecodeElement(_abddf.FgColor, &_dbccb); _gagac != nil {
					return _gagac
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "bgColor"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "bgColor"}:
				_abddf.BgColor = NewCT_Color()
				if _cdgcd := d.DecodeElement(_abddf.BgColor, &_dbccb); _cdgcd != nil {
					return _cdgcd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PatternFill\u0020\u0025v", _dbccb.Name)
				if _egcbeg := d.Skip(); _egcbeg != nil {
					return _egcbeg
				}
			}
		case _f.EndElement:
			break _eadab
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TableStyle and its children, prefixing error messages with path
func (_beabfee *CT_TableStyle) ValidateWithPath(path string) error {
	for _fdgaf, _cccfa := range _beabfee.TableStyleElement {
		if _efbad := _cccfa.ValidateWithPath(_bg.Sprintf("\u0025s\u002fTableStyleElement\u005b\u0025d\u005d", path, _fdgaf)); _efbad != nil {
			return _efbad
		}
	}
	return nil
}

// Validate validates the CT_SharedUser and its children
func (_cgcgg *CT_SharedUser) Validate() error { return _cgcgg.ValidateWithPath("CT_SharedUser") }

// ValidateWithPath validates the CT_Revisions and its children, prefixing error messages with path
func (_cbffea *CT_Revisions) ValidateWithPath(path string) error {
	for _fdged, _gbgb := range _cbffea.Rrc {
		if _fagca := _gbgb.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRrc\u005b\u0025d\u005d", path, _fdged)); _fagca != nil {
			return _fagca
		}
	}
	for _ccegd, _cgbeg := range _cbffea.Rm {
		if _cgfeca := _cgbeg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRm\u005b\u0025d]", path, _ccegd)); _cgfeca != nil {
			return _cgfeca
		}
	}
	for _baafb, _gbbcdd := range _cbffea.Rcv {
		if _fbgcag := _gbbcdd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRcv\u005b\u0025d\u005d", path, _baafb)); _fbgcag != nil {
			return _fbgcag
		}
	}
	for _ggaee, _efcgd := range _cbffea.Rsnm {
		if _cdedf := _efcgd.ValidateWithPath(_bg.Sprintf("%s\u002fRsnm\u005b\u0025d\u005d", path, _ggaee)); _cdedf != nil {
			return _cdedf
		}
	}
	for _fabfa, _acbac := range _cbffea.Ris {
		if _aabfa := _acbac.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRis\u005b\u0025d\u005d", path, _fabfa)); _aabfa != nil {
			return _aabfa
		}
	}
	for _cbbbfb, _bbacbd := range _cbffea.Rcc {
		if _fdcacc := _bbacbd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRcc\u005b\u0025d\u005d", path, _cbbbfb)); _fdcacc != nil {
			return _fdcacc
		}
	}
	for _dacga, _fbcfe := range _cbffea.Rfmt {
		if _deege := _fbcfe.ValidateWithPath(_bg.Sprintf("%s\u002fRfmt\u005b\u0025d\u005d", path, _dacga)); _deege != nil {
			return _deege
		}
	}
	for _gacceb, _ebccd := range _cbffea.Raf {
		if _egcgb := _ebccd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRaf\u005b\u0025d\u005d", path, _gacceb)); _egcgb != nil {
			return _egcgb
		}
	}
	for _bacc, _dbga := range _cbffea.Rdn {
		if _bcfba := _dbga.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRdn\u005b\u0025d\u005d", path, _bacc)); _bcfba != nil {
			return _bcfba
		}
	}
	for _debce, _adcdbe := range _cbffea.Rcmt {
		if _cafda := _adcdbe.ValidateWithPath(_bg.Sprintf("%s\u002fRcmt\u005b\u0025d\u005d", path, _debce)); _cafda != nil {
			return _cafda
		}
	}
	for _acadb, _caagc := range _cbffea.Rqt {
		if _ecfae := _caagc.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRqt\u005b\u0025d\u005d", path, _acadb)); _ecfae != nil {
			return _ecfae
		}
	}
	for _dfcbc, _geffa := range _cbffea.Rcft {
		if _acdbc := _geffa.ValidateWithPath(_bg.Sprintf("%s\u002fRcft\u005b\u0025d\u005d", path, _dfcbc)); _acdbc != nil {
			return _acdbc
		}
	}
	return nil
}
func (_efdfg *ST_PaneState) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_fgddf, _bfeee := d.Token()
	if _bfeee != nil {
		return _bfeee
	}
	if _eecgg, _beeadf := _fgddf.(_f.EndElement); _beeadf && _eecgg.Name == start.Name {
		*_efdfg = 1
		return nil
	}
	if _aggaga, _beaf := _fgddf.(_f.CharData); !_beaf {
		return _bg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fgddf)
	} else {
		switch string(_aggaga) {
		case "":
			*_efdfg = 0
		case "split":
			*_efdfg = 1
		case "frozen":
			*_efdfg = 2
		case "frozenSplit":
			*_efdfg = 3
		}
	}
	_fgddf, _bfeee = d.Token()
	if _bfeee != nil {
		return _bfeee
	}
	if _ccbbea, _gaaddg := _fgddf.(_f.EndElement); _gaaddg && _ccbbea.Name == start.Name {
		return nil
	}
	return _bg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fgddf)
}

type CT_DataBinding struct {

	// Unique Identifer
	DataBindingNameAttr *string

	// Binding to External File
	FileBindingAttr *bool

	// Reference to Connection ID
	ConnectionIDAttr *uint32

	// File Binding Name
	FileBindingNameAttr *string

	// XML Data Loading Behavior
	DataBindingLoadModeAttr uint32
	Any                     _cb.Any
}

const (
	ST_SmartTagShowUnset       ST_SmartTagShow = 0
	ST_SmartTagShowAll         ST_SmartTagShow = 1
	ST_SmartTagShowNone        ST_SmartTagShow = 2
	ST_SmartTagShowNoIndicator ST_SmartTagShow = 3
)

func (_aggbf *CT_SheetCalcPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aggbf.FullCalcOnLoadAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "fullCalcOnLoad"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_aggbf.FullCalcOnLoadAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_acbfbb *CT_SheetPr) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cdbg := range start.Attr {
		if _cdbg.Name.Local == "syncHorizontal" {
			_fbagf, _bddgaa := _g.ParseBool(_cdbg.Value)
			if _bddgaa != nil {
				return _bddgaa
			}
			_acbfbb.SyncHorizontalAttr = &_fbagf
			continue
		}
		if _cdbg.Name.Local == "syncVertical" {
			_eabbd, _cdafeb := _g.ParseBool(_cdbg.Value)
			if _cdafeb != nil {
				return _cdafeb
			}
			_acbfbb.SyncVerticalAttr = &_eabbd
			continue
		}
		if _cdbg.Name.Local == "syncRef" {
			_deeaac, _aggba := _cdbg.Value, error(nil)
			if _aggba != nil {
				return _aggba
			}
			_acbfbb.SyncRefAttr = &_deeaac
			continue
		}
		if _cdbg.Name.Local == "transitionEvaluation" {
			_fcbedd, _edcaf := _g.ParseBool(_cdbg.Value)
			if _edcaf != nil {
				return _edcaf
			}
			_acbfbb.TransitionEvaluationAttr = &_fcbedd
			continue
		}
		if _cdbg.Name.Local == "transitionEntry" {
			_ccebb, _deegaa := _g.ParseBool(_cdbg.Value)
			if _deegaa != nil {
				return _deegaa
			}
			_acbfbb.TransitionEntryAttr = &_ccebb
			continue
		}
		if _cdbg.Name.Local == "published" {
			_adfca, _ddbdc := _g.ParseBool(_cdbg.Value)
			if _ddbdc != nil {
				return _ddbdc
			}
			_acbfbb.PublishedAttr = &_adfca
			continue
		}
		if _cdbg.Name.Local == "codeName" {
			_acbae, _abbedd := _cdbg.Value, error(nil)
			if _abbedd != nil {
				return _abbedd
			}
			_acbfbb.CodeNameAttr = &_acbae
			continue
		}
		if _cdbg.Name.Local == "filterMode" {
			_agdcfg, _dafgdd := _g.ParseBool(_cdbg.Value)
			if _dafgdd != nil {
				return _dafgdd
			}
			_acbfbb.FilterModeAttr = &_agdcfg
			continue
		}
		if _cdbg.Name.Local == "enableFormatConditionsCalculation" {
			_adacc, _dbfeg := _g.ParseBool(_cdbg.Value)
			if _dbfeg != nil {
				return _dbfeg
			}
			_acbfbb.EnableFormatConditionsCalculationAttr = &_adacc
			continue
		}
	}
_cbbbb:
	for {
		_bdgeg, _beacge := d.Token()
		if _beacge != nil {
			return _beacge
		}
		switch _gddbf := _bdgeg.(type) {
		case _f.StartElement:
			switch _gddbf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tabColor"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tabColor"}:
				_acbfbb.TabColor = NewCT_Color()
				if _gdedca := d.DecodeElement(_acbfbb.TabColor, &_gddbf); _gdedca != nil {
					return _gdedca
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "outlinePr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "outlinePr"}:
				_acbfbb.OutlinePr = NewCT_OutlinePr()
				if _ebfgd := d.DecodeElement(_acbfbb.OutlinePr, &_gddbf); _ebfgd != nil {
					return _ebfgd
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "pageSetUpPr"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "pageSetUpPr"}:
				_acbfbb.PageSetUpPr = NewCT_PageSetUpPr()
				if _fgeeff := d.DecodeElement(_acbfbb.PageSetUpPr, &_gddbf); _fgeeff != nil {
					return _fgeeff
				}
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_SheetPr\u0020\u0025v", _gddbf.Name)
				if _afgad := d.Skip(); _afgad != nil {
					return _afgad
				}
			}
		case _f.EndElement:
			break _cbbbb
		case _f.CharData:
		}
	}
	return nil
}

// Validate validates the CT_ExternalSheetData and its children
func (_gdgce *CT_ExternalSheetData) Validate() error {
	return _gdgce.ValidateWithPath("CT_ExternalSheetData")
}
func (_geaggb *ST_ItemType) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_geaggb = 0
	case "data":
		*_geaggb = 1
	case "default":
		*_geaggb = 2
	case "sum":
		*_geaggb = 3
	case "countA":
		*_geaggb = 4
	case "avg":
		*_geaggb = 5
	case "max":
		*_geaggb = 6
	case "min":
		*_geaggb = 7
	case "product":
		*_geaggb = 8
	case "count":
		*_geaggb = 9
	case "stdDev":
		*_geaggb = 10
	case "stdDevP":
		*_geaggb = 11
	case "var":
		*_geaggb = 12
	case "varP":
		*_geaggb = 13
	case "grand":
		*_geaggb = 14
	case "blank":
		*_geaggb = 15
	}
	return nil
}

type ST_IconSetType byte

func (_aagdf *CT_SharedItems) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _cbcbed := range start.Attr {
		if _cbcbed.Name.Local == "minDate" {
			_dgdgb, _egbgae := ParseStdlibTime(_cbcbed.Value)
			if _egbgae != nil {
				return _egbgae
			}
			_aagdf.MinDateAttr = &_dgdgb
			continue
		}
		if _cbcbed.Name.Local == "containsSemiMixedTypes" {
			_ggeac, _fgabg := _g.ParseBool(_cbcbed.Value)
			if _fgabg != nil {
				return _fgabg
			}
			_aagdf.ContainsSemiMixedTypesAttr = &_ggeac
			continue
		}
		if _cbcbed.Name.Local == "maxDate" {
			_dbgcgc, _dfge := ParseStdlibTime(_cbcbed.Value)
			if _dfge != nil {
				return _dfge
			}
			_aagdf.MaxDateAttr = &_dbgcgc
			continue
		}
		if _cbcbed.Name.Local == "containsDate" {
			_cbcded, _ebcacc := _g.ParseBool(_cbcbed.Value)
			if _ebcacc != nil {
				return _ebcacc
			}
			_aagdf.ContainsDateAttr = &_cbcded
			continue
		}
		if _cbcbed.Name.Local == "count" {
			_dfcdf, _aefag := _g.ParseUint(_cbcbed.Value, 10, 32)
			if _aefag != nil {
				return _aefag
			}
			_gcbdb := uint32(_dfcdf)
			_aagdf.CountAttr = &_gcbdb
			continue
		}
		if _cbcbed.Name.Local == "containsBlank" {
			_acfae, _cggefd := _g.ParseBool(_cbcbed.Value)
			if _cggefd != nil {
				return _cggefd
			}
			_aagdf.ContainsBlankAttr = &_acfae
			continue
		}
		if _cbcbed.Name.Local == "longText" {
			_ebcba, _ddcegg := _g.ParseBool(_cbcbed.Value)
			if _ddcegg != nil {
				return _ddcegg
			}
			_aagdf.LongTextAttr = &_ebcba
			continue
		}
		if _cbcbed.Name.Local == "containsNumber" {
			_ecdeb, _cfcdg := _g.ParseBool(_cbcbed.Value)
			if _cfcdg != nil {
				return _cfcdg
			}
			_aagdf.ContainsNumberAttr = &_ecdeb
			continue
		}
		if _cbcbed.Name.Local == "minValue" {
			_dgaad, _acfgb := _g.ParseFloat(_cbcbed.Value, 64)
			if _acfgb != nil {
				return _acfgb
			}
			_aagdf.MinValueAttr = &_dgaad
			continue
		}
		if _cbcbed.Name.Local == "maxValue" {
			_addge, _egaaf := _g.ParseFloat(_cbcbed.Value, 64)
			if _egaaf != nil {
				return _egaaf
			}
			_aagdf.MaxValueAttr = &_addge
			continue
		}
		if _cbcbed.Name.Local == "containsNonDate" {
			_dedba, _addeb := _g.ParseBool(_cbcbed.Value)
			if _addeb != nil {
				return _addeb
			}
			_aagdf.ContainsNonDateAttr = &_dedba
			continue
		}
		if _cbcbed.Name.Local == "containsString" {
			_cccaea, _aecad := _g.ParseBool(_cbcbed.Value)
			if _aecad != nil {
				return _aecad
			}
			_aagdf.ContainsStringAttr = &_cccaea
			continue
		}
		if _cbcbed.Name.Local == "containsMixedTypes" {
			_dagggc, _gcegc := _g.ParseBool(_cbcbed.Value)
			if _gcegc != nil {
				return _gcegc
			}
			_aagdf.ContainsMixedTypesAttr = &_dagggc
			continue
		}
		if _cbcbed.Name.Local == "containsInteger" {
			_cfccdf, _ggfba := _g.ParseBool(_cbcbed.Value)
			if _ggfba != nil {
				return _ggfba
			}
			_aagdf.ContainsIntegerAttr = &_cfccdf
			continue
		}
	}
_afgaf:
	for {
		_egbfb, _ffaa := d.Token()
		if _ffaa != nil {
			return _ffaa
		}
		switch _gbfab := _egbfb.(type) {
		case _f.StartElement:
			switch _gbfab.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "m"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "m"}:
				_efbafg := NewCT_Missing()
				if _gdfab := d.DecodeElement(_efbafg, &_gbfab); _gdfab != nil {
					return _gdfab
				}
				_aagdf.M = append(_aagdf.M, _efbafg)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "n"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "n"}:
				_dafcd := NewCT_Number()
				if _dcffbd := d.DecodeElement(_dafcd, &_gbfab); _dcffbd != nil {
					return _dcffbd
				}
				_aagdf.N = append(_aagdf.N, _dafcd)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "b"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "b"}:
				_eafgdf := NewCT_Boolean()
				if _cafbg := d.DecodeElement(_eafgdf, &_gbfab); _cafbg != nil {
					return _cafbg
				}
				_aagdf.B = append(_aagdf.B, _eafgdf)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "e"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "e"}:
				_bgecca := NewCT_Error()
				if _aggf := d.DecodeElement(_bgecca, &_gbfab); _aggf != nil {
					return _aggf
				}
				_aagdf.E = append(_aagdf.E, _bgecca)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "s"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "s"}:
				_bfdgc := NewCT_String()
				if _bedde := d.DecodeElement(_bfdgc, &_gbfab); _bedde != nil {
					return _bedde
				}
				_aagdf.S = append(_aagdf.S, _bfdgc)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "d"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "d"}:
				_cbebeb := NewCT_DateTime()
				if _ddcae := d.DecodeElement(_cbebeb, &_gbfab); _ddcae != nil {
					return _ddcae
				}
				_aagdf.D = append(_aagdf.D, _cbebeb)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SharedItems\u0020\u0025v", _gbfab.Name)
				if _fbafd := d.Skip(); _fbafd != nil {
					return _fbafd
				}
			}
		case _f.EndElement:
			break _afgaf
		case _f.CharData:
		}
	}
	return nil
}

type CT_GroupMember struct {

	// Group Member Unique Name
	UniqueNameAttr string

	// Group
	GroupAttr *bool
}

func (_agcdgd ST_ShowDataAs) Validate() error { return _agcdgd.ValidateWithPath("") }

// Validate validates the CT_CommentPr and its children
func (_cebfc *CT_CommentPr) Validate() error { return _cebfc.ValidateWithPath("CT_CommentPr") }

type CT_PrintOptions struct {

	// Horizontal Centered
	HorizontalCenteredAttr *bool

	// Vertical Centered
	VerticalCenteredAttr *bool

	// Print Headings
	HeadingsAttr *bool

	// Print Grid Lines
	GridLinesAttr *bool

	// Grid Lines Set
	GridLinesSetAttr *bool
}

func (_dgabc *CT_PivotFilter) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	_dgabc.TypeAttr = ST_PivotFilterType(1)
	_dgabc.AutoFilter = NewCT_AutoFilter()
	for _, _abbaa := range start.Attr {
		if _abbaa.Name.Local == "iMeasureFld" {
			_dbfeba, _acbce := _g.ParseUint(_abbaa.Value, 10, 32)
			if _acbce != nil {
				return _acbce
			}
			_ffadf := uint32(_dbfeba)
			_dgabc.IMeasureFldAttr = &_ffadf
			continue
		}
		if _abbaa.Name.Local == "mpFld" {
			_eccdde, _gfbec := _g.ParseUint(_abbaa.Value, 10, 32)
			if _gfbec != nil {
				return _gfbec
			}
			_eaega := uint32(_eccdde)
			_dgabc.MpFldAttr = &_eaega
			continue
		}
		if _abbaa.Name.Local == "type" {
			_dgabc.TypeAttr.UnmarshalXMLAttr(_abbaa)
			continue
		}
		if _abbaa.Name.Local == "evalOrder" {
			_aacfd, _fagbc := _g.ParseInt(_abbaa.Value, 10, 32)
			if _fagbc != nil {
				return _fagbc
			}
			_beebe := int32(_aacfd)
			_dgabc.EvalOrderAttr = &_beebe
			continue
		}
		if _abbaa.Name.Local == "id" {
			_febgc, _dacdd := _g.ParseUint(_abbaa.Value, 10, 32)
			if _dacdd != nil {
				return _dacdd
			}
			_dgabc.IdAttr = uint32(_febgc)
			continue
		}
		if _abbaa.Name.Local == "iMeasureHier" {
			_debdc, _gbecb := _g.ParseUint(_abbaa.Value, 10, 32)
			if _gbecb != nil {
				return _gbecb
			}
			_cbcdeef := uint32(_debdc)
			_dgabc.IMeasureHierAttr = &_cbcdeef
			continue
		}
		if _abbaa.Name.Local == "fld" {
			_bfffb, _gdgfd := _g.ParseUint(_abbaa.Value, 10, 32)
			if _gdgfd != nil {
				return _gdgfd
			}
			_dgabc.FldAttr = uint32(_bfffb)
			continue
		}
		if _abbaa.Name.Local == "name" {
			_aebge, _agbece := _abbaa.Value, error(nil)
			if _agbece != nil {
				return _agbece
			}
			_dgabc.NameAttr = &_aebge
			continue
		}
		if _abbaa.Name.Local == "description" {
			_acecd, _dffbd := _abbaa.Value, error(nil)
			if _dffbd != nil {
				return _dffbd
			}
			_dgabc.DescriptionAttr = &_acecd
			continue
		}
		if _abbaa.Name.Local == "stringValue1" {
			_adaaac, _gdabb := _abbaa.Value, error(nil)
			if _gdabb != nil {
				return _gdabb
			}
			_dgabc.StringValue1Attr = &_adaaac
			continue
		}
		if _abbaa.Name.Local == "stringValue2" {
			_eebe, _ecdce := _abbaa.Value, error(nil)
			if _ecdce != nil {
				return _ecdce
			}
			_dgabc.StringValue2Attr = &_eebe
			continue
		}
	}
_dccfd:
	for {
		_fdadd, _bdcda := d.Token()
		if _bdcda != nil {
			return _bdcda
		}
		switch _dbcggc := _fdadd.(type) {
		case _f.StartElement:
			switch _dbcggc.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "autoFilter"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "autoFilter"}:
				if _aagda := d.DecodeElement(_dgabc.AutoFilter, &_dbcggc); _aagda != nil {
					return _aagda
				}
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_dgabc.ExtLst = NewCT_ExtensionList()
				if _effbd := d.DecodeElement(_dgabc.ExtLst, &_dbcggc); _effbd != nil {
					return _effbd
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PivotFilter\u0020\u0025v", _dbcggc.Name)
				if _fcaeea := d.Skip(); _fcaeea != nil {
					return _fcaeea
				}
			}
		case _f.EndElement:
			break _dccfd
		case _f.CharData:
		}
	}
	return nil
}

type CT_PCDKPI struct {

	// KPI Unique Name
	UniqueNameAttr string

	// KPI Display Name
	CaptionAttr *string

	// KPI Display Folder
	DisplayFolderAttr *string

	// KPI Measure Group Name
	MeasureGroupAttr *string

	// Parent KPI
	ParentAttr *string

	// KPI Value Unique Name
	ValueAttr string

	// KPI Goal Unique Name
	GoalAttr *string

	// KPI Status Unique Name
	StatusAttr *string

	// KPI Trend Unique Name
	TrendAttr *string

	// KPI Weight Unique Name
	WeightAttr *string

	// Time Member KPI Unique Name
	TimeAttr *string
}

// ValidateWithPath validates the CT_FileSharing and its children, prefixing error messages with path
func (_cbfb *CT_FileSharing) ValidateWithPath(path string) error { return nil }
func (_bdbga *CT_NumFmt) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _dgcdd := range start.Attr {
		if _dgcdd.Name.Local == "numFmtId" {
			_deaefa, _dcdce := _g.ParseUint(_dgcdd.Value, 10, 32)
			if _dcdce != nil {
				return _dcdce
			}
			_bdbga.NumFmtIdAttr = uint32(_deaefa)
			continue
		}
		if _dgcdd.Name.Local == "formatCode" {
			_fbeac, _abbbbb := _dgcdd.Value, error(nil)
			if _abbbbb != nil {
				return _abbbbb
			}
			_bdbga.FormatCodeAttr = _fbeac
			continue
		}
	}
	for {
		_fccde, _ggcdd := d.Token()
		if _ggcdd != nil {
			return _bg.Errorf("parsing\u0020CT_NumFmt:\u0020\u0025s", _ggcdd)
		}
		if _fcad, _fddaf := _fccde.(_f.EndElement); _fddaf && _fcad.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Index struct {

	// Shared Items Index
	VAttr uint32
}

func NewCT_OleObjects() *CT_OleObjects { _eddefa := &CT_OleObjects{}; return _eddefa }
func (_eebfa *CT_DdeItems) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	e.EncodeToken(start)
	if _eebfa.DdeItem != nil {
		_fedeb := _f.StartElement{Name: _f.Name{Local: "ma:ddeItem"}}
		for _, _begad := range _eebfa.DdeItem {
			e.EncodeElement(_begad, _fedeb)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ColFields and its children, prefixing error messages with path
func (_dfag *CT_ColFields) ValidateWithPath(path string) error {
	for _agdg, _cfdg := range _dfag.Field {
		if _gdgc := _cfdg.ValidateWithPath(_bg.Sprintf("\u0025s\u002fField\u005b\u0025d\u005d", path, _agdg)); _gdgc != nil {
			return _gdgc
		}
	}
	return nil
}

type CT_ExternalSheetName struct {

	// Sheet Name Value
	ValAttr *string
}

// ValidateWithPath validates the CT_CellSmartTags and its children, prefixing error messages with path
func (_fafd *CT_CellSmartTags) ValidateWithPath(path string) error {
	for _ddg, _ebbd := range _fafd.CellSmartTag {
		if _faed := _ebbd.ValidateWithPath(_bg.Sprintf("\u0025s\u002fCellSmartTag\u005b\u0025d\u005d", path, _ddg)); _faed != nil {
			return _faed
		}
	}
	return nil
}

type CT_FieldGroup struct {

	// Parent
	ParAttr *uint32

	// Field Base
	BaseAttr *uint32

	// Range Grouping Properties
	RangePr *CT_RangePr

	// Discrete Grouping Properties
	DiscretePr *CT_DiscretePr

	// OLAP Group Items
	GroupItems *CT_GroupItems
}

// Validate validates the PivotCacheRecords and its children
func (_bfbce *PivotCacheRecords) Validate() error {
	return _bfbce.ValidateWithPath("PivotCacheRecords")
}

type Worksheet struct{ CT_Worksheet }

// Validate validates the CT_Connections and its children
func (_cfagb *CT_Connections) Validate() error { return _cfagb.ValidateWithPath("CT_Connections") }

// Validate validates the CT_Comments and its children
func (_aadd *CT_Comments) Validate() error { return _aadd.ValidateWithPath("CT_Comments") }
func (_bfbcaf *ST_TargetScreenSize) UnmarshalXMLAttr(attr _f.Attr) error {
	switch attr.Value {
	case "":
		*_bfbcaf = 0
	case "544x376":
		*_bfbcaf = 1
	case "640x480":
		*_bfbcaf = 2
	case "720x512":
		*_bfbcaf = 3
	case "800x600":
		*_bfbcaf = 4
	case "1024x768":
		*_bfbcaf = 5
	case "1152x882":
		*_bfbcaf = 6
	case "1152x900":
		*_bfbcaf = 7
	case "1280x1024":
		*_bfbcaf = 8
	case "1600x1200":
		*_bfbcaf = 9
	case "1800x1440":
		*_bfbcaf = 10
	case "1920x1200":
		*_bfbcaf = 11
	}
	return nil
}
func NewCT_DeletedField() *CT_DeletedField { _gcdb := &CT_DeletedField{}; return _gcdb }
func NewCT_OleItem() *CT_OleItem           { _bdbcb := &CT_OleItem{}; return _bdbcb }

// ValidateWithPath validates the EG_ExtensionList and its children, prefixing error messages with path
func (_gbgcea *EG_ExtensionList) ValidateWithPath(path string) error {
	for _gdcec, _fccca := range _gbgcea.Ext {
		if _bgeda := _fccca.ValidateWithPath(_bg.Sprintf("\u0025s\u002fExt\u005b\u0025d\u005d", path, _gdcec)); _bgeda != nil {
			return _bgeda
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PrintOptions and its children, prefixing error messages with path
func (_cdcgf *CT_PrintOptions) ValidateWithPath(path string) error { return nil }
func (_accbe ST_SourceType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_accbe.String(), start)
}

type CT_RowFields struct {

	// Repeated Items Count
	CountAttr *uint32

	// Row Items
	Field []*CT_Field
}

func (_ebeddb ST_PaneState) Validate() error { return _ebeddb.ValidateWithPath("") }
func (_ffgcgf *CT_WebPublishItem) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "id"}, Value: _bg.Sprintf("\u0025v", _ffgcgf.IdAttr)})
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "divId"}, Value: _bg.Sprintf("\u0025v", _ffgcgf.DivIdAttr)})
	_cffbgf, _aeaecd := _ffgcgf.SourceTypeAttr.MarshalXMLAttr(_f.Name{Local: "sourceType"})
	if _aeaecd != nil {
		return _aeaecd
	}
	start.Attr = append(start.Attr, _cffbgf)
	if _ffgcgf.SourceRefAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sourceRef"}, Value: _bg.Sprintf("\u0025v", *_ffgcgf.SourceRefAttr)})
	}
	if _ffgcgf.SourceObjectAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "sourceObject"}, Value: _bg.Sprintf("\u0025v", *_ffgcgf.SourceObjectAttr)})
	}
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "destinationFile"}, Value: _bg.Sprintf("\u0025v", _ffgcgf.DestinationFileAttr)})
	if _ffgcgf.TitleAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "title"}, Value: _bg.Sprintf("\u0025v", *_ffgcgf.TitleAttr)})
	}
	if _ffgcgf.AutoRepublishAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "autoRepublish"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_ffgcgf.AutoRepublishAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the PivotCacheRecords and its children, prefixing error messages with path
func (_aggddc *PivotCacheRecords) ValidateWithPath(path string) error {
	if _fadbdd := _aggddc.CT_PivotCacheRecords.ValidateWithPath(path); _fadbdd != nil {
		return _fadbdd
	}
	return nil
}
func (_fbbacc *CT_XStringElement) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "v"}, Value: _bg.Sprintf("\u0025v", _fbbacc.VAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func (_fdfec *CT_MetadataRecord) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ffbc := range start.Attr {
		if _ffbc.Name.Local == "t" {
			_bgfgb, _debgee := _g.ParseUint(_ffbc.Value, 10, 32)
			if _debgee != nil {
				return _debgee
			}
			_fdfec.TAttr = uint32(_bgfgb)
			continue
		}
		if _ffbc.Name.Local == "v" {
			_edcagf, _bbde := _g.ParseUint(_ffbc.Value, 10, 32)
			if _bbde != nil {
				return _bbde
			}
			_fdfec.VAttr = uint32(_edcagf)
			continue
		}
	}
	for {
		_faffd, _cbacb := d.Token()
		if _cbacb != nil {
			return _bg.Errorf("parsing\u0020CT_MetadataRecord: \u0025s", _cbacb)
		}
		if _fggeg, _cbefd := _faffd.(_f.EndElement); _cbefd && _fggeg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_aeg *CT_Authors) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
_fcg:
	for {
		_gge, _fdf := d.Token()
		if _fdf != nil {
			return _fdf
		}
		switch _aa := _gge.(type) {
		case _f.StartElement:
			switch _aa.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "author"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "author"}:
				var _fge string
				if _ccd := d.DecodeElement(&_fge, &_aa); _ccd != nil {
					return _ccd
				}
				_aeg.Author = append(_aeg.Author, _fge)
			default:
				_cb.Log("skipping unsupported\u0020element\u0020on\u0020CT_Authors\u0020\u0025v", _aa.Name)
				if _ga := d.Skip(); _ga != nil {
					return _ga
				}
			}
		case _f.EndElement:
			break _fcg
		case _f.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_OleSize and its children, prefixing error messages with path
func (_ebdfc *CT_OleSize) ValidateWithPath(path string) error { return nil }
func (_cgegg *CT_WebPublishItems) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cgegg.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_cgegg.CountAttr)})
	}
	e.EncodeToken(start)
	_ebada := _f.StartElement{Name: _f.Name{Local: "ma:webPublishItem"}}
	for _, _adffgb := range _cgegg.WebPublishItem {
		e.EncodeElement(_adffgb, _ebada)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

type CT_Fill struct {

	// Pattern
	PatternFill *CT_PatternFill

	// Gradient
	GradientFill *CT_GradientFill
}

func (_fbgac ST_TableStyleType) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_cebed := _f.Attr{}
	_cebed.Name = name
	switch _fbgac {
	case ST_TableStyleTypeUnset:
		_cebed.Value = ""
	case ST_TableStyleTypeWholeTable:
		_cebed.Value = "wholeTable"
	case ST_TableStyleTypeHeaderRow:
		_cebed.Value = "headerRow"
	case ST_TableStyleTypeTotalRow:
		_cebed.Value = "totalRow"
	case ST_TableStyleTypeFirstColumn:
		_cebed.Value = "firstColumn"
	case ST_TableStyleTypeLastColumn:
		_cebed.Value = "lastColumn"
	case ST_TableStyleTypeFirstRowStripe:
		_cebed.Value = "firstRowStripe"
	case ST_TableStyleTypeSecondRowStripe:
		_cebed.Value = "secondRowStripe"
	case ST_TableStyleTypeFirstColumnStripe:
		_cebed.Value = "firstColumnStripe"
	case ST_TableStyleTypeSecondColumnStripe:
		_cebed.Value = "secondColumnStripe"
	case ST_TableStyleTypeFirstHeaderCell:
		_cebed.Value = "firstHeaderCell"
	case ST_TableStyleTypeLastHeaderCell:
		_cebed.Value = "lastHeaderCell"
	case ST_TableStyleTypeFirstTotalCell:
		_cebed.Value = "firstTotalCell"
	case ST_TableStyleTypeLastTotalCell:
		_cebed.Value = "lastTotalCell"
	case ST_TableStyleTypeFirstSubtotalColumn:
		_cebed.Value = "firstSubtotalColumn"
	case ST_TableStyleTypeSecondSubtotalColumn:
		_cebed.Value = "secondSubtotalColumn"
	case ST_TableStyleTypeThirdSubtotalColumn:
		_cebed.Value = "thirdSubtotalColumn"
	case ST_TableStyleTypeFirstSubtotalRow:
		_cebed.Value = "firstSubtotalRow"
	case ST_TableStyleTypeSecondSubtotalRow:
		_cebed.Value = "secondSubtotalRow"
	case ST_TableStyleTypeThirdSubtotalRow:
		_cebed.Value = "thirdSubtotalRow"
	case ST_TableStyleTypeBlankRow:
		_cebed.Value = "blankRow"
	case ST_TableStyleTypeFirstColumnSubheading:
		_cebed.Value = "firstColumnSubheading"
	case ST_TableStyleTypeSecondColumnSubheading:
		_cebed.Value = "secondColumnSubheading"
	case ST_TableStyleTypeThirdColumnSubheading:
		_cebed.Value = "thirdColumnSubheading"
	case ST_TableStyleTypeFirstRowSubheading:
		_cebed.Value = "firstRowSubheading"
	case ST_TableStyleTypeSecondRowSubheading:
		_cebed.Value = "secondRowSubheading"
	case ST_TableStyleTypeThirdRowSubheading:
		_cebed.Value = "thirdRowSubheading"
	case ST_TableStyleTypePageFieldLabels:
		_cebed.Value = "pageFieldLabels"
	case ST_TableStyleTypePageFieldValues:
		_cebed.Value = "pageFieldValues"
	}
	return _cebed, nil
}
func (_bfdbbc ST_Scope) ValidateWithPath(path string) error {
	switch _bfdbbc {
	case 0, 1, 2, 3:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bfdbbc))
	}
	return nil
}
func (_edebce *CT_Tuple) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _agded := range start.Attr {
		if _agded.Name.Local == "fld" {
			_befefc, _edgdge := _g.ParseUint(_agded.Value, 10, 32)
			if _edgdge != nil {
				return _edgdge
			}
			_fccdbea := uint32(_befefc)
			_edebce.FldAttr = &_fccdbea
			continue
		}
		if _agded.Name.Local == "hier" {
			_cbgeb, _ecedg := _g.ParseUint(_agded.Value, 10, 32)
			if _ecedg != nil {
				return _ecedg
			}
			_dbcbgd := uint32(_cbgeb)
			_edebce.HierAttr = &_dbcbgd
			continue
		}
		if _agded.Name.Local == "item" {
			_bagabb, _ddgfg := _g.ParseUint(_agded.Value, 10, 32)
			if _ddgfg != nil {
				return _ddgfg
			}
			_edebce.ItemAttr = uint32(_bagabb)
			continue
		}
	}
	for {
		_gdcef, _cedae := d.Token()
		if _cedae != nil {
			return _bg.Errorf("parsing\u0020CT_Tuple: \u0025s", _cedae)
		}
		if _dgeeg, _egdabe := _gdcef.(_f.EndElement); _egdabe && _dgeeg.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_XmlColumnPr struct {

	// XML Map Id
	MapIdAttr uint32

	// XPath
	XpathAttr string

	// Denormalized
	DenormalizedAttr *bool

	// XML Data Type
	XmlDataTypeAttr string

	// Future Feature Data Storage Area
	ExtLst *CT_ExtensionList
}

func (_ggdbc ST_PhoneticType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_ggdbc.String(), start)
}
func (_gfac *CT_ConditionalFormatting) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _ggdaf := range start.Attr {
		if _ggdaf.Name.Local == "pivot" {
			_gdab, _fdbca := _g.ParseBool(_ggdaf.Value)
			if _fdbca != nil {
				return _fdbca
			}
			_gfac.PivotAttr = &_gdab
			continue
		}
		if _ggdaf.Name.Local == "sqref" {
			_bcbfa, _fdcbd := ParseSliceST_Sqref(_ggdaf.Value)
			if _fdcbd != nil {
				return _fdcbd
			}
			_gfac.SqrefAttr = &_bcbfa
			continue
		}
	}
_afcag:
	for {
		_dfce, _cffa := d.Token()
		if _cffa != nil {
			return _cffa
		}
		switch _fadf := _dfce.(type) {
		case _f.StartElement:
			switch _fadf.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "cfRule"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "cfRule"}:
				_gcgca := NewCT_CfRule()
				if _facac := d.DecodeElement(_gcgca, &_fadf); _facac != nil {
					return _facac
				}
				_gfac.CfRule = append(_gfac.CfRule, _gcgca)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "extLst"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "extLst"}:
				_gfac.ExtLst = NewCT_ExtensionList()
				if _fcbgc := d.DecodeElement(_gfac.ExtLst, &_fadf); _fcbgc != nil {
					return _fcbgc
				}
			default:
				_cb.Log("skipping\u0020unsupported element\u0020on\u0020CT_ConditionalFormatting\u0020%v", _fadf.Name)
				if _gfgd := d.Skip(); _gfgd != nil {
					return _gfgd
				}
			}
		case _f.EndElement:
			break _afcag
		case _f.CharData:
		}
	}
	return nil
}
func (_bgbfd ST_FormulaExpression) MarshalXMLAttr(name _f.Name) (_f.Attr, error) {
	_gfceff := _f.Attr{}
	_gfceff.Name = name
	switch _bgbfd {
	case ST_FormulaExpressionUnset:
		_gfceff.Value = ""
	case ST_FormulaExpressionRef:
		_gfceff.Value = "ref"
	case ST_FormulaExpressionRefError:
		_gfceff.Value = "refError"
	case ST_FormulaExpressionArea:
		_gfceff.Value = "area"
	case ST_FormulaExpressionAreaError:
		_gfceff.Value = "areaError"
	case ST_FormulaExpressionComputedArea:
		_gfceff.Value = "computedArea"
	}
	return _gfceff, nil
}
func NewCT_RangeSet() *CT_RangeSet { _fgeebg := &CT_RangeSet{}; return _fgeebg }

type ST_PatternType byte

// Validate validates the CT_CellProtection and its children
func (_baagd *CT_CellProtection) Validate() error {
	return _baagd.ValidateWithPath("CT_CellProtection")
}
func (_bdge *CT_ChartsheetPr) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _bdge.PublishedAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "published"}, Value: _bg.Sprintf("\u0025d", _fdbfb(*_bdge.PublishedAttr))})
	}
	if _bdge.CodeNameAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "codeName"}, Value: _bg.Sprintf("\u0025v", *_bdge.CodeNameAttr)})
	}
	e.EncodeToken(start)
	if _bdge.TabColor != nil {
		_bggd := _f.StartElement{Name: _f.Name{Local: "ma:tabColor"}}
		e.EncodeElement(_bdge.TabColor, _bggd)
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CalcChain and its children
func (_bcaag *CalcChain) Validate() error { return _bcaag.ValidateWithPath("CalcChain") }
func NewCT_WorkbookPr() *CT_WorkbookPr    { _ebeggg := &CT_WorkbookPr{}; return _ebeggg }
func (_cebb *EG_ExtensionList) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _cebb.Ext != nil {
		_efggf := _f.StartElement{Name: _f.Name{Local: "ma:ext"}}
		for _, _gcgadda := range _cebb.Ext {
			e.EncodeElement(_gcgadda, _efggf)
		}
	}
	return nil
}

// Validate validates the CT_MetadataBlocks and its children
func (_adbecf *CT_MetadataBlocks) Validate() error {
	return _adbecf.ValidateWithPath("CT_MetadataBlocks")
}
func (_eebad ST_HorizontalAlignment) ValidateWithPath(path string) error {
	switch _eebad {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8:
	default:
		return _bg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eebad))
	}
	return nil
}

// ValidateWithPath validates the CT_ExternalDefinedName and its children, prefixing error messages with path
func (_cabfe *CT_ExternalDefinedName) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_RangeSets and its children, prefixing error messages with path
func (_efbda *CT_RangeSets) ValidateWithPath(path string) error {
	for _efbdad, _eacag := range _efbda.RangeSet {
		if _fedbd := _eacag.ValidateWithPath(_bg.Sprintf("\u0025s\u002fRangeSet\u005b\u0025d\u005d", path, _efbdad)); _fedbd != nil {
			return _fedbd
		}
	}
	return nil
}
func (_abefef *CT_Tuples) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _gegcf := range start.Attr {
		if _gegcf.Name.Local == "c" {
			_defafd, _bcgbb := _g.ParseUint(_gegcf.Value, 10, 32)
			if _bcgbb != nil {
				return _bcgbb
			}
			_gbbfg := uint32(_defafd)
			_abefef.CAttr = &_gbbfg
			continue
		}
	}
_bfeaf:
	for {
		_bcgbgd, _accbcg := d.Token()
		if _accbcg != nil {
			return _accbcg
		}
		switch _ebbdg := _bcgbgd.(type) {
		case _f.StartElement:
			switch _ebbdg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tpl"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tpl"}:
				_ffefc := NewCT_Tuple()
				if _ddacg := d.DecodeElement(_ffefc, &_ebbdg); _ddacg != nil {
					return _ddacg
				}
				_abefef.Tpl = append(_abefef.Tpl, _ffefc)
			default:
				_cb.Log("skipping\u0020unsupported\u0020element on CT_Tuples \u0025v", _ebbdg.Name)
				if _gaebb := d.Skip(); _gaebb != nil {
					return _gaebb
				}
			}
		case _f.EndElement:
			break _bfeaf
		case _f.CharData:
		}
	}
	return nil
}
func (_aadc *CT_Fonts) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	if _aadc.CountAttr != nil {
		start.Attr = append(start.Attr, _f.Attr{Name: _f.Name{Local: "count"}, Value: _bg.Sprintf("\u0025v", *_aadc.CountAttr)})
	}
	e.EncodeToken(start)
	if _aadc.Font != nil {
		_cgaf := _f.StartElement{Name: _f.Name{Local: "ma:font"}}
		for _, _dfcc := range _aadc.Font {
			e.EncodeElement(_dfcc, _cgaf)
		}
	}
	e.EncodeToken(_f.EndElement{Name: start.Name})
	return nil
}
func NewCT_CalcChain() *CT_CalcChain { _cggfc := &CT_CalcChain{}; return _cggfc }
func (_bfdba ST_SheetViewType) MarshalXML(e *_f.Encoder, start _f.StartElement) error {
	return e.EncodeElement(_bfdba.String(), start)
}
func init() {
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_AutoFilter", NewCT_AutoFilter)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FilterColumn", NewCT_FilterColumn)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Filters", NewCT_Filters)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Filter", NewCT_Filter)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CustomFilters", NewCT_CustomFilters)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CustomFilter", NewCT_CustomFilter)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Top10", NewCT_Top10)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ColorFilter", NewCT_ColorFilter)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_IconFilter", NewCT_IconFilter)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DynamicFilter", NewCT_DynamicFilter)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SortState", NewCT_SortState)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SortCondition", NewCT_SortCondition)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DateGroupItem", NewCT_DateGroupItem)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_XStringElement", NewCT_XStringElement)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Extension", NewCT_Extension)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ObjectAnchor", NewCT_ObjectAnchor)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExtensionList", NewCT_ExtensionList)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CalcChain", NewCT_CalcChain)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CalcCell", NewCT_CalcCell)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Comments", NewCT_Comments)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Authors", NewCT_Authors)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CommentList", NewCT_CommentList)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Comment", NewCT_Comment)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CommentPr", NewCT_CommentPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MapInfo", NewCT_MapInfo)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Schema", NewCT_Schema)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Map", NewCT_Map)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DataBinding", NewCT_DataBinding)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Connections", NewCT_Connections)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Connection", NewCT_Connection)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DbPr", NewCT_DbPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_OlapPr", NewCT_OlapPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_WebPr", NewCT_WebPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Parameters", NewCT_Parameters)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Parameter", NewCT_Parameter)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Tables", NewCT_Tables)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TableMissing", NewCT_TableMissing)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TextPr", NewCT_TextPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TextFields", NewCT_TextFields)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TextField", NewCT_TextField)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotCacheDefinition", NewCT_PivotCacheDefinition)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CacheFields", NewCT_CacheFields)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CacheField", NewCT_CacheField)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CacheSource", NewCT_CacheSource)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_WorksheetSource", NewCT_WorksheetSource)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Consolidation", NewCT_Consolidation)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Pages", NewCT_Pages)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PCDSCPage", NewCT_PCDSCPage)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PageItem", NewCT_PageItem)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RangeSets", NewCT_RangeSets)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RangeSet", NewCT_RangeSet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SharedItems", NewCT_SharedItems)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Missing", NewCT_Missing)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Number", NewCT_Number)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Boolean", NewCT_Boolean)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Error", NewCT_Error)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_String", NewCT_String)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DateTime", NewCT_DateTime)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FieldGroup", NewCT_FieldGroup)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RangePr", NewCT_RangePr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DiscretePr", NewCT_DiscretePr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_GroupItems", NewCT_GroupItems)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotCacheRecords", NewCT_PivotCacheRecords)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Record", NewCT_Record)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PCDKPIs", NewCT_PCDKPIs)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PCDKPI", NewCT_PCDKPI)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CacheHierarchies", NewCT_CacheHierarchies)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CacheHierarchy", NewCT_CacheHierarchy)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FieldsUsage", NewCT_FieldsUsage)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FieldUsage", NewCT_FieldUsage)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_GroupLevels", NewCT_GroupLevels)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_GroupLevel", NewCT_GroupLevel)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Groups", NewCT_Groups)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_LevelGroup", NewCT_LevelGroup)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_GroupMembers", NewCT_GroupMembers)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_GroupMember", NewCT_GroupMember)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TupleCache", NewCT_TupleCache)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ServerFormat", NewCT_ServerFormat)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ServerFormats", NewCT_ServerFormats)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PCDSDTCEntries", NewCT_PCDSDTCEntries)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Tuples", NewCT_Tuples)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Tuple", NewCT_Tuple)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Sets", NewCT_Sets)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Set", NewCT_Set)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_QueryCache", NewCT_QueryCache)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Query", NewCT_Query)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CalculatedItems", NewCT_CalculatedItems)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CalculatedItem", NewCT_CalculatedItem)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CalculatedMembers", NewCT_CalculatedMembers)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CalculatedMember", NewCT_CalculatedMember)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_pivotTableDefinition", NewCT_pivotTableDefinition)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Location", NewCT_Location)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotFields", NewCT_PivotFields)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotField", NewCT_PivotField)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_AutoSortScope", NewCT_AutoSortScope)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Items", NewCT_Items)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Item", NewCT_Item)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PageFields", NewCT_PageFields)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PageField", NewCT_PageField)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DataFields", NewCT_DataFields)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DataField", NewCT_DataField)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_rowItems", NewCT_rowItems)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_colItems", NewCT_colItems)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_I", NewCT_I)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_X", NewCT_X)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RowFields", NewCT_RowFields)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ColFields", NewCT_ColFields)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Field", NewCT_Field)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Formats", NewCT_Formats)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Format", NewCT_Format)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ConditionalFormats", NewCT_ConditionalFormats)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ConditionalFormat", NewCT_ConditionalFormat)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotAreas", NewCT_PivotAreas)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ChartFormats", NewCT_ChartFormats)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ChartFormat", NewCT_ChartFormat)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotHierarchies", NewCT_PivotHierarchies)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotHierarchy", NewCT_PivotHierarchy)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RowHierarchiesUsage", NewCT_RowHierarchiesUsage)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ColHierarchiesUsage", NewCT_ColHierarchiesUsage)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_HierarchyUsage", NewCT_HierarchyUsage)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MemberProperties", NewCT_MemberProperties)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MemberProperty", NewCT_MemberProperty)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Members", NewCT_Members)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Member", NewCT_Member)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Dimensions", NewCT_Dimensions)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotDimension", NewCT_PivotDimension)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MeasureGroups", NewCT_MeasureGroups)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MeasureDimensionMaps", NewCT_MeasureDimensionMaps)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MeasureGroup", NewCT_MeasureGroup)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MeasureDimensionMap", NewCT_MeasureDimensionMap)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotTableStyle", NewCT_PivotTableStyle)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotFilters", NewCT_PivotFilters)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotFilter", NewCT_PivotFilter)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotArea", NewCT_PivotArea)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotAreaReferences", NewCT_PivotAreaReferences)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotAreaReference", NewCT_PivotAreaReference)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Index", NewCT_Index)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_QueryTable", NewCT_QueryTable)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_QueryTableRefresh", NewCT_QueryTableRefresh)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_QueryTableDeletedFields", NewCT_QueryTableDeletedFields)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DeletedField", NewCT_DeletedField)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_QueryTableFields", NewCT_QueryTableFields)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_QueryTableField", NewCT_QueryTableField)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Sst", NewCT_Sst)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PhoneticRun", NewCT_PhoneticRun)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RElt", NewCT_RElt)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RPrElt", NewCT_RPrElt)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Rst", NewCT_Rst)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PhoneticPr", NewCT_PhoneticPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionHeaders", NewCT_RevisionHeaders)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Revisions", NewCT_Revisions)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionHeader", NewCT_RevisionHeader)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SheetIdMap", NewCT_SheetIdMap)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SheetId", NewCT_SheetId)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ReviewedRevisions", NewCT_ReviewedRevisions)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Reviewed", NewCT_Reviewed)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_UndoInfo", NewCT_UndoInfo)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionRowColumn", NewCT_RevisionRowColumn)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionMove", NewCT_RevisionMove)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionCustomView", NewCT_RevisionCustomView)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionSheetRename", NewCT_RevisionSheetRename)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionInsertSheet", NewCT_RevisionInsertSheet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionCellChange", NewCT_RevisionCellChange)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionFormatting", NewCT_RevisionFormatting)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionAutoFormatting", NewCT_RevisionAutoFormatting)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionComment", NewCT_RevisionComment)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionDefinedName", NewCT_RevisionDefinedName)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionConflict", NewCT_RevisionConflict)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RevisionQueryTableField", NewCT_RevisionQueryTableField)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Users", NewCT_Users)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SharedUser", NewCT_SharedUser)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Macrosheet", NewCT_Macrosheet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Dialogsheet", NewCT_Dialogsheet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Worksheet", NewCT_Worksheet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SheetData", NewCT_SheetData)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SheetCalcPr", NewCT_SheetCalcPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SheetFormatPr", NewCT_SheetFormatPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Cols", NewCT_Cols)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Col", NewCT_Col)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Row", NewCT_Row)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Cell", NewCT_Cell)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SheetPr", NewCT_SheetPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SheetDimension", NewCT_SheetDimension)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SheetViews", NewCT_SheetViews)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SheetView", NewCT_SheetView)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Pane", NewCT_Pane)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotSelection", NewCT_PivotSelection)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Selection", NewCT_Selection)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PageBreak", NewCT_PageBreak)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Break", NewCT_Break)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_OutlinePr", NewCT_OutlinePr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PageSetUpPr", NewCT_PageSetUpPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DataConsolidate", NewCT_DataConsolidate)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DataRefs", NewCT_DataRefs)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DataRef", NewCT_DataRef)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MergeCells", NewCT_MergeCells)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MergeCell", NewCT_MergeCell)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SmartTags", NewCT_SmartTags)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellSmartTags", NewCT_CellSmartTags)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellSmartTag", NewCT_CellSmartTag)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellSmartTagPr", NewCT_CellSmartTagPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Drawing", NewCT_Drawing)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_LegacyDrawing", NewCT_LegacyDrawing)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DrawingHF", NewCT_DrawingHF)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CustomSheetViews", NewCT_CustomSheetViews)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CustomSheetView", NewCT_CustomSheetView)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DataValidations", NewCT_DataValidations)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DataValidation", NewCT_DataValidation)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ConditionalFormatting", NewCT_ConditionalFormatting)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CfRule", NewCT_CfRule)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Hyperlinks", NewCT_Hyperlinks)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Hyperlink", NewCT_Hyperlink)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellFormula", NewCT_CellFormula)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ColorScale", NewCT_ColorScale)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DataBar", NewCT_DataBar)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_IconSet", NewCT_IconSet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Cfvo", NewCT_Cfvo)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PageMargins", NewCT_PageMargins)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PrintOptions", NewCT_PrintOptions)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PageSetup", NewCT_PageSetup)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_HeaderFooter", NewCT_HeaderFooter)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Scenarios", NewCT_Scenarios)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SheetProtection", NewCT_SheetProtection)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ProtectedRanges", NewCT_ProtectedRanges)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ProtectedRange", NewCT_ProtectedRange)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Scenario", NewCT_Scenario)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_InputCells", NewCT_InputCells)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellWatches", NewCT_CellWatches)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellWatch", NewCT_CellWatch)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Chartsheet", NewCT_Chartsheet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ChartsheetPr", NewCT_ChartsheetPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ChartsheetViews", NewCT_ChartsheetViews)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ChartsheetView", NewCT_ChartsheetView)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ChartsheetProtection", NewCT_ChartsheetProtection)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CsPageSetup", NewCT_CsPageSetup)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CustomChartsheetViews", NewCT_CustomChartsheetViews)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CustomChartsheetView", NewCT_CustomChartsheetView)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CustomProperties", NewCT_CustomProperties)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CustomProperty", NewCT_CustomProperty)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_OleObjects", NewCT_OleObjects)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_OleObject", NewCT_OleObject)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ObjectPr", NewCT_ObjectPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_WebPublishItems", NewCT_WebPublishItems)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_WebPublishItem", NewCT_WebPublishItem)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Controls", NewCT_Controls)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Control", NewCT_Control)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ControlPr", NewCT_ControlPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_IgnoredErrors", NewCT_IgnoredErrors)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_IgnoredError", NewCT_IgnoredError)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TableParts", NewCT_TableParts)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TablePart", NewCT_TablePart)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Metadata", NewCT_Metadata)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MetadataTypes", NewCT_MetadataTypes)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MetadataType", NewCT_MetadataType)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MetadataBlocks", NewCT_MetadataBlocks)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MetadataBlock", NewCT_MetadataBlock)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MetadataRecord", NewCT_MetadataRecord)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FutureMetadata", NewCT_FutureMetadata)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FutureMetadataBlock", NewCT_FutureMetadataBlock)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MdxMetadata", NewCT_MdxMetadata)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Mdx", NewCT_Mdx)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MdxTuple", NewCT_MdxTuple)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MdxSet", NewCT_MdxSet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MdxMemeberProp", NewCT_MdxMemeberProp)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MdxKPI", NewCT_MdxKPI)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MetadataStringIndex", NewCT_MetadataStringIndex)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MetadataStrings", NewCT_MetadataStrings)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SingleXmlCells", NewCT_SingleXmlCells)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SingleXmlCell", NewCT_SingleXmlCell)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_XmlCellPr", NewCT_XmlCellPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_XmlPr", NewCT_XmlPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Stylesheet", NewCT_Stylesheet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellAlignment", NewCT_CellAlignment)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Borders", NewCT_Borders)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Border", NewCT_Border)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_BorderPr", NewCT_BorderPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellProtection", NewCT_CellProtection)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Fonts", NewCT_Fonts)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Fills", NewCT_Fills)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Fill", NewCT_Fill)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PatternFill", NewCT_PatternFill)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Color", NewCT_Color)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_GradientFill", NewCT_GradientFill)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_GradientStop", NewCT_GradientStop)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_NumFmts", NewCT_NumFmts)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_NumFmt", NewCT_NumFmt)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellStyleXfs", NewCT_CellStyleXfs)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellXfs", NewCT_CellXfs)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Xf", NewCT_Xf)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellStyles", NewCT_CellStyles)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CellStyle", NewCT_CellStyle)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Dxfs", NewCT_Dxfs)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Dxf", NewCT_Dxf)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Colors", NewCT_Colors)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_IndexedColors", NewCT_IndexedColors)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_MRUColors", NewCT_MRUColors)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_RgbColor", NewCT_RgbColor)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TableStyles", NewCT_TableStyles)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TableStyle", NewCT_TableStyle)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TableStyleElement", NewCT_TableStyleElement)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_BooleanProperty", NewCT_BooleanProperty)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FontSize", NewCT_FontSize)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_IntProperty", NewCT_IntProperty)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FontName", NewCT_FontName)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_VerticalAlignFontProperty", NewCT_VerticalAlignFontProperty)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FontScheme", NewCT_FontScheme)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_UnderlineProperty", NewCT_UnderlineProperty)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Font", NewCT_Font)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FontFamily", NewCT_FontFamily)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalLink", NewCT_ExternalLink)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalBook", NewCT_ExternalBook)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalSheetNames", NewCT_ExternalSheetNames)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalSheetName", NewCT_ExternalSheetName)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalDefinedNames", NewCT_ExternalDefinedNames)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalDefinedName", NewCT_ExternalDefinedName)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalSheetDataSet", NewCT_ExternalSheetDataSet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalSheetData", NewCT_ExternalSheetData)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalRow", NewCT_ExternalRow)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalCell", NewCT_ExternalCell)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DdeLink", NewCT_DdeLink)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DdeItems", NewCT_DdeItems)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DdeItem", NewCT_DdeItem)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DdeValues", NewCT_DdeValues)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DdeValue", NewCT_DdeValue)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_OleLink", NewCT_OleLink)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_OleItems", NewCT_OleItems)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_OleItem", NewCT_OleItem)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Table", NewCT_Table)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TableStyleInfo", NewCT_TableStyleInfo)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TableColumns", NewCT_TableColumns)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TableColumn", NewCT_TableColumn)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_TableFormula", NewCT_TableFormula)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_XmlColumnPr", NewCT_XmlColumnPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_VolTypes", NewCT_VolTypes)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_VolType", NewCT_VolType)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_VolMain", NewCT_VolMain)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_VolTopic", NewCT_VolTopic)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_VolTopicRef", NewCT_VolTopicRef)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Workbook", NewCT_Workbook)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FileVersion", NewCT_FileVersion)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_BookViews", NewCT_BookViews)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_BookView", NewCT_BookView)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CustomWorkbookViews", NewCT_CustomWorkbookViews)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CustomWorkbookView", NewCT_CustomWorkbookView)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Sheets", NewCT_Sheets)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_Sheet", NewCT_Sheet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_WorkbookPr", NewCT_WorkbookPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SmartTagPr", NewCT_SmartTagPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SmartTagTypes", NewCT_SmartTagTypes)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SmartTagType", NewCT_SmartTagType)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FileRecoveryPr", NewCT_FileRecoveryPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_CalcPr", NewCT_CalcPr)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DefinedNames", NewCT_DefinedNames)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_DefinedName", NewCT_DefinedName)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalReferences", NewCT_ExternalReferences)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_ExternalReference", NewCT_ExternalReference)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_SheetBackgroundPicture", NewCT_SheetBackgroundPicture)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotCaches", NewCT_PivotCaches)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_PivotCache", NewCT_PivotCache)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FileSharing", NewCT_FileSharing)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_OleSize", NewCT_OleSize)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_WorkbookProtection", NewCT_WorkbookProtection)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_WebPublishing", NewCT_WebPublishing)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FunctionGroups", NewCT_FunctionGroups)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_FunctionGroup", NewCT_FunctionGroup)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_WebPublishObjects", NewCT_WebPublishObjects)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "CT_WebPublishObject", NewCT_WebPublishObject)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "calcChain", NewCalcChain)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "comments", NewComments)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "MapInfo", NewMapInfo)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "connections", NewConnections)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "pivotCacheDefinition", NewPivotCacheDefinition)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "pivotCacheRecords", NewPivotCacheRecords)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "pivotTableDefinition", NewPivotTableDefinition)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "queryTable", NewQueryTable)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "sst", NewSst)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "headers", NewHeaders)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "revisions", NewRevisions)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "users", NewUsers)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "worksheet", NewWorksheet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "chartsheet", NewChartsheet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "dialogsheet", NewDialogsheet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "metadata", NewMetadata)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "singleXmlCells", NewSingleXmlCells)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "styleSheet", NewStyleSheet)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "externalLink", NewExternalLink)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "table", NewTable)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "volTypes", NewVolTypes)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "workbook", NewWorkbook)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "EG_ExtensionList", NewEG_ExtensionList)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "AG_RevData", NewAG_RevData)
	_cb.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", "AG_AutoFormat", NewAG_AutoFormat)
}
func (_gddbg *CT_Set) UnmarshalXML(d *_f.Decoder, start _f.StartElement) error {
	for _, _agbcd := range start.Attr {
		if _agbcd.Name.Local == "count" {
			_ddafe, _gdfaf := _g.ParseUint(_agbcd.Value, 10, 32)
			if _gdfaf != nil {
				return _gdfaf
			}
			_fafab := uint32(_ddafe)
			_gddbg.CountAttr = &_fafab
			continue
		}
		if _agbcd.Name.Local == "maxRank" {
			_ecbcfa, _addea := _g.ParseInt(_agbcd.Value, 10, 32)
			if _addea != nil {
				return _addea
			}
			_gddbg.MaxRankAttr = int32(_ecbcfa)
			continue
		}
		if _agbcd.Name.Local == "setDefinition" {
			_dcaee, _bbdaf := _agbcd.Value, error(nil)
			if _bbdaf != nil {
				return _bbdaf
			}
			_gddbg.SetDefinitionAttr = _dcaee
			continue
		}
		if _agbcd.Name.Local == "sortType" {
			_gddbg.SortTypeAttr.UnmarshalXMLAttr(_agbcd)
			continue
		}
		if _agbcd.Name.Local == "queryFailed" {
			_gdgb, _fdgfc := _g.ParseBool(_agbcd.Value)
			if _fdgfc != nil {
				return _fdgfc
			}
			_gddbg.QueryFailedAttr = &_gdgb
			continue
		}
	}
_bdaabc:
	for {
		_aeaae, _gbcgf := d.Token()
		if _gbcgf != nil {
			return _gbcgf
		}
		switch _ccgcg := _aeaae.(type) {
		case _f.StartElement:
			switch _ccgcg.Name {
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "tpls"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "tpls"}:
				_fecd := NewCT_Tuples()
				if _efcbg := d.DecodeElement(_fecd, &_ccgcg); _efcbg != nil {
					return _efcbg
				}
				_gddbg.Tpls = append(_gddbg.Tpls, _fecd)
			case _f.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg/spreadsheetml\u002f2006\u002fmain", Local: "sortByTuple"}, _f.Name{Space: "http:\u002f\u002fpurl\u002eoclc.org\u002fooxml\u002fspreadsheetml\u002fmain", Local: "sortByTuple"}:
				_gddbg.SortByTuple = NewCT_Tuples()
				if _fddagf := d.DecodeElement(_gddbg.SortByTuple, &_ccgcg); _fddagf != nil {
					return _fddagf
				}
			default:
				_cb.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Set\u0020\u0025v", _ccgcg.Name)
				if _badbe := d.Skip(); _badbe != nil {
					return _badbe
				}
			}
		case _f.EndElement:
			break _bdaabc
		case _f.CharData:
		}
	}
	return nil
}
func NewCT_Row() *CT_Row { _bdgab := &CT_Row{}; return _bdgab }
