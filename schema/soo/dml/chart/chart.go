//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package chart

import (
	_fa "encoding/xml"
	_gg "fmt"
	_b "gitee.com/greatmusicians/unioffice"
	_cb "gitee.com/greatmusicians/unioffice/schema/soo/dml"
	_gd "gitee.com/greatmusicians/unioffice/schema/soo/dml/chartDrawing"
	_e "gitee.com/greatmusicians/unioffice/schema/soo/ofc/sharedTypes"
	_g "regexp"
	_c "strconv"
)

func NewCT_OfPieChart() *CT_OfPieChart {
	_beda := &CT_OfPieChart{}
	_beda.OfPieType = NewCT_OfPieType()
	return _beda
}

type CT_TickMark struct{ ValAttr ST_TickMark }

// ValidateWithPath validates the CT_Orientation and its children, prefixing error messages with path
func (_ebdc *CT_Orientation) ValidateWithPath(path string) error {
	if _agfgc := _ebdc.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _agfgc != nil {
		return _agfgc
	}
	return nil
}
func NewCT_LogBase() *CT_LogBase { _edgge := &CT_LogBase{}; _edgge.ValAttr = 2; return _edgge }

// ValidateWithPath validates the CT_DepthPercent and its children, prefixing error messages with path
func (_efff *CT_DepthPercent) ValidateWithPath(path string) error {
	if _efff.ValAttr != nil {
		if _gfca := _efff.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _gfca != nil {
			return _gfca
		}
	}
	return nil
}

type CT_Double struct{ ValAttr float64 }

func (_bgabe *CT_SecondPieSize) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _bgabe.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_bgabe.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_fdee *CT_DepthPercent) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _eccb := range start.Attr {
		if _eccb.Name.Local == "val" {
			_cbab, _bbgcf := ParseUnionST_DepthPercent(_eccb.Value)
			if _bbgcf != nil {
				return _bbgcf
			}
			_fdee.ValAttr = &_cbab
			continue
		}
	}
	for {
		_eacc, _cbagf := d.Token()
		if _cbagf != nil {
			return _gg.Errorf("parsing CT_DepthPercent:\u0020\u0025s", _cbagf)
		}
		if _beed, _cfcea := _eacc.(_fa.EndElement); _cfcea && _beed.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_AreaChart and its children, prefixing error messages with path
func (_aab *CT_AreaChart) ValidateWithPath(path string) error {
	if _aab.Grouping != nil {
		if _ceg := _aab.Grouping.ValidateWithPath(path + "\u002fGrouping"); _ceg != nil {
			return _ceg
		}
	}
	if _aab.VaryColors != nil {
		if _eed := _aab.VaryColors.ValidateWithPath(path + "/VaryColors"); _eed != nil {
			return _eed
		}
	}
	for _bdg, _afe := range _aab.Ser {
		if _edg := _afe.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _bdg)); _edg != nil {
			return _edg
		}
	}
	if _aab.DLbls != nil {
		if _ae := _aab.DLbls.ValidateWithPath(path + "\u002fDLbls"); _ae != nil {
			return _ae
		}
	}
	if _aab.DropLines != nil {
		if _fgb := _aab.DropLines.ValidateWithPath(path + "\u002fDropLines"); _fgb != nil {
			return _fgb
		}
	}
	for _cgg, _cf := range _aab.AxId {
		if _dd := _cf.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _cgg)); _dd != nil {
			return _dd
		}
	}
	if _aab.ExtLst != nil {
		if _eef := _aab.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eef != nil {
			return _eef
		}
	}
	return nil
}

// Validate validates the CT_Style and its children
func (_bgefd *CT_Style) Validate() error { return _bgefd.ValidateWithPath("CT_Style") }

// Validate validates the CT_ErrBarType and its children
func (_dggda *CT_ErrBarType) Validate() error { return _dggda.ValidateWithPath("CT_ErrBarType") }
func (_cbecc *CT_RotX) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _fdacbg := range start.Attr {
		if _fdacbg.Name.Local == "val" {
			_baaba, _ecffc := _c.ParseInt(_fdacbg.Value, 10, 8)
			if _ecffc != nil {
				return _ecffc
			}
			_faac := int8(_baaba)
			_cbecc.ValAttr = &_faac
			continue
		}
	}
	for {
		_dbca, _dgdd := d.Token()
		if _dgdd != nil {
			return _gg.Errorf("parsing\u0020CT_RotX:\u0020\u0025s", _dgdd)
		}
		if _gcddd, _gcdf := _dbca.(_fa.EndElement); _gcdf && _gcddd.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Crosses struct{ ValAttr ST_Crosses }

func NewCT_UpDownBar() *CT_UpDownBar { _acffe := &CT_UpDownBar{}; return _acffe }
func (_gfggg ST_TickLblPos) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_gfggg.String(), start)
}
func NewCT_TickMark() *CT_TickMark { _dfefa := &CT_TickMark{}; return _dfefa }

type EG_DLblShared struct {
	NumFmt         *CT_NumFmt
	SpPr           *_cb.CT_ShapeProperties
	TxPr           *_cb.CT_TextBody
	DLblPos        *CT_DLblPos
	ShowLegendKey  *CT_Boolean
	ShowVal        *CT_Boolean
	ShowCatName    *CT_Boolean
	ShowSerName    *CT_Boolean
	ShowPercent    *CT_Boolean
	ShowBubbleSize *CT_Boolean
	Separator      *string
}

func NewCT_PivotFmt() *CT_PivotFmt {
	_gfcc := &CT_PivotFmt{}
	_gfcc.Idx = NewCT_UnsignedInt()
	return _gfcc
}
func (_cgea *CT_DLblPos) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_cgea.ValAttr = ST_DLblPos(1)
	for _, _geca := range start.Attr {
		if _geca.Name.Local == "val" {
			_cgea.ValAttr.UnmarshalXMLAttr(_geca)
			continue
		}
	}
	for {
		_fecc, _eefg := d.Token()
		if _eefg != nil {
			return _gg.Errorf("parsing\u0020CT_DLblPos:\u0020%s", _eefg)
		}
		if _dadc, _eeafc := _fecc.(_fa.EndElement); _eeafc && _dadc.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_LegendPos() *CT_LegendPos { _dgde := &CT_LegendPos{}; return _dgde }

// ValidateWithPath validates the CT_HPercent and its children, prefixing error messages with path
func (_aacef *CT_HPercent) ValidateWithPath(path string) error {
	if _aacef.ValAttr != nil {
		if _fead := _aacef.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _fead != nil {
			return _fead
		}
	}
	return nil
}
func (_bbeb *CT_ScatterSer) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bbeb.Idx = NewCT_UnsignedInt()
	_bbeb.Order = NewCT_UnsignedInt()
_geeed:
	for {
		_dcbcg, _bgfcb := d.Token()
		if _bgfcb != nil {
			return _bgfcb
		}
		switch _cdaec := _dcbcg.(type) {
		case _fa.StartElement:
			switch _cdaec.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _dbfe := d.DecodeElement(_bbeb.Idx, &_cdaec); _dbfe != nil {
					return _dbfe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "order"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "order"}:
				if _fgeddd := d.DecodeElement(_bbeb.Order, &_cdaec); _fgeddd != nil {
					return _fgeddd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_bbeb.Tx = NewCT_SerTx()
				if _aabe := d.DecodeElement(_bbeb.Tx, &_cdaec); _aabe != nil {
					return _aabe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_bbeb.SpPr = _cb.NewCT_ShapeProperties()
				if _efeeg := d.DecodeElement(_bbeb.SpPr, &_cdaec); _efeeg != nil {
					return _efeeg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "marker"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "marker"}:
				_bbeb.Marker = NewCT_Marker()
				if _cgcbda := d.DecodeElement(_bbeb.Marker, &_cdaec); _cgcbda != nil {
					return _cgcbda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dPt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dPt"}:
				_edfce := NewCT_DPt()
				if _gggdf := d.DecodeElement(_edfce, &_cdaec); _gggdf != nil {
					return _gggdf
				}
				_bbeb.DPt = append(_bbeb.DPt, _edfce)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_bbeb.DLbls = NewCT_DLbls()
				if _efdfag := d.DecodeElement(_bbeb.DLbls, &_cdaec); _efdfag != nil {
					return _efdfag
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "trendline"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "trendline"}:
				_ddba := NewCT_Trendline()
				if _gafeg := d.DecodeElement(_ddba, &_cdaec); _gafeg != nil {
					return _gafeg
				}
				_bbeb.Trendline = append(_bbeb.Trendline, _ddba)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "errBars"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "errBars"}:
				_fgcdg := NewCT_ErrBars()
				if _daeefd := d.DecodeElement(_fgcdg, &_cdaec); _daeefd != nil {
					return _daeefd
				}
				_bbeb.ErrBars = append(_bbeb.ErrBars, _fgcdg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "xVal"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "xVal"}:
				_bbeb.XVal = NewCT_AxDataSource()
				if _bffcg := d.DecodeElement(_bbeb.XVal, &_cdaec); _bffcg != nil {
					return _bffcg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "yVal"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "yVal"}:
				_bbeb.YVal = NewCT_NumDataSource()
				if _gcdg := d.DecodeElement(_bbeb.YVal, &_cdaec); _gcdg != nil {
					return _gcdg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "smooth"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "smooth"}:
				_bbeb.Smooth = NewCT_Boolean()
				if _afeac := d.DecodeElement(_bbeb.Smooth, &_cdaec); _afeac != nil {
					return _afeac
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_bbeb.ExtLst = NewCT_ExtensionList()
				if _fdfce := d.DecodeElement(_bbeb.ExtLst, &_cdaec); _fdfce != nil {
					return _fdfce
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_ScatterSer \u0025v", _cdaec.Name)
				if _gcfc := d.Skip(); _gcfc != nil {
					return _gcfc
				}
			}
		case _fa.EndElement:
			break _geeed
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Period and its children
func (_gcafd *CT_Period) Validate() error { return _gcafd.ValidateWithPath("CT_Period") }

type CT_LegendPos struct{ ValAttr ST_LegendPos }

func NewCT_AxDataSourceChoice() *CT_AxDataSourceChoice { _eab := &CT_AxDataSourceChoice{}; return _eab }
func (_aedff ST_TimeUnit) Validate() error             { return _aedff.ValidateWithPath("") }
func (_ggad ST_LayoutMode) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_ggad.String(), start)
}
func (_dccdg *CT_MarkerStyle) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_dccdg.ValAttr = ST_MarkerStyle(1)
	for _, _bgad := range start.Attr {
		if _bgad.Name.Local == "val" {
			_dccdg.ValAttr.UnmarshalXMLAttr(_bgad)
			continue
		}
	}
	for {
		_adbg, _dfgb := d.Token()
		if _dfgb != nil {
			return _gg.Errorf("parsing\u0020CT_MarkerStyle:\u0020\u0025s", _dfgb)
		}
		if _ebcgb, _bdda := _adbg.(_fa.EndElement); _bdda && _ebcgb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_edgg *CT_Line3DChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_ffgg := _fa.StartElement{Name: _fa.Name{Local: "c:grouping"}}
	e.EncodeElement(_edgg.Grouping, _ffgg)
	if _edgg.VaryColors != nil {
		_fcfcg := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_edgg.VaryColors, _fcfcg)
	}
	if _edgg.Ser != nil {
		_fdefa := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _gcecf := range _edgg.Ser {
			e.EncodeElement(_gcecf, _fdefa)
		}
	}
	if _edgg.DLbls != nil {
		_gdge := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_edgg.DLbls, _gdge)
	}
	if _edgg.DropLines != nil {
		_dbbg := _fa.StartElement{Name: _fa.Name{Local: "c:dropLines"}}
		e.EncodeElement(_edgg.DropLines, _dbbg)
	}
	if _edgg.GapDepth != nil {
		_fadg := _fa.StartElement{Name: _fa.Name{Local: "c:gapDepth"}}
		e.EncodeElement(_edgg.GapDepth, _fadg)
	}
	_dbbc := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _bfaec := range _edgg.AxId {
		e.EncodeElement(_bfaec, _dbbc)
	}
	if _edgg.ExtLst != nil {
		_adcc := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_edgg.ExtLst, _adcc)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_eedg *CT_BandFmt) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_eedg.Idx = NewCT_UnsignedInt()
_gbdd:
	for {
		_ceb, _bfe := d.Token()
		if _bfe != nil {
			return _bfe
		}
		switch _deg := _ceb.(type) {
		case _fa.StartElement:
			switch _deg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _aec := d.DecodeElement(_eedg.Idx, &_deg); _aec != nil {
					return _aec
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_eedg.SpPr = _cb.NewCT_ShapeProperties()
				if _acd := d.DecodeElement(_eedg.SpPr, &_deg); _acd != nil {
					return _acd
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_BandFmt\u0020\u0025v", _deg.Name)
				if _eaa := d.Skip(); _eaa != nil {
					return _eaa
				}
			}
		case _fa.EndElement:
			break _gbdd
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_DLblPos and its children
func (_ebgbf *CT_DLblPos) Validate() error { return _ebgbf.ValidateWithPath("CT_DLblPos") }
func (_cgafc *EG_BarChartShared) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_cgafc.BarDir = NewCT_BarDir()
_fddc:
	for {
		_bbbf, _afgg := d.Token()
		if _afgg != nil {
			return _afgg
		}
		switch _gcbfg := _bbbf.(type) {
		case _fa.StartElement:
			switch _gcbfg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "barDir"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "barDir"}:
				if _fbbbe := d.DecodeElement(_cgafc.BarDir, &_gcbfg); _fbbbe != nil {
					return _fbbbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "grouping"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "grouping"}:
				_cgafc.Grouping = NewCT_BarGrouping()
				if _cffafg := d.DecodeElement(_cgafc.Grouping, &_gcbfg); _cffafg != nil {
					return _cffafg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_cgafc.VaryColors = NewCT_Boolean()
				if _gbee := d.DecodeElement(_cgafc.VaryColors, &_gcbfg); _gbee != nil {
					return _gbee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_eeegb := NewCT_BarSer()
				if _dgae := d.DecodeElement(_eeegb, &_gcbfg); _dgae != nil {
					return _dgae
				}
				_cgafc.Ser = append(_cgafc.Ser, _eeegb)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_cgafc.DLbls = NewCT_DLbls()
				if _accc := d.DecodeElement(_cgafc.DLbls, &_gcbfg); _accc != nil {
					return _accc
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020EG_BarChartShared\u0020\u0025v", _gcbfg.Name)
				if _cgeda := d.Skip(); _cgeda != nil {
					return _cgeda
				}
			}
		case _fa.EndElement:
			break _fddc
		case _fa.CharData:
		}
	}
	return nil
}
func (_bfgfa ST_ErrDir) ValidateWithPath(path string) error {
	switch _bfgfa {
	case 0, 1, 2:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bfgfa))
	}
	return nil
}

const (
	ST_ErrValTypeUnset      ST_ErrValType = 0
	ST_ErrValTypeCust       ST_ErrValType = 1
	ST_ErrValTypeFixedVal   ST_ErrValType = 2
	ST_ErrValTypePercentage ST_ErrValType = 3
	ST_ErrValTypeStdDev     ST_ErrValType = 4
	ST_ErrValTypeStdErr     ST_ErrValType = 5
)

func (_cbgefe ST_ErrBarType) Validate() error { return _cbgefe.ValidateWithPath("") }
func (_bdgc *EG_SurfaceChartShared) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _bdgc.Wireframe != nil {
		_cdfb := _fa.StartElement{Name: _fa.Name{Local: "c:wireframe"}}
		e.EncodeElement(_bdgc.Wireframe, _cdfb)
	}
	if _bdgc.Ser != nil {
		_ddagec := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _aebff := range _bdgc.Ser {
			e.EncodeElement(_aebff, _ddagec)
		}
	}
	if _bdgc.BandFmts != nil {
		_aeecc := _fa.StartElement{Name: _fa.Name{Local: "c:bandFmts"}}
		e.EncodeElement(_bdgc.BandFmts, _aeecc)
	}
	return nil
}

type CT_BarChart struct {
	BarDir     *CT_BarDir
	Grouping   *CT_BarGrouping
	VaryColors *CT_Boolean
	Ser        []*CT_BarSer
	DLbls      *CT_DLbls
	GapWidth   *CT_GapAmount
	Overlap    *CT_Overlap
	SerLines   []*CT_ChartLines
	AxId       []*CT_UnsignedInt
	ExtLst     *CT_ExtensionList
}

func (_aaeba ST_ErrValType) ValidateWithPath(path string) error {
	switch _aaeba {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aaeba))
	}
	return nil
}
func (_agagd *CT_TimeUnit) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _dedcg := range start.Attr {
		if _dedcg.Name.Local == "val" {
			_agagd.ValAttr.UnmarshalXMLAttr(_dedcg)
			continue
		}
	}
	for {
		_feced, _accef := d.Token()
		if _accef != nil {
			return _gg.Errorf("parsing\u0020CT_TimeUnit:\u0020\u0025s", _accef)
		}
		if _efcfcb, _fbdgg := _feced.(_fa.EndElement); _fbdgg && _efcfcb.Name == start.Name {
			break
		}
	}
	return nil
}

var ST_BubbleScalePercentPatternRe = _g.MustCompile(ST_BubbleScalePercentPattern)

func (_ffbfg *ST_Shape) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bfccd, _cgade := d.Token()
	if _cgade != nil {
		return _cgade
	}
	if _fgcef, _bdfgc := _bfccd.(_fa.EndElement); _bdfgc && _fgcef.Name == start.Name {
		*_ffbfg = 1
		return nil
	}
	if _geaee, _ddfb := _bfccd.(_fa.CharData); !_ddfb {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bfccd)
	} else {
		switch string(_geaee) {
		case "":
			*_ffbfg = 0
		case "cone":
			*_ffbfg = 1
		case "coneToMax":
			*_ffbfg = 2
		case "box":
			*_ffbfg = 3
		case "cylinder":
			*_ffbfg = 4
		case "pyramid":
			*_ffbfg = 5
		case "pyramidToMax":
			*_ffbfg = 6
		}
	}
	_bfccd, _cgade = d.Token()
	if _cgade != nil {
		return _cgade
	}
	if _gebe, _agdb := _bfccd.(_fa.EndElement); _agdb && _gebe.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bfccd)
}
func (_cbeg ST_BarDir) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_eacfe := _fa.Attr{}
	_eacfe.Name = name
	switch _cbeg {
	case ST_BarDirUnset:
		_eacfe.Value = ""
	case ST_BarDirBar:
		_eacfe.Value = "bar"
	case ST_BarDirCol:
		_eacfe.Value = "col"
	}
	return _eacfe, nil
}

// Validate validates the CT_Orientation and its children
func (_gdgg *CT_Orientation) Validate() error { return _gdgg.ValidateWithPath("CT_Orientation") }

type CT_AxPos struct{ ValAttr ST_AxPos }

func (_acae *ST_RadarStyle) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_fbgee, _ebade := d.Token()
	if _ebade != nil {
		return _ebade
	}
	if _faggd, _ggfgg := _fbgee.(_fa.EndElement); _ggfgg && _faggd.Name == start.Name {
		*_acae = 1
		return nil
	}
	if _ggacg, _efebg := _fbgee.(_fa.CharData); !_efebg {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fbgee)
	} else {
		switch string(_ggacg) {
		case "":
			*_acae = 0
		case "standard":
			*_acae = 1
		case "marker":
			*_acae = 2
		case "filled":
			*_acae = 3
		}
	}
	_fbgee, _ebade = d.Token()
	if _ebade != nil {
		return _ebade
	}
	if _fedde, _gfdge := _fbgee.(_fa.EndElement); _gfdge && _fedde.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fbgee)
}

type CT_DLblsChoice struct {
	Delete          *CT_Boolean
	NumFmt          *CT_NumFmt
	SpPr            *_cb.CT_ShapeProperties
	TxPr            *_cb.CT_TextBody
	DLblPos         *CT_DLblPos
	ShowLegendKey   *CT_Boolean
	ShowVal         *CT_Boolean
	ShowCatName     *CT_Boolean
	ShowSerName     *CT_Boolean
	ShowPercent     *CT_Boolean
	ShowBubbleSize  *CT_Boolean
	Separator       *string
	ShowLeaderLines *CT_Boolean
	LeaderLines     *CT_ChartLines
}

func (_gfaeb ST_PictureFormat) String() string {
	switch _gfaeb {
	case 0:
		return ""
	case 1:
		return "stretch"
	case 2:
		return "stack"
	case 3:
		return "stackScale"
	}
	return ""
}
func (_adeff *EG_LegendEntryData) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_agfcf:
	for {
		_agge, _aeac := d.Token()
		if _aeac != nil {
			return _aeac
		}
		switch _badeb := _agge.(type) {
		case _fa.StartElement:
			switch _badeb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_adeff.TxPr = _cb.NewCT_TextBody()
				if _aaad := d.DecodeElement(_adeff.TxPr, &_badeb); _aaad != nil {
					return _aaad
				}
			default:
				_b.Log("skipping\u0020unsupported element\u0020on\u0020EG_LegendEntryData\u0020\u0025v", _badeb.Name)
				if _edgaf := d.Skip(); _edgaf != nil {
					return _edgaf
				}
			}
		case _fa.EndElement:
			break _agfcf
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_NumRef and its children, prefixing error messages with path
func (_egegf *CT_NumRef) ValidateWithPath(path string) error {
	if _egegf.NumCache != nil {
		if _ebfaf := _egegf.NumCache.ValidateWithPath(path + "\u002fNumCache"); _ebfaf != nil {
			return _ebfaf
		}
	}
	if _egegf.ExtLst != nil {
		if _agcf := _egegf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _agcf != nil {
			return _agcf
		}
	}
	return nil
}
func NewCT_AreaChart() *CT_AreaChart     { _fed := &CT_AreaChart{}; return _fed }
func NewCT_Perspective() *CT_Perspective { _eaaca := &CT_Perspective{}; return _eaaca }

type CT_StockChart struct {
	Ser        []*CT_LineSer
	DLbls      *CT_DLbls
	DropLines  *CT_ChartLines
	HiLowLines *CT_ChartLines
	UpDownBars *CT_UpDownBars
	AxId       []*CT_UnsignedInt
	ExtLst     *CT_ExtensionList
}

func NewEG_SerShared() *EG_SerShared {
	_gcce := &EG_SerShared{}
	_gcce.Idx = NewCT_UnsignedInt()
	_gcce.Order = NewCT_UnsignedInt()
	return _gcce
}

type CT_DoughnutChart struct {
	VaryColors    *CT_Boolean
	Ser           []*CT_PieSer
	DLbls         *CT_DLbls
	FirstSliceAng *CT_FirstSliceAng
	HoleSize      *CT_HoleSize
	ExtLst        *CT_ExtensionList
}

func NewCT_CatAx() *CT_CatAx {
	_eagf := &CT_CatAx{}
	_eagf.AxId = NewCT_UnsignedInt()
	_eagf.Scaling = NewCT_Scaling()
	_eagf.AxPos = NewCT_AxPos()
	_eagf.CrossAx = NewCT_UnsignedInt()
	return _eagf
}
func (_bcgefb *CT_OfPieType) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _bcgefb.ValAttr != ST_OfPieTypeUnset {
		_cbdaf, _eacca := _bcgefb.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _eacca != nil {
			return _eacca
		}
		start.Attr = append(start.Attr, _cbdaf)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_abcb *CT_NumVal) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "idx"}, Value: _gg.Sprintf("\u0025v", _abcb.IdxAttr)})
	if _abcb.FormatCodeAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "formatCode"}, Value: _gg.Sprintf("\u0025v", *_abcb.FormatCodeAttr)})
	}
	e.EncodeToken(start)
	_cafdg := _fa.StartElement{Name: _fa.Name{Local: "c:v"}}
	_b.AddPreserveSpaceAttr(&_cafdg, _abcb.V)
	e.EncodeElement(_abcb.V, _cafdg)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ErrValType and its children, prefixing error messages with path
func (_defce *CT_ErrValType) ValidateWithPath(path string) error {
	if _baddf := _defce.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _baddf != nil {
		return _baddf
	}
	return nil
}

// Validate validates the EG_AxShared and its children
func (_fccfcd *EG_AxShared) Validate() error { return _fccfcd.ValidateWithPath("EG_AxShared") }
func (_gcfg *CT_Orientation) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _decgf := range start.Attr {
		if _decgf.Name.Local == "val" {
			_gcfg.ValAttr.UnmarshalXMLAttr(_decgf)
			continue
		}
	}
	for {
		_gbad, _geaa := d.Token()
		if _geaa != nil {
			return _gg.Errorf("parsing\u0020CT_Orientation:\u0020\u0025s", _geaa)
		}
		if _aaaaa, _cdcgfb := _gbad.(_fa.EndElement); _cdcgfb && _aaaaa.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_FirstSliceAng and its children
func (_bcdg *CT_FirstSliceAng) Validate() error { return _bcdg.ValidateWithPath("CT_FirstSliceAng") }
func NewCT_ErrValType() *CT_ErrValType          { _deba := &CT_ErrValType{}; return _deba }

// ValidateWithPath validates the CT_SerAx and its children, prefixing error messages with path
func (_dbee *CT_SerAx) ValidateWithPath(path string) error {
	if _daegf := _dbee.AxId.ValidateWithPath(path + "\u002fAxId"); _daegf != nil {
		return _daegf
	}
	if _gead := _dbee.Scaling.ValidateWithPath(path + "\u002fScaling"); _gead != nil {
		return _gead
	}
	if _dbee.Delete != nil {
		if _gffbb := _dbee.Delete.ValidateWithPath(path + "\u002fDelete"); _gffbb != nil {
			return _gffbb
		}
	}
	if _fgedec := _dbee.AxPos.ValidateWithPath(path + "\u002fAxPos"); _fgedec != nil {
		return _fgedec
	}
	if _dbee.MajorGridlines != nil {
		if _bagce := _dbee.MajorGridlines.ValidateWithPath(path + "\u002fMajorGridlines"); _bagce != nil {
			return _bagce
		}
	}
	if _dbee.MinorGridlines != nil {
		if _fbaf := _dbee.MinorGridlines.ValidateWithPath(path + "\u002fMinorGridlines"); _fbaf != nil {
			return _fbaf
		}
	}
	if _dbee.Title != nil {
		if _eeca := _dbee.Title.ValidateWithPath(path + "\u002fTitle"); _eeca != nil {
			return _eeca
		}
	}
	if _dbee.NumFmt != nil {
		if _fbcgg := _dbee.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _fbcgg != nil {
			return _fbcgg
		}
	}
	if _dbee.MajorTickMark != nil {
		if _ceeb := _dbee.MajorTickMark.ValidateWithPath(path + "\u002fMajorTickMark"); _ceeb != nil {
			return _ceeb
		}
	}
	if _dbee.MinorTickMark != nil {
		if _bgadb := _dbee.MinorTickMark.ValidateWithPath(path + "\u002fMinorTickMark"); _bgadb != nil {
			return _bgadb
		}
	}
	if _dbee.TickLblPos != nil {
		if _cfeac := _dbee.TickLblPos.ValidateWithPath(path + "/TickLblPos"); _cfeac != nil {
			return _cfeac
		}
	}
	if _dbee.SpPr != nil {
		if _eegef := _dbee.SpPr.ValidateWithPath(path + "\u002fSpPr"); _eegef != nil {
			return _eegef
		}
	}
	if _dbee.TxPr != nil {
		if _dgbdd := _dbee.TxPr.ValidateWithPath(path + "\u002fTxPr"); _dgbdd != nil {
			return _dgbdd
		}
	}
	if _babdf := _dbee.CrossAx.ValidateWithPath(path + "\u002fCrossAx"); _babdf != nil {
		return _babdf
	}
	if _dbee.Choice != nil {
		if _feefc := _dbee.Choice.ValidateWithPath(path + "\u002fChoice"); _feefc != nil {
			return _feefc
		}
	}
	if _dbee.TickLblSkip != nil {
		if _dafce := _dbee.TickLblSkip.ValidateWithPath(path + "\u002fTickLblSkip"); _dafce != nil {
			return _dafce
		}
	}
	if _dbee.TickMarkSkip != nil {
		if _daaa := _dbee.TickMarkSkip.ValidateWithPath(path + "\u002fTickMarkSkip"); _daaa != nil {
			return _daaa
		}
	}
	if _dbee.ExtLst != nil {
		if _dbaa := _dbee.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dbaa != nil {
			return _dbaa
		}
	}
	return nil
}

// ValidateWithPath validates the Group_DLbl and its children, prefixing error messages with path
func (_beeacg *Group_DLbl) ValidateWithPath(path string) error {
	if _beeacg.Layout != nil {
		if _abbfc := _beeacg.Layout.ValidateWithPath(path + "\u002fLayout"); _abbfc != nil {
			return _abbfc
		}
	}
	if _beeacg.Tx != nil {
		if _bdaca := _beeacg.Tx.ValidateWithPath(path + "\u002fTx"); _bdaca != nil {
			return _bdaca
		}
	}
	if _beeacg.NumFmt != nil {
		if _cgfca := _beeacg.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _cgfca != nil {
			return _cgfca
		}
	}
	if _beeacg.SpPr != nil {
		if _gdfdg := _beeacg.SpPr.ValidateWithPath(path + "\u002fSpPr"); _gdfdg != nil {
			return _gdfdg
		}
	}
	if _beeacg.TxPr != nil {
		if _ffead := _beeacg.TxPr.ValidateWithPath(path + "\u002fTxPr"); _ffead != nil {
			return _ffead
		}
	}
	if _beeacg.DLblPos != nil {
		if _caeb := _beeacg.DLblPos.ValidateWithPath(path + "\u002fDLblPos"); _caeb != nil {
			return _caeb
		}
	}
	if _beeacg.ShowLegendKey != nil {
		if _dcba := _beeacg.ShowLegendKey.ValidateWithPath(path + "\u002fShowLegendKey"); _dcba != nil {
			return _dcba
		}
	}
	if _beeacg.ShowVal != nil {
		if _bbffd := _beeacg.ShowVal.ValidateWithPath(path + "\u002fShowVal"); _bbffd != nil {
			return _bbffd
		}
	}
	if _beeacg.ShowCatName != nil {
		if _dgffca := _beeacg.ShowCatName.ValidateWithPath(path + "\u002fShowCatName"); _dgffca != nil {
			return _dgffca
		}
	}
	if _beeacg.ShowSerName != nil {
		if _dfddb := _beeacg.ShowSerName.ValidateWithPath(path + "\u002fShowSerName"); _dfddb != nil {
			return _dfddb
		}
	}
	if _beeacg.ShowPercent != nil {
		if _aaaaaa := _beeacg.ShowPercent.ValidateWithPath(path + "\u002fShowPercent"); _aaaaaa != nil {
			return _aaaaaa
		}
	}
	if _beeacg.ShowBubbleSize != nil {
		if _eadbg := _beeacg.ShowBubbleSize.ValidateWithPath(path + "\u002fShowBubbleSize"); _eadbg != nil {
			return _eadbg
		}
	}
	return nil
}

// Validate validates the CT_BubbleScale and its children
func (_ddde *CT_BubbleScale) Validate() error { return _ddde.ValidateWithPath("CT_BubbleScale") }
func NewCT_SplitType() *CT_SplitType          { _bace := &CT_SplitType{}; return _bace }

// Validate validates the CT_StrVal and its children
func (_bgfcf *CT_StrVal) Validate() error { return _bgfcf.ValidateWithPath("CT_StrVal") }

// Validate validates the CT_Chart and its children
func (_baf *CT_Chart) Validate() error { return _baf.ValidateWithPath("CT_Chart") }

type CT_PictureFormat struct{ ValAttr ST_PictureFormat }

func (_egeff ST_DispBlanksAs) Validate() error { return _egeff.ValidateWithPath("") }
func NewCT_ChartLines() *CT_ChartLines         { _fcee := &CT_ChartLines{}; return _fcee }

// Validate validates the CT_DLblsChoice and its children
func (_ace *CT_DLblsChoice) Validate() error { return _ace.ValidateWithPath("CT_DLblsChoice") }
func (_abdb *CT_LegendPos) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _abdb.ValAttr != ST_LegendPosUnset {
		_bdaa, _febag := _abdb.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _febag != nil {
			return _febag
		}
		start.Attr = append(start.Attr, _bdaa)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_Bar3DChart struct {
	BarDir     *CT_BarDir
	Grouping   *CT_BarGrouping
	VaryColors *CT_Boolean
	Ser        []*CT_BarSer
	DLbls      *CT_DLbls
	GapWidth   *CT_GapAmount
	GapDepth   *CT_GapAmount
	Shape      *CT_Shape
	AxId       []*CT_UnsignedInt
	ExtLst     *CT_ExtensionList
}

// Validate validates the CT_TextLanguageID and its children
func (_dcece *CT_TextLanguageID) Validate() error {
	return _dcece.ValidateWithPath("CT_TextLanguageID")
}
func (_gbcbe *ST_HPercent) Validate() error { return _gbcbe.ValidateWithPath("") }

type CT_LineSer struct {
	Idx       *CT_UnsignedInt
	Order     *CT_UnsignedInt
	Tx        *CT_SerTx
	SpPr      *_cb.CT_ShapeProperties
	Marker    *CT_Marker
	DPt       []*CT_DPt
	DLbls     *CT_DLbls
	Trendline []*CT_Trendline
	ErrBars   *CT_ErrBars
	Cat       *CT_AxDataSource
	Val       *CT_NumDataSource
	Smooth    *CT_Boolean
	ExtLst    *CT_ExtensionList
}

func (_agcdc *CT_DLblsChoice) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_bdfae:
	for {
		_aecad, _fcfe := d.Token()
		if _fcfe != nil {
			return _fcfe
		}
		switch _aeage := _aecad.(type) {
		case _fa.StartElement:
			switch _aeage.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "delete"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "delete"}:
				_agcdc.Delete = NewCT_Boolean()
				if _caba := d.DecodeElement(_agcdc.Delete, &_aeage); _caba != nil {
					return _caba
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				_agcdc.NumFmt = NewCT_NumFmt()
				if _gae := d.DecodeElement(_agcdc.NumFmt, &_aeage); _gae != nil {
					return _gae
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_agcdc.SpPr = _cb.NewCT_ShapeProperties()
				if _eada := d.DecodeElement(_agcdc.SpPr, &_aeage); _eada != nil {
					return _eada
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_agcdc.TxPr = _cb.NewCT_TextBody()
				if _caaf := d.DecodeElement(_agcdc.TxPr, &_aeage); _caaf != nil {
					return _caaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLblPos"}:
				_agcdc.DLblPos = NewCT_DLblPos()
				if _bfgf := d.DecodeElement(_agcdc.DLblPos, &_aeage); _bfgf != nil {
					return _bfgf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showLegendKey"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showLegendKey"}:
				_agcdc.ShowLegendKey = NewCT_Boolean()
				if _gacg := d.DecodeElement(_agcdc.ShowLegendKey, &_aeage); _gacg != nil {
					return _gacg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showVal"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showVal"}:
				_agcdc.ShowVal = NewCT_Boolean()
				if _egdb := d.DecodeElement(_agcdc.ShowVal, &_aeage); _egdb != nil {
					return _egdb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showCatName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showCatName"}:
				_agcdc.ShowCatName = NewCT_Boolean()
				if _ebgd := d.DecodeElement(_agcdc.ShowCatName, &_aeage); _ebgd != nil {
					return _ebgd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showSerName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showSerName"}:
				_agcdc.ShowSerName = NewCT_Boolean()
				if _eeef := d.DecodeElement(_agcdc.ShowSerName, &_aeage); _eeef != nil {
					return _eeef
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showPercent"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showPercent"}:
				_agcdc.ShowPercent = NewCT_Boolean()
				if _bgcd := d.DecodeElement(_agcdc.ShowPercent, &_aeage); _bgcd != nil {
					return _bgcd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showBubbleSize"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showBubbleSize"}:
				_agcdc.ShowBubbleSize = NewCT_Boolean()
				if _cdee := d.DecodeElement(_agcdc.ShowBubbleSize, &_aeage); _cdee != nil {
					return _cdee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "separator"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "separator"}:
				_agcdc.Separator = new(string)
				if _bdfb := d.DecodeElement(_agcdc.Separator, &_aeage); _bdfb != nil {
					return _bdfb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showLeaderLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showLeaderLines"}:
				_agcdc.ShowLeaderLines = NewCT_Boolean()
				if _ecea := d.DecodeElement(_agcdc.ShowLeaderLines, &_aeage); _ecea != nil {
					return _ecea
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "leaderLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "leaderLines"}:
				_agcdc.LeaderLines = NewCT_ChartLines()
				if _edeff := d.DecodeElement(_agcdc.LeaderLines, &_aeage); _edeff != nil {
					return _edeff
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DLblsChoice\u0020\u0025v", _aeage.Name)
				if _bdad := d.Skip(); _bdad != nil {
					return _bdad
				}
			}
		case _fa.EndElement:
			break _bdfae
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_TrendlineLbl and its children
func (_acdcf *CT_TrendlineLbl) Validate() error { return _acdcf.ValidateWithPath("CT_TrendlineLbl") }

type CT_CrossBetween struct{ ValAttr ST_CrossBetween }

// Validate validates the CT_SerTxChoice and its children
func (_decdc *CT_SerTxChoice) Validate() error { return _decdc.ValidateWithPath("CT_SerTxChoice") }
func (_cfaac *EG_LineChartShared) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_cfaac.Grouping = NewCT_Grouping()
_fdcea:
	for {
		_dcadg, _ccbdg := d.Token()
		if _ccbdg != nil {
			return _ccbdg
		}
		switch _aaggdg := _dcadg.(type) {
		case _fa.StartElement:
			switch _aaggdg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "grouping"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "grouping"}:
				if _gfdbg := d.DecodeElement(_cfaac.Grouping, &_aaggdg); _gfdbg != nil {
					return _gfdbg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_cfaac.VaryColors = NewCT_Boolean()
				if _eeeff := d.DecodeElement(_cfaac.VaryColors, &_aaggdg); _eeeff != nil {
					return _eeeff
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_ecge := NewCT_LineSer()
				if _gadgbd := d.DecodeElement(_ecge, &_aaggdg); _gadgbd != nil {
					return _gadgbd
				}
				_cfaac.Ser = append(_cfaac.Ser, _ecge)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_cfaac.DLbls = NewCT_DLbls()
				if _bddggf := d.DecodeElement(_cfaac.DLbls, &_aaggdg); _bddggf != nil {
					return _bddggf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dropLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dropLines"}:
				_cfaac.DropLines = NewCT_ChartLines()
				if _fcfdg := d.DecodeElement(_cfaac.DropLines, &_aaggdg); _fcfdg != nil {
					return _fcfdg
				}
			default:
				_b.Log("skipping\u0020unsupported element\u0020on\u0020EG_LineChartShared\u0020\u0025v", _aaggdg.Name)
				if _edagg := d.Skip(); _edagg != nil {
					return _edagg
				}
			}
		case _fa.EndElement:
			break _fdcea
		case _fa.CharData:
		}
	}
	return nil
}
func (_acbc *CT_LegendEntryChoice) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_ccee:
	for {
		_gdda, _dcfaa := d.Token()
		if _dcfaa != nil {
			return _dcfaa
		}
		switch _dafcc := _gdda.(type) {
		case _fa.StartElement:
			switch _dafcc.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "delete"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "delete"}:
				_acbc.Delete = NewCT_Boolean()
				if _abdg := d.DecodeElement(_acbc.Delete, &_dafcc); _abdg != nil {
					return _abdg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_acbc.TxPr = _cb.NewCT_TextBody()
				if _cgdd := d.DecodeElement(_acbc.TxPr, &_dafcc); _cgdd != nil {
					return _cgdd
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on\u0020CT_LegendEntryChoice\u0020\u0025v", _dafcc.Name)
				if _fgggg := d.Skip(); _fgggg != nil {
					return _fgggg
				}
			}
		case _fa.EndElement:
			break _ccee
		case _fa.CharData:
		}
	}
	return nil
}
func (_efcdg ST_BuiltInUnit) String() string {
	switch _efcdg {
	case 0:
		return ""
	case 1:
		return "hundreds"
	case 2:
		return "thousands"
	case 3:
		return "tenThousands"
	case 4:
		return "hundredThousands"
	case 5:
		return "millions"
	case 6:
		return "tenMillions"
	case 7:
		return "hundredMillions"
	case 8:
		return "billions"
	case 9:
		return "trillions"
	}
	return ""
}
func (_ggcfb ST_Grouping) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_ggcfb.String(), start)
}

type CT_Lvl struct{ Pt []*CT_StrVal }

// Validate validates the CT_DispUnitsLbl and its children
func (_fdccef *CT_DispUnitsLbl) Validate() error { return _fdccef.ValidateWithPath("CT_DispUnitsLbl") }

type CT_Skip struct{ ValAttr uint32 }

// ValidateWithPath validates the CT_LblAlgn and its children, prefixing error messages with path
func (_bfgd *CT_LblAlgn) ValidateWithPath(path string) error {
	if _bfgd.ValAttr == ST_LblAlgnUnset {
		return _gg.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _ecca := _bfgd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _ecca != nil {
		return _ecca
	}
	return nil
}

// Validate validates the CT_TickLblPos and its children
func (_ceeebd *CT_TickLblPos) Validate() error { return _ceeebd.ValidateWithPath("CT_TickLblPos") }

// Validate validates the EG_AxSharedChoice and its children
func (_daede *EG_AxSharedChoice) Validate() error {
	return _daede.ValidateWithPath("EG_AxSharedChoice")
}
func NewCT_RadarStyle() *CT_RadarStyle { _dgffg := &CT_RadarStyle{}; return _dgffg }

type CT_MultiLvlStrData struct {
	PtCount *CT_UnsignedInt
	Lvl     []*CT_Lvl
	ExtLst  *CT_ExtensionList
}
type CT_DTable struct {
	ShowHorzBorder *CT_Boolean
	ShowVertBorder *CT_Boolean
	ShowOutline    *CT_Boolean
	ShowKeys       *CT_Boolean
	SpPr           *_cb.CT_ShapeProperties
	TxPr           *_cb.CT_TextBody
	ExtLst         *CT_ExtensionList
}

// Validate validates the CT_UpDownBars and its children
func (_cfgee *CT_UpDownBars) Validate() error { return _cfgee.ValidateWithPath("CT_UpDownBars") }
func NewCT_ChartSpace() *CT_ChartSpace {
	_cccb := &CT_ChartSpace{}
	_cccb.Chart = NewCT_Chart()
	return _cccb
}

// ValidateWithPath validates the CT_TxChoice and its children, prefixing error messages with path
func (_afaa *CT_TxChoice) ValidateWithPath(path string) error {
	if _afaa.StrRef != nil {
		if _dbdcg := _afaa.StrRef.ValidateWithPath(path + "\u002fStrRef"); _dbdcg != nil {
			return _dbdcg
		}
	}
	if _afaa.Rich != nil {
		if _efgc := _afaa.Rich.ValidateWithPath(path + "\u002fRich"); _efgc != nil {
			return _efgc
		}
	}
	return nil
}

type CT_Area3DChart struct {
	Grouping   *CT_Grouping
	VaryColors *CT_Boolean
	Ser        []*CT_AreaSer
	DLbls      *CT_DLbls
	DropLines  *CT_ChartLines
	GapDepth   *CT_GapAmount
	AxId       []*CT_UnsignedInt
	ExtLst     *CT_ExtensionList
}

func NewCT_Chart() *CT_Chart               { _cdg := &CT_Chart{}; _cdg.PlotArea = NewCT_PlotArea(); return _cdg }
func (_bfedc *ST_Overlap) Validate() error { return _bfedc.ValidateWithPath("") }

// Validate validates the CT_AxisUnit and its children
func (_fad *CT_AxisUnit) Validate() error { return _fad.ValidateWithPath("CT_AxisUnit") }
func (_gabd *CT_DispUnits) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _gabd.Choice != nil {
		_gabd.Choice.MarshalXML(e, _fa.StartElement{})
	}
	if _gabd.DispUnitsLbl != nil {
		_gdaed := _fa.StartElement{Name: _fa.Name{Local: "c:dispUnitsLbl"}}
		e.EncodeElement(_gabd.DispUnitsLbl, _gdaed)
	}
	if _gabd.ExtLst != nil {
		_bgbbe := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_gabd.ExtLst, _bgbbe)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_fefe *CT_Shape) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _fefe.ValAttr != ST_ShapeUnset {
		_dgad, _fgbd := _fefe.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _fgbd != nil {
			return _fgbd
		}
		start.Attr = append(start.Attr, _dgad)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_DateAx() *CT_DateAx {
	_aefe := &CT_DateAx{}
	_aefe.AxId = NewCT_UnsignedInt()
	_aefe.Scaling = NewCT_Scaling()
	_aefe.AxPos = NewCT_AxPos()
	_aefe.CrossAx = NewCT_UnsignedInt()
	return _aefe
}
func NewCT_PictureStackUnit() *CT_PictureStackUnit {
	_ecbb := &CT_PictureStackUnit{}
	_ecbb.ValAttr = 0 + 1
	return _ecbb
}
func (_decgfa ST_RadarStyle) String() string {
	switch _decgfa {
	case 0:
		return ""
	case 1:
		return "standard"
	case 2:
		return "marker"
	case 3:
		return "filled"
	}
	return ""
}
func NewCT_RelId() *CT_RelId { _cabc := &CT_RelId{}; return _cabc }

// ValidateWithPath validates the CT_OfPieChart and its children, prefixing error messages with path
func (_cfbb *CT_OfPieChart) ValidateWithPath(path string) error {
	if _acga := _cfbb.OfPieType.ValidateWithPath(path + "\u002fOfPieType"); _acga != nil {
		return _acga
	}
	if _cfbb.VaryColors != nil {
		if _aebg := _cfbb.VaryColors.ValidateWithPath(path + "/VaryColors"); _aebg != nil {
			return _aebg
		}
	}
	for _fdbef, _gbdcc := range _cfbb.Ser {
		if _bfad := _gbdcc.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _fdbef)); _bfad != nil {
			return _bfad
		}
	}
	if _cfbb.DLbls != nil {
		if _efce := _cfbb.DLbls.ValidateWithPath(path + "\u002fDLbls"); _efce != nil {
			return _efce
		}
	}
	if _cfbb.GapWidth != nil {
		if _fagf := _cfbb.GapWidth.ValidateWithPath(path + "\u002fGapWidth"); _fagf != nil {
			return _fagf
		}
	}
	if _cfbb.SplitType != nil {
		if _ggbf := _cfbb.SplitType.ValidateWithPath(path + "\u002fSplitType"); _ggbf != nil {
			return _ggbf
		}
	}
	if _cfbb.SplitPos != nil {
		if _cdbcc := _cfbb.SplitPos.ValidateWithPath(path + "\u002fSplitPos"); _cdbcc != nil {
			return _cdbcc
		}
	}
	if _cfbb.CustSplit != nil {
		if _abbc := _cfbb.CustSplit.ValidateWithPath(path + "\u002fCustSplit"); _abbc != nil {
			return _abbc
		}
	}
	if _cfbb.SecondPieSize != nil {
		if _gdab := _cfbb.SecondPieSize.ValidateWithPath(path + "\u002fSecondPieSize"); _gdab != nil {
			return _gdab
		}
	}
	for _edfcb, _fcgd := range _cfbb.SerLines {
		if _cdca := _fcgd.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSerLines\u005b\u0025d\u005d", path, _edfcb)); _cdca != nil {
			return _cdca
		}
	}
	if _cfbb.ExtLst != nil {
		if _cfdb := _cfbb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cfdb != nil {
			return _cfdb
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Legend and its children, prefixing error messages with path
func (_bcdba *CT_Legend) ValidateWithPath(path string) error {
	if _bcdba.LegendPos != nil {
		if _efec := _bcdba.LegendPos.ValidateWithPath(path + "\u002fLegendPos"); _efec != nil {
			return _efec
		}
	}
	for _cggdb, _baba := range _bcdba.LegendEntry {
		if _dfabe := _baba.ValidateWithPath(_gg.Sprintf("\u0025s\u002fLegendEntry\u005b\u0025d\u005d", path, _cggdb)); _dfabe != nil {
			return _dfabe
		}
	}
	if _bcdba.Layout != nil {
		if _baaf := _bcdba.Layout.ValidateWithPath(path + "\u002fLayout"); _baaf != nil {
			return _baaf
		}
	}
	if _bcdba.Overlay != nil {
		if _geeef := _bcdba.Overlay.ValidateWithPath(path + "\u002fOverlay"); _geeef != nil {
			return _geeef
		}
	}
	if _bcdba.SpPr != nil {
		if _abfbc := _bcdba.SpPr.ValidateWithPath(path + "\u002fSpPr"); _abfbc != nil {
			return _abfbc
		}
	}
	if _bcdba.TxPr != nil {
		if _faaga := _bcdba.TxPr.ValidateWithPath(path + "\u002fTxPr"); _faaga != nil {
			return _faaga
		}
	}
	if _bcdba.ExtLst != nil {
		if _egcf := _bcdba.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _egcf != nil {
			return _egcf
		}
	}
	return nil
}
func (_bdee ST_Shape) String() string {
	switch _bdee {
	case 0:
		return ""
	case 1:
		return "cone"
	case 2:
		return "coneToMax"
	case 3:
		return "box"
	case 4:
		return "cylinder"
	case 5:
		return "pyramid"
	case 6:
		return "pyramidToMax"
	}
	return ""
}

type CT_Boolean struct{ ValAttr *bool }

const ST_LblOffsetPercentPattern = "0\u002a\u0028\u0028\u005b0\u002d9]\u0029\u007c\u0028[1\u002d9\u005d\u005b0\u002d9\u005d\u0029\u007c\u0028\u005b1\u002d9\u005d\u005b0\u002d9\u005d\u005b0\u002d9\u005d\u0029\u007c1000\u0029\u0025"

func (_gcebc ST_Shape) ValidateWithPath(path string) error {
	switch _gcebc {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gcebc))
	}
	return nil
}

// ValidateWithPath validates the CT_Scaling and its children, prefixing error messages with path
func (_ecggd *CT_Scaling) ValidateWithPath(path string) error {
	if _ecggd.LogBase != nil {
		if _babd := _ecggd.LogBase.ValidateWithPath(path + "\u002fLogBase"); _babd != nil {
			return _babd
		}
	}
	if _ecggd.Orientation != nil {
		if _caecf := _ecggd.Orientation.ValidateWithPath(path + "\u002fOrientation"); _caecf != nil {
			return _caecf
		}
	}
	if _ecggd.Max != nil {
		if _ecfa := _ecggd.Max.ValidateWithPath(path + "\u002fMax"); _ecfa != nil {
			return _ecfa
		}
	}
	if _ecggd.Min != nil {
		if _adada := _ecggd.Min.ValidateWithPath(path + "\u002fMin"); _adada != nil {
			return _adada
		}
	}
	if _ecggd.ExtLst != nil {
		if _bfgfcb := _ecggd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bfgfcb != nil {
			return _bfgfcb
		}
	}
	return nil
}

// ValidateWithPath validates the CT_MarkerSize and its children, prefixing error messages with path
func (_aead *CT_MarkerSize) ValidateWithPath(path string) error {
	if _aead.ValAttr != nil {
		if *_aead.ValAttr < 2 {
			return _gg.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00202\u0020\u0028have\u0020\u0025v\u0029", path, *_aead.ValAttr)
		}
		if *_aead.ValAttr > 72 {
			return _gg.Errorf("\u0025s/m\u002eValAttr must be\u0020\u003c\u003d\u002072 \u0028have\u0020\u0025v\u0029", path, *_aead.ValAttr)
		}
	}
	return nil
}

type CT_LogBase struct{ ValAttr float64 }
type CT_Thickness struct{ ValAttr ST_Thickness }

func NewCT_TimeUnit() *CT_TimeUnit { _dcfdb := &CT_TimeUnit{}; return _dcfdb }

// Validate validates the CT_Lvl and its children
func (_ecfc *CT_Lvl) Validate() error { return _ecfc.ValidateWithPath("CT_Lvl") }
func (_eggg *ST_TickLblPos) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_eggg = 0
	case "high":
		*_eggg = 1
	case "low":
		*_eggg = 2
	case "nextTo":
		*_eggg = 3
	case "none":
		*_eggg = 4
	}
	return nil
}
func NewEG_SurfaceChartShared() *EG_SurfaceChartShared {
	_cfcbe := &EG_SurfaceChartShared{}
	return _cfcbe
}

// Validate validates the CT_DLbl and its children
func (_abfg *CT_DLbl) Validate() error { return _abfg.ValidateWithPath("CT_DLbl") }
func (_cacg ST_SizeRepresents) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_geeefe := _fa.Attr{}
	_geeefe.Name = name
	switch _cacg {
	case ST_SizeRepresentsUnset:
		_geeefe.Value = ""
	case ST_SizeRepresentsArea:
		_geeefe.Value = "area"
	case ST_SizeRepresentsW:
		_geeefe.Value = "w"
	}
	return _geeefe, nil
}
func NewCT_Shape() *CT_Shape { _fgdab := &CT_Shape{}; return _fgdab }
func (_gbgeb *CT_LblAlgn) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_agbb, _ebcgc := _gbgeb.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
	if _ebcgc != nil {
		return _ebcgc
	}
	start.Attr = append(start.Attr, _agbb)
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_babc *CT_Skip) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_babc.ValAttr = 1
	for _, _cefgg := range start.Attr {
		if _cefgg.Name.Local == "val" {
			_effd, _abadf := _c.ParseUint(_cefgg.Value, 10, 32)
			if _abadf != nil {
				return _abadf
			}
			_babc.ValAttr = uint32(_effd)
			continue
		}
	}
	for {
		_cgcdb, _dcec := d.Token()
		if _dcec != nil {
			return _gg.Errorf("parsing\u0020CT_Skip:\u0020\u0025s", _dcec)
		}
		if _gbdb, _edbfe := _cgcdb.(_fa.EndElement); _edbfe && _gbdb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cedff *CT_StockChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_bcbf := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
	for _, _gcedg := range _cedff.Ser {
		e.EncodeElement(_gcedg, _bcbf)
	}
	if _cedff.DLbls != nil {
		_gaccd := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_cedff.DLbls, _gaccd)
	}
	if _cedff.DropLines != nil {
		_ebac := _fa.StartElement{Name: _fa.Name{Local: "c:dropLines"}}
		e.EncodeElement(_cedff.DropLines, _ebac)
	}
	if _cedff.HiLowLines != nil {
		_edgb := _fa.StartElement{Name: _fa.Name{Local: "c:hiLowLines"}}
		e.EncodeElement(_cedff.HiLowLines, _edgb)
	}
	if _cedff.UpDownBars != nil {
		_ddege := _fa.StartElement{Name: _fa.Name{Local: "c:upDownBars"}}
		e.EncodeElement(_cedff.UpDownBars, _ddege)
	}
	_fbcfb := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _aeaff := range _cedff.AxId {
		e.EncodeElement(_aeaff, _fbcfb)
	}
	if _cedff.ExtLst != nil {
		_gdbfgf := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_cedff.ExtLst, _gdbfgf)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_ecaaa *CT_HoleSize) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _cbeeg := range start.Attr {
		if _cbeeg.Name.Local == "val" {
			_agff, _beac := ParseUnionST_HoleSize(_cbeeg.Value)
			if _beac != nil {
				return _beac
			}
			_ecaaa.ValAttr = &_agff
			continue
		}
	}
	for {
		_gbfb, _ddabf := d.Token()
		if _ddabf != nil {
			return _gg.Errorf("parsing\u0020CT_HoleSize:\u0020\u0025s", _ddabf)
		}
		if _aeaaa, _fcdda := _gbfb.(_fa.EndElement); _fcdda && _aeaaa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gbccf *CT_Thickness) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _bacfd := range start.Attr {
		if _bacfd.Name.Local == "val" {
			_ddeb, _ceeeg := ParseUnionST_Thickness(_bacfd.Value)
			if _ceeeg != nil {
				return _ceeeg
			}
			_gbccf.ValAttr = _ddeb
			continue
		}
	}
	for {
		_bacfb, _agaf := d.Token()
		if _agaf != nil {
			return _gg.Errorf("parsing\u0020CT_Thickness:\u0020\u0025s", _agaf)
		}
		if _bgcgg, _gabe := _bacfb.(_fa.EndElement); _gabe && _bgcgg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gcedc ST_ErrDir) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_gcedc.String(), start)
}

type CT_Overlap struct{ ValAttr *ST_Overlap }

// ValidateWithPath validates the CT_DLblsChoice and its children, prefixing error messages with path
func (_gfaee *CT_DLblsChoice) ValidateWithPath(path string) error {
	if _gfaee.Delete != nil {
		if _ddfg := _gfaee.Delete.ValidateWithPath(path + "\u002fDelete"); _ddfg != nil {
			return _ddfg
		}
	}
	if _gfaee.NumFmt != nil {
		if _ggff := _gfaee.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _ggff != nil {
			return _ggff
		}
	}
	if _gfaee.SpPr != nil {
		if _dede := _gfaee.SpPr.ValidateWithPath(path + "\u002fSpPr"); _dede != nil {
			return _dede
		}
	}
	if _gfaee.TxPr != nil {
		if _aacg := _gfaee.TxPr.ValidateWithPath(path + "\u002fTxPr"); _aacg != nil {
			return _aacg
		}
	}
	if _gfaee.DLblPos != nil {
		if _bbbgc := _gfaee.DLblPos.ValidateWithPath(path + "\u002fDLblPos"); _bbbgc != nil {
			return _bbbgc
		}
	}
	if _gfaee.ShowLegendKey != nil {
		if _gcdb := _gfaee.ShowLegendKey.ValidateWithPath(path + "\u002fShowLegendKey"); _gcdb != nil {
			return _gcdb
		}
	}
	if _gfaee.ShowVal != nil {
		if _dbdb := _gfaee.ShowVal.ValidateWithPath(path + "\u002fShowVal"); _dbdb != nil {
			return _dbdb
		}
	}
	if _gfaee.ShowCatName != nil {
		if _dcfg := _gfaee.ShowCatName.ValidateWithPath(path + "\u002fShowCatName"); _dcfg != nil {
			return _dcfg
		}
	}
	if _gfaee.ShowSerName != nil {
		if _fbagg := _gfaee.ShowSerName.ValidateWithPath(path + "\u002fShowSerName"); _fbagg != nil {
			return _fbagg
		}
	}
	if _gfaee.ShowPercent != nil {
		if _gcff := _gfaee.ShowPercent.ValidateWithPath(path + "\u002fShowPercent"); _gcff != nil {
			return _gcff
		}
	}
	if _gfaee.ShowBubbleSize != nil {
		if _egaea := _gfaee.ShowBubbleSize.ValidateWithPath(path + "\u002fShowBubbleSize"); _egaea != nil {
			return _egaea
		}
	}
	if _gfaee.ShowLeaderLines != nil {
		if _edad := _gfaee.ShowLeaderLines.ValidateWithPath(path + "\u002fShowLeaderLines"); _edad != nil {
			return _edad
		}
	}
	if _gfaee.LeaderLines != nil {
		if _ddcg := _gfaee.LeaderLines.ValidateWithPath(path + "\u002fLeaderLines"); _ddcg != nil {
			return _ddcg
		}
	}
	return nil
}

// Validate validates the Group_DLbl and its children
func (_bfcbf *Group_DLbl) Validate() error { return _bfcbf.ValidateWithPath("Group_DLbl") }

type ST_TickMark byte

// ValidateWithPath validates the CT_LegendEntryChoice and its children, prefixing error messages with path
func (_bebee *CT_LegendEntryChoice) ValidateWithPath(path string) error {
	if _bebee.Delete != nil {
		if _eacf := _bebee.Delete.ValidateWithPath(path + "\u002fDelete"); _eacf != nil {
			return _eacf
		}
	}
	if _bebee.TxPr != nil {
		if _ffaecb := _bebee.TxPr.ValidateWithPath(path + "\u002fTxPr"); _ffaecb != nil {
			return _ffaecb
		}
	}
	return nil
}
func (_dbfdc ST_Grouping) Validate() error { return _dbfdc.ValidateWithPath("") }

// ValidateWithPath validates the CT_DLblPos and its children, prefixing error messages with path
func (_aagg *CT_DLblPos) ValidateWithPath(path string) error {
	if _aagg.ValAttr == ST_DLblPosUnset {
		return _gg.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bcbdg := _aagg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bcbdg != nil {
		return _bcbdg
	}
	return nil
}
func (_ebdf *CT_PageMargins) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "l"}, Value: _gg.Sprintf("\u0025v", _ebdf.LAttr)})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "r"}, Value: _gg.Sprintf("\u0025v", _ebdf.RAttr)})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "t"}, Value: _gg.Sprintf("\u0025v", _ebdf.TAttr)})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "b"}, Value: _gg.Sprintf("\u0025v", _ebdf.BAttr)})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "header"}, Value: _gg.Sprintf("\u0025v", _ebdf.HeaderAttr)})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "footer"}, Value: _gg.Sprintf("\u0025v", _ebdf.FooterAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_ErrBars and its children
func (_cbfeb *CT_ErrBars) Validate() error { return _cbfeb.ValidateWithPath("CT_ErrBars") }
func (_gbfc *CT_ErrBarType) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _febe := range start.Attr {
		if _febe.Name.Local == "val" {
			_gbfc.ValAttr.UnmarshalXMLAttr(_febe)
			continue
		}
	}
	for {
		_fcbe, _bgac := d.Token()
		if _bgac != nil {
			return _gg.Errorf("parsing\u0020CT_ErrBarType:\u0020\u0025s", _bgac)
		}
		if _cgef, _fdbg := _fcbe.(_fa.EndElement); _fdbg && _cgef.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fgbf *CT_SerTxChoice) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_edeae:
	for {
		_dadee, _cbgeg := d.Token()
		if _cbgeg != nil {
			return _cbgeg
		}
		switch _agadd := _dadee.(type) {
		case _fa.StartElement:
			switch _agadd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "strRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "strRef"}:
				_fgbf.StrRef = NewCT_StrRef()
				if _eadag := d.DecodeElement(_fgbf.StrRef, &_agadd); _eadag != nil {
					return _eadag
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "v"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "v"}:
				_fgbf.V = new(string)
				if _egfeb := d.DecodeElement(_fgbf.V, &_agadd); _egfeb != nil {
					return _egfeb
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SerTxChoice\u0020\u0025v", _agadd.Name)
				if _afced := d.Skip(); _afced != nil {
					return _afced
				}
			}
		case _fa.EndElement:
			break _edeae
		case _fa.CharData:
		}
	}
	return nil
}
func (_dccbb *ST_LayoutMode) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_dccbb = 0
	case "edge":
		*_dccbb = 1
	case "factor":
		*_dccbb = 2
	}
	return nil
}
func (_fbcfef ST_HoleSize) String() string {
	if _fbcfef.ST_HoleSizePercent != nil {
		return _gg.Sprintf("\u0025v", *_fbcfef.ST_HoleSizePercent)
	}
	if _fbcfef.ST_HoleSizeUByte != nil {
		return _gg.Sprintf("\u0025v", *_fbcfef.ST_HoleSizeUByte)
	}
	return ""
}
func NewCT_BandFmt() *CT_BandFmt {
	_beeb := &CT_BandFmt{}
	_beeb.Idx = NewCT_UnsignedInt()
	return _beeb
}
func (_gdfdgc ST_TickMark) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_bceda := _fa.Attr{}
	_bceda.Name = name
	switch _gdfdgc {
	case ST_TickMarkUnset:
		_bceda.Value = ""
	case ST_TickMarkCross:
		_bceda.Value = "cross"
	case ST_TickMarkIn:
		_bceda.Value = "in"
	case ST_TickMarkNone:
		_bceda.Value = "none"
	case ST_TickMarkOut:
		_bceda.Value = "out"
	}
	return _bceda, nil
}

// Validate validates the CT_Trendline and its children
func (_dcdec *CT_Trendline) Validate() error { return _dcdec.ValidateWithPath("CT_Trendline") }
func (_afed *CT_DispUnitsLbl) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_gddc:
	for {
		_gfcf, _faef := d.Token()
		if _faef != nil {
			return _faef
		}
		switch _dbb := _gfcf.(type) {
		case _fa.StartElement:
			switch _dbb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "layout"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "layout"}:
				_afed.Layout = NewCT_Layout()
				if _edgd := d.DecodeElement(_afed.Layout, &_dbb); _edgd != nil {
					return _edgd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_afed.Tx = NewCT_Tx()
				if _fffef := d.DecodeElement(_afed.Tx, &_dbb); _fffef != nil {
					return _fffef
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_afed.SpPr = _cb.NewCT_ShapeProperties()
				if _agae := d.DecodeElement(_afed.SpPr, &_dbb); _agae != nil {
					return _agae
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_afed.TxPr = _cb.NewCT_TextBody()
				if _fggf := d.DecodeElement(_afed.TxPr, &_dbb); _fggf != nil {
					return _fggf
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DispUnitsLbl\u0020\u0025v", _dbb.Name)
				if _abgga := d.Skip(); _abgga != nil {
					return _abgga
				}
			}
		case _fa.EndElement:
			break _gddc
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_DLblChoice and its children
func (_edec *CT_DLblChoice) Validate() error { return _edec.ValidateWithPath("CT_DLblChoice") }

// ValidateWithPath validates the CT_SurfaceSer and its children, prefixing error messages with path
func (_bbcfd *CT_SurfaceSer) ValidateWithPath(path string) error {
	if _begeg := _bbcfd.Idx.ValidateWithPath(path + "\u002fIdx"); _begeg != nil {
		return _begeg
	}
	if _bfadc := _bbcfd.Order.ValidateWithPath(path + "\u002fOrder"); _bfadc != nil {
		return _bfadc
	}
	if _bbcfd.Tx != nil {
		if _dgdcf := _bbcfd.Tx.ValidateWithPath(path + "\u002fTx"); _dgdcf != nil {
			return _dgdcf
		}
	}
	if _bbcfd.SpPr != nil {
		if _fcdde := _bbcfd.SpPr.ValidateWithPath(path + "\u002fSpPr"); _fcdde != nil {
			return _fcdde
		}
	}
	if _bbcfd.Cat != nil {
		if _gafcc := _bbcfd.Cat.ValidateWithPath(path + "\u002fCat"); _gafcc != nil {
			return _gafcc
		}
	}
	if _bbcfd.Val != nil {
		if _ggcf := _bbcfd.Val.ValidateWithPath(path + "\u002fVal"); _ggcf != nil {
			return _ggcf
		}
	}
	if _bbcfd.ExtLst != nil {
		if _accbe := _bbcfd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _accbe != nil {
			return _accbe
		}
	}
	return nil
}
func (_fdab *CT_NumFmt) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _gafdg := range start.Attr {
		if _gafdg.Name.Local == "formatCode" {
			_ffba, _ddega := _gafdg.Value, error(nil)
			if _ddega != nil {
				return _ddega
			}
			_fdab.FormatCodeAttr = _ffba
			continue
		}
		if _gafdg.Name.Local == "sourceLinked" {
			_cecf, _dbaf := _c.ParseBool(_gafdg.Value)
			if _dbaf != nil {
				return _dbaf
			}
			_fdab.SourceLinkedAttr = &_cecf
			continue
		}
	}
	for {
		_aecf, _gceb := d.Token()
		if _gceb != nil {
			return _gg.Errorf("parsing\u0020CT_NumFmt:\u0020\u0025s", _gceb)
		}
		if _fffb, _geedc := _aecf.(_fa.EndElement); _geedc && _fffb.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_CatAx struct {
	AxId           *CT_UnsignedInt
	Scaling        *CT_Scaling
	Delete         *CT_Boolean
	AxPos          *CT_AxPos
	MajorGridlines *CT_ChartLines
	MinorGridlines *CT_ChartLines
	Title          *CT_Title
	NumFmt         *CT_NumFmt
	MajorTickMark  *CT_TickMark
	MinorTickMark  *CT_TickMark
	TickLblPos     *CT_TickLblPos
	SpPr           *_cb.CT_ShapeProperties
	TxPr           *_cb.CT_TextBody
	CrossAx        *CT_UnsignedInt
	Choice         *EG_AxSharedChoice
	Auto           *CT_Boolean
	LblAlgn        *CT_LblAlgn
	LblOffset      *CT_LblOffset
	TickLblSkip    *CT_Skip
	TickMarkSkip   *CT_Skip
	NoMultiLvlLbl  *CT_Boolean
	ExtLst         *CT_ExtensionList
}

func (_acfce ST_RadarStyle) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_acfce.String(), start)
}

// Validate validates the CT_RotX and its children
func (_becaa *CT_RotX) Validate() error { return _becaa.ValidateWithPath("CT_RotX") }
func (_ffcfe ST_LayoutTarget) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_ffcfe.String(), start)
}

// Validate validates the CT_Surface and its children
func (_ggaca *CT_Surface) Validate() error { return _ggaca.ValidateWithPath("CT_Surface") }
func (_gag *CT_AxDataSourceChoice) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _gag.MultiLvlStrRef != nil {
		_deb := _fa.StartElement{Name: _fa.Name{Local: "c:multiLvlStrRef"}}
		e.EncodeElement(_gag.MultiLvlStrRef, _deb)
	}
	if _gag.NumRef != nil {
		_dac := _fa.StartElement{Name: _fa.Name{Local: "c:numRef"}}
		e.EncodeElement(_gag.NumRef, _dac)
	}
	if _gag.NumLit != nil {
		_fda := _fa.StartElement{Name: _fa.Name{Local: "c:numLit"}}
		e.EncodeElement(_gag.NumLit, _fda)
	}
	if _gag.StrRef != nil {
		_cda := _fa.StartElement{Name: _fa.Name{Local: "c:strRef"}}
		e.EncodeElement(_gag.StrRef, _cda)
	}
	if _gag.StrLit != nil {
		_dgac := _fa.StartElement{Name: _fa.Name{Local: "c:strLit"}}
		e.EncodeElement(_gag.StrLit, _dgac)
	}
	return nil
}

const (
	ST_ErrDirUnset ST_ErrDir = 0
	ST_ErrDirX     ST_ErrDir = 1
	ST_ErrDirY     ST_ErrDir = 2
)

func (_aefd ST_AxPos) Validate() error { return _aefd.ValidateWithPath("") }
func (_fbbaa *EG_AreaChartShared) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_efbec:
	for {
		_fbfd, _gcbfe := d.Token()
		if _gcbfe != nil {
			return _gcbfe
		}
		switch _afgf := _fbfd.(type) {
		case _fa.StartElement:
			switch _afgf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "grouping"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "grouping"}:
				_fbbaa.Grouping = NewCT_Grouping()
				if _abcfc := d.DecodeElement(_fbbaa.Grouping, &_afgf); _abcfc != nil {
					return _abcfc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_fbbaa.VaryColors = NewCT_Boolean()
				if _bccef := d.DecodeElement(_fbbaa.VaryColors, &_afgf); _bccef != nil {
					return _bccef
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_gccf := NewCT_AreaSer()
				if _fccd := d.DecodeElement(_gccf, &_afgf); _fccd != nil {
					return _fccd
				}
				_fbbaa.Ser = append(_fbbaa.Ser, _gccf)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_fbbaa.DLbls = NewCT_DLbls()
				if _faefe := d.DecodeElement(_fbbaa.DLbls, &_afgf); _faefe != nil {
					return _faefe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dropLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dropLines"}:
				_fbbaa.DropLines = NewCT_ChartLines()
				if _eacbb := d.DecodeElement(_fbbaa.DropLines, &_afgf); _eacbb != nil {
					return _eacbb
				}
			default:
				_b.Log("skipping\u0020unsupported element\u0020on\u0020EG_AreaChartShared\u0020\u0025v", _afgf.Name)
				if _bfdc := d.Skip(); _bfdc != nil {
					return _bfdc
				}
			}
		case _fa.EndElement:
			break _efbec
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_RadarStyle and its children
func (_bbdfg *CT_RadarStyle) Validate() error { return _bbdfg.ValidateWithPath("CT_RadarStyle") }
func (_fcdf *CT_PivotFmt) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_efcce := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_fcdf.Idx, _efcce)
	if _fcdf.SpPr != nil {
		_fcedf := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_fcdf.SpPr, _fcedf)
	}
	if _fcdf.TxPr != nil {
		_gdfad := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_fcdf.TxPr, _gdfad)
	}
	if _fcdf.Marker != nil {
		_cecg := _fa.StartElement{Name: _fa.Name{Local: "c:marker"}}
		e.EncodeElement(_fcdf.Marker, _cecg)
	}
	if _fcdf.DLbl != nil {
		_egec := _fa.StartElement{Name: _fa.Name{Local: "c:dLbl"}}
		e.EncodeElement(_fcdf.DLbl, _egec)
	}
	if _fcdf.ExtLst != nil {
		_ccac := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_fcdf.ExtLst, _ccac)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_aaafb *CT_Perspective) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _aaafb.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_aaafb.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_LineChart struct {
	Grouping   *CT_Grouping
	VaryColors *CT_Boolean
	Ser        []*CT_LineSer
	DLbls      *CT_DLbls
	DropLines  *CT_ChartLines
	HiLowLines *CT_ChartLines
	UpDownBars *CT_UpDownBars
	Marker     *CT_Boolean
	Smooth     *CT_Boolean
	AxId       []*CT_UnsignedInt
	ExtLst     *CT_ExtensionList
}
type CT_LblAlgn struct{ ValAttr ST_LblAlgn }

func (_feee *CT_GapAmount) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _babfd := range start.Attr {
		if _babfd.Name.Local == "val" {
			_cage, _deacb := ParseUnionST_GapAmount(_babfd.Value)
			if _deacb != nil {
				return _deacb
			}
			_feee.ValAttr = &_cage
			continue
		}
	}
	for {
		_bbdc, _bfgfc := d.Token()
		if _bfgfc != nil {
			return _gg.Errorf("parsing\u0020CT_GapAmount:\u0020\u0025s", _bfgfc)
		}
		if _fafa, _fccfe := _bbdc.(_fa.EndElement); _fccfe && _fafa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dbgfaf *ST_TrendlineType) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_dafgg, _abfgff := d.Token()
	if _abfgff != nil {
		return _abfgff
	}
	if _fdbfg, _ggggg := _dafgg.(_fa.EndElement); _ggggg && _fdbfg.Name == start.Name {
		*_dbgfaf = 1
		return nil
	}
	if _efbfa, _cccdc := _dafgg.(_fa.CharData); !_cccdc {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dafgg)
	} else {
		switch string(_efbfa) {
		case "":
			*_dbgfaf = 0
		case "exp":
			*_dbgfaf = 1
		case "linear":
			*_dbgfaf = 2
		case "log":
			*_dbgfaf = 3
		case "movingAvg":
			*_dbgfaf = 4
		case "poly":
			*_dbgfaf = 5
		case "power":
			*_dbgfaf = 6
		}
	}
	_dafgg, _abfgff = d.Token()
	if _abfgff != nil {
		return _abfgff
	}
	if _aedcc, _eeged := _dafgg.(_fa.EndElement); _eeged && _aedcc.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dafgg)
}
func (_fbcgc *ST_BarGrouping) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_fbcgc = 0
	case "percentStacked":
		*_fbcgc = 1
	case "clustered":
		*_fbcgc = 2
	case "standard":
		*_fbcgc = 3
	case "stacked":
		*_fbcgc = 4
	}
	return nil
}
func (_cfffb ST_ErrDir) String() string {
	switch _cfffb {
	case 0:
		return ""
	case 1:
		return "x"
	case 2:
		return "y"
	}
	return ""
}
func NewCT_PictureFormat() *CT_PictureFormat {
	_daagc := &CT_PictureFormat{}
	_daagc.ValAttr = ST_PictureFormat(1)
	return _daagc
}

const (
	ST_ShapeUnset        ST_Shape = 0
	ST_ShapeCone         ST_Shape = 1
	ST_ShapeConeToMax    ST_Shape = 2
	ST_ShapeBox          ST_Shape = 3
	ST_ShapeCylinder     ST_Shape = 4
	ST_ShapePyramid      ST_Shape = 5
	ST_ShapePyramidToMax ST_Shape = 6
)

func (_gbbac *EG_SurfaceChartShared) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_gfcffa:
	for {
		_dacbf, _ggead := d.Token()
		if _ggead != nil {
			return _ggead
		}
		switch _ecdag := _dacbf.(type) {
		case _fa.StartElement:
			switch _ecdag.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "wireframe"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "wireframe"}:
				_gbbac.Wireframe = NewCT_Boolean()
				if _bbbd := d.DecodeElement(_gbbac.Wireframe, &_ecdag); _bbbd != nil {
					return _bbbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_dbaca := NewCT_SurfaceSer()
				if _ccad := d.DecodeElement(_dbaca, &_ecdag); _ccad != nil {
					return _ccad
				}
				_gbbac.Ser = append(_gbbac.Ser, _dbaca)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bandFmts"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bandFmts"}:
				_gbbac.BandFmts = NewCT_BandFmts()
				if _addd := d.DecodeElement(_gbbac.BandFmts, &_ecdag); _addd != nil {
					return _addd
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on EG_SurfaceChartShared\u0020\u0025v", _ecdag.Name)
				if _gfcbg := d.Skip(); _gfcbg != nil {
					return _gfcbg
				}
			}
		case _fa.EndElement:
			break _gfcffa
		case _fa.CharData:
		}
	}
	return nil
}
func (_ca *CT_Area3DChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_gfa:
	for {
		_bcf, _eec := d.Token()
		if _eec != nil {
			return _eec
		}
		switch _ge := _bcf.(type) {
		case _fa.StartElement:
			switch _ge.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "grouping"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "grouping"}:
				_ca.Grouping = NewCT_Grouping()
				if _gcc := d.DecodeElement(_ca.Grouping, &_ge); _gcc != nil {
					return _gcc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_ca.VaryColors = NewCT_Boolean()
				if _fga := d.DecodeElement(_ca.VaryColors, &_ge); _fga != nil {
					return _fga
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_ea := NewCT_AreaSer()
				if _ggg := d.DecodeElement(_ea, &_ge); _ggg != nil {
					return _ggg
				}
				_ca.Ser = append(_ca.Ser, _ea)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_ca.DLbls = NewCT_DLbls()
				if _dg := d.DecodeElement(_ca.DLbls, &_ge); _dg != nil {
					return _dg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dropLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dropLines"}:
				_ca.DropLines = NewCT_ChartLines()
				if _eg := d.DecodeElement(_ca.DropLines, &_ge); _eg != nil {
					return _eg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "gapDepth"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "gapDepth"}:
				_ca.GapDepth = NewCT_GapAmount()
				if _fca := d.DecodeElement(_ca.GapDepth, &_ge); _fca != nil {
					return _fca
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_fe := NewCT_UnsignedInt()
				if _a := d.DecodeElement(_fe, &_ge); _a != nil {
					return _a
				}
				_ca.AxId = append(_ca.AxId, _fe)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_ca.ExtLst = NewCT_ExtensionList()
				if _af := d.DecodeElement(_ca.ExtLst, &_ge); _af != nil {
					return _af
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Area3DChart\u0020\u0025v", _ge.Name)
				if _bef := d.Skip(); _bef != nil {
					return _bef
				}
			}
		case _fa.EndElement:
			break _gfa
		case _fa.CharData:
		}
	}
	return nil
}
func (_deee ST_DepthPercent) String() string {
	if _deee.ST_DepthPercentWithSymbol != nil {
		return _gg.Sprintf("\u0025v", *_deee.ST_DepthPercentWithSymbol)
	}
	if _deee.ST_DepthPercentUShort != nil {
		return _gg.Sprintf("\u0025v", *_deee.ST_DepthPercentUShort)
	}
	return ""
}

// Validate validates the CT_DispBlanksAs and its children
func (_cfa *CT_DispBlanksAs) Validate() error { return _cfa.ValidateWithPath("CT_DispBlanksAs") }
func (_cgafbf ST_DLblPos) String() string {
	switch _cgafbf {
	case 0:
		return ""
	case 1:
		return "bestFit"
	case 2:
		return "b"
	case 3:
		return "ctr"
	case 4:
		return "inBase"
	case 5:
		return "inEnd"
	case 6:
		return "l"
	case 7:
		return "outEnd"
	case 8:
		return "r"
	case 9:
		return "t"
	}
	return ""
}

type CT_ValAx struct {
	AxId           *CT_UnsignedInt
	Scaling        *CT_Scaling
	Delete         *CT_Boolean
	AxPos          *CT_AxPos
	MajorGridlines *CT_ChartLines
	MinorGridlines *CT_ChartLines
	Title          *CT_Title
	NumFmt         *CT_NumFmt
	MajorTickMark  *CT_TickMark
	MinorTickMark  *CT_TickMark
	TickLblPos     *CT_TickLblPos
	SpPr           *_cb.CT_ShapeProperties
	TxPr           *_cb.CT_TextBody
	CrossAx        *CT_UnsignedInt
	Choice         *EG_AxSharedChoice
	CrossBetween   *CT_CrossBetween
	MajorUnit      *CT_AxisUnit
	MinorUnit      *CT_AxisUnit
	DispUnits      *CT_DispUnits
	ExtLst         *CT_ExtensionList
}

func (_fcbfa *CT_RadarChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_fcbfa.RadarStyle = NewCT_RadarStyle()
_cdcb:
	for {
		_adbc, _bdcdf := d.Token()
		if _bdcdf != nil {
			return _bdcdf
		}
		switch _dggbg := _adbc.(type) {
		case _fa.StartElement:
			switch _dggbg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "radarStyle"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "radarStyle"}:
				if _eddb := d.DecodeElement(_fcbfa.RadarStyle, &_dggbg); _eddb != nil {
					return _eddb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_fcbfa.VaryColors = NewCT_Boolean()
				if _dddc := d.DecodeElement(_fcbfa.VaryColors, &_dggbg); _dddc != nil {
					return _dddc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_fbbc := NewCT_RadarSer()
				if _bgddb := d.DecodeElement(_fbbc, &_dggbg); _bgddb != nil {
					return _bgddb
				}
				_fcbfa.Ser = append(_fcbfa.Ser, _fbbc)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_fcbfa.DLbls = NewCT_DLbls()
				if _dgfgd := d.DecodeElement(_fcbfa.DLbls, &_dggbg); _dgfgd != nil {
					return _dgfgd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_aade := NewCT_UnsignedInt()
				if _eddad := d.DecodeElement(_aade, &_dggbg); _eddad != nil {
					return _eddad
				}
				_fcbfa.AxId = append(_fcbfa.AxId, _aade)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_fcbfa.ExtLst = NewCT_ExtensionList()
				if _aggbg := d.DecodeElement(_fcbfa.ExtLst, &_dggbg); _aggbg != nil {
					return _aggbg
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_RadarChart \u0025v", _dggbg.Name)
				if _afde := d.Skip(); _afde != nil {
					return _afde
				}
			}
		case _fa.EndElement:
			break _cdcb
		case _fa.CharData:
		}
	}
	return nil
}

var ST_LblOffsetPercentPatternRe = _g.MustCompile(ST_LblOffsetPercentPattern)

// Validate validates the CT_BubbleSer and its children
func (_fegca *CT_BubbleSer) Validate() error { return _fegca.ValidateWithPath("CT_BubbleSer") }
func (_bedd *CT_FirstSliceAng) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _cbbfc := range start.Attr {
		if _cbbfc.Name.Local == "val" {
			_gdcc, _bage := _c.ParseUint(_cbbfc.Value, 10, 16)
			if _bage != nil {
				return _bage
			}
			_gfcge := uint16(_gdcc)
			_bedd.ValAttr = &_gfcge
			continue
		}
	}
	for {
		_gbea, _baea := d.Token()
		if _baea != nil {
			return _gg.Errorf("parsing\u0020CT_FirstSliceAng: \u0025s", _baea)
		}
		if _ggde, _gebf := _gbea.(_fa.EndElement); _gebf && _ggde.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ecff *CT_DispUnitsChoice) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _ecff.CustUnit != nil {
		_daddc := _fa.StartElement{Name: _fa.Name{Local: "c:custUnit"}}
		e.EncodeElement(_ecff.CustUnit, _daddc)
	}
	if _ecff.BuiltInUnit != nil {
		_gefbc := _fa.StartElement{Name: _fa.Name{Local: "c:builtInUnit"}}
		e.EncodeElement(_ecff.BuiltInUnit, _gefbc)
	}
	return nil
}
func (_affd *CT_Grouping) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _affd.ValAttr != ST_GroupingUnset {
		_bced, _adbe := _affd.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _adbe != nil {
			return _adbe
		}
		start.Attr = append(start.Attr, _bced)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_PivotSource struct {
	Name   string
	FmtId  *CT_UnsignedInt
	ExtLst []*CT_ExtensionList
}

// ValidateWithPath validates the CT_DateAx and its children, prefixing error messages with path
func (_gfea *CT_DateAx) ValidateWithPath(path string) error {
	if _egaga := _gfea.AxId.ValidateWithPath(path + "\u002fAxId"); _egaga != nil {
		return _egaga
	}
	if _gaad := _gfea.Scaling.ValidateWithPath(path + "\u002fScaling"); _gaad != nil {
		return _gaad
	}
	if _gfea.Delete != nil {
		if _aaaa := _gfea.Delete.ValidateWithPath(path + "\u002fDelete"); _aaaa != nil {
			return _aaaa
		}
	}
	if _eabe := _gfea.AxPos.ValidateWithPath(path + "\u002fAxPos"); _eabe != nil {
		return _eabe
	}
	if _gfea.MajorGridlines != nil {
		if _abebg := _gfea.MajorGridlines.ValidateWithPath(path + "\u002fMajorGridlines"); _abebg != nil {
			return _abebg
		}
	}
	if _gfea.MinorGridlines != nil {
		if _afda := _gfea.MinorGridlines.ValidateWithPath(path + "\u002fMinorGridlines"); _afda != nil {
			return _afda
		}
	}
	if _gfea.Title != nil {
		if _caefg := _gfea.Title.ValidateWithPath(path + "\u002fTitle"); _caefg != nil {
			return _caefg
		}
	}
	if _gfea.NumFmt != nil {
		if _geee := _gfea.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _geee != nil {
			return _geee
		}
	}
	if _gfea.MajorTickMark != nil {
		if _afbfd := _gfea.MajorTickMark.ValidateWithPath(path + "\u002fMajorTickMark"); _afbfd != nil {
			return _afbfd
		}
	}
	if _gfea.MinorTickMark != nil {
		if _edbff := _gfea.MinorTickMark.ValidateWithPath(path + "\u002fMinorTickMark"); _edbff != nil {
			return _edbff
		}
	}
	if _gfea.TickLblPos != nil {
		if _bagd := _gfea.TickLblPos.ValidateWithPath(path + "/TickLblPos"); _bagd != nil {
			return _bagd
		}
	}
	if _gfea.SpPr != nil {
		if _ceda := _gfea.SpPr.ValidateWithPath(path + "\u002fSpPr"); _ceda != nil {
			return _ceda
		}
	}
	if _gfea.TxPr != nil {
		if _aebd := _gfea.TxPr.ValidateWithPath(path + "\u002fTxPr"); _aebd != nil {
			return _aebd
		}
	}
	if _cebf := _gfea.CrossAx.ValidateWithPath(path + "\u002fCrossAx"); _cebf != nil {
		return _cebf
	}
	if _gfea.Choice != nil {
		if _ecgd := _gfea.Choice.ValidateWithPath(path + "\u002fChoice"); _ecgd != nil {
			return _ecgd
		}
	}
	if _gfea.Auto != nil {
		if _fabbg := _gfea.Auto.ValidateWithPath(path + "\u002fAuto"); _fabbg != nil {
			return _fabbg
		}
	}
	if _gfea.LblOffset != nil {
		if _egcg := _gfea.LblOffset.ValidateWithPath(path + "\u002fLblOffset"); _egcg != nil {
			return _egcg
		}
	}
	if _gfea.BaseTimeUnit != nil {
		if _bagdf := _gfea.BaseTimeUnit.ValidateWithPath(path + "\u002fBaseTimeUnit"); _bagdf != nil {
			return _bagdf
		}
	}
	if _gfea.MajorUnit != nil {
		if _geec := _gfea.MajorUnit.ValidateWithPath(path + "\u002fMajorUnit"); _geec != nil {
			return _geec
		}
	}
	if _gfea.MajorTimeUnit != nil {
		if _fecae := _gfea.MajorTimeUnit.ValidateWithPath(path + "\u002fMajorTimeUnit"); _fecae != nil {
			return _fecae
		}
	}
	if _gfea.MinorUnit != nil {
		if _beea := _gfea.MinorUnit.ValidateWithPath(path + "\u002fMinorUnit"); _beea != nil {
			return _beea
		}
	}
	if _gfea.MinorTimeUnit != nil {
		if _adga := _gfea.MinorTimeUnit.ValidateWithPath(path + "\u002fMinorTimeUnit"); _adga != nil {
			return _adga
		}
	}
	if _gfea.ExtLst != nil {
		if _dffc := _gfea.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dffc != nil {
			return _dffc
		}
	}
	return nil
}

type CT_NumDataSourceChoice struct {
	NumRef *CT_NumRef
	NumLit *CT_NumData
}

func (_gccd *CT_HeaderFooter) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _gccd.AlignWithMarginsAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "alignWithMargins"}, Value: _gg.Sprintf("\u0025d", _feaac(*_gccd.AlignWithMarginsAttr))})
	}
	if _gccd.DifferentOddEvenAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "differentOddEven"}, Value: _gg.Sprintf("\u0025d", _feaac(*_gccd.DifferentOddEvenAttr))})
	}
	if _gccd.DifferentFirstAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "differentFirst"}, Value: _gg.Sprintf("\u0025d", _feaac(*_gccd.DifferentFirstAttr))})
	}
	e.EncodeToken(start)
	if _gccd.OddHeader != nil {
		_dafd := _fa.StartElement{Name: _fa.Name{Local: "c:oddHeader"}}
		_b.AddPreserveSpaceAttr(&_dafd, *_gccd.OddHeader)
		e.EncodeElement(_gccd.OddHeader, _dafd)
	}
	if _gccd.OddFooter != nil {
		_abfge := _fa.StartElement{Name: _fa.Name{Local: "c:oddFooter"}}
		_b.AddPreserveSpaceAttr(&_abfge, *_gccd.OddFooter)
		e.EncodeElement(_gccd.OddFooter, _abfge)
	}
	if _gccd.EvenHeader != nil {
		_ebbfd := _fa.StartElement{Name: _fa.Name{Local: "c:evenHeader"}}
		_b.AddPreserveSpaceAttr(&_ebbfd, *_gccd.EvenHeader)
		e.EncodeElement(_gccd.EvenHeader, _ebbfd)
	}
	if _gccd.EvenFooter != nil {
		_fdea := _fa.StartElement{Name: _fa.Name{Local: "c:evenFooter"}}
		_b.AddPreserveSpaceAttr(&_fdea, *_gccd.EvenFooter)
		e.EncodeElement(_gccd.EvenFooter, _fdea)
	}
	if _gccd.FirstHeader != nil {
		_bgge := _fa.StartElement{Name: _fa.Name{Local: "c:firstHeader"}}
		_b.AddPreserveSpaceAttr(&_bgge, *_gccd.FirstHeader)
		e.EncodeElement(_gccd.FirstHeader, _bgge)
	}
	if _gccd.FirstFooter != nil {
		_abfga := _fa.StartElement{Name: _fa.Name{Local: "c:firstFooter"}}
		_b.AddPreserveSpaceAttr(&_abfga, *_gccd.FirstFooter)
		e.EncodeElement(_gccd.FirstFooter, _abfga)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_egf *CT_AreaSer) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_ece := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_egf.Idx, _ece)
	_febc := _fa.StartElement{Name: _fa.Name{Local: "c:order"}}
	e.EncodeElement(_egf.Order, _febc)
	if _egf.Tx != nil {
		_befb := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_egf.Tx, _befb)
	}
	if _egf.SpPr != nil {
		_gff := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_egf.SpPr, _gff)
	}
	if _egf.PictureOptions != nil {
		_cbe := _fa.StartElement{Name: _fa.Name{Local: "c:pictureOptions"}}
		e.EncodeElement(_egf.PictureOptions, _cbe)
	}
	if _egf.DPt != nil {
		_dcb := _fa.StartElement{Name: _fa.Name{Local: "c:dPt"}}
		for _, _dgga := range _egf.DPt {
			e.EncodeElement(_dgga, _dcb)
		}
	}
	if _egf.DLbls != nil {
		_cfe := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_egf.DLbls, _cfe)
	}
	if _egf.Trendline != nil {
		_fbf := _fa.StartElement{Name: _fa.Name{Local: "c:trendline"}}
		for _, _ebb := range _egf.Trendline {
			e.EncodeElement(_ebb, _fbf)
		}
	}
	if _egf.ErrBars != nil {
		_cee := _fa.StartElement{Name: _fa.Name{Local: "c:errBars"}}
		for _, _gffc := range _egf.ErrBars {
			e.EncodeElement(_gffc, _cee)
		}
	}
	if _egf.Cat != nil {
		_aad := _fa.StartElement{Name: _fa.Name{Local: "c:cat"}}
		e.EncodeElement(_egf.Cat, _aad)
	}
	if _egf.Val != nil {
		_cbc := _fa.StartElement{Name: _fa.Name{Local: "c:val"}}
		e.EncodeElement(_egf.Val, _cbc)
	}
	if _egf.ExtLst != nil {
		_cgc := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_egf.ExtLst, _cgc)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_PieChart struct {
	VaryColors    *CT_Boolean
	Ser           []*CT_PieSer
	DLbls         *CT_DLbls
	FirstSliceAng *CT_FirstSliceAng
	ExtLst        *CT_ExtensionList
}

func (_bccae *ST_Overlap) ValidateWithPath(path string) error {
	_defbea := []string{}
	if _bccae.ST_OverlapPercent != nil {
		_defbea = append(_defbea, "ST_OverlapPercent")
	}
	if _bccae.ST_OverlapByte != nil {
		_defbea = append(_defbea, "ST_OverlapByte")
	}
	if len(_defbea) > 1 {
		return _gg.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _defbea)
	}
	return nil
}

// ValidateWithPath validates the EG_PieChartShared and its children, prefixing error messages with path
func (_ebcde *EG_PieChartShared) ValidateWithPath(path string) error {
	if _ebcde.VaryColors != nil {
		if _afbeg := _ebcde.VaryColors.ValidateWithPath(path + "/VaryColors"); _afbeg != nil {
			return _afbeg
		}
	}
	for _beagb, _gcbg := range _ebcde.Ser {
		if _gdafd := _gcbg.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _beagb)); _gdafd != nil {
			return _gdafd
		}
	}
	if _ebcde.DLbls != nil {
		if _efddb := _ebcde.DLbls.ValidateWithPath(path + "\u002fDLbls"); _efddb != nil {
			return _efddb
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PlotAreaChoice1 and its children, prefixing error messages with path
func (_daaf *CT_PlotAreaChoice1) ValidateWithPath(path string) error {
	for _egafa, _gfddg := range _daaf.ValAx {
		if _eaeaa := _gfddg.ValidateWithPath(_gg.Sprintf("\u0025s\u002fValAx\u005b\u0025d\u005d", path, _egafa)); _eaeaa != nil {
			return _eaeaa
		}
	}
	for _bcbdf, _gfcab := range _daaf.CatAx {
		if _faad := _gfcab.ValidateWithPath(_gg.Sprintf("\u0025s\u002fCatAx\u005b\u0025d\u005d", path, _bcbdf)); _faad != nil {
			return _faad
		}
	}
	for _facf, _geegc := range _daaf.DateAx {
		if _eaaga := _geegc.ValidateWithPath(_gg.Sprintf("\u0025s\u002fDateAx\u005b\u0025d\u005d", path, _facf)); _eaaga != nil {
			return _eaaga
		}
	}
	for _babfc, _cbcbf := range _daaf.SerAx {
		if _bddcc := _cbcbf.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSerAx\u005b\u0025d\u005d", path, _babfc)); _bddcc != nil {
			return _bddcc
		}
	}
	return nil
}
func NewCT_HoleSize() *CT_HoleSize { _bcfg := &CT_HoleSize{}; return _bcfg }
func (_cggda *CT_Lvl) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_bggac:
	for {
		_acbbf, _gacf := d.Token()
		if _gacf != nil {
			return _gacf
		}
		switch _affe := _acbbf.(type) {
		case _fa.StartElement:
			switch _affe.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pt"}:
				_cfgf := NewCT_StrVal()
				if _dfddg := d.DecodeElement(_cfgf, &_affe); _dfddg != nil {
					return _dfddg
				}
				_cggda.Pt = append(_cggda.Pt, _cfgf)
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Lvl\u0020\u0025v", _affe.Name)
				if _facc := d.Skip(); _facc != nil {
					return _facc
				}
			}
		case _fa.EndElement:
			break _bggac
		case _fa.CharData:
		}
	}
	return nil
}

type CT_Marker struct {
	Symbol *CT_MarkerStyle
	Size   *CT_MarkerSize
	SpPr   *_cb.CT_ShapeProperties
	ExtLst *CT_ExtensionList
}

func (_ddgde ST_Grouping) String() string {
	switch _ddgde {
	case 0:
		return ""
	case 1:
		return "percentStacked"
	case 2:
		return "standard"
	case 3:
		return "stacked"
	}
	return ""
}

// Validate validates the EG_LineChartShared and its children
func (_agafe *EG_LineChartShared) Validate() error {
	return _agafe.ValidateWithPath("EG_LineChartShared")
}
func (_aafca *CT_DLblChoice) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_ddgg:
	for {
		_fcae, _ggaa := d.Token()
		if _ggaa != nil {
			return _ggaa
		}
		switch _fffe := _fcae.(type) {
		case _fa.StartElement:
			switch _fffe.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "delete"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "delete"}:
				_aafca.Delete = NewCT_Boolean()
				if _ebef := d.DecodeElement(_aafca.Delete, &_fffe); _ebef != nil {
					return _ebef
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "layout"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "layout"}:
				_aafca.Layout = NewCT_Layout()
				if _adad := d.DecodeElement(_aafca.Layout, &_fffe); _adad != nil {
					return _adad
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_aafca.Tx = NewCT_Tx()
				if _daca := d.DecodeElement(_aafca.Tx, &_fffe); _daca != nil {
					return _daca
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				_aafca.NumFmt = NewCT_NumFmt()
				if _gdfb := d.DecodeElement(_aafca.NumFmt, &_fffe); _gdfb != nil {
					return _gdfb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_aafca.SpPr = _cb.NewCT_ShapeProperties()
				if _ffdf := d.DecodeElement(_aafca.SpPr, &_fffe); _ffdf != nil {
					return _ffdf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_aafca.TxPr = _cb.NewCT_TextBody()
				if _aed := d.DecodeElement(_aafca.TxPr, &_fffe); _aed != nil {
					return _aed
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLblPos"}:
				_aafca.DLblPos = NewCT_DLblPos()
				if _bcbd := d.DecodeElement(_aafca.DLblPos, &_fffe); _bcbd != nil {
					return _bcbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showLegendKey"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showLegendKey"}:
				_aafca.ShowLegendKey = NewCT_Boolean()
				if _eaeg := d.DecodeElement(_aafca.ShowLegendKey, &_fffe); _eaeg != nil {
					return _eaeg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showVal"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showVal"}:
				_aafca.ShowVal = NewCT_Boolean()
				if _bcge := d.DecodeElement(_aafca.ShowVal, &_fffe); _bcge != nil {
					return _bcge
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showCatName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showCatName"}:
				_aafca.ShowCatName = NewCT_Boolean()
				if _acdd := d.DecodeElement(_aafca.ShowCatName, &_fffe); _acdd != nil {
					return _acdd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showSerName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showSerName"}:
				_aafca.ShowSerName = NewCT_Boolean()
				if _dcge := d.DecodeElement(_aafca.ShowSerName, &_fffe); _dcge != nil {
					return _dcge
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showPercent"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showPercent"}:
				_aafca.ShowPercent = NewCT_Boolean()
				if _fbee := d.DecodeElement(_aafca.ShowPercent, &_fffe); _fbee != nil {
					return _fbee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showBubbleSize"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showBubbleSize"}:
				_aafca.ShowBubbleSize = NewCT_Boolean()
				if _gfae := d.DecodeElement(_aafca.ShowBubbleSize, &_fffe); _gfae != nil {
					return _gfae
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "separator"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "separator"}:
				_aafca.Separator = new(string)
				if _eecb := d.DecodeElement(_aafca.Separator, &_fffe); _eecb != nil {
					return _eecb
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_DLblChoice \u0025v", _fffe.Name)
				if _ebaab := d.Skip(); _ebaab != nil {
					return _ebaab
				}
			}
		case _fa.EndElement:
			break _ddgg
		case _fa.CharData:
		}
	}
	return nil
}
func (_dabcg *CT_RadarSer) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cbdad := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_dabcg.Idx, _cbdad)
	_degf := _fa.StartElement{Name: _fa.Name{Local: "c:order"}}
	e.EncodeElement(_dabcg.Order, _degf)
	if _dabcg.Tx != nil {
		_ccfd := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_dabcg.Tx, _ccfd)
	}
	if _dabcg.SpPr != nil {
		_gebff := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_dabcg.SpPr, _gebff)
	}
	if _dabcg.Marker != nil {
		_gbac := _fa.StartElement{Name: _fa.Name{Local: "c:marker"}}
		e.EncodeElement(_dabcg.Marker, _gbac)
	}
	if _dabcg.DPt != nil {
		_fegb := _fa.StartElement{Name: _fa.Name{Local: "c:dPt"}}
		for _, _fcbfaa := range _dabcg.DPt {
			e.EncodeElement(_fcbfaa, _fegb)
		}
	}
	if _dabcg.DLbls != nil {
		_bege := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_dabcg.DLbls, _bege)
	}
	if _dabcg.Cat != nil {
		_dcddc := _fa.StartElement{Name: _fa.Name{Local: "c:cat"}}
		e.EncodeElement(_dabcg.Cat, _dcddc)
	}
	if _dabcg.Val != nil {
		_cece := _fa.StartElement{Name: _fa.Name{Local: "c:val"}}
		e.EncodeElement(_dabcg.Val, _cece)
	}
	if _dabcg.ExtLst != nil {
		_afec := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_dabcg.ExtLst, _afec)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_ffdba *ST_TickLblPos) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_dbafb, _cgfb := d.Token()
	if _cgfb != nil {
		return _cgfb
	}
	if _dggfc, _febba := _dbafb.(_fa.EndElement); _febba && _dggfc.Name == start.Name {
		*_ffdba = 1
		return nil
	}
	if _baeb, _cgafa := _dbafb.(_fa.CharData); !_cgafa {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dbafb)
	} else {
		switch string(_baeb) {
		case "":
			*_ffdba = 0
		case "high":
			*_ffdba = 1
		case "low":
			*_ffdba = 2
		case "nextTo":
			*_ffdba = 3
		case "none":
			*_ffdba = 4
		}
	}
	_dbafb, _cgfb = d.Token()
	if _cgfb != nil {
		return _cgfb
	}
	if _ceade, _gbbba := _dbafb.(_fa.EndElement); _gbbba && _ceade.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dbafb)
}
func (_ddb *CT_Legend) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_aabfc:
	for {
		_aeggf, _ceed := d.Token()
		if _ceed != nil {
			return _ceed
		}
		switch _bfbc := _aeggf.(type) {
		case _fa.StartElement:
			switch _bfbc.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "legendPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "legendPos"}:
				_ddb.LegendPos = NewCT_LegendPos()
				if _fdef := d.DecodeElement(_ddb.LegendPos, &_bfbc); _fdef != nil {
					return _fdef
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "legendEntry"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "legendEntry"}:
				_aaag := NewCT_LegendEntry()
				if _gdea := d.DecodeElement(_aaag, &_bfbc); _gdea != nil {
					return _gdea
				}
				_ddb.LegendEntry = append(_ddb.LegendEntry, _aaag)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "layout"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "layout"}:
				_ddb.Layout = NewCT_Layout()
				if _bfbdb := d.DecodeElement(_ddb.Layout, &_bfbc); _bfbdb != nil {
					return _bfbdb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "overlay"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "overlay"}:
				_ddb.Overlay = NewCT_Boolean()
				if _bfcdc := d.DecodeElement(_ddb.Overlay, &_bfbc); _bfcdc != nil {
					return _bfcdc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_ddb.SpPr = _cb.NewCT_ShapeProperties()
				if _gecaf := d.DecodeElement(_ddb.SpPr, &_bfbc); _gecaf != nil {
					return _gecaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_ddb.TxPr = _cb.NewCT_TextBody()
				if _badc := d.DecodeElement(_ddb.TxPr, &_bfbc); _badc != nil {
					return _badc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_ddb.ExtLst = NewCT_ExtensionList()
				if _fbce := d.DecodeElement(_ddb.ExtLst, &_bfbc); _fbce != nil {
					return _fbce
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_Legend \u0025v", _bfbc.Name)
				if _bddgg := d.Skip(); _bddgg != nil {
					return _bddgg
				}
			}
		case _fa.EndElement:
			break _aabfc
		case _fa.CharData:
		}
	}
	return nil
}
func NewCT_Legend() *CT_Legend { _fafcf := &CT_Legend{}; return _fafcf }
func (_efgf *ST_HPercent) ValidateWithPath(path string) error {
	_cggeb := []string{}
	if _efgf.ST_HPercentWithSymbol != nil {
		_cggeb = append(_cggeb, "ST_HPercentWithSymbol")
	}
	if _efgf.ST_HPercentUShort != nil {
		_cggeb = append(_cggeb, "ST_HPercentUShort")
	}
	if len(_cggeb) > 1 {
		return _gg.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _cggeb)
	}
	return nil
}
func (_dgefg *ST_PictureFormat) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ageac, _cdcc := d.Token()
	if _cdcc != nil {
		return _cdcc
	}
	if _cbfdd, _bcaca := _ageac.(_fa.EndElement); _bcaca && _cbfdd.Name == start.Name {
		*_dgefg = 1
		return nil
	}
	if _afgdd, _ceeg := _ageac.(_fa.CharData); !_ceeg {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ageac)
	} else {
		switch string(_afgdd) {
		case "":
			*_dgefg = 0
		case "stretch":
			*_dgefg = 1
		case "stack":
			*_dgefg = 2
		case "stackScale":
			*_dgefg = 3
		}
	}
	_ageac, _cdcc = d.Token()
	if _cdcc != nil {
		return _cdcc
	}
	if _fdecf, _addccf := _ageac.(_fa.EndElement); _addccf && _fdecf.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ageac)
}

const ST_SecondPieSizePercentPattern = "0\u002a\u0028\u0028\u005b5\u002d9\u005d\u0029\u007c(\u005b1\u002d9]\u005b0\u002d9\u005d\u0029\u007c\u00281\u005b0\u002d9\u005d\u005b0\u002d9\u005d\u0029\u007c200\u0029\u0025"

// Validate validates the CT_MarkerSize and its children
func (_abebf *CT_MarkerSize) Validate() error    { return _abebf.ValidateWithPath("CT_MarkerSize") }
func NewCT_BubbleScale() *CT_BubbleScale         { _aga := &CT_BubbleScale{}; return _aga }
func NewCT_DispUnitsChoice() *CT_DispUnitsChoice { _dbeba := &CT_DispUnitsChoice{}; return _dbeba }

// ValidateWithPath validates the CT_ChartLines and its children, prefixing error messages with path
func (_ddfd *CT_ChartLines) ValidateWithPath(path string) error {
	if _ddfd.SpPr != nil {
		if _bfed := _ddfd.SpPr.ValidateWithPath(path + "\u002fSpPr"); _bfed != nil {
			return _bfed
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TrendlineLbl and its children, prefixing error messages with path
func (_cface *CT_TrendlineLbl) ValidateWithPath(path string) error {
	if _cface.Layout != nil {
		if _bbebb := _cface.Layout.ValidateWithPath(path + "\u002fLayout"); _bbebb != nil {
			return _bbebb
		}
	}
	if _cface.Tx != nil {
		if _cadeg := _cface.Tx.ValidateWithPath(path + "\u002fTx"); _cadeg != nil {
			return _cadeg
		}
	}
	if _cface.NumFmt != nil {
		if _fcfb := _cface.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _fcfb != nil {
			return _fcfb
		}
	}
	if _cface.SpPr != nil {
		if _dbfcb := _cface.SpPr.ValidateWithPath(path + "\u002fSpPr"); _dbfcb != nil {
			return _dbfcb
		}
	}
	if _cface.TxPr != nil {
		if _fgdgg := _cface.TxPr.ValidateWithPath(path + "\u002fTxPr"); _fgdgg != nil {
			return _fgdgg
		}
	}
	if _cface.ExtLst != nil {
		if _dbeab := _cface.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dbeab != nil {
			return _dbeab
		}
	}
	return nil
}

type CT_PivotFmt struct {
	Idx    *CT_UnsignedInt
	SpPr   *_cb.CT_ShapeProperties
	TxPr   *_cb.CT_TextBody
	Marker *CT_Marker
	DLbl   *CT_DLbl
	ExtLst *CT_ExtensionList
}
type CT_Title struct {
	Tx      *CT_Tx
	Layout  *CT_Layout
	Overlay *CT_Boolean
	SpPr    *_cb.CT_ShapeProperties
	TxPr    *_cb.CT_TextBody
	ExtLst  *CT_ExtensionList
}

// Validate validates the CT_Boolean and its children
func (_fdd *CT_Boolean) Validate() error     { return _fdd.ValidateWithPath("CT_Boolean") }
func NewCT_TrendlineType() *CT_TrendlineType { _gggcg := &CT_TrendlineType{}; return _gggcg }

// Validate validates the CT_PlotAreaChoice and its children
func (_eaede *CT_PlotAreaChoice) Validate() error {
	return _eaede.ValidateWithPath("CT_PlotAreaChoice")
}
func (_addgba ST_SecondPieSize) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _addgba.ST_SecondPieSizePercent != nil {
		e.EncodeToken(_fa.CharData(*_addgba.ST_SecondPieSizePercent))
	}
	if _addgba.ST_SecondPieSizeUShort != nil {
		e.EncodeToken(_fa.CharData(_gg.Sprintf("\u0025d", *_addgba.ST_SecondPieSizeUShort)))
	}
	return e.EncodeToken(_fa.EndElement{Name: start.Name})
}

// ValidateWithPath validates the CT_BuiltInUnit and its children, prefixing error messages with path
func (_befe *CT_BuiltInUnit) ValidateWithPath(path string) error {
	if _egee := _befe.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _egee != nil {
		return _egee
	}
	return nil
}

type CT_ExternalData struct {
	IdAttr     string
	AutoUpdate *CT_Boolean
}

func (_fbgg *CT_PivotFmts) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_gdggf:
	for {
		_acaga, _geabb := d.Token()
		if _geabb != nil {
			return _geabb
		}
		switch _dfdb := _acaga.(type) {
		case _fa.StartElement:
			switch _dfdb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pivotFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pivotFmt"}:
				_cdbccf := NewCT_PivotFmt()
				if _cfad := d.DecodeElement(_cdbccf, &_dfdb); _cfad != nil {
					return _cfad
				}
				_fbgg.PivotFmt = append(_fbgg.PivotFmt, _cdbccf)
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PivotFmts\u0020\u0025v", _dfdb.Name)
				if _gbab := d.Skip(); _gbab != nil {
					return _gbab
				}
			}
		case _fa.EndElement:
			break _gdggf
		case _fa.CharData:
		}
	}
	return nil
}
func (_gggag *ST_ErrBarType) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_gggag = 0
	case "both":
		*_gggag = 1
	case "minus":
		*_gggag = 2
	case "plus":
		*_gggag = 3
	}
	return nil
}

// Validate validates the CT_LblOffset and its children
func (_dfcb *CT_LblOffset) Validate() error { return _dfcb.ValidateWithPath("CT_LblOffset") }
func (_gcbb *ST_TickMark) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_gcbb = 0
	case "cross":
		*_gcbb = 1
	case "in":
		*_gcbb = 2
	case "none":
		*_gcbb = 3
	case "out":
		*_gcbb = 4
	}
	return nil
}
func (_ebdfe *CT_SerTx) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ebdfe.Choice = NewCT_SerTxChoice()
_dcddb:
	for {
		_efbc, _eddadf := d.Token()
		if _eddadf != nil {
			return _eddadf
		}
		switch _adaed := _efbc.(type) {
		case _fa.StartElement:
			switch _adaed.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "strRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "strRef"}:
				_ebdfe.Choice = NewCT_SerTxChoice()
				if _gddcd := d.DecodeElement(&_ebdfe.Choice.StrRef, &_adaed); _gddcd != nil {
					return _gddcd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "v"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "v"}:
				_ebdfe.Choice = NewCT_SerTxChoice()
				if _dacgb := d.DecodeElement(&_ebdfe.Choice.V, &_adaed); _dacgb != nil {
					return _dacgb
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SerTx\u0020\u0025v", _adaed.Name)
				if _fbfaf := d.Skip(); _fbfaf != nil {
					return _fbfaf
				}
			}
		case _fa.EndElement:
			break _dcddb
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_NumDataSource and its children, prefixing error messages with path
func (_cefdb *CT_NumDataSource) ValidateWithPath(path string) error {
	if _agbd := _cefdb.Choice.ValidateWithPath(path + "\u002fChoice"); _agbd != nil {
		return _agbd
	}
	return nil
}

type CT_BarGrouping struct{ ValAttr ST_BarGrouping }

const (
	ST_TickLblPosUnset  ST_TickLblPos = 0
	ST_TickLblPosHigh   ST_TickLblPos = 1
	ST_TickLblPosLow    ST_TickLblPos = 2
	ST_TickLblPosNextTo ST_TickLblPos = 3
	ST_TickLblPosNone   ST_TickLblPos = 4
)

func (_adbga ST_CrossBetween) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_ddebe := _fa.Attr{}
	_ddebe.Name = name
	switch _adbga {
	case ST_CrossBetweenUnset:
		_ddebe.Value = ""
	case ST_CrossBetweenBetween:
		_ddebe.Value = "between"
	case ST_CrossBetweenMidCat:
		_ddebe.Value = "midCat"
	}
	return _ddebe, nil
}
func (_eebcd ST_BarGrouping) String() string {
	switch _eebcd {
	case 0:
		return ""
	case 1:
		return "percentStacked"
	case 2:
		return "clustered"
	case 3:
		return "standard"
	case 4:
		return "stacked"
	}
	return ""
}
func (_babce *ST_BubbleScale) ValidateWithPath(path string) error {
	_gbaeeg := []string{}
	if _babce.ST_BubbleScalePercent != nil {
		_gbaeeg = append(_gbaeeg, "ST_BubbleScalePercent")
	}
	if _babce.ST_BubbleScaleUInt != nil {
		_gbaeeg = append(_gbaeeg, "ST_BubbleScaleUInt")
	}
	if len(_gbaeeg) > 1 {
		return _gg.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _gbaeeg)
	}
	return nil
}
func (_ddagf ST_LegendPos) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_ebca := _fa.Attr{}
	_ebca.Name = name
	switch _ddagf {
	case ST_LegendPosUnset:
		_ebca.Value = ""
	case ST_LegendPosB:
		_ebca.Value = "b"
	case ST_LegendPosTr:
		_ebca.Value = "tr"
	case ST_LegendPosL:
		_ebca.Value = "l"
	case ST_LegendPosR:
		_ebca.Value = "r"
	case ST_LegendPosT:
		_ebca.Value = "t"
	}
	return _ebca, nil
}
func NewCT_Extension() *CT_Extension { _fafg := &CT_Extension{}; return _fafg }

type ST_LblAlgn byte

func (_gagf *CT_ManualLayout) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_edbd:
	for {
		_gbca, _gbbb := d.Token()
		if _gbbb != nil {
			return _gbbb
		}
		switch _dafe := _gbca.(type) {
		case _fa.StartElement:
			switch _dafe.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "layoutTarget"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "layoutTarget"}:
				_gagf.LayoutTarget = NewCT_LayoutTarget()
				if _cffaf := d.DecodeElement(_gagf.LayoutTarget, &_dafe); _cffaf != nil {
					return _cffaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "xMode"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "xMode"}:
				_gagf.XMode = NewCT_LayoutMode()
				if _dddg := d.DecodeElement(_gagf.XMode, &_dafe); _dddg != nil {
					return _dddg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "yMode"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "yMode"}:
				_gagf.YMode = NewCT_LayoutMode()
				if _dcdg := d.DecodeElement(_gagf.YMode, &_dafe); _dcdg != nil {
					return _dcdg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "wMode"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "wMode"}:
				_gagf.WMode = NewCT_LayoutMode()
				if _bfcg := d.DecodeElement(_gagf.WMode, &_dafe); _bfcg != nil {
					return _bfcg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "hMode"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "hMode"}:
				_gagf.HMode = NewCT_LayoutMode()
				if _gfgd := d.DecodeElement(_gagf.HMode, &_dafe); _gfgd != nil {
					return _gfgd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "x"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "x"}:
				_gagf.X = NewCT_Double()
				if _eeecf := d.DecodeElement(_gagf.X, &_dafe); _eeecf != nil {
					return _eeecf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "y"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "y"}:
				_gagf.Y = NewCT_Double()
				if _cfaa := d.DecodeElement(_gagf.Y, &_dafe); _cfaa != nil {
					return _cfaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "w"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "w"}:
				_gagf.W = NewCT_Double()
				if _eaacc := d.DecodeElement(_gagf.W, &_dafe); _eaacc != nil {
					return _eaacc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "h"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "h"}:
				_gagf.H = NewCT_Double()
				if _gfdg := d.DecodeElement(_gagf.H, &_dafe); _gfdg != nil {
					return _gfdg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_gagf.ExtLst = NewCT_ExtensionList()
				if _ddbc := d.DecodeElement(_gagf.ExtLst, &_dafe); _ddbc != nil {
					return _ddbc
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ManualLayout\u0020\u0025v", _dafe.Name)
				if _gdfa := d.Skip(); _gdfa != nil {
					return _gdfa
				}
			}
		case _fa.EndElement:
			break _edbd
		case _fa.CharData:
		}
	}
	return nil
}
func (_befg ST_PictureFormat) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_dedca := _fa.Attr{}
	_dedca.Name = name
	switch _befg {
	case ST_PictureFormatUnset:
		_dedca.Value = ""
	case ST_PictureFormatStretch:
		_dedca.Value = "stretch"
	case ST_PictureFormatStack:
		_dedca.Value = "stack"
	case ST_PictureFormatStackScale:
		_dedca.Value = "stackScale"
	}
	return _dedca, nil
}

// Validate validates the CT_LineChart and its children
func (_efffd *CT_LineChart) Validate() error { return _efffd.ValidateWithPath("CT_LineChart") }
func (_dccb *CT_OfPieChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_dccb.OfPieType = NewCT_OfPieType()
_ebefc:
	for {
		_bbbga, _egdc := d.Token()
		if _egdc != nil {
			return _egdc
		}
		switch _eeaa := _bbbga.(type) {
		case _fa.StartElement:
			switch _eeaa.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ofPieType"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ofPieType"}:
				if _cebc := d.DecodeElement(_dccb.OfPieType, &_eeaa); _cebc != nil {
					return _cebc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_dccb.VaryColors = NewCT_Boolean()
				if _ggdd := d.DecodeElement(_dccb.VaryColors, &_eeaa); _ggdd != nil {
					return _ggdd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_acfa := NewCT_PieSer()
				if _bbegc := d.DecodeElement(_acfa, &_eeaa); _bbegc != nil {
					return _bbegc
				}
				_dccb.Ser = append(_dccb.Ser, _acfa)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_dccb.DLbls = NewCT_DLbls()
				if _ffad := d.DecodeElement(_dccb.DLbls, &_eeaa); _ffad != nil {
					return _ffad
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "gapWidth"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "gapWidth"}:
				_dccb.GapWidth = NewCT_GapAmount()
				if _cdcee := d.DecodeElement(_dccb.GapWidth, &_eeaa); _cdcee != nil {
					return _cdcee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "splitType"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "splitType"}:
				_dccb.SplitType = NewCT_SplitType()
				if _ebeebe := d.DecodeElement(_dccb.SplitType, &_eeaa); _ebeebe != nil {
					return _ebeebe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "splitPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "splitPos"}:
				_dccb.SplitPos = NewCT_Double()
				if _aaggc := d.DecodeElement(_dccb.SplitPos, &_eeaa); _aaggc != nil {
					return _aaggc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "custSplit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "custSplit"}:
				_dccb.CustSplit = NewCT_CustSplit()
				if _fefa := d.DecodeElement(_dccb.CustSplit, &_eeaa); _fefa != nil {
					return _fefa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "secondPieSize"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "secondPieSize"}:
				_dccb.SecondPieSize = NewCT_SecondPieSize()
				if _eebaf := d.DecodeElement(_dccb.SecondPieSize, &_eeaa); _eebaf != nil {
					return _eebaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "serLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "serLines"}:
				_dgfgcd := NewCT_ChartLines()
				if _bfaa := d.DecodeElement(_dgfgcd, &_eeaa); _bfaa != nil {
					return _bfaa
				}
				_dccb.SerLines = append(_dccb.SerLines, _dgfgcd)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_dccb.ExtLst = NewCT_ExtensionList()
				if _ddef := d.DecodeElement(_dccb.ExtLst, &_eeaa); _ddef != nil {
					return _ddef
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_OfPieChart \u0025v", _eeaa.Name)
				if _cbeec := d.Skip(); _cbeec != nil {
					return _cbeec
				}
			}
		case _fa.EndElement:
			break _ebefc
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_LegendPos and its children
func (_efecd *CT_LegendPos) Validate() error { return _efecd.ValidateWithPath("CT_LegendPos") }

type CT_TrendlineLbl struct {
	Layout *CT_Layout
	Tx     *CT_Tx
	NumFmt *CT_NumFmt
	SpPr   *_cb.CT_ShapeProperties
	TxPr   *_cb.CT_TextBody
	ExtLst *CT_ExtensionList
}

func (_ddgaag *ST_OfPieType) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bfabd, _cfcdb := d.Token()
	if _cfcdb != nil {
		return _cfcdb
	}
	if _bcfce, _deedb := _bfabd.(_fa.EndElement); _deedb && _bcfce.Name == start.Name {
		*_ddgaag = 1
		return nil
	}
	if _acdef, _bbcag := _bfabd.(_fa.CharData); !_bbcag {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bfabd)
	} else {
		switch string(_acdef) {
		case "":
			*_ddgaag = 0
		case "pie":
			*_ddgaag = 1
		case "bar":
			*_ddgaag = 2
		}
	}
	_bfabd, _cfcdb = d.Token()
	if _cfcdb != nil {
		return _cfcdb
	}
	if _bbcac, _cabbe := _bfabd.(_fa.EndElement); _cabbe && _bbcac.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bfabd)
}

type ST_ErrBarType byte

func (_gffa *CT_ErrBars) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_gffa.ErrBarType = NewCT_ErrBarType()
	_gffa.ErrValType = NewCT_ErrValType()
_ggbd:
	for {
		_fced, _feddb := d.Token()
		if _feddb != nil {
			return _feddb
		}
		switch _cgda := _fced.(type) {
		case _fa.StartElement:
			switch _cgda.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "errDir"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "errDir"}:
				_gffa.ErrDir = NewCT_ErrDir()
				if _gfeaa := d.DecodeElement(_gffa.ErrDir, &_cgda); _gfeaa != nil {
					return _gfeaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "errBarType"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "errBarType"}:
				if _fdaa := d.DecodeElement(_gffa.ErrBarType, &_cgda); _fdaa != nil {
					return _fdaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "errValType"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "errValType"}:
				if _fgaeg := d.DecodeElement(_gffa.ErrValType, &_cgda); _fgaeg != nil {
					return _fgaeg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "noEndCap"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "noEndCap"}:
				_gffa.NoEndCap = NewCT_Boolean()
				if _aeee := d.DecodeElement(_gffa.NoEndCap, &_cgda); _aeee != nil {
					return _aeee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "plus"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "plus"}:
				_gffa.Plus = NewCT_NumDataSource()
				if _bdddc := d.DecodeElement(_gffa.Plus, &_cgda); _bdddc != nil {
					return _bdddc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minus"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minus"}:
				_gffa.Minus = NewCT_NumDataSource()
				if _gdfba := d.DecodeElement(_gffa.Minus, &_cgda); _gdfba != nil {
					return _gdfba
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "val"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "val"}:
				_gffa.Val = NewCT_Double()
				if _cbec := d.DecodeElement(_gffa.Val, &_cgda); _cbec != nil {
					return _cbec
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_gffa.SpPr = _cb.NewCT_ShapeProperties()
				if _ddca := d.DecodeElement(_gffa.SpPr, &_cgda); _ddca != nil {
					return _ddca
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_gffa.ExtLst = NewCT_ExtensionList()
				if _dbggg := d.DecodeElement(_gffa.ExtLst, &_cgda); _dbggg != nil {
					return _dbggg
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_ErrBars\u0020\u0025v", _cgda.Name)
				if _cefg := d.Skip(); _cefg != nil {
					return _cefg
				}
			}
		case _fa.EndElement:
			break _ggbd
		case _fa.CharData:
		}
	}
	return nil
}
func (_ggef *CT_AxDataSourceChoice) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_fbd:
	for {
		_cba, _cdd := d.Token()
		if _cdd != nil {
			return _cdd
		}
		switch _fee := _cba.(type) {
		case _fa.StartElement:
			switch _fee.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "multiLvlStrRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "multiLvlStrRef"}:
				_ggef.MultiLvlStrRef = NewCT_MultiLvlStrRef()
				if _aag := d.DecodeElement(_ggef.MultiLvlStrRef, &_fee); _aag != nil {
					return _aag
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numRef"}:
				_ggef.NumRef = NewCT_NumRef()
				if _fdac := d.DecodeElement(_ggef.NumRef, &_fee); _fdac != nil {
					return _fdac
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numLit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numLit"}:
				_ggef.NumLit = NewCT_NumData()
				if _ced := d.DecodeElement(_ggef.NumLit, &_fee); _ced != nil {
					return _ced
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "strRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "strRef"}:
				_ggef.StrRef = NewCT_StrRef()
				if _bcg := d.DecodeElement(_ggef.StrRef, &_fee); _bcg != nil {
					return _bcg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "strLit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "strLit"}:
				_ggef.StrLit = NewCT_StrData()
				if _agc := d.DecodeElement(_ggef.StrLit, &_fee); _agc != nil {
					return _agc
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on CT_AxDataSourceChoice\u0020\u0025v", _fee.Name)
				if _age := d.Skip(); _age != nil {
					return _age
				}
			}
		case _fa.EndElement:
			break _fbd
		case _fa.CharData:
		}
	}
	return nil
}
func (_gfebad *CT_HeaderFooter) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _cdaa := range start.Attr {
		if _cdaa.Name.Local == "alignWithMargins" {
			_bede, _dafc := _c.ParseBool(_cdaa.Value)
			if _dafc != nil {
				return _dafc
			}
			_gfebad.AlignWithMarginsAttr = &_bede
			continue
		}
		if _cdaa.Name.Local == "differentOddEven" {
			_feef, _dgab := _c.ParseBool(_cdaa.Value)
			if _dgab != nil {
				return _dgab
			}
			_gfebad.DifferentOddEvenAttr = &_feef
			continue
		}
		if _cdaa.Name.Local == "differentFirst" {
			_aggb, _bebce := _c.ParseBool(_cdaa.Value)
			if _bebce != nil {
				return _bebce
			}
			_gfebad.DifferentFirstAttr = &_aggb
			continue
		}
	}
_dgeab:
	for {
		_dbag, _efad := d.Token()
		if _efad != nil {
			return _efad
		}
		switch _fcedg := _dbag.(type) {
		case _fa.StartElement:
			switch _fcedg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "oddHeader"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "oddHeader"}:
				_gfebad.OddHeader = new(string)
				if _baffe := d.DecodeElement(_gfebad.OddHeader, &_fcedg); _baffe != nil {
					return _baffe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "oddFooter"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "oddFooter"}:
				_gfebad.OddFooter = new(string)
				if _acge := d.DecodeElement(_gfebad.OddFooter, &_fcedg); _acge != nil {
					return _acge
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "evenHeader"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "evenHeader"}:
				_gfebad.EvenHeader = new(string)
				if _ggfaa := d.DecodeElement(_gfebad.EvenHeader, &_fcedg); _ggfaa != nil {
					return _ggfaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "evenFooter"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "evenFooter"}:
				_gfebad.EvenFooter = new(string)
				if _abaaa := d.DecodeElement(_gfebad.EvenFooter, &_fcedg); _abaaa != nil {
					return _abaaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "firstHeader"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "firstHeader"}:
				_gfebad.FirstHeader = new(string)
				if _gbfe := d.DecodeElement(_gfebad.FirstHeader, &_fcedg); _gbfe != nil {
					return _gbfe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "firstFooter"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "firstFooter"}:
				_gfebad.FirstFooter = new(string)
				if _dbccd := d.DecodeElement(_gfebad.FirstFooter, &_fcedg); _dbccd != nil {
					return _dbccd
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_HeaderFooter\u0020\u0025v", _fcedg.Name)
				if _dfgc := d.Skip(); _dfgc != nil {
					return _dfgc
				}
			}
		case _fa.EndElement:
			break _dgeab
		case _fa.CharData:
		}
	}
	return nil
}
func (_dgafb *ST_Shape) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_dgafb = 0
	case "cone":
		*_dgafb = 1
	case "coneToMax":
		*_dgafb = 2
	case "box":
		*_dgafb = 3
	case "cylinder":
		*_dgafb = 4
	case "pyramid":
		*_dgafb = 5
	case "pyramidToMax":
		*_dgafb = 6
	}
	return nil
}
func NewCT_SurfaceSer() *CT_SurfaceSer {
	_ecaf := &CT_SurfaceSer{}
	_ecaf.Idx = NewCT_UnsignedInt()
	_ecaf.Order = NewCT_UnsignedInt()
	return _ecaf
}

type EG_SerShared struct {
	Idx   *CT_UnsignedInt
	Order *CT_UnsignedInt
	Tx    *CT_SerTx
	SpPr  *_cb.CT_ShapeProperties
}
type CT_PlotAreaChoice1 struct {
	ValAx  []*CT_ValAx
	CatAx  []*CT_CatAx
	DateAx []*CT_DateAx
	SerAx  []*CT_SerAx
}

func (_cadb *CT_BarSer) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_dfbd := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_cadb.Idx, _dfbd)
	_agfa := _fa.StartElement{Name: _fa.Name{Local: "c:order"}}
	e.EncodeElement(_cadb.Order, _agfa)
	if _cadb.Tx != nil {
		_fea := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_cadb.Tx, _fea)
	}
	if _cadb.SpPr != nil {
		_cbac := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_cadb.SpPr, _cbac)
	}
	if _cadb.InvertIfNegative != nil {
		_afa := _fa.StartElement{Name: _fa.Name{Local: "c:invertIfNegative"}}
		e.EncodeElement(_cadb.InvertIfNegative, _afa)
	}
	if _cadb.PictureOptions != nil {
		_geab := _fa.StartElement{Name: _fa.Name{Local: "c:pictureOptions"}}
		e.EncodeElement(_cadb.PictureOptions, _geab)
	}
	if _cadb.DPt != nil {
		_efa := _fa.StartElement{Name: _fa.Name{Local: "c:dPt"}}
		for _, _bbf := range _cadb.DPt {
			e.EncodeElement(_bbf, _efa)
		}
	}
	if _cadb.DLbls != nil {
		_daf := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_cadb.DLbls, _daf)
	}
	if _cadb.Trendline != nil {
		_bgef := _fa.StartElement{Name: _fa.Name{Local: "c:trendline"}}
		for _, _ebge := range _cadb.Trendline {
			e.EncodeElement(_ebge, _bgef)
		}
	}
	if _cadb.ErrBars != nil {
		_gafg := _fa.StartElement{Name: _fa.Name{Local: "c:errBars"}}
		e.EncodeElement(_cadb.ErrBars, _gafg)
	}
	if _cadb.Cat != nil {
		_caga := _fa.StartElement{Name: _fa.Name{Local: "c:cat"}}
		e.EncodeElement(_cadb.Cat, _caga)
	}
	if _cadb.Val != nil {
		_ddga := _fa.StartElement{Name: _fa.Name{Local: "c:val"}}
		e.EncodeElement(_cadb.Val, _ddga)
	}
	if _cadb.Shape != nil {
		_efcd := _fa.StartElement{Name: _fa.Name{Local: "c:shape"}}
		e.EncodeElement(_cadb.Shape, _efcd)
	}
	if _cadb.ExtLst != nil {
		_gffb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_cadb.ExtLst, _gffb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_cead *CT_Grouping) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _bbff := range start.Attr {
		if _bbff.Name.Local == "val" {
			_cead.ValAttr.UnmarshalXMLAttr(_bbff)
			continue
		}
	}
	for {
		_bcab, _acbd := d.Token()
		if _acbd != nil {
			return _gg.Errorf("parsing\u0020CT_Grouping:\u0020\u0025s", _acbd)
		}
		if _bbdcb, _eccd := _bcab.(_fa.EndElement); _eccd && _bbdcb.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SerTxChoice and its children, prefixing error messages with path
func (_fedfa *CT_SerTxChoice) ValidateWithPath(path string) error {
	if _fedfa.StrRef != nil {
		if _gbfgf := _fedfa.StrRef.ValidateWithPath(path + "\u002fStrRef"); _gbfgf != nil {
			return _gbfgf
		}
	}
	return nil
}

// Validate validates the CT_Thickness and its children
func (_cbcbc *CT_Thickness) Validate() error { return _cbcbc.ValidateWithPath("CT_Thickness") }
func (_eaaaa ST_TickLblPos) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_geeeg := _fa.Attr{}
	_geeeg.Name = name
	switch _eaaaa {
	case ST_TickLblPosUnset:
		_geeeg.Value = ""
	case ST_TickLblPosHigh:
		_geeeg.Value = "high"
	case ST_TickLblPosLow:
		_geeeg.Value = "low"
	case ST_TickLblPosNextTo:
		_geeeg.Value = "nextTo"
	case ST_TickLblPosNone:
		_geeeg.Value = "none"
	}
	return _geeeg, nil
}
func (_dbeda *CT_Pie3DChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_eagaa:
	for {
		_ddbcf, _gccc := d.Token()
		if _gccc != nil {
			return _gccc
		}
		switch _acce := _ddbcf.(type) {
		case _fa.StartElement:
			switch _acce.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_dbeda.VaryColors = NewCT_Boolean()
				if _gdfc := d.DecodeElement(_dbeda.VaryColors, &_acce); _gdfc != nil {
					return _gdfc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_fdebf := NewCT_PieSer()
				if _aafcab := d.DecodeElement(_fdebf, &_acce); _aafcab != nil {
					return _aafcab
				}
				_dbeda.Ser = append(_dbeda.Ser, _fdebf)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_dbeda.DLbls = NewCT_DLbls()
				if _fbccf := d.DecodeElement(_dbeda.DLbls, &_acce); _fbccf != nil {
					return _fbccf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_dbeda.ExtLst = NewCT_ExtensionList()
				if _egcde := d.DecodeElement(_dbeda.ExtLst, &_acce); _egcde != nil {
					return _egcde
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_Pie3DChart \u0025v", _acce.Name)
				if _adggc := d.Skip(); _adggc != nil {
					return _adggc
				}
			}
		case _fa.EndElement:
			break _eagaa
		case _fa.CharData:
		}
	}
	return nil
}
func NewCT_UpDownBars() *CT_UpDownBars { _dfdf := &CT_UpDownBars{}; return _dfdf }
func NewCT_BarSer() *CT_BarSer {
	_ecc := &CT_BarSer{}
	_ecc.Idx = NewCT_UnsignedInt()
	_ecc.Order = NewCT_UnsignedInt()
	return _ecc
}

type ST_BarDir byte

func (_agfc *EG_AxSharedChoice) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_deegb:
	for {
		_cfcebc, _cfcbd := d.Token()
		if _cfcbd != nil {
			return _cfcbd
		}
		switch _dfabc := _cfcebc.(type) {
		case _fa.StartElement:
			switch _dfabc.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crosses"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crosses"}:
				_agfc.Crosses = NewCT_Crosses()
				if _deab := d.DecodeElement(_agfc.Crosses, &_dfabc); _deab != nil {
					return _deab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossesAt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossesAt"}:
				_agfc.CrossesAt = NewCT_Double()
				if _dggae := d.DecodeElement(_agfc.CrossesAt, &_dfabc); _dggae != nil {
					return _dggae
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020EG_AxSharedChoice\u0020\u0025v", _dfabc.Name)
				if _adfe := d.Skip(); _adfe != nil {
					return _adfe
				}
			}
		case _fa.EndElement:
			break _deegb
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the EG_SurfaceChartShared and its children, prefixing error messages with path
func (_acged *EG_SurfaceChartShared) ValidateWithPath(path string) error {
	if _acged.Wireframe != nil {
		if _ebcfb := _acged.Wireframe.ValidateWithPath(path + "\u002fWireframe"); _ebcfb != nil {
			return _ebcfb
		}
	}
	for _bggcf, _afgbd := range _acged.Ser {
		if _fcgca := _afgbd.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _bggcf)); _fcgca != nil {
			return _fcgca
		}
	}
	if _acged.BandFmts != nil {
		if _dcff := _acged.BandFmts.ValidateWithPath(path + "\u002fBandFmts"); _dcff != nil {
			return _dcff
		}
	}
	return nil
}
func (_fcdabb ST_LegendPos) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_fcdabb.String(), start)
}
func (_caacdc *CT_TrendlineType) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _caacdc.ValAttr != ST_TrendlineTypeUnset {
		_aagfbd, _fcbec := _caacdc.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _fcbec != nil {
			return _fcbec
		}
		start.Attr = append(start.Attr, _aagfbd)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_afedb ST_HoleSize) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _afedb.ST_HoleSizePercent != nil {
		e.EncodeToken(_fa.CharData(*_afedb.ST_HoleSizePercent))
	}
	if _afedb.ST_HoleSizeUByte != nil {
		e.EncodeToken(_fa.CharData(_gg.Sprintf("\u0025d", *_afedb.ST_HoleSizeUByte)))
	}
	return e.EncodeToken(_fa.EndElement{Name: start.Name})
}

// Validate validates the CT_MarkerStyle and its children
func (_aefge *CT_MarkerStyle) Validate() error { return _aefge.ValidateWithPath("CT_MarkerStyle") }

// ValidateWithPath validates the CT_PivotFmt and its children, prefixing error messages with path
func (_cace *CT_PivotFmt) ValidateWithPath(path string) error {
	if _faee := _cace.Idx.ValidateWithPath(path + "\u002fIdx"); _faee != nil {
		return _faee
	}
	if _cace.SpPr != nil {
		if _gfbdd := _cace.SpPr.ValidateWithPath(path + "\u002fSpPr"); _gfbdd != nil {
			return _gfbdd
		}
	}
	if _cace.TxPr != nil {
		if _dcegf := _cace.TxPr.ValidateWithPath(path + "\u002fTxPr"); _dcegf != nil {
			return _dcegf
		}
	}
	if _cace.Marker != nil {
		if _fgga := _cace.Marker.ValidateWithPath(path + "\u002fMarker"); _fgga != nil {
			return _fgga
		}
	}
	if _cace.DLbl != nil {
		if _bbcb := _cace.DLbl.ValidateWithPath(path + "\u002fDLbl"); _bbcb != nil {
			return _bbcb
		}
	}
	if _cace.ExtLst != nil {
		if _ccdd := _cace.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ccdd != nil {
			return _ccdd
		}
	}
	return nil
}
func (_edddg *ST_AxPos) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ccfab, _fedbdb := d.Token()
	if _fedbdb != nil {
		return _fedbdb
	}
	if _fecfb, _egcad := _ccfab.(_fa.EndElement); _egcad && _fecfb.Name == start.Name {
		*_edddg = 1
		return nil
	}
	if _ddeea, _egbbc := _ccfab.(_fa.CharData); !_egbbc {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ccfab)
	} else {
		switch string(_ddeea) {
		case "":
			*_edddg = 0
		case "b":
			*_edddg = 1
		case "l":
			*_edddg = 2
		case "r":
			*_edddg = 3
		case "t":
			*_edddg = 4
		}
	}
	_ccfab, _fedbdb = d.Token()
	if _fedbdb != nil {
		return _fedbdb
	}
	if _cfccd, _ggfaac := _ccfab.(_fa.EndElement); _ggfaac && _cfccd.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ccfab)
}
func (_afega *CT_RotY) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _gagbg := range start.Attr {
		if _gagbg.Name.Local == "val" {
			_bbdd, _ccbcgd := _c.ParseUint(_gagbg.Value, 10, 16)
			if _ccbcgd != nil {
				return _ccbcgd
			}
			_efgd := uint16(_bbdd)
			_afega.ValAttr = &_efgd
			continue
		}
	}
	for {
		_cdcae, _gefde := d.Token()
		if _gefde != nil {
			return _gg.Errorf("parsing\u0020CT_RotY:\u0020\u0025s", _gefde)
		}
		if _ebbbe, _fagc := _cdcae.(_fa.EndElement); _fagc && _ebbbe.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_MultiLvlStrRef() *CT_MultiLvlStrRef { _edcgg := &CT_MultiLvlStrRef{}; return _edcgg }
func (_agec *ST_TickMark) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_edcee, _geggce := d.Token()
	if _geggce != nil {
		return _geggce
	}
	if _ggfc, _bdgce := _edcee.(_fa.EndElement); _bdgce && _ggfc.Name == start.Name {
		*_agec = 1
		return nil
	}
	if _dbbeg, _cdabfg := _edcee.(_fa.CharData); !_cdabfg {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _edcee)
	} else {
		switch string(_dbbeg) {
		case "":
			*_agec = 0
		case "cross":
			*_agec = 1
		case "in":
			*_agec = 2
		case "none":
			*_agec = 3
		case "out":
			*_agec = 4
		}
	}
	_edcee, _geggce = d.Token()
	if _geggce != nil {
		return _geggce
	}
	if _gbbdb, _ddcda := _edcee.(_fa.EndElement); _ddcda && _gbbdb.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _edcee)
}
func (_efabc ST_LblAlgn) Validate() error { return _efabc.ValidateWithPath("") }
func (_gfdc *CT_ExternalData) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "r:id"}, Value: _gg.Sprintf("\u0025v", _gfdc.IdAttr)})
	e.EncodeToken(start)
	if _gfdc.AutoUpdate != nil {
		_cegfg := _fa.StartElement{Name: _fa.Name{Local: "c:autoUpdate"}}
		e.EncodeElement(_gfdc.AutoUpdate, _cegfg)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_edggg *CT_LineChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_eadb := _fa.StartElement{Name: _fa.Name{Local: "c:grouping"}}
	e.EncodeElement(_edggg.Grouping, _eadb)
	if _edggg.VaryColors != nil {
		_gfcd := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_edggg.VaryColors, _gfcd)
	}
	if _edggg.Ser != nil {
		_debgd := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _abgd := range _edggg.Ser {
			e.EncodeElement(_abgd, _debgd)
		}
	}
	if _edggg.DLbls != nil {
		_badf := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_edggg.DLbls, _badf)
	}
	if _edggg.DropLines != nil {
		_becfb := _fa.StartElement{Name: _fa.Name{Local: "c:dropLines"}}
		e.EncodeElement(_edggg.DropLines, _becfb)
	}
	if _edggg.HiLowLines != nil {
		_abbeaa := _fa.StartElement{Name: _fa.Name{Local: "c:hiLowLines"}}
		e.EncodeElement(_edggg.HiLowLines, _abbeaa)
	}
	if _edggg.UpDownBars != nil {
		_agcc := _fa.StartElement{Name: _fa.Name{Local: "c:upDownBars"}}
		e.EncodeElement(_edggg.UpDownBars, _agcc)
	}
	if _edggg.Marker != nil {
		_abdag := _fa.StartElement{Name: _fa.Name{Local: "c:marker"}}
		e.EncodeElement(_edggg.Marker, _abdag)
	}
	if _edggg.Smooth != nil {
		_beba := _fa.StartElement{Name: _fa.Name{Local: "c:smooth"}}
		e.EncodeElement(_edggg.Smooth, _beba)
	}
	_eaaeg := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _dbbfc := range _edggg.AxId {
		e.EncodeElement(_dbbfc, _eaaeg)
	}
	if _edggg.ExtLst != nil {
		_gcae := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_edggg.ExtLst, _gcae)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_ScatterChart and its children
func (_eefag *CT_ScatterChart) Validate() error { return _eefag.ValidateWithPath("CT_ScatterChart") }

// ST_GapAmount is a union type
type ST_GapAmount struct {
	ST_GapAmountPercent *string
	ST_GapAmountUShort  *uint16
}

// ValidateWithPath validates the CT_ExtensionList and its children, prefixing error messages with path
func (_bagdg *CT_ExtensionList) ValidateWithPath(path string) error {
	for _ecaaf, _eaac := range _bagdg.Ext {
		if _ecda := _eaac.ValidateWithPath(_gg.Sprintf("\u0025s\u002fExt\u005b\u0025d\u005d", path, _ecaaf)); _ecda != nil {
			return _ecda
		}
	}
	return nil
}
func (_ddfc *CT_BarDir) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _eeba := range start.Attr {
		if _eeba.Name.Local == "val" {
			_ddfc.ValAttr.UnmarshalXMLAttr(_eeba)
			continue
		}
	}
	for {
		_cag, _gce := d.Token()
		if _gce != nil {
			return _gg.Errorf("parsing\u0020CT_BarDir:\u0020\u0025s", _gce)
		}
		if _ebf, _gbef := _cag.(_fa.EndElement); _gbef && _ebf.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_AxisUnit struct{ ValAttr float64 }

// Validate validates the CT_LineSer and its children
func (_ddge *CT_LineSer) Validate() error { return _ddge.ValidateWithPath("CT_LineSer") }

// ValidateWithPath validates the CT_Boolean and its children, prefixing error messages with path
func (_fbcc *CT_Boolean) ValidateWithPath(path string) error { return nil }
func (_bfade ST_DLblPos) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_bfade.String(), start)
}
func (_cefga *CT_PivotFmt) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_cefga.Idx = NewCT_UnsignedInt()
_gabfd:
	for {
		_bcefg, _feadd := d.Token()
		if _feadd != nil {
			return _feadd
		}
		switch _abbeb := _bcefg.(type) {
		case _fa.StartElement:
			switch _abbeb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _gdfe := d.DecodeElement(_cefga.Idx, &_abbeb); _gdfe != nil {
					return _gdfe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_cefga.SpPr = _cb.NewCT_ShapeProperties()
				if _cfgc := d.DecodeElement(_cefga.SpPr, &_abbeb); _cfgc != nil {
					return _cfgc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_cefga.TxPr = _cb.NewCT_TextBody()
				if _bfab := d.DecodeElement(_cefga.TxPr, &_abbeb); _bfab != nil {
					return _bfab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "marker"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "marker"}:
				_cefga.Marker = NewCT_Marker()
				if _faede := d.DecodeElement(_cefga.Marker, &_abbeb); _faede != nil {
					return _faede
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbl"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbl"}:
				_cefga.DLbl = NewCT_DLbl()
				if _cefcf := d.DecodeElement(_cefga.DLbl, &_abbeb); _cefcf != nil {
					return _cefcf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_cefga.ExtLst = NewCT_ExtensionList()
				if _aadf := d.DecodeElement(_cefga.ExtLst, &_abbeb); _aadf != nil {
					return _aadf
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PivotFmt\u0020\u0025v", _abbeb.Name)
				if _dedgdf := d.Skip(); _dedgdf != nil {
					return _dedgdf
				}
			}
		case _fa.EndElement:
			break _gabfd
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_NumData and its children
func (_gdcgf *CT_NumData) Validate() error { return _gdcgf.ValidateWithPath("CT_NumData") }

// Validate validates the CT_SurfaceSer and its children
func (_gaae *CT_SurfaceSer) Validate() error { return _gaae.ValidateWithPath("CT_SurfaceSer") }
func (_ggcc *CT_CustSplit) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_gdeg:
	for {
		_ddeg, _dcdfc := d.Token()
		if _dcdfc != nil {
			return _dcdfc
		}
		switch _fbef := _ddeg.(type) {
		case _fa.StartElement:
			switch _fbef.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "secondPiePt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "secondPiePt"}:
				_gggdg := NewCT_UnsignedInt()
				if _deda := d.DecodeElement(_gggdg, &_fbef); _deda != nil {
					return _deda
				}
				_ggcc.SecondPiePt = append(_ggcc.SecondPiePt, _gggdg)
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CustSplit\u0020\u0025v", _fbef.Name)
				if _bbdag := d.Skip(); _bbdag != nil {
					return _bbdag
				}
			}
		case _fa.EndElement:
			break _gdeg
		case _fa.CharData:
		}
	}
	return nil
}

type Chart struct{ CT_RelId }

func (_fbae ST_DepthPercent) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _fbae.ST_DepthPercentWithSymbol != nil {
		e.EncodeToken(_fa.CharData(*_fbae.ST_DepthPercentWithSymbol))
	}
	if _fbae.ST_DepthPercentUShort != nil {
		e.EncodeToken(_fa.CharData(_gg.Sprintf("\u0025d", *_fbae.ST_DepthPercentUShort)))
	}
	return e.EncodeToken(_fa.EndElement{Name: start.Name})
}

// ValidateWithPath validates the CT_Protection and its children, prefixing error messages with path
func (_bcae *CT_Protection) ValidateWithPath(path string) error {
	if _bcae.ChartObject != nil {
		if _dfde := _bcae.ChartObject.ValidateWithPath(path + "\u002fChartObject"); _dfde != nil {
			return _dfde
		}
	}
	if _bcae.Data != nil {
		if _ccae := _bcae.Data.ValidateWithPath(path + "\u002fData"); _ccae != nil {
			return _ccae
		}
	}
	if _bcae.Formatting != nil {
		if _bedb := _bcae.Formatting.ValidateWithPath(path + "/Formatting"); _bedb != nil {
			return _bedb
		}
	}
	if _bcae.Selection != nil {
		if _dcdgg := _bcae.Selection.ValidateWithPath(path + "\u002fSelection"); _dcdgg != nil {
			return _dcdgg
		}
	}
	if _bcae.UserInterface != nil {
		if _baae := _bcae.UserInterface.ValidateWithPath(path + "\u002fUserInterface"); _baae != nil {
			return _baae
		}
	}
	return nil
}
func (_eabee *CT_LogBase) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", _eabee.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_RelId and its children, prefixing error messages with path
func (_edfde *CT_RelId) ValidateWithPath(path string) error { return nil }
func NewCT_ErrBarType() *CT_ErrBarType                      { _egdg := &CT_ErrBarType{}; return _egdg }
func (_baabg *CT_LblAlgn) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_baabg.ValAttr = ST_LblAlgn(1)
	for _, _cabec := range start.Attr {
		if _cabec.Name.Local == "val" {
			_baabg.ValAttr.UnmarshalXMLAttr(_cabec)
			continue
		}
	}
	for {
		_cdbd, _aefaa := d.Token()
		if _aefaa != nil {
			return _gg.Errorf("parsing\u0020CT_LblAlgn:\u0020%s", _aefaa)
		}
		if _cgac, _feaa := _cdbd.(_fa.EndElement); _feaa && _cgac.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cbbfea ST_PictureFormat) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_cbbfea.String(), start)
}
func (_bgdag ST_SplitType) String() string {
	switch _bgdag {
	case 0:
		return ""
	case 1:
		return "auto"
	case 2:
		return "cust"
	case 3:
		return "percent"
	case 4:
		return "pos"
	case 5:
		return "val"
	}
	return ""
}
func (_cfcb *CT_ErrValType) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _cfcb.ValAttr != ST_ErrValTypeUnset {
		_cbce, _gdgf := _cfcb.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _gdgf != nil {
			return _gdgf
		}
		start.Attr = append(start.Attr, _cbce)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Scaling and its children
func (_gdgfa *CT_Scaling) Validate() error { return _gdgfa.ValidateWithPath("CT_Scaling") }

// Validate validates the CT_CatAx and its children
func (_ffb *CT_CatAx) Validate() error { return _ffb.ValidateWithPath("CT_CatAx") }

// Validate validates the CT_DLbls and its children
func (_ddab *CT_DLbls) Validate() error { return _ddab.ValidateWithPath("CT_DLbls") }

// ValidateWithPath validates the CT_TrendlineType and its children, prefixing error messages with path
func (_caccf *CT_TrendlineType) ValidateWithPath(path string) error {
	if _aaggb := _caccf.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _aaggb != nil {
		return _aaggb
	}
	return nil
}

// ValidateWithPath validates the CT_Order and its children, prefixing error messages with path
func (_fdgc *CT_Order) ValidateWithPath(path string) error {
	if _fdgc.ValAttr != nil {
		if *_fdgc.ValAttr < 2 {
			return _gg.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00202\u0020\u0028have\u0020\u0025v\u0029", path, *_fdgc.ValAttr)
		}
		if *_fdgc.ValAttr > 6 {
			return _gg.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003c=\u00206\u0020\u0028have\u0020\u0025v\u0029", path, *_fdgc.ValAttr)
		}
	}
	return nil
}
func (_fcdg *CT_RotX) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _fcdg.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_fcdg.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_LblOffset() *CT_LblOffset { _facd := &CT_LblOffset{}; return _facd }

// ValidateWithPath validates the CT_ErrBars and its children, prefixing error messages with path
func (_adb *CT_ErrBars) ValidateWithPath(path string) error {
	if _adb.ErrDir != nil {
		if _dbgd := _adb.ErrDir.ValidateWithPath(path + "\u002fErrDir"); _dbgd != nil {
			return _dbgd
		}
	}
	if _gfagg := _adb.ErrBarType.ValidateWithPath(path + "/ErrBarType"); _gfagg != nil {
		return _gfagg
	}
	if _agfgg := _adb.ErrValType.ValidateWithPath(path + "/ErrValType"); _agfgg != nil {
		return _agfgg
	}
	if _adb.NoEndCap != nil {
		if _edcg := _adb.NoEndCap.ValidateWithPath(path + "\u002fNoEndCap"); _edcg != nil {
			return _edcg
		}
	}
	if _adb.Plus != nil {
		if _efb := _adb.Plus.ValidateWithPath(path + "\u002fPlus"); _efb != nil {
			return _efb
		}
	}
	if _adb.Minus != nil {
		if _eedc := _adb.Minus.ValidateWithPath(path + "\u002fMinus"); _eedc != nil {
			return _eedc
		}
	}
	if _adb.Val != nil {
		if _eaga := _adb.Val.ValidateWithPath(path + "\u002fVal"); _eaga != nil {
			return _eaga
		}
	}
	if _adb.SpPr != nil {
		if _cca := _adb.SpPr.ValidateWithPath(path + "\u002fSpPr"); _cca != nil {
			return _cca
		}
	}
	if _adb.ExtLst != nil {
		if _dcbc := _adb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dcbc != nil {
			return _dcbc
		}
	}
	return nil
}
func (_eeea *CT_ErrValType) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _cbcd := range start.Attr {
		if _cbcd.Name.Local == "val" {
			_eeea.ValAttr.UnmarshalXMLAttr(_cbcd)
			continue
		}
	}
	for {
		_fbec, _caag := d.Token()
		if _caag != nil {
			return _gg.Errorf("parsing\u0020CT_ErrValType:\u0020\u0025s", _caag)
		}
		if _dbcc, _fccf := _fbec.(_fa.EndElement); _fccf && _dbcc.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_AxisUnit and its children, prefixing error messages with path
func (_gbcf *CT_AxisUnit) ValidateWithPath(path string) error {
	if _gbcf.ValAttr <= 0 {
		return _gg.Errorf("\u0025s\u002fm.ValAttr\u0020must\u0020be \u003e\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _gbcf.ValAttr)
	}
	return nil
}
func NewCT_PivotSource() *CT_PivotSource {
	_ebdae := &CT_PivotSource{}
	_ebdae.FmtId = NewCT_UnsignedInt()
	return _ebdae
}
func (_gfgdg ST_Orientation) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_gfgdg.String(), start)
}

type CT_CustSplit struct{ SecondPiePt []*CT_UnsignedInt }
type CT_DepthPercent struct{ ValAttr *ST_DepthPercent }

func NewCT_DepthPercent() *CT_DepthPercent { _ccbd := &CT_DepthPercent{}; return _ccbd }
func NewCT_StockChart() *CT_StockChart     { _cbcda := &CT_StockChart{}; return _cbcda }
func NewCT_Order() *CT_Order               { _dcafb := &CT_Order{}; return _dcafb }

type CT_DispBlanksAs struct{ ValAttr ST_DispBlanksAs }

func (_bfgc ST_RadarStyle) Validate() error { return _bfgc.ValidateWithPath("") }
func (_acda ST_SecondPieSize) String() string {
	if _acda.ST_SecondPieSizePercent != nil {
		return _gg.Sprintf("\u0025v", *_acda.ST_SecondPieSizePercent)
	}
	if _acda.ST_SecondPieSizeUShort != nil {
		return _gg.Sprintf("\u0025v", *_acda.ST_SecondPieSizeUShort)
	}
	return ""
}

// ValidateWithPath validates the CT_AxDataSource and its children, prefixing error messages with path
func (_bbd *CT_AxDataSource) ValidateWithPath(path string) error {
	if _dae := _bbd.Choice.ValidateWithPath(path + "\u002fChoice"); _dae != nil {
		return _dae
	}
	return nil
}

type CT_ErrValType struct{ ValAttr ST_ErrValType }

func (_dfbdg *CT_DLbls) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _dfbdg.DLbl != nil {
		_eedd := _fa.StartElement{Name: _fa.Name{Local: "c:dLbl"}}
		for _, _bccbg := range _dfbdg.DLbl {
			e.EncodeElement(_bccbg, _eedd)
		}
	}
	if _dfbdg.Choice != nil {
		_dfbdg.Choice.MarshalXML(e, _fa.StartElement{})
	}
	if _dfbdg.ExtLst != nil {
		_cfeeg := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_dfbdg.ExtLst, _cfeeg)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewEG_LineChartShared() *EG_LineChartShared {
	_fgeeg := &EG_LineChartShared{}
	_fgeeg.Grouping = NewCT_Grouping()
	return _fgeeg
}
func NewCT_DispUnitsLbl() *CT_DispUnitsLbl { _baad := &CT_DispUnitsLbl{}; return _baad }
func (_dedcc *CT_ExtensionList) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_cged:
	for {
		_dgdfa, _ccfag := d.Token()
		if _ccfag != nil {
			return _ccfag
		}
		switch _cedf := _dgdfa.(type) {
		case _fa.StartElement:
			switch _cedf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ext"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ext"}:
				_eebdd := NewCT_Extension()
				if _gfcg := d.DecodeElement(_eebdd, &_cedf); _gfcg != nil {
					return _gfcg
				}
				_dedcc.Ext = append(_dedcc.Ext, _eebdd)
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ExtensionList\u0020\u0025v", _cedf.Name)
				if _adaa := d.Skip(); _adaa != nil {
					return _adaa
				}
			}
		case _fa.EndElement:
			break _cged
		case _fa.CharData:
		}
	}
	return nil
}

const (
	ST_RadarStyleUnset    ST_RadarStyle = 0
	ST_RadarStyleStandard ST_RadarStyle = 1
	ST_RadarStyleMarker   ST_RadarStyle = 2
	ST_RadarStyleFilled   ST_RadarStyle = 3
)

// ValidateWithPath validates the CT_Layout and its children, prefixing error messages with path
func (_aafce *CT_Layout) ValidateWithPath(path string) error {
	if _aafce.ManualLayout != nil {
		if _agdg := _aafce.ManualLayout.ValidateWithPath(path + "\u002fManualLayout"); _agdg != nil {
			return _agdg
		}
	}
	if _aafce.ExtLst != nil {
		if _febaf := _aafce.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _febaf != nil {
			return _febaf
		}
	}
	return nil
}
func (_ebgg *CT_BarSer) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ebgg.Idx = NewCT_UnsignedInt()
	_ebgg.Order = NewCT_UnsignedInt()
_ccef:
	for {
		_dbab, _bdec := d.Token()
		if _bdec != nil {
			return _bdec
		}
		switch _egcd := _dbab.(type) {
		case _fa.StartElement:
			switch _egcd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _daac := d.DecodeElement(_ebgg.Idx, &_egcd); _daac != nil {
					return _daac
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "order"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "order"}:
				if _ccc := d.DecodeElement(_ebgg.Order, &_egcd); _ccc != nil {
					return _ccc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_ebgg.Tx = NewCT_SerTx()
				if _egfd := d.DecodeElement(_ebgg.Tx, &_egcd); _egfd != nil {
					return _egfd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_ebgg.SpPr = _cb.NewCT_ShapeProperties()
				if _fbdd := d.DecodeElement(_ebgg.SpPr, &_egcd); _fbdd != nil {
					return _fbdd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "invertIfNegative"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "invertIfNegative"}:
				_ebgg.InvertIfNegative = NewCT_Boolean()
				if _gecg := d.DecodeElement(_ebgg.InvertIfNegative, &_egcd); _gecg != nil {
					return _gecg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pictureOptions"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pictureOptions"}:
				_ebgg.PictureOptions = NewCT_PictureOptions()
				if _aca := d.DecodeElement(_ebgg.PictureOptions, &_egcd); _aca != nil {
					return _aca
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dPt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dPt"}:
				_eefc := NewCT_DPt()
				if _geb := d.DecodeElement(_eefc, &_egcd); _geb != nil {
					return _geb
				}
				_ebgg.DPt = append(_ebgg.DPt, _eefc)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_ebgg.DLbls = NewCT_DLbls()
				if _bdece := d.DecodeElement(_ebgg.DLbls, &_egcd); _bdece != nil {
					return _bdece
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "trendline"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "trendline"}:
				_dcgb := NewCT_Trendline()
				if _bccb := d.DecodeElement(_dcgb, &_egcd); _bccb != nil {
					return _bccb
				}
				_ebgg.Trendline = append(_ebgg.Trendline, _dcgb)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "errBars"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "errBars"}:
				_ebgg.ErrBars = NewCT_ErrBars()
				if _fdec := d.DecodeElement(_ebgg.ErrBars, &_egcd); _fdec != nil {
					return _fdec
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "cat"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "cat"}:
				_ebgg.Cat = NewCT_AxDataSource()
				if _gadf := d.DecodeElement(_ebgg.Cat, &_egcd); _gadf != nil {
					return _gadf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "val"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "val"}:
				_ebgg.Val = NewCT_NumDataSource()
				if _cdagc := d.DecodeElement(_ebgg.Val, &_egcd); _cdagc != nil {
					return _cdagc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "shape"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "shape"}:
				_ebgg.Shape = NewCT_Shape()
				if _dab := d.DecodeElement(_ebgg.Shape, &_egcd); _dab != nil {
					return _dab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_ebgg.ExtLst = NewCT_ExtensionList()
				if _bgg := d.DecodeElement(_ebgg.ExtLst, &_egcd); _bgg != nil {
					return _bgg
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_BarSer \u0025v", _egcd.Name)
				if _aagf := d.Skip(); _aagf != nil {
					return _aagf
				}
			}
		case _fa.EndElement:
			break _ccef
		case _fa.CharData:
		}
	}
	return nil
}
func (_aacc *CT_LegendEntryChoice) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _aacc.Delete != nil {
		_gffca := _fa.StartElement{Name: _fa.Name{Local: "c:delete"}}
		e.EncodeElement(_aacc.Delete, _gffca)
	}
	if _aacc.TxPr != nil {
		_cbd := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_aacc.TxPr, _cbd)
	}
	return nil
}

// ValidateWithPath validates the CT_PieSer and its children, prefixing error messages with path
func (_bdfe *CT_PieSer) ValidateWithPath(path string) error {
	if _bgcbb := _bdfe.Idx.ValidateWithPath(path + "\u002fIdx"); _bgcbb != nil {
		return _bgcbb
	}
	if _eaag := _bdfe.Order.ValidateWithPath(path + "\u002fOrder"); _eaag != nil {
		return _eaag
	}
	if _bdfe.Tx != nil {
		if _fdaag := _bdfe.Tx.ValidateWithPath(path + "\u002fTx"); _fdaag != nil {
			return _fdaag
		}
	}
	if _bdfe.SpPr != nil {
		if _abccc := _bdfe.SpPr.ValidateWithPath(path + "\u002fSpPr"); _abccc != nil {
			return _abccc
		}
	}
	if _bdfe.Explosion != nil {
		if _egcdf := _bdfe.Explosion.ValidateWithPath(path + "\u002fExplosion"); _egcdf != nil {
			return _egcdf
		}
	}
	for _gegf, _ebfd := range _bdfe.DPt {
		if _caff := _ebfd.ValidateWithPath(_gg.Sprintf("\u0025s\u002fDPt\u005b\u0025d\u005d", path, _gegf)); _caff != nil {
			return _caff
		}
	}
	if _bdfe.DLbls != nil {
		if _egeab := _bdfe.DLbls.ValidateWithPath(path + "\u002fDLbls"); _egeab != nil {
			return _egeab
		}
	}
	if _bdfe.Cat != nil {
		if _bfea := _bdfe.Cat.ValidateWithPath(path + "\u002fCat"); _bfea != nil {
			return _bfea
		}
	}
	if _bdfe.Val != nil {
		if _dfae := _bdfe.Val.ValidateWithPath(path + "\u002fVal"); _dfae != nil {
			return _dfae
		}
	}
	if _bdfe.ExtLst != nil {
		if _degge := _bdfe.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _degge != nil {
			return _degge
		}
	}
	return nil
}
func NewCT_Thickness() *CT_Thickness       { _afag := &CT_Thickness{}; return _afag }
func NewCT_HeaderFooter() *CT_HeaderFooter { _fgbb := &CT_HeaderFooter{}; return _fgbb }

type ST_ErrDir byte

func (_ebc *CT_DPt) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cdba := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_ebc.Idx, _cdba)
	if _ebc.InvertIfNegative != nil {
		_ggffd := _fa.StartElement{Name: _fa.Name{Local: "c:invertIfNegative"}}
		e.EncodeElement(_ebc.InvertIfNegative, _ggffd)
	}
	if _ebc.Marker != nil {
		_fcbf := _fa.StartElement{Name: _fa.Name{Local: "c:marker"}}
		e.EncodeElement(_ebc.Marker, _fcbf)
	}
	if _ebc.Bubble3D != nil {
		_ffgc := _fa.StartElement{Name: _fa.Name{Local: "c:bubble3D"}}
		e.EncodeElement(_ebc.Bubble3D, _ffgc)
	}
	if _ebc.Explosion != nil {
		_bbfa := _fa.StartElement{Name: _fa.Name{Local: "c:explosion"}}
		e.EncodeElement(_ebc.Explosion, _bbfa)
	}
	if _ebc.SpPr != nil {
		_gacbd := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_ebc.SpPr, _gacbd)
	}
	if _ebc.PictureOptions != nil {
		_decg := _fa.StartElement{Name: _fa.Name{Local: "c:pictureOptions"}}
		e.EncodeElement(_ebc.PictureOptions, _decg)
	}
	if _ebc.ExtLst != nil {
		_fgac := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_ebc.ExtLst, _fgac)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_def *CT_AxPos) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_def.ValAttr = ST_AxPos(1)
	for _, _gea := range start.Attr {
		if _gea.Name.Local == "val" {
			_def.ValAttr.UnmarshalXMLAttr(_gea)
			continue
		}
	}
	for {
		_gbgd, _dda := d.Token()
		if _dda != nil {
			return _gg.Errorf("parsing\u0020CT_AxPos: \u0025s", _dda)
		}
		if _ac, _gbgdg := _gbgd.(_fa.EndElement); _gbgdg && _ac.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_DLblChoice struct {
	Delete         *CT_Boolean
	Layout         *CT_Layout
	Tx             *CT_Tx
	NumFmt         *CT_NumFmt
	SpPr           *_cb.CT_ShapeProperties
	TxPr           *_cb.CT_TextBody
	DLblPos        *CT_DLblPos
	ShowLegendKey  *CT_Boolean
	ShowVal        *CT_Boolean
	ShowCatName    *CT_Boolean
	ShowSerName    *CT_Boolean
	ShowPercent    *CT_Boolean
	ShowBubbleSize *CT_Boolean
	Separator      *string
}

func ParseUnionST_Thickness(s string) (ST_Thickness, error) {
	if ST_ThicknessPercentPatternRe.MatchString(s) {
		return ST_Thickness{ST_ThicknessPercent: &s}, nil
	}
	_fbca, _acead := _c.ParseUint(s, 10, 32)
	if _acead != nil {
		return ST_Thickness{}, _acead
	}
	_acccc := uint32(_fbca)
	return ST_Thickness{Uint32: &_acccc}, nil
}

// Validate validates the CT_LblAlgn and its children
func (_eeac *CT_LblAlgn) Validate() error { return _eeac.ValidateWithPath("CT_LblAlgn") }

type EG_BarChartShared struct {
	BarDir     *CT_BarDir
	Grouping   *CT_BarGrouping
	VaryColors *CT_Boolean
	Ser        []*CT_BarSer
	DLbls      *CT_DLbls
}

func (_aefca *CT_PictureFormat) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_bffg, _acaa := _aefca.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
	if _acaa != nil {
		return _acaa
	}
	start.Attr = append(start.Attr, _bffg)
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ScatterChart and its children, prefixing error messages with path
func (_adafa *CT_ScatterChart) ValidateWithPath(path string) error {
	if _gbade := _adafa.ScatterStyle.ValidateWithPath(path + "\u002fScatterStyle"); _gbade != nil {
		return _gbade
	}
	if _adafa.VaryColors != nil {
		if _cdaff := _adafa.VaryColors.ValidateWithPath(path + "/VaryColors"); _cdaff != nil {
			return _cdaff
		}
	}
	for _effeg, _agabc := range _adafa.Ser {
		if _efbed := _agabc.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _effeg)); _efbed != nil {
			return _efbed
		}
	}
	if _adafa.DLbls != nil {
		if _fdaac := _adafa.DLbls.ValidateWithPath(path + "\u002fDLbls"); _fdaac != nil {
			return _fdaac
		}
	}
	for _dddcb, _eafea := range _adafa.AxId {
		if _ggac := _eafea.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _dddcb)); _ggac != nil {
			return _ggac
		}
	}
	if _adafa.ExtLst != nil {
		if _bfeaf := _adafa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bfeaf != nil {
			return _bfeaf
		}
	}
	return nil
}

type CT_ChartSpace struct {
	Date1904       *CT_Boolean
	Lang           *CT_TextLanguageID
	RoundedCorners *CT_Boolean
	Style          *CT_Style
	ClrMapOvr      *_cb.CT_ColorMapping
	PivotSource    *CT_PivotSource
	Protection     *CT_Protection
	Chart          *CT_Chart
	SpPr           *_cb.CT_ShapeProperties
	TxPr           *_cb.CT_TextBody
	ExternalData   *CT_ExternalData
	PrintSettings  *CT_PrintSettings
	UserShapes     *CT_RelId
	ExtLst         *CT_ExtensionList
}

func (_ddg *CT_BarGrouping) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _abg := range start.Attr {
		if _abg.Name.Local == "val" {
			_ddg.ValAttr.UnmarshalXMLAttr(_abg)
			continue
		}
	}
	for {
		_gfc, _gabc := d.Token()
		if _gabc != nil {
			return _gg.Errorf("parsing\u0020CT_BarGrouping:\u0020\u0025s", _gabc)
		}
		if _bbbg, _abda := _gfc.(_fa.EndElement); _abda && _bbbg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fccfc *CT_LblOffset) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _cefc := range start.Attr {
		if _cefc.Name.Local == "val" {
			_adca, _feea := ParseUnionST_LblOffset(_cefc.Value)
			if _feea != nil {
				return _feea
			}
			_fccfc.ValAttr = &_adca
			continue
		}
	}
	for {
		_gbga, _ebgbfd := d.Token()
		if _ebgbfd != nil {
			return _gg.Errorf("parsing\u0020CT_LblOffset:\u0020\u0025s", _ebgbfd)
		}
		if _gfbg, _accac := _gbga.(_fa.EndElement); _accac && _gfbg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_accaa *CT_DateAx) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_edgf := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	e.EncodeElement(_accaa.AxId, _edgf)
	_eedgb := _fa.StartElement{Name: _fa.Name{Local: "c:scaling"}}
	e.EncodeElement(_accaa.Scaling, _eedgb)
	if _accaa.Delete != nil {
		_ggcg := _fa.StartElement{Name: _fa.Name{Local: "c:delete"}}
		e.EncodeElement(_accaa.Delete, _ggcg)
	}
	_gaccg := _fa.StartElement{Name: _fa.Name{Local: "c:axPos"}}
	e.EncodeElement(_accaa.AxPos, _gaccg)
	if _accaa.MajorGridlines != nil {
		_fcdb := _fa.StartElement{Name: _fa.Name{Local: "c:majorGridlines"}}
		e.EncodeElement(_accaa.MajorGridlines, _fcdb)
	}
	if _accaa.MinorGridlines != nil {
		_fac := _fa.StartElement{Name: _fa.Name{Local: "c:minorGridlines"}}
		e.EncodeElement(_accaa.MinorGridlines, _fac)
	}
	if _accaa.Title != nil {
		_ffefe := _fa.StartElement{Name: _fa.Name{Local: "c:title"}}
		e.EncodeElement(_accaa.Title, _ffefe)
	}
	if _accaa.NumFmt != nil {
		_adag := _fa.StartElement{Name: _fa.Name{Local: "c:numFmt"}}
		e.EncodeElement(_accaa.NumFmt, _adag)
	}
	if _accaa.MajorTickMark != nil {
		_gfdb := _fa.StartElement{Name: _fa.Name{Local: "c:majorTickMark"}}
		e.EncodeElement(_accaa.MajorTickMark, _gfdb)
	}
	if _accaa.MinorTickMark != nil {
		_edd := _fa.StartElement{Name: _fa.Name{Local: "c:minorTickMark"}}
		e.EncodeElement(_accaa.MinorTickMark, _edd)
	}
	if _accaa.TickLblPos != nil {
		_aefa := _fa.StartElement{Name: _fa.Name{Local: "c:tickLblPos"}}
		e.EncodeElement(_accaa.TickLblPos, _aefa)
	}
	if _accaa.SpPr != nil {
		_cdcg := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_accaa.SpPr, _cdcg)
	}
	if _accaa.TxPr != nil {
		_gcbd := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_accaa.TxPr, _gcbd)
	}
	_fagd := _fa.StartElement{Name: _fa.Name{Local: "c:crossAx"}}
	e.EncodeElement(_accaa.CrossAx, _fagd)
	if _accaa.Choice != nil {
		_accaa.Choice.MarshalXML(e, _fa.StartElement{})
	}
	if _accaa.Auto != nil {
		_egfe := _fa.StartElement{Name: _fa.Name{Local: "c:auto"}}
		e.EncodeElement(_accaa.Auto, _egfe)
	}
	if _accaa.LblOffset != nil {
		_gcbde := _fa.StartElement{Name: _fa.Name{Local: "c:lblOffset"}}
		e.EncodeElement(_accaa.LblOffset, _gcbde)
	}
	if _accaa.BaseTimeUnit != nil {
		_gfeb := _fa.StartElement{Name: _fa.Name{Local: "c:baseTimeUnit"}}
		e.EncodeElement(_accaa.BaseTimeUnit, _gfeb)
	}
	if _accaa.MajorUnit != nil {
		_egag := _fa.StartElement{Name: _fa.Name{Local: "c:majorUnit"}}
		e.EncodeElement(_accaa.MajorUnit, _egag)
	}
	if _accaa.MajorTimeUnit != nil {
		_edca := _fa.StartElement{Name: _fa.Name{Local: "c:majorTimeUnit"}}
		e.EncodeElement(_accaa.MajorTimeUnit, _edca)
	}
	if _accaa.MinorUnit != nil {
		_agea := _fa.StartElement{Name: _fa.Name{Local: "c:minorUnit"}}
		e.EncodeElement(_accaa.MinorUnit, _agea)
	}
	if _accaa.MinorTimeUnit != nil {
		_abcdg := _fa.StartElement{Name: _fa.Name{Local: "c:minorTimeUnit"}}
		e.EncodeElement(_accaa.MinorTimeUnit, _abcdg)
	}
	if _accaa.ExtLst != nil {
		_eegfc := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_accaa.ExtLst, _eegfc)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_TickLblPos struct{ ValAttr ST_TickLblPos }
type Group_DLbls struct {
	NumFmt          *CT_NumFmt
	SpPr            *_cb.CT_ShapeProperties
	TxPr            *_cb.CT_TextBody
	DLblPos         *CT_DLblPos
	ShowLegendKey   *CT_Boolean
	ShowVal         *CT_Boolean
	ShowCatName     *CT_Boolean
	ShowSerName     *CT_Boolean
	ShowPercent     *CT_Boolean
	ShowBubbleSize  *CT_Boolean
	Separator       *string
	ShowLeaderLines *CT_Boolean
	LeaderLines     *CT_ChartLines
}

func NewCT_PictureOptions() *CT_PictureOptions { _beedb := &CT_PictureOptions{}; return _beedb }
func (_fcbaeg *ST_HoleSize) Validate() error   { return _fcbaeg.ValidateWithPath("") }
func (_eccbd *CT_LblOffset) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _eccbd.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_eccbd.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_BarChart() *CT_BarChart {
	_eecf := &CT_BarChart{}
	_eecf.BarDir = NewCT_BarDir()
	return _eecf
}

// Validate validates the CT_TxChoice and its children
func (_dbcac *CT_TxChoice) Validate() error { return _dbcac.ValidateWithPath("CT_TxChoice") }

var ST_ThicknessPercentPatternRe = _g.MustCompile(ST_ThicknessPercentPattern)

func (_fefd *Chart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:c"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "c:chart"
	return _fefd.CT_RelId.MarshalXML(e, start)
}

// Validate validates the CT_PieSer and its children
func (_daege *CT_PieSer) Validate() error { return _daege.ValidateWithPath("CT_PieSer") }

// Validate validates the CT_BubbleChart and its children
func (_gdfg *CT_BubbleChart) Validate() error { return _gdfg.ValidateWithPath("CT_BubbleChart") }
func (_dega *ST_CrossBetween) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_dega = 0
	case "between":
		*_dega = 1
	case "midCat":
		*_dega = 2
	}
	return nil
}
func (_dc *CT_AreaChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_gdg:
	for {
		_fbc, _gbg := d.Token()
		if _gbg != nil {
			return _gbg
		}
		switch _dgd := _fbc.(type) {
		case _fa.StartElement:
			switch _dgd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "grouping"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "grouping"}:
				_dc.Grouping = NewCT_Grouping()
				if _eda := d.DecodeElement(_dc.Grouping, &_dgd); _eda != nil {
					return _eda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_dc.VaryColors = NewCT_Boolean()
				if _ecg := d.DecodeElement(_dc.VaryColors, &_dgd); _ecg != nil {
					return _ecg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_dcg := NewCT_AreaSer()
				if _cce := d.DecodeElement(_dcg, &_dgd); _cce != nil {
					return _cce
				}
				_dc.Ser = append(_dc.Ser, _dcg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_dc.DLbls = NewCT_DLbls()
				if _eagb := d.DecodeElement(_dc.DLbls, &_dgd); _eagb != nil {
					return _eagb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dropLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dropLines"}:
				_dc.DropLines = NewCT_ChartLines()
				if _db := d.DecodeElement(_dc.DropLines, &_dgd); _db != nil {
					return _db
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_ecd := NewCT_UnsignedInt()
				if _fd := d.DecodeElement(_ecd, &_dgd); _fd != nil {
					return _fd
				}
				_dc.AxId = append(_dc.AxId, _ecd)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_dc.ExtLst = NewCT_ExtensionList()
				if _ab := d.DecodeElement(_dc.ExtLst, &_dgd); _ab != nil {
					return _ab
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_AreaChart\u0020\u0025v", _dgd.Name)
				if _ecad := d.Skip(); _ecad != nil {
					return _ecad
				}
			}
		case _fa.EndElement:
			break _gdg
		case _fa.CharData:
		}
	}
	return nil
}
func (_bgdcb ST_LayoutTarget) String() string {
	switch _bgdcb {
	case 0:
		return ""
	case 1:
		return "inner"
	case 2:
		return "outer"
	}
	return ""
}
func (_cccee ST_TrendlineType) ValidateWithPath(path string) error {
	switch _cccee {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cccee))
	}
	return nil
}
func (_gdcffe ST_MarkerStyle) Validate() error { return _gdcffe.ValidateWithPath("") }

type CT_ErrBars struct {
	ErrDir     *CT_ErrDir
	ErrBarType *CT_ErrBarType
	ErrValType *CT_ErrValType
	NoEndCap   *CT_Boolean
	Plus       *CT_NumDataSource
	Minus      *CT_NumDataSource
	Val        *CT_Double
	SpPr       *_cb.CT_ShapeProperties
	ExtLst     *CT_ExtensionList
}

func (_dbdfd ST_CrossBetween) String() string {
	switch _dbdfd {
	case 0:
		return ""
	case 1:
		return "between"
	case 2:
		return "midCat"
	}
	return ""
}

// ValidateWithPath validates the CT_LblOffset and its children, prefixing error messages with path
func (_eege *CT_LblOffset) ValidateWithPath(path string) error {
	if _eege.ValAttr != nil {
		if _cbcc := _eege.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _cbcc != nil {
			return _cbcc
		}
	}
	return nil
}
func (_geag *CT_RadarChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cgbe := _fa.StartElement{Name: _fa.Name{Local: "c:radarStyle"}}
	e.EncodeElement(_geag.RadarStyle, _cgbe)
	if _geag.VaryColors != nil {
		_dbagc := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_geag.VaryColors, _dbagc)
	}
	if _geag.Ser != nil {
		_bfgg := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _aecg := range _geag.Ser {
			e.EncodeElement(_aecg, _bfgg)
		}
	}
	if _geag.DLbls != nil {
		_dfbb := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_geag.DLbls, _dfbb)
	}
	_eebab := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _cgfa := range _geag.AxId {
		e.EncodeElement(_cgfa, _eebab)
	}
	if _geag.ExtLst != nil {
		_cbge := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_geag.ExtLst, _cbge)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_cgca *CT_DLblChoice) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _cgca.Delete != nil {
		_bdcg := _fa.StartElement{Name: _fa.Name{Local: "c:delete"}}
		e.EncodeElement(_cgca.Delete, _bdcg)
	}
	if _cgca.Layout != nil {
		_cbfe := _fa.StartElement{Name: _fa.Name{Local: "c:layout"}}
		e.EncodeElement(_cgca.Layout, _cbfe)
	}
	if _cgca.Tx != nil {
		_dagc := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_cgca.Tx, _dagc)
	}
	if _cgca.NumFmt != nil {
		_caef := _fa.StartElement{Name: _fa.Name{Local: "c:numFmt"}}
		e.EncodeElement(_cgca.NumFmt, _caef)
	}
	if _cgca.SpPr != nil {
		_gaba := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_cgca.SpPr, _gaba)
	}
	if _cgca.TxPr != nil {
		_abdd := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_cgca.TxPr, _abdd)
	}
	if _cgca.DLblPos != nil {
		_ccga := _fa.StartElement{Name: _fa.Name{Local: "c:dLblPos"}}
		e.EncodeElement(_cgca.DLblPos, _ccga)
	}
	if _cgca.ShowLegendKey != nil {
		_dggd := _fa.StartElement{Name: _fa.Name{Local: "c:showLegendKey"}}
		e.EncodeElement(_cgca.ShowLegendKey, _dggd)
	}
	if _cgca.ShowVal != nil {
		_bacd := _fa.StartElement{Name: _fa.Name{Local: "c:showVal"}}
		e.EncodeElement(_cgca.ShowVal, _bacd)
	}
	if _cgca.ShowCatName != nil {
		_gcbf := _fa.StartElement{Name: _fa.Name{Local: "c:showCatName"}}
		e.EncodeElement(_cgca.ShowCatName, _gcbf)
	}
	if _cgca.ShowSerName != nil {
		_dacc := _fa.StartElement{Name: _fa.Name{Local: "c:showSerName"}}
		e.EncodeElement(_cgca.ShowSerName, _dacc)
	}
	if _cgca.ShowPercent != nil {
		_aaeg := _fa.StartElement{Name: _fa.Name{Local: "c:showPercent"}}
		e.EncodeElement(_cgca.ShowPercent, _aaeg)
	}
	if _cgca.ShowBubbleSize != nil {
		_cbcf := _fa.StartElement{Name: _fa.Name{Local: "c:showBubbleSize"}}
		e.EncodeElement(_cgca.ShowBubbleSize, _cbcf)
	}
	if _cgca.Separator != nil {
		_fbccb := _fa.StartElement{Name: _fa.Name{Local: "c:separator"}}
		_b.AddPreserveSpaceAttr(&_fbccb, *_cgca.Separator)
		e.EncodeElement(_cgca.Separator, _fbccb)
	}
	return nil
}
func (_abcaff *CT_PrintSettings) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _abcaff.HeaderFooter != nil {
		_fcdfe := _fa.StartElement{Name: _fa.Name{Local: "c:headerFooter"}}
		e.EncodeElement(_abcaff.HeaderFooter, _fcdfe)
	}
	if _abcaff.PageMargins != nil {
		_ddegd := _fa.StartElement{Name: _fa.Name{Local: "c:pageMargins"}}
		e.EncodeElement(_abcaff.PageMargins, _ddegd)
	}
	if _abcaff.PageSetup != nil {
		_gaeg := _fa.StartElement{Name: _fa.Name{Local: "c:pageSetup"}}
		e.EncodeElement(_abcaff.PageSetup, _gaeg)
	}
	if _abcaff.LegacyDrawingHF != nil {
		_gcbc := _fa.StartElement{Name: _fa.Name{Local: "c:legacyDrawingHF"}}
		e.EncodeElement(_abcaff.LegacyDrawingHF, _gcbc)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_RotY struct{ ValAttr *uint16 }

func NewCT_BarGrouping() *CT_BarGrouping { _eegf := &CT_BarGrouping{}; return _eegf }
func (_dcddd ST_TickLblPos) ValidateWithPath(path string) error {
	switch _dcddd {
	case 0, 1, 2, 3, 4:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dcddd))
	}
	return nil
}
func NewCT_DispBlanksAs() *CT_DispBlanksAs { _gceg := &CT_DispBlanksAs{}; return _gceg }
func NewCT_Boolean() *CT_Boolean           { _cdac := &CT_Boolean{}; return _cdac }
func NewCT_RotX() *CT_RotX                 { _fgea := &CT_RotX{}; return _fgea }
func (_gdccg ST_PictureFormat) ValidateWithPath(path string) error {
	switch _gdccg {
	case 0, 1, 2, 3:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gdccg))
	}
	return nil
}
func (_daebc ST_HPercent) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _daebc.ST_HPercentWithSymbol != nil {
		e.EncodeToken(_fa.CharData(*_daebc.ST_HPercentWithSymbol))
	}
	if _daebc.ST_HPercentUShort != nil {
		e.EncodeToken(_fa.CharData(_gg.Sprintf("\u0025d", *_daebc.ST_HPercentUShort)))
	}
	return e.EncodeToken(_fa.EndElement{Name: start.Name})
}
func NewCT_TxChoice() *CT_TxChoice       { _dggba := &CT_TxChoice{}; return _dggba }
func (_afadf ST_ErrDir) Validate() error { return _afadf.ValidateWithPath("") }
func (_aff *CT_Chart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_aff.PlotArea = NewCT_PlotArea()
_feca:
	for {
		_gebg, _bfb := d.Token()
		if _bfb != nil {
			return _bfb
		}
		switch _beaa := _gebg.(type) {
		case _fa.StartElement:
			switch _beaa.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "title"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "title"}:
				_aff.Title = NewCT_Title()
				if _fcab := d.DecodeElement(_aff.Title, &_beaa); _fcab != nil {
					return _fcab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "autoTitleDeleted"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "autoTitleDeleted"}:
				_aff.AutoTitleDeleted = NewCT_Boolean()
				if _febcb := d.DecodeElement(_aff.AutoTitleDeleted, &_beaa); _febcb != nil {
					return _febcb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pivotFmts"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pivotFmts"}:
				_aff.PivotFmts = NewCT_PivotFmts()
				if _cded := d.DecodeElement(_aff.PivotFmts, &_beaa); _cded != nil {
					return _cded
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "view3D"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "view3D"}:
				_aff.View3D = NewCT_View3D()
				if _gdgc := d.DecodeElement(_aff.View3D, &_beaa); _gdgc != nil {
					return _gdgc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "floor"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "floor"}:
				_aff.Floor = NewCT_Surface()
				if _cafd := d.DecodeElement(_aff.Floor, &_beaa); _cafd != nil {
					return _cafd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "sideWall"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "sideWall"}:
				_aff.SideWall = NewCT_Surface()
				if _bccbe := d.DecodeElement(_aff.SideWall, &_beaa); _bccbe != nil {
					return _bccbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "backWall"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "backWall"}:
				_aff.BackWall = NewCT_Surface()
				if _aagdb := d.DecodeElement(_aff.BackWall, &_beaa); _aagdb != nil {
					return _aagdb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "plotArea"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "plotArea"}:
				if _bega := d.DecodeElement(_aff.PlotArea, &_beaa); _bega != nil {
					return _bega
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "legend"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "legend"}:
				_aff.Legend = NewCT_Legend()
				if _fgda := d.DecodeElement(_aff.Legend, &_beaa); _fgda != nil {
					return _fgda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "plotVisOnly"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "plotVisOnly"}:
				_aff.PlotVisOnly = NewCT_Boolean()
				if _aafc := d.DecodeElement(_aff.PlotVisOnly, &_beaa); _aafc != nil {
					return _aafc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dispBlanksAs"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dispBlanksAs"}:
				_aff.DispBlanksAs = NewCT_DispBlanksAs()
				if _gbgecg := d.DecodeElement(_aff.DispBlanksAs, &_beaa); _gbgecg != nil {
					return _gbgecg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showDLblsOverMax"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showDLblsOverMax"}:
				_aff.ShowDLblsOverMax = NewCT_Boolean()
				if _eace := d.DecodeElement(_aff.ShowDLblsOverMax, &_beaa); _eace != nil {
					return _eace
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_aff.ExtLst = NewCT_ExtensionList()
				if _bebc := d.DecodeElement(_aff.ExtLst, &_beaa); _bebc != nil {
					return _bebc
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Chart\u0020\u0025v", _beaa.Name)
				if _fag := d.Skip(); _fag != nil {
					return _fag
				}
			}
		case _fa.EndElement:
			break _feca
		case _fa.CharData:
		}
	}
	return nil
}

const ST_DepthPercentWithSymbolPattern = "0\u002a\u0028\u0028\u005b2\u002d9\u005d\u005b0\u002d9\u005d\u0029\u007c\u0028\u005b1\u002d9\u005d\u005b0\u002d9\u005d\u005b0\u002d9\u005d\u0029\u007c\u00281\u005b0\u002d9\u005d\u005b0\u002d9\u005d\u005b0\u002d9\u005d)\u007c2000)\u0025"

type ST_PictureFormat byte
type CT_RadarChart struct {
	RadarStyle *CT_RadarStyle
	VaryColors *CT_Boolean
	Ser        []*CT_RadarSer
	DLbls      *CT_DLbls
	AxId       []*CT_UnsignedInt
	ExtLst     *CT_ExtensionList
}

func (_dggcb *CT_ScatterStyle) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _dggcb.ValAttr != ST_ScatterStyleUnset {
		_eagab, _cbcce := _dggcb.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _cbcce != nil {
			return _cbcce
		}
		start.Attr = append(start.Attr, _eagab)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_caaceb *CT_Period) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _febcf := range start.Attr {
		if _febcf.Name.Local == "val" {
			_bffe, _ceedf := _c.ParseUint(_febcf.Value, 10, 32)
			if _ceedf != nil {
				return _ceedf
			}
			_fbgbc := uint32(_bffe)
			_caaceb.ValAttr = &_fbgbc
			continue
		}
	}
	for {
		_gcab, _gecae := d.Token()
		if _gecae != nil {
			return _gg.Errorf("parsing\u0020CT_Period:\u0020\u0025s", _gecae)
		}
		if _bgbfa, _addf := _gcab.(_fa.EndElement); _addf && _bgbfa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_egbcf ST_Overlap) String() string {
	if _egbcf.ST_OverlapPercent != nil {
		return _gg.Sprintf("\u0025v", *_egbcf.ST_OverlapPercent)
	}
	if _egbcf.ST_OverlapByte != nil {
		return _gg.Sprintf("\u0025v", *_egbcf.ST_OverlapByte)
	}
	return ""
}

// ValidateWithPath validates the CT_Bar3DChart and its children, prefixing error messages with path
func (_cgd *CT_Bar3DChart) ValidateWithPath(path string) error {
	if _fbe := _cgd.BarDir.ValidateWithPath(path + "\u002fBarDir"); _fbe != nil {
		return _fbe
	}
	if _cgd.Grouping != nil {
		if _egg := _cgd.Grouping.ValidateWithPath(path + "\u002fGrouping"); _egg != nil {
			return _egg
		}
	}
	if _cgd.VaryColors != nil {
		if _abcg := _cgd.VaryColors.ValidateWithPath(path + "/VaryColors"); _abcg != nil {
			return _abcg
		}
	}
	for _dba, _fcad := range _cgd.Ser {
		if _efd := _fcad.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _dba)); _efd != nil {
			return _efd
		}
	}
	if _cgd.DLbls != nil {
		if _dbgf := _cgd.DLbls.ValidateWithPath(path + "\u002fDLbls"); _dbgf != nil {
			return _dbgf
		}
	}
	if _cgd.GapWidth != nil {
		if _add := _cgd.GapWidth.ValidateWithPath(path + "\u002fGapWidth"); _add != nil {
			return _add
		}
	}
	if _cgd.GapDepth != nil {
		if _gda := _cgd.GapDepth.ValidateWithPath(path + "\u002fGapDepth"); _gda != nil {
			return _gda
		}
	}
	if _cgd.Shape != nil {
		if _ggce := _cgd.Shape.ValidateWithPath(path + "\u002fShape"); _ggce != nil {
			return _ggce
		}
	}
	for _gbge, _dgca := range _cgd.AxId {
		if _gagg := _dgca.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _gbge)); _gagg != nil {
			return _gagg
		}
	}
	if _cgd.ExtLst != nil {
		if _baa := _cgd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _baa != nil {
			return _baa
		}
	}
	return nil
}
func (_ccfaa *CT_NumDataSourceChoice) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_bggeg:
	for {
		_fafgd, _cdgc := d.Token()
		if _cdgc != nil {
			return _cdgc
		}
		switch _gaag := _fafgd.(type) {
		case _fa.StartElement:
			switch _gaag.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numRef"}:
				_ccfaa.NumRef = NewCT_NumRef()
				if _edead := d.DecodeElement(_ccfaa.NumRef, &_gaag); _edead != nil {
					return _edead
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numLit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numLit"}:
				_ccfaa.NumLit = NewCT_NumData()
				if _bgcga := d.DecodeElement(_ccfaa.NumLit, &_gaag); _bgcga != nil {
					return _bgcga
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_NumDataSourceChoice\u0020\u0025v", _gaag.Name)
				if _aaeb := d.Skip(); _aaeb != nil {
					return _aaeb
				}
			}
		case _fa.EndElement:
			break _bggeg
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_AreaChart and its children
func (_ffa *CT_AreaChart) Validate() error { return _ffa.ValidateWithPath("CT_AreaChart") }
func (_bfabb *CT_SurfaceSer) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_bfeaad := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_bfabb.Idx, _bfeaad)
	_becdg := _fa.StartElement{Name: _fa.Name{Local: "c:order"}}
	e.EncodeElement(_bfabb.Order, _becdg)
	if _bfabb.Tx != nil {
		_aaaag := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_bfabb.Tx, _aaaag)
	}
	if _bfabb.SpPr != nil {
		_accae := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_bfabb.SpPr, _accae)
	}
	if _bfabb.Cat != nil {
		_faff := _fa.StartElement{Name: _fa.Name{Local: "c:cat"}}
		e.EncodeElement(_bfabb.Cat, _faff)
	}
	if _bfabb.Val != nil {
		_fdda := _fa.StartElement{Name: _fa.Name{Local: "c:val"}}
		e.EncodeElement(_bfabb.Val, _fdda)
	}
	if _bfabb.ExtLst != nil {
		_bcggce := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_bfabb.ExtLst, _bcggce)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type ST_SplitType byte

func (_gfed ST_Shape) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_efggb := _fa.Attr{}
	_efggb.Name = name
	switch _gfed {
	case ST_ShapeUnset:
		_efggb.Value = ""
	case ST_ShapeCone:
		_efggb.Value = "cone"
	case ST_ShapeConeToMax:
		_efggb.Value = "coneToMax"
	case ST_ShapeBox:
		_efggb.Value = "box"
	case ST_ShapeCylinder:
		_efggb.Value = "cylinder"
	case ST_ShapePyramid:
		_efggb.Value = "pyramid"
	case ST_ShapePyramidToMax:
		_efggb.Value = "pyramidToMax"
	}
	return _efggb, nil
}
func (_ececa *CT_DPt) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ececa.Idx = NewCT_UnsignedInt()
_gefg:
	for {
		_aace, _adef := d.Token()
		if _adef != nil {
			return _adef
		}
		switch _dbeg := _aace.(type) {
		case _fa.StartElement:
			switch _dbeg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _ceeca := d.DecodeElement(_ececa.Idx, &_dbeg); _ceeca != nil {
					return _ceeca
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "invertIfNegative"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "invertIfNegative"}:
				_ececa.InvertIfNegative = NewCT_Boolean()
				if _fgag := d.DecodeElement(_ececa.InvertIfNegative, &_dbeg); _fgag != nil {
					return _fgag
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "marker"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "marker"}:
				_ececa.Marker = NewCT_Marker()
				if _dbgga := d.DecodeElement(_ececa.Marker, &_dbeg); _dbgga != nil {
					return _dbgga
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bubble3D"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bubble3D"}:
				_ececa.Bubble3D = NewCT_Boolean()
				if _gfec := d.DecodeElement(_ececa.Bubble3D, &_dbeg); _gfec != nil {
					return _gfec
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "explosion"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "explosion"}:
				_ececa.Explosion = NewCT_UnsignedInt()
				if _abeb := d.DecodeElement(_ececa.Explosion, &_dbeg); _abeb != nil {
					return _abeb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_ececa.SpPr = _cb.NewCT_ShapeProperties()
				if _bbfb := d.DecodeElement(_ececa.SpPr, &_dbeg); _bbfb != nil {
					return _bbfb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pictureOptions"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pictureOptions"}:
				_ececa.PictureOptions = NewCT_PictureOptions()
				if _bagf := d.DecodeElement(_ececa.PictureOptions, &_dbeg); _bagf != nil {
					return _bagf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_ececa.ExtLst = NewCT_ExtensionList()
				if _eeddd := d.DecodeElement(_ececa.ExtLst, &_dbeg); _eeddd != nil {
					return _eeddd
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DPt\u0020\u0025v", _dbeg.Name)
				if _aege := d.Skip(); _aege != nil {
					return _aege
				}
			}
		case _fa.EndElement:
			break _gefg
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_ValAx and its children
func (_ecgda *CT_ValAx) Validate() error { return _ecgda.ValidateWithPath("CT_ValAx") }
func (_dggdd *CT_MarkerSize) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _fdbgg := range start.Attr {
		if _fdbgg.Name.Local == "val" {
			_dgfgc, _ddcb := _c.ParseUint(_fdbgg.Value, 10, 8)
			if _ddcb != nil {
				return _ddcb
			}
			_fddbb := uint8(_dgfgc)
			_dggdd.ValAttr = &_fddbb
			continue
		}
	}
	for {
		_gbeb, _gcgb := d.Token()
		if _gcgb != nil {
			return _gg.Errorf("parsing\u0020CT_MarkerSize:\u0020\u0025s", _gcgb)
		}
		if _ebcd, _dcbdf := _gbeb.(_fa.EndElement); _dcbdf && _ebcd.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_View3D and its children, prefixing error messages with path
func (_eecdb *CT_View3D) ValidateWithPath(path string) error {
	if _eecdb.RotX != nil {
		if _dbdfc := _eecdb.RotX.ValidateWithPath(path + "\u002fRotX"); _dbdfc != nil {
			return _dbdfc
		}
	}
	if _eecdb.HPercent != nil {
		if _edabf := _eecdb.HPercent.ValidateWithPath(path + "\u002fHPercent"); _edabf != nil {
			return _edabf
		}
	}
	if _eecdb.RotY != nil {
		if _gabca := _eecdb.RotY.ValidateWithPath(path + "\u002fRotY"); _gabca != nil {
			return _gabca
		}
	}
	if _eecdb.DepthPercent != nil {
		if _efeff := _eecdb.DepthPercent.ValidateWithPath(path + "\u002fDepthPercent"); _efeff != nil {
			return _efeff
		}
	}
	if _eecdb.RAngAx != nil {
		if _ebed := _eecdb.RAngAx.ValidateWithPath(path + "\u002fRAngAx"); _ebed != nil {
			return _ebed
		}
	}
	if _eecdb.Perspective != nil {
		if _cafe := _eecdb.Perspective.ValidateWithPath(path + "\u002fPerspective"); _cafe != nil {
			return _cafe
		}
	}
	if _eecdb.ExtLst != nil {
		if _ebab := _eecdb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ebab != nil {
			return _ebab
		}
	}
	return nil
}
func (_acag *CT_DLbl) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_acag.Idx = NewCT_UnsignedInt()
_fae:
	for {
		_caaa, _cbb := d.Token()
		if _cbb != nil {
			return _cbb
		}
		switch _eeegd := _caaa.(type) {
		case _fa.StartElement:
			switch _eeegd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _cagb := d.DecodeElement(_acag.Idx, &_eeegd); _cagb != nil {
					return _cagb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "delete"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "delete"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _gagec := d.DecodeElement(&_acag.Choice.Delete, &_eeegd); _gagec != nil {
					return _gagec
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "layout"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "layout"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _acbe := d.DecodeElement(&_acag.Choice.Layout, &_eeegd); _acbe != nil {
					return _acbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _dadda := d.DecodeElement(&_acag.Choice.Tx, &_eeegd); _dadda != nil {
					return _dadda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _fgee := d.DecodeElement(&_acag.Choice.NumFmt, &_eeegd); _fgee != nil {
					return _fgee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _ebgb := d.DecodeElement(&_acag.Choice.SpPr, &_eeegd); _ebgb != nil {
					return _ebgb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _gdcf := d.DecodeElement(&_acag.Choice.TxPr, &_eeegd); _gdcf != nil {
					return _gdcf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLblPos"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _ceeea := d.DecodeElement(&_acag.Choice.DLblPos, &_eeegd); _ceeea != nil {
					return _ceeea
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showLegendKey"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showLegendKey"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _ggba := d.DecodeElement(&_acag.Choice.ShowLegendKey, &_eeegd); _ggba != nil {
					return _ggba
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showVal"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showVal"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _gcec := d.DecodeElement(&_acag.Choice.ShowVal, &_eeegd); _gcec != nil {
					return _gcec
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showCatName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showCatName"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _deef := d.DecodeElement(&_acag.Choice.ShowCatName, &_eeegd); _deef != nil {
					return _deef
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showSerName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showSerName"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _gdcd := d.DecodeElement(&_acag.Choice.ShowSerName, &_eeegd); _gdcd != nil {
					return _gdcd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showPercent"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showPercent"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _fdacb := d.DecodeElement(&_acag.Choice.ShowPercent, &_eeegd); _fdacb != nil {
					return _fdacb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showBubbleSize"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showBubbleSize"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _ebfe := d.DecodeElement(&_acag.Choice.ShowBubbleSize, &_eeegd); _ebfe != nil {
					return _ebfe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "separator"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "separator"}:
				if _acag.Choice == nil {
					_acag.Choice = NewCT_DLblChoice()
				}
				if _ebfa := d.DecodeElement(&_acag.Choice.Separator, &_eeegd); _ebfa != nil {
					return _ebfa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_acag.ExtLst = NewCT_ExtensionList()
				if _gbdc := d.DecodeElement(_acag.ExtLst, &_eeegd); _gbdc != nil {
					return _gbdc
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DLbl\u0020\u0025v", _eeegd.Name)
				if _caace := d.Skip(); _caace != nil {
					return _caace
				}
			}
		case _fa.EndElement:
			break _fae
		case _fa.CharData:
		}
	}
	return nil
}
func (_cacf *ST_SplitType) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ddbeb, _afebg := d.Token()
	if _afebg != nil {
		return _afebg
	}
	if _aaafd, _gbfdc := _ddbeb.(_fa.EndElement); _gbfdc && _aaafd.Name == start.Name {
		*_cacf = 1
		return nil
	}
	if _afegd, _gdbba := _ddbeb.(_fa.CharData); !_gdbba {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ddbeb)
	} else {
		switch string(_afegd) {
		case "":
			*_cacf = 0
		case "auto":
			*_cacf = 1
		case "cust":
			*_cacf = 2
		case "percent":
			*_cacf = 3
		case "pos":
			*_cacf = 4
		case "val":
			*_cacf = 5
		}
	}
	_ddbeb, _afebg = d.Token()
	if _afebg != nil {
		return _afebg
	}
	if _agagb, _fbgac := _ddbeb.(_fa.EndElement); _fbgac && _agagb.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ddbeb)
}
func NewCT_OfPieType() *CT_OfPieType { _cdbda := &CT_OfPieType{}; return _cdbda }
func (_efbbg *EG_AxShared) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_efbbg.AxId = NewCT_UnsignedInt()
	_efbbg.Scaling = NewCT_Scaling()
	_efbbg.AxPos = NewCT_AxPos()
	_efbbg.CrossAx = NewCT_UnsignedInt()
_ebgbd:
	for {
		_adabc, _gbfdf := d.Token()
		if _gbfdf != nil {
			return _gbfdf
		}
		switch _ggddg := _adabc.(type) {
		case _fa.StartElement:
			switch _ggddg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				if _gcecg := d.DecodeElement(_efbbg.AxId, &_ggddg); _gcecg != nil {
					return _gcecg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "scaling"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "scaling"}:
				if _dcegg := d.DecodeElement(_efbbg.Scaling, &_ggddg); _dcegg != nil {
					return _dcegg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "delete"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "delete"}:
				_efbbg.Delete = NewCT_Boolean()
				if _agcfa := d.DecodeElement(_efbbg.Delete, &_ggddg); _agcfa != nil {
					return _agcfa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axPos"}:
				if _deege := d.DecodeElement(_efbbg.AxPos, &_ggddg); _deege != nil {
					return _deege
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorGridlines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorGridlines"}:
				_efbbg.MajorGridlines = NewCT_ChartLines()
				if _bbgb := d.DecodeElement(_efbbg.MajorGridlines, &_ggddg); _bbgb != nil {
					return _bbgb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorGridlines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorGridlines"}:
				_efbbg.MinorGridlines = NewCT_ChartLines()
				if _dedcca := d.DecodeElement(_efbbg.MinorGridlines, &_ggddg); _dedcca != nil {
					return _dedcca
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "title"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "title"}:
				_efbbg.Title = NewCT_Title()
				if _eggddb := d.DecodeElement(_efbbg.Title, &_ggddg); _eggddb != nil {
					return _eggddb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				_efbbg.NumFmt = NewCT_NumFmt()
				if _cdafdg := d.DecodeElement(_efbbg.NumFmt, &_ggddg); _cdafdg != nil {
					return _cdafdg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorTickMark"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorTickMark"}:
				_efbbg.MajorTickMark = NewCT_TickMark()
				if _dced := d.DecodeElement(_efbbg.MajorTickMark, &_ggddg); _dced != nil {
					return _dced
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorTickMark"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorTickMark"}:
				_efbbg.MinorTickMark = NewCT_TickMark()
				if _ffcff := d.DecodeElement(_efbbg.MinorTickMark, &_ggddg); _ffcff != nil {
					return _ffcff
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tickLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tickLblPos"}:
				_efbbg.TickLblPos = NewCT_TickLblPos()
				if _fffde := d.DecodeElement(_efbbg.TickLblPos, &_ggddg); _fffde != nil {
					return _fffde
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_efbbg.SpPr = _cb.NewCT_ShapeProperties()
				if _ffece := d.DecodeElement(_efbbg.SpPr, &_ggddg); _ffece != nil {
					return _ffece
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_efbbg.TxPr = _cb.NewCT_TextBody()
				if _dcdc := d.DecodeElement(_efbbg.TxPr, &_ggddg); _dcdc != nil {
					return _dcdc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossAx"}:
				if _bcdc := d.DecodeElement(_efbbg.CrossAx, &_ggddg); _bcdc != nil {
					return _bcdc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crosses"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crosses"}:
				_efbbg.Choice = NewEG_AxSharedChoice()
				if _cbcfa := d.DecodeElement(&_efbbg.Choice.Crosses, &_ggddg); _cbcfa != nil {
					return _cbcfa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossesAt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossesAt"}:
				_efbbg.Choice = NewEG_AxSharedChoice()
				if _ceefb := d.DecodeElement(&_efbbg.Choice.CrossesAt, &_ggddg); _ceefb != nil {
					return _ceefb
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_AxShared\u0020\u0025v", _ggddg.Name)
				if _gcdeg := d.Skip(); _gcdeg != nil {
					return _gcdeg
				}
			}
		case _fa.EndElement:
			break _ebgbd
		case _fa.CharData:
		}
	}
	return nil
}
func (_bcfbd ST_BarDir) String() string {
	switch _bcfbd {
	case 0:
		return ""
	case 1:
		return "bar"
	case 2:
		return "col"
	}
	return ""
}

// ValidateWithPath validates the CT_UpDownBars and its children, prefixing error messages with path
func (_ddbe *CT_UpDownBars) ValidateWithPath(path string) error {
	if _ddbe.GapWidth != nil {
		if _gbaba := _ddbe.GapWidth.ValidateWithPath(path + "\u002fGapWidth"); _gbaba != nil {
			return _gbaba
		}
	}
	if _ddbe.UpBars != nil {
		if _effdf := _ddbe.UpBars.ValidateWithPath(path + "\u002fUpBars"); _effdf != nil {
			return _effdf
		}
	}
	if _ddbe.DownBars != nil {
		if _fdafa := _ddbe.DownBars.ValidateWithPath(path + "\u002fDownBars"); _fdafa != nil {
			return _fdafa
		}
	}
	if _ddbe.ExtLst != nil {
		if _egfbf := _ddbe.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _egfbf != nil {
			return _egfbf
		}
	}
	return nil
}
func NewCT_DPt() *CT_DPt { _bfgb := &CT_DPt{}; _bfgb.Idx = NewCT_UnsignedInt(); return _bfgb }
func NewCT_ErrBars() *CT_ErrBars {
	_befbe := &CT_ErrBars{}
	_befbe.ErrBarType = NewCT_ErrBarType()
	_befbe.ErrValType = NewCT_ErrValType()
	return _befbe
}
func NewCT_StrVal() *CT_StrVal { _cgae := &CT_StrVal{}; return _cgae }
func (_cdfef *EG_PieChartShared) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _cdfef.VaryColors != nil {
		_gabbg := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_cdfef.VaryColors, _gabbg)
	}
	if _cdfef.Ser != nil {
		_debgg := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _bfbb := range _cdfef.Ser {
			e.EncodeElement(_bfbb, _debgg)
		}
	}
	if _cdfef.DLbls != nil {
		_dddf := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_cdfef.DLbls, _dddf)
	}
	return nil
}
func (_ffaf *CT_TextLanguageID) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _dgcace := range start.Attr {
		if _dgcace.Name.Local == "val" {
			_eeefg, _eeecg := _dgcace.Value, error(nil)
			if _eeecg != nil {
				return _eeecg
			}
			_ffaf.ValAttr = _eeefg
			continue
		}
	}
	for {
		_efbdb, _ccbfb := d.Token()
		if _ccbfb != nil {
			return _gg.Errorf("parsing\u0020CT_TextLanguageID: \u0025s", _ccbfb)
		}
		if _ecbbb, _ceeff := _efbdb.(_fa.EndElement); _ceeff && _ecbbb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gaaf *CT_DLbls) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_dbad:
	for {
		_fgfe, _geeg := d.Token()
		if _geeg != nil {
			return _geeg
		}
		switch _aeag := _fgfe.(type) {
		case _fa.StartElement:
			switch _aeag.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbl"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbl"}:
				_cdbc := NewCT_DLbl()
				if _cbfb := d.DecodeElement(_cdbc, &_aeag); _cbfb != nil {
					return _cbfb
				}
				_gaaf.DLbl = append(_gaaf.DLbl, _cdbc)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "delete"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "delete"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _aee := d.DecodeElement(&_gaaf.Choice.Delete, &_aeag); _aee != nil {
					return _aee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _feggb := d.DecodeElement(&_gaaf.Choice.NumFmt, &_aeag); _feggb != nil {
					return _feggb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _ebbf := d.DecodeElement(&_gaaf.Choice.SpPr, &_aeag); _ebbf != nil {
					return _ebbf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _fbeb := d.DecodeElement(&_gaaf.Choice.TxPr, &_aeag); _fbeb != nil {
					return _fbeb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLblPos"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _fcda := d.DecodeElement(&_gaaf.Choice.DLblPos, &_aeag); _fcda != nil {
					return _fcda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showLegendKey"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showLegendKey"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _ffdb := d.DecodeElement(&_gaaf.Choice.ShowLegendKey, &_aeag); _ffdb != nil {
					return _ffdb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showVal"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showVal"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _eaeb := d.DecodeElement(&_gaaf.Choice.ShowVal, &_aeag); _eaeb != nil {
					return _eaeb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showCatName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showCatName"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _gfde := d.DecodeElement(&_gaaf.Choice.ShowCatName, &_aeag); _gfde != nil {
					return _gfde
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showSerName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showSerName"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _cefd := d.DecodeElement(&_gaaf.Choice.ShowSerName, &_aeag); _cefd != nil {
					return _cefd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showPercent"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showPercent"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _addb := d.DecodeElement(&_gaaf.Choice.ShowPercent, &_aeag); _addb != nil {
					return _addb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showBubbleSize"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showBubbleSize"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _begaa := d.DecodeElement(&_gaaf.Choice.ShowBubbleSize, &_aeag); _begaa != nil {
					return _begaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "separator"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "separator"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _becf := d.DecodeElement(&_gaaf.Choice.Separator, &_aeag); _becf != nil {
					return _becf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showLeaderLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showLeaderLines"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _baee := d.DecodeElement(&_gaaf.Choice.ShowLeaderLines, &_aeag); _baee != nil {
					return _baee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "leaderLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "leaderLines"}:
				if _gaaf.Choice == nil {
					_gaaf.Choice = NewCT_DLblsChoice()
				}
				if _fcafc := d.DecodeElement(&_gaaf.Choice.LeaderLines, &_aeag); _fcafc != nil {
					return _fcafc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_gaaf.ExtLst = NewCT_ExtensionList()
				if _gcga := d.DecodeElement(_gaaf.ExtLst, &_aeag); _gcga != nil {
					return _gcga
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DLbls\u0020\u0025v", _aeag.Name)
				if _bfga := d.Skip(); _bfga != nil {
					return _bfga
				}
			}
		case _fa.EndElement:
			break _dbad
		case _fa.CharData:
		}
	}
	return nil
}
func (_ebfcd *CT_ExtensionList) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _ebfcd.Ext != nil {
		_bfcd := _fa.StartElement{Name: _fa.Name{Local: "c:ext"}}
		for _, _dceg := range _ebfcd.Ext {
			e.EncodeElement(_dceg, _bfcd)
		}
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_acbf *CT_ChartSpace) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_acbf.Chart = NewCT_Chart()
_egbe:
	for {
		_cebec, _feeg := d.Token()
		if _feeg != nil {
			return _feeg
		}
		switch _dgba := _cebec.(type) {
		case _fa.StartElement:
			switch _dgba.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "date1904"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "date1904"}:
				_acbf.Date1904 = NewCT_Boolean()
				if _gdd := d.DecodeElement(_acbf.Date1904, &_dgba); _gdd != nil {
					return _gdd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "lang"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "lang"}:
				_acbf.Lang = NewCT_TextLanguageID()
				if _bada := d.DecodeElement(_acbf.Lang, &_dgba); _bada != nil {
					return _bada
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "roundedCorners"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "roundedCorners"}:
				_acbf.RoundedCorners = NewCT_Boolean()
				if _bfg := d.DecodeElement(_acbf.RoundedCorners, &_dgba); _bfg != nil {
					return _bfg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "style"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "style"}:
				_acbf.Style = NewCT_Style()
				if _ebaf := d.DecodeElement(_acbf.Style, &_dgba); _ebaf != nil {
					return _ebaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "clrMapOvr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "clrMapOvr"}:
				_acbf.ClrMapOvr = _cb.NewCT_ColorMapping()
				if _bbdad := d.DecodeElement(_acbf.ClrMapOvr, &_dgba); _bbdad != nil {
					return _bbdad
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pivotSource"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pivotSource"}:
				_acbf.PivotSource = NewCT_PivotSource()
				if _cdacf := d.DecodeElement(_acbf.PivotSource, &_dgba); _cdacf != nil {
					return _cdacf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "protection"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "protection"}:
				_acbf.Protection = NewCT_Protection()
				if _fcaba := d.DecodeElement(_acbf.Protection, &_dgba); _fcaba != nil {
					return _fcaba
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "chart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "chart"}:
				if _fedf := d.DecodeElement(_acbf.Chart, &_dgba); _fedf != nil {
					return _fedf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_acbf.SpPr = _cb.NewCT_ShapeProperties()
				if _cadc := d.DecodeElement(_acbf.SpPr, &_dgba); _cadc != nil {
					return _cadc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_acbf.TxPr = _cb.NewCT_TextBody()
				if _cfdgd := d.DecodeElement(_acbf.TxPr, &_dgba); _cfdgd != nil {
					return _cfdgd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "externalData"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "externalData"}:
				_acbf.ExternalData = NewCT_ExternalData()
				if _afbaa := d.DecodeElement(_acbf.ExternalData, &_dgba); _afbaa != nil {
					return _afbaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "printSettings"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "printSettings"}:
				_acbf.PrintSettings = NewCT_PrintSettings()
				if _gacbf := d.DecodeElement(_acbf.PrintSettings, &_dgba); _gacbf != nil {
					return _gacbf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "userShapes"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "userShapes"}:
				_acbf.UserShapes = NewCT_RelId()
				if _dea := d.DecodeElement(_acbf.UserShapes, &_dgba); _dea != nil {
					return _dea
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_acbf.ExtLst = NewCT_ExtensionList()
				if _dagf := d.DecodeElement(_acbf.ExtLst, &_dgba); _dagf != nil {
					return _dagf
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_ChartSpace \u0025v", _dgba.Name)
				if _ccfe := d.Skip(); _ccfe != nil {
					return _ccfe
				}
			}
		case _fa.EndElement:
			break _egbe
		case _fa.CharData:
		}
	}
	return nil
}

type CT_PieSer struct {
	Idx       *CT_UnsignedInt
	Order     *CT_UnsignedInt
	Tx        *CT_SerTx
	SpPr      *_cb.CT_ShapeProperties
	Explosion *CT_UnsignedInt
	DPt       []*CT_DPt
	DLbls     *CT_DLbls
	Cat       *CT_AxDataSource
	Val       *CT_NumDataSource
	ExtLst    *CT_ExtensionList
}

// Validate validates the CT_PictureStackUnit and its children
func (_cfef *CT_PictureStackUnit) Validate() error {
	return _cfef.ValidateWithPath("CT_PictureStackUnit")
}

// ValidateWithPath validates the CT_Grouping and its children, prefixing error messages with path
func (_fcbfd *CT_Grouping) ValidateWithPath(path string) error {
	if _bgaf := _fcbfd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bgaf != nil {
		return _bgaf
	}
	return nil
}

// ValidateWithPath validates the CT_Extension and its children, prefixing error messages with path
func (_bdge *CT_Extension) ValidateWithPath(path string) error { return nil }
func (_adafg *ST_TrendlineType) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_adafg = 0
	case "exp":
		*_adafg = 1
	case "linear":
		*_adafg = 2
	case "log":
		*_adafg = 3
	case "movingAvg":
		*_adafg = 4
	case "poly":
		*_adafg = 5
	case "power":
		*_adafg = 6
	}
	return nil
}
func (_deedc *CT_LayoutTarget) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _abfc := range start.Attr {
		if _abfc.Name.Local == "val" {
			_deedc.ValAttr.UnmarshalXMLAttr(_abfc)
			continue
		}
	}
	for {
		_feda, _befbb := d.Token()
		if _befbb != nil {
			return _gg.Errorf("parsing CT_LayoutTarget:\u0020\u0025s", _befbb)
		}
		if _bcde, _ebcg := _feda.(_fa.EndElement); _ebcg && _bcde.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_MarkerStyleUnset    ST_MarkerStyle = 0
	ST_MarkerStyleCircle   ST_MarkerStyle = 1
	ST_MarkerStyleDash     ST_MarkerStyle = 2
	ST_MarkerStyleDiamond  ST_MarkerStyle = 3
	ST_MarkerStyleDot      ST_MarkerStyle = 4
	ST_MarkerStyleNone     ST_MarkerStyle = 5
	ST_MarkerStylePicture  ST_MarkerStyle = 6
	ST_MarkerStylePlus     ST_MarkerStyle = 7
	ST_MarkerStyleSquare   ST_MarkerStyle = 8
	ST_MarkerStyleStar     ST_MarkerStyle = 9
	ST_MarkerStyleTriangle ST_MarkerStyle = 10
	ST_MarkerStyleX        ST_MarkerStyle = 11
	ST_MarkerStyleAuto     ST_MarkerStyle = 12
)

// ValidateWithPath validates the CT_PlotArea and its children, prefixing error messages with path
func (_cbcff *CT_PlotArea) ValidateWithPath(path string) error {
	if _cbcff.Layout != nil {
		if _egbd := _cbcff.Layout.ValidateWithPath(path + "\u002fLayout"); _egbd != nil {
			return _egbd
		}
	}
	for _dbbgc, _adec := range _cbcff.Choice {
		if _acff := _adec.ValidateWithPath(_gg.Sprintf("\u0025s\u002fChoice\u005b\u0025d\u005d", path, _dbbgc)); _acff != nil {
			return _acff
		}
	}
	if _cbcff.CChoice != nil {
		if _dgdff := _cbcff.CChoice.ValidateWithPath(path + "\u002fCChoice"); _dgdff != nil {
			return _dgdff
		}
	}
	if _cbcff.DTable != nil {
		if _afbgd := _cbcff.DTable.ValidateWithPath(path + "\u002fDTable"); _afbgd != nil {
			return _afbgd
		}
	}
	if _cbcff.SpPr != nil {
		if _ffbd := _cbcff.SpPr.ValidateWithPath(path + "\u002fSpPr"); _ffbd != nil {
			return _ffbd
		}
	}
	if _cbcff.ExtLst != nil {
		if _dgffc := _cbcff.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dgffc != nil {
			return _dgffc
		}
	}
	return nil
}

type CT_RelId struct{ IdAttr string }

// Validate validates the CT_ChartLines and its children
func (_bdac *CT_ChartLines) Validate() error { return _bdac.ValidateWithPath("CT_ChartLines") }
func (_fefba *CT_PageSetup) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _fefba.PaperSizeAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "paperSize"}, Value: _gg.Sprintf("\u0025v", *_fefba.PaperSizeAttr)})
	}
	if _fefba.PaperHeightAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "paperHeight"}, Value: _gg.Sprintf("\u0025v", *_fefba.PaperHeightAttr)})
	}
	if _fefba.PaperWidthAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "paperWidth"}, Value: _gg.Sprintf("\u0025v", *_fefba.PaperWidthAttr)})
	}
	if _fefba.FirstPageNumberAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "firstPageNumber"}, Value: _gg.Sprintf("\u0025v", *_fefba.FirstPageNumberAttr)})
	}
	if _fefba.OrientationAttr != ST_PageSetupOrientationUnset {
		_ecbe, _dgce := _fefba.OrientationAttr.MarshalXMLAttr(_fa.Name{Local: "orientation"})
		if _dgce != nil {
			return _dgce
		}
		start.Attr = append(start.Attr, _ecbe)
	}
	if _fefba.BlackAndWhiteAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "blackAndWhite"}, Value: _gg.Sprintf("\u0025d", _feaac(*_fefba.BlackAndWhiteAttr))})
	}
	if _fefba.DraftAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "draft"}, Value: _gg.Sprintf("\u0025d", _feaac(*_fefba.DraftAttr))})
	}
	if _fefba.UseFirstPageNumberAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "useFirstPageNumber"}, Value: _gg.Sprintf("\u0025d", _feaac(*_fefba.UseFirstPageNumberAttr))})
	}
	if _fefba.HorizontalDpiAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "horizontalDpi"}, Value: _gg.Sprintf("\u0025v", *_fefba.HorizontalDpiAttr)})
	}
	if _fefba.VerticalDpiAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "verticalDpi"}, Value: _gg.Sprintf("\u0025v", *_fefba.VerticalDpiAttr)})
	}
	if _fefba.CopiesAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "copies"}, Value: _gg.Sprintf("\u0025v", *_fefba.CopiesAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_BandFmt and its children
func (_bbdg *CT_BandFmt) Validate() error { return _bbdg.ValidateWithPath("CT_BandFmt") }

// Validate validates the CT_Surface3DChart and its children
func (_ffebc *CT_Surface3DChart) Validate() error {
	return _ffebc.ValidateWithPath("CT_Surface3DChart")
}
func (_efbg *CT_SerAx) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_bbfgeb := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	e.EncodeElement(_efbg.AxId, _bbfgeb)
	_bceaga := _fa.StartElement{Name: _fa.Name{Local: "c:scaling"}}
	e.EncodeElement(_efbg.Scaling, _bceaga)
	if _efbg.Delete != nil {
		_cacbd := _fa.StartElement{Name: _fa.Name{Local: "c:delete"}}
		e.EncodeElement(_efbg.Delete, _cacbd)
	}
	_cedfg := _fa.StartElement{Name: _fa.Name{Local: "c:axPos"}}
	e.EncodeElement(_efbg.AxPos, _cedfg)
	if _efbg.MajorGridlines != nil {
		_fbceg := _fa.StartElement{Name: _fa.Name{Local: "c:majorGridlines"}}
		e.EncodeElement(_efbg.MajorGridlines, _fbceg)
	}
	if _efbg.MinorGridlines != nil {
		_ffbf := _fa.StartElement{Name: _fa.Name{Local: "c:minorGridlines"}}
		e.EncodeElement(_efbg.MinorGridlines, _ffbf)
	}
	if _efbg.Title != nil {
		_fgfd := _fa.StartElement{Name: _fa.Name{Local: "c:title"}}
		e.EncodeElement(_efbg.Title, _fgfd)
	}
	if _efbg.NumFmt != nil {
		_efcca := _fa.StartElement{Name: _fa.Name{Local: "c:numFmt"}}
		e.EncodeElement(_efbg.NumFmt, _efcca)
	}
	if _efbg.MajorTickMark != nil {
		_gfcac := _fa.StartElement{Name: _fa.Name{Local: "c:majorTickMark"}}
		e.EncodeElement(_efbg.MajorTickMark, _gfcac)
	}
	if _efbg.MinorTickMark != nil {
		_facff := _fa.StartElement{Name: _fa.Name{Local: "c:minorTickMark"}}
		e.EncodeElement(_efbg.MinorTickMark, _facff)
	}
	if _efbg.TickLblPos != nil {
		_gbcfb := _fa.StartElement{Name: _fa.Name{Local: "c:tickLblPos"}}
		e.EncodeElement(_efbg.TickLblPos, _gbcfb)
	}
	if _efbg.SpPr != nil {
		_dcae := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_efbg.SpPr, _dcae)
	}
	if _efbg.TxPr != nil {
		_eegg := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_efbg.TxPr, _eegg)
	}
	_dfgbd := _fa.StartElement{Name: _fa.Name{Local: "c:crossAx"}}
	e.EncodeElement(_efbg.CrossAx, _dfgbd)
	if _efbg.Choice != nil {
		_efbg.Choice.MarshalXML(e, _fa.StartElement{})
	}
	if _efbg.TickLblSkip != nil {
		_dbgcg := _fa.StartElement{Name: _fa.Name{Local: "c:tickLblSkip"}}
		e.EncodeElement(_efbg.TickLblSkip, _dbgcg)
	}
	if _efbg.TickMarkSkip != nil {
		_ccda := _fa.StartElement{Name: _fa.Name{Local: "c:tickMarkSkip"}}
		e.EncodeElement(_efbg.TickMarkSkip, _ccda)
	}
	if _efbg.ExtLst != nil {
		_fffbe := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_efbg.ExtLst, _fffbe)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_dad *CT_BubbleSer) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_dad.Idx = NewCT_UnsignedInt()
	_dad.Order = NewCT_UnsignedInt()
_cac:
	for {
		_ccg, _cbf := d.Token()
		if _cbf != nil {
			return _cbf
		}
		switch _daag := _ccg.(type) {
		case _fa.StartElement:
			switch _daag.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _fdf := d.DecodeElement(_dad.Idx, &_daag); _fdf != nil {
					return _fdf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "order"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "order"}:
				if _bfcb := d.DecodeElement(_dad.Order, &_daag); _bfcb != nil {
					return _bfcb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_dad.Tx = NewCT_SerTx()
				if _cggb := d.DecodeElement(_dad.Tx, &_daag); _cggb != nil {
					return _cggb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_dad.SpPr = _cb.NewCT_ShapeProperties()
				if _gcb := d.DecodeElement(_dad.SpPr, &_daag); _gcb != nil {
					return _gcb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "invertIfNegative"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "invertIfNegative"}:
				_dad.InvertIfNegative = NewCT_Boolean()
				if _abbd := d.DecodeElement(_dad.InvertIfNegative, &_daag); _abbd != nil {
					return _abbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dPt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dPt"}:
				_ccefg := NewCT_DPt()
				if _ceab := d.DecodeElement(_ccefg, &_daag); _ceab != nil {
					return _ceab
				}
				_dad.DPt = append(_dad.DPt, _ccefg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_dad.DLbls = NewCT_DLbls()
				if _cbcb := d.DecodeElement(_dad.DLbls, &_daag); _cbcb != nil {
					return _cbcb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "trendline"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "trendline"}:
				_fge := NewCT_Trendline()
				if _ada := d.DecodeElement(_fge, &_daag); _ada != nil {
					return _ada
				}
				_dad.Trendline = append(_dad.Trendline, _fge)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "errBars"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "errBars"}:
				_defc := NewCT_ErrBars()
				if _dgea := d.DecodeElement(_defc, &_daag); _dgea != nil {
					return _dgea
				}
				_dad.ErrBars = append(_dad.ErrBars, _defc)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "xVal"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "xVal"}:
				_dad.XVal = NewCT_AxDataSource()
				if _fcgbe := d.DecodeElement(_dad.XVal, &_daag); _fcgbe != nil {
					return _fcgbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "yVal"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "yVal"}:
				_dad.YVal = NewCT_NumDataSource()
				if _bfce := d.DecodeElement(_dad.YVal, &_daag); _bfce != nil {
					return _bfce
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bubbleSize"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bubbleSize"}:
				_dad.BubbleSize = NewCT_NumDataSource()
				if _aeb := d.DecodeElement(_dad.BubbleSize, &_daag); _aeb != nil {
					return _aeb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bubble3D"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bubble3D"}:
				_dad.Bubble3D = NewCT_Boolean()
				if _beeee := d.DecodeElement(_dad.Bubble3D, &_daag); _beeee != nil {
					return _beeee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_dad.ExtLst = NewCT_ExtensionList()
				if _fddd := d.DecodeElement(_dad.ExtLst, &_daag); _fddd != nil {
					return _fddd
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BubbleSer\u0020\u0025v", _daag.Name)
				if _cfee := d.Skip(); _cfee != nil {
					return _cfee
				}
			}
		case _fa.EndElement:
			break _cac
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_StrVal and its children, prefixing error messages with path
func (_cgeab *CT_StrVal) ValidateWithPath(path string) error { return nil }
func (_cfda *CT_DispUnits) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_acbb:
	for {
		_gfeba, _gdga := d.Token()
		if _gdga != nil {
			return _gdga
		}
		switch _daea := _gfeba.(type) {
		case _fa.StartElement:
			switch _daea.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "custUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "custUnit"}:
				_cfda.Choice = NewCT_DispUnitsChoice()
				if _dagae := d.DecodeElement(&_cfda.Choice.CustUnit, &_daea); _dagae != nil {
					return _dagae
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "builtInUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "builtInUnit"}:
				_cfda.Choice = NewCT_DispUnitsChoice()
				if _bbec := d.DecodeElement(&_cfda.Choice.BuiltInUnit, &_daea); _bbec != nil {
					return _bbec
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dispUnitsLbl"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dispUnitsLbl"}:
				_cfda.DispUnitsLbl = NewCT_DispUnitsLbl()
				if _agaaf := d.DecodeElement(_cfda.DispUnitsLbl, &_daea); _agaaf != nil {
					return _agaaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_cfda.ExtLst = NewCT_ExtensionList()
				if _efee := d.DecodeElement(_cfda.ExtLst, &_daea); _efee != nil {
					return _efee
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DispUnits\u0020\u0025v", _daea.Name)
				if _bcaga := d.Skip(); _bcaga != nil {
					return _bcaga
				}
			}
		case _fa.EndElement:
			break _acbb
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ScatterStyle and its children, prefixing error messages with path
func (_abcf *CT_ScatterStyle) ValidateWithPath(path string) error {
	if _bfaeg := _abcf.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bfaeg != nil {
		return _bfaeg
	}
	return nil
}
func (_aafbb *CT_Skip) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", _aafbb.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_HeaderFooter and its children
func (_bdce *CT_HeaderFooter) Validate() error { return _bdce.ValidateWithPath("CT_HeaderFooter") }
func (_cdce *CT_CustSplit) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _cdce.SecondPiePt != nil {
		_eebb := _fa.StartElement{Name: _fa.Name{Local: "c:secondPiePt"}}
		for _, _caae := range _cdce.SecondPiePt {
			e.EncodeElement(_caae, _eebb)
		}
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type ST_TrendlineType byte

func (_bagfe ST_PageSetupOrientation) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_cgdcc := _fa.Attr{}
	_cgdcc.Name = name
	switch _bagfe {
	case ST_PageSetupOrientationUnset:
		_cgdcc.Value = ""
	case ST_PageSetupOrientationDefault:
		_cgdcc.Value = "default"
	case ST_PageSetupOrientationPortrait:
		_cgdcc.Value = "portrait"
	case ST_PageSetupOrientationLandscape:
		_cgdcc.Value = "landscape"
	}
	return _cgdcc, nil
}

// ValidateWithPath validates the CT_Shape and its children, prefixing error messages with path
func (_eadbe *CT_Shape) ValidateWithPath(path string) error {
	if _feffa := _eadbe.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _feffa != nil {
		return _feffa
	}
	return nil
}
func (_egebb *EG_BarChartShared) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_fdgf := _fa.StartElement{Name: _fa.Name{Local: "c:barDir"}}
	e.EncodeElement(_egebb.BarDir, _fdgf)
	if _egebb.Grouping != nil {
		_fdeg := _fa.StartElement{Name: _fa.Name{Local: "c:grouping"}}
		e.EncodeElement(_egebb.Grouping, _fdeg)
	}
	if _egebb.VaryColors != nil {
		_gebgc := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_egebb.VaryColors, _gebgc)
	}
	if _egebb.Ser != nil {
		_gcgee := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _dfeeb := range _egebb.Ser {
			e.EncodeElement(_dfeeb, _gcgee)
		}
	}
	if _egebb.DLbls != nil {
		_bfgba := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_egebb.DLbls, _bfgba)
	}
	return nil
}
func (_abcaf *CT_Overlap) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _abcaf.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_abcaf.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ValAx and its children, prefixing error messages with path
func (_efgeg *CT_ValAx) ValidateWithPath(path string) error {
	if _adde := _efgeg.AxId.ValidateWithPath(path + "\u002fAxId"); _adde != nil {
		return _adde
	}
	if _bacee := _efgeg.Scaling.ValidateWithPath(path + "\u002fScaling"); _bacee != nil {
		return _bacee
	}
	if _efgeg.Delete != nil {
		if _beaae := _efgeg.Delete.ValidateWithPath(path + "\u002fDelete"); _beaae != nil {
			return _beaae
		}
	}
	if _dcaa := _efgeg.AxPos.ValidateWithPath(path + "\u002fAxPos"); _dcaa != nil {
		return _dcaa
	}
	if _efgeg.MajorGridlines != nil {
		if _fabdc := _efgeg.MajorGridlines.ValidateWithPath(path + "\u002fMajorGridlines"); _fabdc != nil {
			return _fabdc
		}
	}
	if _efgeg.MinorGridlines != nil {
		if _badbg := _efgeg.MinorGridlines.ValidateWithPath(path + "\u002fMinorGridlines"); _badbg != nil {
			return _badbg
		}
	}
	if _efgeg.Title != nil {
		if _bdbdcg := _efgeg.Title.ValidateWithPath(path + "\u002fTitle"); _bdbdcg != nil {
			return _bdbdcg
		}
	}
	if _efgeg.NumFmt != nil {
		if _ebbba := _efgeg.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _ebbba != nil {
			return _ebbba
		}
	}
	if _efgeg.MajorTickMark != nil {
		if _ggbgb := _efgeg.MajorTickMark.ValidateWithPath(path + "\u002fMajorTickMark"); _ggbgb != nil {
			return _ggbgb
		}
	}
	if _efgeg.MinorTickMark != nil {
		if _acffg := _efgeg.MinorTickMark.ValidateWithPath(path + "\u002fMinorTickMark"); _acffg != nil {
			return _acffg
		}
	}
	if _efgeg.TickLblPos != nil {
		if _aeab := _efgeg.TickLblPos.ValidateWithPath(path + "/TickLblPos"); _aeab != nil {
			return _aeab
		}
	}
	if _efgeg.SpPr != nil {
		if _gdde := _efgeg.SpPr.ValidateWithPath(path + "\u002fSpPr"); _gdde != nil {
			return _gdde
		}
	}
	if _efgeg.TxPr != nil {
		if _dacgg := _efgeg.TxPr.ValidateWithPath(path + "\u002fTxPr"); _dacgg != nil {
			return _dacgg
		}
	}
	if _cgfaae := _efgeg.CrossAx.ValidateWithPath(path + "\u002fCrossAx"); _cgfaae != nil {
		return _cgfaae
	}
	if _efgeg.Choice != nil {
		if _ebfab := _efgeg.Choice.ValidateWithPath(path + "\u002fChoice"); _ebfab != nil {
			return _ebfab
		}
	}
	if _efgeg.CrossBetween != nil {
		if _aagc := _efgeg.CrossBetween.ValidateWithPath(path + "\u002fCrossBetween"); _aagc != nil {
			return _aagc
		}
	}
	if _efgeg.MajorUnit != nil {
		if _cgbef := _efgeg.MajorUnit.ValidateWithPath(path + "\u002fMajorUnit"); _cgbef != nil {
			return _cgbef
		}
	}
	if _efgeg.MinorUnit != nil {
		if _fgbed := _efgeg.MinorUnit.ValidateWithPath(path + "\u002fMinorUnit"); _fgbed != nil {
			return _fgbed
		}
	}
	if _efgeg.DispUnits != nil {
		if _cedc := _efgeg.DispUnits.ValidateWithPath(path + "\u002fDispUnits"); _cedc != nil {
			return _cedc
		}
	}
	if _efgeg.ExtLst != nil {
		if _abefeb := _efgeg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _abefeb != nil {
			return _abefeb
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TickMark and its children, prefixing error messages with path
func (_aafbe *CT_TickMark) ValidateWithPath(path string) error {
	if _gfcea := _aafbe.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _gfcea != nil {
		return _gfcea
	}
	return nil
}

type CT_TimeUnit struct{ ValAttr ST_TimeUnit }

func (_abed ST_AxPos) String() string {
	switch _abed {
	case 0:
		return ""
	case 1:
		return "b"
	case 2:
		return "l"
	case 3:
		return "r"
	case 4:
		return "t"
	}
	return ""
}
func (_cfgfc *CT_Surface) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _cfgfc.Thickness != nil {
		_cdgfd := _fa.StartElement{Name: _fa.Name{Local: "c:thickness"}}
		e.EncodeElement(_cfgfc.Thickness, _cdgfd)
	}
	if _cfgfc.SpPr != nil {
		_acdgb := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_cfgfc.SpPr, _acdgb)
	}
	if _cfgfc.PictureOptions != nil {
		_edag := _fa.StartElement{Name: _fa.Name{Local: "c:pictureOptions"}}
		e.EncodeElement(_cfgfc.PictureOptions, _edag)
	}
	if _cfgfc.ExtLst != nil {
		_cgaa := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_cfgfc.ExtLst, _cgaa)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_efgg *CT_PieChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _efgg.VaryColors != nil {
		_dacb := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_efgg.VaryColors, _dacb)
	}
	if _efgg.Ser != nil {
		_bcbg := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _cdaag := range _efgg.Ser {
			e.EncodeElement(_cdaag, _bcbg)
		}
	}
	if _efgg.DLbls != nil {
		_begbe := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_efgg.DLbls, _begbe)
	}
	if _efgg.FirstSliceAng != nil {
		_dade := _fa.StartElement{Name: _fa.Name{Local: "c:firstSliceAng"}}
		e.EncodeElement(_efgg.FirstSliceAng, _dade)
	}
	if _efgg.ExtLst != nil {
		_fefab := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_efgg.ExtLst, _fefab)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_LayoutMode() *CT_LayoutMode { _bbce := &CT_LayoutMode{}; return _bbce }
func (_dgcf *CT_Extension) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _edefc := range start.Attr {
		if _edefc.Name.Local == "uri" {
			_ddcgb, _ddcge := _edefc.Value, error(nil)
			if _ddcge != nil {
				return _ddcge
			}
			_dgcf.UriAttr = &_ddcgb
			continue
		}
	}
_dfad:
	for {
		_defb, _eafd := d.Token()
		if _eafd != nil {
			return _eafd
		}
		switch _egba := _defb.(type) {
		case _fa.StartElement:
			switch _egba.Name {
			default:
				if _gdca, _dggf := _b.CreateElement(_egba); _dggf != nil {
					return _dggf
				} else {
					if _fefb := d.DecodeElement(_gdca, &_egba); _fefb != nil {
						return _fefb
					}
					_dgcf.Any = _gdca
				}
			}
		case _fa.EndElement:
			break _dfad
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Period and its children, prefixing error messages with path
func (_bdcd *CT_Period) ValidateWithPath(path string) error {
	if _bdcd.ValAttr != nil {
		if *_bdcd.ValAttr < 2 {
			return _gg.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00202\u0020\u0028have\u0020\u0025v\u0029", path, *_bdcd.ValAttr)
		}
	}
	return nil
}

// ValidateWithPath validates the CT_DPt and its children, prefixing error messages with path
func (_gefb *CT_DPt) ValidateWithPath(path string) error {
	if _fefg := _gefb.Idx.ValidateWithPath(path + "\u002fIdx"); _fefg != nil {
		return _fefg
	}
	if _gefb.InvertIfNegative != nil {
		if _fdfa := _gefb.InvertIfNegative.ValidateWithPath(path + "\u002fInvertIfNegative"); _fdfa != nil {
			return _fdfa
		}
	}
	if _gefb.Marker != nil {
		if _bcfb := _gefb.Marker.ValidateWithPath(path + "\u002fMarker"); _bcfb != nil {
			return _bcfb
		}
	}
	if _gefb.Bubble3D != nil {
		if _beaf := _gefb.Bubble3D.ValidateWithPath(path + "\u002fBubble3D"); _beaf != nil {
			return _beaf
		}
	}
	if _gefb.Explosion != nil {
		if _ccce := _gefb.Explosion.ValidateWithPath(path + "\u002fExplosion"); _ccce != nil {
			return _ccce
		}
	}
	if _gefb.SpPr != nil {
		if _cga := _gefb.SpPr.ValidateWithPath(path + "\u002fSpPr"); _cga != nil {
			return _cga
		}
	}
	if _gefb.PictureOptions != nil {
		if _feed := _gefb.PictureOptions.ValidateWithPath(path + "\u002fPictureOptions"); _feed != nil {
			return _feed
		}
	}
	if _gefb.ExtLst != nil {
		if _cbbf := _gefb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cbbf != nil {
			return _cbbf
		}
	}
	return nil
}

// Validate validates the CT_ExternalData and its children
func (_ageb *CT_ExternalData) Validate() error { return _ageb.ValidateWithPath("CT_ExternalData") }

type CT_BandFmts struct{ BandFmt []*CT_BandFmt }

func (_daacdc ST_DLblPos) ValidateWithPath(path string) error {
	switch _daacdc {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_daacdc))
	}
	return nil
}
func (_cddeg *ST_BuiltInUnit) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_cddeg = 0
	case "hundreds":
		*_cddeg = 1
	case "thousands":
		*_cddeg = 2
	case "tenThousands":
		*_cddeg = 3
	case "hundredThousands":
		*_cddeg = 4
	case "millions":
		*_cddeg = 5
	case "tenMillions":
		*_cddeg = 6
	case "hundredMillions":
		*_cddeg = 7
	case "billions":
		*_cddeg = 8
	case "trillions":
		*_cddeg = 9
	}
	return nil
}

type CT_HPercent struct{ ValAttr *ST_HPercent }

// Validate validates the CT_CustSplit and its children
func (_bcdb *CT_CustSplit) Validate() error { return _bcdb.ValidateWithPath("CT_CustSplit") }
func (_ebbgc *ST_ErrDir) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ffbef, _geeba := d.Token()
	if _geeba != nil {
		return _geeba
	}
	if _cbba, _fabec := _ffbef.(_fa.EndElement); _fabec && _cbba.Name == start.Name {
		*_ebbgc = 1
		return nil
	}
	if _cafea, _ebbcd := _ffbef.(_fa.CharData); !_ebbcd {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ffbef)
	} else {
		switch string(_cafea) {
		case "":
			*_ebbgc = 0
		case "x":
			*_ebbgc = 1
		case "y":
			*_ebbgc = 2
		}
	}
	_ffbef, _geeba = d.Token()
	if _geeba != nil {
		return _geeba
	}
	if _cbed, _dacbfa := _ffbef.(_fa.EndElement); _dacbfa && _cbed.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ffbef)
}
func (_adbed *CT_Scaling) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _adbed.LogBase != nil {
		_fcace := _fa.StartElement{Name: _fa.Name{Local: "c:logBase"}}
		e.EncodeElement(_adbed.LogBase, _fcace)
	}
	if _adbed.Orientation != nil {
		_efaag := _fa.StartElement{Name: _fa.Name{Local: "c:orientation"}}
		e.EncodeElement(_adbed.Orientation, _efaag)
	}
	if _adbed.Max != nil {
		_dgcac := _fa.StartElement{Name: _fa.Name{Local: "c:max"}}
		e.EncodeElement(_adbed.Max, _dgcac)
	}
	if _adbed.Min != nil {
		_bcacc := _fa.StartElement{Name: _fa.Name{Local: "c:min"}}
		e.EncodeElement(_adbed.Min, _bcacc)
	}
	if _adbed.ExtLst != nil {
		_badda := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_adbed.ExtLst, _badda)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_GapAmount and its children, prefixing error messages with path
func (_cddb *CT_GapAmount) ValidateWithPath(path string) error {
	if _cddb.ValAttr != nil {
		if _ddda := _cddb.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _ddda != nil {
			return _ddda
		}
	}
	return nil
}
func (_dgfge *ST_PictureFormat) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_dgfge = 0
	case "stretch":
		*_dgfge = 1
	case "stack":
		*_dgfge = 2
	case "stackScale":
		*_dgfge = 3
	}
	return nil
}
func (_gfgg *CT_PageMargins) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _fada := range start.Attr {
		if _fada.Name.Local == "l" {
			_agca, _cfge := _c.ParseFloat(_fada.Value, 64)
			if _cfge != nil {
				return _cfge
			}
			_gfgg.LAttr = _agca
			continue
		}
		if _fada.Name.Local == "r" {
			_cfbe, _ccag := _c.ParseFloat(_fada.Value, 64)
			if _ccag != nil {
				return _ccag
			}
			_gfgg.RAttr = _cfbe
			continue
		}
		if _fada.Name.Local == "t" {
			_fdffc, _befec := _c.ParseFloat(_fada.Value, 64)
			if _befec != nil {
				return _befec
			}
			_gfgg.TAttr = _fdffc
			continue
		}
		if _fada.Name.Local == "b" {
			_decdg, _bcaf := _c.ParseFloat(_fada.Value, 64)
			if _bcaf != nil {
				return _bcaf
			}
			_gfgg.BAttr = _decdg
			continue
		}
		if _fada.Name.Local == "header" {
			_bggf, _ddgba := _c.ParseFloat(_fada.Value, 64)
			if _ddgba != nil {
				return _ddgba
			}
			_gfgg.HeaderAttr = _bggf
			continue
		}
		if _fada.Name.Local == "footer" {
			_eacbc, _cagdg := _c.ParseFloat(_fada.Value, 64)
			if _cagdg != nil {
				return _cagdg
			}
			_gfgg.FooterAttr = _eacbc
			continue
		}
	}
	for {
		_eaefc, _bbgf := d.Token()
		if _bbgf != nil {
			return _gg.Errorf("parsing\u0020CT_PageMargins:\u0020\u0025s", _bbgf)
		}
		if _efbd, _cdgcg := _eaefc.(_fa.EndElement); _cdgcg && _efbd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_abcdd *CT_BandFmt) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_fde := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_abcdd.Idx, _fde)
	if _abcdd.SpPr != nil {
		_cade := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_abcdd.SpPr, _cade)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_Extension struct {
	UriAttr *string
	Any     _b.Any
}

func (_bcbfb *EG_AxSharedChoice) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _bcbfb.Crosses != nil {
		_debcb := _fa.StartElement{Name: _fa.Name{Local: "c:crosses"}}
		e.EncodeElement(_bcbfb.Crosses, _debcb)
	}
	if _bcbfb.CrossesAt != nil {
		_cbae := _fa.StartElement{Name: _fa.Name{Local: "c:crossesAt"}}
		e.EncodeElement(_bcbfb.CrossesAt, _cbae)
	}
	return nil
}
func (_bfaab *CT_PlotAreaChoice) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _bfaab.AreaChart != nil {
		_ddecg := _fa.StartElement{Name: _fa.Name{Local: "c:areaChart"}}
		e.EncodeElement(_bfaab.AreaChart, _ddecg)
	}
	if _bfaab.Area3DChart != nil {
		_bgddc := _fa.StartElement{Name: _fa.Name{Local: "c:area3DChart"}}
		e.EncodeElement(_bfaab.Area3DChart, _bgddc)
	}
	if _bfaab.LineChart != nil {
		_bcecc := _fa.StartElement{Name: _fa.Name{Local: "c:lineChart"}}
		e.EncodeElement(_bfaab.LineChart, _bcecc)
	}
	if _bfaab.Line3DChart != nil {
		_bbeaa := _fa.StartElement{Name: _fa.Name{Local: "c:line3DChart"}}
		e.EncodeElement(_bfaab.Line3DChart, _bbeaa)
	}
	if _bfaab.StockChart != nil {
		_fbefg := _fa.StartElement{Name: _fa.Name{Local: "c:stockChart"}}
		e.EncodeElement(_bfaab.StockChart, _fbefg)
	}
	if _bfaab.RadarChart != nil {
		_fadgb := _fa.StartElement{Name: _fa.Name{Local: "c:radarChart"}}
		e.EncodeElement(_bfaab.RadarChart, _fadgb)
	}
	if _bfaab.ScatterChart != nil {
		_cgefg := _fa.StartElement{Name: _fa.Name{Local: "c:scatterChart"}}
		e.EncodeElement(_bfaab.ScatterChart, _cgefg)
	}
	if _bfaab.PieChart != nil {
		_gedae := _fa.StartElement{Name: _fa.Name{Local: "c:pieChart"}}
		e.EncodeElement(_bfaab.PieChart, _gedae)
	}
	if _bfaab.Pie3DChart != nil {
		_fbecf := _fa.StartElement{Name: _fa.Name{Local: "c:pie3DChart"}}
		e.EncodeElement(_bfaab.Pie3DChart, _fbecf)
	}
	if _bfaab.DoughnutChart != nil {
		_bbca := _fa.StartElement{Name: _fa.Name{Local: "c:doughnutChart"}}
		e.EncodeElement(_bfaab.DoughnutChart, _bbca)
	}
	if _bfaab.BarChart != nil {
		_bfdfeb := _fa.StartElement{Name: _fa.Name{Local: "c:barChart"}}
		e.EncodeElement(_bfaab.BarChart, _bfdfeb)
	}
	if _bfaab.Bar3DChart != nil {
		_faded := _fa.StartElement{Name: _fa.Name{Local: "c:bar3DChart"}}
		e.EncodeElement(_bfaab.Bar3DChart, _faded)
	}
	if _bfaab.OfPieChart != nil {
		_eccbc := _fa.StartElement{Name: _fa.Name{Local: "c:ofPieChart"}}
		e.EncodeElement(_bfaab.OfPieChart, _eccbc)
	}
	if _bfaab.SurfaceChart != nil {
		_defca := _fa.StartElement{Name: _fa.Name{Local: "c:surfaceChart"}}
		e.EncodeElement(_bfaab.SurfaceChart, _defca)
	}
	if _bfaab.Surface3DChart != nil {
		_bdca := _fa.StartElement{Name: _fa.Name{Local: "c:surface3DChart"}}
		e.EncodeElement(_bfaab.Surface3DChart, _bdca)
	}
	if _bfaab.BubbleChart != nil {
		_dadg := _fa.StartElement{Name: _fa.Name{Local: "c:bubbleChart"}}
		e.EncodeElement(_bfaab.BubbleChart, _dadg)
	}
	return nil
}

type EG_SurfaceChartShared struct {
	Wireframe *CT_Boolean
	Ser       []*CT_SurfaceSer
	BandFmts  *CT_BandFmts
}

func (_ccge ST_LegendPos) ValidateWithPath(path string) error {
	switch _ccge {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ccge))
	}
	return nil
}
func (_bacfg *CT_PieSer) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bacfg.Idx = NewCT_UnsignedInt()
	_bacfg.Order = NewCT_UnsignedInt()
_acac:
	for {
		_edgee, _cdde := d.Token()
		if _cdde != nil {
			return _cdde
		}
		switch _caafa := _edgee.(type) {
		case _fa.StartElement:
			switch _caafa.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _dbdf := d.DecodeElement(_bacfg.Idx, &_caafa); _dbdf != nil {
					return _dbdf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "order"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "order"}:
				if _ddbb := d.DecodeElement(_bacfg.Order, &_caafa); _ddbb != nil {
					return _ddbb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_bacfg.Tx = NewCT_SerTx()
				if _cbabc := d.DecodeElement(_bacfg.Tx, &_caafa); _cbabc != nil {
					return _cbabc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_bacfg.SpPr = _cb.NewCT_ShapeProperties()
				if _degb := d.DecodeElement(_bacfg.SpPr, &_caafa); _degb != nil {
					return _degb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "explosion"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "explosion"}:
				_bacfg.Explosion = NewCT_UnsignedInt()
				if _aeda := d.DecodeElement(_bacfg.Explosion, &_caafa); _aeda != nil {
					return _aeda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dPt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dPt"}:
				_dcbg := NewCT_DPt()
				if _dccc := d.DecodeElement(_dcbg, &_caafa); _dccc != nil {
					return _dccc
				}
				_bacfg.DPt = append(_bacfg.DPt, _dcbg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_bacfg.DLbls = NewCT_DLbls()
				if _cagda := d.DecodeElement(_bacfg.DLbls, &_caafa); _cagda != nil {
					return _cagda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "cat"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "cat"}:
				_bacfg.Cat = NewCT_AxDataSource()
				if _bead := d.DecodeElement(_bacfg.Cat, &_caafa); _bead != nil {
					return _bead
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "val"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "val"}:
				_bacfg.Val = NewCT_NumDataSource()
				if _agccd := d.DecodeElement(_bacfg.Val, &_caafa); _agccd != nil {
					return _agccd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_bacfg.ExtLst = NewCT_ExtensionList()
				if _ceabb := d.DecodeElement(_bacfg.ExtLst, &_caafa); _ceabb != nil {
					return _ceabb
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_PieSer \u0025v", _caafa.Name)
				if _fdde := d.Skip(); _fdde != nil {
					return _fdde
				}
			}
		case _fa.EndElement:
			break _acac
		case _fa.CharData:
		}
	}
	return nil
}
func (_gegc ST_MarkerStyle) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_gegc.String(), start)
}

type CT_Trendline struct {
	Name          *string
	SpPr          *_cb.CT_ShapeProperties
	TrendlineType *CT_TrendlineType
	Order         *CT_Order
	Period        *CT_Period
	Forward       *CT_Double
	Backward      *CT_Double
	Intercept     *CT_Double
	DispRSqr      *CT_Boolean
	DispEq        *CT_Boolean
	TrendlineLbl  *CT_TrendlineLbl
	ExtLst        *CT_ExtensionList
}

// Validate validates the CT_LegendEntry and its children
func (_fdag *CT_LegendEntry) Validate() error { return _fdag.ValidateWithPath("CT_LegendEntry") }
func NewEG_BarChartShared() *EG_BarChartShared {
	_eaggf := &EG_BarChartShared{}
	_eaggf.BarDir = NewCT_BarDir()
	return _eaggf
}

// Validate validates the CT_PlotAreaChoice1 and its children
func (_dbaeg *CT_PlotAreaChoice1) Validate() error {
	return _dbaeg.ValidateWithPath("CT_PlotAreaChoice1")
}

const ST_GapAmountPercentPattern = "0\u002a\u0028\u0028\u005b0\u002d9\u005d\u0029|\u0028\u005b1\u002d9\u005d\u005b0-9\u005d\u0029\u007c(\u005b1\u002d4\u005d\u005b0\u002d9][0\u002d9\u005d\u0029\u007c500\u0029\u0025"

func (_bgga *CT_DepthPercent) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _bgga.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_bgga.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_dbge *CT_Crosses) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_efaa, _cfde := _dbge.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
	if _cfde != nil {
		return _cfde
	}
	start.Attr = append(start.Attr, _efaa)
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_PlotAreaChoice1() *CT_PlotAreaChoice1 { _daefb := &CT_PlotAreaChoice1{}; return _daefb }
func (_gfcba *CT_SurfaceSer) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_gfcba.Idx = NewCT_UnsignedInt()
	_gfcba.Order = NewCT_UnsignedInt()
_ccbf:
	for {
		_gaee, _fcfg := d.Token()
		if _fcfg != nil {
			return _fcfg
		}
		switch _acedd := _gaee.(type) {
		case _fa.StartElement:
			switch _acedd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _bdfg := d.DecodeElement(_gfcba.Idx, &_acedd); _bdfg != nil {
					return _bdfg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "order"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "order"}:
				if _aebf := d.DecodeElement(_gfcba.Order, &_acedd); _aebf != nil {
					return _aebf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_gfcba.Tx = NewCT_SerTx()
				if _abbebg := d.DecodeElement(_gfcba.Tx, &_acedd); _abbebg != nil {
					return _abbebg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_gfcba.SpPr = _cb.NewCT_ShapeProperties()
				if _aafd := d.DecodeElement(_gfcba.SpPr, &_acedd); _aafd != nil {
					return _aafd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "cat"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "cat"}:
				_gfcba.Cat = NewCT_AxDataSource()
				if _egdcc := d.DecodeElement(_gfcba.Cat, &_acedd); _egdcc != nil {
					return _egdcc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "val"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "val"}:
				_gfcba.Val = NewCT_NumDataSource()
				if _fdbgb := d.DecodeElement(_gfcba.Val, &_acedd); _fdbgb != nil {
					return _fdbgb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_gfcba.ExtLst = NewCT_ExtensionList()
				if _agbgd := d.DecodeElement(_gfcba.ExtLst, &_acedd); _agbgd != nil {
					return _agbgd
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_SurfaceSer \u0025v", _acedd.Name)
				if _ededb := d.Skip(); _ededb != nil {
					return _ededb
				}
			}
		case _fa.EndElement:
			break _ccbf
		case _fa.CharData:
		}
	}
	return nil
}
func NewCT_AxisUnit() *CT_AxisUnit { _agb := &CT_AxisUnit{}; _agb.ValAttr = 0 + 1; return _agb }

// Validate validates the CT_PivotSource and its children
func (_bfcf *CT_PivotSource) Validate() error { return _bfcf.ValidateWithPath("CT_PivotSource") }
func NewCT_AxDataSource() *CT_AxDataSource {
	_fbfa := &CT_AxDataSource{}
	_fbfa.Choice = NewCT_AxDataSourceChoice()
	return _fbfa
}

// Validate validates the CT_TickMark and its children
func (_bgbbec *CT_TickMark) Validate() error { return _bgbbec.ValidateWithPath("CT_TickMark") }
func (_ceedef ST_SizeRepresents) String() string {
	switch _ceedef {
	case 0:
		return ""
	case 1:
		return "area"
	case 2:
		return "w"
	}
	return ""
}
func (_cdaccd *ST_BarGrouping) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_eecaa, _cdced := d.Token()
	if _cdced != nil {
		return _cdced
	}
	if _bgdb, _dcfec := _eecaa.(_fa.EndElement); _dcfec && _bgdb.Name == start.Name {
		*_cdaccd = 1
		return nil
	}
	if _eeeef, _ffga := _eecaa.(_fa.CharData); !_ffga {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eecaa)
	} else {
		switch string(_eeeef) {
		case "":
			*_cdaccd = 0
		case "percentStacked":
			*_cdaccd = 1
		case "clustered":
			*_cdaccd = 2
		case "standard":
			*_cdaccd = 3
		case "stacked":
			*_cdaccd = 4
		}
	}
	_eecaa, _cdced = d.Token()
	if _cdced != nil {
		return _cdced
	}
	if _bgede, _fdbdf := _eecaa.(_fa.EndElement); _fdbdf && _bgede.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eecaa)
}

// ValidateWithPath validates the CT_RadarChart and its children, prefixing error messages with path
func (_afdaa *CT_RadarChart) ValidateWithPath(path string) error {
	if _fbdag := _afdaa.RadarStyle.ValidateWithPath(path + "/RadarStyle"); _fbdag != nil {
		return _fbdag
	}
	if _afdaa.VaryColors != nil {
		if _cacb := _afdaa.VaryColors.ValidateWithPath(path + "/VaryColors"); _cacb != nil {
			return _cacb
		}
	}
	for _dece, _fcdab := range _afdaa.Ser {
		if _baca := _fcdab.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _dece)); _baca != nil {
			return _baca
		}
	}
	if _afdaa.DLbls != nil {
		if _deeb := _afdaa.DLbls.ValidateWithPath(path + "\u002fDLbls"); _deeb != nil {
			return _deeb
		}
	}
	for _cegbd, _aada := range _afdaa.AxId {
		if _eacef := _aada.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _cegbd)); _eacef != nil {
			return _eacef
		}
	}
	if _afdaa.ExtLst != nil {
		if _bdab := _afdaa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bdab != nil {
			return _bdab
		}
	}
	return nil
}
func (_babb *CT_BubbleScale) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _babb.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_babb.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_LegendEntry() *CT_LegendEntry {
	_deae := &CT_LegendEntry{}
	_deae.Idx = NewCT_UnsignedInt()
	return _deae
}

const (
	ST_ScatterStyleUnset        ST_ScatterStyle = 0
	ST_ScatterStyleNone         ST_ScatterStyle = 1
	ST_ScatterStyleLine         ST_ScatterStyle = 2
	ST_ScatterStyleLineMarker   ST_ScatterStyle = 3
	ST_ScatterStyleMarker       ST_ScatterStyle = 4
	ST_ScatterStyleSmooth       ST_ScatterStyle = 5
	ST_ScatterStyleSmoothMarker ST_ScatterStyle = 6
)
const (
	ST_SizeRepresentsUnset ST_SizeRepresents = 0
	ST_SizeRepresentsArea  ST_SizeRepresents = 1
	ST_SizeRepresentsW     ST_SizeRepresents = 2
)

type CT_PageSetup struct {
	PaperSizeAttr          *uint32
	PaperHeightAttr        *string
	PaperWidthAttr         *string
	FirstPageNumberAttr    *uint32
	OrientationAttr        ST_PageSetupOrientation
	BlackAndWhiteAttr      *bool
	DraftAttr              *bool
	UseFirstPageNumberAttr *bool
	HorizontalDpiAttr      *int32
	VerticalDpiAttr        *int32
	CopiesAttr             *uint32
}

// ValidateWithPath validates the CT_BarDir and its children, prefixing error messages with path
func (_eeff *CT_BarDir) ValidateWithPath(path string) error {
	if _aefg := _eeff.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _aefg != nil {
		return _aefg
	}
	return nil
}

// ValidateWithPath validates the CT_LogBase and its children, prefixing error messages with path
func (_ebeb *CT_LogBase) ValidateWithPath(path string) error {
	if _ebeb.ValAttr < 2 {
		return _gg.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00202\u0020\u0028have\u0020\u0025v\u0029", path, _ebeb.ValAttr)
	}
	if _ebeb.ValAttr > 1000 {
		return _gg.Errorf("\u0025s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003c\u003d\u00201000\u0020\u0028have\u0020\u0025v\u0029", path, _ebeb.ValAttr)
	}
	return nil
}

type ST_PageSetupOrientation byte

// Validate validates the CT_ManualLayout and its children
func (_cdcgf *CT_ManualLayout) Validate() error { return _cdcgf.ValidateWithPath("CT_ManualLayout") }
func (_fadfg ST_ErrDir) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_gdbbf := _fa.Attr{}
	_gdbbf.Name = name
	switch _fadfg {
	case ST_ErrDirUnset:
		_gdbbf.Value = ""
	case ST_ErrDirX:
		_gdbbf.Value = "x"
	case ST_ErrDirY:
		_gdbbf.Value = "y"
	}
	return _gdbbf, nil
}

// ST_SecondPieSize is a union type
type ST_SecondPieSize struct {
	ST_SecondPieSizePercent *string
	ST_SecondPieSizeUShort  *uint16
}

func NewCT_NumFmt() *CT_NumFmt { _fcafd := &CT_NumFmt{}; return _fcafd }

// Validate validates the CT_Protection and its children
func (_bfdef *CT_Protection) Validate() error { return _bfdef.ValidateWithPath("CT_Protection") }
func (_fdeb *CT_MultiLvlStrRef) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_egde := _fa.StartElement{Name: _fa.Name{Local: "c:f"}}
	_b.AddPreserveSpaceAttr(&_egde, _fdeb.F)
	e.EncodeElement(_fdeb.F, _egde)
	if _fdeb.MultiLvlStrCache != nil {
		_faed := _fa.StartElement{Name: _fa.Name{Local: "c:multiLvlStrCache"}}
		e.EncodeElement(_fdeb.MultiLvlStrCache, _faed)
	}
	if _fdeb.ExtLst != nil {
		_cgfc := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_fdeb.ExtLst, _cgfc)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_cdef ST_CrossBetween) Validate() error { return _cdef.ValidateWithPath("") }
func (_dfdba ST_DispBlanksAs) String() string {
	switch _dfdba {
	case 0:
		return ""
	case 1:
		return "span"
	case 2:
		return "gap"
	case 3:
		return "zero"
	}
	return ""
}
func NewCT_PlotAreaChoice() *CT_PlotAreaChoice { _cgggc := &CT_PlotAreaChoice{}; return _cgggc }
func (_adeec *CT_Surface) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_ebaeb:
	for {
		_fabae, _faeee := d.Token()
		if _faeee != nil {
			return _faeee
		}
		switch _adacf := _fabae.(type) {
		case _fa.StartElement:
			switch _adacf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "thickness"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "thickness"}:
				_adeec.Thickness = NewCT_Thickness()
				if _aaed := d.DecodeElement(_adeec.Thickness, &_adacf); _aaed != nil {
					return _aaed
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_adeec.SpPr = _cb.NewCT_ShapeProperties()
				if _bcadf := d.DecodeElement(_adeec.SpPr, &_adacf); _bcadf != nil {
					return _bcadf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pictureOptions"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pictureOptions"}:
				_adeec.PictureOptions = NewCT_PictureOptions()
				if _bedg := d.DecodeElement(_adeec.PictureOptions, &_adacf); _bedg != nil {
					return _bedg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_adeec.ExtLst = NewCT_ExtensionList()
				if _adcb := d.DecodeElement(_adeec.ExtLst, &_adacf); _adcb != nil {
					return _adcb
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_Surface\u0020\u0025v", _adacf.Name)
				if _dbbcc := d.Skip(); _dbbcc != nil {
					return _dbbcc
				}
			}
		case _fa.EndElement:
			break _ebaeb
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_BubbleScale and its children, prefixing error messages with path
func (_ade *CT_BubbleScale) ValidateWithPath(path string) error {
	if _ade.ValAttr != nil {
		if _cebd := _ade.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _cebd != nil {
			return _cebd
		}
	}
	return nil
}
func (_egdf ST_TickLblPos) String() string {
	switch _egdf {
	case 0:
		return ""
	case 1:
		return "high"
	case 2:
		return "low"
	case 3:
		return "nextTo"
	case 4:
		return "none"
	}
	return ""
}

// Validate validates the CT_SecondPieSize and its children
func (_aedc *CT_SecondPieSize) Validate() error { return _aedc.ValidateWithPath("CT_SecondPieSize") }

var ST_OverlapPercentPatternRe = _g.MustCompile(ST_OverlapPercentPattern)

func (_ccfa *CT_BubbleChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_bade:
	for {
		_afcd, _abcdc := d.Token()
		if _abcdc != nil {
			return _abcdc
		}
		switch _bgcf := _afcd.(type) {
		case _fa.StartElement:
			switch _bgcf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_ccfa.VaryColors = NewCT_Boolean()
				if _edfe := d.DecodeElement(_ccfa.VaryColors, &_bgcf); _edfe != nil {
					return _edfe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_gbff := NewCT_BubbleSer()
				if _bcgb := d.DecodeElement(_gbff, &_bgcf); _bcgb != nil {
					return _bcgb
				}
				_ccfa.Ser = append(_ccfa.Ser, _gbff)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_ccfa.DLbls = NewCT_DLbls()
				if _cdb := d.DecodeElement(_ccfa.DLbls, &_bgcf); _cdb != nil {
					return _cdb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bubble3D"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bubble3D"}:
				_ccfa.Bubble3D = NewCT_Boolean()
				if _gafe := d.DecodeElement(_ccfa.Bubble3D, &_bgcf); _gafe != nil {
					return _gafe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bubbleScale"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bubbleScale"}:
				_ccfa.BubbleScale = NewCT_BubbleScale()
				if _fegc := d.DecodeElement(_ccfa.BubbleScale, &_bgcf); _fegc != nil {
					return _fegc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showNegBubbles"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showNegBubbles"}:
				_ccfa.ShowNegBubbles = NewCT_Boolean()
				if _dfbf := d.DecodeElement(_ccfa.ShowNegBubbles, &_bgcf); _dfbf != nil {
					return _dfbf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "sizeRepresents"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "sizeRepresents"}:
				_ccfa.SizeRepresents = NewCT_SizeRepresents()
				if _bbda := d.DecodeElement(_ccfa.SizeRepresents, &_bgcf); _bbda != nil {
					return _bbda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_degg := NewCT_UnsignedInt()
				if _dggc := d.DecodeElement(_degg, &_bgcf); _dggc != nil {
					return _dggc
				}
				_ccfa.AxId = append(_ccfa.AxId, _degg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_ccfa.ExtLst = NewCT_ExtensionList()
				if _bda := d.DecodeElement(_ccfa.ExtLst, &_bgcf); _bda != nil {
					return _bda
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BubbleChart\u0020\u0025v", _bgcf.Name)
				if _abdaf := d.Skip(); _abdaf != nil {
					return _abdaf
				}
			}
		case _fa.EndElement:
			break _bade
		case _fa.CharData:
		}
	}
	return nil
}
func NewCT_SerAx() *CT_SerAx {
	_fdebb := &CT_SerAx{}
	_fdebb.AxId = NewCT_UnsignedInt()
	_fdebb.Scaling = NewCT_Scaling()
	_fdebb.AxPos = NewCT_AxPos()
	_fdebb.CrossAx = NewCT_UnsignedInt()
	return _fdebb
}

// Validate validates the EG_BarChartShared and its children
func (_cacaea *EG_BarChartShared) Validate() error {
	return _cacaea.ValidateWithPath("EG_BarChartShared")
}
func (_fecg *CT_ErrDir) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_aceg, _bfef := _fecg.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
	if _bfef != nil {
		return _bfef
	}
	start.Attr = append(start.Attr, _aceg)
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_cbde ST_Thickness) String() string {
	if _cbde.ST_ThicknessPercent != nil {
		return _gg.Sprintf("\u0025v", *_cbde.ST_ThicknessPercent)
	}
	if _cbde.Uint32 != nil {
		return _gg.Sprintf("\u0025v", *_cbde.Uint32)
	}
	return ""
}
func (_degd ST_BarGrouping) ValidateWithPath(path string) error {
	switch _degd {
	case 0, 1, 2, 3, 4:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_degd))
	}
	return nil
}

// Validate validates the CT_TimeUnit and its children
func (_bbfbc *CT_TimeUnit) Validate() error { return _bbfbc.ValidateWithPath("CT_TimeUnit") }
func (_fbdb *CT_Overlap) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _fbfbb := range start.Attr {
		if _fbfbb.Name.Local == "val" {
			_fcbc, _fbgc := ParseUnionST_Overlap(_fbfbb.Value)
			if _fbgc != nil {
				return _fbgc
			}
			_fbdb.ValAttr = &_fcbc
			continue
		}
	}
	for {
		_efg, _gfgb := d.Token()
		if _gfgb != nil {
			return _gg.Errorf("parsing\u0020CT_Overlap:\u0020%s", _gfgb)
		}
		if _gaddge, _dcce := _efg.(_fa.EndElement); _dcce && _gaddge.Name == start.Name {
			break
		}
	}
	return nil
}
func NewEG_DLblShared() *EG_DLblShared { _gbegf := &EG_DLblShared{}; return _gbegf }
func (_abefed *CT_UpDownBars) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_cfacca:
	for {
		_bceg, _dedee := d.Token()
		if _dedee != nil {
			return _dedee
		}
		switch _eeab := _bceg.(type) {
		case _fa.StartElement:
			switch _eeab.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "gapWidth"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "gapWidth"}:
				_abefed.GapWidth = NewCT_GapAmount()
				if _fbaa := d.DecodeElement(_abefed.GapWidth, &_eeab); _fbaa != nil {
					return _fbaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "upBars"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "upBars"}:
				_abefed.UpBars = NewCT_UpDownBar()
				if _fggda := d.DecodeElement(_abefed.UpBars, &_eeab); _fggda != nil {
					return _fggda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "downBars"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "downBars"}:
				_abefed.DownBars = NewCT_UpDownBar()
				if _gbadc := d.DecodeElement(_abefed.DownBars, &_eeab); _gbadc != nil {
					return _gbadc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_abefed.ExtLst = NewCT_ExtensionList()
				if _eeabd := d.DecodeElement(_abefed.ExtLst, &_eeab); _eeabd != nil {
					return _eeabd
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_UpDownBars \u0025v", _eeab.Name)
				if _dafeb := d.Skip(); _dafeb != nil {
					return _dafeb
				}
			}
		case _fa.EndElement:
			break _cfacca
		case _fa.CharData:
		}
	}
	return nil
}
func (_facbd ST_ScatterStyle) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_facbd.String(), start)
}
func (_cffc *CT_ExternalData) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _daae := range start.Attr {
		if _daae.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _daae.Name.Local == "id" || _daae.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _daae.Name.Local == "id" {
			_eacb, _agfgb := _daae.Value, error(nil)
			if _agfgb != nil {
				return _agfgb
			}
			_cffc.IdAttr = _eacb
			continue
		}
	}
_fdfag:
	for {
		_eagg, _aaba := d.Token()
		if _aaba != nil {
			return _aaba
		}
		switch _fffd := _eagg.(type) {
		case _fa.StartElement:
			switch _fffd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "autoUpdate"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "autoUpdate"}:
				_cffc.AutoUpdate = NewCT_Boolean()
				if _gfee := d.DecodeElement(_cffc.AutoUpdate, &_fffd); _gfee != nil {
					return _gfee
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ExternalData\u0020\u0025v", _fffd.Name)
				if _bafg := d.Skip(); _bafg != nil {
					return _bafg
				}
			}
		case _fa.EndElement:
			break _fdfag
		case _fa.CharData:
		}
	}
	return nil
}
func (_fgdg *CT_ChartSpace) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _fgdg.Date1904 != nil {
		_fded := _fa.StartElement{Name: _fa.Name{Local: "c:date1904"}}
		e.EncodeElement(_fgdg.Date1904, _fded)
	}
	if _fgdg.Lang != nil {
		_agfad := _fa.StartElement{Name: _fa.Name{Local: "c:lang"}}
		e.EncodeElement(_fgdg.Lang, _agfad)
	}
	if _fgdg.RoundedCorners != nil {
		_egbf := _fa.StartElement{Name: _fa.Name{Local: "c:roundedCorners"}}
		e.EncodeElement(_fgdg.RoundedCorners, _egbf)
	}
	if _fgdg.Style != nil {
		_cfdg := _fa.StartElement{Name: _fa.Name{Local: "c:style"}}
		e.EncodeElement(_fgdg.Style, _cfdg)
	}
	if _fgdg.ClrMapOvr != nil {
		_afcb := _fa.StartElement{Name: _fa.Name{Local: "c:clrMapOvr"}}
		e.EncodeElement(_fgdg.ClrMapOvr, _afcb)
	}
	if _fgdg.PivotSource != nil {
		_gdc := _fa.StartElement{Name: _fa.Name{Local: "c:pivotSource"}}
		e.EncodeElement(_fgdg.PivotSource, _gdc)
	}
	if _fgdg.Protection != nil {
		_dadd := _fa.StartElement{Name: _fa.Name{Local: "c:protection"}}
		e.EncodeElement(_fgdg.Protection, _dadd)
	}
	_eebd := _fa.StartElement{Name: _fa.Name{Local: "c:chart"}}
	e.EncodeElement(_fgdg.Chart, _eebd)
	if _fgdg.SpPr != nil {
		_cdge := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_fgdg.SpPr, _cdge)
	}
	if _fgdg.TxPr != nil {
		_aded := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_fgdg.TxPr, _aded)
	}
	if _fgdg.ExternalData != nil {
		_ddag := _fa.StartElement{Name: _fa.Name{Local: "c:externalData"}}
		e.EncodeElement(_fgdg.ExternalData, _ddag)
	}
	if _fgdg.PrintSettings != nil {
		_ggdf := _fa.StartElement{Name: _fa.Name{Local: "c:printSettings"}}
		e.EncodeElement(_fgdg.PrintSettings, _ggdf)
	}
	if _fgdg.UserShapes != nil {
		_ggea := _fa.StartElement{Name: _fa.Name{Local: "c:userShapes"}}
		e.EncodeElement(_fgdg.UserShapes, _ggea)
	}
	if _fgdg.ExtLst != nil {
		_gcgf := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_fgdg.ExtLst, _gcgf)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Order and its children
func (_dbde *CT_Order) Validate() error { return _dbde.ValidateWithPath("CT_Order") }

type CT_Order struct{ ValAttr *uint8 }

// ValidateWithPath validates the CT_AreaSer and its children, prefixing error messages with path
func (_ddc *CT_AreaSer) ValidateWithPath(path string) error {
	if _gdf := _ddc.Idx.ValidateWithPath(path + "\u002fIdx"); _gdf != nil {
		return _gdf
	}
	if _fgg := _ddc.Order.ValidateWithPath(path + "\u002fOrder"); _fgg != nil {
		return _fgg
	}
	if _ddc.Tx != nil {
		if _ag := _ddc.Tx.ValidateWithPath(path + "\u002fTx"); _ag != nil {
			return _ag
		}
	}
	if _ddc.SpPr != nil {
		if _cfd := _ddc.SpPr.ValidateWithPath(path + "\u002fSpPr"); _cfd != nil {
			return _cfd
		}
	}
	if _ddc.PictureOptions != nil {
		if _abf := _ddc.PictureOptions.ValidateWithPath(path + "\u002fPictureOptions"); _abf != nil {
			return _abf
		}
	}
	for _dgc, _gbgb := range _ddc.DPt {
		if _da := _gbgb.ValidateWithPath(_gg.Sprintf("\u0025s\u002fDPt\u005b\u0025d\u005d", path, _dgc)); _da != nil {
			return _da
		}
	}
	if _ddc.DLbls != nil {
		if _bee := _ddc.DLbls.ValidateWithPath(path + "\u002fDLbls"); _bee != nil {
			return _bee
		}
	}
	for _aea, _ggf := range _ddc.Trendline {
		if _caa := _ggf.ValidateWithPath(_gg.Sprintf("\u0025s/Trendline\u005b\u0025d\u005d", path, _aea)); _caa != nil {
			return _caa
		}
	}
	for _eeb, _cff := range _ddc.ErrBars {
		if _abc := _cff.ValidateWithPath(_gg.Sprintf("\u0025s\u002fErrBars\u005b\u0025d\u005d", path, _eeb)); _abc != nil {
			return _abc
		}
	}
	if _ddc.Cat != nil {
		if _de := _ddc.Cat.ValidateWithPath(path + "\u002fCat"); _de != nil {
			return _de
		}
	}
	if _ddc.Val != nil {
		if _beg := _ddc.Val.ValidateWithPath(path + "\u002fVal"); _beg != nil {
			return _beg
		}
	}
	if _ddc.ExtLst != nil {
		if _dge := _ddc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dge != nil {
			return _dge
		}
	}
	return nil
}
func _feaac(_dgabdd bool) uint8 {
	if _dgabdd {
		return 1
	}
	return 0
}

type ST_DLblPos byte

// ValidateWithPath validates the CT_ErrBarType and its children, prefixing error messages with path
func (_bcea *CT_ErrBarType) ValidateWithPath(path string) error {
	if _fecf := _bcea.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _fecf != nil {
		return _fecf
	}
	return nil
}

// ValidateWithPath validates the CT_LegendEntry and its children, prefixing error messages with path
func (_ceeeb *CT_LegendEntry) ValidateWithPath(path string) error {
	if _gefc := _ceeeb.Idx.ValidateWithPath(path + "\u002fIdx"); _gefc != nil {
		return _gefc
	}
	if _ceeeb.Choice != nil {
		if _deefc := _ceeeb.Choice.ValidateWithPath(path + "\u002fChoice"); _deefc != nil {
			return _deefc
		}
	}
	if _ceeeb.ExtLst != nil {
		if _fgaa := _ceeeb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fgaa != nil {
			return _fgaa
		}
	}
	return nil
}
func NewCT_Period() *CT_Period { _eeefc := &CT_Period{}; return _eeefc }
func (_bccbea *CT_StockChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_gabfb:
	for {
		_cbacc, _eddcg := d.Token()
		if _eddcg != nil {
			return _eddcg
		}
		switch _dfdab := _cbacc.(type) {
		case _fa.StartElement:
			switch _dfdab.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_fcdge := NewCT_LineSer()
				if _feab := d.DecodeElement(_fcdge, &_dfdab); _feab != nil {
					return _feab
				}
				_bccbea.Ser = append(_bccbea.Ser, _fcdge)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_bccbea.DLbls = NewCT_DLbls()
				if _gcgdb := d.DecodeElement(_bccbea.DLbls, &_dfdab); _gcgdb != nil {
					return _gcgdb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dropLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dropLines"}:
				_bccbea.DropLines = NewCT_ChartLines()
				if _cdga := d.DecodeElement(_bccbea.DropLines, &_dfdab); _cdga != nil {
					return _cdga
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "hiLowLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "hiLowLines"}:
				_bccbea.HiLowLines = NewCT_ChartLines()
				if _afgb := d.DecodeElement(_bccbea.HiLowLines, &_dfdab); _afgb != nil {
					return _afgb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "upDownBars"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "upDownBars"}:
				_bccbea.UpDownBars = NewCT_UpDownBars()
				if _dgcfc := d.DecodeElement(_bccbea.UpDownBars, &_dfdab); _dgcfc != nil {
					return _dgcfc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_cgfdg := NewCT_UnsignedInt()
				if _fdbf := d.DecodeElement(_cgfdg, &_dfdab); _fdbf != nil {
					return _fdbf
				}
				_bccbea.AxId = append(_bccbea.AxId, _cgfdg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_bccbea.ExtLst = NewCT_ExtensionList()
				if _cgabe := d.DecodeElement(_bccbea.ExtLst, &_dfdab); _cgabe != nil {
					return _cgabe
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_StockChart \u0025v", _dfdab.Name)
				if _bffff := d.Skip(); _bffff != nil {
					return _bffff
				}
			}
		case _fa.EndElement:
			break _gabfb
		case _fa.CharData:
		}
	}
	return nil
}

type EG_LineChartShared struct {
	Grouping   *CT_Grouping
	VaryColors *CT_Boolean
	Ser        []*CT_LineSer
	DLbls      *CT_DLbls
	DropLines  *CT_ChartLines
}

func (_adgae ST_DispBlanksAs) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_bcdbb := _fa.Attr{}
	_bcdbb.Name = name
	switch _adgae {
	case ST_DispBlanksAsUnset:
		_bcdbb.Value = ""
	case ST_DispBlanksAsSpan:
		_bcdbb.Value = "span"
	case ST_DispBlanksAsGap:
		_bcdbb.Value = "gap"
	case ST_DispBlanksAsZero:
		_bcdbb.Value = "zero"
	}
	return _bcdbb, nil
}
func (_gbead *CT_UnsignedInt) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", _gbead.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_dbfcd *ST_HoleSize) ValidateWithPath(path string) error {
	_ccbba := []string{}
	if _dbfcd.ST_HoleSizePercent != nil {
		_ccbba = append(_ccbba, "ST_HoleSizePercent")
	}
	if _dbfcd.ST_HoleSizeUByte != nil {
		_ccbba = append(_ccbba, "ST_HoleSizeUByte")
	}
	if len(_ccbba) > 1 {
		return _gg.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _ccbba)
	}
	return nil
}
func (_gfdbf ST_OfPieType) Validate() error { return _gfdbf.ValidateWithPath("") }

// ValidateWithPath validates the CT_SplitType and its children, prefixing error messages with path
func (_ebcdg *CT_SplitType) ValidateWithPath(path string) error {
	if _gbccc := _ebcdg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _gbccc != nil {
		return _gbccc
	}
	return nil
}

type CT_ErrBarType struct{ ValAttr ST_ErrBarType }

func NewCT_PivotFmts() *CT_PivotFmts { _fgdgf := &CT_PivotFmts{}; return _fgdgf }

// Validate validates the CT_BuiltInUnit and its children
func (_geda *CT_BuiltInUnit) Validate() error { return _geda.ValidateWithPath("CT_BuiltInUnit") }

// ValidateWithPath validates the CT_AxDataSourceChoice and its children, prefixing error messages with path
func (_ebbc *CT_AxDataSourceChoice) ValidateWithPath(path string) error {
	if _ebbc.MultiLvlStrRef != nil {
		if _gbc := _ebbc.MultiLvlStrRef.ValidateWithPath(path + "\u002fMultiLvlStrRef"); _gbc != nil {
			return _gbc
		}
	}
	if _ebbc.NumRef != nil {
		if _ffae := _ebbc.NumRef.ValidateWithPath(path + "\u002fNumRef"); _ffae != nil {
			return _ffae
		}
	}
	if _ebbc.NumLit != nil {
		if _dcbb := _ebbc.NumLit.ValidateWithPath(path + "\u002fNumLit"); _dcbb != nil {
			return _dcbb
		}
	}
	if _ebbc.StrRef != nil {
		if _ddd := _ebbc.StrRef.ValidateWithPath(path + "\u002fStrRef"); _ddd != nil {
			return _ddd
		}
	}
	if _ebbc.StrLit != nil {
		if _ggc := _ebbc.StrLit.ValidateWithPath(path + "\u002fStrLit"); _ggc != nil {
			return _ggc
		}
	}
	return nil
}
func (_ecgag *Group_DLbls) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _ecgag.NumFmt != nil {
		_bdefgb := _fa.StartElement{Name: _fa.Name{Local: "c:numFmt"}}
		e.EncodeElement(_ecgag.NumFmt, _bdefgb)
	}
	if _ecgag.SpPr != nil {
		_gabfa := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_ecgag.SpPr, _gabfa)
	}
	if _ecgag.TxPr != nil {
		_gbbfa := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_ecgag.TxPr, _gbbfa)
	}
	if _ecgag.DLblPos != nil {
		_ccaf := _fa.StartElement{Name: _fa.Name{Local: "c:dLblPos"}}
		e.EncodeElement(_ecgag.DLblPos, _ccaf)
	}
	if _ecgag.ShowLegendKey != nil {
		_cfcce := _fa.StartElement{Name: _fa.Name{Local: "c:showLegendKey"}}
		e.EncodeElement(_ecgag.ShowLegendKey, _cfcce)
	}
	if _ecgag.ShowVal != nil {
		_adaac := _fa.StartElement{Name: _fa.Name{Local: "c:showVal"}}
		e.EncodeElement(_ecgag.ShowVal, _adaac)
	}
	if _ecgag.ShowCatName != nil {
		_facb := _fa.StartElement{Name: _fa.Name{Local: "c:showCatName"}}
		e.EncodeElement(_ecgag.ShowCatName, _facb)
	}
	if _ecgag.ShowSerName != nil {
		_ddegc := _fa.StartElement{Name: _fa.Name{Local: "c:showSerName"}}
		e.EncodeElement(_ecgag.ShowSerName, _ddegc)
	}
	if _ecgag.ShowPercent != nil {
		_begcb := _fa.StartElement{Name: _fa.Name{Local: "c:showPercent"}}
		e.EncodeElement(_ecgag.ShowPercent, _begcb)
	}
	if _ecgag.ShowBubbleSize != nil {
		_geggc := _fa.StartElement{Name: _fa.Name{Local: "c:showBubbleSize"}}
		e.EncodeElement(_ecgag.ShowBubbleSize, _geggc)
	}
	if _ecgag.Separator != nil {
		_eafabf := _fa.StartElement{Name: _fa.Name{Local: "c:separator"}}
		_b.AddPreserveSpaceAttr(&_eafabf, *_ecgag.Separator)
		e.EncodeElement(_ecgag.Separator, _eafabf)
	}
	if _ecgag.ShowLeaderLines != nil {
		_gafef := _fa.StartElement{Name: _fa.Name{Local: "c:showLeaderLines"}}
		e.EncodeElement(_ecgag.ShowLeaderLines, _gafef)
	}
	if _ecgag.LeaderLines != nil {
		_geeb := _fa.StartElement{Name: _fa.Name{Local: "c:leaderLines"}}
		e.EncodeElement(_ecgag.LeaderLines, _geeb)
	}
	return nil
}

const (
	ST_LayoutModeUnset  ST_LayoutMode = 0
	ST_LayoutModeEdge   ST_LayoutMode = 1
	ST_LayoutModeFactor ST_LayoutMode = 2
)

func NewCT_DispUnits() *CT_DispUnits { _faag := &CT_DispUnits{}; return _faag }

// Validate validates the CT_PageMargins and its children
func (_afcgf *CT_PageMargins) Validate() error { return _afcgf.ValidateWithPath("CT_PageMargins") }
func (_ddff *CT_NumData) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _ddff.FormatCode != nil {
		_dfdc := _fa.StartElement{Name: _fa.Name{Local: "c:formatCode"}}
		_b.AddPreserveSpaceAttr(&_dfdc, *_ddff.FormatCode)
		e.EncodeElement(_ddff.FormatCode, _dfdc)
	}
	if _ddff.PtCount != nil {
		_ffggd := _fa.StartElement{Name: _fa.Name{Local: "c:ptCount"}}
		e.EncodeElement(_ddff.PtCount, _ffggd)
	}
	if _ddff.Pt != nil {
		_cgcf := _fa.StartElement{Name: _fa.Name{Local: "c:pt"}}
		for _, _accg := range _ddff.Pt {
			e.EncodeElement(_accg, _cgcf)
		}
	}
	if _ddff.ExtLst != nil {
		_eabc := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_ddff.ExtLst, _eabc)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_StrRef and its children, prefixing error messages with path
func (_gecgg *CT_StrRef) ValidateWithPath(path string) error {
	if _gecgg.StrCache != nil {
		if _bgbfc := _gecgg.StrCache.ValidateWithPath(path + "\u002fStrCache"); _bgbfc != nil {
			return _bgbfc
		}
	}
	if _gecgg.ExtLst != nil {
		if _ffbg := _gecgg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ffbg != nil {
			return _ffbg
		}
	}
	return nil
}
func (_gfdfc *CT_Thickness) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", _gfdfc.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_Chart struct {
	Title            *CT_Title
	AutoTitleDeleted *CT_Boolean
	PivotFmts        *CT_PivotFmts
	View3D           *CT_View3D
	Floor            *CT_Surface
	SideWall         *CT_Surface
	BackWall         *CT_Surface
	PlotArea         *CT_PlotArea
	Legend           *CT_Legend
	PlotVisOnly      *CT_Boolean
	DispBlanksAs     *CT_DispBlanksAs
	ShowDLblsOverMax *CT_Boolean
	ExtLst           *CT_ExtensionList
}

func (_gfbb *CT_DispUnitsChoice) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_acdg:
	for {
		_cdaf, _fbac := d.Token()
		if _fbac != nil {
			return _fbac
		}
		switch _bgcb := _cdaf.(type) {
		case _fa.StartElement:
			switch _bgcb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "custUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "custUnit"}:
				_gfbb.CustUnit = NewCT_Double()
				if _fbba := d.DecodeElement(_gfbb.CustUnit, &_bgcb); _fbba != nil {
					return _fbba
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "builtInUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "builtInUnit"}:
				_gfbb.BuiltInUnit = NewCT_BuiltInUnit()
				if _dgfa := d.DecodeElement(_gfbb.BuiltInUnit, &_bgcb); _dgfa != nil {
					return _dgfa
				}
			default:
				_b.Log("skipping\u0020unsupported element\u0020on\u0020CT_DispUnitsChoice\u0020\u0025v", _bgcb.Name)
				if _dgfg := d.Skip(); _dgfg != nil {
					return _dgfg
				}
			}
		case _fa.EndElement:
			break _acdg
		case _fa.CharData:
		}
	}
	return nil
}
func ParseUnionST_LblOffset(s string) (ST_LblOffset, error) {
	if ST_LblOffsetPercentPatternRe.MatchString(s) {
		return ST_LblOffset{ST_LblOffsetPercent: &s}, nil
	}
	_cafed, _eaccaa := _c.ParseUint(s, 10, 16)
	if _eaccaa != nil {
		return ST_LblOffset{}, _eaccaa
	}
	_eagcg := uint16(_cafed)
	return ST_LblOffset{ST_LblOffsetUShort: &_eagcg}, nil
}
func (_ccccd *CT_Marker) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_bagcf:
	for {
		_bgdf, _ggdff := d.Token()
		if _ggdff != nil {
			return _ggdff
		}
		switch _eggba := _bgdf.(type) {
		case _fa.StartElement:
			switch _eggba.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "symbol"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "symbol"}:
				_ccccd.Symbol = NewCT_MarkerStyle()
				if _ggdg := d.DecodeElement(_ccccd.Symbol, &_eggba); _ggdg != nil {
					return _ggdg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "size"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "size"}:
				_ccccd.Size = NewCT_MarkerSize()
				if _geecd := d.DecodeElement(_ccccd.Size, &_eggba); _geecd != nil {
					return _geecd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_ccccd.SpPr = _cb.NewCT_ShapeProperties()
				if _fbddd := d.DecodeElement(_ccccd.SpPr, &_eggba); _fbddd != nil {
					return _fbddd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_ccccd.ExtLst = NewCT_ExtensionList()
				if _cdfe := d.DecodeElement(_ccccd.ExtLst, &_eggba); _cdfe != nil {
					return _cdfe
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_Marker \u0025v", _eggba.Name)
				if _gbbg := d.Skip(); _gbbg != nil {
					return _gbbg
				}
			}
		case _fa.EndElement:
			break _bagcf
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_NumVal and its children, prefixing error messages with path
func (_afgd *CT_NumVal) ValidateWithPath(path string) error { return nil }
func (_ceba *ST_Grouping) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_ceba = 0
	case "percentStacked":
		*_ceba = 1
	case "standard":
		*_ceba = 2
	case "stacked":
		*_ceba = 3
	}
	return nil
}
func NewCT_ManualLayout() *CT_ManualLayout { _ccebb := &CT_ManualLayout{}; return _ccebb }

type CT_PrintSettings struct {
	HeaderFooter    *CT_HeaderFooter
	PageMargins     *CT_PageMargins
	PageSetup       *CT_PageSetup
	LegacyDrawingHF *CT_RelId
}

func (_feffad *CT_ValAx) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cebdg := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	e.EncodeElement(_feffad.AxId, _cebdg)
	_begaca := _fa.StartElement{Name: _fa.Name{Local: "c:scaling"}}
	e.EncodeElement(_feffad.Scaling, _begaca)
	if _feffad.Delete != nil {
		_egdd := _fa.StartElement{Name: _fa.Name{Local: "c:delete"}}
		e.EncodeElement(_feffad.Delete, _egdd)
	}
	_ffca := _fa.StartElement{Name: _fa.Name{Local: "c:axPos"}}
	e.EncodeElement(_feffad.AxPos, _ffca)
	if _feffad.MajorGridlines != nil {
		_accd := _fa.StartElement{Name: _fa.Name{Local: "c:majorGridlines"}}
		e.EncodeElement(_feffad.MajorGridlines, _accd)
	}
	if _feffad.MinorGridlines != nil {
		_ggcgg := _fa.StartElement{Name: _fa.Name{Local: "c:minorGridlines"}}
		e.EncodeElement(_feffad.MinorGridlines, _ggcgg)
	}
	if _feffad.Title != nil {
		_dfdcf := _fa.StartElement{Name: _fa.Name{Local: "c:title"}}
		e.EncodeElement(_feffad.Title, _dfdcf)
	}
	if _feffad.NumFmt != nil {
		_bbfcf := _fa.StartElement{Name: _fa.Name{Local: "c:numFmt"}}
		e.EncodeElement(_feffad.NumFmt, _bbfcf)
	}
	if _feffad.MajorTickMark != nil {
		_becb := _fa.StartElement{Name: _fa.Name{Local: "c:majorTickMark"}}
		e.EncodeElement(_feffad.MajorTickMark, _becb)
	}
	if _feffad.MinorTickMark != nil {
		_bgdge := _fa.StartElement{Name: _fa.Name{Local: "c:minorTickMark"}}
		e.EncodeElement(_feffad.MinorTickMark, _bgdge)
	}
	if _feffad.TickLblPos != nil {
		_cddd := _fa.StartElement{Name: _fa.Name{Local: "c:tickLblPos"}}
		e.EncodeElement(_feffad.TickLblPos, _cddd)
	}
	if _feffad.SpPr != nil {
		_feacg := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_feffad.SpPr, _feacg)
	}
	if _feffad.TxPr != nil {
		_dfegf := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_feffad.TxPr, _dfegf)
	}
	_edae := _fa.StartElement{Name: _fa.Name{Local: "c:crossAx"}}
	e.EncodeElement(_feffad.CrossAx, _edae)
	if _feffad.Choice != nil {
		_feffad.Choice.MarshalXML(e, _fa.StartElement{})
	}
	if _feffad.CrossBetween != nil {
		_facce := _fa.StartElement{Name: _fa.Name{Local: "c:crossBetween"}}
		e.EncodeElement(_feffad.CrossBetween, _facce)
	}
	if _feffad.MajorUnit != nil {
		_daegfd := _fa.StartElement{Name: _fa.Name{Local: "c:majorUnit"}}
		e.EncodeElement(_feffad.MajorUnit, _daegfd)
	}
	if _feffad.MinorUnit != nil {
		_deebb := _fa.StartElement{Name: _fa.Name{Local: "c:minorUnit"}}
		e.EncodeElement(_feffad.MinorUnit, _deebb)
	}
	if _feffad.DispUnits != nil {
		_bbaab := _fa.StartElement{Name: _fa.Name{Local: "c:dispUnits"}}
		e.EncodeElement(_feffad.DispUnits, _bbaab)
	}
	if _feffad.ExtLst != nil {
		_fadbc := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_feffad.ExtLst, _fadbc)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_ccdfe *ST_LayoutTarget) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_gaac, _cgeag := d.Token()
	if _cgeag != nil {
		return _cgeag
	}
	if _gaabc, _fdcgc := _gaac.(_fa.EndElement); _fdcgc && _gaabc.Name == start.Name {
		*_ccdfe = 1
		return nil
	}
	if _cgggg, _dgge := _gaac.(_fa.CharData); !_dgge {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gaac)
	} else {
		switch string(_cgggg) {
		case "":
			*_ccdfe = 0
		case "inner":
			*_ccdfe = 1
		case "outer":
			*_ccdfe = 2
		}
	}
	_gaac, _cgeag = d.Token()
	if _cgeag != nil {
		return _cgeag
	}
	if _eeaca, _ddgcf := _gaac.(_fa.EndElement); _ddgcf && _eeaca.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gaac)
}
func NewEG_AxSharedChoice() *EG_AxSharedChoice { _ebbd := &EG_AxSharedChoice{}; return _ebbd }

type CT_SurfaceChart struct {
	Wireframe *CT_Boolean
	Ser       []*CT_SurfaceSer
	BandFmts  *CT_BandFmts
	AxId      []*CT_UnsignedInt
	ExtLst    *CT_ExtensionList
}

// Validate validates the CT_GapAmount and its children
func (_afead *CT_GapAmount) Validate() error { return _afead.ValidateWithPath("CT_GapAmount") }

// Validate validates the CT_LegendEntryChoice and its children
func (_cfdaa *CT_LegendEntryChoice) Validate() error {
	return _cfdaa.ValidateWithPath("CT_LegendEntryChoice")
}

// Validate validates the EG_SerShared and its children
func (_agbfg *EG_SerShared) Validate() error { return _agbfg.ValidateWithPath("EG_SerShared") }
func (_gagef *CT_PictureStackUnit) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", _gagef.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_PictureOptions struct {
	ApplyToFront     *CT_Boolean
	ApplyToSides     *CT_Boolean
	ApplyToEnd       *CT_Boolean
	PictureFormat    *CT_PictureFormat
	PictureStackUnit *CT_PictureStackUnit
}

// ValidateWithPath validates the CT_FirstSliceAng and its children, prefixing error messages with path
func (_fgdc *CT_FirstSliceAng) ValidateWithPath(path string) error {
	if _fgdc.ValAttr != nil {
		if *_fgdc.ValAttr < 0 {
			return _gg.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_fgdc.ValAttr)
		}
		if *_fgdc.ValAttr > 360 {
			return _gg.Errorf("\u0025s/m\u002eValAttr\u0020must\u0020be\u0020\u003c\u003d\u0020360\u0020\u0028have\u0020\u0025v\u0029", path, *_fgdc.ValAttr)
		}
	}
	return nil
}
func (_cbdg *EG_DLblShared) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_cdaad:
	for {
		_dbbgcd, _gcdeb := d.Token()
		if _gcdeb != nil {
			return _gcdeb
		}
		switch _ggfab := _dbbgcd.(type) {
		case _fa.StartElement:
			switch _ggfab.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				_cbdg.NumFmt = NewCT_NumFmt()
				if _efda := d.DecodeElement(_cbdg.NumFmt, &_ggfab); _efda != nil {
					return _efda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_cbdg.SpPr = _cb.NewCT_ShapeProperties()
				if _bcca := d.DecodeElement(_cbdg.SpPr, &_ggfab); _bcca != nil {
					return _bcca
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_cbdg.TxPr = _cb.NewCT_TextBody()
				if _faadf := d.DecodeElement(_cbdg.TxPr, &_ggfab); _faadf != nil {
					return _faadf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLblPos"}:
				_cbdg.DLblPos = NewCT_DLblPos()
				if _ggace := d.DecodeElement(_cbdg.DLblPos, &_ggfab); _ggace != nil {
					return _ggace
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showLegendKey"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showLegendKey"}:
				_cbdg.ShowLegendKey = NewCT_Boolean()
				if _ddae := d.DecodeElement(_cbdg.ShowLegendKey, &_ggfab); _ddae != nil {
					return _ddae
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showVal"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showVal"}:
				_cbdg.ShowVal = NewCT_Boolean()
				if _bggc := d.DecodeElement(_cbdg.ShowVal, &_ggfab); _bggc != nil {
					return _bggc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showCatName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showCatName"}:
				_cbdg.ShowCatName = NewCT_Boolean()
				if _bdbae := d.DecodeElement(_cbdg.ShowCatName, &_ggfab); _bdbae != nil {
					return _bdbae
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showSerName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showSerName"}:
				_cbdg.ShowSerName = NewCT_Boolean()
				if _dfcbc := d.DecodeElement(_cbdg.ShowSerName, &_ggfab); _dfcbc != nil {
					return _dfcbc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showPercent"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showPercent"}:
				_cbdg.ShowPercent = NewCT_Boolean()
				if _cagea := d.DecodeElement(_cbdg.ShowPercent, &_ggfab); _cagea != nil {
					return _cagea
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showBubbleSize"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showBubbleSize"}:
				_cbdg.ShowBubbleSize = NewCT_Boolean()
				if _ggbed := d.DecodeElement(_cbdg.ShowBubbleSize, &_ggfab); _ggbed != nil {
					return _ggbed
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "separator"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "separator"}:
				_cbdg.Separator = new(string)
				if _acfb := d.DecodeElement(_cbdg.Separator, &_ggfab); _acfb != nil {
					return _acfb
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020EG_DLblShared \u0025v", _ggfab.Name)
				if _gaggb := d.Skip(); _gaggb != nil {
					return _gaggb
				}
			}
		case _fa.EndElement:
			break _cdaad
		case _fa.CharData:
		}
	}
	return nil
}

type CT_SerTx struct{ Choice *CT_SerTxChoice }
type CT_Grouping struct{ ValAttr ST_Grouping }

func (_dafdg *ST_DepthPercent) ValidateWithPath(path string) error {
	_ddacc := []string{}
	if _dafdg.ST_DepthPercentWithSymbol != nil {
		_ddacc = append(_ddacc, "ST_DepthPercentWithSymbol")
	}
	if _dafdg.ST_DepthPercentUShort != nil {
		_ddacc = append(_ddacc, "ST_DepthPercentUShort")
	}
	if len(_ddacc) > 1 {
		return _gg.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _ddacc)
	}
	return nil
}
func (_aegag *CT_Style) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_aegag.ValAttr = 1
	for _, _agcb := range start.Attr {
		if _agcb.Name.Local == "val" {
			_gfead, _eeee := _c.ParseUint(_agcb.Value, 10, 8)
			if _eeee != nil {
				return _eeee
			}
			_aegag.ValAttr = uint8(_gfead)
			continue
		}
	}
	for {
		_bdegc, _bcacd := d.Token()
		if _bcacd != nil {
			return _gg.Errorf("parsing\u0020CT_Style: \u0025s", _bcacd)
		}
		if _gafcb, _gfbgc := _bdegc.(_fa.EndElement); _gfbgc && _gafcb.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_HPercent() *CT_HPercent { _acegc := &CT_HPercent{}; return _acegc }

// Validate validates the CT_SurfaceChart and its children
func (_effgc *CT_SurfaceChart) Validate() error { return _effgc.ValidateWithPath("CT_SurfaceChart") }

// Validate validates the CT_Line3DChart and its children
func (_cbdd *CT_Line3DChart) Validate() error { return _cbdd.ValidateWithPath("CT_Line3DChart") }
func NewCT_GapAmount() *CT_GapAmount          { _cedg := &CT_GapAmount{}; return _cedg }
func (_gadag ST_DispBlanksAs) ValidateWithPath(path string) error {
	switch _gadag {
	case 0, 1, 2, 3:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gadag))
	}
	return nil
}

// ValidateWithPath validates the CT_CrossBetween and its children, prefixing error messages with path
func (_fbgf *CT_CrossBetween) ValidateWithPath(path string) error {
	if _fbgf.ValAttr == ST_CrossBetweenUnset {
		return _gg.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _gecb := _fbgf.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _gecb != nil {
		return _gecb
	}
	return nil
}

const (
	ST_BarDirUnset ST_BarDir = 0
	ST_BarDirBar   ST_BarDir = 1
	ST_BarDirCol   ST_BarDir = 2
)

// Validate validates the CT_PivotFmts and its children
func (_addgb *CT_PivotFmts) Validate() error { return _addgb.ValidateWithPath("CT_PivotFmts") }

const ST_OverlapPercentPattern = "\u0028\u002d\u003f0\u002a\u0028(\u005b0\u002d9\u005d\u0029\u007c\u0028\u005b1\u002d9\u005d[0\u002d9\u005d\u0029\u007c100\u0029\u0029\u0025"

func (_cgfd *CT_DTable) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_dbfg:
	for {
		_cdab, _ddgc := d.Token()
		if _ddgc != nil {
			return _ddgc
		}
		switch _bfdb := _cdab.(type) {
		case _fa.StartElement:
			switch _bfdb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showHorzBorder"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showHorzBorder"}:
				_cgfd.ShowHorzBorder = NewCT_Boolean()
				if _ecdcc := d.DecodeElement(_cgfd.ShowHorzBorder, &_bfdb); _ecdcc != nil {
					return _ecdcc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showVertBorder"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showVertBorder"}:
				_cgfd.ShowVertBorder = NewCT_Boolean()
				if _cbfbd := d.DecodeElement(_cgfd.ShowVertBorder, &_bfdb); _cbfbd != nil {
					return _cbfbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showOutline"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showOutline"}:
				_cgfd.ShowOutline = NewCT_Boolean()
				if _afea := d.DecodeElement(_cgfd.ShowOutline, &_bfdb); _afea != nil {
					return _afea
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showKeys"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showKeys"}:
				_cgfd.ShowKeys = NewCT_Boolean()
				if _ddaba := d.DecodeElement(_cgfd.ShowKeys, &_bfdb); _ddaba != nil {
					return _ddaba
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_cgfd.SpPr = _cb.NewCT_ShapeProperties()
				if _bccg := d.DecodeElement(_cgfd.SpPr, &_bfdb); _bccg != nil {
					return _bccg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_cgfd.TxPr = _cb.NewCT_TextBody()
				if _ccgdc := d.DecodeElement(_cgfd.TxPr, &_bfdb); _ccgdc != nil {
					return _ccgdc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_cgfd.ExtLst = NewCT_ExtensionList()
				if _bdcb := d.DecodeElement(_cgfd.ExtLst, &_bfdb); _bdcb != nil {
					return _bdcb
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_DTable \u0025v", _bfdb.Name)
				if _ggge := d.Skip(); _ggge != nil {
					return _ggge
				}
			}
		case _fa.EndElement:
			break _dbfg
		case _fa.CharData:
		}
	}
	return nil
}

type ST_AxPos byte

func (_cadgb *ST_PageSetupOrientation) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_gbbff, _gcgga := d.Token()
	if _gcgga != nil {
		return _gcgga
	}
	if _gegeg, _fccfd := _gbbff.(_fa.EndElement); _fccfd && _gegeg.Name == start.Name {
		*_cadgb = 1
		return nil
	}
	if _eceff, _acdgd := _gbbff.(_fa.CharData); !_acdgd {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gbbff)
	} else {
		switch string(_eceff) {
		case "":
			*_cadgb = 0
		case "default":
			*_cadgb = 1
		case "portrait":
			*_cadgb = 2
		case "landscape":
			*_cadgb = 3
		}
	}
	_gbbff, _gcgga = d.Token()
	if _gcgga != nil {
		return _gcgga
	}
	if _egefd, _aadda := _gbbff.(_fa.EndElement); _aadda && _egefd.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gbbff)
}

type CT_GapAmount struct{ ValAttr *ST_GapAmount }

func (_gcbca *CT_TickMark) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _fdgbf := range start.Attr {
		if _fdgbf.Name.Local == "val" {
			_gcbca.ValAttr.UnmarshalXMLAttr(_fdgbf)
			continue
		}
	}
	for {
		_cdfa, _ggbea := d.Token()
		if _ggbea != nil {
			return _gg.Errorf("parsing\u0020CT_TickMark:\u0020\u0025s", _ggbea)
		}
		if _cacab, _fabad := _cdfa.(_fa.EndElement); _fabad && _cacab.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_UpDownBar and its children
func (_defcef *CT_UpDownBar) Validate() error { return _defcef.ValidateWithPath("CT_UpDownBar") }
func (_bbfbe *CT_PlotArea) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_bafee:
	for {
		_dcbcc, _acbfg := d.Token()
		if _acbfg != nil {
			return _acbfg
		}
		switch _dggg := _dcbcc.(type) {
		case _fa.StartElement:
			switch _dggg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "layout"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "layout"}:
				_bbfbe.Layout = NewCT_Layout()
				if _ggee := d.DecodeElement(_bbfbe.Layout, &_dggg); _ggee != nil {
					return _ggee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "areaChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "areaChart"}:
				_cggbg := NewCT_PlotAreaChoice()
				if _bcede := d.DecodeElement(&_cggbg.AreaChart, &_dggg); _bcede != nil {
					return _bcede
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _cggbg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "area3DChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "area3DChart"}:
				_eecfc := NewCT_PlotAreaChoice()
				if _agef := d.DecodeElement(&_eecfc.Area3DChart, &_dggg); _agef != nil {
					return _agef
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _eecfc)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "lineChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "lineChart"}:
				_gabcc := NewCT_PlotAreaChoice()
				if _gfef := d.DecodeElement(&_gabcc.LineChart, &_dggg); _gfef != nil {
					return _gfef
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _gabcc)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "line3DChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "line3DChart"}:
				_cccaf := NewCT_PlotAreaChoice()
				if _bcefa := d.DecodeElement(&_cccaf.Line3DChart, &_dggg); _bcefa != nil {
					return _bcefa
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _cccaf)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "stockChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "stockChart"}:
				_gggg := NewCT_PlotAreaChoice()
				if _gggc := d.DecodeElement(&_gggg.StockChart, &_dggg); _gggc != nil {
					return _gggc
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _gggg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "radarChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "radarChart"}:
				_fabc := NewCT_PlotAreaChoice()
				if _dgfde := d.DecodeElement(&_fabc.RadarChart, &_dggg); _dgfde != nil {
					return _dgfde
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _fabc)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "scatterChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "scatterChart"}:
				_efdg := NewCT_PlotAreaChoice()
				if _aaff := d.DecodeElement(&_efdg.ScatterChart, &_dggg); _aaff != nil {
					return _aaff
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _efdg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pieChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pieChart"}:
				_eggcb := NewCT_PlotAreaChoice()
				if _aefee := d.DecodeElement(&_eggcb.PieChart, &_dggg); _aefee != nil {
					return _aefee
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _eggcb)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pie3DChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pie3DChart"}:
				_ddgeg := NewCT_PlotAreaChoice()
				if _gbec := d.DecodeElement(&_ddgeg.Pie3DChart, &_dggg); _gbec != nil {
					return _gbec
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _ddgeg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "doughnutChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "doughnutChart"}:
				_egbc := NewCT_PlotAreaChoice()
				if _cbaba := d.DecodeElement(&_egbc.DoughnutChart, &_dggg); _cbaba != nil {
					return _cbaba
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _egbc)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "barChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "barChart"}:
				_bffd := NewCT_PlotAreaChoice()
				if _fadd := d.DecodeElement(&_bffd.BarChart, &_dggg); _fadd != nil {
					return _fadd
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _bffd)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bar3DChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bar3DChart"}:
				_ebbag := NewCT_PlotAreaChoice()
				if _dgcff := d.DecodeElement(&_ebbag.Bar3DChart, &_dggg); _dgcff != nil {
					return _dgcff
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _ebbag)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ofPieChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ofPieChart"}:
				_abaf := NewCT_PlotAreaChoice()
				if _ebde := d.DecodeElement(&_abaf.OfPieChart, &_dggg); _ebde != nil {
					return _ebde
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _abaf)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "surfaceChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "surfaceChart"}:
				_efceb := NewCT_PlotAreaChoice()
				if _cfec := d.DecodeElement(&_efceb.SurfaceChart, &_dggg); _cfec != nil {
					return _cfec
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _efceb)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "surface3DChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "surface3DChart"}:
				_gaaa := NewCT_PlotAreaChoice()
				if _badb := d.DecodeElement(&_gaaa.Surface3DChart, &_dggg); _badb != nil {
					return _badb
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _gaaa)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bubbleChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bubbleChart"}:
				_dbfd := NewCT_PlotAreaChoice()
				if _eece := d.DecodeElement(&_dbfd.BubbleChart, &_dggg); _eece != nil {
					return _eece
				}
				_bbfbe.Choice = append(_bbfbe.Choice, _dbfd)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "valAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "valAx"}:
				if _bbfbe.CChoice == nil {
					_bbfbe.CChoice = NewCT_PlotAreaChoice1()
				}
				if _gfab := d.DecodeElement(&_bbfbe.CChoice.ValAx, &_dggg); _gfab != nil {
					return _gfab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "catAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "catAx"}:
				if _bbfbe.CChoice == nil {
					_bbfbe.CChoice = NewCT_PlotAreaChoice1()
				}
				if _dcgc := d.DecodeElement(&_bbfbe.CChoice.CatAx, &_dggg); _dcgc != nil {
					return _dcgc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dateAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dateAx"}:
				if _bbfbe.CChoice == nil {
					_bbfbe.CChoice = NewCT_PlotAreaChoice1()
				}
				if _gabff := d.DecodeElement(&_bbfbe.CChoice.DateAx, &_dggg); _gabff != nil {
					return _gabff
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "serAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "serAx"}:
				if _bbfbe.CChoice == nil {
					_bbfbe.CChoice = NewCT_PlotAreaChoice1()
				}
				if _gdag := d.DecodeElement(&_bbfbe.CChoice.SerAx, &_dggg); _gdag != nil {
					return _gdag
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dTable"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dTable"}:
				_bbfbe.DTable = NewCT_DTable()
				if _agfff := d.DecodeElement(_bbfbe.DTable, &_dggg); _agfff != nil {
					return _agfff
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_bbfbe.SpPr = _cb.NewCT_ShapeProperties()
				if _bcbda := d.DecodeElement(_bbfbe.SpPr, &_dggg); _bcbda != nil {
					return _bcbda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_bbfbe.ExtLst = NewCT_ExtensionList()
				if _adcg := d.DecodeElement(_bbfbe.ExtLst, &_dggg); _adcg != nil {
					return _adcg
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PlotArea\u0020\u0025v", _dggg.Name)
				if _fbfca := d.Skip(); _fbfca != nil {
					return _fbfca
				}
			}
		case _fa.EndElement:
			break _bafee
		case _fa.CharData:
		}
	}
	return nil
}
func (_deeca *ST_SizeRepresents) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_deeca = 0
	case "area":
		*_deeca = 1
	case "w":
		*_deeca = 2
	}
	return nil
}

// ValidateWithPath validates the CT_LineSer and its children, prefixing error messages with path
func (_abcc *CT_LineSer) ValidateWithPath(path string) error {
	if _aecc := _abcc.Idx.ValidateWithPath(path + "\u002fIdx"); _aecc != nil {
		return _aecc
	}
	if _eccf := _abcc.Order.ValidateWithPath(path + "\u002fOrder"); _eccf != nil {
		return _eccf
	}
	if _abcc.Tx != nil {
		if _aafb := _abcc.Tx.ValidateWithPath(path + "\u002fTx"); _aafb != nil {
			return _aafb
		}
	}
	if _abcc.SpPr != nil {
		if _bagc := _abcc.SpPr.ValidateWithPath(path + "\u002fSpPr"); _bagc != nil {
			return _bagc
		}
	}
	if _abcc.Marker != nil {
		if _ecab := _abcc.Marker.ValidateWithPath(path + "\u002fMarker"); _ecab != nil {
			return _ecab
		}
	}
	for _beag, _caec := range _abcc.DPt {
		if _fcceg := _caec.ValidateWithPath(_gg.Sprintf("\u0025s\u002fDPt\u005b\u0025d\u005d", path, _beag)); _fcceg != nil {
			return _fcceg
		}
	}
	if _abcc.DLbls != nil {
		if _dbba := _abcc.DLbls.ValidateWithPath(path + "\u002fDLbls"); _dbba != nil {
			return _dbba
		}
	}
	for _cfac, _beeag := range _abcc.Trendline {
		if _gffe := _beeag.ValidateWithPath(_gg.Sprintf("\u0025s/Trendline\u005b\u0025d\u005d", path, _cfac)); _gffe != nil {
			return _gffe
		}
	}
	if _abcc.ErrBars != nil {
		if _eddg := _abcc.ErrBars.ValidateWithPath(path + "\u002fErrBars"); _eddg != nil {
			return _eddg
		}
	}
	if _abcc.Cat != nil {
		if _aceea := _abcc.Cat.ValidateWithPath(path + "\u002fCat"); _aceea != nil {
			return _aceea
		}
	}
	if _abcc.Val != nil {
		if _abefe := _abcc.Val.ValidateWithPath(path + "\u002fVal"); _abefe != nil {
			return _abefe
		}
	}
	if _abcc.Smooth != nil {
		if _bface := _abcc.Smooth.ValidateWithPath(path + "\u002fSmooth"); _bface != nil {
			return _bface
		}
	}
	if _abcc.ExtLst != nil {
		if _affdb := _abcc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _affdb != nil {
			return _affdb
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ErrDir and its children, prefixing error messages with path
func (_aeff *CT_ErrDir) ValidateWithPath(path string) error {
	if _aeff.ValAttr == ST_ErrDirUnset {
		return _gg.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _gfbf := _aeff.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _gfbf != nil {
		return _gfbf
	}
	return nil
}
func NewCT_BubbleChart() *CT_BubbleChart { _bbfg := &CT_BubbleChart{}; return _bbfg }
func (_dggfg *UserShapes) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_dggfg.CT_Drawing = *_gd.NewCT_Drawing()
	for {
		_dceed, _eeega := d.Token()
		if _eeega != nil {
			return _gg.Errorf("parsing\u0020UserShapes:\u0020%s", _eeega)
		}
		if _ceca, _fbea := _dceed.(_fa.EndElement); _fbea && _ceca.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bfedd *CT_HPercent) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _bfedd.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_bfedd.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_cefbc *CT_MultiLvlStrRef) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_cfba:
	for {
		_gffab, _fggd := d.Token()
		if _fggd != nil {
			return _fggd
		}
		switch _eddc := _gffab.(type) {
		case _fa.StartElement:
			switch _eddc.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "f"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "f"}:
				if _dgee := d.DecodeElement(&_cefbc.F, &_eddc); _dgee != nil {
					return _dgee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "multiLvlStrCache"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "multiLvlStrCache"}:
				_cefbc.MultiLvlStrCache = NewCT_MultiLvlStrData()
				if _eefab := d.DecodeElement(_cefbc.MultiLvlStrCache, &_eddc); _eefab != nil {
					return _eefab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_cefbc.ExtLst = NewCT_ExtensionList()
				if _defcb := d.DecodeElement(_cefbc.ExtLst, &_eddc); _defcb != nil {
					return _defcb
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_MultiLvlStrRef\u0020\u0025v", _eddc.Name)
				if _dbfa := d.Skip(); _dbfa != nil {
					return _dbfa
				}
			}
		case _fa.EndElement:
			break _cfba
		case _fa.CharData:
		}
	}
	return nil
}

type CT_AreaSer struct {
	Idx            *CT_UnsignedInt
	Order          *CT_UnsignedInt
	Tx             *CT_SerTx
	SpPr           *_cb.CT_ShapeProperties
	PictureOptions *CT_PictureOptions
	DPt            []*CT_DPt
	DLbls          *CT_DLbls
	Trendline      []*CT_Trendline
	ErrBars        []*CT_ErrBars
	Cat            *CT_AxDataSource
	Val            *CT_NumDataSource
	ExtLst         *CT_ExtensionList
}

func NewCT_DLbls() *CT_DLbls { _bbcg := &CT_DLbls{}; return _bbcg }

// ValidateWithPath validates the CT_TextLanguageID and its children, prefixing error messages with path
func (_dgeeg *CT_TextLanguageID) ValidateWithPath(path string) error { return nil }
func (_degeg *CT_SerTxChoice) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _degeg.StrRef != nil {
		_ceecg := _fa.StartElement{Name: _fa.Name{Local: "c:strRef"}}
		e.EncodeElement(_degeg.StrRef, _ceecg)
	}
	if _degeg.V != nil {
		_bfede := _fa.StartElement{Name: _fa.Name{Local: "c:v"}}
		_b.AddPreserveSpaceAttr(&_bfede, *_degeg.V)
		e.EncodeElement(_degeg.V, _bfede)
	}
	return nil
}
func (_ccbcg *CT_MultiLvlStrData) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_aggf:
	for {
		_cbgaa, _aced := d.Token()
		if _aced != nil {
			return _aced
		}
		switch _ggbdb := _cbgaa.(type) {
		case _fa.StartElement:
			switch _ggbdb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ptCount"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ptCount"}:
				_ccbcg.PtCount = NewCT_UnsignedInt()
				if _adaae := d.DecodeElement(_ccbcg.PtCount, &_ggbdb); _adaae != nil {
					return _adaae
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "lvl"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "lvl"}:
				_dfgd := NewCT_Lvl()
				if _ccaa := d.DecodeElement(_dfgd, &_ggbdb); _ccaa != nil {
					return _ccaa
				}
				_ccbcg.Lvl = append(_ccbcg.Lvl, _dfgd)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_ccbcg.ExtLst = NewCT_ExtensionList()
				if _cgfdb := d.DecodeElement(_ccbcg.ExtLst, &_ggbdb); _cgfdb != nil {
					return _cgfdb
				}
			default:
				_b.Log("skipping\u0020unsupported element\u0020on\u0020CT_MultiLvlStrData\u0020\u0025v", _ggbdb.Name)
				if _adaf := d.Skip(); _adaf != nil {
					return _adaf
				}
			}
		case _fa.EndElement:
			break _aggf
		case _fa.CharData:
		}
	}
	return nil
}
func (_cagdd *CT_SerTx) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cagdd.Choice.MarshalXML(e, _fa.StartElement{})
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_PageMargins struct {
	LAttr      float64
	RAttr      float64
	TAttr      float64
	BAttr      float64
	HeaderAttr float64
	FooterAttr float64
}

// Validate validates the CT_BandFmts and its children
func (_ecdc *CT_BandFmts) Validate() error { return _ecdc.ValidateWithPath("CT_BandFmts") }

// ValidateWithPath validates the CT_ScatterSer and its children, prefixing error messages with path
func (_cedac *CT_ScatterSer) ValidateWithPath(path string) error {
	if _egcgb := _cedac.Idx.ValidateWithPath(path + "\u002fIdx"); _egcgb != nil {
		return _egcgb
	}
	if _ecde := _cedac.Order.ValidateWithPath(path + "\u002fOrder"); _ecde != nil {
		return _ecde
	}
	if _cedac.Tx != nil {
		if _efaae := _cedac.Tx.ValidateWithPath(path + "\u002fTx"); _efaae != nil {
			return _efaae
		}
	}
	if _cedac.SpPr != nil {
		if _aafa := _cedac.SpPr.ValidateWithPath(path + "\u002fSpPr"); _aafa != nil {
			return _aafa
		}
	}
	if _cedac.Marker != nil {
		if _ddee := _cedac.Marker.ValidateWithPath(path + "\u002fMarker"); _ddee != nil {
			return _ddee
		}
	}
	for _bfgfcf, _fdgcd := range _cedac.DPt {
		if _bgbg := _fdgcd.ValidateWithPath(_gg.Sprintf("\u0025s\u002fDPt\u005b\u0025d\u005d", path, _bfgfcf)); _bgbg != nil {
			return _bgbg
		}
	}
	if _cedac.DLbls != nil {
		if _fcdc := _cedac.DLbls.ValidateWithPath(path + "\u002fDLbls"); _fcdc != nil {
			return _fcdc
		}
	}
	for _cgbd, _bgdfg := range _cedac.Trendline {
		if _dcbga := _bgdfg.ValidateWithPath(_gg.Sprintf("\u0025s/Trendline\u005b\u0025d\u005d", path, _cgbd)); _dcbga != nil {
			return _dcbga
		}
	}
	for _bdeg, _fedac := range _cedac.ErrBars {
		if _ebbfb := _fedac.ValidateWithPath(_gg.Sprintf("\u0025s\u002fErrBars\u005b\u0025d\u005d", path, _bdeg)); _ebbfb != nil {
			return _ebbfb
		}
	}
	if _cedac.XVal != nil {
		if _bdafd := _cedac.XVal.ValidateWithPath(path + "\u002fXVal"); _bdafd != nil {
			return _bdafd
		}
	}
	if _cedac.YVal != nil {
		if _adac := _cedac.YVal.ValidateWithPath(path + "\u002fYVal"); _adac != nil {
			return _adac
		}
	}
	if _cedac.Smooth != nil {
		if _ggefc := _cedac.Smooth.ValidateWithPath(path + "\u002fSmooth"); _ggefc != nil {
			return _ggefc
		}
	}
	if _cedac.ExtLst != nil {
		if _fbge := _cedac.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fbge != nil {
			return _fbge
		}
	}
	return nil
}
func (_gebdb *Group_DLbls) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_abadg:
	for {
		_feded, _eceae := d.Token()
		if _eceae != nil {
			return _eceae
		}
		switch _gcaff := _feded.(type) {
		case _fa.StartElement:
			switch _gcaff.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				_gebdb.NumFmt = NewCT_NumFmt()
				if _fgdbd := d.DecodeElement(_gebdb.NumFmt, &_gcaff); _fgdbd != nil {
					return _fgdbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_gebdb.SpPr = _cb.NewCT_ShapeProperties()
				if _gbde := d.DecodeElement(_gebdb.SpPr, &_gcaff); _gbde != nil {
					return _gbde
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_gebdb.TxPr = _cb.NewCT_TextBody()
				if _fcadb := d.DecodeElement(_gebdb.TxPr, &_gcaff); _fcadb != nil {
					return _fcadb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLblPos"}:
				_gebdb.DLblPos = NewCT_DLblPos()
				if _dgbdc := d.DecodeElement(_gebdb.DLblPos, &_gcaff); _dgbdc != nil {
					return _dgbdc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showLegendKey"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showLegendKey"}:
				_gebdb.ShowLegendKey = NewCT_Boolean()
				if _aaedg := d.DecodeElement(_gebdb.ShowLegendKey, &_gcaff); _aaedg != nil {
					return _aaedg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showVal"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showVal"}:
				_gebdb.ShowVal = NewCT_Boolean()
				if _fgaab := d.DecodeElement(_gebdb.ShowVal, &_gcaff); _fgaab != nil {
					return _fgaab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showCatName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showCatName"}:
				_gebdb.ShowCatName = NewCT_Boolean()
				if _adbd := d.DecodeElement(_gebdb.ShowCatName, &_gcaff); _adbd != nil {
					return _adbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showSerName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showSerName"}:
				_gebdb.ShowSerName = NewCT_Boolean()
				if _bcda := d.DecodeElement(_gebdb.ShowSerName, &_gcaff); _bcda != nil {
					return _bcda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showPercent"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showPercent"}:
				_gebdb.ShowPercent = NewCT_Boolean()
				if _acbbc := d.DecodeElement(_gebdb.ShowPercent, &_gcaff); _acbbc != nil {
					return _acbbc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showBubbleSize"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showBubbleSize"}:
				_gebdb.ShowBubbleSize = NewCT_Boolean()
				if _cddef := d.DecodeElement(_gebdb.ShowBubbleSize, &_gcaff); _cddef != nil {
					return _cddef
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "separator"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "separator"}:
				_gebdb.Separator = new(string)
				if _dbdac := d.DecodeElement(_gebdb.Separator, &_gcaff); _dbdac != nil {
					return _dbdac
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showLeaderLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showLeaderLines"}:
				_gebdb.ShowLeaderLines = NewCT_Boolean()
				if _gagdf := d.DecodeElement(_gebdb.ShowLeaderLines, &_gcaff); _gagdf != nil {
					return _gagdf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "leaderLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "leaderLines"}:
				_gebdb.LeaderLines = NewCT_ChartLines()
				if _gega := d.DecodeElement(_gebdb.LeaderLines, &_gcaff); _gega != nil {
					return _gega
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Group_DLbls\u0020\u0025v", _gcaff.Name)
				if _ccfeae := d.Skip(); _ccfeae != nil {
					return _ccfeae
				}
			}
		case _fa.EndElement:
			break _abadg
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_DateAx and its children
func (_bgdd *CT_DateAx) Validate() error { return _bgdd.ValidateWithPath("CT_DateAx") }

type CT_PlotArea struct {
	Layout  *CT_Layout
	Choice  []*CT_PlotAreaChoice
	CChoice *CT_PlotAreaChoice1
	DTable  *CT_DTable
	SpPr    *_cb.CT_ShapeProperties
	ExtLst  *CT_ExtensionList
}

func (_ecaae *CT_RadarStyle) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _egbeg := range start.Attr {
		if _egbeg.Name.Local == "val" {
			_ecaae.ValAttr.UnmarshalXMLAttr(_egbeg)
			continue
		}
	}
	for {
		_fcdae, _afae := d.Token()
		if _afae != nil {
			return _gg.Errorf("parsing\u0020CT_RadarStyle:\u0020\u0025s", _afae)
		}
		if _dedb, _ddgdb := _fcdae.(_fa.EndElement); _ddgdb && _dedb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cedd ST_ErrBarType) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_aeaab := _fa.Attr{}
	_aeaab.Name = name
	switch _cedd {
	case ST_ErrBarTypeUnset:
		_aeaab.Value = ""
	case ST_ErrBarTypeBoth:
		_aeaab.Value = "both"
	case ST_ErrBarTypeMinus:
		_aeaab.Value = "minus"
	case ST_ErrBarTypePlus:
		_aeaab.Value = "plus"
	}
	return _aeaab, nil
}
func (_efgdd *ST_DLblPos) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_dagcg, _faeff := d.Token()
	if _faeff != nil {
		return _faeff
	}
	if _gbbde, _ccaee := _dagcg.(_fa.EndElement); _ccaee && _gbbde.Name == start.Name {
		*_efgdd = 1
		return nil
	}
	if _aaab, _bacbb := _dagcg.(_fa.CharData); !_bacbb {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dagcg)
	} else {
		switch string(_aaab) {
		case "":
			*_efgdd = 0
		case "bestFit":
			*_efgdd = 1
		case "b":
			*_efgdd = 2
		case "ctr":
			*_efgdd = 3
		case "inBase":
			*_efgdd = 4
		case "inEnd":
			*_efgdd = 5
		case "l":
			*_efgdd = 6
		case "outEnd":
			*_efgdd = 7
		case "r":
			*_efgdd = 8
		case "t":
			*_efgdd = 9
		}
	}
	_dagcg, _faeff = d.Token()
	if _faeff != nil {
		return _faeff
	}
	if _gafccb, _gbgg := _dagcg.(_fa.EndElement); _gbgg && _gafccb.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dagcg)
}

const (
	ST_DLblPosUnset   ST_DLblPos = 0
	ST_DLblPosBestFit ST_DLblPos = 1
	ST_DLblPosB       ST_DLblPos = 2
	ST_DLblPosCtr     ST_DLblPos = 3
	ST_DLblPosInBase  ST_DLblPos = 4
	ST_DLblPosInEnd   ST_DLblPos = 5
	ST_DLblPosL       ST_DLblPos = 6
	ST_DLblPosOutEnd  ST_DLblPos = 7
	ST_DLblPosR       ST_DLblPos = 8
	ST_DLblPosT       ST_DLblPos = 9
)

// ValidateWithPath validates the CT_PieChart and its children, prefixing error messages with path
func (_bgdc *CT_PieChart) ValidateWithPath(path string) error {
	if _bgdc.VaryColors != nil {
		if _gcgc := _bgdc.VaryColors.ValidateWithPath(path + "/VaryColors"); _gcgc != nil {
			return _gcgc
		}
	}
	for _aeec, _ebgef := range _bgdc.Ser {
		if _bfff := _ebgef.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _aeec)); _bfff != nil {
			return _bfff
		}
	}
	if _bgdc.DLbls != nil {
		if _cffe := _bgdc.DLbls.ValidateWithPath(path + "\u002fDLbls"); _cffe != nil {
			return _cffe
		}
	}
	if _bgdc.FirstSliceAng != nil {
		if _eede := _bgdc.FirstSliceAng.ValidateWithPath(path + "\u002fFirstSliceAng"); _eede != nil {
			return _eede
		}
	}
	if _bgdc.ExtLst != nil {
		if _gcegg := _bgdc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gcegg != nil {
			return _gcegg
		}
	}
	return nil
}
func (_ccbb *CT_TrendlineLbl) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _ccbb.Layout != nil {
		_beeeda := _fa.StartElement{Name: _fa.Name{Local: "c:layout"}}
		e.EncodeElement(_ccbb.Layout, _beeeda)
	}
	if _ccbb.Tx != nil {
		_gffabg := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_ccbb.Tx, _gffabg)
	}
	if _ccbb.NumFmt != nil {
		_gbba := _fa.StartElement{Name: _fa.Name{Local: "c:numFmt"}}
		e.EncodeElement(_ccbb.NumFmt, _gbba)
	}
	if _ccbb.SpPr != nil {
		_dcacf := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_ccbb.SpPr, _dcacf)
	}
	if _ccbb.TxPr != nil {
		_fcafcg := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_ccbb.TxPr, _fcafcg)
	}
	if _ccbb.ExtLst != nil {
		_efceg := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_ccbb.ExtLst, _efceg)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func ParseUnionST_SecondPieSize(s string) (ST_SecondPieSize, error) {
	if ST_SecondPieSizePercentPatternRe.MatchString(s) {
		return ST_SecondPieSize{ST_SecondPieSizePercent: &s}, nil
	}
	_daccb, _aaeag := _c.ParseUint(s, 10, 16)
	if _aaeag != nil {
		return ST_SecondPieSize{}, _aaeag
	}
	_dbagb := uint16(_daccb)
	return ST_SecondPieSize{ST_SecondPieSizeUShort: &_dbagb}, nil
}

// ValidateWithPath validates the CT_ChartSpace and its children, prefixing error messages with path
func (_ffcca *CT_ChartSpace) ValidateWithPath(path string) error {
	if _ffcca.Date1904 != nil {
		if _bfd := _ffcca.Date1904.ValidateWithPath(path + "\u002fDate1904"); _bfd != nil {
			return _bfd
		}
	}
	if _ffcca.Lang != nil {
		if _cfdf := _ffcca.Lang.ValidateWithPath(path + "\u002fLang"); _cfdf != nil {
			return _cfdf
		}
	}
	if _ffcca.RoundedCorners != nil {
		if _fafb := _ffcca.RoundedCorners.ValidateWithPath(path + "\u002fRoundedCorners"); _fafb != nil {
			return _fafb
		}
	}
	if _ffcca.Style != nil {
		if _eadf := _ffcca.Style.ValidateWithPath(path + "\u002fStyle"); _eadf != nil {
			return _eadf
		}
	}
	if _ffcca.ClrMapOvr != nil {
		if _daddf := _ffcca.ClrMapOvr.ValidateWithPath(path + "\u002fClrMapOvr"); _daddf != nil {
			return _daddf
		}
	}
	if _ffcca.PivotSource != nil {
		if _bdcc := _ffcca.PivotSource.ValidateWithPath(path + "\u002fPivotSource"); _bdcc != nil {
			return _bdcc
		}
	}
	if _ffcca.Protection != nil {
		if _gbae := _ffcca.Protection.ValidateWithPath(path + "/Protection"); _gbae != nil {
			return _gbae
		}
	}
	if _acgd := _ffcca.Chart.ValidateWithPath(path + "\u002fChart"); _acgd != nil {
		return _acgd
	}
	if _ffcca.SpPr != nil {
		if _bdaf := _ffcca.SpPr.ValidateWithPath(path + "\u002fSpPr"); _bdaf != nil {
			return _bdaf
		}
	}
	if _ffcca.TxPr != nil {
		if _aegf := _ffcca.TxPr.ValidateWithPath(path + "\u002fTxPr"); _aegf != nil {
			return _aegf
		}
	}
	if _ffcca.ExternalData != nil {
		if _fddb := _ffcca.ExternalData.ValidateWithPath(path + "\u002fExternalData"); _fddb != nil {
			return _fddb
		}
	}
	if _ffcca.PrintSettings != nil {
		if _bbga := _ffcca.PrintSettings.ValidateWithPath(path + "\u002fPrintSettings"); _bbga != nil {
			return _bbga
		}
	}
	if _ffcca.UserShapes != nil {
		if _fdcg := _ffcca.UserShapes.ValidateWithPath(path + "/UserShapes"); _fdcg != nil {
			return _fdcg
		}
	}
	if _ffcca.ExtLst != nil {
		if _daddd := _ffcca.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _daddd != nil {
			return _daddd
		}
	}
	return nil
}

const (
	ST_BarGroupingUnset          ST_BarGrouping = 0
	ST_BarGroupingPercentStacked ST_BarGrouping = 1
	ST_BarGroupingClustered      ST_BarGrouping = 2
	ST_BarGroupingStandard       ST_BarGrouping = 3
	ST_BarGroupingStacked        ST_BarGrouping = 4
)

func (_egbga ST_PictureFormat) Validate() error { return _egbga.ValidateWithPath("") }
func (_egefg ST_OfPieType) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_egefg.String(), start)
}
func (_gfbag *EG_SerShared) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_gfbag.Idx = NewCT_UnsignedInt()
	_gfbag.Order = NewCT_UnsignedInt()
_daacf:
	for {
		_aaafc, _eafef := d.Token()
		if _eafef != nil {
			return _eafef
		}
		switch _eedf := _aaafc.(type) {
		case _fa.StartElement:
			switch _eedf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _ddeab := d.DecodeElement(_gfbag.Idx, &_eedf); _ddeab != nil {
					return _ddeab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "order"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "order"}:
				if _ggdfa := d.DecodeElement(_gfbag.Order, &_eedf); _ggdfa != nil {
					return _ggdfa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_gfbag.Tx = NewCT_SerTx()
				if _bfacg := d.DecodeElement(_gfbag.Tx, &_eedf); _bfacg != nil {
					return _bfacg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_gfbag.SpPr = _cb.NewCT_ShapeProperties()
				if _affab := d.DecodeElement(_gfbag.SpPr, &_eedf); _affab != nil {
					return _affab
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_SerShared\u0020\u0025v", _eedf.Name)
				if _geeee := d.Skip(); _geeee != nil {
					return _geeee
				}
			}
		case _fa.EndElement:
			break _daacf
		case _fa.CharData:
		}
	}
	return nil
}
func (_fccfed *CT_TickMark) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _fccfed.ValAttr != ST_TickMarkUnset {
		_egce, _dbbccf := _fccfed.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _dbbccf != nil {
			return _dbbccf
		}
		start.Attr = append(start.Attr, _egce)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_afgc ST_BarGrouping) Validate() error { return _afgc.ValidateWithPath("") }

type ST_Orientation byte

func (_cefba ST_TickMark) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_cefba.String(), start)
}

// ValidateWithPath validates the CT_BarGrouping and its children, prefixing error messages with path
func (_dag *CT_BarGrouping) ValidateWithPath(path string) error {
	if _cbad := _dag.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _cbad != nil {
		return _cbad
	}
	return nil
}
func (_afbegg ST_LblAlgn) String() string {
	switch _afbegg {
	case 0:
		return ""
	case 1:
		return "ctr"
	case 2:
		return "l"
	case 3:
		return "r"
	}
	return ""
}
func NewCT_Scaling() *CT_Scaling { _bcgdc := &CT_Scaling{}; return _bcgdc }
func (_bbeg *CT_CatAx) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bbeg.AxId = NewCT_UnsignedInt()
	_bbeg.Scaling = NewCT_Scaling()
	_bbeg.AxPos = NewCT_AxPos()
	_bbeg.CrossAx = NewCT_UnsignedInt()
_addg:
	for {
		_dacf, _ebee := d.Token()
		if _ebee != nil {
			return _ebee
		}
		switch _eadd := _dacf.(type) {
		case _fa.StartElement:
			switch _eadd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				if _gacb := d.DecodeElement(_bbeg.AxId, &_eadd); _gacb != nil {
					return _gacb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "scaling"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "scaling"}:
				if _dedg := d.DecodeElement(_bbeg.Scaling, &_eadd); _dedg != nil {
					return _dedg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "delete"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "delete"}:
				_bbeg.Delete = NewCT_Boolean()
				if _dabd := d.DecodeElement(_bbeg.Delete, &_eadd); _dabd != nil {
					return _dabd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axPos"}:
				if _eeed := d.DecodeElement(_bbeg.AxPos, &_eadd); _eeed != nil {
					return _eeed
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorGridlines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorGridlines"}:
				_bbeg.MajorGridlines = NewCT_ChartLines()
				if _cgff := d.DecodeElement(_bbeg.MajorGridlines, &_eadd); _cgff != nil {
					return _cgff
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorGridlines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorGridlines"}:
				_bbeg.MinorGridlines = NewCT_ChartLines()
				if _adgb := d.DecodeElement(_bbeg.MinorGridlines, &_eadd); _adgb != nil {
					return _adgb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "title"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "title"}:
				_bbeg.Title = NewCT_Title()
				if _gdff := d.DecodeElement(_bbeg.Title, &_eadd); _gdff != nil {
					return _gdff
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				_bbeg.NumFmt = NewCT_NumFmt()
				if _bdgf := d.DecodeElement(_bbeg.NumFmt, &_eadd); _bdgf != nil {
					return _bdgf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorTickMark"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorTickMark"}:
				_bbeg.MajorTickMark = NewCT_TickMark()
				if _gfd := d.DecodeElement(_bbeg.MajorTickMark, &_eadd); _gfd != nil {
					return _gfd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorTickMark"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorTickMark"}:
				_bbeg.MinorTickMark = NewCT_TickMark()
				if _ebeeb := d.DecodeElement(_bbeg.MinorTickMark, &_eadd); _ebeeb != nil {
					return _ebeeb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tickLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tickLblPos"}:
				_bbeg.TickLblPos = NewCT_TickLblPos()
				if _babe := d.DecodeElement(_bbeg.TickLblPos, &_eadd); _babe != nil {
					return _babe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_bbeg.SpPr = _cb.NewCT_ShapeProperties()
				if _gbcc := d.DecodeElement(_bbeg.SpPr, &_eadd); _gbcc != nil {
					return _gbcc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_bbeg.TxPr = _cb.NewCT_TextBody()
				if _gbaaf := d.DecodeElement(_bbeg.TxPr, &_eadd); _gbaaf != nil {
					return _gbaaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossAx"}:
				if _fec := d.DecodeElement(_bbeg.CrossAx, &_eadd); _fec != nil {
					return _fec
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crosses"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crosses"}:
				_bbeg.Choice = NewEG_AxSharedChoice()
				if _cgdg := d.DecodeElement(&_bbeg.Choice.Crosses, &_eadd); _cgdg != nil {
					return _cgdg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossesAt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossesAt"}:
				_bbeg.Choice = NewEG_AxSharedChoice()
				if _gdae := d.DecodeElement(&_bbeg.Choice.CrossesAt, &_eadd); _gdae != nil {
					return _gdae
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "auto"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "auto"}:
				_bbeg.Auto = NewCT_Boolean()
				if _ffdg := d.DecodeElement(_bbeg.Auto, &_eadd); _ffdg != nil {
					return _ffdg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "lblAlgn"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "lblAlgn"}:
				_bbeg.LblAlgn = NewCT_LblAlgn()
				if _aacb := d.DecodeElement(_bbeg.LblAlgn, &_eadd); _aacb != nil {
					return _aacb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "lblOffset"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "lblOffset"}:
				_bbeg.LblOffset = NewCT_LblOffset()
				if _caf := d.DecodeElement(_bbeg.LblOffset, &_eadd); _caf != nil {
					return _caf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tickLblSkip"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tickLblSkip"}:
				_bbeg.TickLblSkip = NewCT_Skip()
				if _gcca := d.DecodeElement(_bbeg.TickLblSkip, &_eadd); _gcca != nil {
					return _gcca
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tickMarkSkip"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tickMarkSkip"}:
				_bbeg.TickMarkSkip = NewCT_Skip()
				if _adeg := d.DecodeElement(_bbeg.TickMarkSkip, &_eadd); _adeg != nil {
					return _adeg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "noMultiLvlLbl"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "noMultiLvlLbl"}:
				_bbeg.NoMultiLvlLbl = NewCT_Boolean()
				if _bdeff := d.DecodeElement(_bbeg.NoMultiLvlLbl, &_eadd); _bdeff != nil {
					return _bdeff
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_bbeg.ExtLst = NewCT_ExtensionList()
				if _bgeg := d.DecodeElement(_bbeg.ExtLst, &_eadd); _bgeg != nil {
					return _bgeg
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CatAx\u0020\u0025v", _eadd.Name)
				if _bae := d.Skip(); _bae != nil {
					return _bae
				}
			}
		case _fa.EndElement:
			break _addg
		case _fa.CharData:
		}
	}
	return nil
}

const (
	ST_LblAlgnUnset ST_LblAlgn = 0
	ST_LblAlgnCtr   ST_LblAlgn = 1
	ST_LblAlgnL     ST_LblAlgn = 2
	ST_LblAlgnR     ST_LblAlgn = 3
)

func (_cbecd *ST_LblAlgn) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ecdca, _gfcdd := d.Token()
	if _gfcdd != nil {
		return _gfcdd
	}
	if _abgb, _ggacec := _ecdca.(_fa.EndElement); _ggacec && _abgb.Name == start.Name {
		*_cbecd = 1
		return nil
	}
	if _gaeeg, _eccae := _ecdca.(_fa.CharData); !_eccae {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ecdca)
	} else {
		switch string(_gaeeg) {
		case "":
			*_cbecd = 0
		case "ctr":
			*_cbecd = 1
		case "l":
			*_cbecd = 2
		case "r":
			*_cbecd = 3
		}
	}
	_ecdca, _gfcdd = d.Token()
	if _gfcdd != nil {
		return _gfcdd
	}
	if _ffaed, _egebbd := _ecdca.(_fa.EndElement); _egebbd && _ffaed.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ecdca)
}
func (_aagfb *CT_Pie3DChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _aagfb.VaryColors != nil {
		_gbdg := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_aagfb.VaryColors, _gbdg)
	}
	if _aagfb.Ser != nil {
		_bbdf := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _aadc := range _aagfb.Ser {
			e.EncodeElement(_aadc, _bbdf)
		}
	}
	if _aagfb.DLbls != nil {
		_gcgbc := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_aagfb.DLbls, _gcgbc)
	}
	if _aagfb.ExtLst != nil {
		_egdba := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_aagfb.ExtLst, _egdba)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_bgfcba *EG_SerShared) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_bdebc := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_bgfcba.Idx, _bdebc)
	_bgbe := _fa.StartElement{Name: _fa.Name{Local: "c:order"}}
	e.EncodeElement(_bgfcba.Order, _bgbe)
	if _bgfcba.Tx != nil {
		_dgfdeg := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_bgfcba.Tx, _dgfdeg)
	}
	if _bgfcba.SpPr != nil {
		_aeffe := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_bgfcba.SpPr, _aeffe)
	}
	return nil
}
func (_gbbge *ST_Grouping) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bebcg, _bcfgc := d.Token()
	if _bcfgc != nil {
		return _bcfgc
	}
	if _cebbd, _gdebc := _bebcg.(_fa.EndElement); _gdebc && _cebbd.Name == start.Name {
		*_gbbge = 1
		return nil
	}
	if _eeebf, _gefab := _bebcg.(_fa.CharData); !_gefab {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bebcg)
	} else {
		switch string(_eeebf) {
		case "":
			*_gbbge = 0
		case "percentStacked":
			*_gbbge = 1
		case "standard":
			*_gbbge = 2
		case "stacked":
			*_gbbge = 3
		}
	}
	_bebcg, _bcfgc = d.Token()
	if _bcfgc != nil {
		return _bcfgc
	}
	if _dabb, _ecegd := _bebcg.(_fa.EndElement); _ecegd && _dabb.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bebcg)
}
func (_bgfega *CT_StrData) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _bgfega.PtCount != nil {
		_efcbb := _fa.StartElement{Name: _fa.Name{Local: "c:ptCount"}}
		e.EncodeElement(_bgfega.PtCount, _efcbb)
	}
	if _bgfega.Pt != nil {
		_acdc := _fa.StartElement{Name: _fa.Name{Local: "c:pt"}}
		for _, _dagd := range _bgfega.Pt {
			e.EncodeElement(_dagd, _acdc)
		}
	}
	if _bgfega.ExtLst != nil {
		_cgafb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_bgfega.ExtLst, _cgafb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Skip and its children
func (_cafdae *CT_Skip) Validate() error { return _cafdae.ValidateWithPath("CT_Skip") }
func (_gdbb ST_GapAmount) String() string {
	if _gdbb.ST_GapAmountPercent != nil {
		return _gg.Sprintf("\u0025v", *_gdbb.ST_GapAmountPercent)
	}
	if _gdbb.ST_GapAmountUShort != nil {
		return _gg.Sprintf("\u0025v", *_gdbb.ST_GapAmountUShort)
	}
	return ""
}
func (_dgbcd *EG_PieChartShared) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_faedf:
	for {
		_eacbe, _bddce := d.Token()
		if _bddce != nil {
			return _bddce
		}
		switch _abcddb := _eacbe.(type) {
		case _fa.StartElement:
			switch _abcddb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_dgbcd.VaryColors = NewCT_Boolean()
				if _dgfgb := d.DecodeElement(_dgbcd.VaryColors, &_abcddb); _dgfgb != nil {
					return _dgfgb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_eedef := NewCT_PieSer()
				if _egbgd := d.DecodeElement(_eedef, &_abcddb); _egbgd != nil {
					return _egbgd
				}
				_dgbcd.Ser = append(_dgbcd.Ser, _eedef)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_dgbcd.DLbls = NewCT_DLbls()
				if _bfded := d.DecodeElement(_dgbcd.DLbls, &_abcddb); _bfded != nil {
					return _bfded
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020EG_PieChartShared\u0020\u0025v", _abcddb.Name)
				if _cbbge := d.Skip(); _cbbge != nil {
					return _cbbge
				}
			}
		case _fa.EndElement:
			break _faedf
		case _fa.CharData:
		}
	}
	return nil
}
func (_fdfcb *EG_LegendEntryData) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _fdfcb.TxPr != nil {
		_gadbbg := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_fdfcb.TxPr, _gadbbg)
	}
	return nil
}
func (_ebbg *CT_HPercent) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _fafc := range start.Attr {
		if _fafc.Name.Local == "val" {
			_cccd, _defbf := ParseUnionST_HPercent(_fafc.Value)
			if _defbf != nil {
				return _defbf
			}
			_ebbg.ValAttr = &_cccd
			continue
		}
	}
	for {
		_gedf, _aabgc := d.Token()
		if _aabgc != nil {
			return _gg.Errorf("parsing\u0020CT_HPercent:\u0020\u0025s", _aabgc)
		}
		if _fcgg, _bdga := _gedf.(_fa.EndElement); _bdga && _fcgg.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_AxDataSourceChoice struct {
	MultiLvlStrRef *CT_MultiLvlStrRef
	NumRef         *CT_NumRef
	NumLit         *CT_NumData
	StrRef         *CT_StrRef
	StrLit         *CT_StrData
}

func (_cgad *ST_SecondPieSize) Validate() error { return _cgad.ValidateWithPath("") }
func NewCT_NumData() *CT_NumData                { _aabfgg := &CT_NumData{}; return _aabfgg }

const (
	ST_BuiltInUnitUnset            ST_BuiltInUnit = 0
	ST_BuiltInUnitHundreds         ST_BuiltInUnit = 1
	ST_BuiltInUnitThousands        ST_BuiltInUnit = 2
	ST_BuiltInUnitTenThousands     ST_BuiltInUnit = 3
	ST_BuiltInUnitHundredThousands ST_BuiltInUnit = 4
	ST_BuiltInUnitMillions         ST_BuiltInUnit = 5
	ST_BuiltInUnitTenMillions      ST_BuiltInUnit = 6
	ST_BuiltInUnitHundredMillions  ST_BuiltInUnit = 7
	ST_BuiltInUnitBillions         ST_BuiltInUnit = 8
	ST_BuiltInUnitTrillions        ST_BuiltInUnit = 9
)

func NewCT_AreaSer() *CT_AreaSer {
	_aef := &CT_AreaSer{}
	_aef.Idx = NewCT_UnsignedInt()
	_aef.Order = NewCT_UnsignedInt()
	return _aef
}
func NewCT_Double() *CT_Double { _eadg := &CT_Double{}; return _eadg }

// ValidateWithPath validates the CT_Surface and its children, prefixing error messages with path
func (_egfgd *CT_Surface) ValidateWithPath(path string) error {
	if _egfgd.Thickness != nil {
		if _afdea := _egfgd.Thickness.ValidateWithPath(path + "\u002fThickness"); _afdea != nil {
			return _afdea
		}
	}
	if _egfgd.SpPr != nil {
		if _dcaeb := _egfgd.SpPr.ValidateWithPath(path + "\u002fSpPr"); _dcaeb != nil {
			return _dcaeb
		}
	}
	if _egfgd.PictureOptions != nil {
		if _bdeca := _egfgd.PictureOptions.ValidateWithPath(path + "\u002fPictureOptions"); _bdeca != nil {
			return _bdeca
		}
	}
	if _egfgd.ExtLst != nil {
		if _ggddf := _egfgd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ggddf != nil {
			return _ggddf
		}
	}
	return nil
}
func (_fcfac *CT_ValAx) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_fcfac.AxId = NewCT_UnsignedInt()
	_fcfac.Scaling = NewCT_Scaling()
	_fcfac.AxPos = NewCT_AxPos()
	_fcfac.CrossAx = NewCT_UnsignedInt()
_cddg:
	for {
		_gdee, _gadgb := d.Token()
		if _gadgb != nil {
			return _gadgb
		}
		switch _cdddf := _gdee.(type) {
		case _fa.StartElement:
			switch _cdddf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				if _gagbga := d.DecodeElement(_fcfac.AxId, &_cdddf); _gagbga != nil {
					return _gagbga
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "scaling"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "scaling"}:
				if _dedd := d.DecodeElement(_fcfac.Scaling, &_cdddf); _dedd != nil {
					return _dedd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "delete"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "delete"}:
				_fcfac.Delete = NewCT_Boolean()
				if _dbgdd := d.DecodeElement(_fcfac.Delete, &_cdddf); _dbgdd != nil {
					return _dbgdd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axPos"}:
				if _aefcb := d.DecodeElement(_fcfac.AxPos, &_cdddf); _aefcb != nil {
					return _aefcb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorGridlines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorGridlines"}:
				_fcfac.MajorGridlines = NewCT_ChartLines()
				if _feegc := d.DecodeElement(_fcfac.MajorGridlines, &_cdddf); _feegc != nil {
					return _feegc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorGridlines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorGridlines"}:
				_fcfac.MinorGridlines = NewCT_ChartLines()
				if _edcbc := d.DecodeElement(_fcfac.MinorGridlines, &_cdddf); _edcbc != nil {
					return _edcbc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "title"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "title"}:
				_fcfac.Title = NewCT_Title()
				if _deggc := d.DecodeElement(_fcfac.Title, &_cdddf); _deggc != nil {
					return _deggc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				_fcfac.NumFmt = NewCT_NumFmt()
				if _adab := d.DecodeElement(_fcfac.NumFmt, &_cdddf); _adab != nil {
					return _adab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorTickMark"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorTickMark"}:
				_fcfac.MajorTickMark = NewCT_TickMark()
				if _dffb := d.DecodeElement(_fcfac.MajorTickMark, &_cdddf); _dffb != nil {
					return _dffb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorTickMark"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorTickMark"}:
				_fcfac.MinorTickMark = NewCT_TickMark()
				if _adgfg := d.DecodeElement(_fcfac.MinorTickMark, &_cdddf); _adgfg != nil {
					return _adgfg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tickLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tickLblPos"}:
				_fcfac.TickLblPos = NewCT_TickLblPos()
				if _fagb := d.DecodeElement(_fcfac.TickLblPos, &_cdddf); _fagb != nil {
					return _fagb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_fcfac.SpPr = _cb.NewCT_ShapeProperties()
				if _dgbda := d.DecodeElement(_fcfac.SpPr, &_cdddf); _dgbda != nil {
					return _dgbda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_fcfac.TxPr = _cb.NewCT_TextBody()
				if _cfaf := d.DecodeElement(_fcfac.TxPr, &_cdddf); _cfaf != nil {
					return _cfaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossAx"}:
				if _cbead := d.DecodeElement(_fcfac.CrossAx, &_cdddf); _cbead != nil {
					return _cbead
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crosses"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crosses"}:
				_fcfac.Choice = NewEG_AxSharedChoice()
				if _gdgda := d.DecodeElement(&_fcfac.Choice.Crosses, &_cdddf); _gdgda != nil {
					return _gdgda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossesAt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossesAt"}:
				_fcfac.Choice = NewEG_AxSharedChoice()
				if _dbffa := d.DecodeElement(&_fcfac.Choice.CrossesAt, &_cdddf); _dbffa != nil {
					return _dbffa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossBetween"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossBetween"}:
				_fcfac.CrossBetween = NewCT_CrossBetween()
				if _bdbc := d.DecodeElement(_fcfac.CrossBetween, &_cdddf); _bdbc != nil {
					return _bdbc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorUnit"}:
				_fcfac.MajorUnit = NewCT_AxisUnit()
				if _beef := d.DecodeElement(_fcfac.MajorUnit, &_cdddf); _beef != nil {
					return _beef
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorUnit"}:
				_fcfac.MinorUnit = NewCT_AxisUnit()
				if _dfaed := d.DecodeElement(_fcfac.MinorUnit, &_cdddf); _dfaed != nil {
					return _dfaed
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dispUnits"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dispUnits"}:
				_fcfac.DispUnits = NewCT_DispUnits()
				if _cgfaa := d.DecodeElement(_fcfac.DispUnits, &_cdddf); _cgfaa != nil {
					return _cgfaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_fcfac.ExtLst = NewCT_ExtensionList()
				if _fbgcd := d.DecodeElement(_fcfac.ExtLst, &_cdddf); _fbgcd != nil {
					return _fbgcd
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ValAx\u0020\u0025v", _cdddf.Name)
				if _ebegb := d.Skip(); _ebegb != nil {
					return _ebegb
				}
			}
		case _fa.EndElement:
			break _cddg
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_StrData and its children
func (_eaca *CT_StrData) Validate() error { return _eaca.ValidateWithPath("CT_StrData") }

// ValidateWithPath validates the CT_ExternalData and its children, prefixing error messages with path
func (_bdebd *CT_ExternalData) ValidateWithPath(path string) error {
	if _bdebd.AutoUpdate != nil {
		if _bagdfa := _bdebd.AutoUpdate.ValidateWithPath(path + "/AutoUpdate"); _bagdfa != nil {
			return _bagdfa
		}
	}
	return nil
}
func NewCT_Protection() *CT_Protection { _cggbgb := &CT_Protection{}; return _cggbgb }

type CT_DLblPos struct{ ValAttr ST_DLblPos }

func (_ddfcb ST_LegendPos) String() string {
	switch _ddfcb {
	case 0:
		return ""
	case 1:
		return "b"
	case 2:
		return "tr"
	case 3:
		return "l"
	case 4:
		return "r"
	case 5:
		return "t"
	}
	return ""
}
func (_fgcc *CT_BuiltInUnit) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _ebfc := range start.Attr {
		if _ebfc.Name.Local == "val" {
			_fgcc.ValAttr.UnmarshalXMLAttr(_ebfc)
			continue
		}
	}
	for {
		_fdcc, _efe := d.Token()
		if _efe != nil {
			return _gg.Errorf("parsing\u0020CT_BuiltInUnit:\u0020\u0025s", _efe)
		}
		if _dbf, _dfgg := _fdcc.(_fa.EndElement); _dfgg && _dbf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cbgg *ST_ScatterStyle) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_cbgg = 0
	case "none":
		*_cbgg = 1
	case "line":
		*_cbgg = 2
	case "lineMarker":
		*_cbgg = 3
	case "marker":
		*_cbgg = 4
	case "smooth":
		*_cbgg = 5
	case "smoothMarker":
		*_cbgg = 6
	}
	return nil
}
func (_fgbfd *ST_LayoutTarget) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_fgbfd = 0
	case "inner":
		*_fgbfd = 1
	case "outer":
		*_fgbfd = 2
	}
	return nil
}
func (_afefg *CT_SerAx) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_afefg.AxId = NewCT_UnsignedInt()
	_afefg.Scaling = NewCT_Scaling()
	_afefg.AxPos = NewCT_AxPos()
	_afefg.CrossAx = NewCT_UnsignedInt()
_gaaag:
	for {
		_cbff, _agfee := d.Token()
		if _agfee != nil {
			return _agfee
		}
		switch _gegb := _cbff.(type) {
		case _fa.StartElement:
			switch _gegb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				if _edabe := d.DecodeElement(_afefg.AxId, &_gegb); _edabe != nil {
					return _edabe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "scaling"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "scaling"}:
				if _cggdbc := d.DecodeElement(_afefg.Scaling, &_gegb); _cggdbc != nil {
					return _cggdbc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "delete"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "delete"}:
				_afefg.Delete = NewCT_Boolean()
				if _bggd := d.DecodeElement(_afefg.Delete, &_gegb); _bggd != nil {
					return _bggd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axPos"}:
				if _cebeg := d.DecodeElement(_afefg.AxPos, &_gegb); _cebeg != nil {
					return _cebeg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorGridlines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorGridlines"}:
				_afefg.MajorGridlines = NewCT_ChartLines()
				if _cdebb := d.DecodeElement(_afefg.MajorGridlines, &_gegb); _cdebb != nil {
					return _cdebb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorGridlines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorGridlines"}:
				_afefg.MinorGridlines = NewCT_ChartLines()
				if _gdgegb := d.DecodeElement(_afefg.MinorGridlines, &_gegb); _gdgegb != nil {
					return _gdgegb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "title"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "title"}:
				_afefg.Title = NewCT_Title()
				if _cadec := d.DecodeElement(_afefg.Title, &_gegb); _cadec != nil {
					return _cadec
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				_afefg.NumFmt = NewCT_NumFmt()
				if _bggg := d.DecodeElement(_afefg.NumFmt, &_gegb); _bggg != nil {
					return _bggg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorTickMark"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorTickMark"}:
				_afefg.MajorTickMark = NewCT_TickMark()
				if _bbccc := d.DecodeElement(_afefg.MajorTickMark, &_gegb); _bbccc != nil {
					return _bbccc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorTickMark"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorTickMark"}:
				_afefg.MinorTickMark = NewCT_TickMark()
				if _egefa := d.DecodeElement(_afefg.MinorTickMark, &_gegb); _egefa != nil {
					return _egefa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tickLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tickLblPos"}:
				_afefg.TickLblPos = NewCT_TickLblPos()
				if _cccg := d.DecodeElement(_afefg.TickLblPos, &_gegb); _cccg != nil {
					return _cccg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_afefg.SpPr = _cb.NewCT_ShapeProperties()
				if _egefe := d.DecodeElement(_afefg.SpPr, &_gegb); _egefe != nil {
					return _egefe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_afefg.TxPr = _cb.NewCT_TextBody()
				if _abcbd := d.DecodeElement(_afefg.TxPr, &_gegb); _abcbd != nil {
					return _abcbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossAx"}:
				if _acfe := d.DecodeElement(_afefg.CrossAx, &_gegb); _acfe != nil {
					return _acfe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crosses"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crosses"}:
				_afefg.Choice = NewEG_AxSharedChoice()
				if _gaga := d.DecodeElement(&_afefg.Choice.Crosses, &_gegb); _gaga != nil {
					return _gaga
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossesAt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossesAt"}:
				_afefg.Choice = NewEG_AxSharedChoice()
				if _eebbg := d.DecodeElement(&_afefg.Choice.CrossesAt, &_gegb); _eebbg != nil {
					return _eebbg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tickLblSkip"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tickLblSkip"}:
				_afefg.TickLblSkip = NewCT_Skip()
				if _cdaba := d.DecodeElement(_afefg.TickLblSkip, &_gegb); _cdaba != nil {
					return _cdaba
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tickMarkSkip"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tickMarkSkip"}:
				_afefg.TickMarkSkip = NewCT_Skip()
				if _fdaaa := d.DecodeElement(_afefg.TickMarkSkip, &_gegb); _fdaaa != nil {
					return _fdaaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_afefg.ExtLst = NewCT_ExtensionList()
				if _dagaf := d.DecodeElement(_afefg.ExtLst, &_gegb); _dagaf != nil {
					return _dagaf
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SerAx\u0020\u0025v", _gegb.Name)
				if _eeeag := d.Skip(); _eeeag != nil {
					return _eeeag
				}
			}
		case _fa.EndElement:
			break _gaaag
		case _fa.CharData:
		}
	}
	return nil
}

type CT_UnsignedInt struct{ ValAttr uint32 }

func ParseUnionST_GapAmount(s string) (ST_GapAmount, error) {
	if ST_GapAmountPercentPatternRe.MatchString(s) {
		return ST_GapAmount{ST_GapAmountPercent: &s}, nil
	}
	_fgeff, _dfdcd := _c.ParseUint(s, 10, 16)
	if _dfdcd != nil {
		return ST_GapAmount{}, _dfdcd
	}
	_gefea := uint16(_fgeff)
	return ST_GapAmount{ST_GapAmountUShort: &_gefea}, nil
}

type CT_LayoutTarget struct{ ValAttr ST_LayoutTarget }

func (_effc ST_BarDir) ValidateWithPath(path string) error {
	switch _effc {
	case 0, 1, 2:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_effc))
	}
	return nil
}

// Validate validates the CT_ExtensionList and its children
func (_bbbc *CT_ExtensionList) Validate() error { return _bbbc.ValidateWithPath("CT_ExtensionList") }
func (_fedda *CT_View3D) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _fedda.RotX != nil {
		_acbdda := _fa.StartElement{Name: _fa.Name{Local: "c:rotX"}}
		e.EncodeElement(_fedda.RotX, _acbdda)
	}
	if _fedda.HPercent != nil {
		_fbga := _fa.StartElement{Name: _fa.Name{Local: "c:hPercent"}}
		e.EncodeElement(_fedda.HPercent, _fbga)
	}
	if _fedda.RotY != nil {
		_bbge := _fa.StartElement{Name: _fa.Name{Local: "c:rotY"}}
		e.EncodeElement(_fedda.RotY, _bbge)
	}
	if _fedda.DepthPercent != nil {
		_bgegcc := _fa.StartElement{Name: _fa.Name{Local: "c:depthPercent"}}
		e.EncodeElement(_fedda.DepthPercent, _bgegcc)
	}
	if _fedda.RAngAx != nil {
		_cccdd := _fa.StartElement{Name: _fa.Name{Local: "c:rAngAx"}}
		e.EncodeElement(_fedda.RAngAx, _cccdd)
	}
	if _fedda.Perspective != nil {
		_ecgcd := _fa.StartElement{Name: _fa.Name{Local: "c:perspective"}}
		e.EncodeElement(_fedda.Perspective, _ecgcd)
	}
	if _fedda.ExtLst != nil {
		_gaaea := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_fedda.ExtLst, _gaaea)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_fcade *CT_ScatterSer) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_fddbbe := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_fcade.Idx, _fddbbe)
	_ggdb := _fa.StartElement{Name: _fa.Name{Local: "c:order"}}
	e.EncodeElement(_fcade.Order, _ggdb)
	if _fcade.Tx != nil {
		_fdce := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_fcade.Tx, _fdce)
	}
	if _fcade.SpPr != nil {
		_eebe := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_fcade.SpPr, _eebe)
	}
	if _fcade.Marker != nil {
		_edbfc := _fa.StartElement{Name: _fa.Name{Local: "c:marker"}}
		e.EncodeElement(_fcade.Marker, _edbfc)
	}
	if _fcade.DPt != nil {
		_dgfae := _fa.StartElement{Name: _fa.Name{Local: "c:dPt"}}
		for _, _dbbbg := range _fcade.DPt {
			e.EncodeElement(_dbbbg, _dgfae)
		}
	}
	if _fcade.DLbls != nil {
		_aadga := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_fcade.DLbls, _aadga)
	}
	if _fcade.Trendline != nil {
		_dgcad := _fa.StartElement{Name: _fa.Name{Local: "c:trendline"}}
		for _, _efgb := range _fcade.Trendline {
			e.EncodeElement(_efgb, _dgcad)
		}
	}
	if _fcade.ErrBars != nil {
		_fcgfc := _fa.StartElement{Name: _fa.Name{Local: "c:errBars"}}
		for _, _cccda := range _fcade.ErrBars {
			e.EncodeElement(_cccda, _fcgfc)
		}
	}
	if _fcade.XVal != nil {
		_abab := _fa.StartElement{Name: _fa.Name{Local: "c:xVal"}}
		e.EncodeElement(_fcade.XVal, _abab)
	}
	if _fcade.YVal != nil {
		_fcff := _fa.StartElement{Name: _fa.Name{Local: "c:yVal"}}
		e.EncodeElement(_fcade.YVal, _fcff)
	}
	if _fcade.Smooth != nil {
		_gege := _fa.StartElement{Name: _fa.Name{Local: "c:smooth"}}
		e.EncodeElement(_fcade.Smooth, _gege)
	}
	if _fcade.ExtLst != nil {
		_cbbe := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_fcade.ExtLst, _cbbe)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_baab *CT_Layout) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_fbcf:
	for {
		_gebgb, _ecdg := d.Token()
		if _ecdg != nil {
			return _ecdg
		}
		switch _gedc := _gebgb.(type) {
		case _fa.StartElement:
			switch _gedc.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "manualLayout"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "manualLayout"}:
				_baab.ManualLayout = NewCT_ManualLayout()
				if _efffc := d.DecodeElement(_baab.ManualLayout, &_gedc); _efffc != nil {
					return _efffc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_baab.ExtLst = NewCT_ExtensionList()
				if _faca := d.DecodeElement(_baab.ExtLst, &_gedc); _faca != nil {
					return _faca
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_Layout \u0025v", _gedc.Name)
				if _cfeg := d.Skip(); _cfeg != nil {
					return _cfeg
				}
			}
		case _fa.EndElement:
			break _fbcf
		case _fa.CharData:
		}
	}
	return nil
}

type CT_Surface struct {
	Thickness      *CT_Thickness
	SpPr           *_cb.CT_ShapeProperties
	PictureOptions *CT_PictureOptions
	ExtLst         *CT_ExtensionList
}

func (_cgagc *CT_RelId) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "r:id"}, Value: _gg.Sprintf("\u0025v", _cgagc.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_DoughnutChart() *CT_DoughnutChart { _bdgg := &CT_DoughnutChart{}; return _bdgg }

// ValidateWithPath validates the CT_StockChart and its children, prefixing error messages with path
func (_fcgge *CT_StockChart) ValidateWithPath(path string) error {
	for _gcfbd, _fedg := range _fcgge.Ser {
		if _egfafb := _fedg.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _gcfbd)); _egfafb != nil {
			return _egfafb
		}
	}
	if _fcgge.DLbls != nil {
		if _bacdd := _fcgge.DLbls.ValidateWithPath(path + "\u002fDLbls"); _bacdd != nil {
			return _bacdd
		}
	}
	if _fcgge.DropLines != nil {
		if _fcec := _fcgge.DropLines.ValidateWithPath(path + "\u002fDropLines"); _fcec != nil {
			return _fcec
		}
	}
	if _fcgge.HiLowLines != nil {
		if _egcbb := _fcgge.HiLowLines.ValidateWithPath(path + "/HiLowLines"); _egcbb != nil {
			return _egcbb
		}
	}
	if _fcgge.UpDownBars != nil {
		if _bebef := _fcgge.UpDownBars.ValidateWithPath(path + "/UpDownBars"); _bebef != nil {
			return _bebef
		}
	}
	for _fgdd, _eded := range _fcgge.AxId {
		if _adceb := _eded.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _fgdd)); _adceb != nil {
			return _adceb
		}
	}
	if _fcgge.ExtLst != nil {
		if _fgbfa := _fcgge.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fgbfa != nil {
			return _fgbfa
		}
	}
	return nil
}

// Validate validates the CT_Marker and its children
func (_bdcf *CT_Marker) Validate() error { return _bdcf.ValidateWithPath("CT_Marker") }
func NewCT_BarDir() *CT_BarDir           { _aegc := &CT_BarDir{}; return _aegc }

// ST_BubbleScale is a union type
type ST_BubbleScale struct {
	ST_BubbleScalePercent *string
	ST_BubbleScaleUInt    *uint32
}

func (_edbfbg *ST_PageSetupOrientation) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_edbfbg = 0
	case "default":
		*_edbfbg = 1
	case "portrait":
		*_edbfbg = 2
	case "landscape":
		*_edbfbg = 3
	}
	return nil
}
func (_gbfa ST_ScatterStyle) String() string {
	switch _gbfa {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "line"
	case 3:
		return "lineMarker"
	case 4:
		return "marker"
	case 5:
		return "smooth"
	case 6:
		return "smoothMarker"
	}
	return ""
}

type CT_SerTxChoice struct {
	StrRef *CT_StrRef
	V      *string
}

func (_aaeac *CT_PictureFormat) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_aaeac.ValAttr = ST_PictureFormat(1)
	for _, _gabg := range start.Attr {
		if _gabg.Name.Local == "val" {
			_aaeac.ValAttr.UnmarshalXMLAttr(_gabg)
			continue
		}
	}
	for {
		_fdcgf, _ccdf := d.Token()
		if _ccdf != nil {
			return _gg.Errorf("parsing\u0020CT_PictureFormat: \u0025s", _ccdf)
		}
		if _bccbc, _dddbf := _fdcgf.(_fa.EndElement); _dddbf && _bccbc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_eccgg *CT_PictureOptions) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_bgcab:
	for {
		_addcc, _dfefd := d.Token()
		if _dfefd != nil {
			return _dfefd
		}
		switch _gagee := _addcc.(type) {
		case _fa.StartElement:
			switch _gagee.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "applyToFront"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "applyToFront"}:
				_eccgg.ApplyToFront = NewCT_Boolean()
				if _bccga := d.DecodeElement(_eccgg.ApplyToFront, &_gagee); _bccga != nil {
					return _bccga
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "applyToSides"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "applyToSides"}:
				_eccgg.ApplyToSides = NewCT_Boolean()
				if _bfegg := d.DecodeElement(_eccgg.ApplyToSides, &_gagee); _bfegg != nil {
					return _bfegg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "applyToEnd"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "applyToEnd"}:
				_eccgg.ApplyToEnd = NewCT_Boolean()
				if _fgedd := d.DecodeElement(_eccgg.ApplyToEnd, &_gagee); _fgedd != nil {
					return _fgedd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pictureFormat"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pictureFormat"}:
				_eccgg.PictureFormat = NewCT_PictureFormat()
				if _ddcf := d.DecodeElement(_eccgg.PictureFormat, &_gagee); _ddcf != nil {
					return _ddcf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pictureStackUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pictureStackUnit"}:
				_eccgg.PictureStackUnit = NewCT_PictureStackUnit()
				if _ddbf := d.DecodeElement(_eccgg.PictureStackUnit, &_gagee); _ddbf != nil {
					return _ddbf
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_PictureOptions\u0020\u0025v", _gagee.Name)
				if _bcggc := d.Skip(); _bcggc != nil {
					return _bcggc
				}
			}
		case _fa.EndElement:
			break _bgcab
		case _fa.CharData:
		}
	}
	return nil
}
func (_gddac ST_MarkerStyle) String() string {
	switch _gddac {
	case 0:
		return ""
	case 1:
		return "circle"
	case 2:
		return "dash"
	case 3:
		return "diamond"
	case 4:
		return "dot"
	case 5:
		return "none"
	case 6:
		return "picture"
	case 7:
		return "plus"
	case 8:
		return "square"
	case 9:
		return "star"
	case 10:
		return "triangle"
	case 11:
		return "x"
	case 12:
		return "auto"
	}
	return ""
}
func (_ecce *ST_LegendPos) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_ecce = 0
	case "b":
		*_ecce = 1
	case "tr":
		*_ecce = 2
	case "l":
		*_ecce = 3
	case "r":
		*_ecce = 4
	case "t":
		*_ecce = 5
	}
	return nil
}
func (_aegcg *CT_TxChoice) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_egedb:
	for {
		_caege, _fgdeac := d.Token()
		if _fgdeac != nil {
			return _fgdeac
		}
		switch _cbddf := _caege.(type) {
		case _fa.StartElement:
			switch _cbddf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "strRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "strRef"}:
				_aegcg.StrRef = NewCT_StrRef()
				if _cggeee := d.DecodeElement(_aegcg.StrRef, &_cbddf); _cggeee != nil {
					return _cggeee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "rich"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "rich"}:
				_aegcg.Rich = _cb.NewCT_TextBody()
				if _cdede := d.DecodeElement(_aegcg.Rich, &_cbddf); _cdede != nil {
					return _cdede
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TxChoice\u0020\u0025v", _cbddf.Name)
				if _cgdgd := d.Skip(); _cgdgd != nil {
					return _cgdgd
				}
			}
		case _fa.EndElement:
			break _egedb
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_DoughnutChart and its children, prefixing error messages with path
func (_agab *CT_DoughnutChart) ValidateWithPath(path string) error {
	if _agab.VaryColors != nil {
		if _ddcc := _agab.VaryColors.ValidateWithPath(path + "/VaryColors"); _ddcc != nil {
			return _ddcc
		}
	}
	for _eaae, _dfff := range _agab.Ser {
		if _feae := _dfff.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _eaae)); _feae != nil {
			return _feae
		}
	}
	if _agab.DLbls != nil {
		if _cfb := _agab.DLbls.ValidateWithPath(path + "\u002fDLbls"); _cfb != nil {
			return _cfb
		}
	}
	if _agab.FirstSliceAng != nil {
		if _dgcg := _agab.FirstSliceAng.ValidateWithPath(path + "\u002fFirstSliceAng"); _dgcg != nil {
			return _dgcg
		}
	}
	if _agab.HoleSize != nil {
		if _ddgcd := _agab.HoleSize.ValidateWithPath(path + "\u002fHoleSize"); _ddgcd != nil {
			return _ddgcd
		}
	}
	if _agab.ExtLst != nil {
		if _fbddf := _agab.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fbddf != nil {
			return _fbddf
		}
	}
	return nil
}

const (
	ST_GroupingUnset          ST_Grouping = 0
	ST_GroupingPercentStacked ST_Grouping = 1
	ST_GroupingStandard       ST_Grouping = 2
	ST_GroupingStacked        ST_Grouping = 3
)

// Validate validates the CT_ScatterStyle and its children
func (_acafd *CT_ScatterStyle) Validate() error { return _acafd.ValidateWithPath("CT_ScatterStyle") }

type CT_NumVal struct {
	IdxAttr        uint32
	FormatCodeAttr *string
	V              string
}

func NewCT_ScatterStyle() *CT_ScatterStyle   { _agedf := &CT_ScatterStyle{}; return _agedf }
func (_gfaed *ST_LblOffset) Validate() error { return _gfaed.ValidateWithPath("") }
func (_edac ST_CrossBetween) ValidateWithPath(path string) error {
	switch _edac {
	case 0, 1, 2:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_edac))
	}
	return nil
}
func NewCT_NumDataSource() *CT_NumDataSource {
	_dfeg := &CT_NumDataSource{}
	_dfeg.Choice = NewCT_NumDataSourceChoice()
	return _dfeg
}
func (_gagb *CT_DLbl) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_gbaee := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_gagb.Idx, _gbaee)
	if _gagb.Choice != nil {
		_gagb.Choice.MarshalXML(e, _fa.StartElement{})
	}
	if _gagb.ExtLst != nil {
		_ggfb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_gagb.ExtLst, _ggfb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_RadarStyle struct{ ValAttr ST_RadarStyle }

const (
	ST_OrientationUnset  ST_Orientation = 0
	ST_OrientationMaxMin ST_Orientation = 1
	ST_OrientationMinMax ST_Orientation = 2
)

func (_gcde *CT_LayoutTarget) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _gcde.ValAttr != ST_LayoutTargetUnset {
		_bedc, _edge := _gcde.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _edge != nil {
			return _edge
		}
		start.Attr = append(start.Attr, _bedc)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_PageSetup and its children
func (_bcfc *CT_PageSetup) Validate() error { return _bcfc.ValidateWithPath("CT_PageSetup") }
func (_cacae *CT_Protection) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _cacae.ChartObject != nil {
		_abgcc := _fa.StartElement{Name: _fa.Name{Local: "c:chartObject"}}
		e.EncodeElement(_cacae.ChartObject, _abgcc)
	}
	if _cacae.Data != nil {
		_caaae := _fa.StartElement{Name: _fa.Name{Local: "c:data"}}
		e.EncodeElement(_cacae.Data, _caaae)
	}
	if _cacae.Formatting != nil {
		_gcge := _fa.StartElement{Name: _fa.Name{Local: "c:formatting"}}
		e.EncodeElement(_cacae.Formatting, _gcge)
	}
	if _cacae.Selection != nil {
		_cefdc := _fa.StartElement{Name: _fa.Name{Local: "c:selection"}}
		e.EncodeElement(_cacae.Selection, _cefdc)
	}
	if _cacae.UserInterface != nil {
		_ddage := _fa.StartElement{Name: _fa.Name{Local: "c:userInterface"}}
		e.EncodeElement(_cacae.UserInterface, _ddage)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_UpDownBar struct{ SpPr *_cb.CT_ShapeProperties }

func (_dedc *CT_Crosses) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_dedc.ValAttr = ST_Crosses(1)
	for _, _eeeg := range start.Attr {
		if _eeeg.Name.Local == "val" {
			_dedc.ValAttr.UnmarshalXMLAttr(_eeeg)
			continue
		}
	}
	for {
		_ccgd, _bddg := d.Token()
		if _bddg != nil {
			return _gg.Errorf("parsing\u0020CT_Crosses:\u0020%s", _bddg)
		}
		if _gggb, _dgbe := _ccgd.(_fa.EndElement); _dgbe && _gggb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_afeg *CT_BubbleChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _afeg.VaryColors != nil {
		_bgfe := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_afeg.VaryColors, _bgfe)
	}
	if _afeg.Ser != nil {
		_bfac := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _fce := range _afeg.Ser {
			e.EncodeElement(_fce, _bfac)
		}
	}
	if _afeg.DLbls != nil {
		_bfaf := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_afeg.DLbls, _bfaf)
	}
	if _afeg.Bubble3D != nil {
		_dgbd := _fa.StartElement{Name: _fa.Name{Local: "c:bubble3D"}}
		e.EncodeElement(_afeg.Bubble3D, _dgbd)
	}
	if _afeg.BubbleScale != nil {
		_bdde := _fa.StartElement{Name: _fa.Name{Local: "c:bubbleScale"}}
		e.EncodeElement(_afeg.BubbleScale, _bdde)
	}
	if _afeg.ShowNegBubbles != nil {
		_ddgb := _fa.StartElement{Name: _fa.Name{Local: "c:showNegBubbles"}}
		e.EncodeElement(_afeg.ShowNegBubbles, _ddgb)
	}
	if _afeg.SizeRepresents != nil {
		_aegg := _fa.StartElement{Name: _fa.Name{Local: "c:sizeRepresents"}}
		e.EncodeElement(_afeg.SizeRepresents, _aegg)
	}
	_fabb := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _acc := range _afeg.AxId {
		e.EncodeElement(_acc, _fabb)
	}
	if _afeg.ExtLst != nil {
		_afc := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_afeg.ExtLst, _afc)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_gafcf ST_Orientation) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_deeed := _fa.Attr{}
	_deeed.Name = name
	switch _gafcf {
	case ST_OrientationUnset:
		_deeed.Value = ""
	case ST_OrientationMaxMin:
		_deeed.Value = "maxMin"
	case ST_OrientationMinMax:
		_deeed.Value = "minMax"
	}
	return _deeed, nil
}

type CT_BarSer struct {
	Idx              *CT_UnsignedInt
	Order            *CT_UnsignedInt
	Tx               *CT_SerTx
	SpPr             *_cb.CT_ShapeProperties
	InvertIfNegative *CT_Boolean
	PictureOptions   *CT_PictureOptions
	DPt              []*CT_DPt
	DLbls            *CT_DLbls
	Trendline        []*CT_Trendline
	ErrBars          *CT_ErrBars
	Cat              *CT_AxDataSource
	Val              *CT_NumDataSource
	Shape            *CT_Shape
	ExtLst           *CT_ExtensionList
}

// Validate validates the CT_BarChart and its children
func (_geg *CT_BarChart) Validate() error { return _geg.ValidateWithPath("CT_BarChart") }

// Validate validates the CT_BarGrouping and its children
func (_cea *CT_BarGrouping) Validate() error { return _cea.ValidateWithPath("CT_BarGrouping") }
func (_gfgbg *ST_MarkerStyle) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_gfgbg = 0
	case "circle":
		*_gfgbg = 1
	case "dash":
		*_gfgbg = 2
	case "diamond":
		*_gfgbg = 3
	case "dot":
		*_gfgbg = 4
	case "none":
		*_gfgbg = 5
	case "picture":
		*_gfgbg = 6
	case "plus":
		*_gfgbg = 7
	case "square":
		*_gfgbg = 8
	case "star":
		*_gfgbg = 9
	case "triangle":
		*_gfgbg = 10
	case "x":
		*_gfgbg = 11
	case "auto":
		*_gfgbg = 12
	}
	return nil
}
func (_bdaaf *CT_Style) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", _bdaaf.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_fgabe ST_BarDir) Validate() error { return _fgabe.ValidateWithPath("") }
func (_afaec *CT_Shape) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _cgab := range start.Attr {
		if _cgab.Name.Local == "val" {
			_afaec.ValAttr.UnmarshalXMLAttr(_cgab)
			continue
		}
	}
	for {
		_ceaa, _bdaae := d.Token()
		if _bdaae != nil {
			return _gg.Errorf("parsing\u0020CT_Shape: \u0025s", _bdaae)
		}
		if _fdfb, _eebf := _ceaa.(_fa.EndElement); _eebf && _fdfb.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_DLbl struct {
	Idx    *CT_UnsignedInt
	Choice *CT_DLblChoice
	ExtLst *CT_ExtensionList
}

// Validate validates the CT_MultiLvlStrRef and its children
func (_ddeae *CT_MultiLvlStrRef) Validate() error {
	return _ddeae.ValidateWithPath("CT_MultiLvlStrRef")
}
func NewCT_Pie3DChart() *CT_Pie3DChart { _cbgb := &CT_Pie3DChart{}; return _cbgb }

const (
	ST_TrendlineTypeUnset     ST_TrendlineType = 0
	ST_TrendlineTypeExp       ST_TrendlineType = 1
	ST_TrendlineTypeLinear    ST_TrendlineType = 2
	ST_TrendlineTypeLog       ST_TrendlineType = 3
	ST_TrendlineTypeMovingAvg ST_TrendlineType = 4
	ST_TrendlineTypePoly      ST_TrendlineType = 5
	ST_TrendlineTypePower     ST_TrendlineType = 6
)

// ValidateWithPath validates the CT_MultiLvlStrRef and its children, prefixing error messages with path
func (_eadba *CT_MultiLvlStrRef) ValidateWithPath(path string) error {
	if _eadba.MultiLvlStrCache != nil {
		if _fegce := _eadba.MultiLvlStrCache.ValidateWithPath(path + "\u002fMultiLvlStrCache"); _fegce != nil {
			return _fegce
		}
	}
	if _eadba.ExtLst != nil {
		if _bcec := _eadba.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bcec != nil {
			return _bcec
		}
	}
	return nil
}

// Validate validates the CT_DPt and its children
func (_abfb *CT_DPt) Validate() error { return _abfb.ValidateWithPath("CT_DPt") }
func (_acfg *CT_LayoutMode) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _efbb := range start.Attr {
		if _efbb.Name.Local == "val" {
			_acfg.ValAttr.UnmarshalXMLAttr(_efbb)
			continue
		}
	}
	for {
		_fabda, _ebd := d.Token()
		if _ebd != nil {
			return _gg.Errorf("parsing\u0020CT_LayoutMode:\u0020\u0025s", _ebd)
		}
		if _dgeg, _bcba := _fabda.(_fa.EndElement); _bcba && _dgeg.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Scaling struct {
	LogBase     *CT_LogBase
	Orientation *CT_Orientation
	Max         *CT_Double
	Min         *CT_Double
	ExtLst      *CT_ExtensionList
}

// Validate validates the CT_Extension and its children
func (_afeb *CT_Extension) Validate() error { return _afeb.ValidateWithPath("CT_Extension") }
func (_daga *CT_DLblPos) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_cggfg, _ddace := _daga.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
	if _ddace != nil {
		return _ddace
	}
	start.Attr = append(start.Attr, _cggfg)
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Group_DLbls and its children, prefixing error messages with path
func (_ffgcd *Group_DLbls) ValidateWithPath(path string) error {
	if _ffgcd.NumFmt != nil {
		if _dacga := _ffgcd.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _dacga != nil {
			return _dacga
		}
	}
	if _ffgcd.SpPr != nil {
		if _eaegb := _ffgcd.SpPr.ValidateWithPath(path + "\u002fSpPr"); _eaegb != nil {
			return _eaegb
		}
	}
	if _ffgcd.TxPr != nil {
		if _gaecg := _ffgcd.TxPr.ValidateWithPath(path + "\u002fTxPr"); _gaecg != nil {
			return _gaecg
		}
	}
	if _ffgcd.DLblPos != nil {
		if _cdcec := _ffgcd.DLblPos.ValidateWithPath(path + "\u002fDLblPos"); _cdcec != nil {
			return _cdcec
		}
	}
	if _ffgcd.ShowLegendKey != nil {
		if _gcggd := _ffgcd.ShowLegendKey.ValidateWithPath(path + "\u002fShowLegendKey"); _gcggd != nil {
			return _gcggd
		}
	}
	if _ffgcd.ShowVal != nil {
		if _bcagd := _ffgcd.ShowVal.ValidateWithPath(path + "\u002fShowVal"); _bcagd != nil {
			return _bcagd
		}
	}
	if _ffgcd.ShowCatName != nil {
		if _dfbdbd := _ffgcd.ShowCatName.ValidateWithPath(path + "\u002fShowCatName"); _dfbdbd != nil {
			return _dfbdbd
		}
	}
	if _ffgcd.ShowSerName != nil {
		if _ggaga := _ffgcd.ShowSerName.ValidateWithPath(path + "\u002fShowSerName"); _ggaga != nil {
			return _ggaga
		}
	}
	if _ffgcd.ShowPercent != nil {
		if _abag := _ffgcd.ShowPercent.ValidateWithPath(path + "\u002fShowPercent"); _abag != nil {
			return _abag
		}
	}
	if _ffgcd.ShowBubbleSize != nil {
		if _gbbgc := _ffgcd.ShowBubbleSize.ValidateWithPath(path + "\u002fShowBubbleSize"); _gbbgc != nil {
			return _gbbgc
		}
	}
	if _ffgcd.ShowLeaderLines != nil {
		if _ceceb := _ffgcd.ShowLeaderLines.ValidateWithPath(path + "\u002fShowLeaderLines"); _ceceb != nil {
			return _ceceb
		}
	}
	if _ffgcd.LeaderLines != nil {
		if _eceb := _ffgcd.LeaderLines.ValidateWithPath(path + "\u002fLeaderLines"); _eceb != nil {
			return _eceb
		}
	}
	return nil
}

type CT_NumRef struct {
	F        string
	NumCache *CT_NumData
	ExtLst   *CT_ExtensionList
}

func NewCT_TextLanguageID() *CT_TextLanguageID { _gefdf := &CT_TextLanguageID{}; return _gefdf }
func (_gbdef ST_TickLblPos) Validate() error   { return _gbdef.ValidateWithPath("") }

// ValidateWithPath validates the CT_DispBlanksAs and its children, prefixing error messages with path
func (_fgfa *CT_DispBlanksAs) ValidateWithPath(path string) error {
	if _deeg := _fgfa.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _deeg != nil {
		return _deeg
	}
	return nil
}
func (_bdefg *CT_StrVal) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "idx"}, Value: _gg.Sprintf("\u0025v", _bdefg.IdxAttr)})
	e.EncodeToken(start)
	_deaed := _fa.StartElement{Name: _fa.Name{Local: "c:v"}}
	_b.AddPreserveSpaceAttr(&_deaed, _bdefg.V)
	e.EncodeElement(_bdefg.V, _deaed)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_daee *CT_BubbleScale) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _cgcb := range start.Attr {
		if _cgcb.Name.Local == "val" {
			_eff, _baac := ParseUnionST_BubbleScale(_cgcb.Value)
			if _baac != nil {
				return _baac
			}
			_daee.ValAttr = &_eff
			continue
		}
	}
	for {
		_aecd, _fbfe := d.Token()
		if _fbfe != nil {
			return _gg.Errorf("parsing\u0020CT_BubbleScale:\u0020\u0025s", _fbfe)
		}
		if _eaea, _fcfae := _aecd.(_fa.EndElement); _fcfae && _eaea.Name == start.Name {
			break
		}
	}
	return nil
}
func (_afeade *EG_LineChartShared) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_fffcd := _fa.StartElement{Name: _fa.Name{Local: "c:grouping"}}
	e.EncodeElement(_afeade.Grouping, _fffcd)
	if _afeade.VaryColors != nil {
		_eedab := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_afeade.VaryColors, _eedab)
	}
	if _afeade.Ser != nil {
		_eeae := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _gfddc := range _afeade.Ser {
			e.EncodeElement(_gfddc, _eeae)
		}
	}
	if _afeade.DLbls != nil {
		_ggdda := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_afeade.DLbls, _ggdda)
	}
	if _afeade.DropLines != nil {
		_edeaf := _fa.StartElement{Name: _fa.Name{Local: "c:dropLines"}}
		e.EncodeElement(_afeade.DropLines, _edeaf)
	}
	return nil
}
func (_dgefb ST_Orientation) String() string {
	switch _dgefb {
	case 0:
		return ""
	case 1:
		return "maxMin"
	case 2:
		return "minMax"
	}
	return ""
}
func (_ff *CT_AreaChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _ff.Grouping != nil {
		_gdb := _fa.StartElement{Name: _fa.Name{Local: "c:grouping"}}
		e.EncodeElement(_ff.Grouping, _gdb)
	}
	if _ff.VaryColors != nil {
		_bbg := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_ff.VaryColors, _bbg)
	}
	if _ff.Ser != nil {
		_bd := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _afd := range _ff.Ser {
			e.EncodeElement(_afd, _bd)
		}
	}
	if _ff.DLbls != nil {
		_gge := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_ff.DLbls, _gge)
	}
	if _ff.DropLines != nil {
		_ce := _fa.StartElement{Name: _fa.Name{Local: "c:dropLines"}}
		e.EncodeElement(_ff.DropLines, _ce)
	}
	_ad := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _eag := range _ff.AxId {
		e.EncodeElement(_eag, _ad)
	}
	if _ff.ExtLst != nil {
		_feb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_ff.ExtLst, _feb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_aebdg ST_LblOffset) String() string {
	if _aebdg.ST_LblOffsetPercent != nil {
		return _gg.Sprintf("\u0025v", *_aebdg.ST_LblOffsetPercent)
	}
	if _aebdg.ST_LblOffsetUShort != nil {
		return _gg.Sprintf("\u0025v", *_aebdg.ST_LblOffsetUShort)
	}
	return ""
}
func (_dfaa *CT_ErrBarType) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _dfaa.ValAttr != ST_ErrBarTypeUnset {
		_dbac, _dfab := _dfaa.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _dfab != nil {
			return _dfab
		}
		start.Attr = append(start.Attr, _dbac)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_MultiLvlStrData() *CT_MultiLvlStrData { _daeg := &CT_MultiLvlStrData{}; return _daeg }

// ValidateWithPath validates the CT_TickLblPos and its children, prefixing error messages with path
func (_cfff *CT_TickLblPos) ValidateWithPath(path string) error {
	if _eebdg := _cfff.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _eebdg != nil {
		return _eebdg
	}
	return nil
}
func (_cffad *CT_UnsignedInt) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _gadb := range start.Attr {
		if _gadb.Name.Local == "val" {
			_bdagb, _afbga := _c.ParseUint(_gadb.Value, 10, 32)
			if _afbga != nil {
				return _afbga
			}
			_cffad.ValAttr = uint32(_bdagb)
			continue
		}
	}
	for {
		_bfadg, _eedb := d.Token()
		if _eedb != nil {
			return _gg.Errorf("parsing\u0020CT_UnsignedInt:\u0020\u0025s", _eedb)
		}
		if _eebbc, _ggeaa := _bfadg.(_fa.EndElement); _ggeaa && _eebbc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dacgc *CT_NumDataSourceChoice) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _dacgc.NumRef != nil {
		_gdgbg := _fa.StartElement{Name: _fa.Name{Local: "c:numRef"}}
		e.EncodeElement(_dacgc.NumRef, _gdgbg)
	}
	if _dacgc.NumLit != nil {
		_bcadg := _fa.StartElement{Name: _fa.Name{Local: "c:numLit"}}
		e.EncodeElement(_dacgc.NumLit, _bcadg)
	}
	return nil
}

type CT_Layout struct {
	ManualLayout *CT_ManualLayout
	ExtLst       *CT_ExtensionList
}

// ValidateWithPath validates the CT_Marker and its children, prefixing error messages with path
func (_beeac *CT_Marker) ValidateWithPath(path string) error {
	if _beeac.Symbol != nil {
		if _beeed := _beeac.Symbol.ValidateWithPath(path + "\u002fSymbol"); _beeed != nil {
			return _beeed
		}
	}
	if _beeac.Size != nil {
		if _dgfgg := _beeac.Size.ValidateWithPath(path + "\u002fSize"); _dgfgg != nil {
			return _dgfgg
		}
	}
	if _beeac.SpPr != nil {
		if _bgcac := _beeac.SpPr.ValidateWithPath(path + "\u002fSpPr"); _bgcac != nil {
			return _bgcac
		}
	}
	if _beeac.ExtLst != nil {
		if _fffg := _beeac.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fffg != nil {
			return _fffg
		}
	}
	return nil
}
func (_bcfgd *CT_SurfaceChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_bdbdd:
	for {
		_egage, _fedff := d.Token()
		if _fedff != nil {
			return _fedff
		}
		switch _faeg := _egage.(type) {
		case _fa.StartElement:
			switch _faeg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "wireframe"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "wireframe"}:
				_bcfgd.Wireframe = NewCT_Boolean()
				if _cacbe := d.DecodeElement(_bcfgd.Wireframe, &_faeg); _cacbe != nil {
					return _cacbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_ddgaa := NewCT_SurfaceSer()
				if _gbeff := d.DecodeElement(_ddgaa, &_faeg); _gbeff != nil {
					return _gbeff
				}
				_bcfgd.Ser = append(_bcfgd.Ser, _ddgaa)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bandFmts"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bandFmts"}:
				_bcfgd.BandFmts = NewCT_BandFmts()
				if _bbdeb := d.DecodeElement(_bcfgd.BandFmts, &_faeg); _bbdeb != nil {
					return _bbdeb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_dfec := NewCT_UnsignedInt()
				if _ggdgg := d.DecodeElement(_dfec, &_faeg); _ggdgg != nil {
					return _ggdgg
				}
				_bcfgd.AxId = append(_bcfgd.AxId, _dfec)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_bcfgd.ExtLst = NewCT_ExtensionList()
				if _ddaf := d.DecodeElement(_bcfgd.ExtLst, &_faeg); _ddaf != nil {
					return _ddaf
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SurfaceChart\u0020\u0025v", _faeg.Name)
				if _bdgd := d.Skip(); _bdgd != nil {
					return _bdgd
				}
			}
		case _fa.EndElement:
			break _bdbdd
		case _fa.CharData:
		}
	}
	return nil
}
func NewCT_LayoutTarget() *CT_LayoutTarget { _adfde := &CT_LayoutTarget{}; return _adfde }

type CT_DateAx struct {
	AxId           *CT_UnsignedInt
	Scaling        *CT_Scaling
	Delete         *CT_Boolean
	AxPos          *CT_AxPos
	MajorGridlines *CT_ChartLines
	MinorGridlines *CT_ChartLines
	Title          *CT_Title
	NumFmt         *CT_NumFmt
	MajorTickMark  *CT_TickMark
	MinorTickMark  *CT_TickMark
	TickLblPos     *CT_TickLblPos
	SpPr           *_cb.CT_ShapeProperties
	TxPr           *_cb.CT_TextBody
	CrossAx        *CT_UnsignedInt
	Choice         *EG_AxSharedChoice
	Auto           *CT_Boolean
	LblOffset      *CT_LblOffset
	BaseTimeUnit   *CT_TimeUnit
	MajorUnit      *CT_AxisUnit
	MajorTimeUnit  *CT_TimeUnit
	MinorUnit      *CT_AxisUnit
	MinorTimeUnit  *CT_TimeUnit
	ExtLst         *CT_ExtensionList
}

const ST_ThicknessPercentPattern = "\u0028[0\u002d9\u005d\u002b\u0029%"

func (_gagfg *UserShapes) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:c"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "c:userShapes"
	return _gagfg.CT_Drawing.MarshalXML(e, start)
}
func (_afcga ST_ErrBarType) ValidateWithPath(path string) error {
	switch _afcga {
	case 0, 1, 2, 3:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_afcga))
	}
	return nil
}

// Validate validates the CT_Legend and its children
func (_fagg *CT_Legend) Validate() error { return _fagg.ValidateWithPath("CT_Legend") }

type CT_BarDir struct{ ValAttr ST_BarDir }

func NewCT_ErrDir() *CT_ErrDir { _fcfc := &CT_ErrDir{}; _fcfc.ValAttr = ST_ErrDir(1); return _fcfc }

// ValidateWithPath validates the EG_SerShared and its children, prefixing error messages with path
func (_fabaa *EG_SerShared) ValidateWithPath(path string) error {
	if _bfdcf := _fabaa.Idx.ValidateWithPath(path + "\u002fIdx"); _bfdcf != nil {
		return _bfdcf
	}
	if _dacbd := _fabaa.Order.ValidateWithPath(path + "\u002fOrder"); _dacbd != nil {
		return _dacbd
	}
	if _fabaa.Tx != nil {
		if _fbagf := _fabaa.Tx.ValidateWithPath(path + "\u002fTx"); _fbagf != nil {
			return _fbagf
		}
	}
	if _fabaa.SpPr != nil {
		if _acab := _fabaa.SpPr.ValidateWithPath(path + "\u002fSpPr"); _acab != nil {
			return _acab
		}
	}
	return nil
}
func (_ecf *CT_BuiltInUnit) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _ecf.ValAttr != ST_BuiltInUnitUnset {
		_agfed, _bcag := _ecf.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _bcag != nil {
			return _bcag
		}
		start.Attr = append(start.Attr, _agfed)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_dbgc *CT_BarChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_dbgc.BarDir = NewCT_BarDir()
_afdb:
	for {
		_gcf, _gab := d.Token()
		if _gab != nil {
			return _gab
		}
		switch _ecag := _gcf.(type) {
		case _fa.StartElement:
			switch _ecag.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "barDir"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "barDir"}:
				if _gaf := d.DecodeElement(_dbgc.BarDir, &_ecag); _gaf != nil {
					return _gaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "grouping"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "grouping"}:
				_dbgc.Grouping = NewCT_BarGrouping()
				if _fggg := d.DecodeElement(_dbgc.Grouping, &_ecag); _fggg != nil {
					return _fggg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_dbgc.VaryColors = NewCT_Boolean()
				if _cegff := d.DecodeElement(_dbgc.VaryColors, &_ecag); _cegff != nil {
					return _cegff
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_ffe := NewCT_BarSer()
				if _bece := d.DecodeElement(_ffe, &_ecag); _bece != nil {
					return _bece
				}
				_dbgc.Ser = append(_dbgc.Ser, _ffe)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_dbgc.DLbls = NewCT_DLbls()
				if _acg := d.DecodeElement(_dbgc.DLbls, &_ecag); _acg != nil {
					return _acg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "gapWidth"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "gapWidth"}:
				_dbgc.GapWidth = NewCT_GapAmount()
				if _ccbe := d.DecodeElement(_dbgc.GapWidth, &_ecag); _ccbe != nil {
					return _ccbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "overlap"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "overlap"}:
				_dbgc.Overlap = NewCT_Overlap()
				if _fdc := d.DecodeElement(_dbgc.Overlap, &_ecag); _fdc != nil {
					return _fdc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "serLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "serLines"}:
				_eggd := NewCT_ChartLines()
				if _cgb := d.DecodeElement(_eggd, &_ecag); _cgb != nil {
					return _cgb
				}
				_dbgc.SerLines = append(_dbgc.SerLines, _eggd)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_fcada := NewCT_UnsignedInt()
				if _cabe := d.DecodeElement(_fcada, &_ecag); _cabe != nil {
					return _cabe
				}
				_dbgc.AxId = append(_dbgc.AxId, _fcada)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_dbgc.ExtLst = NewCT_ExtensionList()
				if _cdag := d.DecodeElement(_dbgc.ExtLst, &_ecag); _cdag != nil {
					return _cdag
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BarChart\u0020\u0025v", _ecag.Name)
				if _afdc := d.Skip(); _afdc != nil {
					return _afdc
				}
			}
		case _fa.EndElement:
			break _afdb
		case _fa.CharData:
		}
	}
	return nil
}

type CT_Orientation struct{ ValAttr ST_Orientation }

func (_fgeec *CT_PictureStackUnit) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_fgeec.ValAttr = 0 + 1
	for _, _gfbd := range start.Attr {
		if _gfbd.Name.Local == "val" {
			_eaefg, _gdbgd := _c.ParseFloat(_gfbd.Value, 64)
			if _gdbgd != nil {
				return _gdbgd
			}
			_fgeec.ValAttr = _eaefg
			continue
		}
	}
	for {
		_cgcdg, _acbce := d.Token()
		if _acbce != nil {
			return _gg.Errorf("parsing\u0020CT_PictureStackUnit:\u0020\u0025s", _acbce)
		}
		if _fegcg, _ebdg := _cgcdg.(_fa.EndElement); _ebdg && _fegcg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dfdbc *EG_DLblShared) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _dfdbc.NumFmt != nil {
		_aeceg := _fa.StartElement{Name: _fa.Name{Local: "c:numFmt"}}
		e.EncodeElement(_dfdbc.NumFmt, _aeceg)
	}
	if _dfdbc.SpPr != nil {
		_edfee := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_dfdbc.SpPr, _edfee)
	}
	if _dfdbc.TxPr != nil {
		_eaacb := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_dfdbc.TxPr, _eaacb)
	}
	if _dfdbc.DLblPos != nil {
		_eeacc := _fa.StartElement{Name: _fa.Name{Local: "c:dLblPos"}}
		e.EncodeElement(_dfdbc.DLblPos, _eeacc)
	}
	if _dfdbc.ShowLegendKey != nil {
		_feedg := _fa.StartElement{Name: _fa.Name{Local: "c:showLegendKey"}}
		e.EncodeElement(_dfdbc.ShowLegendKey, _feedg)
	}
	if _dfdbc.ShowVal != nil {
		_bedeb := _fa.StartElement{Name: _fa.Name{Local: "c:showVal"}}
		e.EncodeElement(_dfdbc.ShowVal, _bedeb)
	}
	if _dfdbc.ShowCatName != nil {
		_ffefb := _fa.StartElement{Name: _fa.Name{Local: "c:showCatName"}}
		e.EncodeElement(_dfdbc.ShowCatName, _ffefb)
	}
	if _dfdbc.ShowSerName != nil {
		_dadge := _fa.StartElement{Name: _fa.Name{Local: "c:showSerName"}}
		e.EncodeElement(_dfdbc.ShowSerName, _dadge)
	}
	if _dfdbc.ShowPercent != nil {
		_bdgda := _fa.StartElement{Name: _fa.Name{Local: "c:showPercent"}}
		e.EncodeElement(_dfdbc.ShowPercent, _bdgda)
	}
	if _dfdbc.ShowBubbleSize != nil {
		_beaaf := _fa.StartElement{Name: _fa.Name{Local: "c:showBubbleSize"}}
		e.EncodeElement(_dfdbc.ShowBubbleSize, _beaaf)
	}
	if _dfdbc.Separator != nil {
		_fdfde := _fa.StartElement{Name: _fa.Name{Local: "c:separator"}}
		_b.AddPreserveSpaceAttr(&_fdfde, *_dfdbc.Separator)
		e.EncodeElement(_dfdbc.Separator, _fdfde)
	}
	return nil
}

// Validate validates the CT_StrRef and its children
func (_fcdag *CT_StrRef) Validate() error { return _fcdag.ValidateWithPath("CT_StrRef") }

// Validate validates the CT_AxPos and its children
func (_bcga *CT_AxPos) Validate() error { return _bcga.ValidateWithPath("CT_AxPos") }
func (_ffee *CT_ScatterStyle) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _fdefd := range start.Attr {
		if _fdefd.Name.Local == "val" {
			_ffee.ValAttr.UnmarshalXMLAttr(_fdefd)
			continue
		}
	}
	for {
		_cedacg, _gaec := d.Token()
		if _gaec != nil {
			return _gg.Errorf("parsing CT_ScatterStyle:\u0020\u0025s", _gaec)
		}
		if _bagbg, _eeagb := _cedacg.(_fa.EndElement); _eeagb && _bagbg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_agee *CT_Boolean) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _agee.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025d", _feaac(*_agee.ValAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_acdba *CT_PictureOptions) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _acdba.ApplyToFront != nil {
		_bggbe := _fa.StartElement{Name: _fa.Name{Local: "c:applyToFront"}}
		e.EncodeElement(_acdba.ApplyToFront, _bggbe)
	}
	if _acdba.ApplyToSides != nil {
		_cgfgc := _fa.StartElement{Name: _fa.Name{Local: "c:applyToSides"}}
		e.EncodeElement(_acdba.ApplyToSides, _cgfgc)
	}
	if _acdba.ApplyToEnd != nil {
		_fgdea := _fa.StartElement{Name: _fa.Name{Local: "c:applyToEnd"}}
		e.EncodeElement(_acdba.ApplyToEnd, _fgdea)
	}
	if _acdba.PictureFormat != nil {
		_agbe := _fa.StartElement{Name: _fa.Name{Local: "c:pictureFormat"}}
		e.EncodeElement(_acdba.PictureFormat, _agbe)
	}
	if _acdba.PictureStackUnit != nil {
		_gdgfc := _fa.StartElement{Name: _fa.Name{Local: "c:pictureStackUnit"}}
		e.EncodeElement(_acdba.PictureStackUnit, _gdgfc)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SerTx and its children
func (_cffcf *CT_SerTx) Validate() error { return _cffcf.ValidateWithPath("CT_SerTx") }
func (_deffb *ST_BarDir) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bgabc, _dedbd := d.Token()
	if _dedbd != nil {
		return _dedbd
	}
	if _gddb, _ffeae := _bgabc.(_fa.EndElement); _ffeae && _gddb.Name == start.Name {
		*_deffb = 1
		return nil
	}
	if _fbdf, _fggeb := _bgabc.(_fa.CharData); !_fggeb {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bgabc)
	} else {
		switch string(_fbdf) {
		case "":
			*_deffb = 0
		case "bar":
			*_deffb = 1
		case "col":
			*_deffb = 2
		}
	}
	_bgabc, _dedbd = d.Token()
	if _dedbd != nil {
		return _dedbd
	}
	if _ecefb, _ggeecc := _bgabc.(_fa.EndElement); _ggeecc && _ecefb.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bgabc)
}
func (_bed *CT_AreaSer) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bed.Idx = NewCT_UnsignedInt()
	_bed.Order = NewCT_UnsignedInt()
_ga:
	for {
		_gac, _fef := d.Token()
		if _fef != nil {
			return _fef
		}
		switch _cd := _gac.(type) {
		case _fa.StartElement:
			switch _cd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _gffd := d.DecodeElement(_bed.Idx, &_cd); _gffd != nil {
					return _gffd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "order"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "order"}:
				if _gbe := d.DecodeElement(_bed.Order, &_cd); _gbe != nil {
					return _gbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_bed.Tx = NewCT_SerTx()
				if _cfc := d.DecodeElement(_bed.Tx, &_cd); _cfc != nil {
					return _cfc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_bed.SpPr = _cb.NewCT_ShapeProperties()
				if _gbd := d.DecodeElement(_bed.SpPr, &_cd); _gbd != nil {
					return _gbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pictureOptions"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pictureOptions"}:
				_bed.PictureOptions = NewCT_PictureOptions()
				if _eac := d.DecodeElement(_bed.PictureOptions, &_cd); _eac != nil {
					return _eac
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dPt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dPt"}:
				_bbb := NewCT_DPt()
				if _gacd := d.DecodeElement(_bbb, &_cd); _gacd != nil {
					return _gacd
				}
				_bed.DPt = append(_bed.DPt, _bbb)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_bed.DLbls = NewCT_DLbls()
				if _fcg := d.DecodeElement(_bed.DLbls, &_cd); _fcg != nil {
					return _fcg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "trendline"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "trendline"}:
				_fbag := NewCT_Trendline()
				if _gee := d.DecodeElement(_fbag, &_cd); _gee != nil {
					return _gee
				}
				_bed.Trendline = append(_bed.Trendline, _fbag)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "errBars"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "errBars"}:
				_fedd := NewCT_ErrBars()
				if _ceec := d.DecodeElement(_fedd, &_cd); _ceec != nil {
					return _ceec
				}
				_bed.ErrBars = append(_bed.ErrBars, _fedd)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "cat"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "cat"}:
				_bed.Cat = NewCT_AxDataSource()
				if _ba := d.DecodeElement(_bed.Cat, &_cd); _ba != nil {
					return _ba
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "val"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "val"}:
				_bed.Val = NewCT_NumDataSource()
				if _adg := d.DecodeElement(_bed.Val, &_cd); _adg != nil {
					return _adg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_bed.ExtLst = NewCT_ExtensionList()
				if _bfa := d.DecodeElement(_bed.ExtLst, &_cd); _bfa != nil {
					return _bfa
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_AreaSer\u0020\u0025v", _cd.Name)
				if _fccb := d.Skip(); _fccb != nil {
					return _fccb
				}
			}
		case _fa.EndElement:
			break _ga
		case _fa.CharData:
		}
	}
	return nil
}
func NewCT_StrData() *CT_StrData { _dgbcf := &CT_StrData{}; return _dgbcf }

// ValidateWithPath validates the Chart and its children, prefixing error messages with path
func (_eeaab *Chart) ValidateWithPath(path string) error {
	if _gfge := _eeaab.CT_RelId.ValidateWithPath(path); _gfge != nil {
		return _gfge
	}
	return nil
}

// Validate validates the CT_View3D and its children
func (_gdfgc *CT_View3D) Validate() error { return _gdfgc.ValidateWithPath("CT_View3D") }
func NewCT_Area3DChart() *CT_Area3DChart  { _cc := &CT_Area3DChart{}; return _cc }

type CT_Legend struct {
	LegendPos   *CT_LegendPos
	LegendEntry []*CT_LegendEntry
	Layout      *CT_Layout
	Overlay     *CT_Boolean
	SpPr        *_cb.CT_ShapeProperties
	TxPr        *_cb.CT_TextBody
	ExtLst      *CT_ExtensionList
}

// ValidateWithPath validates the CT_RotX and its children, prefixing error messages with path
func (_ebafa *CT_RotX) ValidateWithPath(path string) error {
	if _ebafa.ValAttr != nil {
		if *_ebafa.ValAttr < -90 {
			return _gg.Errorf("\u0025s/m\u002eValAttr\u0020must\u0020be\u0020\u003e\u003d\u0020\u002d90\u0020\u0028have\u0020\u0025v\u0029", path, *_ebafa.ValAttr)
		}
		if *_ebafa.ValAttr > 90 {
			return _gg.Errorf("\u0025s/m\u002eValAttr must be\u0020\u003c\u003d\u002090 \u0028have\u0020\u0025v\u0029", path, *_ebafa.ValAttr)
		}
	}
	return nil
}
func NewCT_TickLblPos() *CT_TickLblPos { _ddbbe := &CT_TickLblPos{}; return _ddbbe }
func (_gegbc ST_PageSetupOrientation) String() string {
	switch _gegbc {
	case 0:
		return ""
	case 1:
		return "default"
	case 2:
		return "portrait"
	case 3:
		return "landscape"
	}
	return ""
}

// ST_Thickness is a union type
type ST_Thickness struct {
	ST_ThicknessPercent *string
	Uint32              *uint32
}

func (_eaaeb *ST_Crosses) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_fdfbf, _cdea := d.Token()
	if _cdea != nil {
		return _cdea
	}
	if _fcdaef, _gfcaf := _fdfbf.(_fa.EndElement); _gfcaf && _fcdaef.Name == start.Name {
		*_eaaeb = 1
		return nil
	}
	if _cegfd, _cffef := _fdfbf.(_fa.CharData); !_cffef {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fdfbf)
	} else {
		switch string(_cegfd) {
		case "":
			*_eaaeb = 0
		case "autoZero":
			*_eaaeb = 1
		case "max":
			*_eaaeb = 2
		case "min":
			*_eaaeb = 3
		}
	}
	_fdfbf, _cdea = d.Token()
	if _cdea != nil {
		return _cdea
	}
	if _eedce, _dacde := _fdfbf.(_fa.EndElement); _dacde && _eedce.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fdfbf)
}

type CT_Tx struct{ Choice *CT_TxChoice }

func (_baceb *ST_ErrValType) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_baceb = 0
	case "cust":
		*_baceb = 1
	case "fixedVal":
		*_baceb = 2
	case "percentage":
		*_baceb = 3
	case "stdDev":
		*_baceb = 4
	case "stdErr":
		*_baceb = 5
	}
	return nil
}

// Validate validates the CT_Title and its children
func (_cccad *CT_Title) Validate() error { return _cccad.ValidateWithPath("CT_Title") }

type ST_TimeUnit byte

func (_cffag *ST_ErrValType) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bbed, _caaaf := d.Token()
	if _caaaf != nil {
		return _caaaf
	}
	if _afceg, _cadef := _bbed.(_fa.EndElement); _cadef && _afceg.Name == start.Name {
		*_cffag = 1
		return nil
	}
	if _adbee, _fdbc := _bbed.(_fa.CharData); !_fdbc {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bbed)
	} else {
		switch string(_adbee) {
		case "":
			*_cffag = 0
		case "cust":
			*_cffag = 1
		case "fixedVal":
			*_cffag = 2
		case "percentage":
			*_cffag = 3
		case "stdDev":
			*_cffag = 4
		case "stdErr":
			*_cffag = 5
		}
	}
	_bbed, _caaaf = d.Token()
	if _caaaf != nil {
		return _caaaf
	}
	if _fcdfg, _cgbb := _bbed.(_fa.EndElement); _cgbb && _fcdfg.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bbed)
}

type CT_Pie3DChart struct {
	VaryColors *CT_Boolean
	Ser        []*CT_PieSer
	DLbls      *CT_DLbls
	ExtLst     *CT_ExtensionList
}

func (_gcfga ST_TimeUnit) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_gcfga.String(), start)
}

// ValidateWithPath validates the CT_CustSplit and its children, prefixing error messages with path
func (_edef *CT_CustSplit) ValidateWithPath(path string) error {
	for _gcea, _eagd := range _edef.SecondPiePt {
		if _fcce := _eagd.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSecondPiePt\u005b\u0025d\u005d", path, _gcea)); _fcce != nil {
			return _fcce
		}
	}
	return nil
}
func NewChartSpace() *ChartSpace {
	_fefdd := &ChartSpace{}
	_fefdd.CT_ChartSpace = *NewCT_ChartSpace()
	return _fefdd
}

type CT_ExtensionList struct{ Ext []*CT_Extension }

func (_ggbeb ST_BuiltInUnit) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_fecbd := _fa.Attr{}
	_fecbd.Name = name
	switch _ggbeb {
	case ST_BuiltInUnitUnset:
		_fecbd.Value = ""
	case ST_BuiltInUnitHundreds:
		_fecbd.Value = "hundreds"
	case ST_BuiltInUnitThousands:
		_fecbd.Value = "thousands"
	case ST_BuiltInUnitTenThousands:
		_fecbd.Value = "tenThousands"
	case ST_BuiltInUnitHundredThousands:
		_fecbd.Value = "hundredThousands"
	case ST_BuiltInUnitMillions:
		_fecbd.Value = "millions"
	case ST_BuiltInUnitTenMillions:
		_fecbd.Value = "tenMillions"
	case ST_BuiltInUnitHundredMillions:
		_fecbd.Value = "hundredMillions"
	case ST_BuiltInUnitBillions:
		_fecbd.Value = "billions"
	case ST_BuiltInUnitTrillions:
		_fecbd.Value = "trillions"
	}
	return _fecbd, nil
}
func NewCT_ExtensionList() *CT_ExtensionList { _bbde := &CT_ExtensionList{}; return _bbde }
func (_fagfd ST_DLblPos) Validate() error    { return _fagfd.ValidateWithPath("") }
func (_dbbda ST_SizeRepresents) ValidateWithPath(path string) error {
	switch _dbbda {
	case 0, 1, 2:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dbbda))
	}
	return nil
}
func NewCT_SizeRepresents() *CT_SizeRepresents { _dgfgfc := &CT_SizeRepresents{}; return _dgfgfc }

// ValidateWithPath validates the CT_NumData and its children, prefixing error messages with path
func (_bgcg *CT_NumData) ValidateWithPath(path string) error {
	if _bgcg.PtCount != nil {
		if _bcac := _bgcg.PtCount.ValidateWithPath(path + "\u002fPtCount"); _bcac != nil {
			return _bcac
		}
	}
	for _adbf, _afcg := range _bgcg.Pt {
		if _ggbg := _afcg.ValidateWithPath(_gg.Sprintf("\u0025s\u002fPt\u005b\u0025d]", path, _adbf)); _ggbg != nil {
			return _ggbg
		}
	}
	if _bgcg.ExtLst != nil {
		if _bfdfe := _bgcg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bfdfe != nil {
			return _bfdfe
		}
	}
	return nil
}

type ST_SizeRepresents byte

func (_ddebf *ChartSpace) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ddebf.CT_ChartSpace = *NewCT_ChartSpace()
_geaf:
	for {
		_fcabb, _eacaa := d.Token()
		if _eacaa != nil {
			return _eacaa
		}
		switch _dfded := _fcabb.(type) {
		case _fa.StartElement:
			switch _dfded.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "date1904"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "date1904"}:
				_ddebf.Date1904 = NewCT_Boolean()
				if _cdgb := d.DecodeElement(_ddebf.Date1904, &_dfded); _cdgb != nil {
					return _cdgb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "lang"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "lang"}:
				_ddebf.Lang = NewCT_TextLanguageID()
				if _baag := d.DecodeElement(_ddebf.Lang, &_dfded); _baag != nil {
					return _baag
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "roundedCorners"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "roundedCorners"}:
				_ddebf.RoundedCorners = NewCT_Boolean()
				if _ddcfa := d.DecodeElement(_ddebf.RoundedCorners, &_dfded); _ddcfa != nil {
					return _ddcfa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "style"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "style"}:
				_ddebf.Style = NewCT_Style()
				if _eade := d.DecodeElement(_ddebf.Style, &_dfded); _eade != nil {
					return _eade
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "clrMapOvr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "clrMapOvr"}:
				_ddebf.ClrMapOvr = _cb.NewCT_ColorMapping()
				if _eaff := d.DecodeElement(_ddebf.ClrMapOvr, &_dfded); _eaff != nil {
					return _eaff
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pivotSource"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pivotSource"}:
				_ddebf.PivotSource = NewCT_PivotSource()
				if _ceebb := d.DecodeElement(_ddebf.PivotSource, &_dfded); _ceebb != nil {
					return _ceebb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "protection"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "protection"}:
				_ddebf.Protection = NewCT_Protection()
				if _afee := d.DecodeElement(_ddebf.Protection, &_dfded); _afee != nil {
					return _afee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "chart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "chart"}:
				if _aefb := d.DecodeElement(_ddebf.Chart, &_dfded); _aefb != nil {
					return _aefb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_ddebf.SpPr = _cb.NewCT_ShapeProperties()
				if _ccfb := d.DecodeElement(_ddebf.SpPr, &_dfded); _ccfb != nil {
					return _ccfb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_ddebf.TxPr = _cb.NewCT_TextBody()
				if _eceaa := d.DecodeElement(_ddebf.TxPr, &_dfded); _eceaa != nil {
					return _eceaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "externalData"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "externalData"}:
				_ddebf.ExternalData = NewCT_ExternalData()
				if _ffbaa := d.DecodeElement(_ddebf.ExternalData, &_dfded); _ffbaa != nil {
					return _ffbaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "printSettings"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "printSettings"}:
				_ddebf.PrintSettings = NewCT_PrintSettings()
				if _affaa := d.DecodeElement(_ddebf.PrintSettings, &_dfded); _affaa != nil {
					return _affaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "userShapes"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "userShapes"}:
				_ddebf.UserShapes = NewCT_RelId()
				if _cddbb := d.DecodeElement(_ddebf.UserShapes, &_dfded); _cddbb != nil {
					return _cddbb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_ddebf.ExtLst = NewCT_ExtensionList()
				if _fcgc := d.DecodeElement(_ddebf.ExtLst, &_dfded); _fcgc != nil {
					return _fcgc
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020ChartSpace\u0020\u0025v", _dfded.Name)
				if _bagfc := d.Skip(); _bagfc != nil {
					return _bagfc
				}
			}
		case _fa.EndElement:
			break _geaf
		case _fa.CharData:
		}
	}
	return nil
}
func (_cecc ST_BuiltInUnit) ValidateWithPath(path string) error {
	switch _cecc {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cecc))
	}
	return nil
}
func (_efcfe *CT_RotY) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _efcfe.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_efcfe.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_cggea ST_ErrValType) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_cggea.String(), start)
}
func (_cdeb *CT_DTable) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _cdeb.ShowHorzBorder != nil {
		_eegb := _fa.StartElement{Name: _fa.Name{Local: "c:showHorzBorder"}}
		e.EncodeElement(_cdeb.ShowHorzBorder, _eegb)
	}
	if _cdeb.ShowVertBorder != nil {
		_dbeb := _fa.StartElement{Name: _fa.Name{Local: "c:showVertBorder"}}
		e.EncodeElement(_cdeb.ShowVertBorder, _dbeb)
	}
	if _cdeb.ShowOutline != nil {
		_defg := _fa.StartElement{Name: _fa.Name{Local: "c:showOutline"}}
		e.EncodeElement(_cdeb.ShowOutline, _defg)
	}
	if _cdeb.ShowKeys != nil {
		_daba := _fa.StartElement{Name: _fa.Name{Local: "c:showKeys"}}
		e.EncodeElement(_cdeb.ShowKeys, _daba)
	}
	if _cdeb.SpPr != nil {
		_bga := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_cdeb.SpPr, _bga)
	}
	if _cdeb.TxPr != nil {
		_cagag := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_cdeb.TxPr, _cagag)
	}
	if _cdeb.ExtLst != nil {
		_aabf := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_cdeb.ExtLst, _aabf)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Bar3DChart and its children
func (_gfg *CT_Bar3DChart) Validate() error { return _gfg.ValidateWithPath("CT_Bar3DChart") }
func NewCT_LegendEntryChoice() *CT_LegendEntryChoice {
	_dbgfb := &CT_LegendEntryChoice{}
	return _dbgfb
}

// Validate validates the CT_StockChart and its children
func (_aacec *CT_StockChart) Validate() error { return _aacec.ValidateWithPath("CT_StockChart") }
func ParseUnionST_DepthPercent(s string) (ST_DepthPercent, error) {
	if ST_DepthPercentWithSymbolPatternRe.MatchString(s) {
		return ST_DepthPercent{ST_DepthPercentWithSymbol: &s}, nil
	}
	_edaeb, _gaagb := _c.ParseUint(s, 10, 16)
	if _gaagb != nil {
		return ST_DepthPercent{}, _gaagb
	}
	_dfbgb := uint16(_edaeb)
	return ST_DepthPercent{ST_DepthPercentUShort: &_dfbgb}, nil
}
func (_egbegd ST_BubbleScale) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _egbegd.ST_BubbleScalePercent != nil {
		e.EncodeToken(_fa.CharData(*_egbegd.ST_BubbleScalePercent))
	}
	if _egbegd.ST_BubbleScaleUInt != nil {
		e.EncodeToken(_fa.CharData(_gg.Sprintf("\u0025d", *_egbegd.ST_BubbleScaleUInt)))
	}
	return e.EncodeToken(_fa.EndElement{Name: start.Name})
}
func (_cbcea *ST_BarDir) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_cbcea = 0
	case "bar":
		*_cbcea = 1
	case "col":
		*_cbcea = 2
	}
	return nil
}
func NewCT_DLblsChoice() *CT_DLblsChoice { _daed := &CT_DLblsChoice{}; return _daed }

type CT_SecondPieSize struct{ ValAttr *ST_SecondPieSize }

func (_ggeb *ST_LayoutMode) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_adgc, _egbb := d.Token()
	if _egbb != nil {
		return _egbb
	}
	if _bdbcg, _efbf := _adgc.(_fa.EndElement); _efbf && _bdbcg.Name == start.Name {
		*_ggeb = 1
		return nil
	}
	if _efaf, _babfg := _adgc.(_fa.CharData); !_babfg {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _adgc)
	} else {
		switch string(_efaf) {
		case "":
			*_ggeb = 0
		case "edge":
			*_ggeb = 1
		case "factor":
			*_ggeb = 2
		}
	}
	_adgc, _egbb = d.Token()
	if _egbb != nil {
		return _egbb
	}
	if _accfb, _ecdff := _adgc.(_fa.EndElement); _ecdff && _accfb.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _adgc)
}
func NewCT_BuiltInUnit() *CT_BuiltInUnit { _eebg := &CT_BuiltInUnit{}; return _eebg }
func (_fgef *CT_NumFmt) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "formatCode"}, Value: _gg.Sprintf("\u0025v", _fgef.FormatCodeAttr)})
	if _fgef.SourceLinkedAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "sourceLinked"}, Value: _gg.Sprintf("\u0025d", _feaac(*_fgef.SourceLinkedAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_gfcbgc *Group_DLbl) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_egac:
	for {
		_dfbe, _fgce := d.Token()
		if _fgce != nil {
			return _fgce
		}
		switch _gdeb := _dfbe.(type) {
		case _fa.StartElement:
			switch _gdeb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "layout"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "layout"}:
				_gfcbgc.Layout = NewCT_Layout()
				if _aabd := d.DecodeElement(_gfcbgc.Layout, &_gdeb); _aabd != nil {
					return _aabd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_gfcbgc.Tx = NewCT_Tx()
				if _eacaaa := d.DecodeElement(_gfcbgc.Tx, &_gdeb); _eacaaa != nil {
					return _eacaaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				_gfcbgc.NumFmt = NewCT_NumFmt()
				if _afagf := d.DecodeElement(_gfcbgc.NumFmt, &_gdeb); _afagf != nil {
					return _afagf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_gfcbgc.SpPr = _cb.NewCT_ShapeProperties()
				if _feccf := d.DecodeElement(_gfcbgc.SpPr, &_gdeb); _feccf != nil {
					return _feccf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_gfcbgc.TxPr = _cb.NewCT_TextBody()
				if _bcaa := d.DecodeElement(_gfcbgc.TxPr, &_gdeb); _bcaa != nil {
					return _bcaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLblPos"}:
				_gfcbgc.DLblPos = NewCT_DLblPos()
				if _dfbc := d.DecodeElement(_gfcbgc.DLblPos, &_gdeb); _dfbc != nil {
					return _dfbc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showLegendKey"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showLegendKey"}:
				_gfcbgc.ShowLegendKey = NewCT_Boolean()
				if _acagf := d.DecodeElement(_gfcbgc.ShowLegendKey, &_gdeb); _acagf != nil {
					return _acagf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showVal"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showVal"}:
				_gfcbgc.ShowVal = NewCT_Boolean()
				if _fgbbc := d.DecodeElement(_gfcbgc.ShowVal, &_gdeb); _fgbbc != nil {
					return _fgbbc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showCatName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showCatName"}:
				_gfcbgc.ShowCatName = NewCT_Boolean()
				if _ecac := d.DecodeElement(_gfcbgc.ShowCatName, &_gdeb); _ecac != nil {
					return _ecac
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showSerName"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showSerName"}:
				_gfcbgc.ShowSerName = NewCT_Boolean()
				if _gbbfg := d.DecodeElement(_gfcbgc.ShowSerName, &_gdeb); _gbbfg != nil {
					return _gbbfg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showPercent"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showPercent"}:
				_gfcbgc.ShowPercent = NewCT_Boolean()
				if _gbfbg := d.DecodeElement(_gfcbgc.ShowPercent, &_gdeb); _gbfbg != nil {
					return _gbfbg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "showBubbleSize"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "showBubbleSize"}:
				_gfcbgc.ShowBubbleSize = NewCT_Boolean()
				if _cfadd := d.DecodeElement(_gfcbgc.ShowBubbleSize, &_gdeb); _cfadd != nil {
					return _cfadd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "separator"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "separator"}:
				_gfcbgc.Separator = new(string)
				if _edfgf := d.DecodeElement(_gfcbgc.Separator, &_gdeb); _edfgf != nil {
					return _edfgf
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020Group_DLbl\u0020\u0025v", _gdeb.Name)
				if _cbgef := d.Skip(); _cbgef != nil {
					return _cbgef
				}
			}
		case _fa.EndElement:
			break _egac
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_DLbl and its children, prefixing error messages with path
func (_geea *CT_DLbl) ValidateWithPath(path string) error {
	if _dcfa := _geea.Idx.ValidateWithPath(path + "\u002fIdx"); _dcfa != nil {
		return _dcfa
	}
	if _geea.Choice != nil {
		if _gdbc := _geea.Choice.ValidateWithPath(path + "\u002fChoice"); _gdbc != nil {
			return _gdbc
		}
	}
	if _geea.ExtLst != nil {
		if _gcaf := _geea.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gcaf != nil {
			return _gcaf
		}
	}
	return nil
}

type CT_OfPieType struct{ ValAttr ST_OfPieType }

func (_fafbd *CT_Perspective) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _bfdab := range start.Attr {
		if _bfdab.Name.Local == "val" {
			_effb, _cgbg := _c.ParseUint(_bfdab.Value, 10, 8)
			if _cgbg != nil {
				return _cgbg
			}
			_cdaab := uint8(_effb)
			_fafbd.ValAttr = &_cdaab
			continue
		}
	}
	for {
		_afce, _fgbc := d.Token()
		if _fgbc != nil {
			return _gg.Errorf("parsing\u0020CT_Perspective:\u0020\u0025s", _fgbc)
		}
		if _ebcgbf, _ecfb := _afce.(_fa.EndElement); _ecfb && _ebcgbf.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_BubbleSer struct {
	Idx              *CT_UnsignedInt
	Order            *CT_UnsignedInt
	Tx               *CT_SerTx
	SpPr             *_cb.CT_ShapeProperties
	InvertIfNegative *CT_Boolean
	DPt              []*CT_DPt
	DLbls            *CT_DLbls
	Trendline        []*CT_Trendline
	ErrBars          []*CT_ErrBars
	XVal             *CT_AxDataSource
	YVal             *CT_NumDataSource
	BubbleSize       *CT_NumDataSource
	Bubble3D         *CT_Boolean
	ExtLst           *CT_ExtensionList
}
type Group_DLbl struct {
	Layout         *CT_Layout
	Tx             *CT_Tx
	NumFmt         *CT_NumFmt
	SpPr           *_cb.CT_ShapeProperties
	TxPr           *_cb.CT_TextBody
	DLblPos        *CT_DLblPos
	ShowLegendKey  *CT_Boolean
	ShowVal        *CT_Boolean
	ShowCatName    *CT_Boolean
	ShowSerName    *CT_Boolean
	ShowPercent    *CT_Boolean
	ShowBubbleSize *CT_Boolean
	Separator      *string
}

func (_gbgc *CT_LineSer) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_gbgc.Idx = NewCT_UnsignedInt()
	_gbgc.Order = NewCT_UnsignedInt()
_aaagf:
	for {
		_feeea, _gafd := d.Token()
		if _gafd != nil {
			return _gafd
		}
		switch _gaff := _feeea.(type) {
		case _fa.StartElement:
			switch _gaff.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _fgede := d.DecodeElement(_gbgc.Idx, &_gaff); _fgede != nil {
					return _fgede
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "order"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "order"}:
				if _dage := d.DecodeElement(_gbgc.Order, &_gaff); _dage != nil {
					return _dage
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_gbgc.Tx = NewCT_SerTx()
				if _acbee := d.DecodeElement(_gbgc.Tx, &_gaff); _acbee != nil {
					return _acbee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_gbgc.SpPr = _cb.NewCT_ShapeProperties()
				if _bbfge := d.DecodeElement(_gbgc.SpPr, &_gaff); _bbfge != nil {
					return _bbfge
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "marker"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "marker"}:
				_gbgc.Marker = NewCT_Marker()
				if _gdcb := d.DecodeElement(_gbgc.Marker, &_gaff); _gdcb != nil {
					return _gdcb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dPt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dPt"}:
				_defe := NewCT_DPt()
				if _acbbe := d.DecodeElement(_defe, &_gaff); _acbbe != nil {
					return _acbbe
				}
				_gbgc.DPt = append(_gbgc.DPt, _defe)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_gbgc.DLbls = NewCT_DLbls()
				if _fage := d.DecodeElement(_gbgc.DLbls, &_gaff); _fage != nil {
					return _fage
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "trendline"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "trendline"}:
				_bcfa := NewCT_Trendline()
				if _bggeb := d.DecodeElement(_bcfa, &_gaff); _bggeb != nil {
					return _bggeb
				}
				_gbgc.Trendline = append(_gbgc.Trendline, _bcfa)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "errBars"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "errBars"}:
				_gbgc.ErrBars = NewCT_ErrBars()
				if _aabc := d.DecodeElement(_gbgc.ErrBars, &_gaff); _aabc != nil {
					return _aabc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "cat"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "cat"}:
				_gbgc.Cat = NewCT_AxDataSource()
				if _caaef := d.DecodeElement(_gbgc.Cat, &_gaff); _caaef != nil {
					return _caaef
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "val"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "val"}:
				_gbgc.Val = NewCT_NumDataSource()
				if _agaeg := d.DecodeElement(_gbgc.Val, &_gaff); _agaeg != nil {
					return _agaeg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "smooth"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "smooth"}:
				_gbgc.Smooth = NewCT_Boolean()
				if _bcdgb := d.DecodeElement(_gbgc.Smooth, &_gaff); _bcdgb != nil {
					return _bcdgb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_gbgc.ExtLst = NewCT_ExtensionList()
				if _bgcdg := d.DecodeElement(_gbgc.ExtLst, &_gaff); _bgcdg != nil {
					return _bgcdg
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_LineSer\u0020\u0025v", _gaff.Name)
				if _bdfad := d.Skip(); _bdfad != nil {
					return _bdfad
				}
			}
		case _fa.EndElement:
			break _aaagf
		case _fa.CharData:
		}
	}
	return nil
}
func (_agffe *CT_MultiLvlStrData) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _agffe.PtCount != nil {
		_bcgef := _fa.StartElement{Name: _fa.Name{Local: "c:ptCount"}}
		e.EncodeElement(_agffe.PtCount, _bcgef)
	}
	if _agffe.Lvl != nil {
		_deaf := _fa.StartElement{Name: _fa.Name{Local: "c:lvl"}}
		for _, _facde := range _agffe.Lvl {
			e.EncodeElement(_facde, _deaf)
		}
	}
	if _agffe.ExtLst != nil {
		_ebaac := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_agffe.ExtLst, _ebaac)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_Line3DChart() *CT_Line3DChart {
	_abga := &CT_Line3DChart{}
	_abga.Grouping = NewCT_Grouping()
	return _abga
}

var ST_GapAmountPercentPatternRe = _g.MustCompile(ST_GapAmountPercentPattern)

func (_adba ST_ErrValType) String() string {
	switch _adba {
	case 0:
		return ""
	case 1:
		return "cust"
	case 2:
		return "fixedVal"
	case 3:
		return "percentage"
	case 4:
		return "stdDev"
	case 5:
		return "stdErr"
	}
	return ""
}

// ValidateWithPath validates the CT_Line3DChart and its children, prefixing error messages with path
func (_bcdgd *CT_Line3DChart) ValidateWithPath(path string) error {
	if _aaaf := _bcdgd.Grouping.ValidateWithPath(path + "\u002fGrouping"); _aaaf != nil {
		return _aaaf
	}
	if _bcdgd.VaryColors != nil {
		if _ebcb := _bcdgd.VaryColors.ValidateWithPath(path + "/VaryColors"); _ebcb != nil {
			return _ebcb
		}
	}
	for _edeffa, _edggc := range _bcdgd.Ser {
		if _daef := _edggc.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _edeffa)); _daef != nil {
			return _daef
		}
	}
	if _bcdgd.DLbls != nil {
		if _dfga := _bcdgd.DLbls.ValidateWithPath(path + "\u002fDLbls"); _dfga != nil {
			return _dfga
		}
	}
	if _bcdgd.DropLines != nil {
		if _bdbd := _bcdgd.DropLines.ValidateWithPath(path + "\u002fDropLines"); _bdbd != nil {
			return _bdbd
		}
	}
	if _bcdgd.GapDepth != nil {
		if _fgca := _bcdgd.GapDepth.ValidateWithPath(path + "\u002fGapDepth"); _fgca != nil {
			return _fgca
		}
	}
	for _fgdb, _cbccg := range _bcdgd.AxId {
		if _gggef := _cbccg.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _fgdb)); _gggef != nil {
			return _gggef
		}
	}
	if _bcdgd.ExtLst != nil {
		if _bacga := _bcdgd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bacga != nil {
			return _bacga
		}
	}
	return nil
}
func (_adegc ST_Overlap) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _adegc.ST_OverlapPercent != nil {
		e.EncodeToken(_fa.CharData(*_adegc.ST_OverlapPercent))
	}
	if _adegc.ST_OverlapByte != nil {
		e.EncodeToken(_fa.CharData(_gg.Sprintf("\u0025d", *_adegc.ST_OverlapByte)))
	}
	return e.EncodeToken(_fa.EndElement{Name: start.Name})
}

type CT_AxDataSource struct{ Choice *CT_AxDataSourceChoice }

// ValidateWithPath validates the CT_BarChart and its children, prefixing error messages with path
func (_fcgb *CT_BarChart) ValidateWithPath(path string) error {
	if _gfe := _fcgb.BarDir.ValidateWithPath(path + "\u002fBarDir"); _gfe != nil {
		return _gfe
	}
	if _fcgb.Grouping != nil {
		if _dee := _fcgb.Grouping.ValidateWithPath(path + "\u002fGrouping"); _dee != nil {
			return _dee
		}
	}
	if _fcgb.VaryColors != nil {
		if _ddac := _fcgb.VaryColors.ValidateWithPath(path + "/VaryColors"); _ddac != nil {
			return _ddac
		}
	}
	for _acde, _adfd := range _fcgb.Ser {
		if _afdf := _adfd.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _acde)); _afdf != nil {
			return _afdf
		}
	}
	if _fcgb.DLbls != nil {
		if _bgb := _fcgb.DLbls.ValidateWithPath(path + "\u002fDLbls"); _bgb != nil {
			return _bgb
		}
	}
	if _fcgb.GapWidth != nil {
		if _gdgd := _fcgb.GapWidth.ValidateWithPath(path + "\u002fGapWidth"); _gdgd != nil {
			return _gdgd
		}
	}
	if _fcgb.Overlap != nil {
		if _bab := _fcgb.Overlap.ValidateWithPath(path + "\u002fOverlap"); _bab != nil {
			return _bab
		}
	}
	for _deea, _bca := range _fcgb.SerLines {
		if _daa := _bca.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSerLines\u005b\u0025d\u005d", path, _deea)); _daa != nil {
			return _daa
		}
	}
	for _agfe, _beege := range _fcgb.AxId {
		if _faa := _beege.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _agfe)); _faa != nil {
			return _faa
		}
	}
	if _fcgb.ExtLst != nil {
		if _dbe := _fcgb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dbe != nil {
			return _dbe
		}
	}
	return nil
}
func (_aagb ST_ErrValType) Validate() error { return _aagb.ValidateWithPath("") }
func (_ggd *CT_BubbleSer) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_feff := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_ggd.Idx, _feff)
	_ecb := _fa.StartElement{Name: _fa.Name{Local: "c:order"}}
	e.EncodeElement(_ggd.Order, _ecb)
	if _ggd.Tx != nil {
		_dfgf := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_ggd.Tx, _dfgf)
	}
	if _ggd.SpPr != nil {
		_adgf := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_ggd.SpPr, _adgf)
	}
	if _ggd.InvertIfNegative != nil {
		_abaa := _fa.StartElement{Name: _fa.Name{Local: "c:invertIfNegative"}}
		e.EncodeElement(_ggd.InvertIfNegative, _abaa)
	}
	if _ggd.DPt != nil {
		_bce := _fa.StartElement{Name: _fa.Name{Local: "c:dPt"}}
		for _, _eeeb := range _ggd.DPt {
			e.EncodeElement(_eeeb, _bce)
		}
	}
	if _ggd.DLbls != nil {
		_agd := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_ggd.DLbls, _agd)
	}
	if _ggd.Trendline != nil {
		_egbg := _fa.StartElement{Name: _fa.Name{Local: "c:trendline"}}
		for _, _efcb := range _ggd.Trendline {
			e.EncodeElement(_efcb, _egbg)
		}
	}
	if _ggd.ErrBars != nil {
		_cgf := _fa.StartElement{Name: _fa.Name{Local: "c:errBars"}}
		for _, _bddd := range _ggd.ErrBars {
			e.EncodeElement(_bddd, _cgf)
		}
	}
	if _ggd.XVal != nil {
		_ecga := _fa.StartElement{Name: _fa.Name{Local: "c:xVal"}}
		e.EncodeElement(_ggd.XVal, _ecga)
	}
	if _ggd.YVal != nil {
		_cec := _fa.StartElement{Name: _fa.Name{Local: "c:yVal"}}
		e.EncodeElement(_ggd.YVal, _cec)
	}
	if _ggd.BubbleSize != nil {
		_bffc := _fa.StartElement{Name: _fa.Name{Local: "c:bubbleSize"}}
		e.EncodeElement(_ggd.BubbleSize, _bffc)
	}
	if _ggd.Bubble3D != nil {
		_gbfd := _fa.StartElement{Name: _fa.Name{Local: "c:bubble3D"}}
		e.EncodeElement(_ggd.Bubble3D, _gbfd)
	}
	if _ggd.ExtLst != nil {
		_bddb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_ggd.ExtLst, _bddb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_abef *CT_DLblsChoice) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _abef.Delete != nil {
		_eefa := _fa.StartElement{Name: _fa.Name{Local: "c:delete"}}
		e.EncodeElement(_abef.Delete, _eefa)
	}
	if _abef.NumFmt != nil {
		_bcad := _fa.StartElement{Name: _fa.Name{Local: "c:numFmt"}}
		e.EncodeElement(_abef.NumFmt, _bcad)
	}
	if _abef.SpPr != nil {
		_bgbb := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_abef.SpPr, _bgbb)
	}
	if _abef.TxPr != nil {
		_fdcb := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_abef.TxPr, _fdcb)
	}
	if _abef.DLblPos != nil {
		_abbf := _fa.StartElement{Name: _fa.Name{Local: "c:dLblPos"}}
		e.EncodeElement(_abef.DLblPos, _abbf)
	}
	if _abef.ShowLegendKey != nil {
		_edbc := _fa.StartElement{Name: _fa.Name{Local: "c:showLegendKey"}}
		e.EncodeElement(_abef.ShowLegendKey, _edbc)
	}
	if _abef.ShowVal != nil {
		_bcef := _fa.StartElement{Name: _fa.Name{Local: "c:showVal"}}
		e.EncodeElement(_abef.ShowVal, _bcef)
	}
	if _abef.ShowCatName != nil {
		_adfdd := _fa.StartElement{Name: _fa.Name{Local: "c:showCatName"}}
		e.EncodeElement(_abef.ShowCatName, _adfdd)
	}
	if _abef.ShowSerName != nil {
		_cgcbd := _fa.StartElement{Name: _fa.Name{Local: "c:showSerName"}}
		e.EncodeElement(_abef.ShowSerName, _cgcbd)
	}
	if _abef.ShowPercent != nil {
		_fbbb := _fa.StartElement{Name: _fa.Name{Local: "c:showPercent"}}
		e.EncodeElement(_abef.ShowPercent, _fbbb)
	}
	if _abef.ShowBubbleSize != nil {
		_cebb := _fa.StartElement{Name: _fa.Name{Local: "c:showBubbleSize"}}
		e.EncodeElement(_abef.ShowBubbleSize, _cebb)
	}
	if _abef.Separator != nil {
		_abgca := _fa.StartElement{Name: _fa.Name{Local: "c:separator"}}
		_b.AddPreserveSpaceAttr(&_abgca, *_abef.Separator)
		e.EncodeElement(_abef.Separator, _abgca)
	}
	if _abef.ShowLeaderLines != nil {
		_cagd := _fa.StartElement{Name: _fa.Name{Local: "c:showLeaderLines"}}
		e.EncodeElement(_abef.ShowLeaderLines, _cagd)
	}
	if _abef.LeaderLines != nil {
		_dfca := _fa.StartElement{Name: _fa.Name{Local: "c:leaderLines"}}
		e.EncodeElement(_abef.LeaderLines, _dfca)
	}
	return nil
}
func (_babdc *ST_LblOffset) ValidateWithPath(path string) error {
	_deggeg := []string{}
	if _babdc.ST_LblOffsetPercent != nil {
		_deggeg = append(_deggeg, "ST_LblOffsetPercent")
	}
	if _babdc.ST_LblOffsetUShort != nil {
		_deggeg = append(_deggeg, "ST_LblOffsetUShort")
	}
	if len(_deggeg) > 1 {
		return _gg.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _deggeg)
	}
	return nil
}
func NewCT_PieChart() *CT_PieChart { _dbgge := &CT_PieChart{}; return _dbgge }
func (_ggbag *CT_LineSer) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cbef := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_ggbag.Idx, _cbef)
	_febb := _fa.StartElement{Name: _fa.Name{Local: "c:order"}}
	e.EncodeElement(_ggbag.Order, _febb)
	if _ggbag.Tx != nil {
		_fcfd := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_ggbag.Tx, _fcfd)
	}
	if _ggbag.SpPr != nil {
		_gced := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_ggbag.SpPr, _gced)
	}
	if _ggbag.Marker != nil {
		_efeb := _fa.StartElement{Name: _fa.Name{Local: "c:marker"}}
		e.EncodeElement(_ggbag.Marker, _efeb)
	}
	if _ggbag.DPt != nil {
		_ccefb := _fa.StartElement{Name: _fa.Name{Local: "c:dPt"}}
		for _, _cbdf := range _ggbag.DPt {
			e.EncodeElement(_cbdf, _ccefb)
		}
	}
	if _ggbag.DLbls != nil {
		_dgdg := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_ggbag.DLbls, _dgdg)
	}
	if _ggbag.Trendline != nil {
		_gbgebf := _fa.StartElement{Name: _fa.Name{Local: "c:trendline"}}
		for _, _eadge := range _ggbag.Trendline {
			e.EncodeElement(_eadge, _gbgebf)
		}
	}
	if _ggbag.ErrBars != nil {
		_ffed := _fa.StartElement{Name: _fa.Name{Local: "c:errBars"}}
		e.EncodeElement(_ggbag.ErrBars, _ffed)
	}
	if _ggbag.Cat != nil {
		_efaeb := _fa.StartElement{Name: _fa.Name{Local: "c:cat"}}
		e.EncodeElement(_ggbag.Cat, _efaeb)
	}
	if _ggbag.Val != nil {
		_aebc := _fa.StartElement{Name: _fa.Name{Local: "c:val"}}
		e.EncodeElement(_ggbag.Val, _aebc)
	}
	if _ggbag.Smooth != nil {
		_aedd := _fa.StartElement{Name: _fa.Name{Local: "c:smooth"}}
		e.EncodeElement(_ggbag.Smooth, _aedd)
	}
	if _ggbag.ExtLst != nil {
		_egeg := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_ggbag.ExtLst, _egeg)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewGroup_DLbl() *Group_DLbl { _acec := &Group_DLbl{}; return _acec }
func (_efedd *CT_TickLblPos) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _efedd.ValAttr != ST_TickLblPosUnset {
		_ddaga, _aabad := _efedd.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _aabad != nil {
			return _aabad
		}
		start.Attr = append(start.Attr, _ddaga)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_feaag ST_SplitType) ValidateWithPath(path string) error {
	switch _feaag {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_feaag))
	}
	return nil
}
func (_ceada *CT_Line3DChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ceada.Grouping = NewCT_Grouping()
_debg:
	for {
		_fcfcd, _adda := d.Token()
		if _adda != nil {
			return _adda
		}
		switch _fedbd := _fcfcd.(type) {
		case _fa.StartElement:
			switch _fedbd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "grouping"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "grouping"}:
				if _ceadc := d.DecodeElement(_ceada.Grouping, &_fedbd); _ceadc != nil {
					return _ceadc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_ceada.VaryColors = NewCT_Boolean()
				if _deffe := d.DecodeElement(_ceada.VaryColors, &_fedbd); _deffe != nil {
					return _deffe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_ccec := NewCT_LineSer()
				if _dcbdb := d.DecodeElement(_ccec, &_fedbd); _dcbdb != nil {
					return _dcbdb
				}
				_ceada.Ser = append(_ceada.Ser, _ccec)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_ceada.DLbls = NewCT_DLbls()
				if _ffge := d.DecodeElement(_ceada.DLbls, &_fedbd); _ffge != nil {
					return _ffge
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dropLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dropLines"}:
				_ceada.DropLines = NewCT_ChartLines()
				if _ccdg := d.DecodeElement(_ceada.DropLines, &_fedbd); _ccdg != nil {
					return _ccdg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "gapDepth"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "gapDepth"}:
				_ceada.GapDepth = NewCT_GapAmount()
				if _afdfa := d.DecodeElement(_ceada.GapDepth, &_fedbd); _afdfa != nil {
					return _afdfa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_dgfgf := NewCT_UnsignedInt()
				if _dcbbe := d.DecodeElement(_dgfgf, &_fedbd); _dcbbe != nil {
					return _dcbbe
				}
				_ceada.AxId = append(_ceada.AxId, _dgfgf)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_ceada.ExtLst = NewCT_ExtensionList()
				if _bgafc := d.DecodeElement(_ceada.ExtLst, &_fedbd); _bgafc != nil {
					return _bgafc
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Line3DChart\u0020\u0025v", _fedbd.Name)
				if _acee := d.Skip(); _acee != nil {
					return _acee
				}
			}
		case _fa.EndElement:
			break _debg
		case _fa.CharData:
		}
	}
	return nil
}

// ST_HPercent is a union type
type ST_HPercent struct {
	ST_HPercentWithSymbol *string
	ST_HPercentUShort     *uint16
}

// Validate validates the CT_SizeRepresents and its children
func (_dfaag *CT_SizeRepresents) Validate() error {
	return _dfaag.ValidateWithPath("CT_SizeRepresents")
}
func NewCT_DLbl() *CT_DLbl { _acca := &CT_DLbl{}; _acca.Idx = NewCT_UnsignedInt(); return _acca }
func (_gfgge ST_RadarStyle) ValidateWithPath(path string) error {
	switch _gfgge {
	case 0, 1, 2, 3:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gfgge))
	}
	return nil
}

// Validate validates the CT_AreaSer and its children
func (_eea *CT_AreaSer) Validate() error { return _eea.ValidateWithPath("CT_AreaSer") }
func (_ccddd *ST_ErrDir) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_ccddd = 0
	case "x":
		*_ccddd = 1
	case "y":
		*_ccddd = 2
	}
	return nil
}
func NewCT_SurfaceChart() *CT_SurfaceChart { _acbdd := &CT_SurfaceChart{}; return _acbdd }

// ValidateWithPath validates the CT_PictureOptions and its children, prefixing error messages with path
func (_gdbcd *CT_PictureOptions) ValidateWithPath(path string) error {
	if _gdbcd.ApplyToFront != nil {
		if _eccaa := _gdbcd.ApplyToFront.ValidateWithPath(path + "\u002fApplyToFront"); _eccaa != nil {
			return _eccaa
		}
	}
	if _gdbcd.ApplyToSides != nil {
		if _cgacc := _gdbcd.ApplyToSides.ValidateWithPath(path + "\u002fApplyToSides"); _cgacc != nil {
			return _cgacc
		}
	}
	if _gdbcd.ApplyToEnd != nil {
		if _fgba := _gdbcd.ApplyToEnd.ValidateWithPath(path + "/ApplyToEnd"); _fgba != nil {
			return _fgba
		}
	}
	if _gdbcd.PictureFormat != nil {
		if _ggbb := _gdbcd.PictureFormat.ValidateWithPath(path + "\u002fPictureFormat"); _ggbb != nil {
			return _ggbb
		}
	}
	if _gdbcd.PictureStackUnit != nil {
		if _eegbb := _gdbcd.PictureStackUnit.ValidateWithPath(path + "\u002fPictureStackUnit"); _eegbb != nil {
			return _eegbb
		}
	}
	return nil
}
func (_aacf *CT_NumVal) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _ecbfc := range start.Attr {
		if _ecbfc.Name.Local == "idx" {
			_fecaed, _efab := _c.ParseUint(_ecbfc.Value, 10, 32)
			if _efab != nil {
				return _efab
			}
			_aacf.IdxAttr = uint32(_fecaed)
			continue
		}
		if _ecbfc.Name.Local == "formatCode" {
			_dbdd, _fdddb := _ecbfc.Value, error(nil)
			if _fdddb != nil {
				return _fdddb
			}
			_aacf.FormatCodeAttr = &_dbdd
			continue
		}
	}
_ceef:
	for {
		_bbcf, _faae := d.Token()
		if _faae != nil {
			return _faae
		}
		switch _agbg := _bbcf.(type) {
		case _fa.StartElement:
			switch _agbg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "v"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "v"}:
				if _debaf := d.DecodeElement(&_aacf.V, &_agbg); _debaf != nil {
					return _debaf
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_NumVal \u0025v", _agbg.Name)
				if _ddec := d.Skip(); _ddec != nil {
					return _ddec
				}
			}
		case _fa.EndElement:
			break _ceef
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_MarkerStyle and its children, prefixing error messages with path
func (_cadcg *CT_MarkerStyle) ValidateWithPath(path string) error {
	if _cadcg.ValAttr == ST_MarkerStyleUnset {
		return _gg.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _dcdag := _cadcg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _dcdag != nil {
		return _dcdag
	}
	return nil
}

// Validate validates the CT_Crosses and its children
func (_gadff *CT_Crosses) Validate() error     { return _gadff.ValidateWithPath("CT_Crosses") }
func NewCT_Surface3DChart() *CT_Surface3DChart { _bcggfd := &CT_Surface3DChart{}; return _bcggfd }
func (_dceae *ST_LegendPos) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_efcega, _fffeg := d.Token()
	if _fffeg != nil {
		return _fffeg
	}
	if _dbfed, _aedef := _efcega.(_fa.EndElement); _aedef && _dbfed.Name == start.Name {
		*_dceae = 1
		return nil
	}
	if _fgcf, _cgcaf := _efcega.(_fa.CharData); !_cgcaf {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _efcega)
	} else {
		switch string(_fgcf) {
		case "":
			*_dceae = 0
		case "b":
			*_dceae = 1
		case "tr":
			*_dceae = 2
		case "l":
			*_dceae = 3
		case "r":
			*_dceae = 4
		case "t":
			*_dceae = 5
		}
	}
	_efcega, _fffeg = d.Token()
	if _fffeg != nil {
		return _fffeg
	}
	if _dedfd, _aaec := _efcega.(_fa.EndElement); _aaec && _dedfd.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _efcega)
}

type CT_DispUnitsChoice struct {
	CustUnit    *CT_Double
	BuiltInUnit *CT_BuiltInUnit
}

const (
	ST_ErrBarTypeUnset ST_ErrBarType = 0
	ST_ErrBarTypeBoth  ST_ErrBarType = 1
	ST_ErrBarTypeMinus ST_ErrBarType = 2
	ST_ErrBarTypePlus  ST_ErrBarType = 3
)

func (_dfccd *CT_Protection) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_eafdf:
	for {
		_dbgfd, _abbde := d.Token()
		if _abbde != nil {
			return _abbde
		}
		switch _cbaa := _dbgfd.(type) {
		case _fa.StartElement:
			switch _cbaa.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "chartObject"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "chartObject"}:
				_dfccd.ChartObject = NewCT_Boolean()
				if _dgdc := d.DecodeElement(_dfccd.ChartObject, &_cbaa); _dgdc != nil {
					return _dgdc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "data"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "data"}:
				_dfccd.Data = NewCT_Boolean()
				if _fgfac := d.DecodeElement(_dfccd.Data, &_cbaa); _fgfac != nil {
					return _fgfac
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "formatting"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "formatting"}:
				_dfccd.Formatting = NewCT_Boolean()
				if _dfdce := d.DecodeElement(_dfccd.Formatting, &_cbaa); _dfdce != nil {
					return _dfdce
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "selection"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "selection"}:
				_dfccd.Selection = NewCT_Boolean()
				if _dege := d.DecodeElement(_dfccd.Selection, &_cbaa); _dege != nil {
					return _dege
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "userInterface"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "userInterface"}:
				_dfccd.UserInterface = NewCT_Boolean()
				if _dgbcb := d.DecodeElement(_dfccd.UserInterface, &_cbaa); _dgbcb != nil {
					return _dgbcb
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_Protection \u0025v", _cbaa.Name)
				if _gedb := d.Skip(); _gedb != nil {
					return _gedb
				}
			}
		case _fa.EndElement:
			break _eafdf
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_UnsignedInt and its children, prefixing error messages with path
func (_ddcgbc *CT_UnsignedInt) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_Pie3DChart and its children
func (_ffeb *CT_Pie3DChart) Validate() error { return _ffeb.ValidateWithPath("CT_Pie3DChart") }
func (_ffddd *ST_TimeUnit) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_ffddd = 0
	case "days":
		*_ffddd = 1
	case "months":
		*_ffddd = 2
	case "years":
		*_ffddd = 3
	}
	return nil
}
func NewCT_FirstSliceAng() *CT_FirstSliceAng { _cfea := &CT_FirstSliceAng{}; return _cfea }
func (_gbdda ST_LayoutMode) Validate() error { return _gbdda.ValidateWithPath("") }

const (
	ST_TimeUnitUnset  ST_TimeUnit = 0
	ST_TimeUnitDays   ST_TimeUnit = 1
	ST_TimeUnitMonths ST_TimeUnit = 2
	ST_TimeUnitYears  ST_TimeUnit = 3
)

type CT_TxChoice struct {
	StrRef *CT_StrRef
	Rich   *_cb.CT_TextBody
}

func (_gggd *CT_BandFmts) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_gccb:
	for {
		_fcf, _eeg := d.Token()
		if _eeg != nil {
			return _eeg
		}
		switch _cef := _fcf.(type) {
		case _fa.StartElement:
			switch _cef.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bandFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bandFmt"}:
				_dcda := NewCT_BandFmt()
				if _eeaf := d.DecodeElement(_dcda, &_cef); _eeaf != nil {
					return _eeaf
				}
				_gggd.BandFmt = append(_gggd.BandFmt, _dcda)
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BandFmts\u0020\u0025v", _cef.Name)
				if _edf := d.Skip(); _edf != nil {
					return _edf
				}
			}
		case _fa.EndElement:
			break _gccb
		case _fa.CharData:
		}
	}
	return nil
}
func (_gfbfd *CT_Trendline) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_gfbfd.TrendlineType = NewCT_TrendlineType()
_eaefcc:
	for {
		_egagad, _gafb := d.Token()
		if _gafb != nil {
			return _gafb
		}
		switch _gdegb := _egagad.(type) {
		case _fa.StartElement:
			switch _gdegb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "name"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "name"}:
				_gfbfd.Name = new(string)
				if _dbffb := d.DecodeElement(_gfbfd.Name, &_gdegb); _dbffb != nil {
					return _dbffb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_gfbfd.SpPr = _cb.NewCT_ShapeProperties()
				if _dbffg := d.DecodeElement(_gfbfd.SpPr, &_gdegb); _dbffg != nil {
					return _dbffg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "trendlineType"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "trendlineType"}:
				if _fcccf := d.DecodeElement(_gfbfd.TrendlineType, &_gdegb); _fcccf != nil {
					return _fcccf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "order"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "order"}:
				_gfbfd.Order = NewCT_Order()
				if _fegceg := d.DecodeElement(_gfbfd.Order, &_gdegb); _fegceg != nil {
					return _fegceg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "period"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "period"}:
				_gfbfd.Period = NewCT_Period()
				if _gaab := d.DecodeElement(_gfbfd.Period, &_gdegb); _gaab != nil {
					return _gaab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "forward"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "forward"}:
				_gfbfd.Forward = NewCT_Double()
				if _caeg := d.DecodeElement(_gfbfd.Forward, &_gdegb); _caeg != nil {
					return _caeg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "backward"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "backward"}:
				_gfbfd.Backward = NewCT_Double()
				if _fabbga := d.DecodeElement(_gfbfd.Backward, &_gdegb); _fabbga != nil {
					return _fabbga
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "intercept"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "intercept"}:
				_gfbfd.Intercept = NewCT_Double()
				if _abfab := d.DecodeElement(_gfbfd.Intercept, &_gdegb); _abfab != nil {
					return _abfab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dispRSqr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dispRSqr"}:
				_gfbfd.DispRSqr = NewCT_Boolean()
				if _aeffc := d.DecodeElement(_gfbfd.DispRSqr, &_gdegb); _aeffc != nil {
					return _aeffc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dispEq"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dispEq"}:
				_gfbfd.DispEq = NewCT_Boolean()
				if _dfdae := d.DecodeElement(_gfbfd.DispEq, &_gdegb); _dfdae != nil {
					return _dfdae
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "trendlineLbl"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "trendlineLbl"}:
				_gfbfd.TrendlineLbl = NewCT_TrendlineLbl()
				if _adcbd := d.DecodeElement(_gfbfd.TrendlineLbl, &_gdegb); _adcbd != nil {
					return _adcbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_gfbfd.ExtLst = NewCT_ExtensionList()
				if _fdga := d.DecodeElement(_gfbfd.ExtLst, &_gdegb); _fdga != nil {
					return _fdga
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Trendline\u0020\u0025v", _gdegb.Name)
				if _dgec := d.Skip(); _dgec != nil {
					return _dgec
				}
			}
		case _fa.EndElement:
			break _eaefcc
		case _fa.CharData:
		}
	}
	return nil
}
func (_bgdfb *CT_TickLblPos) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _cdadb := range start.Attr {
		if _cdadb.Name.Local == "val" {
			_bgdfb.ValAttr.UnmarshalXMLAttr(_cdadb)
			continue
		}
	}
	for {
		_ggca, _gffbc := d.Token()
		if _gffbc != nil {
			return _gg.Errorf("parsing\u0020CT_TickLblPos:\u0020\u0025s", _gffbc)
		}
		if _edgbb, _afdg := _ggca.(_fa.EndElement); _afdg && _edgbb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dcd *CT_AxisUnit) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", _dcd.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_ScatterSer struct {
	Idx       *CT_UnsignedInt
	Order     *CT_UnsignedInt
	Tx        *CT_SerTx
	SpPr      *_cb.CT_ShapeProperties
	Marker    *CT_Marker
	DPt       []*CT_DPt
	DLbls     *CT_DLbls
	Trendline []*CT_Trendline
	ErrBars   []*CT_ErrBars
	XVal      *CT_AxDataSource
	YVal      *CT_NumDataSource
	Smooth    *CT_Boolean
	ExtLst    *CT_ExtensionList
}

// Validate validates the CT_HoleSize and its children
func (_efadg *CT_HoleSize) Validate() error { return _efadg.ValidateWithPath("CT_HoleSize") }

// ValidateWithPath validates the CT_Area3DChart and its children, prefixing error messages with path
func (_fcc *CT_Area3DChart) ValidateWithPath(path string) error {
	if _fcc.Grouping != nil {
		if _fb := _fcc.Grouping.ValidateWithPath(path + "\u002fGrouping"); _fb != nil {
			return _fb
		}
	}
	if _fcc.VaryColors != nil {
		if _dga := _fcc.VaryColors.ValidateWithPath(path + "/VaryColors"); _dga != nil {
			return _dga
		}
	}
	for _aa, _eca := range _fcc.Ser {
		if _ed := _eca.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _aa)); _ed != nil {
			return _ed
		}
	}
	if _fcc.DLbls != nil {
		if _gb := _fcc.DLbls.ValidateWithPath(path + "\u002fDLbls"); _gb != nil {
			return _gb
		}
	}
	if _fcc.DropLines != nil {
		if _dgg := _fcc.DropLines.ValidateWithPath(path + "\u002fDropLines"); _dgg != nil {
			return _dgg
		}
	}
	if _fcc.GapDepth != nil {
		if _fgd := _fcc.GapDepth.ValidateWithPath(path + "\u002fGapDepth"); _fgd != nil {
			return _fgd
		}
	}
	for _eba, _bf := range _fcc.AxId {
		if _bea := _bf.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _eba)); _bea != nil {
			return _bea
		}
	}
	if _fcc.ExtLst != nil {
		if _bba := _fcc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bba != nil {
			return _bba
		}
	}
	return nil
}
func (_aedf ST_LayoutMode) String() string {
	switch _aedf {
	case 0:
		return ""
	case 1:
		return "edge"
	case 2:
		return "factor"
	}
	return ""
}

// ValidateWithPath validates the CT_HoleSize and its children, prefixing error messages with path
func (_fcaa *CT_HoleSize) ValidateWithPath(path string) error {
	if _fcaa.ValAttr != nil {
		if _efba := _fcaa.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _efba != nil {
			return _efba
		}
	}
	return nil
}
func (_gaeff ST_TimeUnit) String() string {
	switch _gaeff {
	case 0:
		return ""
	case 1:
		return "days"
	case 2:
		return "months"
	case 3:
		return "years"
	}
	return ""
}
func (_efebf *CT_View3D) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_ddada:
	for {
		_fafce, _ggbda := d.Token()
		if _ggbda != nil {
			return _ggbda
		}
		switch _gbbcd := _fafce.(type) {
		case _fa.StartElement:
			switch _gbbcd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "rotX"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "rotX"}:
				_efebf.RotX = NewCT_RotX()
				if _ddcaf := d.DecodeElement(_efebf.RotX, &_gbbcd); _ddcaf != nil {
					return _ddcaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "hPercent"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "hPercent"}:
				_efebf.HPercent = NewCT_HPercent()
				if _adcbg := d.DecodeElement(_efebf.HPercent, &_gbbcd); _adcbg != nil {
					return _adcbg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "rotY"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "rotY"}:
				_efebf.RotY = NewCT_RotY()
				if _edbfea := d.DecodeElement(_efebf.RotY, &_gbbcd); _edbfea != nil {
					return _edbfea
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "depthPercent"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "depthPercent"}:
				_efebf.DepthPercent = NewCT_DepthPercent()
				if _befd := d.DecodeElement(_efebf.DepthPercent, &_gbbcd); _befd != nil {
					return _befd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "rAngAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "rAngAx"}:
				_efebf.RAngAx = NewCT_Boolean()
				if _afdba := d.DecodeElement(_efebf.RAngAx, &_gbbcd); _afdba != nil {
					return _afdba
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "perspective"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "perspective"}:
				_efebf.Perspective = NewCT_Perspective()
				if _egeda := d.DecodeElement(_efebf.Perspective, &_gbbcd); _egeda != nil {
					return _egeda
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_efebf.ExtLst = NewCT_ExtensionList()
				if _cdeba := d.DecodeElement(_efebf.ExtLst, &_gbbcd); _cdeba != nil {
					return _cdeba
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_View3D \u0025v", _gbbcd.Name)
				if _eaeef := d.Skip(); _eaeef != nil {
					return _eaeef
				}
			}
		case _fa.EndElement:
			break _ddada
		case _fa.CharData:
		}
	}
	return nil
}
func (_bbcae ST_DLblPos) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_aadd := _fa.Attr{}
	_aadd.Name = name
	switch _bbcae {
	case ST_DLblPosUnset:
		_aadd.Value = ""
	case ST_DLblPosBestFit:
		_aadd.Value = "bestFit"
	case ST_DLblPosB:
		_aadd.Value = "b"
	case ST_DLblPosCtr:
		_aadd.Value = "ctr"
	case ST_DLblPosInBase:
		_aadd.Value = "inBase"
	case ST_DLblPosInEnd:
		_aadd.Value = "inEnd"
	case ST_DLblPosL:
		_aadd.Value = "l"
	case ST_DLblPosOutEnd:
		_aadd.Value = "outEnd"
	case ST_DLblPosR:
		_aadd.Value = "r"
	case ST_DLblPosT:
		_aadd.Value = "t"
	}
	return _aadd, nil
}

type CT_Surface3DChart struct {
	Wireframe *CT_Boolean
	Ser       []*CT_SurfaceSer
	BandFmts  *CT_BandFmts
	AxId      []*CT_UnsignedInt
	ExtLst    *CT_ExtensionList
}

// ValidateWithPath validates the CT_DLbls and its children, prefixing error messages with path
func (_dbea *CT_DLbls) ValidateWithPath(path string) error {
	for _ffbc, _fged := range _dbea.DLbl {
		if _efaab := _fged.ValidateWithPath(_gg.Sprintf("%s\u002fDLbl\u005b\u0025d\u005d", path, _ffbc)); _efaab != nil {
			return _efaab
		}
	}
	if _dbea.Choice != nil {
		if _gagga := _dbea.Choice.ValidateWithPath(path + "\u002fChoice"); _gagga != nil {
			return _gagga
		}
	}
	if _dbea.ExtLst != nil {
		if _dfbg := _dbea.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dfbg != nil {
			return _dfbg
		}
	}
	return nil
}

type CT_DLbls struct {
	DLbl   []*CT_DLbl
	Choice *CT_DLblsChoice
	ExtLst *CT_ExtensionList
}

// ValidateWithPath validates the CT_PlotAreaChoice and its children, prefixing error messages with path
func (_adcae *CT_PlotAreaChoice) ValidateWithPath(path string) error {
	if _adcae.AreaChart != nil {
		if _geead := _adcae.AreaChart.ValidateWithPath(path + "\u002fAreaChart"); _geead != nil {
			return _geead
		}
	}
	if _adcae.Area3DChart != nil {
		if _cbbc := _adcae.Area3DChart.ValidateWithPath(path + "\u002fArea3DChart"); _cbbc != nil {
			return _cbbc
		}
	}
	if _adcae.LineChart != nil {
		if _bbfgb := _adcae.LineChart.ValidateWithPath(path + "\u002fLineChart"); _bbfgb != nil {
			return _bbfgb
		}
	}
	if _adcae.Line3DChart != nil {
		if _dfee := _adcae.Line3DChart.ValidateWithPath(path + "\u002fLine3DChart"); _dfee != nil {
			return _dfee
		}
	}
	if _adcae.StockChart != nil {
		if _bfceb := _adcae.StockChart.ValidateWithPath(path + "/StockChart"); _bfceb != nil {
			return _bfceb
		}
	}
	if _adcae.RadarChart != nil {
		if _adgd := _adcae.RadarChart.ValidateWithPath(path + "/RadarChart"); _adgd != nil {
			return _adgd
		}
	}
	if _adcae.ScatterChart != nil {
		if _gacad := _adcae.ScatterChart.ValidateWithPath(path + "\u002fScatterChart"); _gacad != nil {
			return _gacad
		}
	}
	if _adcae.PieChart != nil {
		if _ggbbc := _adcae.PieChart.ValidateWithPath(path + "\u002fPieChart"); _ggbbc != nil {
			return _ggbbc
		}
	}
	if _adcae.Pie3DChart != nil {
		if _edbe := _adcae.Pie3DChart.ValidateWithPath(path + "/Pie3DChart"); _edbe != nil {
			return _edbe
		}
	}
	if _adcae.DoughnutChart != nil {
		if _bgddd := _adcae.DoughnutChart.ValidateWithPath(path + "\u002fDoughnutChart"); _bgddd != nil {
			return _bgddd
		}
	}
	if _adcae.BarChart != nil {
		if _cbbb := _adcae.BarChart.ValidateWithPath(path + "\u002fBarChart"); _cbbb != nil {
			return _cbbb
		}
	}
	if _adcae.Bar3DChart != nil {
		if _cfbd := _adcae.Bar3DChart.ValidateWithPath(path + "/Bar3DChart"); _cfbd != nil {
			return _cfbd
		}
	}
	if _adcae.OfPieChart != nil {
		if _ageae := _adcae.OfPieChart.ValidateWithPath(path + "/OfPieChart"); _ageae != nil {
			return _ageae
		}
	}
	if _adcae.SurfaceChart != nil {
		if _gdabg := _adcae.SurfaceChart.ValidateWithPath(path + "\u002fSurfaceChart"); _gdabg != nil {
			return _gdabg
		}
	}
	if _adcae.Surface3DChart != nil {
		if _fddbba := _adcae.Surface3DChart.ValidateWithPath(path + "\u002fSurface3DChart"); _fddbba != nil {
			return _fddbba
		}
	}
	if _adcae.BubbleChart != nil {
		if _bbdgba := _adcae.BubbleChart.ValidateWithPath(path + "\u002fBubbleChart"); _bbdgba != nil {
			return _bbdgba
		}
	}
	return nil
}
func (_efcfc *CT_DateAx) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_efcfc.AxId = NewCT_UnsignedInt()
	_efcfc.Scaling = NewCT_Scaling()
	_efcfc.AxPos = NewCT_AxPos()
	_efcfc.CrossAx = NewCT_UnsignedInt()
_edbb:
	for {
		_geed, _edbf := d.Token()
		if _edbf != nil {
			return _edbf
		}
		switch _bfbd := _geed.(type) {
		case _fa.StartElement:
			switch _bfbd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				if _cggd := d.DecodeElement(_efcfc.AxId, &_bfbd); _cggd != nil {
					return _cggd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "scaling"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "scaling"}:
				if _fbeg := d.DecodeElement(_efcfc.Scaling, &_bfbd); _fbeg != nil {
					return _fbeg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "delete"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "delete"}:
				_efcfc.Delete = NewCT_Boolean()
				if _cfcgg := d.DecodeElement(_efcfc.Delete, &_bfbd); _cfcgg != nil {
					return _cfcgg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axPos"}:
				if _eegd := d.DecodeElement(_efcfc.AxPos, &_bfbd); _eegd != nil {
					return _eegd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorGridlines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorGridlines"}:
				_efcfc.MajorGridlines = NewCT_ChartLines()
				if _fbgb := d.DecodeElement(_efcfc.MajorGridlines, &_bfbd); _fbgb != nil {
					return _fbgb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorGridlines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorGridlines"}:
				_efcfc.MinorGridlines = NewCT_ChartLines()
				if _fcabd := d.DecodeElement(_efcfc.MinorGridlines, &_bfbd); _fcabd != nil {
					return _fcabd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "title"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "title"}:
				_efcfc.Title = NewCT_Title()
				if _dgbg := d.DecodeElement(_efcfc.Title, &_bfbd); _dgbg != nil {
					return _dgbg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				_efcfc.NumFmt = NewCT_NumFmt()
				if _fbdc := d.DecodeElement(_efcfc.NumFmt, &_bfbd); _fbdc != nil {
					return _fbdc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorTickMark"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorTickMark"}:
				_efcfc.MajorTickMark = NewCT_TickMark()
				if _afbf := d.DecodeElement(_efcfc.MajorTickMark, &_bfbd); _afbf != nil {
					return _afbf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorTickMark"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorTickMark"}:
				_efcfc.MinorTickMark = NewCT_TickMark()
				if _bagb := d.DecodeElement(_efcfc.MinorTickMark, &_bfbd); _bagb != nil {
					return _bagb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tickLblPos"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tickLblPos"}:
				_efcfc.TickLblPos = NewCT_TickLblPos()
				if _bddc := d.DecodeElement(_efcfc.TickLblPos, &_bfbd); _bddc != nil {
					return _bddc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_efcfc.SpPr = _cb.NewCT_ShapeProperties()
				if _fdca := d.DecodeElement(_efcfc.SpPr, &_bfbd); _fdca != nil {
					return _fdca
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_efcfc.TxPr = _cb.NewCT_TextBody()
				if _aega := d.DecodeElement(_efcfc.TxPr, &_bfbd); _aega != nil {
					return _aega
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossAx"}:
				if _bfacf := d.DecodeElement(_efcfc.CrossAx, &_bfbd); _bfacf != nil {
					return _bfacf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crosses"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crosses"}:
				_efcfc.Choice = NewEG_AxSharedChoice()
				if _gcfb := d.DecodeElement(&_efcfc.Choice.Crosses, &_bfbd); _gcfb != nil {
					return _gcfb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "crossesAt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "crossesAt"}:
				_efcfc.Choice = NewEG_AxSharedChoice()
				if _affa := d.DecodeElement(&_efcfc.Choice.CrossesAt, &_bfbd); _affa != nil {
					return _affa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "auto"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "auto"}:
				_efcfc.Auto = NewCT_Boolean()
				if _badd := d.DecodeElement(_efcfc.Auto, &_bfbd); _badd != nil {
					return _badd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "lblOffset"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "lblOffset"}:
				_efcfc.LblOffset = NewCT_LblOffset()
				if _edga := d.DecodeElement(_efcfc.LblOffset, &_bfbd); _edga != nil {
					return _edga
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "baseTimeUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "baseTimeUnit"}:
				_efcfc.BaseTimeUnit = NewCT_TimeUnit()
				if _bgab := d.DecodeElement(_efcfc.BaseTimeUnit, &_bfbd); _bgab != nil {
					return _bgab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorUnit"}:
				_efcfc.MajorUnit = NewCT_AxisUnit()
				if _cdgea := d.DecodeElement(_efcfc.MajorUnit, &_bfbd); _cdgea != nil {
					return _cdgea
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "majorTimeUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "majorTimeUnit"}:
				_efcfc.MajorTimeUnit = NewCT_TimeUnit()
				if _fbfb := d.DecodeElement(_efcfc.MajorTimeUnit, &_bfbd); _fbfb != nil {
					return _fbfb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorUnit"}:
				_efcfc.MinorUnit = NewCT_AxisUnit()
				if _eeffb := d.DecodeElement(_efcfc.MinorUnit, &_bfbd); _eeffb != nil {
					return _eeffb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "minorTimeUnit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "minorTimeUnit"}:
				_efcfc.MinorTimeUnit = NewCT_TimeUnit()
				if _agaa := d.DecodeElement(_efcfc.MinorTimeUnit, &_bfbd); _agaa != nil {
					return _agaa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_efcfc.ExtLst = NewCT_ExtensionList()
				if _eead := d.DecodeElement(_efcfc.ExtLst, &_bfbd); _eead != nil {
					return _eead
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_DateAx \u0025v", _bfbd.Name)
				if _adagg := d.Skip(); _adagg != nil {
					return _adagg
				}
			}
		case _fa.EndElement:
			break _edbb
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the EG_AreaChartShared and its children, prefixing error messages with path
func (_edaef *EG_AreaChartShared) ValidateWithPath(path string) error {
	if _edaef.Grouping != nil {
		if _bgdgf := _edaef.Grouping.ValidateWithPath(path + "\u002fGrouping"); _bgdgf != nil {
			return _bgdgf
		}
	}
	if _edaef.VaryColors != nil {
		if _dedgf := _edaef.VaryColors.ValidateWithPath(path + "/VaryColors"); _dedgf != nil {
			return _dedgf
		}
	}
	for _bgcdc, _gfcca := range _edaef.Ser {
		if _bbcfe := _gfcca.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _bgcdc)); _bbcfe != nil {
			return _bbcfe
		}
	}
	if _edaef.DLbls != nil {
		if _daeb := _edaef.DLbls.ValidateWithPath(path + "\u002fDLbls"); _daeb != nil {
			return _daeb
		}
	}
	if _edaef.DropLines != nil {
		if _eeffba := _edaef.DropLines.ValidateWithPath(path + "\u002fDropLines"); _eeffba != nil {
			return _eeffba
		}
	}
	return nil
}

// ValidateWithPath validates the ChartSpace and its children, prefixing error messages with path
func (_fbccg *ChartSpace) ValidateWithPath(path string) error {
	if _aecdc := _fbccg.CT_ChartSpace.ValidateWithPath(path); _aecdc != nil {
		return _aecdc
	}
	return nil
}

// Validate validates the CT_BarSer and its children
func (_gcgg *CT_BarSer) Validate() error { return _gcgg.ValidateWithPath("CT_BarSer") }
func (_cffb ST_LblAlgn) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_cffb.String(), start)
}

type ST_LayoutMode byte

func NewCT_DLblChoice() *CT_DLblChoice { _debf := &CT_DLblChoice{}; return _debf }

const (
	ST_LayoutTargetUnset ST_LayoutTarget = 0
	ST_LayoutTargetInner ST_LayoutTarget = 1
	ST_LayoutTargetOuter ST_LayoutTarget = 2
)

// Validate validates the CT_RadarChart and its children
func (_fgaae *CT_RadarChart) Validate() error { return _fgaae.ValidateWithPath("CT_RadarChart") }
func (_deaa *CT_OfPieChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cgecf := _fa.StartElement{Name: _fa.Name{Local: "c:ofPieType"}}
	e.EncodeElement(_deaa.OfPieType, _cgecf)
	if _deaa.VaryColors != nil {
		_efbac := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_deaa.VaryColors, _efbac)
	}
	if _deaa.Ser != nil {
		_debc := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _eggca := range _deaa.Ser {
			e.EncodeElement(_eggca, _debc)
		}
	}
	if _deaa.DLbls != nil {
		_facg := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_deaa.DLbls, _facg)
	}
	if _deaa.GapWidth != nil {
		_geecf := _fa.StartElement{Name: _fa.Name{Local: "c:gapWidth"}}
		e.EncodeElement(_deaa.GapWidth, _geecf)
	}
	if _deaa.SplitType != nil {
		_gfda := _fa.StartElement{Name: _fa.Name{Local: "c:splitType"}}
		e.EncodeElement(_deaa.SplitType, _gfda)
	}
	if _deaa.SplitPos != nil {
		_agad := _fa.StartElement{Name: _fa.Name{Local: "c:splitPos"}}
		e.EncodeElement(_deaa.SplitPos, _agad)
	}
	if _deaa.CustSplit != nil {
		_aagdc := _fa.StartElement{Name: _fa.Name{Local: "c:custSplit"}}
		e.EncodeElement(_deaa.CustSplit, _aagdc)
	}
	if _deaa.SecondPieSize != nil {
		_cada := _fa.StartElement{Name: _fa.Name{Local: "c:secondPieSize"}}
		e.EncodeElement(_deaa.SecondPieSize, _cada)
	}
	if _deaa.SerLines != nil {
		_gefee := _fa.StartElement{Name: _fa.Name{Local: "c:serLines"}}
		for _, _debfg := range _deaa.SerLines {
			e.EncodeElement(_debfg, _gefee)
		}
	}
	if _deaa.ExtLst != nil {
		_faba := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_deaa.ExtLst, _faba)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewEG_PieChartShared() *EG_PieChartShared { _fbgge := &EG_PieChartShared{}; return _fbgge }

type EG_AreaChartShared struct {
	Grouping   *CT_Grouping
	VaryColors *CT_Boolean
	Ser        []*CT_AreaSer
	DLbls      *CT_DLbls
	DropLines  *CT_ChartLines
}

// Validate validates the CT_AxDataSourceChoice and its children
func (_gef *CT_AxDataSourceChoice) Validate() error {
	return _gef.ValidateWithPath("CT_AxDataSourceChoice")
}
func (_bddgd ST_Orientation) ValidateWithPath(path string) error {
	switch _bddgd {
	case 0, 1, 2:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bddgd))
	}
	return nil
}
func (_eafab *CT_RelId) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _bcbdb := range start.Attr {
		if _bcbdb.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bcbdb.Name.Local == "id" || _bcbdb.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bcbdb.Name.Local == "id" {
			_ccfea, _dffg := _bcbdb.Value, error(nil)
			if _dffg != nil {
				return _dffg
			}
			_eafab.IdAttr = _ccfea
			continue
		}
	}
	for {
		_gabb, _dgdea := d.Token()
		if _dgdea != nil {
			return _gg.Errorf("parsing\u0020CT_RelId: \u0025s", _dgdea)
		}
		if _baaa, _dffe := _gabb.(_fa.EndElement); _dffe && _baaa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_eedde *CT_Layout) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _eedde.ManualLayout != nil {
		_fdgg := _fa.StartElement{Name: _fa.Name{Local: "c:manualLayout"}}
		e.EncodeElement(_eedde.ManualLayout, _fdgg)
	}
	if _eedde.ExtLst != nil {
		_gcaa := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_eedde.ExtLst, _gcaa)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_bcage *CT_PivotSource) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cafda := _fa.StartElement{Name: _fa.Name{Local: "c:name"}}
	_b.AddPreserveSpaceAttr(&_cafda, _bcage.Name)
	e.EncodeElement(_bcage.Name, _cafda)
	_caadd := _fa.StartElement{Name: _fa.Name{Local: "c:fmtId"}}
	e.EncodeElement(_bcage.FmtId, _caadd)
	if _bcage.ExtLst != nil {
		_dgfc := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		for _, _eaed := range _bcage.ExtLst {
			e.EncodeElement(_eaed, _dgfc)
		}
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_DispUnits and its children
func (_eeec *CT_DispUnits) Validate() error { return _eeec.ValidateWithPath("CT_DispUnits") }

// Validate validates the CT_LogBase and its children
func (_dfe *CT_LogBase) Validate() error { return _dfe.ValidateWithPath("CT_LogBase") }

type CT_Style struct{ ValAttr uint8 }

func NewGroup_DLbls() *Group_DLbls { _ebad := &Group_DLbls{}; return _ebad }

var ST_SecondPieSizePercentPatternRe = _g.MustCompile(ST_SecondPieSizePercentPattern)

func (_efadf *ST_Thickness) Validate() error { return _efadf.ValidateWithPath("") }

// Validate validates the CT_HPercent and its children
func (_cbcab *CT_HPercent) Validate() error { return _cbcab.ValidateWithPath("CT_HPercent") }

type CT_Shape struct{ ValAttr ST_Shape }

func (_abaad *CT_DoughnutChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _abaad.VaryColors != nil {
		_fgffbb := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_abaad.VaryColors, _fgffbb)
	}
	if _abaad.Ser != nil {
		_fbbd := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _fcag := range _abaad.Ser {
			e.EncodeElement(_fcag, _fbbd)
		}
	}
	if _abaad.DLbls != nil {
		_dacaf := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_abaad.DLbls, _dacaf)
	}
	if _abaad.FirstSliceAng != nil {
		_dbed := _fa.StartElement{Name: _fa.Name{Local: "c:firstSliceAng"}}
		e.EncodeElement(_abaad.FirstSliceAng, _dbed)
	}
	if _abaad.HoleSize != nil {
		_fdcad := _fa.StartElement{Name: _fa.Name{Local: "c:holeSize"}}
		e.EncodeElement(_abaad.HoleSize, _fdcad)
	}
	if _abaad.ExtLst != nil {
		_dfcc := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_abaad.ExtLst, _dfcc)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_PieSer() *CT_PieSer {
	_cfbf := &CT_PieSer{}
	_cfbf.Idx = NewCT_UnsignedInt()
	_cfbf.Order = NewCT_UnsignedInt()
	return _cfbf
}
func (_gedaf *CT_LegendEntry) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_edadb := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_gedaf.Idx, _edadb)
	if _gedaf.Choice != nil {
		_gedaf.Choice.MarshalXML(e, _fa.StartElement{})
	}
	if _gedaf.ExtLst != nil {
		_caee := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_gedaf.ExtLst, _caee)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_PageSetup and its children, prefixing error messages with path
func (_gbbc *CT_PageSetup) ValidateWithPath(path string) error {
	if _gbbc.PaperHeightAttr != nil {
		if !_e.ST_PositiveUniversalMeasurePatternRe.MatchString(*_gbbc.PaperHeightAttr) {
			return _gg.Errorf("\u0025s/m\u002ePaperHeightAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_PositiveUniversalMeasurePatternRe, *_gbbc.PaperHeightAttr)
		}
	}
	if _gbbc.PaperHeightAttr != nil {
		if !_e.ST_UniversalMeasurePatternRe.MatchString(*_gbbc.PaperHeightAttr) {
			return _gg.Errorf("\u0025s/m\u002ePaperHeightAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _e.ST_UniversalMeasurePatternRe, *_gbbc.PaperHeightAttr)
		}
	}
	if _gbbc.PaperWidthAttr != nil {
		if !_e.ST_PositiveUniversalMeasurePatternRe.MatchString(*_gbbc.PaperWidthAttr) {
			return _gg.Errorf("\u0025s\u002fm.PaperWidthAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027 \u0028have\u0020\u0025v\u0029", path, _e.ST_PositiveUniversalMeasurePatternRe, *_gbbc.PaperWidthAttr)
		}
	}
	if _gbbc.PaperWidthAttr != nil {
		if !_e.ST_UniversalMeasurePatternRe.MatchString(*_gbbc.PaperWidthAttr) {
			return _gg.Errorf("\u0025s\u002fm.PaperWidthAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027 \u0028have\u0020\u0025v\u0029", path, _e.ST_UniversalMeasurePatternRe, *_gbbc.PaperWidthAttr)
		}
	}
	if _bceec := _gbbc.OrientationAttr.ValidateWithPath(path + "\u002fOrientationAttr"); _bceec != nil {
		return _bceec
	}
	return nil
}
func (_bafdg *ST_TimeUnit) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_efbgd, _gegae := d.Token()
	if _gegae != nil {
		return _gegae
	}
	if _egaad, _ggbdg := _efbgd.(_fa.EndElement); _ggbdg && _egaad.Name == start.Name {
		*_bafdg = 1
		return nil
	}
	if _gfcddf, _adagc := _efbgd.(_fa.CharData); !_adagc {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _efbgd)
	} else {
		switch string(_gfcddf) {
		case "":
			*_bafdg = 0
		case "days":
			*_bafdg = 1
		case "months":
			*_bafdg = 2
		case "years":
			*_bafdg = 3
		}
	}
	_efbgd, _gegae = d.Token()
	if _gegae != nil {
		return _gegae
	}
	if _fcfga, _ebggc := _efbgd.(_fa.EndElement); _ebggc && _fcfga.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _efbgd)
}

const (
	ST_CrossBetweenUnset   ST_CrossBetween = 0
	ST_CrossBetweenBetween ST_CrossBetween = 1
	ST_CrossBetweenMidCat  ST_CrossBetween = 2
)

func (_gebb *CT_GapAmount) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _gebb.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_gebb.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_CrossBetween and its children
func (_fadb *CT_CrossBetween) Validate() error { return _fadb.ValidateWithPath("CT_CrossBetween") }
func (_bcb *CT_AxPos) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_dgef, _edea := _bcb.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
	if _edea != nil {
		return _edea
	}
	start.Attr = append(start.Attr, _dgef)
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_cagbf *CT_Legend) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _cagbf.LegendPos != nil {
		_bacb := _fa.StartElement{Name: _fa.Name{Local: "c:legendPos"}}
		e.EncodeElement(_cagbf.LegendPos, _bacb)
	}
	if _cagbf.LegendEntry != nil {
		_eggc := _fa.StartElement{Name: _fa.Name{Local: "c:legendEntry"}}
		for _, _bdadc := range _cagbf.LegendEntry {
			e.EncodeElement(_bdadc, _eggc)
		}
	}
	if _cagbf.Layout != nil {
		_abad := _fa.StartElement{Name: _fa.Name{Local: "c:layout"}}
		e.EncodeElement(_cagbf.Layout, _abad)
	}
	if _cagbf.Overlay != nil {
		_dbcca := _fa.StartElement{Name: _fa.Name{Local: "c:overlay"}}
		e.EncodeElement(_cagbf.Overlay, _dbcca)
	}
	if _cagbf.SpPr != nil {
		_aabfg := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_cagbf.SpPr, _aabfg)
	}
	if _cagbf.TxPr != nil {
		_cgdad := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_cagbf.TxPr, _cgdad)
	}
	if _cagbf.ExtLst != nil {
		_fggfb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_cagbf.ExtLst, _fggfb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_aeggg *CT_RadarStyle) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _aeggg.ValAttr != ST_RadarStyleUnset {
		_gfeg, _dfaeb := _aeggg.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _dfaeb != nil {
			return _dfaeb
		}
		start.Attr = append(start.Attr, _gfeg)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_BandFmt and its children, prefixing error messages with path
func (_aba *CT_BandFmt) ValidateWithPath(path string) error {
	if _ccf := _aba.Idx.ValidateWithPath(path + "\u002fIdx"); _ccf != nil {
		return _ccf
	}
	if _aba.SpPr != nil {
		if _cab := _aba.SpPr.ValidateWithPath(path + "\u002fSpPr"); _cab != nil {
			return _cab
		}
	}
	return nil
}
func (_fbbe *CT_BarChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_fbbf := _fa.StartElement{Name: _fa.Name{Local: "c:barDir"}}
	e.EncodeElement(_fbbe.BarDir, _fbbf)
	if _fbbe.Grouping != nil {
		_bec := _fa.StartElement{Name: _fa.Name{Local: "c:grouping"}}
		e.EncodeElement(_fbbe.Grouping, _bec)
	}
	if _fbbe.VaryColors != nil {
		_bde := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_fbbe.VaryColors, _bde)
	}
	if _fbbe.Ser != nil {
		_abd := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _eee := range _fbbe.Ser {
			e.EncodeElement(_eee, _abd)
		}
	}
	if _fbbe.DLbls != nil {
		_aefc := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_fbbe.DLbls, _aefc)
	}
	if _fbbe.GapWidth != nil {
		_agf := _fa.StartElement{Name: _fa.Name{Local: "c:gapWidth"}}
		e.EncodeElement(_fbbe.GapWidth, _agf)
	}
	if _fbbe.Overlap != nil {
		_bdeb := _fa.StartElement{Name: _fa.Name{Local: "c:overlap"}}
		e.EncodeElement(_fbbe.Overlap, _bdeb)
	}
	if _fbbe.SerLines != nil {
		_bag := _fa.StartElement{Name: _fa.Name{Local: "c:serLines"}}
		for _, _dec := range _fbbe.SerLines {
			e.EncodeElement(_dec, _bag)
		}
	}
	_ccb := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _fbab := range _fbbe.AxId {
		e.EncodeElement(_fbab, _ccb)
	}
	if _fbbe.ExtLst != nil {
		_abb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_fbbe.ExtLst, _abb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_SerTxChoice() *CT_SerTxChoice { _ddedd := &CT_SerTxChoice{}; return _ddedd }
func (_ebdff ST_Shape) Validate() error  { return _ebdff.ValidateWithPath("") }

// Validate validates the CT_RelId and its children
func (_gdfcf *CT_RelId) Validate() error { return _gdfcf.ValidateWithPath("CT_RelId") }
func (_ebbab ST_LayoutMode) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_dfadb := _fa.Attr{}
	_dfadb.Name = name
	switch _ebbab {
	case ST_LayoutModeUnset:
		_dfadb.Value = ""
	case ST_LayoutModeEdge:
		_dfadb.Value = "edge"
	case ST_LayoutModeFactor:
		_dfadb.Value = "factor"
	}
	return _dfadb, nil
}

// Validate validates the CT_ErrValType and its children
func (_ecdb *CT_ErrValType) Validate() error { return _ecdb.ValidateWithPath("CT_ErrValType") }
func (_fceg *CT_LegendEntry) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_fceg.Idx = NewCT_UnsignedInt()
_fgde:
	for {
		_debdf, _dbbf := d.Token()
		if _dbbf != nil {
			return _dbbf
		}
		switch _dedae := _debdf.(type) {
		case _fa.StartElement:
			switch _dedae.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _bgee := d.DecodeElement(_fceg.Idx, &_dedae); _bgee != nil {
					return _bgee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "delete"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "delete"}:
				if _fceg.Choice == nil {
					_fceg.Choice = NewCT_LegendEntryChoice()
				}
				if _egfb := d.DecodeElement(&_fceg.Choice.Delete, &_dedae); _egfb != nil {
					return _egfb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				if _fceg.Choice == nil {
					_fceg.Choice = NewCT_LegendEntryChoice()
				}
				if _dbga := d.DecodeElement(&_fceg.Choice.TxPr, &_dedae); _dbga != nil {
					return _dbga
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_fceg.ExtLst = NewCT_ExtensionList()
				if _bdgb := d.DecodeElement(_fceg.ExtLst, &_dedae); _bdgb != nil {
					return _bdgb
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_LegendEntry\u0020\u0025v", _dedae.Name)
				if _eceg := d.Skip(); _eceg != nil {
					return _eceg
				}
			}
		case _fa.EndElement:
			break _fgde
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_DispUnitsChoice and its children, prefixing error messages with path
func (_deed *CT_DispUnitsChoice) ValidateWithPath(path string) error {
	if _deed.CustUnit != nil {
		if _abae := _deed.CustUnit.ValidateWithPath(path + "\u002fCustUnit"); _abae != nil {
			return _abae
		}
	}
	if _deed.BuiltInUnit != nil {
		if _bbegd := _deed.BuiltInUnit.ValidateWithPath(path + "\u002fBuiltInUnit"); _bbegd != nil {
			return _bbegd
		}
	}
	return nil
}
func (_eebbd *ST_Orientation) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_fdcff, _gbeea := d.Token()
	if _gbeea != nil {
		return _gbeea
	}
	if _eccaac, _badca := _fdcff.(_fa.EndElement); _badca && _eccaac.Name == start.Name {
		*_eebbd = 1
		return nil
	}
	if _ggfcc, _edecd := _fdcff.(_fa.CharData); !_edecd {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fdcff)
	} else {
		switch string(_ggfcc) {
		case "":
			*_eebbd = 0
		case "maxMin":
			*_eebbd = 1
		case "minMax":
			*_eebbd = 2
		}
	}
	_fdcff, _gbeea = d.Token()
	if _gbeea != nil {
		return _gbeea
	}
	if _fgcad, _ccgdg := _fdcff.(_fa.EndElement); _ccgdg && _fgcad.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fdcff)
}
func (_acccg ST_LblAlgn) ValidateWithPath(path string) error {
	switch _acccg {
	case 0, 1, 2, 3:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_acccg))
	}
	return nil
}
func NewCT_ScatterSer() *CT_ScatterSer {
	_fdbd := &CT_ScatterSer{}
	_fdbd.Idx = NewCT_UnsignedInt()
	_fdbd.Order = NewCT_UnsignedInt()
	return _fdbd
}
func NewCT_UnsignedInt() *CT_UnsignedInt { _addcb := &CT_UnsignedInt{}; return _addcb }
func NewEG_AxShared() *EG_AxShared {
	_egbea := &EG_AxShared{}
	_egbea.AxId = NewCT_UnsignedInt()
	_egbea.Scaling = NewCT_Scaling()
	_egbea.AxPos = NewCT_AxPos()
	_egbea.CrossAx = NewCT_UnsignedInt()
	return _egbea
}

// Validate validates the EG_AreaChartShared and its children
func (_cagfa *EG_AreaChartShared) Validate() error {
	return _cagfa.ValidateWithPath("EG_AreaChartShared")
}

type Any interface {
	MarshalXML(_bgbdb *_fa.Encoder, _eafgc _fa.StartElement) error
	UnmarshalXML(_eeecc *_fa.Decoder, _baec _fa.StartElement) error
}

const (
	ST_AxPosUnset ST_AxPos = 0
	ST_AxPosB     ST_AxPos = 1
	ST_AxPosL     ST_AxPos = 2
	ST_AxPosR     ST_AxPos = 3
	ST_AxPosT     ST_AxPos = 4
)

type ST_RadarStyle byte

func (_bdffd *CT_CrossBetween) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bdffd.ValAttr = ST_CrossBetween(1)
	for _, _fcca := range start.Attr {
		if _fcca.Name.Local == "val" {
			_bdffd.ValAttr.UnmarshalXMLAttr(_fcca)
			continue
		}
	}
	for {
		_cbag, _egeef := d.Token()
		if _egeef != nil {
			return _gg.Errorf("parsing CT_CrossBetween:\u0020\u0025s", _egeef)
		}
		if _ecaa, _cfeb := _cbag.(_fa.EndElement); _cfeb && _ecaa.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_PlotArea() *CT_PlotArea { _gedcc := &CT_PlotArea{}; return _gedcc }
func (_gebga *CT_StrRef) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_beab := _fa.StartElement{Name: _fa.Name{Local: "c:f"}}
	_b.AddPreserveSpaceAttr(&_beab, _gebga.F)
	e.EncodeElement(_gebga.F, _beab)
	if _gebga.StrCache != nil {
		_cdbb := _fa.StartElement{Name: _fa.Name{Local: "c:strCache"}}
		e.EncodeElement(_gebga.StrCache, _cdbb)
	}
	if _gebga.ExtLst != nil {
		_bdafb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_gebga.ExtLst, _bdafb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_PrintSettings and its children
func (_bcbe *CT_PrintSettings) Validate() error { return _bcbe.ValidateWithPath("CT_PrintSettings") }
func (_fbdcb *ST_SecondPieSize) ValidateWithPath(path string) error {
	_acfga := []string{}
	if _fbdcb.ST_SecondPieSizePercent != nil {
		_acfga = append(_acfga, "ST_SecondPieSizePercent")
	}
	if _fbdcb.ST_SecondPieSizeUShort != nil {
		_acfga = append(_acfga, "ST_SecondPieSizeUShort")
	}
	if len(_acfga) > 1 {
		return _gg.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _acfga)
	}
	return nil
}
func (_eaeagg *CT_DispUnitsLbl) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _eaeagg.Layout != nil {
		_bgca := _fa.StartElement{Name: _fa.Name{Local: "c:layout"}}
		e.EncodeElement(_eaeagg.Layout, _bgca)
	}
	if _eaeagg.Tx != nil {
		_edgab := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_eaeagg.Tx, _edgab)
	}
	if _eaeagg.SpPr != nil {
		_bbdae := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_eaeagg.SpPr, _bbdae)
	}
	if _eaeagg.TxPr != nil {
		_cbea := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_eaeagg.TxPr, _cbea)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_OfPieChart and its children
func (_ccca *CT_OfPieChart) Validate() error { return _ccca.ValidateWithPath("CT_OfPieChart") }

// Validate validates the CT_Tx and its children
func (_begd *CT_Tx) Validate() error { return _begd.ValidateWithPath("CT_Tx") }

const ST_HPercentWithSymbolPattern = "0\u002a\u0028\u0028\u005b5\u002d9\u005d\u0029|\u0028\u005b1\u002d9\u005d\u005b0-9\u005d\u0029\u007c(\u005b1\u002d4\u005d\u005b0\u002d9][0\u002d9\u005d\u0029\u007c500\u0029\u0025"

// ValidateWithPath validates the EG_AxSharedChoice and its children, prefixing error messages with path
func (_defbee *EG_AxSharedChoice) ValidateWithPath(path string) error {
	if _defbee.Crosses != nil {
		if _effa := _defbee.Crosses.ValidateWithPath(path + "\u002fCrosses"); _effa != nil {
			return _effa
		}
	}
	if _defbee.CrossesAt != nil {
		if _acafe := _defbee.CrossesAt.ValidateWithPath(path + "\u002fCrossesAt"); _acafe != nil {
			return _acafe
		}
	}
	return nil
}
func (_gfff *CT_LayoutMode) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _gfff.ValAttr != ST_LayoutModeUnset {
		_bcee, _egca := _gfff.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _egca != nil {
			return _egca
		}
		start.Attr = append(start.Attr, _bcee)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ST_HoleSize is a union type
type ST_HoleSize struct {
	ST_HoleSizePercent *string
	ST_HoleSizeUByte   *uint8
}

const (
	ST_OfPieTypeUnset ST_OfPieType = 0
	ST_OfPieTypePie   ST_OfPieType = 1
	ST_OfPieTypeBar   ST_OfPieType = 2
)

func NewCT_ValAx() *CT_ValAx {
	_bdddf := &CT_ValAx{}
	_bdddf.AxId = NewCT_UnsignedInt()
	_bdddf.Scaling = NewCT_Scaling()
	_bdddf.AxPos = NewCT_AxPos()
	_bdddf.CrossAx = NewCT_UnsignedInt()
	return _bdddf
}
func NewCT_Marker() *CT_Marker { _edfc := &CT_Marker{}; return _edfc }
func (_dcad *CT_FirstSliceAng) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _dcad.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_dcad.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_BubbleScale struct{ ValAttr *ST_BubbleScale }

func (_fgeae ST_OfPieType) String() string {
	switch _fgeae {
	case 0:
		return ""
	case 1:
		return "pie"
	case 2:
		return "bar"
	}
	return ""
}
func (_gfcbf *CT_PageSetup) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _cagde := range start.Attr {
		if _cagde.Name.Local == "paperSize" {
			_fgbe, _edgeg := _c.ParseUint(_cagde.Value, 10, 32)
			if _edgeg != nil {
				return _edgeg
			}
			_gcddf := uint32(_fgbe)
			_gfcbf.PaperSizeAttr = &_gcddf
			continue
		}
		if _cagde.Name.Local == "paperHeight" {
			_gacga, _addc := _cagde.Value, error(nil)
			if _addc != nil {
				return _addc
			}
			_gfcbf.PaperHeightAttr = &_gacga
			continue
		}
		if _cagde.Name.Local == "paperWidth" {
			_gfddb, _baacd := _cagde.Value, error(nil)
			if _baacd != nil {
				return _baacd
			}
			_gfcbf.PaperWidthAttr = &_gfddb
			continue
		}
		if _cagde.Name.Local == "firstPageNumber" {
			_eegdf, _befba := _c.ParseUint(_cagde.Value, 10, 32)
			if _befba != nil {
				return _befba
			}
			_afeaa := uint32(_eegdf)
			_gfcbf.FirstPageNumberAttr = &_afeaa
			continue
		}
		if _cagde.Name.Local == "orientation" {
			_gfcbf.OrientationAttr.UnmarshalXMLAttr(_cagde)
			continue
		}
		if _cagde.Name.Local == "blackAndWhite" {
			_fgdbc, _bfaac := _c.ParseBool(_cagde.Value)
			if _bfaac != nil {
				return _bfaac
			}
			_gfcbf.BlackAndWhiteAttr = &_fgdbc
			continue
		}
		if _cagde.Name.Local == "draft" {
			_ebec, _gedfb := _c.ParseBool(_cagde.Value)
			if _gedfb != nil {
				return _gedfb
			}
			_gfcbf.DraftAttr = &_ebec
			continue
		}
		if _cagde.Name.Local == "useFirstPageNumber" {
			_cfeaf, _fbbbb := _c.ParseBool(_cagde.Value)
			if _fbbbb != nil {
				return _fbbbb
			}
			_gfcbf.UseFirstPageNumberAttr = &_cfeaf
			continue
		}
		if _cagde.Name.Local == "horizontalDpi" {
			_ebba, _egfa := _c.ParseInt(_cagde.Value, 10, 32)
			if _egfa != nil {
				return _egfa
			}
			_dgff := int32(_ebba)
			_gfcbf.HorizontalDpiAttr = &_dgff
			continue
		}
		if _cagde.Name.Local == "verticalDpi" {
			_abgaf, _dfef := _c.ParseInt(_cagde.Value, 10, 32)
			if _dfef != nil {
				return _dfef
			}
			_bcggf := int32(_abgaf)
			_gfcbf.VerticalDpiAttr = &_bcggf
			continue
		}
		if _cagde.Name.Local == "copies" {
			_ffdd, _ebda := _c.ParseUint(_cagde.Value, 10, 32)
			if _ebda != nil {
				return _ebda
			}
			_cgbc := uint32(_ffdd)
			_gfcbf.CopiesAttr = &_cgbc
			continue
		}
	}
	for {
		_eecbb, _bbef := d.Token()
		if _bbef != nil {
			return _gg.Errorf("parsing\u0020CT_PageSetup:\u0020\u0025s", _bbef)
		}
		if _caagf, _aacbc := _eecbb.(_fa.EndElement); _aacbc && _caagf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gcbbf *ST_DispBlanksAs) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_gcbbf = 0
	case "span":
		*_gcbbf = 1
	case "gap":
		*_gcbbf = 2
	case "zero":
		*_gcbbf = 3
	}
	return nil
}
func (_beeg *CT_AxDataSource) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_beeg.Choice.MarshalXML(e, _fa.StartElement{})
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Double and its children, prefixing error messages with path
func (_becd *CT_Double) ValidateWithPath(path string) error { return nil }

const (
	ST_SplitTypeUnset   ST_SplitType = 0
	ST_SplitTypeAuto    ST_SplitType = 1
	ST_SplitTypeCust    ST_SplitType = 2
	ST_SplitTypePercent ST_SplitType = 3
	ST_SplitTypePos     ST_SplitType = 4
	ST_SplitTypeVal     ST_SplitType = 5
)

func (_ddccb *CT_PieChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_cfacc:
	for {
		_bbfc, _fgec := d.Token()
		if _fgec != nil {
			return _fgec
		}
		switch _gbbf := _bbfc.(type) {
		case _fa.StartElement:
			switch _gbbf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_ddccb.VaryColors = NewCT_Boolean()
				if _eaaed := d.DecodeElement(_ddccb.VaryColors, &_gbbf); _eaaed != nil {
					return _eaaed
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_baddb := NewCT_PieSer()
				if _bcgaf := d.DecodeElement(_baddb, &_gbbf); _bcgaf != nil {
					return _bcgaf
				}
				_ddccb.Ser = append(_ddccb.Ser, _baddb)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_ddccb.DLbls = NewCT_DLbls()
				if _agbf := d.DecodeElement(_ddccb.DLbls, &_gbbf); _agbf != nil {
					return _agbf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "firstSliceAng"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "firstSliceAng"}:
				_ddccb.FirstSliceAng = NewCT_FirstSliceAng()
				if _gbgab := d.DecodeElement(_ddccb.FirstSliceAng, &_gbbf); _gbgab != nil {
					return _gbgab
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_ddccb.ExtLst = NewCT_ExtensionList()
				if _bbfd := d.DecodeElement(_ddccb.ExtLst, &_gbbf); _bbfd != nil {
					return _bbfd
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PieChart\u0020\u0025v", _gbbf.Name)
				if _aabaf := d.Skip(); _aabaf != nil {
					return _aabaf
				}
			}
		case _fa.EndElement:
			break _cfacc
		case _fa.CharData:
		}
	}
	return nil
}
func (_edbbc ST_GapAmount) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _edbbc.ST_GapAmountPercent != nil {
		e.EncodeToken(_fa.CharData(*_edbbc.ST_GapAmountPercent))
	}
	if _edbbc.ST_GapAmountUShort != nil {
		e.EncodeToken(_fa.CharData(_gg.Sprintf("\u0025d", *_edbbc.ST_GapAmountUShort)))
	}
	return e.EncodeToken(_fa.EndElement{Name: start.Name})
}

const ST_BubbleScalePercentPattern = "0\u002a\u0028\u0028\u005b0\u002d9\u005d\u0029|\u0028\u005b1\u002d9\u005d\u005b0-9\u005d\u0029\u007c(\u005b1\u002d2\u005d\u005b0\u002d9][0\u002d9\u005d\u0029\u007c300\u0029\u0025"

func (_afgeg *ST_Orientation) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_afgeg = 0
	case "maxMin":
		*_afgeg = 1
	case "minMax":
		*_afgeg = 2
	}
	return nil
}

// ValidateWithPath validates the CT_LayoutMode and its children, prefixing error messages with path
func (_fdfc *CT_LayoutMode) ValidateWithPath(path string) error {
	if _abbea := _fdfc.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _abbea != nil {
		return _abbea
	}
	return nil
}
func (_bgcbe ST_Thickness) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _bgcbe.ST_ThicknessPercent != nil {
		e.EncodeToken(_fa.CharData(*_bgcbe.ST_ThicknessPercent))
	}
	if _bgcbe.Uint32 != nil {
		e.EncodeToken(_fa.CharData(_gg.Sprintf("\u0025d", *_bgcbe.Uint32)))
	}
	return e.EncodeToken(_fa.EndElement{Name: start.Name})
}

// ValidateWithPath validates the CT_Chart and its children, prefixing error messages with path
func (_bgd *CT_Chart) ValidateWithPath(path string) error {
	if _bgd.Title != nil {
		if _ebgge := _bgd.Title.ValidateWithPath(path + "\u002fTitle"); _ebgge != nil {
			return _ebgge
		}
	}
	if _bgd.AutoTitleDeleted != nil {
		if _effg := _bgd.AutoTitleDeleted.ValidateWithPath(path + "\u002fAutoTitleDeleted"); _effg != nil {
			return _effg
		}
	}
	if _bgd.PivotFmts != nil {
		if _afba := _bgd.PivotFmts.ValidateWithPath(path + "\u002fPivotFmts"); _afba != nil {
			return _afba
		}
	}
	if _bgd.View3D != nil {
		if _aaea := _bgd.View3D.ValidateWithPath(path + "\u002fView3D"); _aaea != nil {
			return _aaea
		}
	}
	if _bgd.Floor != nil {
		if _efeg := _bgd.Floor.ValidateWithPath(path + "\u002fFloor"); _efeg != nil {
			return _efeg
		}
	}
	if _bgd.SideWall != nil {
		if _fccc := _bgd.SideWall.ValidateWithPath(path + "\u002fSideWall"); _fccc != nil {
			return _fccc
		}
	}
	if _bgd.BackWall != nil {
		if _cdc := _bgd.BackWall.ValidateWithPath(path + "\u002fBackWall"); _cdc != nil {
			return _cdc
		}
	}
	if _ffef := _bgd.PlotArea.ValidateWithPath(path + "\u002fPlotArea"); _ffef != nil {
		return _ffef
	}
	if _bgd.Legend != nil {
		if _agfg := _bgd.Legend.ValidateWithPath(path + "\u002fLegend"); _agfg != nil {
			return _agfg
		}
	}
	if _bgd.PlotVisOnly != nil {
		if _gffcd := _bgd.PlotVisOnly.ValidateWithPath(path + "\u002fPlotVisOnly"); _gffcd != nil {
			return _gffcd
		}
	}
	if _bgd.DispBlanksAs != nil {
		if _abee := _bgd.DispBlanksAs.ValidateWithPath(path + "\u002fDispBlanksAs"); _abee != nil {
			return _abee
		}
	}
	if _bgd.ShowDLblsOverMax != nil {
		if _fdb := _bgd.ShowDLblsOverMax.ValidateWithPath(path + "\u002fShowDLblsOverMax"); _fdb != nil {
			return _fdb
		}
	}
	if _bgd.ExtLst != nil {
		if _bgce := _bgd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bgce != nil {
			return _bgce
		}
	}
	return nil
}
func NewCT_MarkerSize() *CT_MarkerSize { _afdd := &CT_MarkerSize{}; return _afdd }

const (
	ST_TickMarkUnset ST_TickMark = 0
	ST_TickMarkCross ST_TickMark = 1
	ST_TickMarkIn    ST_TickMark = 2
	ST_TickMarkNone  ST_TickMark = 3
	ST_TickMarkOut   ST_TickMark = 4
)

// Validate validates the CT_LayoutTarget and its children
func (_decd *CT_LayoutTarget) Validate() error { return _decd.ValidateWithPath("CT_LayoutTarget") }

// ValidateWithPath validates the CT_Perspective and its children, prefixing error messages with path
func (_gddg *CT_Perspective) ValidateWithPath(path string) error {
	if _gddg.ValAttr != nil {
		if *_gddg.ValAttr < 0 {
			return _gg.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_gddg.ValAttr)
		}
		if *_gddg.ValAttr > 240 {
			return _gg.Errorf("\u0025s/m\u002eValAttr\u0020must\u0020be\u0020\u003c\u003d\u0020240\u0020\u0028have\u0020\u0025v\u0029", path, *_gddg.ValAttr)
		}
	}
	return nil
}
func (_afbg *CT_MarkerSize) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _afbg.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_afbg.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_PageMargins() *CT_PageMargins { _bffba := &CT_PageMargins{}; return _bffba }
func (_acbdg *CT_LegendPos) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _cafb := range start.Attr {
		if _cafb.Name.Local == "val" {
			_acbdg.ValAttr.UnmarshalXMLAttr(_cafb)
			continue
		}
	}
	for {
		_gefe, _bfeb := d.Token()
		if _bfeb != nil {
			return _gg.Errorf("parsing\u0020CT_LegendPos:\u0020\u0025s", _bfeb)
		}
		if _egda, _gdcg := _gefe.(_fa.EndElement); _gdcg && _egda.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cefggg ST_SizeRepresents) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_cefggg.String(), start)
}
func (_gacc *CT_CrossBetween) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_fegg, _dddb := _gacc.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
	if _dddb != nil {
		return _dddb
	}
	start.Attr = append(start.Attr, _fegg)
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_LegendPos and its children, prefixing error messages with path
func (_dccd *CT_LegendPos) ValidateWithPath(path string) error {
	if _fgcg := _dccd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _fgcg != nil {
		return _fgcg
	}
	return nil
}
func (_bdfd *CT_Surface3DChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _bdfd.Wireframe != nil {
		_cgffb := _fa.StartElement{Name: _fa.Name{Local: "c:wireframe"}}
		e.EncodeElement(_bdfd.Wireframe, _cgffb)
	}
	if _bdfd.Ser != nil {
		_ddce := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _acage := range _bdfd.Ser {
			e.EncodeElement(_acage, _ddce)
		}
	}
	if _bdfd.BandFmts != nil {
		_afcedb := _fa.StartElement{Name: _fa.Name{Local: "c:bandFmts"}}
		e.EncodeElement(_bdfd.BandFmts, _afcedb)
	}
	_fefeb := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _bbdcc := range _bdfd.AxId {
		e.EncodeElement(_bbdcc, _fefeb)
	}
	if _bdfd.ExtLst != nil {
		_cgecb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_bdfd.ExtLst, _cgecb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_PlotAreaChoice struct {
	AreaChart      *CT_AreaChart
	Area3DChart    *CT_Area3DChart
	LineChart      *CT_LineChart
	Line3DChart    *CT_Line3DChart
	StockChart     *CT_StockChart
	RadarChart     *CT_RadarChart
	ScatterChart   *CT_ScatterChart
	PieChart       *CT_PieChart
	Pie3DChart     *CT_Pie3DChart
	DoughnutChart  *CT_DoughnutChart
	BarChart       *CT_BarChart
	Bar3DChart     *CT_Bar3DChart
	OfPieChart     *CT_OfPieChart
	SurfaceChart   *CT_SurfaceChart
	Surface3DChart *CT_Surface3DChart
	BubbleChart    *CT_BubbleChart
}

// ValidateWithPath validates the CT_BubbleChart and its children, prefixing error messages with path
func (_ffd *CT_BubbleChart) ValidateWithPath(path string) error {
	if _ffd.VaryColors != nil {
		if _ecdf := _ffd.VaryColors.ValidateWithPath(path + "/VaryColors"); _ecdf != nil {
			return _ecdf
		}
	}
	for _gadg, _aagd := range _ffd.Ser {
		if _ddgf := _aagd.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _gadg)); _ddgf != nil {
			return _ddgf
		}
	}
	if _ffd.DLbls != nil {
		if _bacf := _ffd.DLbls.ValidateWithPath(path + "\u002fDLbls"); _bacf != nil {
			return _bacf
		}
	}
	if _ffd.Bubble3D != nil {
		if _fega := _ffd.Bubble3D.ValidateWithPath(path + "\u002fBubble3D"); _fega != nil {
			return _fega
		}
	}
	if _ffd.BubbleScale != nil {
		if _fgff := _ffd.BubbleScale.ValidateWithPath(path + "\u002fBubbleScale"); _fgff != nil {
			return _fgff
		}
	}
	if _ffd.ShowNegBubbles != nil {
		if _dfa := _ffd.ShowNegBubbles.ValidateWithPath(path + "\u002fShowNegBubbles"); _dfa != nil {
			return _dfa
		}
	}
	if _ffd.SizeRepresents != nil {
		if _cedb := _ffd.SizeRepresents.ValidateWithPath(path + "\u002fSizeRepresents"); _cedb != nil {
			return _cedb
		}
	}
	for _fccg, _ged := range _ffd.AxId {
		if _gdbf := _ged.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _fccg)); _gdbf != nil {
			return _gdbf
		}
	}
	if _ffd.ExtLst != nil {
		if _bdc := _ffd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bdc != nil {
			return _bdc
		}
	}
	return nil
}
func ParseUnionST_HoleSize(s string) (ST_HoleSize, error) {
	if ST_HoleSizePercentPatternRe.MatchString(s) {
		return ST_HoleSize{ST_HoleSizePercent: &s}, nil
	}
	_fgaea, _affdba := _c.ParseUint(s, 10, 8)
	if _affdba != nil {
		return ST_HoleSize{}, _affdba
	}
	_bacdab := uint8(_fgaea)
	return ST_HoleSize{ST_HoleSizeUByte: &_bacdab}, nil
}
func (_bfaecd *ChartSpace) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:c"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "c:chartSpace"
	return _bfaecd.CT_ChartSpace.MarshalXML(e, start)
}
func (_geff ST_SizeRepresents) Validate() error { return _geff.ValidateWithPath("") }

type EG_LegendEntryData struct{ TxPr *_cb.CT_TextBody }
type CT_PivotFmts struct{ PivotFmt []*CT_PivotFmt }

// ValidateWithPath validates the CT_NumFmt and its children, prefixing error messages with path
func (_bgbf *CT_NumFmt) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_Overlap and its children
func (_cbcg *CT_Overlap) Validate() error { return _cbcg.ValidateWithPath("CT_Overlap") }
func (_fbbg ST_ErrValType) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_fdfg := _fa.Attr{}
	_fdfg.Name = name
	switch _fbbg {
	case ST_ErrValTypeUnset:
		_fdfg.Value = ""
	case ST_ErrValTypeCust:
		_fdfg.Value = "cust"
	case ST_ErrValTypeFixedVal:
		_fdfg.Value = "fixedVal"
	case ST_ErrValTypePercentage:
		_fdfg.Value = "percentage"
	case ST_ErrValTypeStdDev:
		_fdfg.Value = "stdDev"
	case ST_ErrValTypeStdErr:
		_fdfg.Value = "stdErr"
	}
	return _fdfg, nil
}

// Validate validates the CT_Area3DChart and its children
func (_ec *CT_Area3DChart) Validate() error { return _ec.ValidateWithPath("CT_Area3DChart") }

// ValidateWithPath validates the CT_DTable and its children, prefixing error messages with path
func (_feegb *CT_DTable) ValidateWithPath(path string) error {
	if _feegb.ShowHorzBorder != nil {
		if _eged := _feegb.ShowHorzBorder.ValidateWithPath(path + "\u002fShowHorzBorder"); _eged != nil {
			return _eged
		}
	}
	if _feegb.ShowVertBorder != nil {
		if _efea := _feegb.ShowVertBorder.ValidateWithPath(path + "\u002fShowVertBorder"); _efea != nil {
			return _efea
		}
	}
	if _feegb.ShowOutline != nil {
		if _fbdg := _feegb.ShowOutline.ValidateWithPath(path + "\u002fShowOutline"); _fbdg != nil {
			return _fbdg
		}
	}
	if _feegb.ShowKeys != nil {
		if _cacc := _feegb.ShowKeys.ValidateWithPath(path + "\u002fShowKeys"); _cacc != nil {
			return _cacc
		}
	}
	if _feegb.SpPr != nil {
		if _eaee := _feegb.SpPr.ValidateWithPath(path + "\u002fSpPr"); _eaee != nil {
			return _eaee
		}
	}
	if _feegb.TxPr != nil {
		if _bgbdc := _feegb.TxPr.ValidateWithPath(path + "\u002fTxPr"); _bgbdc != nil {
			return _bgbdc
		}
	}
	if _feegb.ExtLst != nil {
		if _fdcce := _feegb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fdcce != nil {
			return _fdcce
		}
	}
	return nil
}

// ValidateWithPath validates the EG_DLblShared and its children, prefixing error messages with path
func (_eedec *EG_DLblShared) ValidateWithPath(path string) error {
	if _eedec.NumFmt != nil {
		if _dgfbc := _eedec.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _dgfbc != nil {
			return _dgfbc
		}
	}
	if _eedec.SpPr != nil {
		if _cgegg := _eedec.SpPr.ValidateWithPath(path + "\u002fSpPr"); _cgegg != nil {
			return _cgegg
		}
	}
	if _eedec.TxPr != nil {
		if _fecb := _eedec.TxPr.ValidateWithPath(path + "\u002fTxPr"); _fecb != nil {
			return _fecb
		}
	}
	if _eedec.DLblPos != nil {
		if _feccb := _eedec.DLblPos.ValidateWithPath(path + "\u002fDLblPos"); _feccb != nil {
			return _feccb
		}
	}
	if _eedec.ShowLegendKey != nil {
		if _efeef := _eedec.ShowLegendKey.ValidateWithPath(path + "\u002fShowLegendKey"); _efeef != nil {
			return _efeef
		}
	}
	if _eedec.ShowVal != nil {
		if _ebdb := _eedec.ShowVal.ValidateWithPath(path + "\u002fShowVal"); _ebdb != nil {
			return _ebdb
		}
	}
	if _eedec.ShowCatName != nil {
		if _faeac := _eedec.ShowCatName.ValidateWithPath(path + "\u002fShowCatName"); _faeac != nil {
			return _faeac
		}
	}
	if _eedec.ShowSerName != nil {
		if _caffd := _eedec.ShowSerName.ValidateWithPath(path + "\u002fShowSerName"); _caffd != nil {
			return _caffd
		}
	}
	if _eedec.ShowPercent != nil {
		if _cfbfc := _eedec.ShowPercent.ValidateWithPath(path + "\u002fShowPercent"); _cfbfc != nil {
			return _cfbfc
		}
	}
	if _eedec.ShowBubbleSize != nil {
		if _bdaafg := _eedec.ShowBubbleSize.ValidateWithPath(path + "\u002fShowBubbleSize"); _bdaafg != nil {
			return _bdaafg
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Thickness and its children, prefixing error messages with path
func (_dcgbd *CT_Thickness) ValidateWithPath(path string) error {
	if _egcff := _dcgbd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _egcff != nil {
		return _egcff
	}
	return nil
}

// Validate validates the EG_SurfaceChartShared and its children
func (_bfegd *EG_SurfaceChartShared) Validate() error {
	return _bfegd.ValidateWithPath("EG_SurfaceChartShared")
}
func (_gaea *CT_TxChoice) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _gaea.StrRef != nil {
		_gbadf := _fa.StartElement{Name: _fa.Name{Local: "c:strRef"}}
		e.EncodeElement(_gaea.StrRef, _gbadf)
	}
	if _gaea.Rich != nil {
		_dcebf := _fa.StartElement{Name: _fa.Name{Local: "c:rich"}}
		e.EncodeElement(_gaea.Rich, _dcebf)
	}
	return nil
}
func NewCT_Style() *CT_Style                  { _fgagd := &CT_Style{}; _fgagd.ValAttr = 1; return _fgagd }
func (_dcfe ST_ScatterStyle) Validate() error { return _dcfe.ValidateWithPath("") }
func (_gccga *CT_StrRef) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_ddad:
	for {
		_afdfaf, _edba := d.Token()
		if _edba != nil {
			return _edba
		}
		switch _fcabad := _afdfaf.(type) {
		case _fa.StartElement:
			switch _fcabad.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "f"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "f"}:
				if _feag := d.DecodeElement(&_gccga.F, &_fcabad); _feag != nil {
					return _feag
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "strCache"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "strCache"}:
				_gccga.StrCache = NewCT_StrData()
				if _fbedd := d.DecodeElement(_gccga.StrCache, &_fcabad); _fbedd != nil {
					return _fbedd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_gccga.ExtLst = NewCT_ExtensionList()
				if _efbab := d.DecodeElement(_gccga.ExtLst, &_fcabad); _efbab != nil {
					return _efbab
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_StrRef \u0025v", _fcabad.Name)
				if _ggga := d.Skip(); _ggga != nil {
					return _ggga
				}
			}
		case _fa.EndElement:
			break _ddad
		case _fa.CharData:
		}
	}
	return nil
}
func NewCT_Grouping() *CT_Grouping { _edabd := &CT_Grouping{}; return _edabd }

type ST_Grouping byte

func (_ggbc ST_LayoutTarget) Validate() error { return _ggbc.ValidateWithPath("") }
func (_fcaf *CT_ChartLines) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _fcaf.SpPr != nil {
		_eecdg := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_fcaf.SpPr, _eecdg)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_ccggg ST_PageSetupOrientation) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_ccggg.String(), start)
}
func (_cabb *CT_Tx) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cabb.Choice.MarshalXML(e, _fa.StartElement{})
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_BandFmt struct {
	Idx  *CT_UnsignedInt
	SpPr *_cb.CT_ShapeProperties
}

func (_bgbdbd ST_MarkerStyle) ValidateWithPath(path string) error {
	switch _bgbdbd {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bgbdbd))
	}
	return nil
}
func (_caac *CT_Boolean) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _abgc := range start.Attr {
		if _abgc.Name.Local == "val" {
			_dgdf, _egeb := _c.ParseBool(_abgc.Value)
			if _egeb != nil {
				return _egeb
			}
			_caac.ValAttr = &_dgdf
			continue
		}
	}
	for {
		_efcc, _dbd := d.Token()
		if _dbd != nil {
			return _gg.Errorf("parsing\u0020CT_Boolean:\u0020%s", _dbd)
		}
		if _ffaec, _aac := _efcc.(_fa.EndElement); _aac && _ffaec.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dabgc ST_PageSetupOrientation) ValidateWithPath(path string) error {
	switch _dabgc {
	case 0, 1, 2, 3:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dabgc))
	}
	return nil
}

type CT_Period struct{ ValAttr *uint32 }

func (_ecfde ST_ScatterStyle) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_dbgb := _fa.Attr{}
	_dbgb.Name = name
	switch _ecfde {
	case ST_ScatterStyleUnset:
		_dbgb.Value = ""
	case ST_ScatterStyleNone:
		_dbgb.Value = "none"
	case ST_ScatterStyleLine:
		_dbgb.Value = "line"
	case ST_ScatterStyleLineMarker:
		_dbgb.Value = "lineMarker"
	case ST_ScatterStyleMarker:
		_dbgb.Value = "marker"
	case ST_ScatterStyleSmooth:
		_dbgb.Value = "smooth"
	case ST_ScatterStyleSmoothMarker:
		_dbgb.Value = "smoothMarker"
	}
	return _dbgb, nil
}

type CT_View3D struct {
	RotX         *CT_RotX
	HPercent     *CT_HPercent
	RotY         *CT_RotY
	DepthPercent *CT_DepthPercent
	RAngAx       *CT_Boolean
	Perspective  *CT_Perspective
	ExtLst       *CT_ExtensionList
}

func (_be *CT_Area3DChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _be.Grouping != nil {
		_cg := _fa.StartElement{Name: _fa.Name{Local: "c:grouping"}}
		e.EncodeElement(_be.Grouping, _cg)
	}
	if _be.VaryColors != nil {
		_gf := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_be.VaryColors, _gf)
	}
	if _be.Ser != nil {
		_gc := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _ee := range _be.Ser {
			e.EncodeElement(_ee, _gc)
		}
	}
	if _be.DLbls != nil {
		_fg := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_be.DLbls, _fg)
	}
	if _be.DropLines != nil {
		_gga := _fa.StartElement{Name: _fa.Name{Local: "c:dropLines"}}
		e.EncodeElement(_be.DropLines, _gga)
	}
	if _be.GapDepth != nil {
		_fc := _fa.StartElement{Name: _fa.Name{Local: "c:gapDepth"}}
		e.EncodeElement(_be.GapDepth, _fc)
	}
	_bb := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _bc := range _be.AxId {
		e.EncodeElement(_bc, _bb)
	}
	if _be.ExtLst != nil {
		_d := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_be.ExtLst, _d)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Perspective and its children
func (_bdgfb *CT_Perspective) Validate() error { return _bdgfb.ValidateWithPath("CT_Perspective") }

// ValidateWithPath validates the CT_Title and its children, prefixing error messages with path
func (_ccgg *CT_Title) ValidateWithPath(path string) error {
	if _ccgg.Tx != nil {
		if _dbda := _ccgg.Tx.ValidateWithPath(path + "\u002fTx"); _dbda != nil {
			return _dbda
		}
	}
	if _ccgg.Layout != nil {
		if _gcecc := _ccgg.Layout.ValidateWithPath(path + "\u002fLayout"); _gcecc != nil {
			return _gcecc
		}
	}
	if _ccgg.Overlay != nil {
		if _ffgd := _ccgg.Overlay.ValidateWithPath(path + "\u002fOverlay"); _ffgd != nil {
			return _ffgd
		}
	}
	if _ccgg.SpPr != nil {
		if _bcceb := _ccgg.SpPr.ValidateWithPath(path + "\u002fSpPr"); _bcceb != nil {
			return _bcceb
		}
	}
	if _ccgg.TxPr != nil {
		if _gegg := _ccgg.TxPr.ValidateWithPath(path + "\u002fTxPr"); _gegg != nil {
			return _gegg
		}
	}
	if _ccgg.ExtLst != nil {
		if _gacbc := _ccgg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gacbc != nil {
			return _gacbc
		}
	}
	return nil
}
func (_eebddb *CT_Order) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _eebddb.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_eebddb.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_LineSer() *CT_LineSer {
	_cfegf := &CT_LineSer{}
	_cfegf.Idx = NewCT_UnsignedInt()
	_cfegf.Order = NewCT_UnsignedInt()
	return _cfegf
}

// Validate validates the UserShapes and its children
func (_aagcc *UserShapes) Validate() error { return _aagcc.ValidateWithPath("UserShapes") }

// ValidateWithPath validates the CT_Lvl and its children, prefixing error messages with path
func (_cgdcf *CT_Lvl) ValidateWithPath(path string) error {
	for _bfcac, _cbeeb := range _cgdcf.Pt {
		if _gbfcg := _cbeeb.ValidateWithPath(_gg.Sprintf("\u0025s\u002fPt\u005b\u0025d]", path, _bfcac)); _gbfcg != nil {
			return _gbfcg
		}
	}
	return nil
}

type CT_TextLanguageID struct{ ValAttr string }

func NewCT_StrRef() *CT_StrRef { _bebaa := &CT_StrRef{}; return _bebaa }
func (_bfegb ST_ErrBarType) String() string {
	switch _bfegb {
	case 0:
		return ""
	case 1:
		return "both"
	case 2:
		return "minus"
	case 3:
		return "plus"
	}
	return ""
}

// ValidateWithPath validates the CT_SurfaceChart and its children, prefixing error messages with path
func (_bdbe *CT_SurfaceChart) ValidateWithPath(path string) error {
	if _bdbe.Wireframe != nil {
		if _cgece := _bdbe.Wireframe.ValidateWithPath(path + "\u002fWireframe"); _cgece != nil {
			return _cgece
		}
	}
	for _agbdb, _bbdgf := range _bdbe.Ser {
		if _egdae := _bbdgf.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _agbdb)); _egdae != nil {
			return _egdae
		}
	}
	if _bdbe.BandFmts != nil {
		if _fgad := _bdbe.BandFmts.ValidateWithPath(path + "\u002fBandFmts"); _fgad != nil {
			return _fgad
		}
	}
	for _daccc, _acegag := range _bdbe.AxId {
		if _gdccf := _acegag.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _daccc)); _gdccf != nil {
			return _gdccf
		}
	}
	if _bdbe.ExtLst != nil {
		if _bggge := _bdbe.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bggge != nil {
			return _bggge
		}
	}
	return nil
}
func NewCT_BandFmts() *CT_BandFmts { _fbfc := &CT_BandFmts{}; return _fbfc }

type CT_AreaChart struct {
	Grouping   *CT_Grouping
	VaryColors *CT_Boolean
	Ser        []*CT_AreaSer
	DLbls      *CT_DLbls
	DropLines  *CT_ChartLines
	AxId       []*CT_UnsignedInt
	ExtLst     *CT_ExtensionList
}
type ChartSpace struct{ CT_ChartSpace }

// ValidateWithPath validates the CT_SerTx and its children, prefixing error messages with path
func (_dbdbge *CT_SerTx) ValidateWithPath(path string) error {
	if _ddcde := _dbdbge.Choice.ValidateWithPath(path + "\u002fChoice"); _ddcde != nil {
		return _ddcde
	}
	return nil
}

// ValidateWithPath validates the CT_BarSer and its children, prefixing error messages with path
func (_cffa *CT_BarSer) ValidateWithPath(path string) error {
	if _bfc := _cffa.Idx.ValidateWithPath(path + "\u002fIdx"); _bfc != nil {
		return _bfc
	}
	if _dbabd := _cffa.Order.ValidateWithPath(path + "\u002fOrder"); _dbabd != nil {
		return _dbabd
	}
	if _cffa.Tx != nil {
		if _bgc := _cffa.Tx.ValidateWithPath(path + "\u002fTx"); _bgc != nil {
			return _bgc
		}
	}
	if _cffa.SpPr != nil {
		if _gbaa := _cffa.SpPr.ValidateWithPath(path + "\u002fSpPr"); _gbaa != nil {
			return _gbaa
		}
	}
	if _cffa.InvertIfNegative != nil {
		if _ebe := _cffa.InvertIfNegative.ValidateWithPath(path + "\u002fInvertIfNegative"); _ebe != nil {
			return _ebe
		}
	}
	if _cffa.PictureOptions != nil {
		if _dacg := _cffa.PictureOptions.ValidateWithPath(path + "\u002fPictureOptions"); _dacg != nil {
			return _dacg
		}
	}
	for _bdef, _cadg := range _cffa.DPt {
		if _bgbd := _cadg.ValidateWithPath(_gg.Sprintf("\u0025s\u002fDPt\u005b\u0025d\u005d", path, _bdef)); _bgbd != nil {
			return _bgbd
		}
	}
	if _cffa.DLbls != nil {
		if _fff := _cffa.DLbls.ValidateWithPath(path + "\u002fDLbls"); _fff != nil {
			return _fff
		}
	}
	for _gaa, _ggfd := range _cffa.Trendline {
		if _dfc := _ggfd.ValidateWithPath(_gg.Sprintf("\u0025s/Trendline\u005b\u0025d\u005d", path, _gaa)); _dfc != nil {
			return _dfc
		}
	}
	if _cffa.ErrBars != nil {
		if _gde := _cffa.ErrBars.ValidateWithPath(path + "\u002fErrBars"); _gde != nil {
			return _gde
		}
	}
	if _cffa.Cat != nil {
		if _dgf := _cffa.Cat.ValidateWithPath(path + "\u002fCat"); _dgf != nil {
			return _dgf
		}
	}
	if _cffa.Val != nil {
		if _fdaf := _cffa.Val.ValidateWithPath(path + "\u002fVal"); _fdaf != nil {
			return _fdaf
		}
	}
	if _cffa.Shape != nil {
		if _ggb := _cffa.Shape.ValidateWithPath(path + "\u002fShape"); _ggb != nil {
			return _ggb
		}
	}
	if _cffa.ExtLst != nil {
		if _dafg := _cffa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dafg != nil {
			return _dafg
		}
	}
	return nil
}

type CT_ErrDir struct{ ValAttr ST_ErrDir }

// ValidateWithPath validates the CT_MultiLvlStrData and its children, prefixing error messages with path
func (_dcde *CT_MultiLvlStrData) ValidateWithPath(path string) error {
	if _dcde.PtCount != nil {
		if _ddfgd := _dcde.PtCount.ValidateWithPath(path + "\u002fPtCount"); _ddfgd != nil {
			return _ddfgd
		}
	}
	for _ffcf, _dedgg := range _dcde.Lvl {
		if _bfacc := _dedgg.ValidateWithPath(_gg.Sprintf("\u0025s\u002fLvl\u005b\u0025d\u005d", path, _ffcf)); _bfacc != nil {
			return _bfacc
		}
	}
	if _dcde.ExtLst != nil {
		if _dcfgf := _dcde.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dcfgf != nil {
			return _dcfgf
		}
	}
	return nil
}
func ParseUnionST_BubbleScale(s string) (ST_BubbleScale, error) {
	if ST_BubbleScalePercentPatternRe.MatchString(s) {
		return ST_BubbleScale{ST_BubbleScalePercent: &s}, nil
	}
	_gcbe, _feeaf := _c.ParseUint(s, 10, 32)
	if _feeaf != nil {
		return ST_BubbleScale{}, _feeaf
	}
	_ddbea := uint32(_gcbe)
	return ST_BubbleScale{ST_BubbleScaleUInt: &_ddbea}, nil
}

const (
	ST_PictureFormatUnset      ST_PictureFormat = 0
	ST_PictureFormatStretch    ST_PictureFormat = 1
	ST_PictureFormatStack      ST_PictureFormat = 2
	ST_PictureFormatStackScale ST_PictureFormat = 3
)

func (_bg *CT_AxDataSource) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bg.Choice = NewCT_AxDataSourceChoice()
_ecgc:
	for {
		_fgf, _cad := d.Token()
		if _cad != nil {
			return _cad
		}
		switch _eeda := _fgf.(type) {
		case _fa.StartElement:
			switch _eeda.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "multiLvlStrRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "multiLvlStrRef"}:
				_bg.Choice = NewCT_AxDataSourceChoice()
				if _fbg := d.DecodeElement(&_bg.Choice.MultiLvlStrRef, &_eeda); _fbg != nil {
					return _fbg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numRef"}:
				_bg.Choice = NewCT_AxDataSourceChoice()
				if _gcg := d.DecodeElement(&_bg.Choice.NumRef, &_eeda); _gcg != nil {
					return _gcg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numLit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numLit"}:
				_bg.Choice = NewCT_AxDataSourceChoice()
				if _dgb := d.DecodeElement(&_bg.Choice.NumLit, &_eeda); _dgb != nil {
					return _dgb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "strRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "strRef"}:
				_bg.Choice = NewCT_AxDataSourceChoice()
				if _fbb := d.DecodeElement(&_bg.Choice.StrRef, &_eeda); _fbb != nil {
					return _fbb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "strLit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "strLit"}:
				_bg.Choice = NewCT_AxDataSourceChoice()
				if _eae := d.DecodeElement(&_bg.Choice.StrLit, &_eeda); _eae != nil {
					return _eae
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_AxDataSource\u0020\u0025v", _eeda.Name)
				if _ffg := d.Skip(); _ffg != nil {
					return _ffg
				}
			}
		case _fa.EndElement:
			break _ecgc
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_BandFmts and its children, prefixing error messages with path
func (_debd *CT_BandFmts) ValidateWithPath(path string) error {
	for _gba, _egff := range _debd.BandFmt {
		if _bdf := _egff.ValidateWithPath(_gg.Sprintf("\u0025s\u002fBandFmt\u005b\u0025d\u005d", path, _gba)); _bdf != nil {
			return _bdf
		}
	}
	return nil
}
func (_abaed *ST_CrossBetween) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_agffb, _gegbe := d.Token()
	if _gegbe != nil {
		return _gegbe
	}
	if _cffbf, _fggab := _agffb.(_fa.EndElement); _fggab && _cffbf.Name == start.Name {
		*_abaed = 1
		return nil
	}
	if _fbgca, _gfdab := _agffb.(_fa.CharData); !_gfdab {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _agffb)
	} else {
		switch string(_fbgca) {
		case "":
			*_abaed = 0
		case "between":
			*_abaed = 1
		case "midCat":
			*_abaed = 2
		}
	}
	_agffb, _gegbe = d.Token()
	if _gegbe != nil {
		return _gegbe
	}
	if _cagee, _becg := _agffb.(_fa.EndElement); _becg && _cagee.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _agffb)
}
func (_fabcc *CT_PlotAreaChoice1) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_cefbcd:
	for {
		_babg, _baga := d.Token()
		if _baga != nil {
			return _baga
		}
		switch _agffg := _babg.(type) {
		case _fa.StartElement:
			switch _agffg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "valAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "valAx"}:
				_dbcg := NewCT_ValAx()
				if _ccgdce := d.DecodeElement(_dbcg, &_agffg); _ccgdce != nil {
					return _ccgdce
				}
				_fabcc.ValAx = append(_fabcc.ValAx, _dbcg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "catAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "catAx"}:
				_cdgg := NewCT_CatAx()
				if _cecfa := d.DecodeElement(_cdgg, &_agffg); _cecfa != nil {
					return _cecfa
				}
				_fabcc.CatAx = append(_fabcc.CatAx, _cdgg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dateAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dateAx"}:
				_dbff := NewCT_DateAx()
				if _ecega := d.DecodeElement(_dbff, &_agffg); _ecega != nil {
					return _ecega
				}
				_fabcc.DateAx = append(_fabcc.DateAx, _dbff)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "serAx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "serAx"}:
				_gdbfg := NewCT_SerAx()
				if _adae := d.DecodeElement(_gdbfg, &_agffg); _adae != nil {
					return _adae
				}
				_fabcc.SerAx = append(_fabcc.SerAx, _gdbfg)
			default:
				_b.Log("skipping\u0020unsupported element\u0020on\u0020CT_PlotAreaChoice1\u0020\u0025v", _agffg.Name)
				if _ggab := d.Skip(); _ggab != nil {
					return _ggab
				}
			}
		case _fa.EndElement:
			break _cefbcd
		case _fa.CharData:
		}
	}
	return nil
}
func (_febbc ST_Crosses) String() string {
	switch _febbc {
	case 0:
		return ""
	case 1:
		return "autoZero"
	case 2:
		return "max"
	case 3:
		return "min"
	}
	return ""
}
func (_bafd ST_BubbleScale) String() string {
	if _bafd.ST_BubbleScalePercent != nil {
		return _gg.Sprintf("\u0025v", *_bafd.ST_BubbleScalePercent)
	}
	if _bafd.ST_BubbleScaleUInt != nil {
		return _gg.Sprintf("\u0025v", *_bafd.ST_BubbleScaleUInt)
	}
	return ""
}

type CT_DispUnitsLbl struct {
	Layout *CT_Layout
	Tx     *CT_Tx
	SpPr   *_cb.CT_ShapeProperties
	TxPr   *_cb.CT_TextBody
}

// ValidateWithPath validates the CT_PivotFmts and its children, prefixing error messages with path
func (_afaf *CT_PivotFmts) ValidateWithPath(path string) error {
	for _efac, _bfdg := range _afaf.PivotFmt {
		if _gaca := _bfdg.ValidateWithPath(_gg.Sprintf("\u0025s\u002fPivotFmt\u005b\u0025d\u005d", path, _efac)); _gaca != nil {
			return _gaca
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PrintSettings and its children, prefixing error messages with path
func (_acbea *CT_PrintSettings) ValidateWithPath(path string) error {
	if _acbea.HeaderFooter != nil {
		if _fgge := _acbea.HeaderFooter.ValidateWithPath(path + "\u002fHeaderFooter"); _fgge != nil {
			return _fgge
		}
	}
	if _acbea.PageMargins != nil {
		if _eddaa := _acbea.PageMargins.ValidateWithPath(path + "\u002fPageMargins"); _eddaa != nil {
			return _eddaa
		}
	}
	if _acbea.PageSetup != nil {
		if _gfdf := _acbea.PageSetup.ValidateWithPath(path + "\u002fPageSetup"); _gfdf != nil {
			return _gfdf
		}
	}
	if _acbea.LegacyDrawingHF != nil {
		if _fbeff := _acbea.LegacyDrawingHF.ValidateWithPath(path + "\u002fLegacyDrawingHF"); _fbeff != nil {
			return _fbeff
		}
	}
	return nil
}
func (_fcge ST_BuiltInUnit) Validate() error { return _fcge.ValidateWithPath("") }

// ValidateWithPath validates the CT_LineChart and its children, prefixing error messages with path
func (_fgdge *CT_LineChart) ValidateWithPath(path string) error {
	if _cbbg := _fgdge.Grouping.ValidateWithPath(path + "\u002fGrouping"); _cbbg != nil {
		return _cbbg
	}
	if _fgdge.VaryColors != nil {
		if _bbdb := _fgdge.VaryColors.ValidateWithPath(path + "/VaryColors"); _bbdb != nil {
			return _bbdb
		}
	}
	for _dbdc, _gbcb := range _fgdge.Ser {
		if _ggccd := _gbcb.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _dbdc)); _ggccd != nil {
			return _ggccd
		}
	}
	if _fgdge.DLbls != nil {
		if _adgg := _fgdge.DLbls.ValidateWithPath(path + "\u002fDLbls"); _adgg != nil {
			return _adgg
		}
	}
	if _fgdge.DropLines != nil {
		if _cgdf := _fgdge.DropLines.ValidateWithPath(path + "\u002fDropLines"); _cgdf != nil {
			return _cgdf
		}
	}
	if _fgdge.HiLowLines != nil {
		if _cbda := _fgdge.HiLowLines.ValidateWithPath(path + "/HiLowLines"); _cbda != nil {
			return _cbda
		}
	}
	if _fgdge.UpDownBars != nil {
		if _baadd := _fgdge.UpDownBars.ValidateWithPath(path + "/UpDownBars"); _baadd != nil {
			return _baadd
		}
	}
	if _fgdge.Marker != nil {
		if _gfbe := _fgdge.Marker.ValidateWithPath(path + "\u002fMarker"); _gfbe != nil {
			return _gfbe
		}
	}
	if _fgdge.Smooth != nil {
		if _ffeg := _fgdge.Smooth.ValidateWithPath(path + "\u002fSmooth"); _ffeg != nil {
			return _ffeg
		}
	}
	for _fbdgc, _cegg := range _fgdge.AxId {
		if _decb := _cegg.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _fbdgc)); _decb != nil {
			return _decb
		}
	}
	if _fgdge.ExtLst != nil {
		if _cfdeb := _fgdge.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cfdeb != nil {
			return _cfdeb
		}
	}
	return nil
}
func (_dff *CT_BarDir) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _dff.ValAttr != ST_BarDirUnset {
		_dfd, _dggb := _dff.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _dggb != nil {
			return _dggb
		}
		start.Attr = append(start.Attr, _dfd)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_LineChart() *CT_LineChart {
	_fdaae := &CT_LineChart{}
	_fdaae.Grouping = NewCT_Grouping()
	return _fdaae
}

// Validate validates the CT_NumFmt and its children
func (_egaf *CT_NumFmt) Validate() error { return _egaf.ValidateWithPath("CT_NumFmt") }

type ST_BarGrouping byte

func (_gadgg *CT_TimeUnit) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _gadgg.ValAttr != ST_TimeUnitUnset {
		_gegfb, _gdcaf := _gadgg.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _gdcaf != nil {
			return _gdcaf
		}
		start.Attr = append(start.Attr, _gegfb)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_gcgd *CT_PivotSource) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_gcgd.FmtId = NewCT_UnsignedInt()
_fcac:
	for {
		_bbeab, _ddfdd := d.Token()
		if _ddfdd != nil {
			return _ddfdd
		}
		switch _gebc := _bbeab.(type) {
		case _fa.StartElement:
			switch _gebc.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "name"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "name"}:
				if _fece := d.DecodeElement(&_gcgd.Name, &_gebc); _fece != nil {
					return _fece
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "fmtId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "fmtId"}:
				if _aaee := d.DecodeElement(_gcgd.FmtId, &_gebc); _aaee != nil {
					return _aaee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_edfcf := NewCT_ExtensionList()
				if _gefd := d.DecodeElement(_edfcf, &_gebc); _gefd != nil {
					return _gefd
				}
				_gcgd.ExtLst = append(_gcgd.ExtLst, _edfcf)
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PivotSource\u0020\u0025v", _gebc.Name)
				if _gfbba := d.Skip(); _gfbba != nil {
					return _gfbba
				}
			}
		case _fa.EndElement:
			break _fcac
		case _fa.CharData:
		}
	}
	return nil
}
func (_ccab ST_TimeUnit) ValidateWithPath(path string) error {
	switch _ccab {
	case 0, 1, 2, 3:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ccab))
	}
	return nil
}

type CT_StrRef struct {
	F        string
	StrCache *CT_StrData
	ExtLst   *CT_ExtensionList
}

// Validate validates the CT_NumVal and its children
func (_dcbda *CT_NumVal) Validate() error { return _dcbda.ValidateWithPath("CT_NumVal") }
func (_fdgde ST_AxPos) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_gaacc := _fa.Attr{}
	_gaacc.Name = name
	switch _fdgde {
	case ST_AxPosUnset:
		_gaacc.Value = ""
	case ST_AxPosB:
		_gaacc.Value = "b"
	case ST_AxPosL:
		_gaacc.Value = "l"
	case ST_AxPosR:
		_gaacc.Value = "r"
	case ST_AxPosT:
		_gaacc.Value = "t"
	}
	return _gaacc, nil
}
func (_acbde *CT_RadarSer) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_acbde.Idx = NewCT_UnsignedInt()
	_acbde.Order = NewCT_UnsignedInt()
_gbfg:
	for {
		_cefcd, _adce := d.Token()
		if _adce != nil {
			return _adce
		}
		switch _beeef := _cefcd.(type) {
		case _fa.StartElement:
			switch _beeef.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "idx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "idx"}:
				if _dgcc := d.DecodeElement(_acbde.Idx, &_beeef); _dgcc != nil {
					return _dgcc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "order"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "order"}:
				if _edcf := d.DecodeElement(_acbde.Order, &_beeef); _edcf != nil {
					return _edcf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_acbde.Tx = NewCT_SerTx()
				if _aeada := d.DecodeElement(_acbde.Tx, &_beeef); _aeada != nil {
					return _aeada
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_acbde.SpPr = _cb.NewCT_ShapeProperties()
				if _agbbc := d.DecodeElement(_acbde.SpPr, &_beeef); _agbbc != nil {
					return _agbbc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "marker"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "marker"}:
				_acbde.Marker = NewCT_Marker()
				if _becfc := d.DecodeElement(_acbde.Marker, &_beeef); _becfc != nil {
					return _becfc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dPt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dPt"}:
				_eddgb := NewCT_DPt()
				if _dgdfb := d.DecodeElement(_eddgb, &_beeef); _dgdfb != nil {
					return _dgdfb
				}
				_acbde.DPt = append(_acbde.DPt, _eddgb)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_acbde.DLbls = NewCT_DLbls()
				if _ddbd := d.DecodeElement(_acbde.DLbls, &_beeef); _ddbd != nil {
					return _ddbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "cat"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "cat"}:
				_acbde.Cat = NewCT_AxDataSource()
				if _fbff := d.DecodeElement(_acbde.Cat, &_beeef); _fbff != nil {
					return _fbff
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "val"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "val"}:
				_acbde.Val = NewCT_NumDataSource()
				if _bdbad := d.DecodeElement(_acbde.Val, &_beeef); _bdbad != nil {
					return _bdbad
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_acbde.ExtLst = NewCT_ExtensionList()
				if _fgcd := d.DecodeElement(_acbde.ExtLst, &_beeef); _fgcd != nil {
					return _fgcd
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RadarSer\u0020\u0025v", _beeef.Name)
				if _dcdgd := d.Skip(); _dcdgd != nil {
					return _dcdgd
				}
			}
		case _fa.EndElement:
			break _gbfg
		case _fa.CharData:
		}
	}
	return nil
}
func (_ffda ST_TrendlineType) Validate() error { return _ffda.ValidateWithPath("") }

// Validate validates the CT_DispUnitsChoice and its children
func (_fedb *CT_DispUnitsChoice) Validate() error {
	return _fedb.ValidateWithPath("CT_DispUnitsChoice")
}
func NewCT_NumVal() *CT_NumVal { _egagf := &CT_NumVal{}; return _egagf }

// Validate validates the CT_TrendlineType and its children
func (_faefg *CT_TrendlineType) Validate() error { return _faefg.ValidateWithPath("CT_TrendlineType") }

// ST_LblOffset is a union type
type ST_LblOffset struct {
	ST_LblOffsetPercent *string
	ST_LblOffsetUShort  *uint16
}

func (_aefcd ST_ScatterStyle) ValidateWithPath(path string) error {
	switch _aefcd {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aefcd))
	}
	return nil
}

type ST_MarkerStyle byte

// Validate validates the CT_Double and its children
func (_dgbc *CT_Double) Validate() error { return _dgbc.ValidateWithPath("CT_Double") }
func (_gdbge *CT_Marker) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _gdbge.Symbol != nil {
		_abbdd := _fa.StartElement{Name: _fa.Name{Local: "c:symbol"}}
		e.EncodeElement(_gdbge.Symbol, _abbdd)
	}
	if _gdbge.Size != nil {
		_cafg := _fa.StartElement{Name: _fa.Name{Local: "c:size"}}
		e.EncodeElement(_gdbge.Size, _cafg)
	}
	if _gdbge.SpPr != nil {
		_bbfgg := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_gdbge.SpPr, _bbfgg)
	}
	if _gdbge.ExtLst != nil {
		_fbfce := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_gdbge.ExtLst, _fbfce)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_eaadg ST_Grouping) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_fceee := _fa.Attr{}
	_fceee.Name = name
	switch _eaadg {
	case ST_GroupingUnset:
		_fceee.Value = ""
	case ST_GroupingPercentStacked:
		_fceee.Value = "percentStacked"
	case ST_GroupingStandard:
		_fceee.Value = "standard"
	case ST_GroupingStacked:
		_fceee.Value = "stacked"
	}
	return _fceee, nil
}

// Validate validates the CT_MultiLvlStrData and its children
func (_dded *CT_MultiLvlStrData) Validate() error {
	return _dded.ValidateWithPath("CT_MultiLvlStrData")
}

// ValidateWithPath validates the CT_Tx and its children, prefixing error messages with path
func (_fecce *CT_Tx) ValidateWithPath(path string) error {
	if _cacda := _fecce.Choice.ValidateWithPath(path + "\u002fChoice"); _cacda != nil {
		return _cacda
	}
	return nil
}
func (_dafb *ST_ErrBarType) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_eebc, _fbeec := d.Token()
	if _fbeec != nil {
		return _fbeec
	}
	if _dagff, _acgge := _eebc.(_fa.EndElement); _acgge && _dagff.Name == start.Name {
		*_dafb = 1
		return nil
	}
	if _cceed, _geggcd := _eebc.(_fa.CharData); !_geggcd {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eebc)
	} else {
		switch string(_cceed) {
		case "":
			*_dafb = 0
		case "both":
			*_dafb = 1
		case "minus":
			*_dafb = 2
		case "plus":
			*_dafb = 3
		}
	}
	_eebc, _fbeec = d.Token()
	if _fbeec != nil {
		return _fbeec
	}
	if _eeeeg, _gbfffc := _eebc.(_fa.EndElement); _gbfffc && _eeeeg.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eebc)
}
func (_gceda ST_MarkerStyle) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_eaade := _fa.Attr{}
	_eaade.Name = name
	switch _gceda {
	case ST_MarkerStyleUnset:
		_eaade.Value = ""
	case ST_MarkerStyleCircle:
		_eaade.Value = "circle"
	case ST_MarkerStyleDash:
		_eaade.Value = "dash"
	case ST_MarkerStyleDiamond:
		_eaade.Value = "diamond"
	case ST_MarkerStyleDot:
		_eaade.Value = "dot"
	case ST_MarkerStyleNone:
		_eaade.Value = "none"
	case ST_MarkerStylePicture:
		_eaade.Value = "picture"
	case ST_MarkerStylePlus:
		_eaade.Value = "plus"
	case ST_MarkerStyleSquare:
		_eaade.Value = "square"
	case ST_MarkerStyleStar:
		_eaade.Value = "star"
	case ST_MarkerStyleTriangle:
		_eaade.Value = "triangle"
	case ST_MarkerStyleX:
		_eaade.Value = "x"
	case ST_MarkerStyleAuto:
		_eaade.Value = "auto"
	}
	return _eaade, nil
}

const ST_HoleSizePercentPattern = "0\u002a\u0028\u005b1\u002d9\u005d\u007c\u0028\u005b1\u002d8\u005d\u005b0\u002d9\u005d\u0029\u007c90\u0029\u0025"

// Validate validates the Chart and its children
func (_edaa *Chart) Validate() error { return _edaa.ValidateWithPath("Chart") }

// Validate validates the CT_PieChart and its children
func (_feegbd *CT_PieChart) Validate() error { return _feegbd.ValidateWithPath("CT_PieChart") }
func NewCT_RadarChart() *CT_RadarChart {
	_becdd := &CT_RadarChart{}
	_becdd.RadarStyle = NewCT_RadarStyle()
	return _becdd
}
func (_adfef *ST_DispBlanksAs) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_aecfc, _gegcg := d.Token()
	if _gegcg != nil {
		return _gegcg
	}
	if _cdeeg, _gccad := _aecfc.(_fa.EndElement); _gccad && _cdeeg.Name == start.Name {
		*_adfef = 1
		return nil
	}
	if _dcfac, _fcedb := _aecfc.(_fa.CharData); !_fcedb {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aecfc)
	} else {
		switch string(_dcfac) {
		case "":
			*_adfef = 0
		case "span":
			*_adfef = 1
		case "gap":
			*_adfef = 2
		case "zero":
			*_adfef = 3
		}
	}
	_aecfc, _gegcg = d.Token()
	if _gegcg != nil {
		return _gegcg
	}
	if _daegea, _fddde := _aecfc.(_fa.EndElement); _fddde && _daegea.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aecfc)
}

type CT_StrVal struct {
	IdxAttr uint32
	V       string
}

// Validate validates the CT_LayoutMode and its children
func (_abca *CT_LayoutMode) Validate() error { return _abca.ValidateWithPath("CT_LayoutMode") }
func (_cecb ST_TimeUnit) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_beged := _fa.Attr{}
	_beged.Name = name
	switch _cecb {
	case ST_TimeUnitUnset:
		_beged.Value = ""
	case ST_TimeUnitDays:
		_beged.Value = "days"
	case ST_TimeUnitMonths:
		_beged.Value = "months"
	case ST_TimeUnitYears:
		_beged.Value = "years"
	}
	return _beged, nil
}
func (_gfeag *CT_ScatterChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cgba := _fa.StartElement{Name: _fa.Name{Local: "c:scatterStyle"}}
	e.EncodeElement(_gfeag.ScatterStyle, _cgba)
	if _gfeag.VaryColors != nil {
		_edbce := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_gfeag.VaryColors, _edbce)
	}
	if _gfeag.Ser != nil {
		_geecb := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _dfgef := range _gfeag.Ser {
			e.EncodeElement(_dfgef, _geecb)
		}
	}
	if _gfeag.DLbls != nil {
		_dcac := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_gfeag.DLbls, _dcac)
	}
	_fabe := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _gagd := range _gfeag.AxId {
		e.EncodeElement(_gagd, _fabe)
	}
	if _gfeag.ExtLst != nil {
		_ecfd := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_gfeag.ExtLst, _ecfd)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_gebbe ST_LegendPos) Validate() error { return _gebbe.ValidateWithPath("") }

type UserShapes struct{ _gd.CT_Drawing }

// Validate validates the EG_LegendEntryData and its children
func (_eggf *EG_LegendEntryData) Validate() error {
	return _eggf.ValidateWithPath("EG_LegendEntryData")
}
func (_fcfag *CT_DoughnutChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_aede:
	for {
		_eggdd, _egcb := d.Token()
		if _egcb != nil {
			return _egcb
		}
		switch _gaddg := _eggdd.(type) {
		case _fa.StartElement:
			switch _gaddg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_fcfag.VaryColors = NewCT_Boolean()
				if _bagbe := d.DecodeElement(_fcfag.VaryColors, &_gaddg); _bagbe != nil {
					return _bagbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_aeaaf := NewCT_PieSer()
				if _bbcdb := d.DecodeElement(_aeaaf, &_gaddg); _bbcdb != nil {
					return _bbcdb
				}
				_fcfag.Ser = append(_fcfag.Ser, _aeaaf)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_fcfag.DLbls = NewCT_DLbls()
				if _feggg := d.DecodeElement(_fcfag.DLbls, &_gaddg); _feggg != nil {
					return _feggg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "firstSliceAng"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "firstSliceAng"}:
				_fcfag.FirstSliceAng = NewCT_FirstSliceAng()
				if _ggfa := d.DecodeElement(_fcfag.FirstSliceAng, &_gaddg); _ggfa != nil {
					return _ggfa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "holeSize"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "holeSize"}:
				_fcfag.HoleSize = NewCT_HoleSize()
				if _ggbe := d.DecodeElement(_fcfag.HoleSize, &_gaddg); _ggbe != nil {
					return _ggbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_fcfag.ExtLst = NewCT_ExtensionList()
				if _gabad := d.DecodeElement(_fcfag.ExtLst, &_gaddg); _gabad != nil {
					return _gabad
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DoughnutChart\u0020\u0025v", _gaddg.Name)
				if _bfdf := d.Skip(); _bfdf != nil {
					return _bfdf
				}
			}
		case _fa.EndElement:
			break _aede
		case _fa.CharData:
		}
	}
	return nil
}
func NewCT_Bar3DChart() *CT_Bar3DChart {
	_cegf := &CT_Bar3DChart{}
	_cegf.BarDir = NewCT_BarDir()
	return _cegf
}

type CT_Line3DChart struct {
	Grouping   *CT_Grouping
	VaryColors *CT_Boolean
	Ser        []*CT_LineSer
	DLbls      *CT_DLbls
	DropLines  *CT_ChartLines
	GapDepth   *CT_GapAmount
	AxId       []*CT_UnsignedInt
	ExtLst     *CT_ExtensionList
}

func (_beafb *CT_ErrDir) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_beafb.ValAttr = ST_ErrDir(1)
	for _, _bfeg := range start.Attr {
		if _bfeg.Name.Local == "val" {
			_beafb.ValAttr.UnmarshalXMLAttr(_bfeg)
			continue
		}
	}
	for {
		_dcgd, _dbggb := d.Token()
		if _dbggb != nil {
			return _gg.Errorf("parsing\u0020CT_ErrDir:\u0020\u0025s", _dbggb)
		}
		if _cgce, _begac := _dcgd.(_fa.EndElement); _begac && _cgce.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the UserShapes and its children, prefixing error messages with path
func (_cffab *UserShapes) ValidateWithPath(path string) error {
	if _eeedd := _cffab.CT_Drawing.ValidateWithPath(path); _eeedd != nil {
		return _eeedd
	}
	return nil
}
func (_bgfc *CT_NumRef) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_bgdaa:
	for {
		_geae, _gbgcb := d.Token()
		if _gbgcb != nil {
			return _gbgcb
		}
		switch _cagc := _geae.(type) {
		case _fa.StartElement:
			switch _cagc.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "f"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "f"}:
				if _adcd := d.DecodeElement(&_bgfc.F, &_cagc); _adcd != nil {
					return _adcd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numCache"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numCache"}:
				_bgfc.NumCache = NewCT_NumData()
				if _eeffa := d.DecodeElement(_bgfc.NumCache, &_cagc); _eeffa != nil {
					return _eeffa
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_bgfc.ExtLst = NewCT_ExtensionList()
				if _fbcfe := d.DecodeElement(_bgfc.ExtLst, &_cagc); _fbcfe != nil {
					return _fbcfe
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_NumRef \u0025v", _cagc.Name)
				if _bcdgdf := d.Skip(); _bcdgdf != nil {
					return _bcdgdf
				}
			}
		case _fa.EndElement:
			break _bgdaa
		case _fa.CharData:
		}
	}
	return nil
}
func NewUserShapes() *UserShapes {
	_gaafe := &UserShapes{}
	_gaafe.CT_Drawing = *_gd.NewCT_Drawing()
	return _gaafe
}
func (_gccg *CT_Bar3DChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_gccg.BarDir = NewCT_BarDir()
_aae:
	for {
		_dfg, _dfb := d.Token()
		if _dfb != nil {
			return _dfb
		}
		switch _gage := _dfg.(type) {
		case _fa.StartElement:
			switch _gage.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "barDir"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "barDir"}:
				if _gbf := d.DecodeElement(_gccg.BarDir, &_gage); _gbf != nil {
					return _gbf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "grouping"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "grouping"}:
				_gccg.Grouping = NewCT_BarGrouping()
				if _dgaf := d.DecodeElement(_gccg.Grouping, &_gage); _dgaf != nil {
					return _dgaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_gccg.VaryColors = NewCT_Boolean()
				if _dcbd := d.DecodeElement(_gccg.VaryColors, &_gage); _dcbd != nil {
					return _dcbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_efc := NewCT_BarSer()
				if _bcc := d.DecodeElement(_efc, &_gage); _bcc != nil {
					return _bcc
				}
				_gccg.Ser = append(_gccg.Ser, _efc)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_gccg.DLbls = NewCT_DLbls()
				if _acdb := d.DecodeElement(_gccg.DLbls, &_gage); _acdb != nil {
					return _acdb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "gapWidth"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "gapWidth"}:
				_gccg.GapWidth = NewCT_GapAmount()
				if _acb := d.DecodeElement(_gccg.GapWidth, &_gage); _acb != nil {
					return _acb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "gapDepth"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "gapDepth"}:
				_gccg.GapDepth = NewCT_GapAmount()
				if _ded := d.DecodeElement(_gccg.GapDepth, &_gage); _ded != nil {
					return _ded
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "shape"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "shape"}:
				_gccg.Shape = NewCT_Shape()
				if _fgc := d.DecodeElement(_gccg.Shape, &_gage); _fgc != nil {
					return _fgc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_fab := NewCT_UnsignedInt()
				if _bcd := d.DecodeElement(_fab, &_gage); _bcd != nil {
					return _bcd
				}
				_gccg.AxId = append(_gccg.AxId, _fab)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_gccg.ExtLst = NewCT_ExtensionList()
				if _bac := d.DecodeElement(_gccg.ExtLst, &_gage); _bac != nil {
					return _bac
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_Bar3DChart \u0025v", _gage.Name)
				if _fcgf := d.Skip(); _fcgf != nil {
					return _fcgf
				}
			}
		case _fa.EndElement:
			break _aae
		case _fa.CharData:
		}
	}
	return nil
}
func (_fdgd *ST_BubbleScale) Validate() error { return _fdgd.ValidateWithPath("") }
func (_eafee *ST_LblAlgn) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_eafee = 0
	case "ctr":
		*_eafee = 1
	case "l":
		*_eafee = 2
	case "r":
		*_eafee = 3
	}
	return nil
}
func NewCT_Title() *CT_Title { _gfbef := &CT_Title{}; return _gfbef }

// Validate validates the CT_NumRef and its children
func (_fdba *CT_NumRef) Validate() error { return _fdba.ValidateWithPath("CT_NumRef") }
func NewCT_MarkerStyle() *CT_MarkerStyle {
	_fcba := &CT_MarkerStyle{}
	_fcba.ValAttr = ST_MarkerStyle(1)
	return _fcba
}

// ValidateWithPath validates the CT_PivotSource and its children, prefixing error messages with path
func (_ggeab *CT_PivotSource) ValidateWithPath(path string) error {
	if _dagg := _ggeab.FmtId.ValidateWithPath(path + "\u002fFmtId"); _dagg != nil {
		return _dagg
	}
	for _bafe, _gfcgb := range _ggeab.ExtLst {
		if _egcdg := _gfcgb.ValidateWithPath(_gg.Sprintf("\u0025s\u002fExtLst\u005b\u0025d\u005d", path, _bafe)); _egcdg != nil {
			return _egcdg
		}
	}
	return nil
}

// Validate validates the CT_PictureOptions and its children
func (_bged *CT_PictureOptions) Validate() error { return _bged.ValidateWithPath("CT_PictureOptions") }

// ValidateWithPath validates the CT_Crosses and its children, prefixing error messages with path
func (_ecbf *CT_Crosses) ValidateWithPath(path string) error {
	if _ecbf.ValAttr == ST_CrossesUnset {
		return _gg.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _baeg := _ecbf.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _baeg != nil {
		return _baeg
	}
	return nil
}
func NewCT_Lvl() *CT_Lvl { _eaef := &CT_Lvl{}; return _eaef }

type CT_ChartLines struct{ SpPr *_cb.CT_ShapeProperties }

// ValidateWithPath validates the CT_BubbleSer and its children, prefixing error messages with path
func (_fgcb *CT_BubbleSer) ValidateWithPath(path string) error {
	if _bfca := _fgcb.Idx.ValidateWithPath(path + "\u002fIdx"); _bfca != nil {
		return _bfca
	}
	if _afb := _fgcb.Order.ValidateWithPath(path + "\u002fOrder"); _afb != nil {
		return _afb
	}
	if _fgcb.Tx != nil {
		if _gca := _fgcb.Tx.ValidateWithPath(path + "\u002fTx"); _gca != nil {
			return _gca
		}
	}
	if _fgcb.SpPr != nil {
		if _cbfg := _fgcb.SpPr.ValidateWithPath(path + "\u002fSpPr"); _cbfg != nil {
			return _cbfg
		}
	}
	if _fgcb.InvertIfNegative != nil {
		if _cge := _fgcb.InvertIfNegative.ValidateWithPath(path + "\u002fInvertIfNegative"); _cge != nil {
			return _cge
		}
	}
	for _dca, _eaeag := range _fgcb.DPt {
		if _cbfa := _eaeag.ValidateWithPath(_gg.Sprintf("\u0025s\u002fDPt\u005b\u0025d\u005d", path, _dca)); _cbfa != nil {
			return _cbfa
		}
	}
	if _fgcb.DLbls != nil {
		if _acf := _fgcb.DLbls.ValidateWithPath(path + "\u002fDLbls"); _acf != nil {
			return _acf
		}
	}
	for _gcd, _fbcg := range _fgcb.Trendline {
		if _egd := _fbcg.ValidateWithPath(_gg.Sprintf("\u0025s/Trendline\u005b\u0025d\u005d", path, _gcd)); _egd != nil {
			return _egd
		}
	}
	for _cfcg, _eecd := range _fgcb.ErrBars {
		if _gbce := _eecd.ValidateWithPath(_gg.Sprintf("\u0025s\u002fErrBars\u005b\u0025d\u005d", path, _cfcg)); _gbce != nil {
			return _gbce
		}
	}
	if _fgcb.XVal != nil {
		if _fade := _fgcb.XVal.ValidateWithPath(path + "\u002fXVal"); _fade != nil {
			return _fade
		}
	}
	if _fgcb.YVal != nil {
		if _bdfa := _fgcb.YVal.ValidateWithPath(path + "\u002fYVal"); _bdfa != nil {
			return _bdfa
		}
	}
	if _fgcb.BubbleSize != nil {
		if _afab := _fgcb.BubbleSize.ValidateWithPath(path + "/BubbleSize"); _afab != nil {
			return _afab
		}
	}
	if _fgcb.Bubble3D != nil {
		if _aaa := _fgcb.Bubble3D.ValidateWithPath(path + "\u002fBubble3D"); _aaa != nil {
			return _aaa
		}
	}
	if _fgcb.ExtLst != nil {
		if _caad := _fgcb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _caad != nil {
			return _caad
		}
	}
	return nil
}
func (_efedc *ST_SplitType) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_efedc = 0
	case "auto":
		*_efedc = 1
	case "cust":
		*_efedc = 2
	case "percent":
		*_efedc = 3
	case "pos":
		*_efedc = 4
	case "val":
		*_efedc = 5
	}
	return nil
}

type CT_SurfaceSer struct {
	Idx    *CT_UnsignedInt
	Order  *CT_UnsignedInt
	Tx     *CT_SerTx
	SpPr   *_cb.CT_ShapeProperties
	Cat    *CT_AxDataSource
	Val    *CT_NumDataSource
	ExtLst *CT_ExtensionList
}
type ST_ErrValType byte

// Validate validates the CT_Shape and its children
func (_ddcged *CT_Shape) Validate() error { return _ddcged.ValidateWithPath("CT_Shape") }

type CT_SplitType struct{ ValAttr ST_SplitType }

// ValidateWithPath validates the CT_PictureStackUnit and its children, prefixing error messages with path
func (_afac *CT_PictureStackUnit) ValidateWithPath(path string) error {
	if _afac.ValAttr <= 0 {
		return _gg.Errorf("\u0025s\u002fm.ValAttr\u0020must\u0020be \u003e\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _afac.ValAttr)
	}
	return nil
}

type CT_RadarSer struct {
	Idx    *CT_UnsignedInt
	Order  *CT_UnsignedInt
	Tx     *CT_SerTx
	SpPr   *_cb.CT_ShapeProperties
	Marker *CT_Marker
	DPt    []*CT_DPt
	DLbls  *CT_DLbls
	Cat    *CT_AxDataSource
	Val    *CT_NumDataSource
	ExtLst *CT_ExtensionList
}

func (_abcad *CT_NumDataSource) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_abcad.Choice = NewCT_NumDataSourceChoice()
_egcgf:
	for {
		_eeag, _cebda := d.Token()
		if _cebda != nil {
			return _cebda
		}
		switch _daacd := _eeag.(type) {
		case _fa.StartElement:
			switch _daacd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numRef"}:
				_abcad.Choice = NewCT_NumDataSourceChoice()
				if _adcaf := d.DecodeElement(&_abcad.Choice.NumRef, &_daacd); _adcaf != nil {
					return _adcaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numLit"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numLit"}:
				_abcad.Choice = NewCT_NumDataSourceChoice()
				if _gabf := d.DecodeElement(&_abcad.Choice.NumLit, &_daacd); _gabf != nil {
					return _gabf
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_NumDataSource\u0020\u0025v", _daacd.Name)
				if _egab := d.Skip(); _egab != nil {
					return _egab
				}
			}
		case _fa.EndElement:
			break _egcgf
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_OfPieType and its children
func (_fdff *CT_OfPieType) Validate() error { return _fdff.ValidateWithPath("CT_OfPieType") }

// Validate validates the CT_RadarSer and its children
func (_cdcge *CT_RadarSer) Validate() error { return _cdcge.ValidateWithPath("CT_RadarSer") }
func (_baabb *CT_Orientation) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _baabb.ValAttr != ST_OrientationUnset {
		_dbdg, _aacab := _baabb.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _aacab != nil {
			return _aacab
		}
		start.Attr = append(start.Attr, _dbdg)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_cdafd *CT_PivotFmts) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _cdafd.PivotFmt != nil {
		_dbfb := _fa.StartElement{Name: _fa.Name{Local: "c:pivotFmt"}}
		for _, _edbdc := range _cdafd.PivotFmt {
			e.EncodeElement(_edbdc, _dbfb)
		}
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_ManualLayout struct {
	LayoutTarget *CT_LayoutTarget
	XMode        *CT_LayoutMode
	YMode        *CT_LayoutMode
	WMode        *CT_LayoutMode
	HMode        *CT_LayoutMode
	X            *CT_Double
	Y            *CT_Double
	W            *CT_Double
	H            *CT_Double
	ExtLst       *CT_ExtensionList
}

// ST_DepthPercent is a union type
type ST_DepthPercent struct {
	ST_DepthPercentWithSymbol *string
	ST_DepthPercentUShort     *uint16
}
type ST_OfPieType byte

func (_efedf *CT_Extension) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _efedf.UriAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "uri"}, Value: _gg.Sprintf("\u0025v", *_efedf.UriAttr)})
	}
	e.EncodeToken(start)
	if _efedf.Any != nil {
		_efedf.Any.MarshalXML(e, _fa.StartElement{})
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_fgfdg *CT_TrendlineLbl) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_cgffa:
	for {
		_aaffa, _aabcc := d.Token()
		if _aabcc != nil {
			return _aabcc
		}
		switch _dedf := _aaffa.(type) {
		case _fa.StartElement:
			switch _dedf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "layout"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "layout"}:
				_fgfdg.Layout = NewCT_Layout()
				if _efddf := d.DecodeElement(_fgfdg.Layout, &_dedf); _efddf != nil {
					return _efddf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_fgfdg.Tx = NewCT_Tx()
				if _adaff := d.DecodeElement(_fgfdg.Tx, &_dedf); _adaff != nil {
					return _adaff
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "numFmt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "numFmt"}:
				_fgfdg.NumFmt = NewCT_NumFmt()
				if _cgddbf := d.DecodeElement(_fgfdg.NumFmt, &_dedf); _cgddbf != nil {
					return _cgddbf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_fgfdg.SpPr = _cb.NewCT_ShapeProperties()
				if _ggege := d.DecodeElement(_fgfdg.SpPr, &_dedf); _ggege != nil {
					return _ggege
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_fgfdg.TxPr = _cb.NewCT_TextBody()
				if _gabfbd := d.DecodeElement(_fgfdg.TxPr, &_dedf); _gabfbd != nil {
					return _gabfbd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_fgfdg.ExtLst = NewCT_ExtensionList()
				if _bdea := d.DecodeElement(_fgfdg.ExtLst, &_dedf); _bdea != nil {
					return _bdea
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TrendlineLbl\u0020\u0025v", _dedf.Name)
				if _gdfcff := d.Skip(); _gdfcff != nil {
					return _gdfcff
				}
			}
		case _fa.EndElement:
			break _cgffa
		case _fa.CharData:
		}
	}
	return nil
}
func (_gafde *CT_UpDownBars) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _gafde.GapWidth != nil {
		_bfcdd := _fa.StartElement{Name: _fa.Name{Local: "c:gapWidth"}}
		e.EncodeElement(_gafde.GapWidth, _bfcdd)
	}
	if _gafde.UpBars != nil {
		_gfcga := _fa.StartElement{Name: _fa.Name{Local: "c:upBars"}}
		e.EncodeElement(_gafde.UpBars, _gfcga)
	}
	if _gafde.DownBars != nil {
		_cbgbf := _fa.StartElement{Name: _fa.Name{Local: "c:downBars"}}
		e.EncodeElement(_gafde.DownBars, _cbgbf)
	}
	if _gafde.ExtLst != nil {
		_dbbe := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_gafde.ExtLst, _dbbe)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_Perspective struct{ ValAttr *uint8 }
type CT_HeaderFooter struct {
	AlignWithMarginsAttr *bool
	DifferentOddEvenAttr *bool
	DifferentFirstAttr   *bool
	OddHeader            *string
	OddFooter            *string
	EvenHeader           *string
	EvenFooter           *string
	FirstHeader          *string
	FirstFooter          *string
}

func (_ecef *CT_ChartLines) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_cceg:
	for {
		_gdbff, _aggd := d.Token()
		if _aggd != nil {
			return _aggd
		}
		switch _cafc := _gdbff.(type) {
		case _fa.StartElement:
			switch _cafc.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_ecef.SpPr = _cb.NewCT_ShapeProperties()
				if _ecdcb := d.DecodeElement(_ecef.SpPr, &_cafc); _ecdcb != nil {
					return _ecdcb
				}
			default:
				_b.Log("skipping unsupported element\u0020on\u0020CT_ChartLines \u0025v", _cafc.Name)
				if _abfa := d.Skip(); _abfa != nil {
					return _abfa
				}
			}
		case _fa.EndElement:
			break _cceg
		case _fa.CharData:
		}
	}
	return nil
}
func (_cbeaf ST_CrossBetween) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_cbeaf.String(), start)
}

// ValidateWithPath validates the CT_Pie3DChart and its children, prefixing error messages with path
func (_bagff *CT_Pie3DChart) ValidateWithPath(path string) error {
	if _bagff.VaryColors != nil {
		if _fafbf := _bagff.VaryColors.ValidateWithPath(path + "/VaryColors"); _fafbf != nil {
			return _fafbf
		}
	}
	for _cacd, _bfbcf := range _bagff.Ser {
		if _cggg := _bfbcf.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _cacd)); _cggg != nil {
			return _cggg
		}
	}
	if _bagff.DLbls != nil {
		if _geedca := _bagff.DLbls.ValidateWithPath(path + "\u002fDLbls"); _geedca != nil {
			return _geedca
		}
	}
	if _bagff.ExtLst != nil {
		if _ggdgc := _bagff.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ggdgc != nil {
			return _ggdgc
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Style and its children, prefixing error messages with path
func (_fadgbe *CT_Style) ValidateWithPath(path string) error {
	if _fadgbe.ValAttr < 1 {
		return _gg.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00201\u0020\u0028have\u0020\u0025v\u0029", path, _fadgbe.ValAttr)
	}
	if _fadgbe.ValAttr > 48 {
		return _gg.Errorf("\u0025s/m\u002eValAttr must be\u0020\u003c\u003d\u002048 \u0028have\u0020\u0025v\u0029", path, _fadgbe.ValAttr)
	}
	return nil
}
func (_efbba *CT_OfPieType) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _fceea := range start.Attr {
		if _fceea.Name.Local == "val" {
			_efbba.ValAttr.UnmarshalXMLAttr(_fceea)
			continue
		}
	}
	for {
		_bgaa, _agag := d.Token()
		if _agag != nil {
			return _gg.Errorf("parsing\u0020CT_OfPieType:\u0020\u0025s", _agag)
		}
		if _ecffg, _dbgac := _bgaa.(_fa.EndElement); _dbgac && _ecffg.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CatAx and its children, prefixing error messages with path
func (_fcdd *CT_CatAx) ValidateWithPath(path string) error {
	if _aeca := _fcdd.AxId.ValidateWithPath(path + "\u002fAxId"); _aeca != nil {
		return _aeca
	}
	if _accb := _fcdd.Scaling.ValidateWithPath(path + "\u002fScaling"); _accb != nil {
		return _accb
	}
	if _fcdd.Delete != nil {
		if _aaca := _fcdd.Delete.ValidateWithPath(path + "\u002fDelete"); _aaca != nil {
			return _aaca
		}
	}
	if _egae := _fcdd.AxPos.ValidateWithPath(path + "\u002fAxPos"); _egae != nil {
		return _egae
	}
	if _fcdd.MajorGridlines != nil {
		if _cgge := _fcdd.MajorGridlines.ValidateWithPath(path + "\u002fMajorGridlines"); _cgge != nil {
			return _cgge
		}
	}
	if _fcdd.MinorGridlines != nil {
		if _aefgc := _fcdd.MinorGridlines.ValidateWithPath(path + "\u002fMinorGridlines"); _aefgc != nil {
			return _aefgc
		}
	}
	if _fcdd.Title != nil {
		if _babf := _fcdd.Title.ValidateWithPath(path + "\u002fTitle"); _babf != nil {
			return _babf
		}
	}
	if _fcdd.NumFmt != nil {
		if _agg := _fcdd.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _agg != nil {
			return _agg
		}
	}
	if _fcdd.MajorTickMark != nil {
		if _gfad := _fcdd.MajorTickMark.ValidateWithPath(path + "\u002fMajorTickMark"); _gfad != nil {
			return _gfad
		}
	}
	if _fcdd.MinorTickMark != nil {
		if _gadd := _fcdd.MinorTickMark.ValidateWithPath(path + "\u002fMinorTickMark"); _gadd != nil {
			return _gadd
		}
	}
	if _fcdd.TickLblPos != nil {
		if _efcf := _fcdd.TickLblPos.ValidateWithPath(path + "/TickLblPos"); _efcf != nil {
			return _efcf
		}
	}
	if _fcdd.SpPr != nil {
		if _fcb := _fcdd.SpPr.ValidateWithPath(path + "\u002fSpPr"); _fcb != nil {
			return _fcb
		}
	}
	if _fcdd.TxPr != nil {
		if _feba := _fcdd.TxPr.ValidateWithPath(path + "\u002fTxPr"); _feba != nil {
			return _feba
		}
	}
	if _dbae := _fcdd.CrossAx.ValidateWithPath(path + "\u002fCrossAx"); _dbae != nil {
		return _dbae
	}
	if _fcdd.Choice != nil {
		if _cbeef := _fcdd.Choice.ValidateWithPath(path + "\u002fChoice"); _cbeef != nil {
			return _cbeef
		}
	}
	if _fcdd.Auto != nil {
		if _edab := _fcdd.Auto.ValidateWithPath(path + "\u002fAuto"); _edab != nil {
			return _edab
		}
	}
	if _fcdd.LblAlgn != nil {
		if _dcaf := _fcdd.LblAlgn.ValidateWithPath(path + "\u002fLblAlgn"); _dcaf != nil {
			return _dcaf
		}
	}
	if _fcdd.LblOffset != nil {
		if _gfb := _fcdd.LblOffset.ValidateWithPath(path + "\u002fLblOffset"); _gfb != nil {
			return _gfb
		}
	}
	if _fcdd.TickLblSkip != nil {
		if _ffcc := _fcdd.TickLblSkip.ValidateWithPath(path + "\u002fTickLblSkip"); _ffcc != nil {
			return _ffcc
		}
	}
	if _fcdd.TickMarkSkip != nil {
		if _effe := _fcdd.TickMarkSkip.ValidateWithPath(path + "\u002fTickMarkSkip"); _effe != nil {
			return _effe
		}
	}
	if _fcdd.NoMultiLvlLbl != nil {
		if _egea := _fcdd.NoMultiLvlLbl.ValidateWithPath(path + "\u002fNoMultiLvlLbl"); _egea != nil {
			return _egea
		}
	}
	if _fcdd.ExtLst != nil {
		if _beca := _fcdd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _beca != nil {
			return _beca
		}
	}
	return nil
}
func (_addac *CT_PlotAreaChoice) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_bcce:
	for {
		_dbgfe, _dcea := d.Token()
		if _dcea != nil {
			return _dcea
		}
		switch _gecf := _dbgfe.(type) {
		case _fa.StartElement:
			switch _gecf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "areaChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "areaChart"}:
				_addac.AreaChart = NewCT_AreaChart()
				if _fdgb := d.DecodeElement(_addac.AreaChart, &_gecf); _fdgb != nil {
					return _fdgb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "area3DChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "area3DChart"}:
				_addac.Area3DChart = NewCT_Area3DChart()
				if _becfbe := d.DecodeElement(_addac.Area3DChart, &_gecf); _becfbe != nil {
					return _becfbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "lineChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "lineChart"}:
				_addac.LineChart = NewCT_LineChart()
				if _cdae := d.DecodeElement(_addac.LineChart, &_gecf); _cdae != nil {
					return _cdae
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "line3DChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "line3DChart"}:
				_addac.Line3DChart = NewCT_Line3DChart()
				if _ffag := d.DecodeElement(_addac.Line3DChart, &_gecf); _ffag != nil {
					return _ffag
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "stockChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "stockChart"}:
				_addac.StockChart = NewCT_StockChart()
				if _cgga := d.DecodeElement(_addac.StockChart, &_gecf); _cgga != nil {
					return _cgga
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "radarChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "radarChart"}:
				_addac.RadarChart = NewCT_RadarChart()
				if _fbece := d.DecodeElement(_addac.RadarChart, &_gecf); _fbece != nil {
					return _fbece
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "scatterChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "scatterChart"}:
				_addac.ScatterChart = NewCT_ScatterChart()
				if _bfbf := d.DecodeElement(_addac.ScatterChart, &_gecf); _bfbf != nil {
					return _bfbf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pieChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pieChart"}:
				_addac.PieChart = NewCT_PieChart()
				if _cbfd := d.DecodeElement(_addac.PieChart, &_gecf); _cbfd != nil {
					return _cbfd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pie3DChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pie3DChart"}:
				_addac.Pie3DChart = NewCT_Pie3DChart()
				if _cgbgf := d.DecodeElement(_addac.Pie3DChart, &_gecf); _cgbgf != nil {
					return _cgbgf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "doughnutChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "doughnutChart"}:
				_addac.DoughnutChart = NewCT_DoughnutChart()
				if _efbe := d.DecodeElement(_addac.DoughnutChart, &_gecf); _efbe != nil {
					return _efbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "barChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "barChart"}:
				_addac.BarChart = NewCT_BarChart()
				if _aebb := d.DecodeElement(_addac.BarChart, &_gecf); _aebb != nil {
					return _aebb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bar3DChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bar3DChart"}:
				_addac.Bar3DChart = NewCT_Bar3DChart()
				if _cgaf := d.DecodeElement(_addac.Bar3DChart, &_gecf); _cgaf != nil {
					return _cgaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ofPieChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ofPieChart"}:
				_addac.OfPieChart = NewCT_OfPieChart()
				if _bfdae := d.DecodeElement(_addac.OfPieChart, &_gecf); _bfdae != nil {
					return _bfdae
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "surfaceChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "surfaceChart"}:
				_addac.SurfaceChart = NewCT_SurfaceChart()
				if _aabcg := d.DecodeElement(_addac.SurfaceChart, &_gecf); _aabcg != nil {
					return _aabcg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "surface3DChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "surface3DChart"}:
				_addac.Surface3DChart = NewCT_Surface3DChart()
				if _ccebd := d.DecodeElement(_addac.Surface3DChart, &_gecf); _ccebd != nil {
					return _ccebd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bubbleChart"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bubbleChart"}:
				_addac.BubbleChart = NewCT_BubbleChart()
				if _ddcd := d.DecodeElement(_addac.BubbleChart, &_gecf); _ddcd != nil {
					return _ddcd
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_PlotAreaChoice\u0020\u0025v", _gecf.Name)
				if _acded := d.Skip(); _acded != nil {
					return _acded
				}
			}
		case _fa.EndElement:
			break _bcce
		case _fa.CharData:
		}
	}
	return nil
}
func (_afabe *ST_GapAmount) ValidateWithPath(path string) error {
	_dfaedd := []string{}
	if _afabe.ST_GapAmountPercent != nil {
		_dfaedd = append(_dfaedd, "ST_GapAmountPercent")
	}
	if _afabe.ST_GapAmountUShort != nil {
		_dfaedd = append(_dfaedd, "ST_GapAmountUShort")
	}
	if len(_dfaedd) > 1 {
		return _gg.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _dfaedd)
	}
	return nil
}

// ValidateWithPath validates the CT_SizeRepresents and its children, prefixing error messages with path
func (_feged *CT_SizeRepresents) ValidateWithPath(path string) error {
	if _ggfg := _feged.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _ggfg != nil {
		return _ggfg
	}
	return nil
}

type CT_SizeRepresents struct{ ValAttr ST_SizeRepresents }

func (_fgdbcd *ST_Thickness) ValidateWithPath(path string) error {
	_eedae := []string{}
	if _fgdbcd.ST_ThicknessPercent != nil {
		_eedae = append(_eedae, "ST_ThicknessPercent")
	}
	if _fgdbcd.Uint32 != nil {
		_eedae = append(_eedae, "Uint32")
	}
	if len(_eedae) > 1 {
		return _gg.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _eedae)
	}
	return nil
}

// ValidateWithPath validates the CT_Trendline and its children, prefixing error messages with path
func (_aadfg *CT_Trendline) ValidateWithPath(path string) error {
	if _aadfg.SpPr != nil {
		if _adbcb := _aadfg.SpPr.ValidateWithPath(path + "\u002fSpPr"); _adbcb != nil {
			return _adbcb
		}
	}
	if _eddd := _aadfg.TrendlineType.ValidateWithPath(path + "\u002fTrendlineType"); _eddd != nil {
		return _eddd
	}
	if _aadfg.Order != nil {
		if _edfga := _aadfg.Order.ValidateWithPath(path + "\u002fOrder"); _edfga != nil {
			return _edfga
		}
	}
	if _aadfg.Period != nil {
		if _afbfb := _aadfg.Period.ValidateWithPath(path + "\u002fPeriod"); _afbfb != nil {
			return _afbfb
		}
	}
	if _aadfg.Forward != nil {
		if _gbdgd := _aadfg.Forward.ValidateWithPath(path + "\u002fForward"); _gbdgd != nil {
			return _gbdgd
		}
	}
	if _aadfg.Backward != nil {
		if _baaac := _aadfg.Backward.ValidateWithPath(path + "\u002fBackward"); _baaac != nil {
			return _baaac
		}
	}
	if _aadfg.Intercept != nil {
		if _deec := _aadfg.Intercept.ValidateWithPath(path + "\u002fIntercept"); _deec != nil {
			return _deec
		}
	}
	if _aadfg.DispRSqr != nil {
		if _gdfd := _aadfg.DispRSqr.ValidateWithPath(path + "\u002fDispRSqr"); _gdfd != nil {
			return _gdfd
		}
	}
	if _aadfg.DispEq != nil {
		if _aeggge := _aadfg.DispEq.ValidateWithPath(path + "\u002fDispEq"); _aeggge != nil {
			return _aeggge
		}
	}
	if _aadfg.TrendlineLbl != nil {
		if _aadb := _aadfg.TrendlineLbl.ValidateWithPath(path + "\u002fTrendlineLbl"); _aadb != nil {
			return _aadb
		}
	}
	if _aadfg.ExtLst != nil {
		if _fdcf := _aadfg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fdcf != nil {
			return _fdcf
		}
	}
	return nil
}

// ValidateWithPath validates the CT_OfPieType and its children, prefixing error messages with path
func (_ffadd *CT_OfPieType) ValidateWithPath(path string) error {
	if _bebca := _ffadd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bebca != nil {
		return _bebca
	}
	return nil
}

type CT_RotX struct{ ValAttr *int8 }

const (
	ST_LegendPosUnset ST_LegendPos = 0
	ST_LegendPosB     ST_LegendPos = 1
	ST_LegendPosTr    ST_LegendPos = 2
	ST_LegendPosL     ST_LegendPos = 3
	ST_LegendPosR     ST_LegendPos = 4
	ST_LegendPosT     ST_LegendPos = 5
)

// ValidateWithPath validates the CT_LayoutTarget and its children, prefixing error messages with path
func (_gdbg *CT_LayoutTarget) ValidateWithPath(path string) error {
	if _bbad := _gdbg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bbad != nil {
		return _bbad
	}
	return nil
}
func (_acbg *CT_UpDownBar) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_dgda:
	for {
		_geecc, _addag := d.Token()
		if _addag != nil {
			return _addag
		}
		switch _fbefc := _geecc.(type) {
		case _fa.StartElement:
			switch _fbefc.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_acbg.SpPr = _cb.NewCT_ShapeProperties()
				if _eafg := d.DecodeElement(_acbg.SpPr, &_fbefc); _eafg != nil {
					return _eafg
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_UpDownBar\u0020\u0025v", _fbefc.Name)
				if _fcdad := d.Skip(); _fcdad != nil {
					return _fcdad
				}
			}
		case _fa.EndElement:
			break _dgda
		case _fa.CharData:
		}
	}
	return nil
}
func (_ecbfa *ST_SizeRepresents) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_cfaaa, _acafdc := d.Token()
	if _acafdc != nil {
		return _acafdc
	}
	if _gfaf, _cfdff := _cfaaa.(_fa.EndElement); _cfdff && _gfaf.Name == start.Name {
		*_ecbfa = 1
		return nil
	}
	if _eaad, _beaea := _cfaaa.(_fa.CharData); !_beaea {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cfaaa)
	} else {
		switch string(_eaad) {
		case "":
			*_ecbfa = 0
		case "area":
			*_ecbfa = 1
		case "w":
			*_ecbfa = 2
		}
	}
	_cfaaa, _acafdc = d.Token()
	if _acafdc != nil {
		return _acafdc
	}
	if _gbfff, _fagdf := _cfaaa.(_fa.EndElement); _fagdf && _gbfff.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cfaaa)
}
func NewCT_CrossBetween() *CT_CrossBetween {
	_bgec := &CT_CrossBetween{}
	_bgec.ValAttr = ST_CrossBetween(1)
	return _bgec
}

// ValidateWithPath validates the CT_DispUnits and its children, prefixing error messages with path
func (_efed *CT_DispUnits) ValidateWithPath(path string) error {
	if _efed.Choice != nil {
		if _bebe := _efed.Choice.ValidateWithPath(path + "\u002fChoice"); _bebe != nil {
			return _bebe
		}
	}
	if _efed.DispUnitsLbl != nil {
		if _fadf := _efed.DispUnitsLbl.ValidateWithPath(path + "\u002fDispUnitsLbl"); _fadf != nil {
			return _fadf
		}
	}
	if _efed.ExtLst != nil {
		if _faaa := _efed.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _faaa != nil {
			return _faaa
		}
	}
	return nil
}

type EG_AxShared struct {
	AxId           *CT_UnsignedInt
	Scaling        *CT_Scaling
	Delete         *CT_Boolean
	AxPos          *CT_AxPos
	MajorGridlines *CT_ChartLines
	MinorGridlines *CT_ChartLines
	Title          *CT_Title
	NumFmt         *CT_NumFmt
	MajorTickMark  *CT_TickMark
	MinorTickMark  *CT_TickMark
	TickLblPos     *CT_TickLblPos
	SpPr           *_cb.CT_ShapeProperties
	TxPr           *_cb.CT_TextBody
	CrossAx        *CT_UnsignedInt
	Choice         *EG_AxSharedChoice
}
type ST_BuiltInUnit byte

func (_accfc ST_BarDir) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_accfc.String(), start)
}

// Validate validates the CT_DoughnutChart and its children
func (_gece *CT_DoughnutChart) Validate() error { return _gece.ValidateWithPath("CT_DoughnutChart") }

// Validate validates the CT_ScatterSer and its children
func (_ebcf *CT_ScatterSer) Validate() error { return _ebcf.ValidateWithPath("CT_ScatterSer") }
func NewCT_NumRef() *CT_NumRef               { _ffgf := &CT_NumRef{}; return _ffgf }
func (_dadcd *CT_ScatterChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_dadcd.ScatterStyle = NewCT_ScatterStyle()
_eefff:
	for {
		_fbbdb, _ggegd := d.Token()
		if _ggegd != nil {
			return _ggegd
		}
		switch _bdcce := _fbbdb.(type) {
		case _fa.StartElement:
			switch _bdcce.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "scatterStyle"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "scatterStyle"}:
				if _dfefc := d.DecodeElement(_dadcd.ScatterStyle, &_bdcce); _dfefc != nil {
					return _dfefc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_dadcd.VaryColors = NewCT_Boolean()
				if _ddfdg := d.DecodeElement(_dadcd.VaryColors, &_bdcce); _ddfdg != nil {
					return _ddfdg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_ceced := NewCT_ScatterSer()
				if _cbacd := d.DecodeElement(_ceced, &_bdcce); _cbacd != nil {
					return _cbacd
				}
				_dadcd.Ser = append(_dadcd.Ser, _ceced)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_dadcd.DLbls = NewCT_DLbls()
				if _fecfe := d.DecodeElement(_dadcd.DLbls, &_bdcce); _fecfe != nil {
					return _fecfe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_fcfaa := NewCT_UnsignedInt()
				if _edfg := d.DecodeElement(_fcfaa, &_bdcce); _edfg != nil {
					return _edfg
				}
				_dadcd.AxId = append(_dadcd.AxId, _fcfaa)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_dadcd.ExtLst = NewCT_ExtensionList()
				if _efdd := d.DecodeElement(_dadcd.ExtLst, &_bdcce); _efdd != nil {
					return _efdd
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ScatterChart\u0020\u0025v", _bdcce.Name)
				if _cagfd := d.Skip(); _cagfd != nil {
					return _cagfd
				}
			}
		case _fa.EndElement:
			break _eefff
		case _fa.CharData:
		}
	}
	return nil
}

var ST_HPercentWithSymbolPatternRe = _g.MustCompile(ST_HPercentWithSymbolPattern)

func NewEG_LegendEntryData() *EG_LegendEntryData { _cedbd := &EG_LegendEntryData{}; return _cedbd }

type CT_StrData struct {
	PtCount *CT_UnsignedInt
	Pt      []*CT_StrVal
	ExtLst  *CT_ExtensionList
}

func (_gbcbf *CT_NumData) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_dbfc:
	for {
		_baddfc, _eafe := d.Token()
		if _eafe != nil {
			return _eafe
		}
		switch _gcafe := _baddfc.(type) {
		case _fa.StartElement:
			switch _gcafe.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "formatCode"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "formatCode"}:
				_gbcbf.FormatCode = new(string)
				if _dcee := d.DecodeElement(_gbcbf.FormatCode, &_gcafe); _dcee != nil {
					return _dcee
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ptCount"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ptCount"}:
				_gbcbf.PtCount = NewCT_UnsignedInt()
				if _bbea := d.DecodeElement(_gbcbf.PtCount, &_gcafe); _bbea != nil {
					return _bbea
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pt"}:
				_dbef := NewCT_NumVal()
				if _efdf := d.DecodeElement(_dbef, &_gcafe); _efdf != nil {
					return _efdf
				}
				_gbcbf.Pt = append(_gbcbf.Pt, _dbef)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_gbcbf.ExtLst = NewCT_ExtensionList()
				if _ceecc := d.DecodeElement(_gbcbf.ExtLst, &_gcafe); _ceecc != nil {
					return _ceecc
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_NumData\u0020\u0025v", _gcafe.Name)
				if _bdgee := d.Skip(); _bdgee != nil {
					return _bdgee
				}
			}
		case _fa.EndElement:
			break _dbfc
		case _fa.CharData:
		}
	}
	return nil
}
func (_eedcd *ST_DepthPercent) Validate() error { return _eedcd.ValidateWithPath("") }

// Validate validates the CT_DTable and its children
func (_bdag *CT_DTable) Validate() error { return _bdag.ValidateWithPath("CT_DTable") }

// Validate validates the CT_PivotFmt and its children
func (_efdfa *CT_PivotFmt) Validate() error { return _efdfa.ValidateWithPath("CT_PivotFmt") }

var ST_HoleSizePercentPatternRe = _g.MustCompile(ST_HoleSizePercentPattern)

type CT_BuiltInUnit struct{ ValAttr ST_BuiltInUnit }

// ValidateWithPath validates the CT_AxPos and its children, prefixing error messages with path
func (_edc *CT_AxPos) ValidateWithPath(path string) error {
	if _edc.ValAttr == ST_AxPosUnset {
		return _gg.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _ffc := _edc.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _ffc != nil {
		return _ffc
	}
	return nil
}
func (_dadfd ST_RadarStyle) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_bcfbf := _fa.Attr{}
	_bcfbf.Name = name
	switch _dadfd {
	case ST_RadarStyleUnset:
		_bcfbf.Value = ""
	case ST_RadarStyleStandard:
		_bcfbf.Value = "standard"
	case ST_RadarStyleMarker:
		_bcfbf.Value = "marker"
	case ST_RadarStyleFilled:
		_bcfbf.Value = "filled"
	}
	return _bcfbf, nil
}
func (_bdbdc *CT_PrintSettings) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_fcbb:
	for {
		_fbecg, _cdda := d.Token()
		if _cdda != nil {
			return _cdda
		}
		switch _gefac := _fbecg.(type) {
		case _fa.StartElement:
			switch _gefac.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "headerFooter"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "headerFooter"}:
				_bdbdc.HeaderFooter = NewCT_HeaderFooter()
				if _defbe := d.DecodeElement(_bdbdc.HeaderFooter, &_gefac); _defbe != nil {
					return _defbe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pageMargins"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pageMargins"}:
				_bdbdc.PageMargins = NewCT_PageMargins()
				if _cfcc := d.DecodeElement(_bdbdc.PageMargins, &_gefac); _cfcc != nil {
					return _cfcc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pageSetup"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pageSetup"}:
				_bdbdc.PageSetup = NewCT_PageSetup()
				if _ddefe := d.DecodeElement(_bdbdc.PageSetup, &_gefac); _ddefe != nil {
					return _ddefe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "legacyDrawingHF"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "legacyDrawingHF"}:
				_bdbdc.LegacyDrawingHF = NewCT_RelId()
				if _cgag := d.DecodeElement(_bdbdc.LegacyDrawingHF, &_gefac); _cgag != nil {
					return _cgag
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PrintSettings\u0020\u0025v", _gefac.Name)
				if _ggbeg := d.Skip(); _ggbeg != nil {
					return _ggbeg
				}
			}
		case _fa.EndElement:
			break _fcbb
		case _fa.CharData:
		}
	}
	return nil
}

const (
	ST_DispBlanksAsUnset ST_DispBlanksAs = 0
	ST_DispBlanksAsSpan  ST_DispBlanksAs = 1
	ST_DispBlanksAsGap   ST_DispBlanksAs = 2
	ST_DispBlanksAsZero  ST_DispBlanksAs = 3
)

func (_edcd ST_Crosses) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_edcd.String(), start)
}
func NewCT_LblAlgn() *CT_LblAlgn { _abdc := &CT_LblAlgn{}; _abdc.ValAttr = ST_LblAlgn(1); return _abdc }

// Validate validates the CT_SerAx and its children
func (_dccag *CT_SerAx) Validate() error { return _dccag.ValidateWithPath("CT_SerAx") }

// ValidateWithPath validates the EG_AxShared and its children, prefixing error messages with path
func (_eeebc *EG_AxShared) ValidateWithPath(path string) error {
	if _ebbfdg := _eeebc.AxId.ValidateWithPath(path + "\u002fAxId"); _ebbfdg != nil {
		return _ebbfdg
	}
	if _fgab := _eeebc.Scaling.ValidateWithPath(path + "\u002fScaling"); _fgab != nil {
		return _fgab
	}
	if _eeebc.Delete != nil {
		if _cgeg := _eeebc.Delete.ValidateWithPath(path + "\u002fDelete"); _cgeg != nil {
			return _cgeg
		}
	}
	if _agbbce := _eeebc.AxPos.ValidateWithPath(path + "\u002fAxPos"); _agbbce != nil {
		return _agbbce
	}
	if _eeebc.MajorGridlines != nil {
		if _gebcb := _eeebc.MajorGridlines.ValidateWithPath(path + "\u002fMajorGridlines"); _gebcb != nil {
			return _gebcb
		}
	}
	if _eeebc.MinorGridlines != nil {
		if _agdd := _eeebc.MinorGridlines.ValidateWithPath(path + "\u002fMinorGridlines"); _agdd != nil {
			return _agdd
		}
	}
	if _eeebc.Title != nil {
		if _gedba := _eeebc.Title.ValidateWithPath(path + "\u002fTitle"); _gedba != nil {
			return _gedba
		}
	}
	if _eeebc.NumFmt != nil {
		if _ffedd := _eeebc.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _ffedd != nil {
			return _ffedd
		}
	}
	if _eeebc.MajorTickMark != nil {
		if _ffbcd := _eeebc.MajorTickMark.ValidateWithPath(path + "\u002fMajorTickMark"); _ffbcd != nil {
			return _ffbcd
		}
	}
	if _eeebc.MinorTickMark != nil {
		if _dbgfa := _eeebc.MinorTickMark.ValidateWithPath(path + "\u002fMinorTickMark"); _dbgfa != nil {
			return _dbgfa
		}
	}
	if _eeebc.TickLblPos != nil {
		if _gdeeb := _eeebc.TickLblPos.ValidateWithPath(path + "/TickLblPos"); _gdeeb != nil {
			return _gdeeb
		}
	}
	if _eeebc.SpPr != nil {
		if _dadgc := _eeebc.SpPr.ValidateWithPath(path + "\u002fSpPr"); _dadgc != nil {
			return _dadgc
		}
	}
	if _eeebc.TxPr != nil {
		if _dcafbb := _eeebc.TxPr.ValidateWithPath(path + "\u002fTxPr"); _dcafbb != nil {
			return _dcafbb
		}
	}
	if _ffbe := _eeebc.CrossAx.ValidateWithPath(path + "\u002fCrossAx"); _ffbe != nil {
		return _ffbe
	}
	if _eeebc.Choice != nil {
		if _bbag := _eeebc.Choice.ValidateWithPath(path + "\u002fChoice"); _bbag != nil {
			return _bbag
		}
	}
	return nil
}

// Validate validates the CT_BarDir and its children
func (_dcdf *CT_BarDir) Validate() error { return _dcdf.ValidateWithPath("CT_BarDir") }

// ValidateWithPath validates the CT_DispUnitsLbl and its children, prefixing error messages with path
func (_dddbe *CT_DispUnitsLbl) ValidateWithPath(path string) error {
	if _dddbe.Layout != nil {
		if _dbaef := _dddbe.Layout.ValidateWithPath(path + "\u002fLayout"); _dbaef != nil {
			return _dbaef
		}
	}
	if _dddbe.Tx != nil {
		if _dcbbg := _dddbe.Tx.ValidateWithPath(path + "\u002fTx"); _dcbbg != nil {
			return _dcbbg
		}
	}
	if _dddbe.SpPr != nil {
		if _gfce := _dddbe.SpPr.ValidateWithPath(path + "\u002fSpPr"); _gfce != nil {
			return _gfce
		}
	}
	if _dddbe.TxPr != nil {
		if _dfgeg := _dddbe.TxPr.ValidateWithPath(path + "\u002fTxPr"); _dfgeg != nil {
			return _dfgeg
		}
	}
	return nil
}
func (_caaed ST_SplitType) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_caaed.String(), start)
}
func (_agaef *CT_ErrBars) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _agaef.ErrDir != nil {
		_cgdc := _fa.StartElement{Name: _fa.Name{Local: "c:errDir"}}
		e.EncodeElement(_agaef.ErrDir, _cgdc)
	}
	_aedeg := _fa.StartElement{Name: _fa.Name{Local: "c:errBarType"}}
	e.EncodeElement(_agaef.ErrBarType, _aedeg)
	_aged := _fa.StartElement{Name: _fa.Name{Local: "c:errValType"}}
	e.EncodeElement(_agaef.ErrValType, _aged)
	if _agaef.NoEndCap != nil {
		_eggb := _fa.StartElement{Name: _fa.Name{Local: "c:noEndCap"}}
		e.EncodeElement(_agaef.NoEndCap, _eggb)
	}
	if _agaef.Plus != nil {
		_ggeg := _fa.StartElement{Name: _fa.Name{Local: "c:plus"}}
		e.EncodeElement(_agaef.Plus, _ggeg)
	}
	if _agaef.Minus != nil {
		_bgdg := _fa.StartElement{Name: _fa.Name{Local: "c:minus"}}
		e.EncodeElement(_agaef.Minus, _bgdg)
	}
	if _agaef.Val != nil {
		_ageeb := _fa.StartElement{Name: _fa.Name{Local: "c:val"}}
		e.EncodeElement(_agaef.Val, _ageeb)
	}
	if _agaef.SpPr != nil {
		_fdg := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_agaef.SpPr, _fdg)
	}
	if _agaef.ExtLst != nil {
		_gefa := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_agaef.ExtLst, _gefa)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_feg *CT_BarGrouping) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _feg.ValAttr != ST_BarGroupingUnset {
		_fgbg, _fcfa := _feg.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _fcfa != nil {
			return _fcfa
		}
		start.Attr = append(start.Attr, _fgbg)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_eacae ST_TrendlineType) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_ebaba := _fa.Attr{}
	_ebaba.Name = name
	switch _eacae {
	case ST_TrendlineTypeUnset:
		_ebaba.Value = ""
	case ST_TrendlineTypeExp:
		_ebaba.Value = "exp"
	case ST_TrendlineTypeLinear:
		_ebaba.Value = "linear"
	case ST_TrendlineTypeLog:
		_ebaba.Value = "log"
	case ST_TrendlineTypeMovingAvg:
		_ebaba.Value = "movingAvg"
	case ST_TrendlineTypePoly:
		_ebaba.Value = "poly"
	case ST_TrendlineTypePower:
		_ebaba.Value = "power"
	}
	return _ebaba, nil
}
func (_aggdc *CT_SizeRepresents) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _dgabd := range start.Attr {
		if _dgabd.Name.Local == "val" {
			_aggdc.ValAttr.UnmarshalXMLAttr(_dgabd)
			continue
		}
	}
	for {
		_gfcbb, _gffcac := d.Token()
		if _gffcac != nil {
			return _gg.Errorf("parsing\u0020CT_SizeRepresents: \u0025s", _gffcac)
		}
		if _aeaf, _gbbbd := _gfcbb.(_fa.EndElement); _gbbbd && _aeaf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dbgba *ST_ScatterStyle) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ggeec, _bedgg := d.Token()
	if _bedgg != nil {
		return _bedgg
	}
	if _efedg, _abfca := _ggeec.(_fa.EndElement); _abfca && _efedg.Name == start.Name {
		*_dbgba = 1
		return nil
	}
	if _ddgeb, _fdgba := _ggeec.(_fa.CharData); !_fdgba {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ggeec)
	} else {
		switch string(_ddgeb) {
		case "":
			*_dbgba = 0
		case "none":
			*_dbgba = 1
		case "line":
			*_dbgba = 2
		case "lineMarker":
			*_dbgba = 3
		case "marker":
			*_dbgba = 4
		case "smooth":
			*_dbgba = 5
		case "smoothMarker":
			*_dbgba = 6
		}
	}
	_ggeec, _bedgg = d.Token()
	if _bedgg != nil {
		return _bedgg
	}
	if _aagbe, _ccbdc := _ggeec.(_fa.EndElement); _ccbdc && _aagbe.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ggeec)
}
func (_efgdg ST_TrendlineType) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_efgdg.String(), start)
}
func (_eecfg *EG_AreaChartShared) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _eecfg.Grouping != nil {
		_gcggb := _fa.StartElement{Name: _fa.Name{Local: "c:grouping"}}
		e.EncodeElement(_eecfg.Grouping, _gcggb)
	}
	if _eecfg.VaryColors != nil {
		_ecggf := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_eecfg.VaryColors, _ecggf)
	}
	if _eecfg.Ser != nil {
		_gaegf := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _bafb := range _eecfg.Ser {
			e.EncodeElement(_bafb, _gaegf)
		}
	}
	if _eecfg.DLbls != nil {
		_gdabc := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_eecfg.DLbls, _gdabc)
	}
	if _eecfg.DropLines != nil {
		_gafbf := _fa.StartElement{Name: _fa.Name{Local: "c:dropLines"}}
		e.EncodeElement(_eecfg.DropLines, _gafbf)
	}
	return nil
}
func (_dcded *CT_SplitType) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _fdffb := range start.Attr {
		if _fdffb.Name.Local == "val" {
			_dcded.ValAttr.UnmarshalXMLAttr(_fdffb)
			continue
		}
	}
	for {
		_gfdfg, _bacaa := d.Token()
		if _bacaa != nil {
			return _gg.Errorf("parsing\u0020CT_SplitType:\u0020\u0025s", _bacaa)
		}
		if _bfba, _efbee := _gfdfg.(_fa.EndElement); _efbee && _bfba.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cbdc *ST_RadarStyle) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_cbdc = 0
	case "standard":
		*_cbdc = 1
	case "marker":
		*_cbdc = 2
	case "filled":
		*_cbdc = 3
	}
	return nil
}
func (_afge *CT_SizeRepresents) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _afge.ValAttr != ST_SizeRepresentsUnset {
		_bcagc, _eaeab := _afge.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _eaeab != nil {
			return _eaeab
		}
		start.Attr = append(start.Attr, _bcagc)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_deeag *Group_DLbl) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _deeag.Layout != nil {
		_ddgegb := _fa.StartElement{Name: _fa.Name{Local: "c:layout"}}
		e.EncodeElement(_deeag.Layout, _ddgegb)
	}
	if _deeag.Tx != nil {
		_gffg := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_deeag.Tx, _gffg)
	}
	if _deeag.NumFmt != nil {
		_cbbfe := _fa.StartElement{Name: _fa.Name{Local: "c:numFmt"}}
		e.EncodeElement(_deeag.NumFmt, _cbbfe)
	}
	if _deeag.SpPr != nil {
		_gebgcb := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_deeag.SpPr, _gebgcb)
	}
	if _deeag.TxPr != nil {
		_afcea := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_deeag.TxPr, _afcea)
	}
	if _deeag.DLblPos != nil {
		_ccba := _fa.StartElement{Name: _fa.Name{Local: "c:dLblPos"}}
		e.EncodeElement(_deeag.DLblPos, _ccba)
	}
	if _deeag.ShowLegendKey != nil {
		_faegf := _fa.StartElement{Name: _fa.Name{Local: "c:showLegendKey"}}
		e.EncodeElement(_deeag.ShowLegendKey, _faegf)
	}
	if _deeag.ShowVal != nil {
		_debda := _fa.StartElement{Name: _fa.Name{Local: "c:showVal"}}
		e.EncodeElement(_deeag.ShowVal, _debda)
	}
	if _deeag.ShowCatName != nil {
		_adcaa := _fa.StartElement{Name: _fa.Name{Local: "c:showCatName"}}
		e.EncodeElement(_deeag.ShowCatName, _adcaa)
	}
	if _deeag.ShowSerName != nil {
		_acdbd := _fa.StartElement{Name: _fa.Name{Local: "c:showSerName"}}
		e.EncodeElement(_deeag.ShowSerName, _acdbd)
	}
	if _deeag.ShowPercent != nil {
		_aaadb := _fa.StartElement{Name: _fa.Name{Local: "c:showPercent"}}
		e.EncodeElement(_deeag.ShowPercent, _aaadb)
	}
	if _deeag.ShowBubbleSize != nil {
		_bacfc := _fa.StartElement{Name: _fa.Name{Local: "c:showBubbleSize"}}
		e.EncodeElement(_deeag.ShowBubbleSize, _bacfc)
	}
	if _deeag.Separator != nil {
		_efabd := _fa.StartElement{Name: _fa.Name{Local: "c:separator"}}
		_b.AddPreserveSpaceAttr(&_efabd, *_deeag.Separator)
		e.EncodeElement(_deeag.Separator, _efabd)
	}
	return nil
}

// Validate validates the CT_AxDataSource and its children
func (_bbc *CT_AxDataSource) Validate() error { return _bbc.ValidateWithPath("CT_AxDataSource") }
func (_acgde ST_DispBlanksAs) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_acgde.String(), start)
}
func (_ebbe *CT_SurfaceChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _ebbe.Wireframe != nil {
		_cbcgg := _fa.StartElement{Name: _fa.Name{Local: "c:wireframe"}}
		e.EncodeElement(_ebbe.Wireframe, _cbcgg)
	}
	if _ebbe.Ser != nil {
		_ffcb := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _fggfa := range _ebbe.Ser {
			e.EncodeElement(_fggfa, _ffcb)
		}
	}
	if _ebbe.BandFmts != nil {
		_egcgc := _fa.StartElement{Name: _fa.Name{Local: "c:bandFmts"}}
		e.EncodeElement(_ebbe.BandFmts, _egcgc)
	}
	_feceg := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _ebegd := range _ebbe.AxId {
		e.EncodeElement(_ebegd, _feceg)
	}
	if _ebbe.ExtLst != nil {
		_feaca := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_ebbe.ExtLst, _feaca)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_acbfgd *ST_OfPieType) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_acbfgd = 0
	case "pie":
		*_acbfgd = 1
	case "bar":
		*_acbfgd = 2
	}
	return nil
}
func NewCT_SecondPieSize() *CT_SecondPieSize { _cgead := &CT_SecondPieSize{}; return _cgead }
func (_agcbd ST_Crosses) Validate() error    { return _agcbd.ValidateWithPath("") }
func (_aabda ST_ErrBarType) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_aabda.String(), start)
}

type CT_DispUnits struct {
	Choice       *CT_DispUnitsChoice
	DispUnitsLbl *CT_DispUnitsLbl
	ExtLst       *CT_ExtensionList
}

// ValidateWithPath validates the EG_BarChartShared and its children, prefixing error messages with path
func (_cbcabe *EG_BarChartShared) ValidateWithPath(path string) error {
	if _dcege := _cbcabe.BarDir.ValidateWithPath(path + "\u002fBarDir"); _dcege != nil {
		return _dcege
	}
	if _cbcabe.Grouping != nil {
		if _dccaf := _cbcabe.Grouping.ValidateWithPath(path + "\u002fGrouping"); _dccaf != nil {
			return _dccaf
		}
	}
	if _cbcabe.VaryColors != nil {
		if _egge := _cbcabe.VaryColors.ValidateWithPath(path + "/VaryColors"); _egge != nil {
			return _egge
		}
	}
	for _dfgbdf, _gcaag := range _cbcabe.Ser {
		if _ebgf := _gcaag.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _dfgbdf)); _ebgf != nil {
			return _ebgf
		}
	}
	if _cbcabe.DLbls != nil {
		if _ffcd := _cbcabe.DLbls.ValidateWithPath(path + "\u002fDLbls"); _ffcd != nil {
			return _ffcd
		}
	}
	return nil
}
func (_bcgd *CT_Double) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _gdef := range start.Attr {
		if _gdef.Name.Local == "val" {
			_cabeg, _dbbd := _c.ParseFloat(_gdef.Value, 64)
			if _dbbd != nil {
				return _dbbd
			}
			_bcgd.ValAttr = _cabeg
			continue
		}
	}
	for {
		_acba, _caacd := d.Token()
		if _caacd != nil {
			return _gg.Errorf("parsing\u0020CT_Double:\u0020\u0025s", _caacd)
		}
		if _cbca, _bacg := _acba.(_fa.EndElement); _bacg && _cbca.Name == start.Name {
			break
		}
	}
	return nil
}

var ST_DepthPercentWithSymbolPatternRe = _g.MustCompile(ST_DepthPercentWithSymbolPattern)

type ST_LayoutTarget byte

func (_fefaf ST_PageSetupOrientation) Validate() error { return _fefaf.ValidateWithPath("") }
func (_cegb *CT_HoleSize) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _cegb.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_cegb.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_eafa *CT_DispBlanksAs) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _eafa.ValAttr != ST_DispBlanksAsUnset {
		_agfd, _gafc := _eafa.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _gafc != nil {
			return _gafc
		}
		start.Attr = append(start.Attr, _agfd)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type ST_DispBlanksAs byte
type CT_HoleSize struct{ ValAttr *ST_HoleSize }
type CT_DPt struct {
	Idx              *CT_UnsignedInt
	InvertIfNegative *CT_Boolean
	Marker           *CT_Marker
	Bubble3D         *CT_Boolean
	Explosion        *CT_UnsignedInt
	SpPr             *_cb.CT_ShapeProperties
	PictureOptions   *CT_PictureOptions
	ExtLst           *CT_ExtensionList
}
type CT_LegendEntryChoice struct {
	Delete *CT_Boolean
	TxPr   *_cb.CT_TextBody
}

func NewEG_AreaChartShared() *EG_AreaChartShared { _egddg := &EG_AreaChartShared{}; return _egddg }
func NewCT_Orientation() *CT_Orientation         { _agdgg := &CT_Orientation{}; return _agdgg }
func (_ebaee *ST_DLblPos) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_ebaee = 0
	case "bestFit":
		*_ebaee = 1
	case "b":
		*_ebaee = 2
	case "ctr":
		*_ebaee = 3
	case "inBase":
		*_ebaee = 4
	case "inEnd":
		*_ebaee = 5
	case "l":
		*_ebaee = 6
	case "outEnd":
		*_ebaee = 7
	case "r":
		*_ebaee = 8
	case "t":
		*_ebaee = 9
	}
	return nil
}
func (_afca *CT_ManualLayout) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _afca.LayoutTarget != nil {
		_edcab := _fa.StartElement{Name: _fa.Name{Local: "c:layoutTarget"}}
		e.EncodeElement(_afca.LayoutTarget, _edcab)
	}
	if _afca.XMode != nil {
		_gbffd := _fa.StartElement{Name: _fa.Name{Local: "c:xMode"}}
		e.EncodeElement(_afca.XMode, _gbffd)
	}
	if _afca.YMode != nil {
		_afg := _fa.StartElement{Name: _fa.Name{Local: "c:yMode"}}
		e.EncodeElement(_afca.YMode, _afg)
	}
	if _afca.WMode != nil {
		_cbga := _fa.StartElement{Name: _fa.Name{Local: "c:wMode"}}
		e.EncodeElement(_afca.WMode, _cbga)
	}
	if _afca.HMode != nil {
		_abbee := _fa.StartElement{Name: _fa.Name{Local: "c:hMode"}}
		e.EncodeElement(_afca.HMode, _abbee)
	}
	if _afca.X != nil {
		_ddgga := _fa.StartElement{Name: _fa.Name{Local: "c:x"}}
		e.EncodeElement(_afca.X, _ddgga)
	}
	if _afca.Y != nil {
		_cgddb := _fa.StartElement{Name: _fa.Name{Local: "c:y"}}
		e.EncodeElement(_afca.Y, _cgddb)
	}
	if _afca.W != nil {
		_gdec := _fa.StartElement{Name: _fa.Name{Local: "c:w"}}
		e.EncodeElement(_afca.W, _gdec)
	}
	if _afca.H != nil {
		_ccgf := _fa.StartElement{Name: _fa.Name{Local: "c:h"}}
		e.EncodeElement(_afca.H, _ccgf)
	}
	if _afca.ExtLst != nil {
		_fbagb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_afca.ExtLst, _fbagb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_Overlap() *CT_Overlap { _adge := &CT_Overlap{}; return _adge }

// Validate validates the Group_DLbls and its children
func (_ffdge *Group_DLbls) Validate() error { return _ffdge.ValidateWithPath("Group_DLbls") }

const (
	ST_CrossesUnset    ST_Crosses = 0
	ST_CrossesAutoZero ST_Crosses = 1
	ST_CrossesMax      ST_Crosses = 2
	ST_CrossesMin      ST_Crosses = 3
)

func (_gcfa ST_OfPieType) ValidateWithPath(path string) error {
	switch _gcfa {
	case 0, 1, 2:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gcfa))
	}
	return nil
}

type CT_MarkerStyle struct{ ValAttr ST_MarkerStyle }

// ValidateWithPath validates the CT_Surface3DChart and its children, prefixing error messages with path
func (_bdecd *CT_Surface3DChart) ValidateWithPath(path string) error {
	if _bdecd.Wireframe != nil {
		if _bdcaa := _bdecd.Wireframe.ValidateWithPath(path + "\u002fWireframe"); _bdcaa != nil {
			return _bdcaa
		}
	}
	for _ffgga, _gdbcdg := range _bdecd.Ser {
		if _aaegg := _gdbcdg.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _ffgga)); _aaegg != nil {
			return _aaegg
		}
	}
	if _bdecd.BandFmts != nil {
		if _abdce := _bdecd.BandFmts.ValidateWithPath(path + "\u002fBandFmts"); _abdce != nil {
			return _abdce
		}
	}
	for _gcgfg, _acfc := range _bdecd.AxId {
		if _gcgeb := _acfc.ValidateWithPath(_gg.Sprintf("%s\u002fAxId\u005b\u0025d\u005d", path, _gcgfg)); _gcgeb != nil {
			return _gcgeb
		}
	}
	if _bdecd.ExtLst != nil {
		if _fdcgg := _bdecd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fdcgg != nil {
			return _fdcgg
		}
	}
	return nil
}
func NewCT_Surface() *CT_Surface { _gbceb := &CT_Surface{}; return _gbceb }
func NewCT_Layout() *CT_Layout   { _caca := &CT_Layout{}; return _caca }

type CT_LayoutMode struct{ ValAttr ST_LayoutMode }

func NewCT_CustSplit() *CT_CustSplit { _ccbc := &CT_CustSplit{}; return _ccbc }

// Validate validates the CT_NumDataSourceChoice and its children
func (_cgcc *CT_NumDataSourceChoice) Validate() error {
	return _cgcc.ValidateWithPath("CT_NumDataSourceChoice")
}

// ValidateWithPath validates the CT_SecondPieSize and its children, prefixing error messages with path
func (_gcac *CT_SecondPieSize) ValidateWithPath(path string) error {
	if _gcac.ValAttr != nil {
		if _cgee := _gcac.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _cgee != nil {
			return _cgee
		}
	}
	return nil
}
func NewCT_PageSetup() *CT_PageSetup { _bfda := &CT_PageSetup{}; return _bfda }
func (_aegea *CT_StrData) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_egeed:
	for {
		_afad, _aedb := d.Token()
		if _aedb != nil {
			return _aedb
		}
		switch _bebf := _afad.(type) {
		case _fa.StartElement:
			switch _bebf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ptCount"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ptCount"}:
				_aegea.PtCount = NewCT_UnsignedInt()
				if _edbbf := d.DecodeElement(_aegea.PtCount, &_bebf); _edbbf != nil {
					return _edbbf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "pt"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "pt"}:
				_cgdcg := NewCT_StrVal()
				if _dcbdbb := d.DecodeElement(_cgdcg, &_bebf); _dcbdbb != nil {
					return _dcbdbb
				}
				_aegea.Pt = append(_aegea.Pt, _cgdcg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_aegea.ExtLst = NewCT_ExtensionList()
				if _fegad := d.DecodeElement(_aegea.ExtLst, &_bebf); _fegad != nil {
					return _fegad
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_StrData\u0020\u0025v", _bebf.Name)
				if _defd := d.Skip(); _defd != nil {
					return _defd
				}
			}
		case _fa.EndElement:
			break _egeed
		case _fa.CharData:
		}
	}
	return nil
}

// Validate validates the CT_PlotArea and its children
func (_ecffa *CT_PlotArea) Validate() error { return _ecffa.ValidateWithPath("CT_PlotArea") }

// ValidateWithPath validates the CT_RadarSer and its children, prefixing error messages with path
func (_ggage *CT_RadarSer) ValidateWithPath(path string) error {
	if _ggaag := _ggage.Idx.ValidateWithPath(path + "\u002fIdx"); _ggaag != nil {
		return _ggaag
	}
	if _fgaf := _ggage.Order.ValidateWithPath(path + "\u002fOrder"); _fgaf != nil {
		return _fgaf
	}
	if _ggage.Tx != nil {
		if _gfac := _ggage.Tx.ValidateWithPath(path + "\u002fTx"); _gfac != nil {
			return _gfac
		}
	}
	if _ggage.SpPr != nil {
		if _afbe := _ggage.SpPr.ValidateWithPath(path + "\u002fSpPr"); _afbe != nil {
			return _afbe
		}
	}
	if _ggage.Marker != nil {
		if _gcdec := _ggage.Marker.ValidateWithPath(path + "\u002fMarker"); _gcdec != nil {
			return _gcdec
		}
	}
	for _dceb, _dbbb := range _ggage.DPt {
		if _degc := _dbbb.ValidateWithPath(_gg.Sprintf("\u0025s\u002fDPt\u005b\u0025d\u005d", path, _dceb)); _degc != nil {
			return _degc
		}
	}
	if _ggage.DLbls != nil {
		if _dbdbe := _ggage.DLbls.ValidateWithPath(path + "\u002fDLbls"); _dbdbe != nil {
			return _dbdbe
		}
	}
	if _ggage.Cat != nil {
		if _bgacc := _ggage.Cat.ValidateWithPath(path + "\u002fCat"); _bgacc != nil {
			return _bgacc
		}
	}
	if _ggage.Val != nil {
		if _egef := _ggage.Val.ValidateWithPath(path + "\u002fVal"); _egef != nil {
			return _egef
		}
	}
	if _ggage.ExtLst != nil {
		if _bbaa := _ggage.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bbaa != nil {
			return _bbaa
		}
	}
	return nil
}
func (_fgadf *CT_UpDownBar) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _fgadf.SpPr != nil {
		_feaae := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_fgadf.SpPr, _feaae)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type ST_ScatterStyle byte

func (_efef *CT_PlotArea) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _efef.Layout != nil {
		_bceag := _fa.StartElement{Name: _fa.Name{Local: "c:layout"}}
		e.EncodeElement(_efef.Layout, _bceag)
	}
	for _, _gedca := range _efef.Choice {
		_gedca.MarshalXML(e, _fa.StartElement{})
	}
	if _efef.CChoice != nil {
		_efef.CChoice.MarshalXML(e, _fa.StartElement{})
	}
	if _efef.DTable != nil {
		_edbg := _fa.StartElement{Name: _fa.Name{Local: "c:dTable"}}
		e.EncodeElement(_efef.DTable, _edbg)
	}
	if _efef.SpPr != nil {
		_bgba := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_efef.SpPr, _bgba)
	}
	if _efef.ExtLst != nil {
		_egfaf := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_efef.ExtLst, _egfaf)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Layout and its children
func (_geabg *CT_Layout) Validate() error { return _geabg.ValidateWithPath("CT_Layout") }
func NewCT_ScatterChart() *CT_ScatterChart {
	_gdba := &CT_ScatterChart{}
	_gdba.ScatterStyle = NewCT_ScatterStyle()
	return _gdba
}
func (_bfdee ST_AxPos) ValidateWithPath(path string) error {
	switch _bfdee {
	case 0, 1, 2, 3, 4:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bfdee))
	}
	return nil
}
func NewCT_RadarSer() *CT_RadarSer {
	_bfcbg := &CT_RadarSer{}
	_bfcbg.Idx = NewCT_UnsignedInt()
	_bfcbg.Order = NewCT_UnsignedInt()
	return _bfcbg
}

type CT_NumFmt struct {
	FormatCodeAttr   string
	SourceLinkedAttr *bool
}

func (_eebgb *CT_PlotAreaChoice1) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _eebgb.ValAx != nil {
		_fbfbg := _fa.StartElement{Name: _fa.Name{Local: "c:valAx"}}
		for _, _ceedaa := range _eebgb.ValAx {
			e.EncodeElement(_ceedaa, _fbfbg)
		}
	}
	if _eebgb.CatAx != nil {
		_fadba := _fa.StartElement{Name: _fa.Name{Local: "c:catAx"}}
		for _, _bfgab := range _eebgb.CatAx {
			e.EncodeElement(_bfgab, _fadba)
		}
	}
	if _eebgb.DateAx != nil {
		_bdcfa := _fa.StartElement{Name: _fa.Name{Local: "c:dateAx"}}
		for _, _agba := range _eebgb.DateAx {
			e.EncodeElement(_agba, _bdcfa)
		}
	}
	if _eebgb.SerAx != nil {
		_daeef := _fa.StartElement{Name: _fa.Name{Local: "c:serAx"}}
		for _, _gccdc := range _eebgb.SerAx {
			e.EncodeElement(_gccdc, _daeef)
		}
	}
	return nil
}
func NewCT_TrendlineLbl() *CT_TrendlineLbl { _caafb := &CT_TrendlineLbl{}; return _caafb }
func (_afegb ST_BuiltInUnit) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_afegb.String(), start)
}
func (_gaef ST_TrendlineType) String() string {
	switch _gaef {
	case 0:
		return ""
	case 1:
		return "exp"
	case 2:
		return "linear"
	case 3:
		return "log"
	case 4:
		return "movingAvg"
	case 5:
		return "poly"
	case 6:
		return "power"
	}
	return ""
}
func (_dfbef *ST_GapAmount) Validate() error { return _dfbef.ValidateWithPath("") }

type ST_TickLblPos byte

func (_fgdbf *ST_AxPos) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_fgdbf = 0
	case "b":
		*_fgdbf = 1
	case "l":
		*_fgdbf = 2
	case "r":
		*_fgdbf = 3
	case "t":
		*_fgdbf = 4
	}
	return nil
}

type CT_FirstSliceAng struct{ ValAttr *uint16 }

func NewCT_SerTx() *CT_SerTx { _cccf := &CT_SerTx{}; _cccf.Choice = NewCT_SerTxChoice(); return _cccf }
func NewCT_RotY() *CT_RotY   { _bdceb := &CT_RotY{}; return _bdceb }
func (_dgfed ST_Crosses) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_dggec := _fa.Attr{}
	_dggec.Name = name
	switch _dgfed {
	case ST_CrossesUnset:
		_dggec.Value = ""
	case ST_CrossesAutoZero:
		_dggec.Value = "autoZero"
	case ST_CrossesMax:
		_dggec.Value = "max"
	case ST_CrossesMin:
		_dggec.Value = "min"
	}
	return _dggec, nil
}
func NewCT_Trendline() *CT_Trendline {
	_fgfcf := &CT_Trendline{}
	_fgfcf.TrendlineType = NewCT_TrendlineType()
	return _fgfcf
}
func NewCT_DLblPos() *CT_DLblPos { _dcfd := &CT_DLblPos{}; _dcfd.ValAttr = ST_DLblPos(1); return _dcfd }

// ValidateWithPath validates the CT_TimeUnit and its children, prefixing error messages with path
func (_bffdf *CT_TimeUnit) ValidateWithPath(path string) error {
	if _agce := _bffdf.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _agce != nil {
		return _agce
	}
	return nil
}
func (_ebeg *CT_DispBlanksAs) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _deff := range start.Attr {
		if _deff.Name.Local == "val" {
			_ebeg.ValAttr.UnmarshalXMLAttr(_deff)
			continue
		}
	}
	for {
		_baff, _beec := d.Token()
		if _beec != nil {
			return _gg.Errorf("parsing CT_DispBlanksAs:\u0020\u0025s", _beec)
		}
		if _fccee, _fbda := _baff.(_fa.EndElement); _fbda && _fccee.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the EG_PieChartShared and its children
func (_dcceg *EG_PieChartShared) Validate() error {
	return _dcceg.ValidateWithPath("EG_PieChartShared")
}

type CT_LblOffset struct{ ValAttr *ST_LblOffset }

func (_fabg ST_LayoutTarget) ValidateWithPath(path string) error {
	switch _fabg {
	case 0, 1, 2:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fabg))
	}
	return nil
}

type CT_MarkerSize struct{ ValAttr *uint8 }
type ST_Shape byte

func (_acebe *EG_AxShared) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_cadbc := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	e.EncodeElement(_acebe.AxId, _cadbc)
	_fgcab := _fa.StartElement{Name: _fa.Name{Local: "c:scaling"}}
	e.EncodeElement(_acebe.Scaling, _fgcab)
	if _acebe.Delete != nil {
		_dada := _fa.StartElement{Name: _fa.Name{Local: "c:delete"}}
		e.EncodeElement(_acebe.Delete, _dada)
	}
	_cecd := _fa.StartElement{Name: _fa.Name{Local: "c:axPos"}}
	e.EncodeElement(_acebe.AxPos, _cecd)
	if _acebe.MajorGridlines != nil {
		_edce := _fa.StartElement{Name: _fa.Name{Local: "c:majorGridlines"}}
		e.EncodeElement(_acebe.MajorGridlines, _edce)
	}
	if _acebe.MinorGridlines != nil {
		_ceff := _fa.StartElement{Name: _fa.Name{Local: "c:minorGridlines"}}
		e.EncodeElement(_acebe.MinorGridlines, _ceff)
	}
	if _acebe.Title != nil {
		_cebfd := _fa.StartElement{Name: _fa.Name{Local: "c:title"}}
		e.EncodeElement(_acebe.Title, _cebfd)
	}
	if _acebe.NumFmt != nil {
		_bdbdcgd := _fa.StartElement{Name: _fa.Name{Local: "c:numFmt"}}
		e.EncodeElement(_acebe.NumFmt, _bdbdcgd)
	}
	if _acebe.MajorTickMark != nil {
		_cbaccg := _fa.StartElement{Name: _fa.Name{Local: "c:majorTickMark"}}
		e.EncodeElement(_acebe.MajorTickMark, _cbaccg)
	}
	if _acebe.MinorTickMark != nil {
		_gacfe := _fa.StartElement{Name: _fa.Name{Local: "c:minorTickMark"}}
		e.EncodeElement(_acebe.MinorTickMark, _gacfe)
	}
	if _acebe.TickLblPos != nil {
		_ebbbb := _fa.StartElement{Name: _fa.Name{Local: "c:tickLblPos"}}
		e.EncodeElement(_acebe.TickLblPos, _ebbbb)
	}
	if _acebe.SpPr != nil {
		_ebcgg := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_acebe.SpPr, _ebcgg)
	}
	if _acebe.TxPr != nil {
		_badcb := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_acebe.TxPr, _badcb)
	}
	_gcedf := _fa.StartElement{Name: _fa.Name{Local: "c:crossAx"}}
	e.EncodeElement(_acebe.CrossAx, _gcedf)
	if _acebe.Choice != nil {
		_acebe.Choice.MarshalXML(e, _fa.StartElement{})
	}
	return nil
}
func ParseUnionST_HPercent(s string) (ST_HPercent, error) {
	if ST_HPercentWithSymbolPatternRe.MatchString(s) {
		return ST_HPercent{ST_HPercentWithSymbol: &s}, nil
	}
	_begfef, _adfa := _c.ParseUint(s, 10, 16)
	if _adfa != nil {
		return ST_HPercent{}, _adfa
	}
	_bfcc := uint16(_begfef)
	return ST_HPercent{ST_HPercentUShort: &_bfcc}, nil
}
func (_egeea *CT_Title) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _egeea.Tx != nil {
		_gdggfd := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_egeea.Tx, _gdggfd)
	}
	if _egeea.Layout != nil {
		_gdcff := _fa.StartElement{Name: _fa.Name{Local: "c:layout"}}
		e.EncodeElement(_egeea.Layout, _gdcff)
	}
	if _egeea.Overlay != nil {
		_efggc := _fa.StartElement{Name: _fa.Name{Local: "c:overlay"}}
		e.EncodeElement(_egeea.Overlay, _efggc)
	}
	if _egeea.SpPr != nil {
		_adgda := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_egeea.SpPr, _adgda)
	}
	if _egeea.TxPr != nil {
		_fbgfa := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_egeea.TxPr, _fbgfa)
	}
	if _egeea.ExtLst != nil {
		_efegc := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_egeea.ExtLst, _efegc)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func NewCT_View3D() *CT_View3D { _gadbb := &CT_View3D{}; return _gadbb }

// Validate validates the CT_UnsignedInt and its children
func (_fgeag *CT_UnsignedInt) Validate() error { return _fgeag.ValidateWithPath("CT_UnsignedInt") }

// Validate validates the CT_NumDataSource and its children
func (_cdgde *CT_NumDataSource) Validate() error { return _cdgde.ValidateWithPath("CT_NumDataSource") }
func NewCT_PrintSettings() *CT_PrintSettings     { _deag := &CT_PrintSettings{}; return _deag }
func (_edee *CT_Bar3DChart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_bdff := _fa.StartElement{Name: _fa.Name{Local: "c:barDir"}}
	e.EncodeElement(_edee.BarDir, _bdff)
	if _edee.Grouping != nil {
		_aaf := _fa.StartElement{Name: _fa.Name{Local: "c:grouping"}}
		e.EncodeElement(_edee.Grouping, _aaf)
	}
	if _edee.VaryColors != nil {
		_gfag := _fa.StartElement{Name: _fa.Name{Local: "c:varyColors"}}
		e.EncodeElement(_edee.VaryColors, _gfag)
	}
	if _edee.Ser != nil {
		_ebaa := _fa.StartElement{Name: _fa.Name{Local: "c:ser"}}
		for _, _cadeb := range _edee.Ser {
			e.EncodeElement(_cadeb, _ebaa)
		}
	}
	if _edee.DLbls != nil {
		_egb := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_edee.DLbls, _egb)
	}
	if _edee.GapWidth != nil {
		_bdd := _fa.StartElement{Name: _fa.Name{Local: "c:gapWidth"}}
		e.EncodeElement(_edee.GapWidth, _bdd)
	}
	if _edee.GapDepth != nil {
		_ef := _fa.StartElement{Name: _fa.Name{Local: "c:gapDepth"}}
		e.EncodeElement(_edee.GapDepth, _ef)
	}
	if _edee.Shape != nil {
		_debdb := _fa.StartElement{Name: _fa.Name{Local: "c:shape"}}
		e.EncodeElement(_edee.Shape, _debdb)
	}
	_adf := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	for _, _dcc := range _edee.AxId {
		e.EncodeElement(_dcc, _adf)
	}
	if _edee.ExtLst != nil {
		_aeg := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_edee.ExtLst, _aeg)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_gfagd ST_OfPieType) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_eecfe := _fa.Attr{}
	_eecfe.Name = name
	switch _gfagd {
	case ST_OfPieTypeUnset:
		_eecfe.Value = ""
	case ST_OfPieTypePie:
		_eecfe.Value = "pie"
	case ST_OfPieTypeBar:
		_eecfe.Value = "bar"
	}
	return _eecfe, nil
}
func (_edggea *CT_NumRef) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cdgcc := _fa.StartElement{Name: _fa.Name{Local: "c:f"}}
	_b.AddPreserveSpaceAttr(&_cdgcc, _edggea.F)
	e.EncodeElement(_edggea.F, _cdgcc)
	if _edggea.NumCache != nil {
		_begb := _fa.StartElement{Name: _fa.Name{Local: "c:numCache"}}
		e.EncodeElement(_edggea.NumCache, _begb)
	}
	if _edggea.ExtLst != nil {
		_bdfbb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_edggea.ExtLst, _bdfbb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_dcbag ST_Crosses) ValidateWithPath(path string) error {
	switch _dcbag {
	case 0, 1, 2, 3:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dcbag))
	}
	return nil
}
func (_gaeac ST_HPercent) String() string {
	if _gaeac.ST_HPercentWithSymbol != nil {
		return _gg.Sprintf("\u0025v", *_gaeac.ST_HPercentWithSymbol)
	}
	if _gaeac.ST_HPercentUShort != nil {
		return _gg.Sprintf("\u0025v", *_gaeac.ST_HPercentUShort)
	}
	return ""
}

// ValidateWithPath validates the CT_Overlap and its children, prefixing error messages with path
func (_bddef *CT_Overlap) ValidateWithPath(path string) error {
	if _bddef.ValAttr != nil {
		if _fcgfd := _bddef.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _fcgfd != nil {
			return _fcgfd
		}
	}
	return nil
}

type CT_TrendlineType struct{ ValAttr ST_TrendlineType }

func (_dde *CT_BandFmts) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _dde.BandFmt != nil {
		_bgf := _fa.StartElement{Name: _fa.Name{Local: "c:bandFmt"}}
		for _, _ebg := range _dde.BandFmt {
			e.EncodeElement(_ebg, _bgf)
		}
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type CT_Protection struct {
	ChartObject   *CT_Boolean
	Data          *CT_Boolean
	Formatting    *CT_Boolean
	Selection     *CT_Boolean
	UserInterface *CT_Boolean
}
type CT_NumData struct {
	FormatCode *string
	PtCount    *CT_UnsignedInt
	Pt         []*CT_NumVal
	ExtLst     *CT_ExtensionList
}
type ST_Crosses byte

// ST_Overlap is a union type
type ST_Overlap struct {
	ST_OverlapPercent *string
	ST_OverlapByte    *int8
}

func (_bdba *CT_Lvl) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _bdba.Pt != nil {
		_dgfb := _fa.StartElement{Name: _fa.Name{Local: "c:pt"}}
		for _, _acea := range _bdba.Pt {
			e.EncodeElement(_acea, _dgfb)
		}
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type EG_PieChartShared struct {
	VaryColors *CT_Boolean
	Ser        []*CT_PieSer
	DLbls      *CT_DLbls
}

func (_bfadf *Chart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_bfadf.CT_RelId = *NewCT_RelId()
	for _, _bfag := range start.Attr {
		if _bfag.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bfag.Name.Local == "id" || _bfag.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bfag.Name.Local == "id" {
			_dgddg, _fcadg := _bfag.Value, error(nil)
			if _fcadg != nil {
				return _fcadg
			}
			_bfadf.IdAttr = _dgddg
			continue
		}
	}
	for {
		_dgadc, _fbde := d.Token()
		if _fbde != nil {
			return _gg.Errorf("parsing\u0020Chart:\u0020\u0025s", _fbde)
		}
		if _dgfe, _fgfce := _dgadc.(_fa.EndElement); _fgfce && _dgfe.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_ScatterChart struct {
	ScatterStyle *CT_ScatterStyle
	VaryColors   *CT_Boolean
	Ser          []*CT_ScatterSer
	DLbls        *CT_DLbls
	AxId         []*CT_UnsignedInt
	ExtLst       *CT_ExtensionList
}

func (_feaaf *CT_LineChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_feaaf.Grouping = NewCT_Grouping()
_cgcd:
	for {
		_ggda, _aadg := d.Token()
		if _aadg != nil {
			return _aadg
		}
		switch _eeedb := _ggda.(type) {
		case _fa.StartElement:
			switch _eeedb.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "grouping"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "grouping"}:
				if _affg := d.DecodeElement(_feaaf.Grouping, &_eeedb); _affg != nil {
					return _affg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "varyColors"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "varyColors"}:
				_feaaf.VaryColors = NewCT_Boolean()
				if _edecf := d.DecodeElement(_feaaf.VaryColors, &_eeedb); _edecf != nil {
					return _edecf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_edda := NewCT_LineSer()
				if _fdbe := d.DecodeElement(_edda, &_eeedb); _fdbe != nil {
					return _fdbe
				}
				_feaaf.Ser = append(_feaaf.Ser, _edda)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dLbls"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dLbls"}:
				_feaaf.DLbls = NewCT_DLbls()
				if _cabaf := d.DecodeElement(_feaaf.DLbls, &_eeedb); _cabaf != nil {
					return _cabaf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "dropLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "dropLines"}:
				_feaaf.DropLines = NewCT_ChartLines()
				if _bfcbc := d.DecodeElement(_feaaf.DropLines, &_eeedb); _bfcbc != nil {
					return _bfcbc
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "hiLowLines"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "hiLowLines"}:
				_feaaf.HiLowLines = NewCT_ChartLines()
				if _ddea := d.DecodeElement(_feaaf.HiLowLines, &_eeedb); _ddea != nil {
					return _ddea
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "upDownBars"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "upDownBars"}:
				_feaaf.UpDownBars = NewCT_UpDownBars()
				if _bfcdg := d.DecodeElement(_feaaf.UpDownBars, &_eeedb); _bfcdg != nil {
					return _bfcdg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "marker"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "marker"}:
				_feaaf.Marker = NewCT_Boolean()
				if _cdgd := d.DecodeElement(_feaaf.Marker, &_eeedb); _cdgd != nil {
					return _cdgd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "smooth"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "smooth"}:
				_feaaf.Smooth = NewCT_Boolean()
				if _ddgdf := d.DecodeElement(_feaaf.Smooth, &_eeedb); _ddgdf != nil {
					return _ddgdf
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_faec := NewCT_UnsignedInt()
				if _cgfg := d.DecodeElement(_faec, &_eeedb); _cgfg != nil {
					return _cgfg
				}
				_feaaf.AxId = append(_feaaf.AxId, _faec)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_feaaf.ExtLst = NewCT_ExtensionList()
				if _ggagg := d.DecodeElement(_feaaf.ExtLst, &_eeedb); _ggagg != nil {
					return _ggagg
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_LineChart\u0020\u0025v", _eeedb.Name)
				if _debfe := d.Skip(); _debfe != nil {
					return _debfe
				}
			}
		case _fa.EndElement:
			break _cgcd
		case _fa.CharData:
		}
	}
	return nil
}
func (_abfgf *CT_TextLanguageID) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", _abfgf.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_dadf *CT_Chart) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _dadf.Title != nil {
		_eefcf := _fa.StartElement{Name: _fa.Name{Local: "c:title"}}
		e.EncodeElement(_dadf.Title, _eefcf)
	}
	if _dadf.AutoTitleDeleted != nil {
		_aaga := _fa.StartElement{Name: _fa.Name{Local: "c:autoTitleDeleted"}}
		e.EncodeElement(_dadf.AutoTitleDeleted, _aaga)
	}
	if _dadf.PivotFmts != nil {
		_cggf := _fa.StartElement{Name: _fa.Name{Local: "c:pivotFmts"}}
		e.EncodeElement(_dadf.PivotFmts, _cggf)
	}
	if _dadf.View3D != nil {
		_aeaa := _fa.StartElement{Name: _fa.Name{Local: "c:view3D"}}
		e.EncodeElement(_dadf.View3D, _aeaa)
	}
	if _dadf.Floor != nil {
		_dedgd := _fa.StartElement{Name: _fa.Name{Local: "c:floor"}}
		e.EncodeElement(_dadf.Floor, _dedgd)
	}
	if _dadf.SideWall != nil {
		_dbgg := _fa.StartElement{Name: _fa.Name{Local: "c:sideWall"}}
		e.EncodeElement(_dadf.SideWall, _dbgg)
	}
	if _dadf.BackWall != nil {
		_dcf := _fa.StartElement{Name: _fa.Name{Local: "c:backWall"}}
		e.EncodeElement(_dadf.BackWall, _dcf)
	}
	_edfd := _fa.StartElement{Name: _fa.Name{Local: "c:plotArea"}}
	e.EncodeElement(_dadf.PlotArea, _edfd)
	if _dadf.Legend != nil {
		_cefb := _fa.StartElement{Name: _fa.Name{Local: "c:legend"}}
		e.EncodeElement(_dadf.Legend, _cefb)
	}
	if _dadf.PlotVisOnly != nil {
		_egfg := _fa.StartElement{Name: _fa.Name{Local: "c:plotVisOnly"}}
		e.EncodeElement(_dadf.PlotVisOnly, _egfg)
	}
	if _dadf.DispBlanksAs != nil {
		_eccg := _fa.StartElement{Name: _fa.Name{Local: "c:dispBlanksAs"}}
		e.EncodeElement(_dadf.DispBlanksAs, _eccg)
	}
	if _dadf.ShowDLblsOverMax != nil {
		_bbae := _fa.StartElement{Name: _fa.Name{Local: "c:showDLblsOverMax"}}
		e.EncodeElement(_dadf.ShowDLblsOverMax, _bbae)
	}
	if _dadf.ExtLst != nil {
		_begf := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_dadf.ExtLst, _begf)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_DLblChoice and its children, prefixing error messages with path
func (_befef *CT_DLblChoice) ValidateWithPath(path string) error {
	if _befef.Delete != nil {
		if _dfda := _befef.Delete.ValidateWithPath(path + "\u002fDelete"); _dfda != nil {
			return _dfda
		}
	}
	if _befef.Layout != nil {
		if _gadfg := _befef.Layout.ValidateWithPath(path + "\u002fLayout"); _gadfg != nil {
			return _gadfg
		}
	}
	if _befef.Tx != nil {
		if _fgae := _befef.Tx.ValidateWithPath(path + "\u002fTx"); _fgae != nil {
			return _fgae
		}
	}
	if _befef.NumFmt != nil {
		if _bffb := _befef.NumFmt.ValidateWithPath(path + "\u002fNumFmt"); _bffb != nil {
			return _bffb
		}
	}
	if _befef.SpPr != nil {
		if _bacda := _befef.SpPr.ValidateWithPath(path + "\u002fSpPr"); _bacda != nil {
			return _bacda
		}
	}
	if _befef.TxPr != nil {
		if _eaf := _befef.TxPr.ValidateWithPath(path + "\u002fTxPr"); _eaf != nil {
			return _eaf
		}
	}
	if _befef.DLblPos != nil {
		if _dabg := _befef.DLblPos.ValidateWithPath(path + "\u002fDLblPos"); _dabg != nil {
			return _dabg
		}
	}
	if _befef.ShowLegendKey != nil {
		if _ddgd := _befef.ShowLegendKey.ValidateWithPath(path + "\u002fShowLegendKey"); _ddgd != nil {
			return _ddgd
		}
	}
	if _befef.ShowVal != nil {
		if _cfg := _befef.ShowVal.ValidateWithPath(path + "\u002fShowVal"); _cfg != nil {
			return _cfg
		}
	}
	if _befef.ShowCatName != nil {
		if _cceb := _befef.ShowCatName.ValidateWithPath(path + "\u002fShowCatName"); _cceb != nil {
			return _cceb
		}
	}
	if _befef.ShowSerName != nil {
		if _gfdd := _befef.ShowSerName.ValidateWithPath(path + "\u002fShowSerName"); _gfdd != nil {
			return _gfdd
		}
	}
	if _befef.ShowPercent != nil {
		if _deac := _befef.ShowPercent.ValidateWithPath(path + "\u002fShowPercent"); _deac != nil {
			return _deac
		}
	}
	if _befef.ShowBubbleSize != nil {
		if _ggae := _befef.ShowBubbleSize.ValidateWithPath(path + "\u002fShowBubbleSize"); _ggae != nil {
			return _ggae
		}
	}
	return nil
}
func NewCT_NumDataSourceChoice() *CT_NumDataSourceChoice {
	_ecgac := &CT_NumDataSourceChoice{}
	return _ecgac
}

// ValidateWithPath validates the CT_RadarStyle and its children, prefixing error messages with path
func (_bfcea *CT_RadarStyle) ValidateWithPath(path string) error {
	if _gdgeg := _bfcea.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _gdgeg != nil {
		return _gdgeg
	}
	return nil
}
func (_afga ST_LayoutMode) ValidateWithPath(path string) error {
	switch _afga {
	case 0, 1, 2:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_afga))
	}
	return nil
}

type CT_SerAx struct {
	AxId           *CT_UnsignedInt
	Scaling        *CT_Scaling
	Delete         *CT_Boolean
	AxPos          *CT_AxPos
	MajorGridlines *CT_ChartLines
	MinorGridlines *CT_ChartLines
	Title          *CT_Title
	NumFmt         *CT_NumFmt
	MajorTickMark  *CT_TickMark
	MinorTickMark  *CT_TickMark
	TickLblPos     *CT_TickLblPos
	SpPr           *_cb.CT_ShapeProperties
	TxPr           *_cb.CT_TextBody
	CrossAx        *CT_UnsignedInt
	Choice         *EG_AxSharedChoice
	TickLblSkip    *CT_Skip
	TickMarkSkip   *CT_Skip
	ExtLst         *CT_ExtensionList
}
type CT_LegendEntry struct {
	Idx    *CT_UnsignedInt
	Choice *CT_LegendEntryChoice
	ExtLst *CT_ExtensionList
}

func (_gdgb *CT_MarkerStyle) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	_fege, _gebd := _gdgb.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
	if _gebd != nil {
		return _gebd
	}
	start.Attr = append(start.Attr, _fege)
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_edbfb ST_Grouping) ValidateWithPath(path string) error {
	switch _edbfb {
	case 0, 1, 2, 3:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_edbfb))
	}
	return nil
}
func NewCT_Skip() *CT_Skip { _agacb := &CT_Skip{}; _agacb.ValAttr = 1; return _agacb }
func (_dcgef *CT_PieSer) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_cagf := _fa.StartElement{Name: _fa.Name{Local: "c:idx"}}
	e.EncodeElement(_dcgef.Idx, _cagf)
	_dgeff := _fa.StartElement{Name: _fa.Name{Local: "c:order"}}
	e.EncodeElement(_dcgef.Order, _dgeff)
	if _dcgef.Tx != nil {
		_bebg := _fa.StartElement{Name: _fa.Name{Local: "c:tx"}}
		e.EncodeElement(_dcgef.Tx, _bebg)
	}
	if _dcgef.SpPr != nil {
		_cdgcd := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_dcgef.SpPr, _cdgcd)
	}
	if _dcgef.Explosion != nil {
		_ffea := _fa.StartElement{Name: _fa.Name{Local: "c:explosion"}}
		e.EncodeElement(_dcgef.Explosion, _ffea)
	}
	if _dcgef.DPt != nil {
		_bacbc := _fa.StartElement{Name: _fa.Name{Local: "c:dPt"}}
		for _, _cdafc := range _dcgef.DPt {
			e.EncodeElement(_cdafc, _bacbc)
		}
	}
	if _dcgef.DLbls != nil {
		_aabb := _fa.StartElement{Name: _fa.Name{Local: "c:dLbls"}}
		e.EncodeElement(_dcgef.DLbls, _aabb)
	}
	if _dcgef.Cat != nil {
		_faeb := _fa.StartElement{Name: _fa.Name{Local: "c:cat"}}
		e.EncodeElement(_dcgef.Cat, _faeb)
	}
	if _dcgef.Val != nil {
		_decba := _fa.StartElement{Name: _fa.Name{Local: "c:val"}}
		e.EncodeElement(_dcgef.Val, _decba)
	}
	if _dcgef.ExtLst != nil {
		_bfde := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_dcgef.ExtLst, _bfde)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_cagcd *ST_BuiltInUnit) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_acbeed, _feace := d.Token()
	if _feace != nil {
		return _feace
	}
	if _egbgf, _agfag := _acbeed.(_fa.EndElement); _agfag && _egbgf.Name == start.Name {
		*_cagcd = 1
		return nil
	}
	if _ffgcc, _dabe := _acbeed.(_fa.CharData); !_dabe {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _acbeed)
	} else {
		switch string(_ffgcc) {
		case "":
			*_cagcd = 0
		case "hundreds":
			*_cagcd = 1
		case "thousands":
			*_cagcd = 2
		case "tenThousands":
			*_cagcd = 3
		case "hundredThousands":
			*_cagcd = 4
		case "millions":
			*_cagcd = 5
		case "tenMillions":
			*_cagcd = 6
		case "hundredMillions":
			*_cagcd = 7
		case "billions":
			*_cagcd = 8
		case "trillions":
			*_cagcd = 9
		}
	}
	_acbeed, _feace = d.Token()
	if _feace != nil {
		return _feace
	}
	if _ggfag, _ffgac := _acbeed.(_fa.EndElement); _ffgac && _ggfag.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _acbeed)
}
func (_ggfgd *CT_Tx) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ggfgd.Choice = NewCT_TxChoice()
_cfab:
	for {
		_edaga, _ddebd := d.Token()
		if _ddebd != nil {
			return _ddebd
		}
		switch _cccaa := _edaga.(type) {
		case _fa.StartElement:
			switch _cccaa.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "strRef"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "strRef"}:
				_ggfgd.Choice = NewCT_TxChoice()
				if _aeeb := d.DecodeElement(&_ggfgd.Choice.StrRef, &_cccaa); _aeeb != nil {
					return _aeeb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "rich"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "rich"}:
				_ggfgd.Choice = NewCT_TxChoice()
				if _dcfaf := d.DecodeElement(&_ggfgd.Choice.Rich, &_cccaa); _dcfaf != nil {
					return _dcfaf
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on CT_Tx \u0025v", _cccaa.Name)
				if _bcefb := d.Skip(); _bcefb != nil {
					return _bcefb
				}
			}
		case _fa.EndElement:
			break _cfab
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_HeaderFooter and its children, prefixing error messages with path
func (_acaf *CT_HeaderFooter) ValidateWithPath(path string) error { return nil }
func (_afef *CT_NumDataSource) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_afef.Choice.MarshalXML(e, _fa.StartElement{})
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_PictureFormat and its children
func (_bfcaa *CT_PictureFormat) Validate() error { return _bfcaa.ValidateWithPath("CT_PictureFormat") }

// ValidateWithPath validates the EG_LegendEntryData and its children, prefixing error messages with path
func (_gddcb *EG_LegendEntryData) ValidateWithPath(path string) error {
	if _gddcb.TxPr != nil {
		if _aeadaa := _gddcb.TxPr.ValidateWithPath(path + "\u002fTxPr"); _aeadaa != nil {
			return _aeadaa
		}
	}
	return nil
}
func (_bfeaa *CT_SecondPieSize) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _egaa := range start.Attr {
		if _egaa.Name.Local == "val" {
			_dbcd, _bfefc := ParseUnionST_SecondPieSize(_egaa.Value)
			if _bfefc != nil {
				return _bfefc
			}
			_bfeaa.ValAttr = &_dbcd
			continue
		}
	}
	for {
		_bfbfd, _faea := d.Token()
		if _faea != nil {
			return _gg.Errorf("parsing\u0020CT_SecondPieSize: \u0025s", _faea)
		}
		if _fcgbg, _gddf := _bfbfd.(_fa.EndElement); _gddf && _fcgbg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_eefga ST_SplitType) Validate() error { return _eefga.ValidateWithPath("") }
func (_cdbad *CT_Period) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _cdbad.ValAttr != nil {
		start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", *_cdbad.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

type EG_AxSharedChoice struct {
	Crosses   *CT_Crosses
	CrossesAt *CT_Double
}
type CT_NumDataSource struct{ Choice *CT_NumDataSourceChoice }

func (_badab ST_LayoutTarget) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_fagfa := _fa.Attr{}
	_fagfa.Name = name
	switch _badab {
	case ST_LayoutTargetUnset:
		_fagfa.Value = ""
	case ST_LayoutTargetInner:
		_fagfa.Value = "inner"
	case ST_LayoutTargetOuter:
		_fagfa.Value = "outer"
	}
	return _fagfa, nil
}
func (_eabg ST_TickMark) Validate() error { return _eabg.ValidateWithPath("") }
func NewCT_AxPos() *CT_AxPos              { _agcd := &CT_AxPos{}; _agcd.ValAttr = ST_AxPos(1); return _agcd }
func (_ededa ST_BarGrouping) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_ededa.String(), start)
}

// Validate validates the CT_DepthPercent and its children
func (_bbcd *CT_DepthPercent) Validate() error { return _bbcd.ValidateWithPath("CT_DepthPercent") }
func (_gbfeb ST_Orientation) Validate() error  { return _gbfeb.ValidateWithPath("") }
func ParseUnionST_Overlap(s string) (ST_Overlap, error) {
	if ST_OverlapPercentPatternRe.MatchString(s) {
		return ST_Overlap{ST_OverlapPercent: &s}, nil
	}
	_ecfaa, _cbdeg := _c.ParseInt(s, 10, 8)
	if _cbdeg != nil {
		return ST_Overlap{}, _cbdeg
	}
	_eadac := int8(_ecfaa)
	return ST_Overlap{ST_OverlapByte: &_eadac}, nil
}
func (_aadce ST_Shape) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_aadce.String(), start)
}

type ST_LegendPos byte

// Validate validates the CT_RotY and its children
func (_cddbe *CT_RotY) Validate() error { return _cddbe.ValidateWithPath("CT_RotY") }

// Validate validates the CT_Grouping and its children
func (_dbadc *CT_Grouping) Validate() error { return _dbadc.ValidateWithPath("CT_Grouping") }
func (_dbg *CT_AxisUnit) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_dbg.ValAttr = 0 + 1
	for _, _cdad := range start.Attr {
		if _cdad.Name.Local == "val" {
			_bge, _gec := _c.ParseFloat(_cdad.Value, 64)
			if _gec != nil {
				return _gec
			}
			_dbg.ValAttr = _bge
			continue
		}
	}
	for {
		_ddf, _cdf := d.Token()
		if _cdf != nil {
			return _gg.Errorf("parsing\u0020CT_AxisUnit:\u0020\u0025s", _cdf)
		}
		if _bad, _df := _ddf.(_fa.EndElement); _df && _bad.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_UpDownBars struct {
	GapWidth *CT_GapAmount
	UpBars   *CT_UpDownBar
	DownBars *CT_UpDownBar
	ExtLst   *CT_ExtensionList
}

// Validate validates the CT_ChartSpace and its children
func (_bggb *CT_ChartSpace) Validate() error { return _bggb.ValidateWithPath("CT_ChartSpace") }

// ValidateWithPath validates the CT_PageMargins and its children, prefixing error messages with path
func (_ceeda *CT_PageMargins) ValidateWithPath(path string) error { return nil }
func (_ffec *CT_Surface3DChart) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_bacc:
	for {
		_aegb, _bgegc := d.Token()
		if _bgegc != nil {
			return _bgegc
		}
		switch _baabf := _aegb.(type) {
		case _fa.StartElement:
			switch _baabf.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "wireframe"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "wireframe"}:
				_ffec.Wireframe = NewCT_Boolean()
				if _fgdec := d.DecodeElement(_ffec.Wireframe, &_baabf); _fgdec != nil {
					return _fgdec
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "ser"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "ser"}:
				_debgb := NewCT_SurfaceSer()
				if _bbgfd := d.DecodeElement(_debgb, &_baabf); _bbgfd != nil {
					return _bbgfd
				}
				_ffec.Ser = append(_ffec.Ser, _debgb)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "bandFmts"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "bandFmts"}:
				_ffec.BandFmts = NewCT_BandFmts()
				if _cffd := d.DecodeElement(_ffec.BandFmts, &_baabf); _cffd != nil {
					return _cffd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "axId"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "axId"}:
				_egfeg := NewCT_UnsignedInt()
				if _cdadc := d.DecodeElement(_egfeg, &_baabf); _cdadc != nil {
					return _cdadc
				}
				_ffec.AxId = append(_ffec.AxId, _egfeg)
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_ffec.ExtLst = NewCT_ExtensionList()
				if _gfbdf := d.DecodeElement(_ffec.ExtLst, &_baabf); _gfbdf != nil {
					return _gfbdf
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_Surface3DChart\u0020\u0025v", _baabf.Name)
				if _gfadb := d.Skip(); _gfadb != nil {
					return _gfadb
				}
			}
		case _fa.EndElement:
			break _bacc
		case _fa.CharData:
		}
	}
	return nil
}

type CT_OfPieChart struct {
	OfPieType     *CT_OfPieType
	VaryColors    *CT_Boolean
	Ser           []*CT_PieSer
	DLbls         *CT_DLbls
	GapWidth      *CT_GapAmount
	SplitType     *CT_SplitType
	SplitPos      *CT_Double
	CustSplit     *CT_CustSplit
	SecondPieSize *CT_SecondPieSize
	SerLines      []*CT_ChartLines
	ExtLst        *CT_ExtensionList
}
type CT_BubbleChart struct {
	VaryColors     *CT_Boolean
	Ser            []*CT_BubbleSer
	DLbls          *CT_DLbls
	Bubble3D       *CT_Boolean
	BubbleScale    *CT_BubbleScale
	ShowNegBubbles *CT_Boolean
	SizeRepresents *CT_SizeRepresents
	AxId           []*CT_UnsignedInt
	ExtLst         *CT_ExtensionList
}

func NewCT_Tx() *CT_Tx { _baddg := &CT_Tx{}; _baddg.Choice = NewCT_TxChoice(); return _baddg }

const (
	ST_PageSetupOrientationUnset     ST_PageSetupOrientation = 0
	ST_PageSetupOrientationDefault   ST_PageSetupOrientation = 1
	ST_PageSetupOrientationPortrait  ST_PageSetupOrientation = 2
	ST_PageSetupOrientationLandscape ST_PageSetupOrientation = 3
)

func (_egffb *CT_Trendline) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _egffb.Name != nil {
		_edbee := _fa.StartElement{Name: _fa.Name{Local: "c:name"}}
		_b.AddPreserveSpaceAttr(&_edbee, *_egffb.Name)
		e.EncodeElement(_egffb.Name, _edbee)
	}
	if _egffb.SpPr != nil {
		_cgbcc := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_egffb.SpPr, _cgbcc)
	}
	_dacd := _fa.StartElement{Name: _fa.Name{Local: "c:trendlineType"}}
	e.EncodeElement(_egffb.TrendlineType, _dacd)
	if _egffb.Order != nil {
		_gcaea := _fa.StartElement{Name: _fa.Name{Local: "c:order"}}
		e.EncodeElement(_egffb.Order, _gcaea)
	}
	if _egffb.Period != nil {
		_adbce := _fa.StartElement{Name: _fa.Name{Local: "c:period"}}
		e.EncodeElement(_egffb.Period, _adbce)
	}
	if _egffb.Forward != nil {
		_acgf := _fa.StartElement{Name: _fa.Name{Local: "c:forward"}}
		e.EncodeElement(_egffb.Forward, _acgf)
	}
	if _egffb.Backward != nil {
		_bceb := _fa.StartElement{Name: _fa.Name{Local: "c:backward"}}
		e.EncodeElement(_egffb.Backward, _bceb)
	}
	if _egffb.Intercept != nil {
		_bcbc := _fa.StartElement{Name: _fa.Name{Local: "c:intercept"}}
		e.EncodeElement(_egffb.Intercept, _bcbc)
	}
	if _egffb.DispRSqr != nil {
		_ggabc := _fa.StartElement{Name: _fa.Name{Local: "c:dispRSqr"}}
		e.EncodeElement(_egffb.DispRSqr, _ggabc)
	}
	if _egffb.DispEq != nil {
		_edff := _fa.StartElement{Name: _fa.Name{Local: "c:dispEq"}}
		e.EncodeElement(_egffb.DispEq, _edff)
	}
	if _egffb.TrendlineLbl != nil {
		_faage := _fa.StartElement{Name: _fa.Name{Local: "c:trendlineLbl"}}
		e.EncodeElement(_egffb.TrendlineLbl, _faage)
	}
	if _egffb.ExtLst != nil {
		_ffgca := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_egffb.ExtLst, _ffgca)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_agaea *CT_Double) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	start.Attr = append(start.Attr, _fa.Attr{Name: _fa.Name{Local: "val"}, Value: _gg.Sprintf("\u0025v", _agaea.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_gcba *CT_SplitType) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	if _gcba.ValAttr != ST_SplitTypeUnset {
		_dcbdd, _cgecg := _gcba.ValAttr.MarshalXMLAttr(_fa.Name{Local: "val"})
		if _cgecg != nil {
			return _cgecg
		}
		start.Attr = append(start.Attr, _dcbdd)
	}
	e.EncodeToken(start)
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}
func (_ddfgb *CT_Order) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _cdbg := range start.Attr {
		if _cdbg.Name.Local == "val" {
			_ceede, _ddfgbe := _c.ParseUint(_cdbg.Value, 10, 8)
			if _ddfgbe != nil {
				return _ddfgbe
			}
			_cedbg := uint8(_ceede)
			_ddfgb.ValAttr = &_cedbg
			continue
		}
	}
	for {
		_dcdd, _bacbd := d.Token()
		if _bacbd != nil {
			return _gg.Errorf("parsing\u0020CT_Order: \u0025s", _bacbd)
		}
		if _cadf, _gbcag := _dcdd.(_fa.EndElement); _gbcag && _cadf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dgeca ST_TickMark) ValidateWithPath(path string) error {
	switch _dgeca {
	case 0, 1, 2, 3, 4:
	default:
		return _gg.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dgeca))
	}
	return nil
}
func (_dfdd *CT_CatAx) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	_bbe := _fa.StartElement{Name: _fa.Name{Local: "c:axId"}}
	e.EncodeElement(_dfdd.AxId, _bbe)
	_abbe := _fa.StartElement{Name: _fa.Name{Local: "c:scaling"}}
	e.EncodeElement(_dfdd.Scaling, _abbe)
	if _dfdd.Delete != nil {
		_dce := _fa.StartElement{Name: _fa.Name{Local: "c:delete"}}
		e.EncodeElement(_dfdd.Delete, _dce)
	}
	_cde := _fa.StartElement{Name: _fa.Name{Local: "c:axPos"}}
	e.EncodeElement(_dfdd.AxPos, _cde)
	if _dfdd.MajorGridlines != nil {
		_adc := _fa.StartElement{Name: _fa.Name{Local: "c:majorGridlines"}}
		e.EncodeElement(_dfdd.MajorGridlines, _adc)
	}
	if _dfdd.MinorGridlines != nil {
		_bfae := _fa.StartElement{Name: _fa.Name{Local: "c:minorGridlines"}}
		e.EncodeElement(_dfdd.MinorGridlines, _bfae)
	}
	if _dfdd.Title != nil {
		_ddaa := _fa.StartElement{Name: _fa.Name{Local: "c:title"}}
		e.EncodeElement(_dfdd.Title, _ddaa)
	}
	if _dfdd.NumFmt != nil {
		_daff := _fa.StartElement{Name: _fa.Name{Local: "c:numFmt"}}
		e.EncodeElement(_dfdd.NumFmt, _daff)
	}
	if _dfdd.MajorTickMark != nil {
		_cfce := _fa.StartElement{Name: _fa.Name{Local: "c:majorTickMark"}}
		e.EncodeElement(_dfdd.MajorTickMark, _cfce)
	}
	if _dfdd.MinorTickMark != nil {
		_cdacc := _fa.StartElement{Name: _fa.Name{Local: "c:minorTickMark"}}
		e.EncodeElement(_dfdd.MinorTickMark, _cdacc)
	}
	if _dfdd.TickLblPos != nil {
		_cbee := _fa.StartElement{Name: _fa.Name{Local: "c:tickLblPos"}}
		e.EncodeElement(_dfdd.TickLblPos, _cbee)
	}
	if _dfdd.SpPr != nil {
		_gbgec := _fa.StartElement{Name: _fa.Name{Local: "c:spPr"}}
		e.EncodeElement(_dfdd.SpPr, _gbgec)
	}
	if _dfdd.TxPr != nil {
		_adea := _fa.StartElement{Name: _fa.Name{Local: "c:txPr"}}
		e.EncodeElement(_dfdd.TxPr, _adea)
	}
	_dabc := _fa.StartElement{Name: _fa.Name{Local: "c:crossAx"}}
	e.EncodeElement(_dfdd.CrossAx, _dabc)
	if _dfdd.Choice != nil {
		_dfdd.Choice.MarshalXML(e, _fa.StartElement{})
	}
	if _dfdd.Auto != nil {
		_bbgc := _fa.StartElement{Name: _fa.Name{Local: "c:auto"}}
		e.EncodeElement(_dfdd.Auto, _bbgc)
	}
	if _dfdd.LblAlgn != nil {
		_ceee := _fa.StartElement{Name: _fa.Name{Local: "c:lblAlgn"}}
		e.EncodeElement(_dfdd.LblAlgn, _ceee)
	}
	if _dfdd.LblOffset != nil {
		_fgffb := _fa.StartElement{Name: _fa.Name{Local: "c:lblOffset"}}
		e.EncodeElement(_dfdd.LblOffset, _fgffb)
	}
	if _dfdd.TickLblSkip != nil {
		_feac := _fa.StartElement{Name: _fa.Name{Local: "c:tickLblSkip"}}
		e.EncodeElement(_dfdd.TickLblSkip, _feac)
	}
	if _dfdd.TickMarkSkip != nil {
		_efae := _fa.StartElement{Name: _fa.Name{Local: "c:tickMarkSkip"}}
		e.EncodeElement(_dfdd.TickMarkSkip, _efae)
	}
	if _dfdd.NoMultiLvlLbl != nil {
		_cfceb := _fa.StartElement{Name: _fa.Name{Local: "c:noMultiLvlLbl"}}
		e.EncodeElement(_dfdd.NoMultiLvlLbl, _cfceb)
	}
	if _dfdd.ExtLst != nil {
		_bdb := _fa.StartElement{Name: _fa.Name{Local: "c:extLst"}}
		e.EncodeElement(_dfdd.ExtLst, _bdb)
	}
	e.EncodeToken(_fa.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_ErrDir and its children
func (_adee *CT_ErrDir) Validate() error { return _adee.ValidateWithPath("CT_ErrDir") }

// ValidateWithPath validates the CT_Skip and its children, prefixing error messages with path
func (_dgcd *CT_Skip) ValidateWithPath(path string) error {
	if _dgcd.ValAttr < 1 {
		return _gg.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00201\u0020\u0028have\u0020\u0025v\u0029", path, _dgcd.ValAttr)
	}
	return nil
}

// ValidateWithPath validates the CT_StrData and its children, prefixing error messages with path
func (_fdge *CT_StrData) ValidateWithPath(path string) error {
	if _fdge.PtCount != nil {
		if _gbcg := _fdge.PtCount.ValidateWithPath(path + "\u002fPtCount"); _gbcg != nil {
			return _gbcg
		}
	}
	for _bdcfae, _aebdc := range _fdge.Pt {
		if _aedce := _aebdc.ValidateWithPath(_gg.Sprintf("\u0025s\u002fPt\u005b\u0025d]", path, _bdcfae)); _aedce != nil {
			return _aedce
		}
	}
	if _fdge.ExtLst != nil {
		if _fgeed := _fdge.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fgeed != nil {
			return _fgeed
		}
	}
	return nil
}
func NewCT_DTable() *CT_DTable { _cdgf := &CT_DTable{}; return _cdgf }

// Validate validates the CT_SplitType and its children
func (_dbadd *CT_SplitType) Validate() error { return _dbadd.ValidateWithPath("CT_SplitType") }

// Validate validates the ChartSpace and its children
func (_egaeg *ChartSpace) Validate() error { return _egaeg.ValidateWithPath("ChartSpace") }
func (_afgdf ST_LblOffset) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	e.EncodeToken(start)
	if _afgdf.ST_LblOffsetPercent != nil {
		e.EncodeToken(_fa.CharData(*_afgdf.ST_LblOffsetPercent))
	}
	if _afgdf.ST_LblOffsetUShort != nil {
		e.EncodeToken(_fa.CharData(_gg.Sprintf("\u0025d", *_afgdf.ST_LblOffsetUShort)))
	}
	return e.EncodeToken(_fa.EndElement{Name: start.Name})
}

// ValidateWithPath validates the CT_ManualLayout and its children, prefixing error messages with path
func (_edggd *CT_ManualLayout) ValidateWithPath(path string) error {
	if _edggd.LayoutTarget != nil {
		if _agaag := _edggd.LayoutTarget.ValidateWithPath(path + "\u002fLayoutTarget"); _agaag != nil {
			return _agaag
		}
	}
	if _edggd.XMode != nil {
		if _dfbff := _edggd.XMode.ValidateWithPath(path + "\u002fXMode"); _dfbff != nil {
			return _dfbff
		}
	}
	if _edggd.YMode != nil {
		if _eagc := _edggd.YMode.ValidateWithPath(path + "\u002fYMode"); _eagc != nil {
			return _eagc
		}
	}
	if _edggd.WMode != nil {
		if _dgdge := _edggd.WMode.ValidateWithPath(path + "\u002fWMode"); _dgdge != nil {
			return _dgdge
		}
	}
	if _edggd.HMode != nil {
		if _dgfd := _edggd.HMode.ValidateWithPath(path + "\u002fHMode"); _dgfd != nil {
			return _dgfd
		}
	}
	if _edggd.X != nil {
		if _acgg := _edggd.X.ValidateWithPath(path + "\u002fX"); _acgg != nil {
			return _acgg
		}
	}
	if _edggd.Y != nil {
		if _gebbg := _edggd.Y.ValidateWithPath(path + "\u002fY"); _gebbg != nil {
			return _gebbg
		}
	}
	if _edggd.W != nil {
		if _ecgb := _edggd.W.ValidateWithPath(path + "\u002fW"); _ecgb != nil {
			return _ecgb
		}
	}
	if _edggd.H != nil {
		if _bcgg := _edggd.H.ValidateWithPath(path + "\u002fH"); _bcgg != nil {
			return _bcgg
		}
	}
	if _edggd.ExtLst != nil {
		if _cgec := _edggd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cgec != nil {
			return _cgec
		}
	}
	return nil
}
func (_gadcb ST_AxPos) MarshalXML(e *_fa.Encoder, start _fa.StartElement) error {
	return e.EncodeElement(_gadcb.String(), start)
}
func (_ffggaf ST_SplitType) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_dgecb := _fa.Attr{}
	_dgecb.Name = name
	switch _ffggaf {
	case ST_SplitTypeUnset:
		_dgecb.Value = ""
	case ST_SplitTypeAuto:
		_dgecb.Value = "auto"
	case ST_SplitTypeCust:
		_dgecb.Value = "cust"
	case ST_SplitTypePercent:
		_dgecb.Value = "percent"
	case ST_SplitTypePos:
		_dgecb.Value = "pos"
	case ST_SplitTypeVal:
		_dgecb.Value = "val"
	}
	return _dgecb, nil
}
func (_gfaa ST_TickMark) String() string {
	switch _gfaa {
	case 0:
		return ""
	case 1:
		return "cross"
	case 2:
		return "in"
	case 3:
		return "none"
	case 4:
		return "out"
	}
	return ""
}
func (_dfce ST_BarGrouping) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_bcaeb := _fa.Attr{}
	_bcaeb.Name = name
	switch _dfce {
	case ST_BarGroupingUnset:
		_bcaeb.Value = ""
	case ST_BarGroupingPercentStacked:
		_bcaeb.Value = "percentStacked"
	case ST_BarGroupingClustered:
		_bcaeb.Value = "clustered"
	case ST_BarGroupingStandard:
		_bcaeb.Value = "standard"
	case ST_BarGroupingStacked:
		_bcaeb.Value = "stacked"
	}
	return _bcaeb, nil
}
func (_cdabf *CT_LogBase) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_cdabf.ValAttr = 2
	for _, _ddgac := range start.Attr {
		if _ddgac.Name.Local == "val" {
			_gbgf, _dfbdb := _c.ParseFloat(_ddgac.Value, 64)
			if _dfbdb != nil {
				return _dfbdb
			}
			_cdabf.ValAttr = _gbgf
			continue
		}
	}
	for {
		_eccbg, _cccc := d.Token()
		if _cccc != nil {
			return _gg.Errorf("parsing\u0020CT_LogBase:\u0020%s", _cccc)
		}
		if _aaef, _cfgb := _eccbg.(_fa.EndElement); _cfgb && _aaef.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the EG_LineChartShared and its children, prefixing error messages with path
func (_bdaafe *EG_LineChartShared) ValidateWithPath(path string) error {
	if _ecee := _bdaafe.Grouping.ValidateWithPath(path + "\u002fGrouping"); _ecee != nil {
		return _ecee
	}
	if _bdaafe.VaryColors != nil {
		if _gbcec := _bdaafe.VaryColors.ValidateWithPath(path + "/VaryColors"); _gbcec != nil {
			return _gbcec
		}
	}
	for _feeb, _dgdab := range _bdaafe.Ser {
		if _ggec := _dgdab.ValidateWithPath(_gg.Sprintf("\u0025s\u002fSer\u005b\u0025d\u005d", path, _feeb)); _ggec != nil {
			return _ggec
		}
	}
	if _bdaafe.DLbls != nil {
		if _ccbbf := _bdaafe.DLbls.ValidateWithPath(path + "\u002fDLbls"); _ccbbf != nil {
			return _ccbbf
		}
	}
	if _bdaafe.DropLines != nil {
		if _aegca := _bdaafe.DropLines.ValidateWithPath(path + "\u002fDropLines"); _aegca != nil {
			return _aegca
		}
	}
	return nil
}
func (_ccbbc *ST_MarkerStyle) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	_ebdag, _ecebb := d.Token()
	if _ecebb != nil {
		return _ecebb
	}
	if _egafe, _cbecb := _ebdag.(_fa.EndElement); _cbecb && _egafe.Name == start.Name {
		*_ccbbc = 1
		return nil
	}
	if _geafc, _ffcfc := _ebdag.(_fa.CharData); !_ffcfc {
		return _gg.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ebdag)
	} else {
		switch string(_geafc) {
		case "":
			*_ccbbc = 0
		case "circle":
			*_ccbbc = 1
		case "dash":
			*_ccbbc = 2
		case "diamond":
			*_ccbbc = 3
		case "dot":
			*_ccbbc = 4
		case "none":
			*_ccbbc = 5
		case "picture":
			*_ccbbc = 6
		case "plus":
			*_ccbbc = 7
		case "square":
			*_ccbbc = 8
		case "star":
			*_ccbbc = 9
		case "triangle":
			*_ccbbc = 10
		case "x":
			*_ccbbc = 11
		case "auto":
			*_ccbbc = 12
		}
	}
	_ebdag, _ecebb = d.Token()
	if _ecebb != nil {
		return _ecebb
	}
	if _edcc, _gbaf := _ebdag.(_fa.EndElement); _gbaf && _edcc.Name == start.Name {
		return nil
	}
	return _gg.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ebdag)
}

type CT_PictureStackUnit struct{ ValAttr float64 }
type ST_CrossBetween byte

// ValidateWithPath validates the CT_RotY and its children, prefixing error messages with path
func (_deaec *CT_RotY) ValidateWithPath(path string) error {
	if _deaec.ValAttr != nil {
		if *_deaec.ValAttr < 0 {
			return _gg.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_deaec.ValAttr)
		}
		if *_deaec.ValAttr > 360 {
			return _gg.Errorf("\u0025s/m\u002eValAttr\u0020must\u0020be\u0020\u003c\u003d\u0020360\u0020\u0028have\u0020\u0025v\u0029", path, *_deaec.ValAttr)
		}
	}
	return nil
}
func (_afgec *CT_StrVal) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _acegb := range start.Attr {
		if _acegb.Name.Local == "idx" {
			_fede, _ecfbf := _c.ParseUint(_acegb.Value, 10, 32)
			if _ecfbf != nil {
				return _ecfbf
			}
			_afgec.IdxAttr = uint32(_fede)
			continue
		}
	}
_dfeff:
	for {
		_bgcea, _efge := d.Token()
		if _efge != nil {
			return _efge
		}
		switch _gbbd := _bgcea.(type) {
		case _fa.StartElement:
			switch _gbbd.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "v"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "v"}:
				if _dgcdf := d.DecodeElement(&_afgec.V, &_gbbd); _dgcdf != nil {
					return _dgcdf
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element on CT_StrVal \u0025v", _gbbd.Name)
				if _gfcff := d.Skip(); _gfcff != nil {
					return _gfcff
				}
			}
		case _fa.EndElement:
			break _dfeff
		case _fa.CharData:
		}
	}
	return nil
}
func NewCT_BubbleSer() *CT_BubbleSer {
	_ecae := &CT_BubbleSer{}
	_ecae.Idx = NewCT_UnsignedInt()
	_ecae.Order = NewCT_UnsignedInt()
	return _ecae
}

type CT_MultiLvlStrRef struct {
	F                string
	MultiLvlStrCache *CT_MultiLvlStrData
	ExtLst           *CT_ExtensionList
}

func (_eeaabc ST_LblAlgn) MarshalXMLAttr(name _fa.Name) (_fa.Attr, error) {
	_dddd := _fa.Attr{}
	_dddd.Name = name
	switch _eeaabc {
	case ST_LblAlgnUnset:
		_dddd.Value = ""
	case ST_LblAlgnCtr:
		_dddd.Value = "ctr"
	case ST_LblAlgnL:
		_dddd.Value = "l"
	case ST_LblAlgnR:
		_dddd.Value = "r"
	}
	return _dddd, nil
}

// ValidateWithPath validates the CT_UpDownBar and its children, prefixing error messages with path
func (_cbffb *CT_UpDownBar) ValidateWithPath(path string) error {
	if _cbffb.SpPr != nil {
		if _fabfb := _cbffb.SpPr.ValidateWithPath(path + "\u002fSpPr"); _fabfb != nil {
			return _fabfb
		}
	}
	return nil
}
func NewCT_ExternalData() *CT_ExternalData { _bbdgb := &CT_ExternalData{}; return _bbdgb }
func (_bffge *CT_TrendlineType) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
	for _, _edcb := range start.Attr {
		if _edcb.Name.Local == "val" {
			_bffge.ValAttr.UnmarshalXMLAttr(_edcb)
			continue
		}
	}
	for {
		_dbgacff, _fegf := d.Token()
		if _fegf != nil {
			return _gg.Errorf("parsing\u0020CT_TrendlineType: \u0025s", _fegf)
		}
		if _fcbae, _aece := _dbgacff.(_fa.EndElement); _aece && _fcbae.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dffeb *ST_Crosses) UnmarshalXMLAttr(attr _fa.Attr) error {
	switch attr.Value {
	case "":
		*_dffeb = 0
	case "autoZero":
		*_dffeb = 1
	case "max":
		*_dffeb = 2
	case "min":
		*_dffeb = 3
	}
	return nil
}
func (_dbfge *CT_Scaling) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_cggee:
	for {
		_dfgcf, _dbgacf := d.Token()
		if _dbgacf != nil {
			return _dbgacf
		}
		switch _eaedg := _dfgcf.(type) {
		case _fa.StartElement:
			switch _eaedg.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "logBase"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "logBase"}:
				_dbfge.LogBase = NewCT_LogBase()
				if _cege := d.DecodeElement(_dbfge.LogBase, &_eaedg); _cege != nil {
					return _cege
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "orientation"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "orientation"}:
				_dbfge.Orientation = NewCT_Orientation()
				if _dedce := d.DecodeElement(_dbfge.Orientation, &_eaedg); _dedce != nil {
					return _dedce
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "max"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "max"}:
				_dbfge.Max = NewCT_Double()
				if _ffcg := d.DecodeElement(_dbfge.Max, &_eaedg); _ffcg != nil {
					return _ffcg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "min"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "min"}:
				_dbfge.Min = NewCT_Double()
				if _ecead := d.DecodeElement(_dbfge.Min, &_eaedg); _ecead != nil {
					return _ecead
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_dbfge.ExtLst = NewCT_ExtensionList()
				if _bbeac := d.DecodeElement(_dbfge.ExtLst, &_eaedg); _bbeac != nil {
					return _bbeac
				}
			default:
				_b.Log("skipping unsupported\u0020element\u0020on\u0020CT_Scaling\u0020\u0025v", _eaedg.Name)
				if _caea := d.Skip(); _caea != nil {
					return _caea
				}
			}
		case _fa.EndElement:
			break _cggee
		case _fa.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PictureFormat and its children, prefixing error messages with path
func (_ddfda *CT_PictureFormat) ValidateWithPath(path string) error {
	if _ddfda.ValAttr == ST_PictureFormatUnset {
		return _gg.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _ebae := _ddfda.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _ebae != nil {
		return _ebae
	}
	return nil
}
func (_bdgeb *CT_Title) UnmarshalXML(d *_fa.Decoder, start _fa.StartElement) error {
_gegd:
	for {
		_daec, _gcegb := d.Token()
		if _gcegb != nil {
			return _gcegb
		}
		switch _faeag := _daec.(type) {
		case _fa.StartElement:
			switch _faeag.Name {
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "tx"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "tx"}:
				_bdgeb.Tx = NewCT_Tx()
				if _bdege := d.DecodeElement(_bdgeb.Tx, &_faeag); _bdege != nil {
					return _bdege
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "layout"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "layout"}:
				_bdgeb.Layout = NewCT_Layout()
				if _begfe := d.DecodeElement(_bdgeb.Layout, &_faeag); _begfe != nil {
					return _begfe
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "overlay"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "overlay"}:
				_bdgeb.Overlay = NewCT_Boolean()
				if _cbefd := d.DecodeElement(_bdgeb.Overlay, &_faeag); _cbefd != nil {
					return _cbefd
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "spPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "spPr"}:
				_bdgeb.SpPr = _cb.NewCT_ShapeProperties()
				if _ddbfg := d.DecodeElement(_bdgeb.SpPr, &_faeag); _ddbfg != nil {
					return _ddbfg
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "txPr"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "txPr"}:
				_bdgeb.TxPr = _cb.NewCT_TextBody()
				if _faaeb := d.DecodeElement(_bdgeb.TxPr, &_faeag); _faaeb != nil {
					return _faaeb
				}
			case _fa.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", Local: "extLst"}, _fa.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fchart", Local: "extLst"}:
				_bdgeb.ExtLst = NewCT_ExtensionList()
				if _gfba := d.DecodeElement(_bdgeb.ExtLst, &_faeag); _gfba != nil {
					return _gfba
				}
			default:
				_b.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Title\u0020\u0025v", _faeag.Name)
				if _ebace := d.Skip(); _ebace != nil {
					return _ebace
				}
			}
		case _fa.EndElement:
			break _gegd
		case _fa.CharData:
		}
	}
	return nil
}

type CT_ScatterStyle struct{ ValAttr ST_ScatterStyle }

// ValidateWithPath validates the CT_NumDataSourceChoice and its children, prefixing error messages with path
func (_gedcg *CT_NumDataSourceChoice) ValidateWithPath(path string) error {
	if _gedcg.NumRef != nil {
		if _ecggb := _gedcg.NumRef.ValidateWithPath(path + "\u002fNumRef"); _ecggb != nil {
			return _ecggb
		}
	}
	if _gedcg.NumLit != nil {
		if _afdae := _gedcg.NumLit.ValidateWithPath(path + "\u002fNumLit"); _afdae != nil {
			return _afdae
		}
	}
	return nil
}
func NewChart() *Chart { _gcfd := &Chart{}; _gcfd.CT_RelId = *NewCT_RelId(); return _gcfd }

// Validate validates the EG_DLblShared and its children
func (_eabcg *EG_DLblShared) Validate() error { return _eabcg.ValidateWithPath("EG_DLblShared") }
func NewCT_Crosses() *CT_Crosses              { _gcdd := &CT_Crosses{}; _gcdd.ValAttr = ST_Crosses(1); return _gcdd }
func init() {
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Boolean", NewCT_Boolean)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Double", NewCT_Double)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_UnsignedInt", NewCT_UnsignedInt)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_RelId", NewCT_RelId)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Extension", NewCT_Extension)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ExtensionList", NewCT_ExtensionList)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_NumVal", NewCT_NumVal)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_NumData", NewCT_NumData)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_NumRef", NewCT_NumRef)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_NumDataSource", NewCT_NumDataSource)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_StrVal", NewCT_StrVal)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_StrData", NewCT_StrData)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_StrRef", NewCT_StrRef)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Tx", NewCT_Tx)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_TextLanguageID", NewCT_TextLanguageID)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Lvl", NewCT_Lvl)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_MultiLvlStrData", NewCT_MultiLvlStrData)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_MultiLvlStrRef", NewCT_MultiLvlStrRef)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_AxDataSource", NewCT_AxDataSource)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_SerTx", NewCT_SerTx)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_LayoutTarget", NewCT_LayoutTarget)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_LayoutMode", NewCT_LayoutMode)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ManualLayout", NewCT_ManualLayout)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Layout", NewCT_Layout)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Title", NewCT_Title)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_RotX", NewCT_RotX)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_HPercent", NewCT_HPercent)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_RotY", NewCT_RotY)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_DepthPercent", NewCT_DepthPercent)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Perspective", NewCT_Perspective)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_View3D", NewCT_View3D)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Surface", NewCT_Surface)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Thickness", NewCT_Thickness)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_DTable", NewCT_DTable)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_GapAmount", NewCT_GapAmount)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Overlap", NewCT_Overlap)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_BubbleScale", NewCT_BubbleScale)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_SizeRepresents", NewCT_SizeRepresents)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_FirstSliceAng", NewCT_FirstSliceAng)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_HoleSize", NewCT_HoleSize)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_SplitType", NewCT_SplitType)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_CustSplit", NewCT_CustSplit)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_SecondPieSize", NewCT_SecondPieSize)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_NumFmt", NewCT_NumFmt)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_LblAlgn", NewCT_LblAlgn)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_DLblPos", NewCT_DLblPos)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_DLbl", NewCT_DLbl)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_DLbls", NewCT_DLbls)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_MarkerStyle", NewCT_MarkerStyle)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_MarkerSize", NewCT_MarkerSize)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Marker", NewCT_Marker)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_DPt", NewCT_DPt)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_TrendlineType", NewCT_TrendlineType)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Order", NewCT_Order)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Period", NewCT_Period)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_TrendlineLbl", NewCT_TrendlineLbl)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Trendline", NewCT_Trendline)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ErrDir", NewCT_ErrDir)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ErrBarType", NewCT_ErrBarType)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ErrValType", NewCT_ErrValType)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ErrBars", NewCT_ErrBars)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_UpDownBar", NewCT_UpDownBar)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_UpDownBars", NewCT_UpDownBars)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_LineSer", NewCT_LineSer)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ScatterSer", NewCT_ScatterSer)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_RadarSer", NewCT_RadarSer)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_BarSer", NewCT_BarSer)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_AreaSer", NewCT_AreaSer)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PieSer", NewCT_PieSer)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_BubbleSer", NewCT_BubbleSer)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_SurfaceSer", NewCT_SurfaceSer)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Grouping", NewCT_Grouping)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ChartLines", NewCT_ChartLines)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_LineChart", NewCT_LineChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Line3DChart", NewCT_Line3DChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_StockChart", NewCT_StockChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ScatterStyle", NewCT_ScatterStyle)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ScatterChart", NewCT_ScatterChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_RadarStyle", NewCT_RadarStyle)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_RadarChart", NewCT_RadarChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_BarGrouping", NewCT_BarGrouping)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_BarDir", NewCT_BarDir)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Shape", NewCT_Shape)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_BarChart", NewCT_BarChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Bar3DChart", NewCT_Bar3DChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_AreaChart", NewCT_AreaChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Area3DChart", NewCT_Area3DChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PieChart", NewCT_PieChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Pie3DChart", NewCT_Pie3DChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_DoughnutChart", NewCT_DoughnutChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_OfPieType", NewCT_OfPieType)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_OfPieChart", NewCT_OfPieChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_BubbleChart", NewCT_BubbleChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_BandFmt", NewCT_BandFmt)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_BandFmts", NewCT_BandFmts)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_SurfaceChart", NewCT_SurfaceChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Surface3DChart", NewCT_Surface3DChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_AxPos", NewCT_AxPos)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Crosses", NewCT_Crosses)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_CrossBetween", NewCT_CrossBetween)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_TickMark", NewCT_TickMark)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_TickLblPos", NewCT_TickLblPos)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Skip", NewCT_Skip)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_TimeUnit", NewCT_TimeUnit)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_AxisUnit", NewCT_AxisUnit)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_BuiltInUnit", NewCT_BuiltInUnit)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PictureFormat", NewCT_PictureFormat)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PictureStackUnit", NewCT_PictureStackUnit)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PictureOptions", NewCT_PictureOptions)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_DispUnitsLbl", NewCT_DispUnitsLbl)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_DispUnits", NewCT_DispUnits)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Orientation", NewCT_Orientation)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_LogBase", NewCT_LogBase)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Scaling", NewCT_Scaling)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_LblOffset", NewCT_LblOffset)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_CatAx", NewCT_CatAx)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_DateAx", NewCT_DateAx)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_SerAx", NewCT_SerAx)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ValAx", NewCT_ValAx)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PlotArea", NewCT_PlotArea)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PivotFmt", NewCT_PivotFmt)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PivotFmts", NewCT_PivotFmts)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_LegendPos", NewCT_LegendPos)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_LegendEntry", NewCT_LegendEntry)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Legend", NewCT_Legend)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_DispBlanksAs", NewCT_DispBlanksAs)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Chart", NewCT_Chart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Style", NewCT_Style)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PivotSource", NewCT_PivotSource)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_Protection", NewCT_Protection)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_HeaderFooter", NewCT_HeaderFooter)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PageMargins", NewCT_PageMargins)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ExternalData", NewCT_ExternalData)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PageSetup", NewCT_PageSetup)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_PrintSettings", NewCT_PrintSettings)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "CT_ChartSpace", NewCT_ChartSpace)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "chartSpace", NewChartSpace)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "userShapes", NewUserShapes)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "chart", NewChart)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "EG_DLblShared", NewEG_DLblShared)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "Group_DLbl", NewGroup_DLbl)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "Group_DLbls", NewGroup_DLbls)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "EG_SerShared", NewEG_SerShared)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "EG_LineChartShared", NewEG_LineChartShared)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "EG_BarChartShared", NewEG_BarChartShared)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "EG_AreaChartShared", NewEG_AreaChartShared)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "EG_PieChartShared", NewEG_PieChartShared)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "EG_SurfaceChartShared", NewEG_SurfaceChartShared)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "EG_AxShared", NewEG_AxShared)
	_b.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml/2006\u002fchart", "EG_LegendEntryData", NewEG_LegendEntryData)
}
