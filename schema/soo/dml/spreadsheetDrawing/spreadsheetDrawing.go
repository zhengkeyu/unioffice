//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package spreadsheetDrawing

import (
	_b "encoding/xml"
	_c "fmt"
	_gc "gitee.com/greatmusicians/unioffice"
	_a "gitee.com/greatmusicians/unioffice/schema/soo/dml"
	_f "strconv"
)

type CT_Marker struct {
	Col    int32
	ColOff _a.ST_Coordinate
	Row    int32
	RowOff _a.ST_Coordinate
}
type CT_ShapeNonVisual struct {
	CNvPr   *_a.CT_NonVisualDrawingProps
	CNvSpPr *_a.CT_NonVisualDrawingShapeProps
}

func NewCT_Shape() *CT_Shape {
	_abf := &CT_Shape{}
	_abf.NvSpPr = NewCT_ShapeNonVisual()
	_abf.SpPr = _a.NewCT_ShapeProperties()
	return _abf
}
func NewCT_GraphicalObjectFrameNonVisual() *CT_GraphicalObjectFrameNonVisual {
	_cfg := &CT_GraphicalObjectFrameNonVisual{}
	_cfg.CNvPr = _a.NewCT_NonVisualDrawingProps()
	_cfg.CNvGraphicFramePr = _a.NewCT_NonVisualGraphicFrameProperties()
	return _cfg
}

// ValidateWithPath validates the CT_GraphicalObjectFrame and its children, prefixing error messages with path
func (_cfb *CT_GraphicalObjectFrame) ValidateWithPath(path string) error {
	if _dbg := _cfb.NvGraphicFramePr.ValidateWithPath(path + "\u002fNvGraphicFramePr"); _dbg != nil {
		return _dbg
	}
	if _de := _cfb.Xfrm.ValidateWithPath(path + "\u002fXfrm"); _de != nil {
		return _de
	}
	if _acc := _cfb.Graphic.ValidateWithPath(path + "\u002fGraphic"); _acc != nil {
		return _acc
	}
	return nil
}

// ValidateWithPath validates the CT_PictureNonVisual and its children, prefixing error messages with path
func (_egga *CT_PictureNonVisual) ValidateWithPath(path string) error {
	if _fbg := _egga.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _fbg != nil {
		return _fbg
	}
	if _dfg := _egga.CNvPicPr.ValidateWithPath(path + "\u002fCNvPicPr"); _dfg != nil {
		return _dfg
	}
	return nil
}
func NewCT_Marker() *CT_Marker { _cac := &CT_Marker{}; _cac.Col = 0; _cac.Row = 0; return _cac }

type CT_Connector struct {
	MacroAttr      *string
	FPublishedAttr *bool
	NvCxnSpPr      *CT_ConnectorNonVisual
	SpPr           *_a.CT_ShapeProperties
	Style          *_a.CT_ShapeStyle
}

// ValidateWithPath validates the CT_Marker and its children, prefixing error messages with path
func (_eacf *CT_Marker) ValidateWithPath(path string) error {
	if _eacf.Col < 0 {
		return _c.Errorf("\u0025s\u002fm\u002eCol must\u0020be \u003e\u003d\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _eacf.Col)
	}
	if _deb := _eacf.ColOff.ValidateWithPath(path + "\u002fColOff"); _deb != nil {
		return _deb
	}
	if _eacf.Row < 0 {
		return _c.Errorf("\u0025s\u002fm\u002eRow must\u0020be \u003e\u003d\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _eacf.Row)
	}
	if _gdag := _eacf.RowOff.ValidateWithPath(path + "\u002fRowOff"); _gdag != nil {
		return _gdag
	}
	return nil
}

// ValidateWithPath validates the CT_GroupShape and its children, prefixing error messages with path
func (_bda *CT_GroupShape) ValidateWithPath(path string) error {
	if _fdb := _bda.NvGrpSpPr.ValidateWithPath(path + "\u002fNvGrpSpPr"); _fdb != nil {
		return _fdb
	}
	if _ffac := _bda.GrpSpPr.ValidateWithPath(path + "\u002fGrpSpPr"); _ffac != nil {
		return _ffac
	}
	for _bbb, _cbc := range _bda.Choice {
		if _fcf := _cbc.ValidateWithPath(_c.Sprintf("\u0025s\u002fChoice\u005b\u0025d\u005d", path, _bbb)); _fcf != nil {
			return _fcf
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Rel and its children, prefixing error messages with path
func (_bcdf *CT_Rel) ValidateWithPath(path string) error { return nil }
func NewCT_OneCellAnchor() *CT_OneCellAnchor {
	_gfc := &CT_OneCellAnchor{}
	_gfc.From = NewCT_Marker()
	_gfc.Ext = _a.NewCT_PositiveSize2D()
	_gfc.ClientData = NewCT_AnchorClientData()
	return _gfc
}

// Validate validates the CT_OneCellAnchor and its children
func (_gadb *CT_OneCellAnchor) Validate() error { return _gadb.ValidateWithPath("CT_OneCellAnchor") }
func (_eegf *ST_EditAs) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_eegf = 0
	case "twoCell":
		*_eegf = 1
	case "oneCell":
		*_eegf = 2
	case "absolute":
		*_eegf = 3
	}
	return nil
}
func _badf(_ddaa bool) uint8 {
	if _ddaa {
		return 1
	}
	return 0
}

type CT_PictureNonVisual struct {
	CNvPr    *_a.CT_NonVisualDrawingProps
	CNvPicPr *_a.CT_NonVisualPictureProperties
}

func (_fcc *CT_PictureNonVisual) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fcc.CNvPr = _a.NewCT_NonVisualDrawingProps()
	_fcc.CNvPicPr = _a.NewCT_NonVisualPictureProperties()
_bbg:
	for {
		_affb, _gba := d.Token()
		if _gba != nil {
			return _gba
		}
		switch _bccc := _affb.(type) {
		case _b.StartElement:
			switch _bccc.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cNvPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cNvPr"}:
				if _feg := d.DecodeElement(_fcc.CNvPr, &_bccc); _feg != nil {
					return _feg
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cNvPicPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cNvPicPr"}:
				if _aefb := d.DecodeElement(_fcc.CNvPicPr, &_bccc); _aefb != nil {
					return _aefb
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PictureNonVisual\u0020\u0025v", _bccc.Name)
				if _cddfd := d.Skip(); _cddfd != nil {
					return _cddfd
				}
			}
		case _b.EndElement:
			break _bbg
		case _b.CharData:
		}
	}
	return nil
}
func (_bbc *WsDr) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "xdr:wsDr"
	return _bbc.CT_Drawing.MarshalXML(e, start)
}
func NewCT_GraphicalObjectFrame() *CT_GraphicalObjectFrame {
	_cfc := &CT_GraphicalObjectFrame{}
	_cfc.NvGraphicFramePr = NewCT_GraphicalObjectFrameNonVisual()
	_cfc.Xfrm = _a.NewCT_Transform2D()
	_cfc.Graphic = _a.NewGraphic()
	return _cfc
}
func (_dad *CT_GraphicalObjectFrame) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dad.NvGraphicFramePr = NewCT_GraphicalObjectFrameNonVisual()
	_dad.Xfrm = _a.NewCT_Transform2D()
	_dad.Graphic = _a.NewGraphic()
	for _, _ac := range start.Attr {
		if _ac.Name.Local == "macro" {
			_dda, _ega := _ac.Value, error(nil)
			if _ega != nil {
				return _ega
			}
			_dad.MacroAttr = &_dda
			continue
		}
		if _ac.Name.Local == "fPublished" {
			_edb, _bad := _f.ParseBool(_ac.Value)
			if _bad != nil {
				return _bad
			}
			_dad.FPublishedAttr = &_edb
			continue
		}
	}
_feb:
	for {
		_ebcc, _ag := d.Token()
		if _ag != nil {
			return _ag
		}
		switch _cda := _ebcc.(type) {
		case _b.StartElement:
			switch _cda.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "nvGraphicFramePr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "nvGraphicFramePr"}:
				if _ggf := d.DecodeElement(_dad.NvGraphicFramePr, &_cda); _ggf != nil {
					return _ggf
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "xfrm"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "xfrm"}:
				if _cdg := d.DecodeElement(_dad.Xfrm, &_cda); _cdg != nil {
					return _cdg
				}
			case _b.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "graphic"}, _b.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "graphic"}:
				if _gcfc := d.DecodeElement(_dad.Graphic, &_cda); _gcfc != nil {
					return _gcfc
				}
			default:
				_gc.Log("skipping\u0020unsupported element\u0020on\u0020CT_GraphicalObjectFrame \u0025v", _cda.Name)
				if _bee := d.Skip(); _bee != nil {
					return _bee
				}
			}
		case _b.EndElement:
			break _feb
		case _b.CharData:
		}
	}
	return nil
}
func (_ccf *CT_Shape) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ccf.MacroAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "macro"}, Value: _c.Sprintf("\u0025v", *_ccf.MacroAttr)})
	}
	if _ccf.TextlinkAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "textlink"}, Value: _c.Sprintf("\u0025v", *_ccf.TextlinkAttr)})
	}
	if _ccf.FLocksTextAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fLocksText"}, Value: _c.Sprintf("\u0025d", _badf(*_ccf.FLocksTextAttr))})
	}
	if _ccf.FPublishedAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fPublished"}, Value: _c.Sprintf("\u0025d", _badf(*_ccf.FPublishedAttr))})
	}
	e.EncodeToken(start)
	_faf := _b.StartElement{Name: _b.Name{Local: "xdr:nvSpPr"}}
	e.EncodeElement(_ccf.NvSpPr, _faf)
	_efgd := _b.StartElement{Name: _b.Name{Local: "xdr:spPr"}}
	e.EncodeElement(_ccf.SpPr, _efgd)
	if _ccf.Style != nil {
		_cabg := _b.StartElement{Name: _b.Name{Local: "xdr:style"}}
		e.EncodeElement(_ccf.Style, _cabg)
	}
	if _ccf.TxBody != nil {
		_bgga := _b.StartElement{Name: _b.Name{Local: "xdr:txBody"}}
		e.EncodeElement(_ccf.TxBody, _bgga)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewCT_Connector() *CT_Connector {
	_gg := &CT_Connector{}
	_gg.NvCxnSpPr = NewCT_ConnectorNonVisual()
	_gg.SpPr = _a.NewCT_ShapeProperties()
	return _gg
}
func (_fcg *CT_Picture) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fcg.NvPicPr = NewCT_PictureNonVisual()
	_fcg.BlipFill = _a.NewCT_BlipFillProperties()
	_fcg.SpPr = _a.NewCT_ShapeProperties()
	for _, _edee := range start.Attr {
		if _edee.Name.Local == "macro" {
			_ace, _eedf := _edee.Value, error(nil)
			if _eedf != nil {
				return _eedf
			}
			_fcg.MacroAttr = &_ace
			continue
		}
		if _edee.Name.Local == "fPublished" {
			_ebdc, _deg := _f.ParseBool(_edee.Value)
			if _deg != nil {
				return _deg
			}
			_fcg.FPublishedAttr = &_ebdc
			continue
		}
	}
_cbe:
	for {
		_gfb, _ebfg := d.Token()
		if _ebfg != nil {
			return _ebfg
		}
		switch _fcae := _gfb.(type) {
		case _b.StartElement:
			switch _fcae.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "nvPicPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "nvPicPr"}:
				if _egca := d.DecodeElement(_fcg.NvPicPr, &_fcae); _egca != nil {
					return _egca
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "blipFill"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "blipFill"}:
				if _afcc := d.DecodeElement(_fcg.BlipFill, &_fcae); _afcc != nil {
					return _afcc
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "spPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "spPr"}:
				if _gbg := d.DecodeElement(_fcg.SpPr, &_fcae); _gbg != nil {
					return _gbg
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "style"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "style"}:
				_fcg.Style = _a.NewCT_ShapeStyle()
				if _fbc := d.DecodeElement(_fcg.Style, &_fcae); _fbc != nil {
					return _fbc
				}
			default:
				_gc.Log("skipping unsupported\u0020element\u0020on\u0020CT_Picture\u0020\u0025v", _fcae.Name)
				if _aged := d.Skip(); _aged != nil {
					return _aged
				}
			}
		case _b.EndElement:
			break _cbe
		case _b.CharData:
		}
	}
	return nil
}
func (_gaa *CT_Rel) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _gaa.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_GroupShapeChoice and its children
func (_beee *CT_GroupShapeChoice) Validate() error {
	return _beee.ValidateWithPath("CT_GroupShapeChoice")
}

type CT_Rel struct{ IdAttr string }

func (_bgb *CT_ConnectorNonVisual) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bgb.CNvPr = _a.NewCT_NonVisualDrawingProps()
	_bgb.CNvCxnSpPr = _a.NewCT_NonVisualConnectorProperties()
_cdf:
	for {
		_af, _ga := d.Token()
		if _ga != nil {
			return _ga
		}
		switch _ebc := _af.(type) {
		case _b.StartElement:
			switch _ebc.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cNvPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cNvPr"}:
				if _cbb := d.DecodeElement(_bgb.CNvPr, &_ebc); _cbb != nil {
					return _cbb
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cNvCxnSpPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cNvCxnSpPr"}:
				if _gaf := d.DecodeElement(_bgb.CNvCxnSpPr, &_ebc); _gaf != nil {
					return _gaf
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on CT_ConnectorNonVisual\u0020\u0025v", _ebc.Name)
				if _gec := d.Skip(); _gec != nil {
					return _gec
				}
			}
		case _b.EndElement:
			break _cdf
		case _b.CharData:
		}
	}
	return nil
}

// Validate validates the CT_GroupShapeNonVisual and its children
func (_cce *CT_GroupShapeNonVisual) Validate() error {
	return _cce.ValidateWithPath("CT_GroupShapeNonVisual")
}
func (_gca *CT_GraphicalObjectFrameNonVisual) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gca.CNvPr = _a.NewCT_NonVisualDrawingProps()
	_gca.CNvGraphicFramePr = _a.NewCT_NonVisualGraphicFrameProperties()
_cec:
	for {
		_cdbe, _gdg := d.Token()
		if _gdg != nil {
			return _gdg
		}
		switch _ccae := _cdbe.(type) {
		case _b.StartElement:
			switch _ccae.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cNvPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cNvPr"}:
				if _edbg := d.DecodeElement(_gca.CNvPr, &_ccae); _edbg != nil {
					return _edbg
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cNvGraphicFramePr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cNvGraphicFramePr"}:
				if _gfg := d.DecodeElement(_gca.CNvGraphicFramePr, &_ccae); _gfg != nil {
					return _gfg
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GraphicalObjectFrameNonVisual\u0020\u0025v", _ccae.Name)
				if _bcd := d.Skip(); _bcd != nil {
					return _bcd
				}
			}
		case _b.EndElement:
			break _cec
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_AnchorClientData and its children, prefixing error messages with path
func (_eef *CT_AnchorClientData) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_Connector and its children, prefixing error messages with path
func (_bcc *CT_Connector) ValidateWithPath(path string) error {
	if _fb := _bcc.NvCxnSpPr.ValidateWithPath(path + "\u002fNvCxnSpPr"); _fb != nil {
		return _fb
	}
	if _aa := _bcc.SpPr.ValidateWithPath(path + "\u002fSpPr"); _aa != nil {
		return _aa
	}
	if _bcc.Style != nil {
		if _dce := _bcc.Style.ValidateWithPath(path + "\u002fStyle"); _dce != nil {
			return _dce
		}
	}
	return nil
}
func NewCT_GroupShapeNonVisual() *CT_GroupShapeNonVisual {
	_edc := &CT_GroupShapeNonVisual{}
	_edc.CNvPr = _a.NewCT_NonVisualDrawingProps()
	_edc.CNvGrpSpPr = _a.NewCT_NonVisualGroupDrawingShapeProps()
	return _edc
}

// ValidateWithPath validates the CT_ConnectorNonVisual and its children, prefixing error messages with path
func (_gf *CT_ConnectorNonVisual) ValidateWithPath(path string) error {
	if _gcf := _gf.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _gcf != nil {
		return _gcf
	}
	if _aeg := _gf.CNvCxnSpPr.ValidateWithPath(path + "/CNvCxnSpPr"); _aeg != nil {
		return _aeg
	}
	return nil
}
func (_ecdd *EG_ObjectChoices) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_eece:
	for {
		_gfbb, _cgd := d.Token()
		if _cgd != nil {
			return _cgd
		}
		switch _cgde := _gfbb.(type) {
		case _b.StartElement:
			switch _cgde.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "sp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "sp"}:
				_ecdd.Choice = NewEG_ObjectChoicesChoice()
				if _edd := d.DecodeElement(&_ecdd.Choice.Sp, &_cgde); _edd != nil {
					return _edd
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "grpSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "grpSp"}:
				_ecdd.Choice = NewEG_ObjectChoicesChoice()
				if _deed := d.DecodeElement(&_ecdd.Choice.GrpSp, &_cgde); _deed != nil {
					return _deed
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "graphicFrame"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "graphicFrame"}:
				_ecdd.Choice = NewEG_ObjectChoicesChoice()
				if _aed := d.DecodeElement(&_ecdd.Choice.GraphicFrame, &_cgde); _aed != nil {
					return _aed
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cxnSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cxnSp"}:
				_ecdd.Choice = NewEG_ObjectChoicesChoice()
				if _ggae := d.DecodeElement(&_ecdd.Choice.CxnSp, &_cgde); _ggae != nil {
					return _ggae
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "pic"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "pic"}:
				_ecdd.Choice = NewEG_ObjectChoicesChoice()
				if _aagd := d.DecodeElement(&_ecdd.Choice.Pic, &_cgde); _aagd != nil {
					return _aagd
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "contentPart"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "contentPart"}:
				_ecdd.Choice = NewEG_ObjectChoicesChoice()
				if _fagg := d.DecodeElement(&_ecdd.Choice.ContentPart, &_cgde); _fagg != nil {
					return _fagg
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_ObjectChoices\u0020\u0025v", _cgde.Name)
				if _dcce := d.Skip(); _dcce != nil {
					return _dcce
				}
			}
		case _b.EndElement:
			break _eece
		case _b.CharData:
		}
	}
	return nil
}
func (_baf *CT_Connector) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_baf.NvCxnSpPr = NewCT_ConnectorNonVisual()
	_baf.SpPr = _a.NewCT_ShapeProperties()
	for _, _cca := range start.Attr {
		if _cca.Name.Local == "macro" {
			_cd, _fda := _cca.Value, error(nil)
			if _fda != nil {
				return _fda
			}
			_baf.MacroAttr = &_cd
			continue
		}
		if _cca.Name.Local == "fPublished" {
			_eae, _adg := _f.ParseBool(_cca.Value)
			if _adg != nil {
				return _adg
			}
			_baf.FPublishedAttr = &_eae
			continue
		}
	}
_gga:
	for {
		_dd, _dae := d.Token()
		if _dae != nil {
			return _dae
		}
		switch _gea := _dd.(type) {
		case _b.StartElement:
			switch _gea.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "nvCxnSpPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "nvCxnSpPr"}:
				if _fge := d.DecodeElement(_baf.NvCxnSpPr, &_gea); _fge != nil {
					return _fge
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "spPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "spPr"}:
				if _eab := d.DecodeElement(_baf.SpPr, &_gea); _eab != nil {
					return _eab
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "style"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "style"}:
				_baf.Style = _a.NewCT_ShapeStyle()
				if _db := d.DecodeElement(_baf.Style, &_gea); _db != nil {
					return _db
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Connector\u0020\u0025v", _gea.Name)
				if _edg := d.Skip(); _edg != nil {
					return _edg
				}
			}
		case _b.EndElement:
			break _gga
		case _b.CharData:
		}
	}
	return nil
}
func (_egf *EG_Anchor) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _egf.TwoCellAnchor != nil {
		_bccd := _b.StartElement{Name: _b.Name{Local: "xdr:twoCellAnchor"}}
		e.EncodeElement(_egf.TwoCellAnchor, _bccd)
	}
	if _egf.OneCellAnchor != nil {
		_bcfg := _b.StartElement{Name: _b.Name{Local: "xdr:oneCellAnchor"}}
		e.EncodeElement(_egf.OneCellAnchor, _bcfg)
	}
	if _egf.AbsoluteAnchor != nil {
		_bcdfb := _b.StartElement{Name: _b.Name{Local: "xdr:absoluteAnchor"}}
		e.EncodeElement(_egf.AbsoluteAnchor, _bcdfb)
	}
	return nil
}

// Validate validates the CT_Shape and its children
func (_fgc *CT_Shape) Validate() error { return _fgc.ValidateWithPath("CT_Shape") }

// Validate validates the From and its children
func (_gcac *From) Validate() error { return _gcac.ValidateWithPath("From") }
func (_bff *CT_TwoCellAnchor) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bff.From = NewCT_Marker()
	_bff.To = NewCT_Marker()
	_bff.ClientData = NewCT_AnchorClientData()
	for _, _bcbd := range start.Attr {
		if _bcbd.Name.Local == "editAs" {
			_bff.EditAsAttr.UnmarshalXMLAttr(_bcbd)
			continue
		}
	}
_gdc:
	for {
		_cabe, _gebc := d.Token()
		if _gebc != nil {
			return _gebc
		}
		switch _dfed := _cabe.(type) {
		case _b.StartElement:
			switch _dfed.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "from"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "from"}:
				if _egae := d.DecodeElement(_bff.From, &_dfed); _egae != nil {
					return _egae
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "to"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "to"}:
				if _ebbd := d.DecodeElement(_bff.To, &_dfed); _ebbd != nil {
					return _ebbd
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "sp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "sp"}:
				_bff.Choice = NewEG_ObjectChoicesChoice()
				if _bba := d.DecodeElement(&_bff.Choice.Sp, &_dfed); _bba != nil {
					return _bba
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "grpSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "grpSp"}:
				_bff.Choice = NewEG_ObjectChoicesChoice()
				if _bfaf := d.DecodeElement(&_bff.Choice.GrpSp, &_dfed); _bfaf != nil {
					return _bfaf
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "graphicFrame"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "graphicFrame"}:
				_bff.Choice = NewEG_ObjectChoicesChoice()
				if _ffca := d.DecodeElement(&_bff.Choice.GraphicFrame, &_dfed); _ffca != nil {
					return _ffca
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cxnSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cxnSp"}:
				_bff.Choice = NewEG_ObjectChoicesChoice()
				if _bag := d.DecodeElement(&_bff.Choice.CxnSp, &_dfed); _bag != nil {
					return _bag
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "pic"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "pic"}:
				_bff.Choice = NewEG_ObjectChoicesChoice()
				if _afdb := d.DecodeElement(&_bff.Choice.Pic, &_dfed); _afdb != nil {
					return _afdb
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "contentPart"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "contentPart"}:
				_bff.Choice = NewEG_ObjectChoicesChoice()
				if _bafg := d.DecodeElement(&_bff.Choice.ContentPart, &_dfed); _bafg != nil {
					return _bafg
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "clientData"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "clientData"}:
				if _ceae := d.DecodeElement(_bff.ClientData, &_dfed); _ceae != nil {
					return _ceae
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TwoCellAnchor\u0020\u0025v", _dfed.Name)
				if _acf := d.Skip(); _acf != nil {
					return _acf
				}
			}
		case _b.EndElement:
			break _gdc
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Shape and its children, prefixing error messages with path
func (_fgae *CT_Shape) ValidateWithPath(path string) error {
	if _bgba := _fgae.NvSpPr.ValidateWithPath(path + "\u002fNvSpPr"); _bgba != nil {
		return _bgba
	}
	if _fggg := _fgae.SpPr.ValidateWithPath(path + "\u002fSpPr"); _fggg != nil {
		return _fggg
	}
	if _fgae.Style != nil {
		if _ecgb := _fgae.Style.ValidateWithPath(path + "\u002fStyle"); _ecgb != nil {
			return _ecgb
		}
	}
	if _fgae.TxBody != nil {
		if _cecb := _fgae.TxBody.ValidateWithPath(path + "\u002fTxBody"); _cecb != nil {
			return _cecb
		}
	}
	return nil
}
func NewEG_Anchor() *EG_Anchor { _ddbeb := &EG_Anchor{}; return _ddbeb }
func (_fea *CT_TwoCellAnchor) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _fea.EditAsAttr != ST_EditAsUnset {
		_abad, _ccfg := _fea.EditAsAttr.MarshalXMLAttr(_b.Name{Local: "editAs"})
		if _ccfg != nil {
			return _ccfg
		}
		start.Attr = append(start.Attr, _abad)
	}
	e.EncodeToken(start)
	_ccaf := _b.StartElement{Name: _b.Name{Local: "xdr:from"}}
	e.EncodeElement(_fea.From, _ccaf)
	_gebe := _b.StartElement{Name: _b.Name{Local: "xdr:to"}}
	e.EncodeElement(_fea.To, _gebe)
	if _fea.Choice != nil {
		_fea.Choice.MarshalXML(e, _b.StartElement{})
	}
	_daea := _b.StartElement{Name: _b.Name{Local: "xdr:clientData"}}
	e.EncodeElement(_fea.ClientData, _daea)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewTo() *To { _dbgaa := &To{}; _dbgaa.CT_Marker = *NewCT_Marker(); return _dbgaa }

// ValidateWithPath validates the CT_Drawing and its children, prefixing error messages with path
func (_addg *CT_Drawing) ValidateWithPath(path string) error {
	for _ce, _aege := range _addg.EG_Anchor {
		if _aded := _aege.ValidateWithPath(_c.Sprintf("\u0025s/EG_Anchor\u005b\u0025d\u005d", path, _ce)); _aded != nil {
			return _aded
		}
	}
	return nil
}
func (_gbc *EG_ObjectChoicesChoice) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_bedg:
	for {
		_ccdf, _efc := d.Token()
		if _efc != nil {
			return _efc
		}
		switch _cbbe := _ccdf.(type) {
		case _b.StartElement:
			switch _cbbe.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "sp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "sp"}:
				_gbc.Sp = NewCT_Shape()
				if _eggd := d.DecodeElement(_gbc.Sp, &_cbbe); _eggd != nil {
					return _eggd
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "grpSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "grpSp"}:
				_gbc.GrpSp = NewCT_GroupShape()
				if _gfeb := d.DecodeElement(_gbc.GrpSp, &_cbbe); _gfeb != nil {
					return _gfeb
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "graphicFrame"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "graphicFrame"}:
				_gbc.GraphicFrame = NewCT_GraphicalObjectFrame()
				if _cbag := d.DecodeElement(_gbc.GraphicFrame, &_cbbe); _cbag != nil {
					return _cbag
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cxnSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cxnSp"}:
				_gbc.CxnSp = NewCT_Connector()
				if _faggb := d.DecodeElement(_gbc.CxnSp, &_cbbe); _faggb != nil {
					return _faggb
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "pic"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "pic"}:
				_gbc.Pic = NewCT_Picture()
				if _fcfd := d.DecodeElement(_gbc.Pic, &_cbbe); _fcfd != nil {
					return _fcfd
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "contentPart"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "contentPart"}:
				_gbc.ContentPart = NewCT_Rel()
				if _acgg := d.DecodeElement(_gbc.ContentPart, &_cbbe); _acgg != nil {
					return _acgg
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_ObjectChoicesChoice\u0020\u0025v", _cbbe.Name)
				if _ccfe := d.Skip(); _ccfe != nil {
					return _ccfe
				}
			}
		case _b.EndElement:
			break _bedg
		case _b.CharData:
		}
	}
	return nil
}
func (_fddc *CT_ShapeNonVisual) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fddc.CNvPr = _a.NewCT_NonVisualDrawingProps()
	_fddc.CNvSpPr = _a.NewCT_NonVisualDrawingShapeProps()
_ffef:
	for {
		_fffd, _daac := d.Token()
		if _daac != nil {
			return _daac
		}
		switch _bgd := _fffd.(type) {
		case _b.StartElement:
			switch _bgd.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cNvPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cNvPr"}:
				if _bea := d.DecodeElement(_fddc.CNvPr, &_bgd); _bea != nil {
					return _bea
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cNvSpPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cNvSpPr"}:
				if _agb := d.DecodeElement(_fddc.CNvSpPr, &_bgd); _agb != nil {
					return _agb
				}
			default:
				_gc.Log("skipping unsupported\u0020element\u0020on\u0020CT_ShapeNonVisual\u0020\u0025v", _bgd.Name)
				if _cffg := d.Skip(); _cffg != nil {
					return _cffg
				}
			}
		case _b.EndElement:
			break _ffef
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the To and its children, prefixing error messages with path
func (_egb *To) ValidateWithPath(path string) error {
	if _dfbcc := _egb.CT_Marker.ValidateWithPath(path); _dfbcc != nil {
		return _dfbcc
	}
	return nil
}
func NewCT_TwoCellAnchor() *CT_TwoCellAnchor {
	_gggf := &CT_TwoCellAnchor{}
	_gggf.From = NewCT_Marker()
	_gggf.To = NewCT_Marker()
	_gggf.ClientData = NewCT_AnchorClientData()
	return _gggf
}

type CT_AnchorClientData struct {
	FLocksWithSheetAttr  *bool
	FPrintsWithSheetAttr *bool
}

// Validate validates the CT_Rel and its children
func (_cedf *CT_Rel) Validate() error { return _cedf.ValidateWithPath("CT_Rel") }

type CT_OneCellAnchor struct {
	From       *CT_Marker
	Ext        *_a.CT_PositiveSize2D
	Choice     *EG_ObjectChoicesChoice
	ClientData *CT_AnchorClientData
}
type CT_AbsoluteAnchor struct {
	Pos        *_a.CT_Point2D
	Ext        *_a.CT_PositiveSize2D
	Choice     *EG_ObjectChoicesChoice
	ClientData *CT_AnchorClientData
}

func NewWsDr() *WsDr { _bfff := &WsDr{}; _bfff.CT_Drawing = *NewCT_Drawing(); return _bfff }
func (_cgbe *CT_PictureNonVisual) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	_abca := _b.StartElement{Name: _b.Name{Local: "xdr:cNvPr"}}
	e.EncodeElement(_cgbe.CNvPr, _abca)
	_bebg := _b.StartElement{Name: _b.Name{Local: "xdr:cNvPicPr"}}
	e.EncodeElement(_cgbe.CNvPicPr, _bebg)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_beb *CT_GroupShapeNonVisual) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_beb.CNvPr = _a.NewCT_NonVisualDrawingProps()
	_beb.CNvGrpSpPr = _a.NewCT_NonVisualGroupDrawingShapeProps()
_cea:
	for {
		_gcgf, _egaf := d.Token()
		if _egaf != nil {
			return _egaf
		}
		switch _bde := _gcgf.(type) {
		case _b.StartElement:
			switch _bde.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cNvPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cNvPr"}:
				if _ded := d.DecodeElement(_beb.CNvPr, &_bde); _ded != nil {
					return _ded
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cNvGrpSpPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cNvGrpSpPr"}:
				if _ccgd := d.DecodeElement(_beb.CNvGrpSpPr, &_bde); _ccgd != nil {
					return _ccgd
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GroupShapeNonVisual\u0020\u0025v", _bde.Name)
				if _aag := d.Skip(); _aag != nil {
					return _aag
				}
			}
		case _b.EndElement:
			break _cea
		case _b.CharData:
		}
	}
	return nil
}
func NewCT_ShapeNonVisual() *CT_ShapeNonVisual {
	_eeb := &CT_ShapeNonVisual{}
	_eeb.CNvPr = _a.NewCT_NonVisualDrawingProps()
	_eeb.CNvSpPr = _a.NewCT_NonVisualDrawingShapeProps()
	return _eeb
}
func (_ede *CT_OneCellAnchor) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	_dee := _b.StartElement{Name: _b.Name{Local: "xdr:from"}}
	e.EncodeElement(_ede.From, _dee)
	_bdb := _b.StartElement{Name: _b.Name{Local: "xdr:ext"}}
	e.EncodeElement(_ede.Ext, _bdb)
	if _ede.Choice != nil {
		_ede.Choice.MarshalXML(e, _b.StartElement{})
	}
	_gcb := _b.StartElement{Name: _b.Name{Local: "xdr:clientData"}}
	e.EncodeElement(_ede.ClientData, _gcb)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type CT_ConnectorNonVisual struct {
	CNvPr      *_a.CT_NonVisualDrawingProps
	CNvCxnSpPr *_a.CT_NonVisualConnectorProperties
}

func (_cgc *To) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "xdr:to"
	return _cgc.CT_Marker.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_GraphicalObjectFrameNonVisual and its children, prefixing error messages with path
func (_eff *CT_GraphicalObjectFrameNonVisual) ValidateWithPath(path string) error {
	if _ffg := _eff.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _ffg != nil {
		return _ffg
	}
	if _gda := _eff.CNvGraphicFramePr.ValidateWithPath(path + "\u002fCNvGraphicFramePr"); _gda != nil {
		return _gda
	}
	return nil
}

// ValidateWithPath validates the EG_Anchor and its children, prefixing error messages with path
func (_aaf *EG_Anchor) ValidateWithPath(path string) error {
	if _aaf.TwoCellAnchor != nil {
		if _bbf := _aaf.TwoCellAnchor.ValidateWithPath(path + "\u002fTwoCellAnchor"); _bbf != nil {
			return _bbf
		}
	}
	if _aaf.OneCellAnchor != nil {
		if _bca := _aaf.OneCellAnchor.ValidateWithPath(path + "\u002fOneCellAnchor"); _bca != nil {
			return _bca
		}
	}
	if _aaf.AbsoluteAnchor != nil {
		if _bfbf := _aaf.AbsoluteAnchor.ValidateWithPath(path + "\u002fAbsoluteAnchor"); _bfbf != nil {
			return _bfbf
		}
	}
	return nil
}
func (_cg *CT_AnchorClientData) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _cg.FLocksWithSheetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fLocksWithSheet"}, Value: _c.Sprintf("\u0025d", _badf(*_cg.FLocksWithSheetAttr))})
	}
	if _cg.FPrintsWithSheetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fPrintsWithSheet"}, Value: _c.Sprintf("\u0025d", _badf(*_cg.FPrintsWithSheetAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_baa *CT_AnchorClientData) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _eec := range start.Attr {
		if _eec.Name.Local == "fLocksWithSheet" {
			_ade, _ea := _f.ParseBool(_eec.Value)
			if _ea != nil {
				return _ea
			}
			_baa.FLocksWithSheetAttr = &_ade
			continue
		}
		if _eec.Name.Local == "fPrintsWithSheet" {
			_ffa, _cgb := _f.ParseBool(_eec.Value)
			if _cgb != nil {
				return _cgb
			}
			_baa.FPrintsWithSheetAttr = &_ffa
			continue
		}
	}
	for {
		_ebb, _fg := d.Token()
		if _fg != nil {
			return _c.Errorf("parsing\u0020CT_AnchorClientData:\u0020\u0025s", _fg)
		}
		if _ed, _ebd := _ebb.(_b.EndElement); _ebd && _ed.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ebg *EG_ObjectChoicesChoice) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ebg.Sp != nil {
		_eabf := _b.StartElement{Name: _b.Name{Local: "xdr:sp"}}
		e.EncodeElement(_ebg.Sp, _eabf)
	}
	if _ebg.GrpSp != nil {
		_dff := _b.StartElement{Name: _b.Name{Local: "xdr:grpSp"}}
		e.EncodeElement(_ebg.GrpSp, _dff)
	}
	if _ebg.GraphicFrame != nil {
		_baag := _b.StartElement{Name: _b.Name{Local: "xdr:graphicFrame"}}
		e.EncodeElement(_ebg.GraphicFrame, _baag)
	}
	if _ebg.CxnSp != nil {
		_bfe := _b.StartElement{Name: _b.Name{Local: "xdr:cxnSp"}}
		e.EncodeElement(_ebg.CxnSp, _bfe)
	}
	if _ebg.Pic != nil {
		_ffab := _b.StartElement{Name: _b.Name{Local: "xdr:pic"}}
		e.EncodeElement(_ebg.Pic, _ffab)
	}
	if _ebg.ContentPart != nil {
		_bdbd := _b.StartElement{Name: _b.Name{Local: "xdr:contentPart"}}
		e.EncodeElement(_ebg.ContentPart, _bdbd)
	}
	return nil
}

// Validate validates the CT_Marker and its children
func (_ccde *CT_Marker) Validate() error { return _ccde.ValidateWithPath("CT_Marker") }

// Validate validates the CT_Connector and its children
func (_bga *CT_Connector) Validate() error { return _bga.ValidateWithPath("CT_Connector") }

type CT_TwoCellAnchor struct {
	EditAsAttr ST_EditAs
	From       *CT_Marker
	To         *CT_Marker
	Choice     *EG_ObjectChoicesChoice
	ClientData *CT_AnchorClientData
}

// Validate validates the CT_GraphicalObjectFrameNonVisual and its children
func (_edgc *CT_GraphicalObjectFrameNonVisual) Validate() error {
	return _edgc.ValidateWithPath("CT_GraphicalObjectFrameNonVisual")
}

type EG_Anchor struct {
	TwoCellAnchor  *CT_TwoCellAnchor
	OneCellAnchor  *CT_OneCellAnchor
	AbsoluteAnchor *CT_AbsoluteAnchor
}

func (_ebbc *CT_ShapeNonVisual) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	_acga := _b.StartElement{Name: _b.Name{Local: "xdr:cNvPr"}}
	e.EncodeElement(_ebbc.CNvPr, _acga)
	_dab := _b.StartElement{Name: _b.Name{Local: "xdr:cNvSpPr"}}
	e.EncodeElement(_ebbc.CNvSpPr, _dab)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_df *CT_GraphicalObjectFrameNonVisual) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	_bb := _b.StartElement{Name: _b.Name{Local: "xdr:cNvPr"}}
	e.EncodeElement(_df.CNvPr, _bb)
	_gfa := _b.StartElement{Name: _b.Name{Local: "xdr:cNvGraphicFramePr"}}
	e.EncodeElement(_df.CNvGraphicFramePr, _gfa)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the From and its children, prefixing error messages with path
func (_fgd *From) ValidateWithPath(path string) error {
	if _ebae := _fgd.CT_Marker.ValidateWithPath(path); _ebae != nil {
		return _ebae
	}
	return nil
}

type CT_GroupShapeNonVisual struct {
	CNvPr      *_a.CT_NonVisualDrawingProps
	CNvGrpSpPr *_a.CT_NonVisualGroupDrawingShapeProps
}

func (_bcf *CT_GraphicalObjectFrame) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bcf.MacroAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "macro"}, Value: _c.Sprintf("\u0025v", *_bcf.MacroAttr)})
	}
	if _bcf.FPublishedAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fPublished"}, Value: _c.Sprintf("\u0025d", _badf(*_bcf.FPublishedAttr))})
	}
	e.EncodeToken(start)
	_fcd := _b.StartElement{Name: _b.Name{Local: "xdr:nvGraphicFramePr"}}
	e.EncodeElement(_bcf.NvGraphicFramePr, _fcd)
	_abc := _b.StartElement{Name: _b.Name{Local: "xdr:xfrm"}}
	e.EncodeElement(_bcf.Xfrm, _abc)
	_aea := _b.StartElement{Name: _b.Name{Local: "a:graphic"}}
	_aea.Attr = append(_aea.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	e.EncodeElement(_bcf.Graphic, _aea)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the EG_ObjectChoicesChoice and its children, prefixing error messages with path
func (_dddf *EG_ObjectChoicesChoice) ValidateWithPath(path string) error {
	if _dddf.Sp != nil {
		if _fbe := _dddf.Sp.ValidateWithPath(path + "\u002fSp"); _fbe != nil {
			return _fbe
		}
	}
	if _dddf.GrpSp != nil {
		if _cbbeb := _dddf.GrpSp.ValidateWithPath(path + "\u002fGrpSp"); _cbbeb != nil {
			return _cbbeb
		}
	}
	if _dddf.GraphicFrame != nil {
		if _fecb := _dddf.GraphicFrame.ValidateWithPath(path + "\u002fGraphicFrame"); _fecb != nil {
			return _fecb
		}
	}
	if _dddf.CxnSp != nil {
		if _afca := _dddf.CxnSp.ValidateWithPath(path + "\u002fCxnSp"); _afca != nil {
			return _afca
		}
	}
	if _dddf.Pic != nil {
		if _ccgg := _dddf.Pic.ValidateWithPath(path + "\u002fPic"); _ccgg != nil {
			return _ccgg
		}
	}
	if _dddf.ContentPart != nil {
		if _ccdeb := _dddf.ContentPart.ValidateWithPath(path + "\u002fContentPart"); _ccdeb != nil {
			return _ccdeb
		}
	}
	return nil
}

// Validate validates the EG_Anchor and its children
func (_ceg *EG_Anchor) Validate() error { return _ceg.ValidateWithPath("EG_Anchor") }

// Validate validates the CT_GraphicalObjectFrame and its children
func (_bfbe *CT_GraphicalObjectFrame) Validate() error {
	return _bfbe.ValidateWithPath("CT_GraphicalObjectFrame")
}
func (_ddf *CT_Picture) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ddf.MacroAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "macro"}, Value: _c.Sprintf("\u0025v", *_ddf.MacroAttr)})
	}
	if _ddf.FPublishedAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fPublished"}, Value: _c.Sprintf("\u0025d", _badf(*_ddf.FPublishedAttr))})
	}
	e.EncodeToken(start)
	_eba := _b.StartElement{Name: _b.Name{Local: "xdr:nvPicPr"}}
	e.EncodeElement(_ddf.NvPicPr, _eba)
	_fdg := _b.StartElement{Name: _b.Name{Local: "xdr:blipFill"}}
	e.EncodeElement(_ddf.BlipFill, _fdg)
	_egdg := _b.StartElement{Name: _b.Name{Local: "xdr:spPr"}}
	e.EncodeElement(_ddf.SpPr, _egdg)
	if _ddf.Style != nil {
		_dgc := _b.StartElement{Name: _b.Name{Local: "xdr:style"}}
		e.EncodeElement(_ddf.Style, _dgc)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_ffe *CT_ConnectorNonVisual) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	_ab := _b.StartElement{Name: _b.Name{Local: "xdr:cNvPr"}}
	e.EncodeElement(_ffe.CNvPr, _ab)
	_fee := _b.StartElement{Name: _b.Name{Local: "xdr:cNvCxnSpPr"}}
	e.EncodeElement(_ffe.CNvCxnSpPr, _fee)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type CT_GroupShape struct {
	NvGrpSpPr *CT_GroupShapeNonVisual
	GrpSpPr   *_a.CT_GroupShapeProperties
	Choice    []*CT_GroupShapeChoice
}

func NewCT_Drawing() *CT_Drawing { _bec := &CT_Drawing{}; return _bec }
func (_gfbd *From) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xdr"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "xdr:from"
	return _gfbd.CT_Marker.MarshalXML(e, start)
}
func (_egd *CT_AbsoluteAnchor) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_egd.Pos = _a.NewCT_Point2D()
	_egd.Ext = _a.NewCT_PositiveSize2D()
	_egd.ClientData = NewCT_AnchorClientData()
_ef:
	for {
		_ad, _eb := d.Token()
		if _eb != nil {
			return _eb
		}
		switch _ff := _ad.(type) {
		case _b.StartElement:
			switch _ff.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "pos"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "pos"}:
				if _bc := d.DecodeElement(_egd.Pos, &_ff); _bc != nil {
					return _bc
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "ext"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "ext"}:
				if _d := d.DecodeElement(_egd.Ext, &_ff); _d != nil {
					return _d
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "sp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "sp"}:
				_egd.Choice = NewEG_ObjectChoicesChoice()
				if _fe := d.DecodeElement(&_egd.Choice.Sp, &_ff); _fe != nil {
					return _fe
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "grpSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "grpSp"}:
				_egd.Choice = NewEG_ObjectChoicesChoice()
				if _gd := d.DecodeElement(&_egd.Choice.GrpSp, &_ff); _gd != nil {
					return _gd
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "graphicFrame"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "graphicFrame"}:
				_egd.Choice = NewEG_ObjectChoicesChoice()
				if _dc := d.DecodeElement(&_egd.Choice.GraphicFrame, &_ff); _dc != nil {
					return _dc
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cxnSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cxnSp"}:
				_egd.Choice = NewEG_ObjectChoicesChoice()
				if _bcb := d.DecodeElement(&_egd.Choice.CxnSp, &_ff); _bcb != nil {
					return _bcb
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "pic"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "pic"}:
				_egd.Choice = NewEG_ObjectChoicesChoice()
				if _ccg := d.DecodeElement(&_egd.Choice.Pic, &_ff); _ccg != nil {
					return _ccg
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "contentPart"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "contentPart"}:
				_egd.Choice = NewEG_ObjectChoicesChoice()
				if _fab := d.DecodeElement(&_egd.Choice.ContentPart, &_ff); _fab != nil {
					return _fab
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "clientData"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "clientData"}:
				if _eed := d.DecodeElement(_egd.ClientData, &_ff); _eed != nil {
					return _eed
				}
			default:
				_gc.Log("skipping unsupported\u0020element\u0020on\u0020CT_AbsoluteAnchor\u0020\u0025v", _ff.Name)
				if _fd := d.Skip(); _fd != nil {
					return _fd
				}
			}
		case _b.EndElement:
			break _ef
		case _b.CharData:
		}
	}
	return nil
}

type From struct{ CT_Marker }

func (_bgad *CT_Shape) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bgad.NvSpPr = NewCT_ShapeNonVisual()
	_bgad.SpPr = _a.NewCT_ShapeProperties()
	for _, _edf := range start.Attr {
		if _edf.Name.Local == "macro" {
			_bbgg, _cbf := _edf.Value, error(nil)
			if _cbf != nil {
				return _cbf
			}
			_bgad.MacroAttr = &_bbgg
			continue
		}
		if _edf.Name.Local == "textlink" {
			_gbbd, _dfe := _edf.Value, error(nil)
			if _dfe != nil {
				return _dfe
			}
			_bgad.TextlinkAttr = &_gbbd
			continue
		}
		if _edf.Name.Local == "fLocksText" {
			_afb, _dbc := _f.ParseBool(_edf.Value)
			if _dbc != nil {
				return _dbc
			}
			_bgad.FLocksTextAttr = &_afb
			continue
		}
		if _edf.Name.Local == "fPublished" {
			_gfe, _dfb := _f.ParseBool(_edf.Value)
			if _dfb != nil {
				return _dfb
			}
			_bgad.FPublishedAttr = &_gfe
			continue
		}
	}
_ecde:
	for {
		_gceg, _ecg := d.Token()
		if _ecg != nil {
			return _ecg
		}
		switch _ebcg := _gceg.(type) {
		case _b.StartElement:
			switch _ebcg.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "nvSpPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "nvSpPr"}:
				if _aebe := d.DecodeElement(_bgad.NvSpPr, &_ebcg); _aebe != nil {
					return _aebe
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "spPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "spPr"}:
				if _deba := d.DecodeElement(_bgad.SpPr, &_ebcg); _deba != nil {
					return _deba
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "style"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "style"}:
				_bgad.Style = _a.NewCT_ShapeStyle()
				if _abg := d.DecodeElement(_bgad.Style, &_ebcg); _abg != nil {
					return _abg
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "txBody"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "txBody"}:
				_bgad.TxBody = _a.NewCT_TextBody()
				if _dgf := d.DecodeElement(_bgad.TxBody, &_ebcg); _dgf != nil {
					return _dgf
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Shape\u0020\u0025v", _ebcg.Name)
				if _eea := d.Skip(); _eea != nil {
					return _eea
				}
			}
		case _b.EndElement:
			break _ecde
		case _b.CharData:
		}
	}
	return nil
}

type To struct{ CT_Marker }
type ST_EditAs byte

// ValidateWithPath validates the EG_ObjectChoices and its children, prefixing error messages with path
func (_accca *EG_ObjectChoices) ValidateWithPath(path string) error {
	if _accca.Choice != nil {
		if _acde := _accca.Choice.ValidateWithPath(path + "\u002fChoice"); _acde != nil {
			return _acde
		}
	}
	return nil
}
func (_deaf ST_EditAs) Validate() error { return _deaf.ValidateWithPath("") }

// ValidateWithPath validates the WsDr and its children, prefixing error messages with path
func (_eacg *WsDr) ValidateWithPath(path string) error {
	if _bgaa := _eacg.CT_Drawing.ValidateWithPath(path); _bgaa != nil {
		return _bgaa
	}
	return nil
}

type CT_GraphicalObjectFrameNonVisual struct {
	CNvPr             *_a.CT_NonVisualDrawingProps
	CNvGraphicFramePr *_a.CT_NonVisualGraphicFrameProperties
}

func (_ee *CT_AbsoluteAnchor) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	_fa := _b.StartElement{Name: _b.Name{Local: "xdr:pos"}}
	e.EncodeElement(_ee.Pos, _fa)
	_eg := _b.StartElement{Name: _b.Name{Local: "xdr:ext"}}
	e.EncodeElement(_ee.Ext, _eg)
	if _ee.Choice != nil {
		_ee.Choice.MarshalXML(e, _b.StartElement{})
	}
	_cc := _b.StartElement{Name: _b.Name{Local: "xdr:clientData"}}
	e.EncodeElement(_ee.ClientData, _cc)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewCT_PictureNonVisual() *CT_PictureNonVisual {
	_becf := &CT_PictureNonVisual{}
	_becf.CNvPr = _a.NewCT_NonVisualDrawingProps()
	_becf.CNvPicPr = _a.NewCT_NonVisualPictureProperties()
	return _becf
}
func (_bedf ST_EditAs) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bedf.String(), start)
}
func NewCT_GroupShape() *CT_GroupShape {
	_aaad := &CT_GroupShape{}
	_aaad.NvGrpSpPr = NewCT_GroupShapeNonVisual()
	_aaad.GrpSpPr = _a.NewCT_GroupShapeProperties()
	return _aaad
}

// Validate validates the CT_GroupShape and its children
func (_faa *CT_GroupShape) Validate() error { return _faa.ValidateWithPath("CT_GroupShape") }

// Validate validates the CT_Picture and its children
func (_cdae *CT_Picture) Validate() error { return _cdae.ValidateWithPath("CT_Picture") }
func (_ddb *CT_GroupShapeChoice) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ddb.Sp != nil {
		_fec := _b.StartElement{Name: _b.Name{Local: "xdr:sp"}}
		for _, _eda := range _ddb.Sp {
			e.EncodeElement(_eda, _fec)
		}
	}
	if _ddb.GrpSp != nil {
		_bce := _b.StartElement{Name: _b.Name{Local: "xdr:grpSp"}}
		for _, _ggdf := range _ddb.GrpSp {
			e.EncodeElement(_ggdf, _bce)
		}
	}
	if _ddb.GraphicFrame != nil {
		_acb := _b.StartElement{Name: _b.Name{Local: "xdr:graphicFrame"}}
		for _, _bdde := range _ddb.GraphicFrame {
			e.EncodeElement(_bdde, _acb)
		}
	}
	if _ddb.CxnSp != nil {
		_dbgd := _b.StartElement{Name: _b.Name{Local: "xdr:cxnSp"}}
		for _, _efeg := range _ddb.CxnSp {
			e.EncodeElement(_efeg, _dbgd)
		}
	}
	if _ddb.Pic != nil {
		_ec := _b.StartElement{Name: _b.Name{Local: "xdr:pic"}}
		for _, _fad := range _ddb.Pic {
			e.EncodeElement(_fad, _ec)
		}
	}
	return nil
}
func NewCT_ConnectorNonVisual() *CT_ConnectorNonVisual {
	_cf := &CT_ConnectorNonVisual{}
	_cf.CNvPr = _a.NewCT_NonVisualDrawingProps()
	_cf.CNvCxnSpPr = _a.NewCT_NonVisualConnectorProperties()
	return _cf
}

// Validate validates the CT_ShapeNonVisual and its children
func (_agea *CT_ShapeNonVisual) Validate() error { return _agea.ValidateWithPath("CT_ShapeNonVisual") }
func (_dbb *CT_GroupShapeChoice) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_cdcb:
	for {
		_gag, _ddd := d.Token()
		if _ddd != nil {
			return _ddd
		}
		switch _gcg := _gag.(type) {
		case _b.StartElement:
			switch _gcg.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "sp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "sp"}:
				_dg := NewCT_Shape()
				if _abd := d.DecodeElement(_dg, &_gcg); _abd != nil {
					return _abd
				}
				_dbb.Sp = append(_dbb.Sp, _dg)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "grpSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "grpSp"}:
				_cfgb := NewCT_GroupShape()
				if _efg := d.DecodeElement(_cfgb, &_gcg); _efg != nil {
					return _efg
				}
				_dbb.GrpSp = append(_dbb.GrpSp, _cfgb)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "graphicFrame"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "graphicFrame"}:
				_cba := NewCT_GraphicalObjectFrame()
				if _cab := d.DecodeElement(_cba, &_gcg); _cab != nil {
					return _cab
				}
				_dbb.GraphicFrame = append(_dbb.GraphicFrame, _cba)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cxnSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cxnSp"}:
				_ggg := NewCT_Connector()
				if _ccd := d.DecodeElement(_ggg, &_gcg); _ccd != nil {
					return _ccd
				}
				_dbb.CxnSp = append(_dbb.CxnSp, _ggg)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "pic"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "pic"}:
				_egc := NewCT_Picture()
				if _gdb := d.DecodeElement(_egc, &_gcg); _gdb != nil {
					return _gdb
				}
				_dbb.Pic = append(_dbb.Pic, _egc)
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GroupShapeChoice\u0020\u0025v", _gcg.Name)
				if _feeb := d.Skip(); _feeb != nil {
					return _feeb
				}
			}
		case _b.EndElement:
			break _cdcb
		case _b.CharData:
		}
	}
	return nil
}

type EG_ObjectChoices struct{ Choice *EG_ObjectChoicesChoice }

func (_ffabd ST_EditAs) String() string {
	switch _ffabd {
	case 0:
		return ""
	case 1:
		return "twoCell"
	case 2:
		return "oneCell"
	case 3:
		return "absolute"
	}
	return ""
}
func (_cfge *CT_GroupShape) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cfge.NvGrpSpPr = NewCT_GroupShapeNonVisual()
	_cfge.GrpSpPr = _a.NewCT_GroupShapeProperties()
_eag:
	for {
		_fgg, _agf := d.Token()
		if _agf != nil {
			return _agf
		}
		switch _gce := _fgg.(type) {
		case _b.StartElement:
			switch _gce.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "nvGrpSpPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "nvGrpSpPr"}:
				if _eaa := d.DecodeElement(_cfge.NvGrpSpPr, &_gce); _eaa != nil {
					return _eaa
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "grpSpPr"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "grpSpPr"}:
				if _ffc := d.DecodeElement(_cfge.GrpSpPr, &_gce); _ffc != nil {
					return _ffc
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "sp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "sp"}:
				_fcdf := NewCT_GroupShapeChoice()
				if _dcf := d.DecodeElement(&_fcdf.Sp, &_gce); _dcf != nil {
					return _dcf
				}
				_cfge.Choice = append(_cfge.Choice, _fcdf)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "grpSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "grpSp"}:
				_bddc := NewCT_GroupShapeChoice()
				if _dcc := d.DecodeElement(&_bddc.GrpSp, &_gce); _dcc != nil {
					return _dcc
				}
				_cfge.Choice = append(_cfge.Choice, _bddc)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "graphicFrame"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "graphicFrame"}:
				_baad := NewCT_GroupShapeChoice()
				if _dcb := d.DecodeElement(&_baad.GraphicFrame, &_gce); _dcb != nil {
					return _dcb
				}
				_cfge.Choice = append(_cfge.Choice, _baad)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cxnSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cxnSp"}:
				_eaf := NewCT_GroupShapeChoice()
				if _cgf := d.DecodeElement(&_eaf.CxnSp, &_gce); _cgf != nil {
					return _cgf
				}
				_cfge.Choice = append(_cfge.Choice, _eaf)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "pic"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "pic"}:
				_bef := NewCT_GroupShapeChoice()
				if _geg := d.DecodeElement(&_bef.Pic, &_gce); _geg != nil {
					return _geg
				}
				_cfge.Choice = append(_cfge.Choice, _bef)
			default:
				_gc.Log("skipping unsupported element\u0020on\u0020CT_GroupShape \u0025v", _gce.Name)
				if _adb := d.Skip(); _adb != nil {
					return _adb
				}
			}
		case _b.EndElement:
			break _eag
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_GroupShapeChoice and its children, prefixing error messages with path
func (_gfaf *CT_GroupShapeChoice) ValidateWithPath(path string) error {
	for _dec, _eeca := range _gfaf.Sp {
		if _eagc := _eeca.ValidateWithPath(_c.Sprintf("\u0025s\u002fSp\u005b\u0025d]", path, _dec)); _eagc != nil {
			return _eagc
		}
	}
	for _cdba, _dcba := range _gfaf.GrpSp {
		if _eaab := _dcba.ValidateWithPath(_c.Sprintf("\u0025s\u002fGrpSp\u005b\u0025d\u005d", path, _cdba)); _eaab != nil {
			return _eaab
		}
	}
	for _fef, _geac := range _gfaf.GraphicFrame {
		if _efa := _geac.ValidateWithPath(_c.Sprintf("\u0025s\u002fGraphicFrame\u005b\u0025d\u005d", path, _fef)); _efa != nil {
			return _efa
		}
	}
	for _fdd, _eac := range _gfaf.CxnSp {
		if _aba := _eac.ValidateWithPath(_c.Sprintf("\u0025s\u002fCxnSp\u005b\u0025d\u005d", path, _fdd)); _aba != nil {
			return _aba
		}
	}
	for _fdc, _efaf := range _gfaf.Pic {
		if _cag := _efaf.ValidateWithPath(_c.Sprintf("\u0025s\u002fPic\u005b\u0025d\u005d", path, _fdc)); _cag != nil {
			return _cag
		}
	}
	return nil
}
func NewCT_AbsoluteAnchor() *CT_AbsoluteAnchor {
	_e := &CT_AbsoluteAnchor{}
	_e.Pos = _a.NewCT_Point2D()
	_e.Ext = _a.NewCT_PositiveSize2D()
	_e.ClientData = NewCT_AnchorClientData()
	return _e
}
func NewCT_GroupShapeChoice() *CT_GroupShapeChoice { _fca := &CT_GroupShapeChoice{}; return _fca }
func (_edaf *To) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_edaf.CT_Marker = *NewCT_Marker()
_ecff:
	for {
		_ggdg, _cgee := d.Token()
		if _cgee != nil {
			return _cgee
		}
		switch _fege := _ggdg.(type) {
		case _b.StartElement:
			switch _fege.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "col"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "col"}:
				if _efgc := d.DecodeElement(&_edaf.Col, &_fege); _efgc != nil {
					return _efgc
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "colOff"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "colOff"}:
				_dcee, _fdce := d.Token()
				if _fdce != nil {
					return _fdce
				}
				switch _bbgb := _dcee.(type) {
				case _b.CharData:
					_bbd := string(_bbgb)
					_gcgfe, _beab := _a.ParseUnionST_Coordinate(_bbd)
					if _beab != nil {
						return nil
					}
					_edaf.ColOff = _gcgfe
					d.Skip()
				case _b.EndElement:
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "row"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "row"}:
				if _dbbd := d.DecodeElement(&_edaf.Row, &_fege); _dbbd != nil {
					return _dbbd
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "rowOff"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "rowOff"}:
				_ffb, _edaa := d.Token()
				if _edaa != nil {
					return _edaa
				}
				switch _bgf := _ffb.(type) {
				case _b.CharData:
					_bagb := string(_bgf)
					_dge, _eedfg := _a.ParseUnionST_Coordinate(_bagb)
					if _eedfg != nil {
						return nil
					}
					_edaf.RowOff = _dge
					d.Skip()
				case _b.EndElement:
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on\u0020To\u0020\u0025v", _fege.Name)
				if _aafe := d.Skip(); _aafe != nil {
					return _aafe
				}
			}
		case _b.EndElement:
			break _ecff
		case _b.CharData:
		}
	}
	return nil
}
func NewEG_ObjectChoicesChoice() *EG_ObjectChoicesChoice {
	_cgda := &EG_ObjectChoicesChoice{}
	return _cgda
}
func (_bdad *From) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bdad.CT_Marker = *NewCT_Marker()
_beae:
	for {
		_dca, _gab := d.Token()
		if _gab != nil {
			return _gab
		}
		switch _gabf := _dca.(type) {
		case _b.StartElement:
			switch _gabf.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "col"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "col"}:
				if _ecf := d.DecodeElement(&_bdad.Col, &_gabf); _ecf != nil {
					return _ecf
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "colOff"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "colOff"}:
				_cbce, _dbd := d.Token()
				if _dbd != nil {
					return _dbd
				}
				switch _cdbc := _cbce.(type) {
				case _b.CharData:
					_dbe := string(_cdbc)
					_abda, _feba := _a.ParseUnionST_Coordinate(_dbe)
					if _feba != nil {
						return nil
					}
					_bdad.ColOff = _abda
					d.Skip()
				case _b.EndElement:
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "row"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "row"}:
				if _aga := d.DecodeElement(&_bdad.Row, &_gabf); _aga != nil {
					return _aga
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "rowOff"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "rowOff"}:
				_edbb, _gaac := d.Token()
				if _gaac != nil {
					return _gaac
				}
				switch _cace := _edbb.(type) {
				case _b.CharData:
					_efegf := string(_cace)
					_gbd, _ebef := _a.ParseUnionST_Coordinate(_efegf)
					if _ebef != nil {
						return nil
					}
					_bdad.RowOff = _gbd
					d.Skip()
				case _b.EndElement:
				}
			default:
				_gc.Log("skipping\u0020unsupported element\u0020on\u0020From\u0020\u0025v", _gabf.Name)
				if _cdfg := d.Skip(); _cdfg != nil {
					return _cdfg
				}
			}
		case _b.EndElement:
			break _beae
		case _b.CharData:
		}
	}
	return nil
}
func NewCT_AnchorClientData() *CT_AnchorClientData { _be := &CT_AnchorClientData{}; return _be }
func (_gac *EG_Anchor) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_cbg:
	for {
		_aaga, _dde := d.Token()
		if _dde != nil {
			return _dde
		}
		switch _gdd := _aaga.(type) {
		case _b.StartElement:
			switch _gdd.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "twoCellAnchor"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "twoCellAnchor"}:
				_gac.TwoCellAnchor = NewCT_TwoCellAnchor()
				if _cfd := d.DecodeElement(_gac.TwoCellAnchor, &_gdd); _cfd != nil {
					return _cfd
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "oneCellAnchor"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "oneCellAnchor"}:
				_gac.OneCellAnchor = NewCT_OneCellAnchor()
				if _eggb := d.DecodeElement(_gac.OneCellAnchor, &_gdd); _eggb != nil {
					return _eggb
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "absoluteAnchor"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "absoluteAnchor"}:
				_gac.AbsoluteAnchor = NewCT_AbsoluteAnchor()
				if _cee := d.DecodeElement(_gac.AbsoluteAnchor, &_gdd); _cee != nil {
					return _cee
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element on EG_Anchor \u0025v", _gdd.Name)
				if _ddbg := d.Skip(); _ddbg != nil {
					return _ddbg
				}
			}
		case _b.EndElement:
			break _cbg
		case _b.CharData:
		}
	}
	return nil
}

type EG_ObjectChoicesChoice struct {
	Sp           *CT_Shape
	GrpSp        *CT_GroupShape
	GraphicFrame *CT_GraphicalObjectFrame
	CxnSp        *CT_Connector
	Pic          *CT_Picture
	ContentPart  *CT_Rel
}

// Validate validates the WsDr and its children
func (_ecfe *WsDr) Validate() error { return _ecfe.ValidateWithPath("WsDr") }

// Validate validates the CT_Drawing and its children
func (_ead *CT_Drawing) Validate() error { return _ead.ValidateWithPath("CT_Drawing") }

// Validate validates the CT_PictureNonVisual and its children
func (_gbb *CT_PictureNonVisual) Validate() error {
	return _gbb.ValidateWithPath("CT_PictureNonVisual")
}

// ValidateWithPath validates the CT_Picture and its children, prefixing error messages with path
func (_bfbb *CT_Picture) ValidateWithPath(path string) error {
	if _fff := _bfbb.NvPicPr.ValidateWithPath(path + "\u002fNvPicPr"); _fff != nil {
		return _fff
	}
	if _fga := _bfbb.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _fga != nil {
		return _fga
	}
	if _dgd := _bfbb.SpPr.ValidateWithPath(path + "\u002fSpPr"); _dgd != nil {
		return _dgd
	}
	if _bfbb.Style != nil {
		if _daa := _bfbb.Style.ValidateWithPath(path + "\u002fStyle"); _daa != nil {
			return _daa
		}
	}
	return nil
}

// Validate validates the CT_ConnectorNonVisual and its children
func (_aaa *CT_ConnectorNonVisual) Validate() error {
	return _aaa.ValidateWithPath("CT_ConnectorNonVisual")
}
func (_cdca *CT_Rel) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _aeaf := range start.Attr {
		if _aeaf.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _aeaf.Name.Local == "id" || _aeaf.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _aeaf.Name.Local == "id" {
			_fde, _acg := _aeaf.Value, error(nil)
			if _acg != nil {
				return _acg
			}
			_cdca.IdAttr = _fde
			continue
		}
	}
	for {
		_bfbg, _aad := d.Token()
		if _aad != nil {
			return _c.Errorf("parsing\u0020CT_Rel:\u0020\u0025s", _aad)
		}
		if _bfbbf, _ccga := _bfbg.(_b.EndElement); _ccga && _bfbbf.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_GroupShapeNonVisual and its children, prefixing error messages with path
func (_afd *CT_GroupShapeNonVisual) ValidateWithPath(path string) error {
	if _cbd := _afd.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _cbd != nil {
		return _cbd
	}
	if _aff := _afd.CNvGrpSpPr.ValidateWithPath(path + "/CNvGrpSpPr"); _aff != nil {
		return _aff
	}
	return nil
}
func NewFrom() *From { _caf := &From{}; _caf.CT_Marker = *NewCT_Marker(); return _caf }
func (_bced *WsDr) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bced.CT_Drawing = *NewCT_Drawing()
_ceea:
	for {
		_abge, _aagad := d.Token()
		if _aagad != nil {
			return _aagad
		}
		switch _eaac := _abge.(type) {
		case _b.StartElement:
			switch _eaac.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "twoCellAnchor"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "twoCellAnchor"}:
				_fcea := NewEG_Anchor()
				_fcea.TwoCellAnchor = NewCT_TwoCellAnchor()
				if _gae := d.DecodeElement(_fcea.TwoCellAnchor, &_eaac); _gae != nil {
					return _gae
				}
				_bced.EG_Anchor = append(_bced.EG_Anchor, _fcea)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "oneCellAnchor"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "oneCellAnchor"}:
				_cga := NewEG_Anchor()
				_cga.OneCellAnchor = NewCT_OneCellAnchor()
				if _fafe := d.DecodeElement(_cga.OneCellAnchor, &_eaac); _fafe != nil {
					return _fafe
				}
				_bced.EG_Anchor = append(_bced.EG_Anchor, _cga)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "absoluteAnchor"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "absoluteAnchor"}:
				_afce := NewEG_Anchor()
				_afce.AbsoluteAnchor = NewCT_AbsoluteAnchor()
				if _bbe := d.DecodeElement(_afce.AbsoluteAnchor, &_eaac); _bbe != nil {
					return _bbe
				}
				_bced.EG_Anchor = append(_bced.EG_Anchor, _afce)
			default:
				_gc.Log("skipping\u0020unsupported element\u0020on\u0020WsDr\u0020\u0025v", _eaac.Name)
				if _gaaa := d.Skip(); _gaaa != nil {
					return _gaaa
				}
			}
		case _b.EndElement:
			break _ceea
		case _b.CharData:
		}
	}
	return nil
}

// Validate validates the CT_AbsoluteAnchor and its children
func (_ge *CT_AbsoluteAnchor) Validate() error { return _ge.ValidateWithPath("CT_AbsoluteAnchor") }
func (_egac *ST_EditAs) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cbdd, _ffad := d.Token()
	if _ffad != nil {
		return _ffad
	}
	if _dabd, _gbbc := _cbdd.(_b.EndElement); _gbbc && _dabd.Name == start.Name {
		*_egac = 1
		return nil
	}
	if _acgga, _bdcb := _cbdd.(_b.CharData); !_bdcb {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cbdd)
	} else {
		switch string(_acgga) {
		case "":
			*_egac = 0
		case "twoCell":
			*_egac = 1
		case "oneCell":
			*_egac = 2
		case "absolute":
			*_egac = 3
		}
	}
	_cbdd, _ffad = d.Token()
	if _ffad != nil {
		return _ffad
	}
	if _aedf, _bcca := _cbdd.(_b.EndElement); _bcca && _aedf.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cbdd)
}

// ValidateWithPath validates the CT_AbsoluteAnchor and its children, prefixing error messages with path
func (_egg *CT_AbsoluteAnchor) ValidateWithPath(path string) error {
	if _ffd := _egg.Pos.ValidateWithPath(path + "\u002fPos"); _ffd != nil {
		return _ffd
	}
	if _add := _egg.Ext.ValidateWithPath(path + "\u002fExt"); _add != nil {
		return _add
	}
	if _egg.Choice != nil {
		if _ba := _egg.Choice.ValidateWithPath(path + "\u002fChoice"); _ba != nil {
			return _ba
		}
	}
	if _efe := _egg.ClientData.ValidateWithPath(path + "/ClientData"); _efe != nil {
		return _efe
	}
	return nil
}

const (
	ST_EditAsUnset    ST_EditAs = 0
	ST_EditAsTwoCell  ST_EditAs = 1
	ST_EditAsOneCell  ST_EditAs = 2
	ST_EditAsAbsolute ST_EditAs = 3
)

func (_bed *CT_Marker) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bed.Col = 0
	_bed.Row = 0
_gdba:
	for {
		_gdf, _eabe := d.Token()
		if _eabe != nil {
			return _eabe
		}
		switch _ece := _gdf.(type) {
		case _b.StartElement:
			switch _ece.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "col"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "col"}:
				if _fcb := d.DecodeElement(&_bed.Col, &_ece); _fcb != nil {
					return _fcb
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "colOff"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "colOff"}:
				_gcgg, _eedc := d.Token()
				if _eedc != nil {
					return _eedc
				}
				switch _dddg := _gcgg.(type) {
				case _b.CharData:
					_cffe := string(_dddg)
					_bcg, _gege := _a.ParseUnionST_Coordinate(_cffe)
					if _gege != nil {
						return nil
					}
					_bed.ColOff = _bcg
					d.Skip()
				case _b.EndElement:
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "row"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "row"}:
				if _ccab := d.DecodeElement(&_bed.Row, &_ece); _ccab != nil {
					return _ccab
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "rowOff"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "rowOff"}:
				_dgg, _ebf := d.Token()
				if _ebf != nil {
					return _ebf
				}
				switch _agg := _dgg.(type) {
				case _b.CharData:
					_ced := string(_agg)
					_ebe, _eagg := _a.ParseUnionST_Coordinate(_ced)
					if _eagg != nil {
						return nil
					}
					_bed.RowOff = _ebe
					d.Skip()
				case _b.EndElement:
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element on CT_Marker \u0025v", _ece.Name)
				if _ddbe := d.Skip(); _ddbe != nil {
					return _ddbe
				}
			}
		case _b.EndElement:
			break _gdba
		case _b.CharData:
		}
	}
	return nil
}
func (_bf *CT_Connector) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bf.MacroAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "macro"}, Value: _c.Sprintf("\u0025v", *_bf.MacroAttr)})
	}
	if _bf.FPublishedAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fPublished"}, Value: _c.Sprintf("\u0025d", _badf(*_bf.FPublishedAttr))})
	}
	e.EncodeToken(start)
	_ae := _b.StartElement{Name: _b.Name{Local: "xdr:nvCxnSpPr"}}
	e.EncodeElement(_bf.NvCxnSpPr, _ae)
	_cgbb := _b.StartElement{Name: _b.Name{Local: "xdr:spPr"}}
	e.EncodeElement(_bf.SpPr, _cgbb)
	if _bf.Style != nil {
		_aeb := _b.StartElement{Name: _b.Name{Local: "xdr:style"}}
		e.EncodeElement(_bf.Style, _aeb)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_OneCellAnchor and its children, prefixing error messages with path
func (_afc *CT_OneCellAnchor) ValidateWithPath(path string) error {
	if _dggc := _afc.From.ValidateWithPath(path + "\u002fFrom"); _dggc != nil {
		return _dggc
	}
	if _dbge := _afc.Ext.ValidateWithPath(path + "\u002fExt"); _dbge != nil {
		return _dbge
	}
	if _afc.Choice != nil {
		if _dedf := _afc.Choice.ValidateWithPath(path + "\u002fChoice"); _dedf != nil {
			return _dedf
		}
	}
	if _ccdeg := _afc.ClientData.ValidateWithPath(path + "/ClientData"); _ccdeg != nil {
		return _ccdeg
	}
	return nil
}
func (_fc *CT_Drawing) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _fc.EG_Anchor != nil {
		for _, _ca := range _fc.EG_Anchor {
			_ca.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_efgg *EG_ObjectChoices) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _efgg.Choice != nil {
		_efgg.Choice.MarshalXML(e, _b.StartElement{})
	}
	return nil
}

// ValidateWithPath validates the CT_ShapeNonVisual and its children, prefixing error messages with path
func (_cbdg *CT_ShapeNonVisual) ValidateWithPath(path string) error {
	if _gcgc := _cbdg.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _gcgc != nil {
		return _gcgc
	}
	if _dadf := _cbdg.CNvSpPr.ValidateWithPath(path + "\u002fCNvSpPr"); _dadf != nil {
		return _dadf
	}
	return nil
}
func NewEG_ObjectChoices() *EG_ObjectChoices { _fba := &EG_ObjectChoices{}; return _fba }

type WsDr struct{ CT_Drawing }

// Validate validates the To and its children
func (_gee *To) Validate() error { return _gee.ValidateWithPath("To") }

type CT_GroupShapeChoice struct {
	Sp           []*CT_Shape
	GrpSp        []*CT_GroupShape
	GraphicFrame []*CT_GraphicalObjectFrame
	CxnSp        []*CT_Connector
	Pic          []*CT_Picture
}

func NewCT_Picture() *CT_Picture {
	_eca := &CT_Picture{}
	_eca.NvPicPr = NewCT_PictureNonVisual()
	_eca.BlipFill = _a.NewCT_BlipFillProperties()
	_eca.SpPr = _a.NewCT_ShapeProperties()
	return _eca
}
func (_fce *CT_GroupShapeNonVisual) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	_dcbd := _b.StartElement{Name: _b.Name{Local: "xdr:cNvPr"}}
	e.EncodeElement(_fce.CNvPr, _dcbd)
	_age := _b.StartElement{Name: _b.Name{Local: "xdr:cNvGrpSpPr"}}
	e.EncodeElement(_fce.CNvGrpSpPr, _age)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type CT_GraphicalObjectFrame struct {
	MacroAttr        *string
	FPublishedAttr   *bool
	NvGraphicFramePr *CT_GraphicalObjectFrameNonVisual
	Xfrm             *_a.CT_Transform2D
	Graphic          *_a.Graphic
}

func (_gb *CT_Drawing) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_bd:
	for {
		_cdd, _bfb := d.Token()
		if _bfb != nil {
			return _bfb
		}
		switch _aae := _cdd.(type) {
		case _b.StartElement:
			switch _aae.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "twoCellAnchor"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "twoCellAnchor"}:
				_fbf := NewEG_Anchor()
				_fbf.TwoCellAnchor = NewCT_TwoCellAnchor()
				if _fag := d.DecodeElement(_fbf.TwoCellAnchor, &_aae); _fag != nil {
					return _fag
				}
				_gb.EG_Anchor = append(_gb.EG_Anchor, _fbf)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "oneCellAnchor"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "oneCellAnchor"}:
				_afe := NewEG_Anchor()
				_afe.OneCellAnchor = NewCT_OneCellAnchor()
				if _bfc := d.DecodeElement(_afe.OneCellAnchor, &_aae); _bfc != nil {
					return _bfc
				}
				_gb.EG_Anchor = append(_gb.EG_Anchor, _afe)
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "absoluteAnchor"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "absoluteAnchor"}:
				_cdb := NewEG_Anchor()
				_cdb.AbsoluteAnchor = NewCT_AbsoluteAnchor()
				if _bdd := d.DecodeElement(_cdb.AbsoluteAnchor, &_aae); _bdd != nil {
					return _bdd
				}
				_gb.EG_Anchor = append(_gb.EG_Anchor, _cdb)
			default:
				_gc.Log("skipping unsupported\u0020element\u0020on\u0020CT_Drawing\u0020\u0025v", _aae.Name)
				if _cfe := d.Skip(); _cfe != nil {
					return _cfe
				}
			}
		case _b.EndElement:
			break _bd
		case _b.CharData:
		}
	}
	return nil
}
func (_cdgd *CT_Marker) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	_addgd := _b.StartElement{Name: _b.Name{Local: "xdr:col"}}
	e.EncodeElement(_cdgd.Col, _addgd)
	_eafg := _b.StartElement{Name: _b.Name{Local: "xdr:colOff"}}
	e.EncodeElement(_cdgd.ColOff, _eafg)
	_ggac := _b.StartElement{Name: _b.Name{Local: "xdr:row"}}
	e.EncodeElement(_cdgd.Row, _ggac)
	_dea := _b.StartElement{Name: _b.Name{Local: "xdr:rowOff"}}
	e.EncodeElement(_cdgd.RowOff, _dea)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_AnchorClientData and its children
func (_da *CT_AnchorClientData) Validate() error { return _da.ValidateWithPath("CT_AnchorClientData") }

type CT_Shape struct {
	MacroAttr      *string
	TextlinkAttr   *string
	FLocksTextAttr *bool
	FPublishedAttr *bool
	NvSpPr         *CT_ShapeNonVisual
	SpPr           *_a.CT_ShapeProperties
	Style          *_a.CT_ShapeStyle
	TxBody         *_a.CT_TextBody
}

// ValidateWithPath validates the CT_TwoCellAnchor and its children, prefixing error messages with path
func (_eeg *CT_TwoCellAnchor) ValidateWithPath(path string) error {
	if _ccdc := _eeg.EditAsAttr.ValidateWithPath(path + "/EditAsAttr"); _ccdc != nil {
		return _ccdc
	}
	if _ffda := _eeg.From.ValidateWithPath(path + "\u002fFrom"); _ffda != nil {
		return _ffda
	}
	if _gfgc := _eeg.To.ValidateWithPath(path + "\u002fTo"); _gfgc != nil {
		return _gfgc
	}
	if _eeg.Choice != nil {
		if _ccec := _eeg.Choice.ValidateWithPath(path + "\u002fChoice"); _ccec != nil {
			return _ccec
		}
	}
	if _cgef := _eeg.ClientData.ValidateWithPath(path + "/ClientData"); _cgef != nil {
		return _cgef
	}
	return nil
}
func NewCT_Rel() *CT_Rel { _edcc := &CT_Rel{}; return _edcc }
func (_ggb *CT_OneCellAnchor) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ggb.From = NewCT_Marker()
	_ggb.Ext = _a.NewCT_PositiveSize2D()
	_ggb.ClientData = NewCT_AnchorClientData()
_dbga:
	for {
		_gge, _ege := d.Token()
		if _ege != nil {
			return _ege
		}
		switch _geb := _gge.(type) {
		case _b.StartElement:
			switch _geb.Name {
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "from"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "from"}:
				if _ddc := d.DecodeElement(_ggb.From, &_geb); _ddc != nil {
					return _ddc
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "ext"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "ext"}:
				if _ffde := d.DecodeElement(_ggb.Ext, &_geb); _ffde != nil {
					return _ffde
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "sp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "sp"}:
				_ggb.Choice = NewEG_ObjectChoicesChoice()
				if _cge := d.DecodeElement(&_ggb.Choice.Sp, &_geb); _cge != nil {
					return _cge
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "grpSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "grpSp"}:
				_ggb.Choice = NewEG_ObjectChoicesChoice()
				if _edec := d.DecodeElement(&_ggb.Choice.GrpSp, &_geb); _edec != nil {
					return _edec
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "graphicFrame"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "graphicFrame"}:
				_ggb.Choice = NewEG_ObjectChoicesChoice()
				if _bddee := d.DecodeElement(&_ggb.Choice.GraphicFrame, &_geb); _bddee != nil {
					return _bddee
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "cxnSp"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "cxnSp"}:
				_ggb.Choice = NewEG_ObjectChoicesChoice()
				if _agec := d.DecodeElement(&_ggb.Choice.CxnSp, &_geb); _agec != nil {
					return _agec
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "pic"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "pic"}:
				_ggb.Choice = NewEG_ObjectChoicesChoice()
				if _aefg := d.DecodeElement(&_ggb.Choice.Pic, &_geb); _aefg != nil {
					return _aefg
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "contentPart"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "contentPart"}:
				_ggb.Choice = NewEG_ObjectChoicesChoice()
				if _bgg := d.DecodeElement(&_ggb.Choice.ContentPart, &_geb); _bgg != nil {
					return _bgg
				}
			case _b.Name{Space: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", Local: "clientData"}, _b.Name{Space: "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fdrawingml\u002fspreadsheetDrawing", Local: "clientData"}:
				if _ecd := d.DecodeElement(_ggb.ClientData, &_geb); _ecd != nil {
					return _ecd
				}
			default:
				_gc.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OneCellAnchor\u0020\u0025v", _geb.Name)
				if _affa := d.Skip(); _affa != nil {
					return _affa
				}
			}
		case _b.EndElement:
			break _dbga
		case _b.CharData:
		}
	}
	return nil
}
func (_gfd ST_EditAs) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_egea := _b.Attr{}
	_egea.Name = name
	switch _gfd {
	case ST_EditAsUnset:
		_egea.Value = ""
	case ST_EditAsTwoCell:
		_egea.Value = "twoCell"
	case ST_EditAsOneCell:
		_egea.Value = "oneCell"
	case ST_EditAsAbsolute:
		_egea.Value = "absolute"
	}
	return _egea, nil
}

// Validate validates the EG_ObjectChoicesChoice and its children
func (_cdce *EG_ObjectChoicesChoice) Validate() error {
	return _cdce.ValidateWithPath("EG_ObjectChoicesChoice")
}
func (_accg *CT_GroupShape) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	_cdc := _b.StartElement{Name: _b.Name{Local: "xdr:nvGrpSpPr"}}
	e.EncodeElement(_accg.NvGrpSpPr, _cdc)
	_accc := _b.StartElement{Name: _b.Name{Local: "xdr:grpSpPr"}}
	e.EncodeElement(_accg.GrpSpPr, _accc)
	if _accg.Choice != nil {
		for _, _ggd := range _accg.Choice {
			_ggd.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TwoCellAnchor and its children
func (_dfbc *CT_TwoCellAnchor) Validate() error { return _dfbc.ValidateWithPath("CT_TwoCellAnchor") }

type CT_Drawing struct{ EG_Anchor []*EG_Anchor }
type CT_Picture struct {
	MacroAttr      *string
	FPublishedAttr *bool
	NvPicPr        *CT_PictureNonVisual
	BlipFill       *_a.CT_BlipFillProperties
	SpPr           *_a.CT_ShapeProperties
	Style          *_a.CT_ShapeStyle
}

// Validate validates the EG_ObjectChoices and its children
func (_dbgae *EG_ObjectChoices) Validate() error { return _dbgae.ValidateWithPath("EG_ObjectChoices") }
func (_bedfd ST_EditAs) ValidateWithPath(path string) error {
	switch _bedfd {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bedfd))
	}
	return nil
}
func init() {
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_AnchorClientData", NewCT_AnchorClientData)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_ShapeNonVisual", NewCT_ShapeNonVisual)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_Shape", NewCT_Shape)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_ConnectorNonVisual", NewCT_ConnectorNonVisual)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_Connector", NewCT_Connector)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_PictureNonVisual", NewCT_PictureNonVisual)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_Picture", NewCT_Picture)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_GraphicalObjectFrameNonVisual", NewCT_GraphicalObjectFrameNonVisual)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_GraphicalObjectFrame", NewCT_GraphicalObjectFrame)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_GroupShapeNonVisual", NewCT_GroupShapeNonVisual)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_GroupShape", NewCT_GroupShape)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_Rel", NewCT_Rel)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_Marker", NewCT_Marker)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_TwoCellAnchor", NewCT_TwoCellAnchor)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_OneCellAnchor", NewCT_OneCellAnchor)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_AbsoluteAnchor", NewCT_AbsoluteAnchor)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "CT_Drawing", NewCT_Drawing)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "from", NewFrom)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "to", NewTo)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "wsDr", NewWsDr)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "EG_ObjectChoices", NewEG_ObjectChoices)
	_gc.RegisterConstructor("http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fspreadsheetDrawing", "EG_Anchor", NewEG_Anchor)
}
