//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package dml

import (
	_g "encoding/xml"
	_dcf "fmt"
	_ee "gitee.com/greatmusicians/unioffice"
	_f "gitee.com/greatmusicians/unioffice/schema/soo/ofc/sharedTypes"
	_dc "regexp"
	_e "strconv"
	_d "time"
)

func (_fcfeb *CT_TextListStyle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_cadcf:
	for {
		_gedag, _eaffa := d.Token()
		if _eaffa != nil {
			return _eaffa
		}
		switch _eaebd := _gedag.(type) {
		case _g.StartElement:
			switch _eaebd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "defPPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "defPPr"}:
				_fcfeb.DefPPr = NewCT_TextParagraphProperties()
				if _gefde := d.DecodeElement(_fcfeb.DefPPr, &_eaebd); _gefde != nil {
					return _gefde
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lvl1pPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lvl1pPr"}:
				_fcfeb.Lvl1pPr = NewCT_TextParagraphProperties()
				if _bdgcc := d.DecodeElement(_fcfeb.Lvl1pPr, &_eaebd); _bdgcc != nil {
					return _bdgcc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lvl2pPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lvl2pPr"}:
				_fcfeb.Lvl2pPr = NewCT_TextParagraphProperties()
				if _efdcf := d.DecodeElement(_fcfeb.Lvl2pPr, &_eaebd); _efdcf != nil {
					return _efdcf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lvl3pPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lvl3pPr"}:
				_fcfeb.Lvl3pPr = NewCT_TextParagraphProperties()
				if _feccbc := d.DecodeElement(_fcfeb.Lvl3pPr, &_eaebd); _feccbc != nil {
					return _feccbc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lvl4pPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lvl4pPr"}:
				_fcfeb.Lvl4pPr = NewCT_TextParagraphProperties()
				if _abggb := d.DecodeElement(_fcfeb.Lvl4pPr, &_eaebd); _abggb != nil {
					return _abggb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lvl5pPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lvl5pPr"}:
				_fcfeb.Lvl5pPr = NewCT_TextParagraphProperties()
				if _fgeg := d.DecodeElement(_fcfeb.Lvl5pPr, &_eaebd); _fgeg != nil {
					return _fgeg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lvl6pPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lvl6pPr"}:
				_fcfeb.Lvl6pPr = NewCT_TextParagraphProperties()
				if _dccea := d.DecodeElement(_fcfeb.Lvl6pPr, &_eaebd); _dccea != nil {
					return _dccea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lvl7pPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lvl7pPr"}:
				_fcfeb.Lvl7pPr = NewCT_TextParagraphProperties()
				if _bcdgdd := d.DecodeElement(_fcfeb.Lvl7pPr, &_eaebd); _bcdgdd != nil {
					return _bcdgdd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lvl8pPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lvl8pPr"}:
				_fcfeb.Lvl8pPr = NewCT_TextParagraphProperties()
				if _cccef := d.DecodeElement(_fcfeb.Lvl8pPr, &_eaebd); _cccef != nil {
					return _cccef
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lvl9pPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lvl9pPr"}:
				_fcfeb.Lvl9pPr = NewCT_TextParagraphProperties()
				if _aeaafb := d.DecodeElement(_fcfeb.Lvl9pPr, &_eaebd); _aeaafb != nil {
					return _aeaafb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_fcfeb.ExtLst = NewCT_OfficeArtExtensionList()
				if _dgfcad := d.DecodeElement(_fcfeb.ExtLst, &_eaebd); _dgfcad != nil {
					return _dgfcad
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TextListStyle\u0020\u0025v", _eaebd.Name)
				if _aedebf := d.Skip(); _aedebf != nil {
					return _aedebf
				}
			}
		case _g.EndElement:
			break _cadcf
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_TextParagraph and its children
func (_gdfdc *CT_TextParagraph) Validate() error { return _gdfdc.ValidateWithPath("CT_TextParagraph") }
func (_acdbae *CT_GvmlGroupShapeChoice) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _acdbae.TxSp != nil {
		_afabd := _g.StartElement{Name: _g.Name{Local: "a:txSp"}}
		for _, _cabaf := range _acdbae.TxSp {
			e.EncodeElement(_cabaf, _afabd)
		}
	}
	if _acdbae.Sp != nil {
		_fgfc := _g.StartElement{Name: _g.Name{Local: "a:sp"}}
		for _, _ggbga := range _acdbae.Sp {
			e.EncodeElement(_ggbga, _fgfc)
		}
	}
	if _acdbae.CxnSp != nil {
		_afaff := _g.StartElement{Name: _g.Name{Local: "a:cxnSp"}}
		for _, _afea := range _acdbae.CxnSp {
			e.EncodeElement(_afea, _afaff)
		}
	}
	if _acdbae.Pic != nil {
		_ggdac := _g.StartElement{Name: _g.Name{Local: "a:pic"}}
		for _, _fcebb := range _acdbae.Pic {
			e.EncodeElement(_fcebb, _ggdac)
		}
	}
	if _acdbae.GraphicFrame != nil {
		_gcfe := _g.StartElement{Name: _g.Name{Local: "a:graphicFrame"}}
		for _, _ccfbf := range _acdbae.GraphicFrame {
			e.EncodeElement(_ccfbf, _gcfe)
		}
	}
	if _acdbae.GrpSp != nil {
		_cecb := _g.StartElement{Name: _g.Name{Local: "a:grpSp"}}
		for _, _efbgd := range _acdbae.GrpSp {
			e.EncodeElement(_efbgd, _cecb)
		}
	}
	return nil
}

// ValidateWithPath validates the CT_GvmlGraphicalObjectFrame and its children, prefixing error messages with path
func (_gddb *CT_GvmlGraphicalObjectFrame) ValidateWithPath(path string) error {
	if _ebbf := _gddb.NvGraphicFramePr.ValidateWithPath(path + "\u002fNvGraphicFramePr"); _ebbf != nil {
		return _ebbf
	}
	if _ebdecg := _gddb.Graphic.ValidateWithPath(path + "\u002fGraphic"); _ebdecg != nil {
		return _ebdecg
	}
	if _adfb := _gddb.Xfrm.ValidateWithPath(path + "\u002fXfrm"); _adfb != nil {
		return _adfb
	}
	if _gddb.ExtLst != nil {
		if _bdae := _gddb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bdae != nil {
			return _bdae
		}
	}
	return nil
}

// Validate validates the CT_TableStyle and its children
func (_feacb *CT_TableStyle) Validate() error { return _feacb.ValidateWithPath("CT_TableStyle") }
func NewCT_Point3D() *CT_Point3D              { _cddbe := &CT_Point3D{}; return _cddbe }

type CT_GvmlTextShapeChoice struct {
	UseSpRect *CT_GvmlUseShapeRectangle
	Xfrm      *CT_Transform2D
}
type CT_GvmlGraphicFrameNonVisual struct {
	CNvPr             *CT_NonVisualDrawingProps
	CNvGraphicFramePr *CT_NonVisualGraphicFrameProperties
}

func (_ddfb *CT_AnimationChartElement) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _ddfb.SeriesIdxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "seriesIdx"}, Value: _dcf.Sprintf("\u0025v", *_ddfb.SeriesIdxAttr)})
	}
	if _ddfb.CategoryIdxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "categoryIdx"}, Value: _dcf.Sprintf("\u0025v", *_ddfb.CategoryIdxAttr)})
	}
	_edb, _aefb := _ddfb.BldStepAttr.MarshalXMLAttr(_g.Name{Local: "bldStep"})
	if _aefb != nil {
		return _aefb
	}
	start.Attr = append(start.Attr, _edb)
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_gcdca *EG_ThemeableFillStyle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _gcdca.Fill != nil {
		_dbgeag := _g.StartElement{Name: _g.Name{Local: "a:fill"}}
		e.EncodeElement(_gcdca.Fill, _dbgeag)
	}
	if _gcdca.FillRef != nil {
		_ecbbga := _g.StartElement{Name: _g.Name{Local: "a:fillRef"}}
		e.EncodeElement(_gcdca.FillRef, _ecbbga)
	}
	return nil
}
func (_gaff *CT_GraphicalObjectFrameLocking) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _gbeed := range start.Attr {
		if _gbeed.Name.Local == "noGrp" {
			_cbedcg, _faabe := _e.ParseBool(_gbeed.Value)
			if _faabe != nil {
				return _faabe
			}
			_gaff.NoGrpAttr = &_cbedcg
			continue
		}
		if _gbeed.Name.Local == "noDrilldown" {
			_ebgcf, _eada := _e.ParseBool(_gbeed.Value)
			if _eada != nil {
				return _eada
			}
			_gaff.NoDrilldownAttr = &_ebgcf
			continue
		}
		if _gbeed.Name.Local == "noSelect" {
			_ddfgg, _bbac := _e.ParseBool(_gbeed.Value)
			if _bbac != nil {
				return _bbac
			}
			_gaff.NoSelectAttr = &_ddfgg
			continue
		}
		if _gbeed.Name.Local == "noChangeAspect" {
			_dcgf, _abab := _e.ParseBool(_gbeed.Value)
			if _abab != nil {
				return _abab
			}
			_gaff.NoChangeAspectAttr = &_dcgf
			continue
		}
		if _gbeed.Name.Local == "noMove" {
			_cceda, _ddbgc := _e.ParseBool(_gbeed.Value)
			if _ddbgc != nil {
				return _ddbgc
			}
			_gaff.NoMoveAttr = &_cceda
			continue
		}
		if _gbeed.Name.Local == "noResize" {
			_cddf, _ceeae := _e.ParseBool(_gbeed.Value)
			if _ceeae != nil {
				return _ceeae
			}
			_gaff.NoResizeAttr = &_cddf
			continue
		}
	}
_aggef:
	for {
		_efbab, _ebac := d.Token()
		if _ebac != nil {
			return _ebac
		}
		switch _gdaa := _efbab.(type) {
		case _g.StartElement:
			switch _gdaa.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_gaff.ExtLst = NewCT_OfficeArtExtensionList()
				if _gage := d.DecodeElement(_gaff.ExtLst, &_gdaa); _gage != nil {
					return _gage
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GraphicalObjectFrameLocking\u0020\u0025v", _gdaa.Name)
				if _gbde := d.Skip(); _gbde != nil {
					return _gbde
				}
			}
		case _g.EndElement:
			break _aggef
		case _g.CharData:
		}
	}
	return nil
}
func NewEG_ColorTransform() *EG_ColorTransform { _afgead := &EG_ColorTransform{}; return _afgead }

// Validate validates the CT_LinearShadeProperties and its children
func (_ggafb *CT_LinearShadeProperties) Validate() error {
	return _ggafb.ValidateWithPath("CT_LinearShadeProperties")
}
func (_gecee ST_TextHorzOverflowType) ValidateWithPath(path string) error {
	switch _gecee {
	case 0, 1, 2:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gecee))
	}
	return nil
}
func (_baefg ST_PathShadeType) ValidateWithPath(path string) error {
	switch _baefg {
	case 0, 1, 2, 3:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_baefg))
	}
	return nil
}
func (_gabcaa ST_PresetCameraType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_gabcaa.String(), start)
}
func (_fed *CT_AnimationDgmBuildProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ggea := range start.Attr {
		if _ggea.Name.Local == "bld" {
			_cge, _ecfg := ParseUnionST_AnimationDgmBuildType(_ggea.Value)
			if _ecfg != nil {
				return _ecfg
			}
			_fed.BldAttr = &_cge
			continue
		}
		if _ggea.Name.Local == "rev" {
			_eeab, _bacg := _e.ParseBool(_ggea.Value)
			if _bacg != nil {
				return _bacg
			}
			_fed.RevAttr = &_eeab
			continue
		}
	}
	for {
		_bbbc, _ace := d.Token()
		if _ace != nil {
			return _dcf.Errorf("parsing\u0020CT_AnimationDgmBuildProperties:\u0020\u0025s", _ace)
		}
		if _gbdc, _aea := _bbbc.(_g.EndElement); _aea && _gbdc.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_GradientStop() *CT_GradientStop { _bccd := &CT_GradientStop{}; return _bccd }
func (_fafcg *CT_Path2DLineTo) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fafcg.Pt = NewCT_AdjPoint2D()
_abgbb:
	for {
		_cfegd, _cfab := d.Token()
		if _cfab != nil {
			return _cfab
		}
		switch _gcgce := _cfegd.(type) {
		case _g.StartElement:
			switch _gcgce.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pt"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pt"}:
				if _adcef := d.DecodeElement(_fafcg.Pt, &_gcgce); _adcef != nil {
					return _adcef
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Path2DLineTo\u0020\u0025v", _gcgce.Name)
				if _afgce := d.Skip(); _afgce != nil {
					return _afgce
				}
			}
		case _g.EndElement:
			break _abgbb
		case _g.CharData:
		}
	}
	return nil
}

type ST_TextAlignType byte

// Validate validates the CT_HSLEffect and its children
func (_ccfbd *CT_HSLEffect) Validate() error { return _ccfbd.ValidateWithPath("CT_HSLEffect") }
func (_caaafb ST_LineEndWidth) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_caaafb.String(), start)
}
func NewCT_TableCellProperties() *CT_TableCellProperties {
	_egbde := &CT_TableCellProperties{}
	return _egbde
}
func ParseUnionST_Coordinate(s string) (ST_Coordinate, error) {
	_fbgdd := ST_Coordinate{}
	if _f.ST_UniversalMeasurePatternRe.MatchString(s) {
		_fbgdd.ST_UniversalMeasure = &s
	} else {
		_ceeeb, _ceeeg := _e.ParseInt(s, 10, 64)
		if _ceeeg != nil {
			return _fbgdd, _dcf.Errorf("parsing\u0020\u0025s\u0020as\u0020int", _ceeeg)
		}
		_fbgdd.ST_CoordinateUnqualified = &_ceeeb
	}
	return _fbgdd, nil
}
func (_ageaa *CT_StretchInfoProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _ageaa.FillRect != nil {
		_cgfada := _g.StartElement{Name: _g.Name{Local: "a:fillRect"}}
		e.EncodeElement(_ageaa.FillRect, _cgfada)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_egaec *ST_LightRigType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_egaec = 0
	case "legacyFlat1":
		*_egaec = 1
	case "legacyFlat2":
		*_egaec = 2
	case "legacyFlat3":
		*_egaec = 3
	case "legacyFlat4":
		*_egaec = 4
	case "legacyNormal1":
		*_egaec = 5
	case "legacyNormal2":
		*_egaec = 6
	case "legacyNormal3":
		*_egaec = 7
	case "legacyNormal4":
		*_egaec = 8
	case "legacyHarsh1":
		*_egaec = 9
	case "legacyHarsh2":
		*_egaec = 10
	case "legacyHarsh3":
		*_egaec = 11
	case "legacyHarsh4":
		*_egaec = 12
	case "threePt":
		*_egaec = 13
	case "balanced":
		*_egaec = 14
	case "soft":
		*_egaec = 15
	case "harsh":
		*_egaec = 16
	case "flood":
		*_egaec = 17
	case "contrasting":
		*_egaec = 18
	case "morning":
		*_egaec = 19
	case "sunrise":
		*_egaec = 20
	case "sunset":
		*_egaec = 21
	case "chilly":
		*_egaec = 22
	case "freezing":
		*_egaec = 23
	case "flat":
		*_egaec = 24
	case "twoPt":
		*_egaec = 25
	case "glow":
		*_egaec = 26
	case "brightRoom":
		*_egaec = 27
	}
	return nil
}
func (_gceg *CT_Color) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_cdae:
	for {
		_fedcf, _aagf := d.Token()
		if _aagf != nil {
			return _aagf
		}
		switch _bgdf := _fedcf.(type) {
		case _g.StartElement:
			switch _bgdf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_gceg.ScrgbClr = NewCT_ScRgbColor()
				if _dbed := d.DecodeElement(_gceg.ScrgbClr, &_bgdf); _dbed != nil {
					return _dbed
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_gceg.SrgbClr = NewCT_SRgbColor()
				if _eged := d.DecodeElement(_gceg.SrgbClr, &_bgdf); _eged != nil {
					return _eged
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_gceg.HslClr = NewCT_HslColor()
				if _gefe := d.DecodeElement(_gceg.HslClr, &_bgdf); _gefe != nil {
					return _gefe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_gceg.SysClr = NewCT_SystemColor()
				if _afbb := d.DecodeElement(_gceg.SysClr, &_bgdf); _afbb != nil {
					return _afbb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_gceg.SchemeClr = NewCT_SchemeColor()
				if _eadgg := d.DecodeElement(_gceg.SchemeClr, &_bgdf); _eadgg != nil {
					return _eadgg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_gceg.PrstClr = NewCT_PresetColor()
				if _fdgd := d.DecodeElement(_gceg.PrstClr, &_bgdf); _fdgd != nil {
					return _fdgd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Color\u0020\u0025v", _bgdf.Name)
				if _ecdd := d.Skip(); _ecdd != nil {
					return _ecdd
				}
			}
		case _g.EndElement:
			break _cdae
		case _g.CharData:
		}
	}
	return nil
}
func (_dgfff *CT_FontReference) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dgfff.IdxAttr = ST_FontCollectionIndex(1)
	for _, _dafda := range start.Attr {
		if _dafda.Name.Local == "idx" {
			_dgfff.IdxAttr.UnmarshalXMLAttr(_dafda)
			continue
		}
	}
_faag:
	for {
		_bcceb, _egaea := d.Token()
		if _egaea != nil {
			return _egaea
		}
		switch _bggcc := _bcceb.(type) {
		case _g.StartElement:
			switch _bggcc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_dgfff.ScrgbClr = NewCT_ScRgbColor()
				if _bbbaf := d.DecodeElement(_dgfff.ScrgbClr, &_bggcc); _bbbaf != nil {
					return _bbbaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_dgfff.SrgbClr = NewCT_SRgbColor()
				if _ddfde := d.DecodeElement(_dgfff.SrgbClr, &_bggcc); _ddfde != nil {
					return _ddfde
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_dgfff.HslClr = NewCT_HslColor()
				if _fgfg := d.DecodeElement(_dgfff.HslClr, &_bggcc); _fgfg != nil {
					return _fgfg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_dgfff.SysClr = NewCT_SystemColor()
				if _egaf := d.DecodeElement(_dgfff.SysClr, &_bggcc); _egaf != nil {
					return _egaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_dgfff.SchemeClr = NewCT_SchemeColor()
				if _caeg := d.DecodeElement(_dgfff.SchemeClr, &_bggcc); _caeg != nil {
					return _caeg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_dgfff.PrstClr = NewCT_PresetColor()
				if _ebcab := d.DecodeElement(_dgfff.PrstClr, &_bggcc); _ebcab != nil {
					return _ebcab
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_FontReference\u0020\u0025v", _bggcc.Name)
				if _gcfg := d.Skip(); _gcfg != nil {
					return _gcfg
				}
			}
		case _g.EndElement:
			break _faag
		case _g.CharData:
		}
	}
	return nil
}

type CT_PositiveFixedPercentage struct{ ValAttr ST_PositiveFixedPercentage }

func (_bacfae *CT_NonVisualGroupDrawingShapeProps) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_cabad:
	for {
		_gedfc, _fecc := d.Token()
		if _fecc != nil {
			return _fecc
		}
		switch _fbcad := _gedfc.(type) {
		case _g.StartElement:
			switch _fbcad.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpSpLocks"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpSpLocks"}:
				_bacfae.GrpSpLocks = NewCT_GroupLocking()
				if _edefa := d.DecodeElement(_bacfae.GrpSpLocks, &_fbcad); _edefa != nil {
					return _edefa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_bacfae.ExtLst = NewCT_OfficeArtExtensionList()
				if _fgbgcb := d.DecodeElement(_bacfae.ExtLst, &_fbcad); _fgbgcb != nil {
					return _fgbgcb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_NonVisualGroupDrawingShapeProps\u0020%v", _fbcad.Name)
				if _ebegbf := d.Skip(); _ebegbf != nil {
					return _ebegbf
				}
			}
		case _g.EndElement:
			break _cabad
		case _g.CharData:
		}
	}
	return nil
}
func (_agfbd *CT_TableCellProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _agfbd.MarLAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "marL"}, Value: _dcf.Sprintf("\u0025v", *_agfbd.MarLAttr)})
	}
	if _agfbd.MarRAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "marR"}, Value: _dcf.Sprintf("\u0025v", *_agfbd.MarRAttr)})
	}
	if _agfbd.MarTAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "marT"}, Value: _dcf.Sprintf("\u0025v", *_agfbd.MarTAttr)})
	}
	if _agfbd.MarBAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "marB"}, Value: _dcf.Sprintf("\u0025v", *_agfbd.MarBAttr)})
	}
	if _agfbd.VertAttr != ST_TextVerticalTypeUnset {
		_afbaac, _cdegf := _agfbd.VertAttr.MarshalXMLAttr(_g.Name{Local: "vert"})
		if _cdegf != nil {
			return _cdegf
		}
		start.Attr = append(start.Attr, _afbaac)
	}
	if _agfbd.AnchorAttr != ST_TextAnchoringTypeUnset {
		_abfbb, _ddcfe := _agfbd.AnchorAttr.MarshalXMLAttr(_g.Name{Local: "anchor"})
		if _ddcfe != nil {
			return _ddcfe
		}
		start.Attr = append(start.Attr, _abfbb)
	}
	if _agfbd.AnchorCtrAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "anchorCtr"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_agfbd.AnchorCtrAttr))})
	}
	if _agfbd.HorzOverflowAttr != ST_TextHorzOverflowTypeUnset {
		_dgcfg, _cadgf := _agfbd.HorzOverflowAttr.MarshalXMLAttr(_g.Name{Local: "horzOverflow"})
		if _cadgf != nil {
			return _cadgf
		}
		start.Attr = append(start.Attr, _dgcfg)
	}
	e.EncodeToken(start)
	if _agfbd.LnL != nil {
		_afbag := _g.StartElement{Name: _g.Name{Local: "a:lnL"}}
		e.EncodeElement(_agfbd.LnL, _afbag)
	}
	if _agfbd.LnR != nil {
		_cdccf := _g.StartElement{Name: _g.Name{Local: "a:lnR"}}
		e.EncodeElement(_agfbd.LnR, _cdccf)
	}
	if _agfbd.LnT != nil {
		_egcf := _g.StartElement{Name: _g.Name{Local: "a:lnT"}}
		e.EncodeElement(_agfbd.LnT, _egcf)
	}
	if _agfbd.LnB != nil {
		_ggadag := _g.StartElement{Name: _g.Name{Local: "a:lnB"}}
		e.EncodeElement(_agfbd.LnB, _ggadag)
	}
	if _agfbd.LnTlToBr != nil {
		_dcaf := _g.StartElement{Name: _g.Name{Local: "a:lnTlToBr"}}
		e.EncodeElement(_agfbd.LnTlToBr, _dcaf)
	}
	if _agfbd.LnBlToTr != nil {
		_cacbg := _g.StartElement{Name: _g.Name{Local: "a:lnBlToTr"}}
		e.EncodeElement(_agfbd.LnBlToTr, _cacbg)
	}
	if _agfbd.Cell3D != nil {
		_aeagag := _g.StartElement{Name: _g.Name{Local: "a:cell3D"}}
		e.EncodeElement(_agfbd.Cell3D, _aeagag)
	}
	if _agfbd.NoFill != nil {
		_eddcf := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_agfbd.NoFill, _eddcf)
	}
	if _agfbd.SolidFill != nil {
		_fffaa := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_agfbd.SolidFill, _fffaa)
	}
	if _agfbd.GradFill != nil {
		_faabea := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_agfbd.GradFill, _faabea)
	}
	if _agfbd.BlipFill != nil {
		_efbbb := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
		e.EncodeElement(_agfbd.BlipFill, _efbbb)
	}
	if _agfbd.PattFill != nil {
		_bbbef := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_agfbd.PattFill, _bbbef)
	}
	if _agfbd.GrpFill != nil {
		_ecaeg := _g.StartElement{Name: _g.Name{Local: "a:grpFill"}}
		e.EncodeElement(_agfbd.GrpFill, _ecaeg)
	}
	if _agfbd.Headers != nil {
		_febf := _g.StartElement{Name: _g.Name{Local: "a:headers"}}
		e.EncodeElement(_agfbd.Headers, _febf)
	}
	if _agfbd.ExtLst != nil {
		_abbdd := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_agfbd.ExtLst, _abbdd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_GlowEffect and its children
func (_fggf *CT_GlowEffect) Validate() error { return _fggf.ValidateWithPath("CT_GlowEffect") }

type CT_Camera struct {
	PrstAttr ST_PresetCameraType
	FovAttr  *int32
	ZoomAttr *ST_PositivePercentage
	Rot      *CT_SphereCoords
}

// ValidateWithPath validates the CT_TextBody and its children, prefixing error messages with path
func (_bcfaf *CT_TextBody) ValidateWithPath(path string) error {
	if _eafbg := _bcfaf.BodyPr.ValidateWithPath(path + "\u002fBodyPr"); _eafbg != nil {
		return _eafbg
	}
	if _bcfaf.LstStyle != nil {
		if _agffb := _bcfaf.LstStyle.ValidateWithPath(path + "\u002fLstStyle"); _agffb != nil {
			return _agffb
		}
	}
	for _effa, _faedg := range _bcfaf.P {
		if _gaafb := _faedg.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fP\u005b\u0025d\u005d", path, _effa)); _gaafb != nil {
			return _gaafb
		}
	}
	return nil
}

type CT_ShapeProperties struct {
	BwModeAttr ST_BlackWhiteMode
	Xfrm       *CT_Transform2D
	CustGeom   *CT_CustomGeometry2D
	PrstGeom   *CT_PresetGeometry2D
	NoFill     *CT_NoFillProperties
	SolidFill  *CT_SolidColorFillProperties
	GradFill   *CT_GradientFillProperties
	BlipFill   *CT_BlipFillProperties
	PattFill   *CT_PatternFillProperties
	GrpFill    *CT_GroupFillProperties
	Ln         *CT_LineProperties
	EffectLst  *CT_EffectList
	EffectDag  *CT_EffectContainer
	Scene3d    *CT_Scene3D
	Sp3d       *CT_Shape3D
	ExtLst     *CT_OfficeArtExtensionList
}

// Validate validates the CT_Cell3D and its children
func (_gbcc *CT_Cell3D) Validate() error { return _gbcc.ValidateWithPath("CT_Cell3D") }

type CT_TextUnderlineFillGroupWrapper struct {
	NoFill    *CT_NoFillProperties
	SolidFill *CT_SolidColorFillProperties
	GradFill  *CT_GradientFillProperties
	BlipFill  *CT_BlipFillProperties
	PattFill  *CT_PatternFillProperties
	GrpFill   *CT_GroupFillProperties
}

func (_feee *CT_GroupShapeProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _cgcf := range start.Attr {
		if _cgcf.Name.Local == "bwMode" {
			_feee.BwModeAttr.UnmarshalXMLAttr(_cgcf)
			continue
		}
	}
_fbadb:
	for {
		_gacd, _gcfda := d.Token()
		if _gcfda != nil {
			return _gcfda
		}
		switch _aeec := _gacd.(type) {
		case _g.StartElement:
			switch _aeec.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "xfrm"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "xfrm"}:
				_feee.Xfrm = NewCT_GroupTransform2D()
				if _bffe := d.DecodeElement(_feee.Xfrm, &_aeec); _bffe != nil {
					return _bffe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_feee.NoFill = NewCT_NoFillProperties()
				if _abdd := d.DecodeElement(_feee.NoFill, &_aeec); _abdd != nil {
					return _abdd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_feee.SolidFill = NewCT_SolidColorFillProperties()
				if _becfe := d.DecodeElement(_feee.SolidFill, &_aeec); _becfe != nil {
					return _becfe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_feee.GradFill = NewCT_GradientFillProperties()
				if _bedad := d.DecodeElement(_feee.GradFill, &_aeec); _bedad != nil {
					return _bedad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_feee.BlipFill = NewCT_BlipFillProperties()
				if _acgb := d.DecodeElement(_feee.BlipFill, &_aeec); _acgb != nil {
					return _acgb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_feee.PattFill = NewCT_PatternFillProperties()
				if _bdba := d.DecodeElement(_feee.PattFill, &_aeec); _bdba != nil {
					return _bdba
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_feee.GrpFill = NewCT_GroupFillProperties()
				if _dcce := d.DecodeElement(_feee.GrpFill, &_aeec); _dcce != nil {
					return _dcce
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectLst"}:
				_feee.EffectLst = NewCT_EffectList()
				if _edcee := d.DecodeElement(_feee.EffectLst, &_aeec); _edcee != nil {
					return _edcee
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectDag"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectDag"}:
				_feee.EffectDag = NewCT_EffectContainer()
				if _efad := d.DecodeElement(_feee.EffectDag, &_aeec); _efad != nil {
					return _efad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scene3d"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scene3d"}:
				_feee.Scene3d = NewCT_Scene3D()
				if _eaddc := d.DecodeElement(_feee.Scene3d, &_aeec); _eaddc != nil {
					return _eaddc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_feee.ExtLst = NewCT_OfficeArtExtensionList()
				if _eage := d.DecodeElement(_feee.ExtLst, &_aeec); _eage != nil {
					return _eage
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_GroupShapeProperties \u0025v", _aeec.Name)
				if _bcdd := d.Skip(); _bcdd != nil {
					return _bcdd
				}
			}
		case _g.EndElement:
			break _fbadb
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_TintEffect() *CT_TintEffect { _eacdg := &CT_TintEffect{}; return _eacdg }

type CT_AdjustHandleList struct {
	AhXY    []*CT_XYAdjustHandle
	AhPolar []*CT_PolarAdjustHandle
}

// Validate validates the EG_TextBullet and its children
func (_fabgc *EG_TextBullet) Validate() error { return _fabgc.ValidateWithPath("EG_TextBullet") }

// ValidateWithPath validates the Graphic and its children, prefixing error messages with path
func (_eaccb *Graphic) ValidateWithPath(path string) error {
	if _fccab := _eaccb.CT_GraphicalObject.ValidateWithPath(path); _fccab != nil {
		return _fccab
	}
	return nil
}
func (_cdfac *CT_TextLineBreak) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_dcdf:
	for {
		_agcc, _abgeg := d.Token()
		if _abgeg != nil {
			return _abgeg
		}
		switch _dfceg := _agcc.(type) {
		case _g.StartElement:
			switch _dfceg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "rPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "rPr"}:
				_cdfac.RPr = NewCT_TextCharacterProperties()
				if _bbbcc := d.DecodeElement(_cdfac.RPr, &_dfceg); _bbbcc != nil {
					return _bbbcc
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TextLineBreak\u0020\u0025v", _dfceg.Name)
				if _dfgca := d.Skip(); _dfgca != nil {
					return _dfgca
				}
			}
		case _g.EndElement:
			break _dcdf
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ShapeStyle and its children, prefixing error messages with path
func (_fcaee *CT_ShapeStyle) ValidateWithPath(path string) error {
	if _bgba := _fcaee.LnRef.ValidateWithPath(path + "\u002fLnRef"); _bgba != nil {
		return _bgba
	}
	if _gffcf := _fcaee.FillRef.ValidateWithPath(path + "\u002fFillRef"); _gffcf != nil {
		return _gffcf
	}
	if _bdgg := _fcaee.EffectRef.ValidateWithPath(path + "\u002fEffectRef"); _bdgg != nil {
		return _bdgg
	}
	if _bead := _fcaee.FontRef.ValidateWithPath(path + "\u002fFontRef"); _bead != nil {
		return _bead
	}
	return nil
}
func NewCT_LineJoinMiterProperties() *CT_LineJoinMiterProperties {
	_dbcd := &CT_LineJoinMiterProperties{}
	return _dbcd
}
func (_acbb *CT_Angle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", _acbb.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TextUnderlineFillGroupWrapper and its children, prefixing error messages with path
func (_caafe *CT_TextUnderlineFillGroupWrapper) ValidateWithPath(path string) error {
	if _caafe.NoFill != nil {
		if _cfdcf := _caafe.NoFill.ValidateWithPath(path + "\u002fNoFill"); _cfdcf != nil {
			return _cfdcf
		}
	}
	if _caafe.SolidFill != nil {
		if _gdaea := _caafe.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _gdaea != nil {
			return _gdaea
		}
	}
	if _caafe.GradFill != nil {
		if _gacba := _caafe.GradFill.ValidateWithPath(path + "\u002fGradFill"); _gacba != nil {
			return _gacba
		}
	}
	if _caafe.BlipFill != nil {
		if _bcea := _caafe.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _bcea != nil {
			return _bcea
		}
	}
	if _caafe.PattFill != nil {
		if _agdbe := _caafe.PattFill.ValidateWithPath(path + "\u002fPattFill"); _agdbe != nil {
			return _agdbe
		}
	}
	if _caafe.GrpFill != nil {
		if _eddde := _caafe.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _eddde != nil {
			return _eddde
		}
	}
	return nil
}
func NewCT_SphereCoords() *CT_SphereCoords {
	_edadgf := &CT_SphereCoords{}
	_edadgf.LatAttr = 0
	_edadgf.LonAttr = 0
	_edadgf.RevAttr = 0
	return _edadgf
}
func (_agacg *EG_ColorChoice) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _agacg.ScrgbClr != nil {
		_cfgbe := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_agacg.ScrgbClr, _cfgbe)
	}
	if _agacg.SrgbClr != nil {
		_dcgcf := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_agacg.SrgbClr, _dcgcf)
	}
	if _agacg.HslClr != nil {
		_bgfcf := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_agacg.HslClr, _bgfcf)
	}
	if _agacg.SysClr != nil {
		_dbgdeg := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_agacg.SysClr, _dbgdeg)
	}
	if _agacg.SchemeClr != nil {
		_ggbce := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_agacg.SchemeClr, _ggbce)
	}
	if _agacg.PrstClr != nil {
		_gcee := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_agacg.PrstClr, _gcee)
	}
	return nil
}
func (_cgddc ST_TextFontAlignType) ValidateWithPath(path string) error {
	switch _cgddc {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cgddc))
	}
	return nil
}
func (_beda *CT_GrayscaleTransform) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_debfb, _aadf := d.Token()
		if _aadf != nil {
			return _dcf.Errorf("parsing\u0020CT_GrayscaleTransform:\u0020\u0025s", _aadf)
		}
		if _fbgea, _eace := _debfb.(_g.EndElement); _eace && _fbgea.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fcfcdg *CT_OfficeStyleSheet) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fcfcdg.NameAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "name"}, Value: _dcf.Sprintf("\u0025v", *_fcfcdg.NameAttr)})
	}
	e.EncodeToken(start)
	_dcefbc := _g.StartElement{Name: _g.Name{Local: "a:themeElements"}}
	e.EncodeElement(_fcfcdg.ThemeElements, _dcefbc)
	if _fcfcdg.ObjectDefaults != nil {
		_adgd := _g.StartElement{Name: _g.Name{Local: "a:objectDefaults"}}
		e.EncodeElement(_fcfcdg.ObjectDefaults, _adgd)
	}
	if _fcfcdg.ExtraClrSchemeLst != nil {
		_caad := _g.StartElement{Name: _g.Name{Local: "a:extraClrSchemeLst"}}
		e.EncodeElement(_fcfcdg.ExtraClrSchemeLst, _caad)
	}
	if _fcfcdg.CustClrLst != nil {
		_fgeag := _g.StartElement{Name: _g.Name{Local: "a:custClrLst"}}
		e.EncodeElement(_fcfcdg.CustClrLst, _fgeag)
	}
	if _fcfcdg.ExtLst != nil {
		_gbded := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_fcfcdg.ExtLst, _gbded)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_BackgroundFillStyleList and its children, prefixing error messages with path
func (_eabf *CT_BackgroundFillStyleList) ValidateWithPath(path string) error {
	for _aeea, _gdee := range _eabf.EG_FillProperties {
		if _ddga := _gdee.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fEG_FillProperties\u005b\u0025d\u005d", path, _aeea)); _ddga != nil {
			return _ddga
		}
	}
	return nil
}

// Validate validates the CT_SoftEdgesEffect and its children
func (_dadc *CT_SoftEdgesEffect) Validate() error {
	return _dadc.ValidateWithPath("CT_SoftEdgesEffect")
}

// Validate validates the AG_Locking and its children
func (_ad *AG_Locking) Validate() error { return _ad.ValidateWithPath("AG_Locking") }
func (_bgcaf ST_PitchFamily) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_bgcaf.String(), start)
}
func NewCT_TransformEffect() *CT_TransformEffect { _abcac := &CT_TransformEffect{}; return _abcac }
func (_abcca *CT_SystemColor) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_fggaf, _gbeef := _abcca.ValAttr.MarshalXMLAttr(_g.Name{Local: "val"})
	if _gbeef != nil {
		return _gbeef
	}
	start.Attr = append(start.Attr, _fggaf)
	if _abcca.LastClrAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lastClr"}, Value: _dcf.Sprintf("\u0025v", *_abcca.LastClrAttr)})
	}
	e.EncodeToken(start)
	if _abcca.EG_ColorTransform != nil {
		for _, _addebd := range _abcca.EG_ColorTransform {
			_addebd.MarshalXML(e, _g.StartElement{})
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_GvmlGroupShapeChoice and its children
func (_dceg *CT_GvmlGroupShapeChoice) Validate() error {
	return _dceg.ValidateWithPath("CT_GvmlGroupShapeChoice")
}

// Validate validates the CT_AnimationChartBuildProperties and its children
func (_ecf *CT_AnimationChartBuildProperties) Validate() error {
	return _ecf.ValidateWithPath("CT_AnimationChartBuildProperties")
}

type CT_ShapeStyle struct {
	LnRef     *CT_StyleMatrixReference
	FillRef   *CT_StyleMatrixReference
	EffectRef *CT_StyleMatrixReference
	FontRef   *CT_FontReference
}

// ValidateWithPath validates the EG_Text3D and its children, prefixing error messages with path
func (_aggbf *EG_Text3D) ValidateWithPath(path string) error {
	if _aggbf.Sp3d != nil {
		if _cdbad := _aggbf.Sp3d.ValidateWithPath(path + "\u002fSp3d"); _cdbad != nil {
			return _cdbad
		}
	}
	if _aggbf.FlatTx != nil {
		if _cfgbdc := _aggbf.FlatTx.ValidateWithPath(path + "\u002fFlatTx"); _cfgbdc != nil {
			return _cfgbdc
		}
	}
	return nil
}
func NewCT_TextUnderlineFillGroupWrapper() *CT_TextUnderlineFillGroupWrapper {
	_gecfg := &CT_TextUnderlineFillGroupWrapper{}
	return _gecfg
}
func (_ecbca *Graphic) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return _ecbca.CT_GraphicalObject.MarshalXML(e, start)
}
func (_ccbae ST_CompoundLine) ValidateWithPath(path string) error {
	switch _ccbae {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ccbae))
	}
	return nil
}

// ValidateWithPath validates the CT_ContentPartLocking and its children, prefixing error messages with path
func (_ecggd *CT_ContentPartLocking) ValidateWithPath(path string) error {
	if _ecggd.ExtLst != nil {
		if _acede := _ecggd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _acede != nil {
			return _acede
		}
	}
	return nil
}
func NewCT_Boolean() *CT_Boolean { _ccbc := &CT_Boolean{}; return _ccbc }
func (_bffbg *EG_TextUnderlineLine) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _bffbg.ULnTx != nil {
		_bfede := _g.StartElement{Name: _g.Name{Local: "a:uLnTx"}}
		e.EncodeElement(_bffbg.ULnTx, _bfede)
	}
	if _bffbg.ULn != nil {
		_ggffg := _g.StartElement{Name: _g.Name{Local: "a:uLn"}}
		e.EncodeElement(_bffbg.ULn, _ggffg)
	}
	return nil
}
func (_bgcf *CT_PresetColor) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_fabdc, _bccfd := _bgcf.ValAttr.MarshalXMLAttr(_g.Name{Local: "val"})
	if _bccfd != nil {
		return _bccfd
	}
	start.Attr = append(start.Attr, _fabdc)
	e.EncodeToken(start)
	if _bgcf.EG_ColorTransform != nil {
		for _, _fbgc := range _bgcf.EG_ColorTransform {
			_fbgc.MarshalXML(e, _g.StartElement{})
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_fdfeb *CT_SRgbColor) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ddfgc := range start.Attr {
		if _ddfgc.Name.Local == "val" {
			_cddd, _cdffaa := _ddfgc.Value, error(nil)
			if _cdffaa != nil {
				return _cdffaa
			}
			_fdfeb.ValAttr = _cddd
			continue
		}
	}
_cfegc:
	for {
		_cfada, _dfbbe := d.Token()
		if _dfbbe != nil {
			return _dfbbe
		}
		switch _ffbb := _cfada.(type) {
		case _g.StartElement:
			switch _ffbb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_ffbgc := NewEG_ColorTransform()
				_ffbgc.Tint = NewCT_PositiveFixedPercentage()
				if _cbebc := d.DecodeElement(_ffbgc.Tint, &_ffbb); _cbebc != nil {
					return _cbebc
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _ffbgc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "shade"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "shade"}:
				_ddeed := NewEG_ColorTransform()
				_ddeed.Shade = NewCT_PositiveFixedPercentage()
				if _gabaa := d.DecodeElement(_ddeed.Shade, &_ffbb); _gabaa != nil {
					return _gabaa
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _ddeed)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "comp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "comp"}:
				_gdacag := NewEG_ColorTransform()
				_gdacag.Comp = NewCT_ComplementTransform()
				if _cdfbe := d.DecodeElement(_gdacag.Comp, &_ffbb); _cdfbe != nil {
					return _cdfbe
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _gdacag)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "inv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "inv"}:
				_acgcc := NewEG_ColorTransform()
				_acgcc.Inv = NewCT_InverseTransform()
				if _acbbaf := d.DecodeElement(_acgcc.Inv, &_ffbb); _acbbaf != nil {
					return _acbbaf
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _acgcc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gray"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gray"}:
				_bdbdb := NewEG_ColorTransform()
				_bdbdb.Gray = NewCT_GrayscaleTransform()
				if _cdcdc := d.DecodeElement(_bdbdb.Gray, &_ffbb); _cdcdc != nil {
					return _cdcdc
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _bdbdb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alpha"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alpha"}:
				_aagda := NewEG_ColorTransform()
				_aagda.Alpha = NewCT_PositiveFixedPercentage()
				if _eddgcc := d.DecodeElement(_aagda.Alpha, &_ffbb); _eddgcc != nil {
					return _eddgcc
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _aagda)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaOff"}:
				_afaffd := NewEG_ColorTransform()
				_afaffd.AlphaOff = NewCT_FixedPercentage()
				if _bbdcc := d.DecodeElement(_afaffd.AlphaOff, &_ffbb); _bbdcc != nil {
					return _bbdcc
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _afaffd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_febc := NewEG_ColorTransform()
				_febc.AlphaMod = NewCT_PositivePercentage()
				if _fbadfb := d.DecodeElement(_febc.AlphaMod, &_ffbb); _fbadfb != nil {
					return _fbadfb
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _febc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hue"}:
				_ccfde := NewEG_ColorTransform()
				_ccfde.Hue = NewCT_PositiveFixedAngle()
				if _febe := d.DecodeElement(_ccfde.Hue, &_ffbb); _febe != nil {
					return _febe
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _ccfde)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueOff"}:
				_cbccc := NewEG_ColorTransform()
				_cbccc.HueOff = NewCT_Angle()
				if _ffae := d.DecodeElement(_cbccc.HueOff, &_ffbb); _ffae != nil {
					return _ffae
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _cbccc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueMod"}:
				_bedfc := NewEG_ColorTransform()
				_bedfc.HueMod = NewCT_PositivePercentage()
				if _dfdg := d.DecodeElement(_bedfc.HueMod, &_ffbb); _dfdg != nil {
					return _dfdg
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _bedfc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sat"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sat"}:
				_dcgcd := NewEG_ColorTransform()
				_dcgcd.Sat = NewCT_Percentage()
				if _dccfe := d.DecodeElement(_dcgcd.Sat, &_ffbb); _dccfe != nil {
					return _dccfe
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _dcgcd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satOff"}:
				_bbfde := NewEG_ColorTransform()
				_bbfde.SatOff = NewCT_Percentage()
				if _cbgf := d.DecodeElement(_bbfde.SatOff, &_ffbb); _cbgf != nil {
					return _cbgf
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _bbfde)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satMod"}:
				_feaeb := NewEG_ColorTransform()
				_feaeb.SatMod = NewCT_Percentage()
				if _cfee := d.DecodeElement(_feaeb.SatMod, &_ffbb); _cfee != nil {
					return _cfee
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _feaeb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_bbec := NewEG_ColorTransform()
				_bbec.Lum = NewCT_Percentage()
				if _ddbde := d.DecodeElement(_bbec.Lum, &_ffbb); _ddbde != nil {
					return _ddbde
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _bbec)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumOff"}:
				_aedag := NewEG_ColorTransform()
				_aedag.LumOff = NewCT_Percentage()
				if _ffeac := d.DecodeElement(_aedag.LumOff, &_ffbb); _ffeac != nil {
					return _ffeac
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _aedag)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumMod"}:
				_fgcac := NewEG_ColorTransform()
				_fgcac.LumMod = NewCT_Percentage()
				if _gbbc := d.DecodeElement(_fgcac.LumMod, &_ffbb); _gbbc != nil {
					return _gbbc
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _fgcac)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "red"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "red"}:
				_fedda := NewEG_ColorTransform()
				_fedda.Red = NewCT_Percentage()
				if _cbefg := d.DecodeElement(_fedda.Red, &_ffbb); _cbefg != nil {
					return _cbefg
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _fedda)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redOff"}:
				_gfdae := NewEG_ColorTransform()
				_gfdae.RedOff = NewCT_Percentage()
				if _edccg := d.DecodeElement(_gfdae.RedOff, &_ffbb); _edccg != nil {
					return _edccg
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _gfdae)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redMod"}:
				_cdgbg := NewEG_ColorTransform()
				_cdgbg.RedMod = NewCT_Percentage()
				if _beff := d.DecodeElement(_cdgbg.RedMod, &_ffbb); _beff != nil {
					return _beff
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _cdgbg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "green"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "green"}:
				_efagb := NewEG_ColorTransform()
				_efagb.Green = NewCT_Percentage()
				if _dfgda := d.DecodeElement(_efagb.Green, &_ffbb); _dfgda != nil {
					return _dfgda
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _efagb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenOff"}:
				_aaddf := NewEG_ColorTransform()
				_aaddf.GreenOff = NewCT_Percentage()
				if _caceb := d.DecodeElement(_aaddf.GreenOff, &_ffbb); _caceb != nil {
					return _caceb
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _aaddf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenMod"}:
				_bgdca := NewEG_ColorTransform()
				_bgdca.GreenMod = NewCT_Percentage()
				if _gebga := d.DecodeElement(_bgdca.GreenMod, &_ffbb); _gebga != nil {
					return _gebga
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _bgdca)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blue"}:
				_cgcga := NewEG_ColorTransform()
				_cgcga.Blue = NewCT_Percentage()
				if _ggabe := d.DecodeElement(_cgcga.Blue, &_ffbb); _ggabe != nil {
					return _ggabe
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _cgcga)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueOff"}:
				_efedb := NewEG_ColorTransform()
				_efedb.BlueOff = NewCT_Percentage()
				if _cfda := d.DecodeElement(_efedb.BlueOff, &_ffbb); _cfda != nil {
					return _cfda
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _efedb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueMod"}:
				_dgdec := NewEG_ColorTransform()
				_dgdec.BlueMod = NewCT_Percentage()
				if _dbgfd := d.DecodeElement(_dgdec.BlueMod, &_ffbb); _dbgfd != nil {
					return _dbgfd
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _dgdec)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gamma"}:
				_ebabb := NewEG_ColorTransform()
				_ebabb.Gamma = NewCT_GammaTransform()
				if _cbdae := d.DecodeElement(_ebabb.Gamma, &_ffbb); _cbdae != nil {
					return _cbdae
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _ebabb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "invGamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "invGamma"}:
				_beeg := NewEG_ColorTransform()
				_beeg.InvGamma = NewCT_InverseGammaTransform()
				if _gdacd := d.DecodeElement(_beeg.InvGamma, &_ffbb); _gdacd != nil {
					return _gdacd
				}
				_fdfeb.EG_ColorTransform = append(_fdfeb.EG_ColorTransform, _beeg)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SRgbColor\u0020\u0025v", _ffbb.Name)
				if _ddccb := d.Skip(); _ddccb != nil {
					return _ddccb
				}
			}
		case _g.EndElement:
			break _cfegc
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_RegularTextRun() *CT_RegularTextRun { _eagc := &CT_RegularTextRun{}; return _eagc }
func (_acdbd ST_AnimationDgmOnlyBuildType) String() string {
	switch _acdbd {
	case 0:
		return ""
	case 1:
		return "one"
	case 2:
		return "lvlOne"
	case 3:
		return "lvlAtOnce"
	}
	return ""
}
func (_eegf *CT_GvmlUseShapeRectangle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_ddebcc, _becfg := d.Token()
		if _becfg != nil {
			return _dcf.Errorf("parsing CT_GvmlUseShapeRectangle:\u0020%s", _becfg)
		}
		if _ebcag, _caabe := _ddebcc.(_g.EndElement); _caabe && _ebcag.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bbd *AG_Locking) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _faa := range start.Attr {
		if _faa.Name.Local == "noGrp" {
			_aec, _ce := _e.ParseBool(_faa.Value)
			if _ce != nil {
				return _ce
			}
			_bbd.NoGrpAttr = &_aec
			continue
		}
		if _faa.Name.Local == "noSelect" {
			_ge, _aa := _e.ParseBool(_faa.Value)
			if _aa != nil {
				return _aa
			}
			_bbd.NoSelectAttr = &_ge
			continue
		}
		if _faa.Name.Local == "noRot" {
			_fac, _cbb := _e.ParseBool(_faa.Value)
			if _cbb != nil {
				return _cbb
			}
			_bbd.NoRotAttr = &_fac
			continue
		}
		if _faa.Name.Local == "noChangeAspect" {
			_fe, _gc := _e.ParseBool(_faa.Value)
			if _gc != nil {
				return _gc
			}
			_bbd.NoChangeAspectAttr = &_fe
			continue
		}
		if _faa.Name.Local == "noMove" {
			_da, _bad := _e.ParseBool(_faa.Value)
			if _bad != nil {
				return _bad
			}
			_bbd.NoMoveAttr = &_da
			continue
		}
		if _faa.Name.Local == "noResize" {
			_ega, _ebd := _e.ParseBool(_faa.Value)
			if _ebd != nil {
				return _ebd
			}
			_bbd.NoResizeAttr = &_ega
			continue
		}
		if _faa.Name.Local == "noEditPoints" {
			_dd, _eec := _e.ParseBool(_faa.Value)
			if _eec != nil {
				return _eec
			}
			_bbd.NoEditPointsAttr = &_dd
			continue
		}
		if _faa.Name.Local == "noAdjustHandles" {
			_cf, _gb := _e.ParseBool(_faa.Value)
			if _gb != nil {
				return _gb
			}
			_bbd.NoAdjustHandlesAttr = &_cf
			continue
		}
		if _faa.Name.Local == "noChangeArrowheads" {
			_ced, _cc := _e.ParseBool(_faa.Value)
			if _cc != nil {
				return _cc
			}
			_bbd.NoChangeArrowheadsAttr = &_ced
			continue
		}
		if _faa.Name.Local == "noChangeShapeType" {
			_dbc, _cg := _e.ParseBool(_faa.Value)
			if _cg != nil {
				return _cg
			}
			_bbd.NoChangeShapeTypeAttr = &_dbc
			continue
		}
	}
	for {
		_fcb, _dcfb := d.Token()
		if _dcfb != nil {
			return _dcf.Errorf("parsing\u0020AG_Locking:\u0020%s", _dcfb)
		}
		if _bba, _bg := _fcb.(_g.EndElement); _bg && _bba.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cfbf *CT_Backdrop) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_ddgb := _g.StartElement{Name: _g.Name{Local: "a:anchor"}}
	e.EncodeElement(_cfbf.Anchor, _ddgb)
	_dfe := _g.StartElement{Name: _g.Name{Local: "a:norm"}}
	e.EncodeElement(_cfbf.Norm, _dfe)
	_gefg := _g.StartElement{Name: _g.Name{Local: "a:up"}}
	e.EncodeElement(_cfbf.Up, _gefg)
	if _cfbf.ExtLst != nil {
		_gaga := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_cfbf.ExtLst, _gaga)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ddcg *CT_TextNormalAutofit) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _ddcg.FontScaleAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "fontScale"}, Value: _dcf.Sprintf("\u0025v", *_ddcg.FontScaleAttr)})
	}
	if _ddcg.LnSpcReductionAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lnSpcReduction"}, Value: _dcf.Sprintf("\u0025v", *_ddcg.LnSpcReductionAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_PresetShadowEffect and its children, prefixing error messages with path
func (_babaf *CT_PresetShadowEffect) ValidateWithPath(path string) error {
	if _babaf.PrstAttr == ST_PresetShadowValUnset {
		return _dcf.Errorf("\u0025s\u002fPrstAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _gfdb := _babaf.PrstAttr.ValidateWithPath(path + "\u002fPrstAttr"); _gfdb != nil {
		return _gfdb
	}
	if _babaf.DistAttr != nil {
		if *_babaf.DistAttr < 0 {
			return _dcf.Errorf("\u0025s/m\u002eDistAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_babaf.DistAttr)
		}
		if *_babaf.DistAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s\u002fm\u002eDistAttr\u0020must\u0020be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_babaf.DistAttr)
		}
	}
	if _babaf.DirAttr != nil {
		if *_babaf.DirAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eDirAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_babaf.DirAttr)
		}
		if *_babaf.DirAttr >= 21600000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eDirAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, *_babaf.DirAttr)
		}
	}
	if _babaf.ScrgbClr != nil {
		if _fcbf := _babaf.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _fcbf != nil {
			return _fcbf
		}
	}
	if _babaf.SrgbClr != nil {
		if _edabc := _babaf.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _edabc != nil {
			return _edabc
		}
	}
	if _babaf.HslClr != nil {
		if _gcga := _babaf.HslClr.ValidateWithPath(path + "\u002fHslClr"); _gcga != nil {
			return _gcga
		}
	}
	if _babaf.SysClr != nil {
		if _bbfba := _babaf.SysClr.ValidateWithPath(path + "\u002fSysClr"); _bbfba != nil {
			return _bbfba
		}
	}
	if _babaf.SchemeClr != nil {
		if _eadfff := _babaf.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _eadfff != nil {
			return _eadfff
		}
	}
	if _babaf.PrstClr != nil {
		if _dafaf := _babaf.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _dafaf != nil {
			return _dafaf
		}
	}
	return nil
}
func (_ededg *CT_WholeE2oFormatting) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _ededg.Ln != nil {
		_gbacf := _g.StartElement{Name: _g.Name{Local: "a:ln"}}
		e.EncodeElement(_ededg.Ln, _gbacf)
	}
	if _ededg.EffectLst != nil {
		_aedfe := _g.StartElement{Name: _g.Name{Local: "a:effectLst"}}
		e.EncodeElement(_ededg.EffectLst, _aedfe)
	}
	if _ededg.EffectDag != nil {
		_geacf := _g.StartElement{Name: _g.Name{Local: "a:effectDag"}}
		e.EncodeElement(_ededg.EffectDag, _geacf)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_AudioFile() *CT_AudioFile { _bec := &CT_AudioFile{}; return _bec }
func (_ebecef *CT_GvmlShapeNonVisual) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_dadff := _g.StartElement{Name: _g.Name{Local: "a:cNvPr"}}
	e.EncodeElement(_ebecef.CNvPr, _dadff)
	_efae := _g.StartElement{Name: _g.Name{Local: "a:cNvSpPr"}}
	e.EncodeElement(_ebecef.CNvSpPr, _efae)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_befad *CT_PositiveFixedPercentage) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", _befad.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the EG_Geometry and its children, prefixing error messages with path
func (_bfegg *EG_Geometry) ValidateWithPath(path string) error {
	if _bfegg.CustGeom != nil {
		if _ceeba := _bfegg.CustGeom.ValidateWithPath(path + "\u002fCustGeom"); _ceeba != nil {
			return _ceeba
		}
	}
	if _bfegg.PrstGeom != nil {
		if _befac := _bfegg.PrstGeom.ValidateWithPath(path + "\u002fPrstGeom"); _befac != nil {
			return _befac
		}
	}
	return nil
}
func (_fefdad ST_PositiveFixedPercentage) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _fefdad.ST_PositiveFixedPercentageDecimal != nil {
		e.EncodeToken(_g.CharData(_dcf.Sprintf("\u0025d", *_fefdad.ST_PositiveFixedPercentageDecimal)))
	}
	if _fefdad.ST_PositiveFixedPercentage != nil {
		e.Encode(_fefdad.ST_PositiveFixedPercentage)
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

// Validate validates the CT_PositiveFixedAngle and its children
func (_fgcaf *CT_PositiveFixedAngle) Validate() error {
	return _fgcaf.ValidateWithPath("CT_PositiveFixedAngle")
}
func (_abccd *EG_Effect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _abccd.Cont != nil {
		_bacbcd := _g.StartElement{Name: _g.Name{Local: "a:cont"}}
		e.EncodeElement(_abccd.Cont, _bacbcd)
	}
	if _abccd.Effect != nil {
		_ffgbd := _g.StartElement{Name: _g.Name{Local: "a:effect"}}
		e.EncodeElement(_abccd.Effect, _ffgbd)
	}
	if _abccd.AlphaBiLevel != nil {
		_degebb := _g.StartElement{Name: _g.Name{Local: "a:alphaBiLevel"}}
		e.EncodeElement(_abccd.AlphaBiLevel, _degebb)
	}
	if _abccd.AlphaCeiling != nil {
		_acbfb := _g.StartElement{Name: _g.Name{Local: "a:alphaCeiling"}}
		e.EncodeElement(_abccd.AlphaCeiling, _acbfb)
	}
	if _abccd.AlphaFloor != nil {
		_accdf := _g.StartElement{Name: _g.Name{Local: "a:alphaFloor"}}
		e.EncodeElement(_abccd.AlphaFloor, _accdf)
	}
	if _abccd.AlphaInv != nil {
		_gffca := _g.StartElement{Name: _g.Name{Local: "a:alphaInv"}}
		e.EncodeElement(_abccd.AlphaInv, _gffca)
	}
	if _abccd.AlphaMod != nil {
		_fgbdge := _g.StartElement{Name: _g.Name{Local: "a:alphaMod"}}
		e.EncodeElement(_abccd.AlphaMod, _fgbdge)
	}
	if _abccd.AlphaModFix != nil {
		_cefeb := _g.StartElement{Name: _g.Name{Local: "a:alphaModFix"}}
		e.EncodeElement(_abccd.AlphaModFix, _cefeb)
	}
	if _abccd.AlphaOutset != nil {
		_ebedg := _g.StartElement{Name: _g.Name{Local: "a:alphaOutset"}}
		e.EncodeElement(_abccd.AlphaOutset, _ebedg)
	}
	if _abccd.AlphaRepl != nil {
		_faecg := _g.StartElement{Name: _g.Name{Local: "a:alphaRepl"}}
		e.EncodeElement(_abccd.AlphaRepl, _faecg)
	}
	if _abccd.BiLevel != nil {
		_bbacg := _g.StartElement{Name: _g.Name{Local: "a:biLevel"}}
		e.EncodeElement(_abccd.BiLevel, _bbacg)
	}
	if _abccd.Blend != nil {
		_abgcff := _g.StartElement{Name: _g.Name{Local: "a:blend"}}
		e.EncodeElement(_abccd.Blend, _abgcff)
	}
	if _abccd.Blur != nil {
		_dddcc := _g.StartElement{Name: _g.Name{Local: "a:blur"}}
		e.EncodeElement(_abccd.Blur, _dddcc)
	}
	if _abccd.ClrChange != nil {
		_fcgba := _g.StartElement{Name: _g.Name{Local: "a:clrChange"}}
		e.EncodeElement(_abccd.ClrChange, _fcgba)
	}
	if _abccd.ClrRepl != nil {
		_edaef := _g.StartElement{Name: _g.Name{Local: "a:clrRepl"}}
		e.EncodeElement(_abccd.ClrRepl, _edaef)
	}
	if _abccd.Duotone != nil {
		_faadf := _g.StartElement{Name: _g.Name{Local: "a:duotone"}}
		e.EncodeElement(_abccd.Duotone, _faadf)
	}
	if _abccd.Fill != nil {
		_babfb := _g.StartElement{Name: _g.Name{Local: "a:fill"}}
		e.EncodeElement(_abccd.Fill, _babfb)
	}
	if _abccd.FillOverlay != nil {
		_dfeag := _g.StartElement{Name: _g.Name{Local: "a:fillOverlay"}}
		e.EncodeElement(_abccd.FillOverlay, _dfeag)
	}
	if _abccd.Glow != nil {
		_badef := _g.StartElement{Name: _g.Name{Local: "a:glow"}}
		e.EncodeElement(_abccd.Glow, _badef)
	}
	if _abccd.Grayscl != nil {
		_aaebb := _g.StartElement{Name: _g.Name{Local: "a:grayscl"}}
		e.EncodeElement(_abccd.Grayscl, _aaebb)
	}
	if _abccd.Hsl != nil {
		_cdbfc := _g.StartElement{Name: _g.Name{Local: "a:hsl"}}
		e.EncodeElement(_abccd.Hsl, _cdbfc)
	}
	if _abccd.InnerShdw != nil {
		_bddeea := _g.StartElement{Name: _g.Name{Local: "a:innerShdw"}}
		e.EncodeElement(_abccd.InnerShdw, _bddeea)
	}
	if _abccd.Lum != nil {
		_bcegd := _g.StartElement{Name: _g.Name{Local: "a:lum"}}
		e.EncodeElement(_abccd.Lum, _bcegd)
	}
	if _abccd.OuterShdw != nil {
		_faggg := _g.StartElement{Name: _g.Name{Local: "a:outerShdw"}}
		e.EncodeElement(_abccd.OuterShdw, _faggg)
	}
	if _abccd.PrstShdw != nil {
		_gegdb := _g.StartElement{Name: _g.Name{Local: "a:prstShdw"}}
		e.EncodeElement(_abccd.PrstShdw, _gegdb)
	}
	if _abccd.Reflection != nil {
		_affgc := _g.StartElement{Name: _g.Name{Local: "a:reflection"}}
		e.EncodeElement(_abccd.Reflection, _affgc)
	}
	if _abccd.RelOff != nil {
		_eefdf := _g.StartElement{Name: _g.Name{Local: "a:relOff"}}
		e.EncodeElement(_abccd.RelOff, _eefdf)
	}
	if _abccd.SoftEdge != nil {
		_bcgcbb := _g.StartElement{Name: _g.Name{Local: "a:softEdge"}}
		e.EncodeElement(_abccd.SoftEdge, _bcgcbb)
	}
	if _abccd.Tint != nil {
		_efbbd := _g.StartElement{Name: _g.Name{Local: "a:tint"}}
		e.EncodeElement(_abccd.Tint, _efbbd)
	}
	if _abccd.Xfrm != nil {
		_dbacd := _g.StartElement{Name: _g.Name{Local: "a:xfrm"}}
		e.EncodeElement(_abccd.Xfrm, _dbacd)
	}
	return nil
}

type CT_NonVisualPictureProperties struct {
	PreferRelativeResizeAttr *bool
	PicLocks                 *CT_PictureLocking
	ExtLst                   *CT_OfficeArtExtensionList
}

func NewCT_ColorMappingOverride() *CT_ColorMappingOverride {
	_bbdg := &CT_ColorMappingOverride{}
	_bbdg.Choice = NewCT_ColorMappingOverrideChoice()
	return _bbdg
}
func (_cfdbea *CT_Path2DList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fcffdb:
	for {
		_agac, _cfgba := d.Token()
		if _cfgba != nil {
			return _cfgba
		}
		switch _cebe := _agac.(type) {
		case _g.StartElement:
			switch _cebe.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "path"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "path"}:
				_egbfc := NewCT_Path2D()
				if _gfggff := d.DecodeElement(_egbfc, &_cebe); _gfggff != nil {
					return _gfggff
				}
				_cfdbea.Path = append(_cfdbea.Path, _egbfc)
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_Path2DList \u0025v", _cebe.Name)
				if _fcfcea := d.Skip(); _fcfcea != nil {
					return _fcfcea
				}
			}
		case _g.EndElement:
			break _fcffdb
		case _g.CharData:
		}
	}
	return nil
}

type CT_GvmlPictureNonVisual struct {
	CNvPr    *CT_NonVisualDrawingProps
	CNvPicPr *CT_NonVisualPictureProperties
}

// ValidateWithPath validates the CT_AdjustHandleList and its children, prefixing error messages with path
func (_dcc *CT_AdjustHandleList) ValidateWithPath(path string) error {
	for _ggd, _bfe := range _dcc.AhXY {
		if _bbgc := _bfe.ValidateWithPath(_dcf.Sprintf("%s\u002fAhXY\u005b\u0025d\u005d", path, _ggd)); _bbgc != nil {
			return _bbgc
		}
	}
	for _fba, _eda := range _dcc.AhPolar {
		if _dga := _eda.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fAhPolar\u005b\u0025d\u005d", path, _fba)); _dga != nil {
			return _dga
		}
	}
	return nil
}
func NewCT_TableStyle() *CT_TableStyle {
	_aefdba := &CT_TableStyle{}
	_aefdba.StyleIdAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	return _aefdba
}

const (
	ST_TextVerticalTypeUnset          ST_TextVerticalType = 0
	ST_TextVerticalTypeHorz           ST_TextVerticalType = 1
	ST_TextVerticalTypeVert           ST_TextVerticalType = 2
	ST_TextVerticalTypeVert270        ST_TextVerticalType = 3
	ST_TextVerticalTypeWordArtVert    ST_TextVerticalType = 4
	ST_TextVerticalTypeEaVert         ST_TextVerticalType = 5
	ST_TextVerticalTypeMongolianVert  ST_TextVerticalType = 6
	ST_TextVerticalTypeWordArtVertRtl ST_TextVerticalType = 7
)

func (_ageebd ST_ShapeType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ageebd.String(), start)
}

// ValidateWithPath validates the CT_Path2DList and its children, prefixing error messages with path
func (_bbega *CT_Path2DList) ValidateWithPath(path string) error {
	for _dfacg, _fgga := range _bbega.Path {
		if _befce := _fgga.ValidateWithPath(_dcf.Sprintf("%s\u002fPath\u005b\u0025d\u005d", path, _dfacg)); _befce != nil {
			return _befce
		}
	}
	return nil
}
func (_fdcefd *CT_Path2DCubicBezierTo) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_eagad := _g.StartElement{Name: _g.Name{Local: "a:pt"}}
	for _, _egbfd := range _fdcefd.Pt {
		e.EncodeElement(_egbfd, _eagad)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_BaseStyles() *CT_BaseStyles {
	_fdc := &CT_BaseStyles{}
	_fdc.ClrScheme = NewCT_ColorScheme()
	_fdc.FontScheme = NewCT_FontScheme()
	_fdc.FmtScheme = NewCT_StyleMatrix()
	return _fdc
}

type CT_HSLEffect struct {
	HueAttr *int32
	SatAttr *ST_FixedPercentage
	LumAttr *ST_FixedPercentage
}

func (_cebgdf ST_EffectContainerType) ValidateWithPath(path string) error {
	switch _cebgdf {
	case 0, 1, 2:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cebgdf))
	}
	return nil
}
func NewCT_CustomGeometry2D() *CT_CustomGeometry2D {
	_adbe := &CT_CustomGeometry2D{}
	_adbe.PathLst = NewCT_Path2DList()
	return _adbe
}

type CT_PositiveFixedAngle struct{ ValAttr int32 }

func (_egffaac *EG_OfficeArtExtensionList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fgdac:
	for {
		_eggee, _egfcf := d.Token()
		if _egfcf != nil {
			return _egfcf
		}
		switch _dfbfc := _eggee.(type) {
		case _g.StartElement:
			switch _dfbfc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ext"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ext"}:
				_ecdfa := NewCT_OfficeArtExtension()
				if _gcfc := d.DecodeElement(_ecdfa, &_dfbfc); _gcfc != nil {
					return _gcfc
				}
				_egffaac.Ext = append(_egffaac.Ext, _ecdfa)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_OfficeArtExtensionList\u0020\u0025v", _dfbfc.Name)
				if _bgad := d.Skip(); _bgad != nil {
					return _bgad
				}
			}
		case _g.EndElement:
			break _fgdac
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_AlphaFloorEffect and its children
func (_ebdd *CT_AlphaFloorEffect) Validate() error {
	return _ebdd.ValidateWithPath("CT_AlphaFloorEffect")
}
func (_eafbf *CT_GvmlConnectorNonVisual) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_efea := _g.StartElement{Name: _g.Name{Local: "a:cNvPr"}}
	e.EncodeElement(_eafbf.CNvPr, _efea)
	_cfffe := _g.StartElement{Name: _g.Name{Local: "a:cNvCxnSpPr"}}
	e.EncodeElement(_eafbf.CNvCxnSpPr, _cfffe)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ColorChangeEffect and its children, prefixing error messages with path
func (_fdaa *CT_ColorChangeEffect) ValidateWithPath(path string) error {
	if _cace := _fdaa.ClrFrom.ValidateWithPath(path + "\u002fClrFrom"); _cace != nil {
		return _cace
	}
	if _beg := _fdaa.ClrTo.ValidateWithPath(path + "\u002fClrTo"); _beg != nil {
		return _beg
	}
	return nil
}
func (_agaab *CT_ShapeProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _agaab.BwModeAttr != ST_BlackWhiteModeUnset {
		_bgbf, _gabge := _agaab.BwModeAttr.MarshalXMLAttr(_g.Name{Local: "bwMode"})
		if _gabge != nil {
			return _gabge
		}
		start.Attr = append(start.Attr, _bgbf)
	}
	e.EncodeToken(start)
	if _agaab.Xfrm != nil {
		_fegdd := _g.StartElement{Name: _g.Name{Local: "a:xfrm"}}
		e.EncodeElement(_agaab.Xfrm, _fegdd)
	}
	if _agaab.CustGeom != nil {
		_affedc := _g.StartElement{Name: _g.Name{Local: "a:custGeom"}}
		e.EncodeElement(_agaab.CustGeom, _affedc)
	}
	if _agaab.PrstGeom != nil {
		_afac := _g.StartElement{Name: _g.Name{Local: "a:prstGeom"}}
		e.EncodeElement(_agaab.PrstGeom, _afac)
	}
	if _agaab.NoFill != nil {
		_gfdce := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_agaab.NoFill, _gfdce)
	}
	if _agaab.SolidFill != nil {
		_fedag := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_agaab.SolidFill, _fedag)
	}
	if _agaab.GradFill != nil {
		_ggdee := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_agaab.GradFill, _ggdee)
	}
	if _agaab.BlipFill != nil {
		_fcec := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
		e.EncodeElement(_agaab.BlipFill, _fcec)
	}
	if _agaab.PattFill != nil {
		_bfbc := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_agaab.PattFill, _bfbc)
	}
	if _agaab.GrpFill != nil {
		_afbbce := _g.StartElement{Name: _g.Name{Local: "a:grpFill"}}
		e.EncodeElement(_agaab.GrpFill, _afbbce)
	}
	if _agaab.Ln != nil {
		_bfda := _g.StartElement{Name: _g.Name{Local: "a:ln"}}
		e.EncodeElement(_agaab.Ln, _bfda)
	}
	if _agaab.EffectLst != nil {
		_dfagc := _g.StartElement{Name: _g.Name{Local: "a:effectLst"}}
		e.EncodeElement(_agaab.EffectLst, _dfagc)
	}
	if _agaab.EffectDag != nil {
		_gcea := _g.StartElement{Name: _g.Name{Local: "a:effectDag"}}
		e.EncodeElement(_agaab.EffectDag, _gcea)
	}
	if _agaab.Scene3d != nil {
		_acceb := _g.StartElement{Name: _g.Name{Local: "a:scene3d"}}
		e.EncodeElement(_agaab.Scene3d, _acceb)
	}
	if _agaab.Sp3d != nil {
		_bbaaf := _g.StartElement{Name: _g.Name{Local: "a:sp3d"}}
		e.EncodeElement(_agaab.Sp3d, _bbaaf)
	}
	if _agaab.ExtLst != nil {
		_ebfbd := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_agaab.ExtLst, _ebfbd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_bbbbd *CT_Shape3D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fagg := range start.Attr {
		if _fagg.Name.Local == "z" {
			_gefae, _eacee := ParseUnionST_Coordinate(_fagg.Value)
			if _eacee != nil {
				return _eacee
			}
			_bbbbd.ZAttr = &_gefae
			continue
		}
		if _fagg.Name.Local == "extrusionH" {
			_efgfb, _eacb := _e.ParseInt(_fagg.Value, 10, 64)
			if _eacb != nil {
				return _eacb
			}
			_bbbbd.ExtrusionHAttr = &_efgfb
			continue
		}
		if _fagg.Name.Local == "contourW" {
			_cfgdg, _ffgb := _e.ParseInt(_fagg.Value, 10, 64)
			if _ffgb != nil {
				return _ffgb
			}
			_bbbbd.ContourWAttr = &_cfgdg
			continue
		}
		if _fagg.Name.Local == "prstMaterial" {
			_bbbbd.PrstMaterialAttr.UnmarshalXMLAttr(_fagg)
			continue
		}
	}
_fgbab:
	for {
		_gbbf, _dcdg := d.Token()
		if _dcdg != nil {
			return _dcdg
		}
		switch _bagdd := _gbbf.(type) {
		case _g.StartElement:
			switch _bagdd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bevelT"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bevelT"}:
				_bbbbd.BevelT = NewCT_Bevel()
				if _cgce := d.DecodeElement(_bbbbd.BevelT, &_bagdd); _cgce != nil {
					return _cgce
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bevelB"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bevelB"}:
				_bbbbd.BevelB = NewCT_Bevel()
				if _ebbda := d.DecodeElement(_bbbbd.BevelB, &_bagdd); _ebbda != nil {
					return _ebbda
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extrusionClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extrusionClr"}:
				_bbbbd.ExtrusionClr = NewCT_Color()
				if _gdfe := d.DecodeElement(_bbbbd.ExtrusionClr, &_bagdd); _gdfe != nil {
					return _gdfe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "contourClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "contourClr"}:
				_bbbbd.ContourClr = NewCT_Color()
				if _fdedb := d.DecodeElement(_bbbbd.ContourClr, &_bagdd); _fdedb != nil {
					return _fdedb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_bbbbd.ExtLst = NewCT_OfficeArtExtensionList()
				if _dagaf := d.DecodeElement(_bbbbd.ExtLst, &_bagdd); _dagaf != nil {
					return _dagaf
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_Shape3D\u0020\u0025v", _bagdd.Name)
				if _bdcga := d.Skip(); _bdcga != nil {
					return _bdcga
				}
			}
		case _g.EndElement:
			break _fgbab
		case _g.CharData:
		}
	}
	return nil
}
func ParseStdlibTime(s string) (_d.Time, error) { return _d.Time{}, nil }

// Validate validates the EG_OfficeArtExtensionList and its children
func (_acgdde *EG_OfficeArtExtensionList) Validate() error {
	return _acgdde.ValidateWithPath("EG_OfficeArtExtensionList")
}
func (_cgega ST_PresetMaterialType) ValidateWithPath(path string) error {
	switch _cgega {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cgega))
	}
	return nil
}
func (_bbded *CT_NonVisualDrawingProps) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fabg := range start.Attr {
		if _fabg.Name.Local == "id" {
			_dfdaf, _bdbg := _e.ParseUint(_fabg.Value, 10, 32)
			if _bdbg != nil {
				return _bdbg
			}
			_bbded.IdAttr = uint32(_dfdaf)
			continue
		}
		if _fabg.Name.Local == "name" {
			_gacdgc, _bebbb := _fabg.Value, error(nil)
			if _bebbb != nil {
				return _bebbb
			}
			_bbded.NameAttr = _gacdgc
			continue
		}
		if _fabg.Name.Local == "descr" {
			_bbabb, _fdcc := _fabg.Value, error(nil)
			if _fdcc != nil {
				return _fdcc
			}
			_bbded.DescrAttr = &_bbabb
			continue
		}
		if _fabg.Name.Local == "hidden" {
			_bacee, _gdcb := _e.ParseBool(_fabg.Value)
			if _gdcb != nil {
				return _gdcb
			}
			_bbded.HiddenAttr = &_bacee
			continue
		}
		if _fabg.Name.Local == "title" {
			_fabde, _bebcc := _fabg.Value, error(nil)
			if _bebcc != nil {
				return _bebcc
			}
			_bbded.TitleAttr = &_fabde
			continue
		}
	}
_geggc:
	for {
		_gcbfc, _agdb := d.Token()
		if _agdb != nil {
			return _agdb
		}
		switch _ddbac := _gcbfc.(type) {
		case _g.StartElement:
			switch _ddbac.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hlinkClick"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hlinkClick"}:
				_bbded.HlinkClick = NewCT_Hyperlink()
				if _dcbf := d.DecodeElement(_bbded.HlinkClick, &_ddbac); _dcbf != nil {
					return _dcbf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hlinkHover"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hlinkHover"}:
				_bbded.HlinkHover = NewCT_Hyperlink()
				if _ggdbc := d.DecodeElement(_bbded.HlinkHover, &_ddbac); _ggdbc != nil {
					return _ggdbc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_bbded.ExtLst = NewCT_OfficeArtExtensionList()
				if _efaef := d.DecodeElement(_bbded.ExtLst, &_ddbac); _efaef != nil {
					return _efaef
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_NonVisualDrawingProps\u0020%v", _ddbac.Name)
				if _gfdag := d.Skip(); _gfdag != nil {
					return _gfdag
				}
			}
		case _g.EndElement:
			break _geggc
		case _g.CharData:
		}
	}
	return nil
}

const (
	ST_PresetMaterialTypeUnset             ST_PresetMaterialType = 0
	ST_PresetMaterialTypeLegacyMatte       ST_PresetMaterialType = 1
	ST_PresetMaterialTypeLegacyPlastic     ST_PresetMaterialType = 2
	ST_PresetMaterialTypeLegacyMetal       ST_PresetMaterialType = 3
	ST_PresetMaterialTypeLegacyWireframe   ST_PresetMaterialType = 4
	ST_PresetMaterialTypeMatte             ST_PresetMaterialType = 5
	ST_PresetMaterialTypePlastic           ST_PresetMaterialType = 6
	ST_PresetMaterialTypeMetal             ST_PresetMaterialType = 7
	ST_PresetMaterialTypeWarmMatte         ST_PresetMaterialType = 8
	ST_PresetMaterialTypeTranslucentPowder ST_PresetMaterialType = 9
	ST_PresetMaterialTypePowder            ST_PresetMaterialType = 10
	ST_PresetMaterialTypeDkEdge            ST_PresetMaterialType = 11
	ST_PresetMaterialTypeSoftEdge          ST_PresetMaterialType = 12
	ST_PresetMaterialTypeClear             ST_PresetMaterialType = 13
	ST_PresetMaterialTypeFlat              ST_PresetMaterialType = 14
	ST_PresetMaterialTypeSoftmetal         ST_PresetMaterialType = 15
)

func (_ccaff ST_OnOffStyleType) ValidateWithPath(path string) error {
	switch _ccaff {
	case 0, 1, 2, 3:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ccaff))
	}
	return nil
}
func (_gadbe *CT_TableProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _gabbdd := range start.Attr {
		if _gabbdd.Name.Local == "firstRow" {
			_caeaa, _gegcf := _e.ParseBool(_gabbdd.Value)
			if _gegcf != nil {
				return _gegcf
			}
			_gadbe.FirstRowAttr = &_caeaa
			continue
		}
		if _gabbdd.Name.Local == "lastRow" {
			_ffba, _gdaec := _e.ParseBool(_gabbdd.Value)
			if _gdaec != nil {
				return _gdaec
			}
			_gadbe.LastRowAttr = &_ffba
			continue
		}
		if _gabbdd.Name.Local == "bandRow" {
			_fecdc, _dacd := _e.ParseBool(_gabbdd.Value)
			if _dacd != nil {
				return _dacd
			}
			_gadbe.BandRowAttr = &_fecdc
			continue
		}
		if _gabbdd.Name.Local == "bandCol" {
			_gbcec, _bccbd := _e.ParseBool(_gabbdd.Value)
			if _bccbd != nil {
				return _bccbd
			}
			_gadbe.BandColAttr = &_gbcec
			continue
		}
		if _gabbdd.Name.Local == "rtl" {
			_cabbd, _efabe := _e.ParseBool(_gabbdd.Value)
			if _efabe != nil {
				return _efabe
			}
			_gadbe.RtlAttr = &_cabbd
			continue
		}
		if _gabbdd.Name.Local == "firstCol" {
			_gcbgb, _fgbgbc := _e.ParseBool(_gabbdd.Value)
			if _fgbgbc != nil {
				return _fgbgbc
			}
			_gadbe.FirstColAttr = &_gcbgb
			continue
		}
		if _gabbdd.Name.Local == "lastCol" {
			_fadfe, _eaaed := _e.ParseBool(_gabbdd.Value)
			if _eaaed != nil {
				return _eaaed
			}
			_gadbe.LastColAttr = &_fadfe
			continue
		}
	}
_abcf:
	for {
		_eceea, _gdgde := d.Token()
		if _gdgde != nil {
			return _gdgde
		}
		switch _acbed := _eceea.(type) {
		case _g.StartElement:
			switch _acbed.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_gadbe.NoFill = NewCT_NoFillProperties()
				if _dadge := d.DecodeElement(_gadbe.NoFill, &_acbed); _dadge != nil {
					return _dadge
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_gadbe.SolidFill = NewCT_SolidColorFillProperties()
				if _debbd := d.DecodeElement(_gadbe.SolidFill, &_acbed); _debbd != nil {
					return _debbd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_gadbe.GradFill = NewCT_GradientFillProperties()
				if _efbcf := d.DecodeElement(_gadbe.GradFill, &_acbed); _efbcf != nil {
					return _efbcf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_gadbe.BlipFill = NewCT_BlipFillProperties()
				if _cbcad := d.DecodeElement(_gadbe.BlipFill, &_acbed); _cbcad != nil {
					return _cbcad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_gadbe.PattFill = NewCT_PatternFillProperties()
				if _fddgb := d.DecodeElement(_gadbe.PattFill, &_acbed); _fddgb != nil {
					return _fddgb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_gadbe.GrpFill = NewCT_GroupFillProperties()
				if _edfgf := d.DecodeElement(_gadbe.GrpFill, &_acbed); _edfgf != nil {
					return _edfgf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectLst"}:
				_gadbe.EffectLst = NewCT_EffectList()
				if _edbe := d.DecodeElement(_gadbe.EffectLst, &_acbed); _edbe != nil {
					return _edbe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectDag"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectDag"}:
				_gadbe.EffectDag = NewCT_EffectContainer()
				if _bacbg := d.DecodeElement(_gadbe.EffectDag, &_acbed); _bacbg != nil {
					return _bacbg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tableStyle"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tableStyle"}:
				_gadbe.Choice = NewCT_TablePropertiesChoice()
				if _afbdb := d.DecodeElement(&_gadbe.Choice.TableStyle, &_acbed); _afbdb != nil {
					return _afbdb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tableStyleId"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tableStyleId"}:
				_gadbe.Choice = NewCT_TablePropertiesChoice()
				if _cdeab := d.DecodeElement(&_gadbe.Choice.TableStyleId, &_acbed); _cdeab != nil {
					return _cdeab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_gadbe.ExtLst = NewCT_OfficeArtExtensionList()
				if _ddedd := d.DecodeElement(_gadbe.ExtLst, &_acbed); _ddedd != nil {
					return _ddedd
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_TableProperties\u0020\u0025v", _acbed.Name)
				if _aebb := d.Skip(); _aebb != nil {
					return _aebb
				}
			}
		case _g.EndElement:
			break _abcf
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_NonVisualGroupDrawingShapeProps() *CT_NonVisualGroupDrawingShapeProps {
	_cbgac := &CT_NonVisualGroupDrawingShapeProps{}
	return _cbgac
}
func (_caa *CT_AlphaModulateFixedEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bee := range start.Attr {
		if _bee.Name.Local == "amt" {
			_fce, _bac := ParseUnionST_PositivePercentage(_bee.Value)
			if _bac != nil {
				return _bac
			}
			_caa.AmtAttr = &_fce
			continue
		}
	}
	for {
		_fcf, _faea := d.Token()
		if _faea != nil {
			return _dcf.Errorf("parsing\u0020CT_AlphaModulateFixedEffect:\u0020\u0025s", _faea)
		}
		if _fcd, _cefg := _fcf.(_g.EndElement); _cefg && _fcd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dcedb *ST_Coordinate) ValidateWithPath(path string) error {
	_fdgfc := []string{}
	if _dcedb.ST_CoordinateUnqualified != nil {
		_fdgfc = append(_fdgfc, "ST_CoordinateUnqualified")
	}
	if _dcedb.ST_UniversalMeasure != nil {
		_fdgfc = append(_fdgfc, "ST_UniversalMeasure")
	}
	if len(_fdgfc) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _fdgfc)
	}
	return nil
}
func (_dgcfa ST_TextCapsType) String() string {
	switch _dgcfa {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "small"
	case 3:
		return "all"
	}
	return ""
}

// ValidateWithPath validates the CT_NonVisualDrawingProps and its children, prefixing error messages with path
func (_afdcb *CT_NonVisualDrawingProps) ValidateWithPath(path string) error {
	if _afdcb.HlinkClick != nil {
		if _bcfe := _afdcb.HlinkClick.ValidateWithPath(path + "/HlinkClick"); _bcfe != nil {
			return _bcfe
		}
	}
	if _afdcb.HlinkHover != nil {
		if _ecbbge := _afdcb.HlinkHover.ValidateWithPath(path + "/HlinkHover"); _ecbbge != nil {
			return _ecbbge
		}
	}
	if _afdcb.ExtLst != nil {
		if _gedc := _afdcb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gedc != nil {
			return _gedc
		}
	}
	return nil
}
func (_bcba *CT_GvmlTextShape) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_egcbe := _g.StartElement{Name: _g.Name{Local: "a:txBody"}}
	e.EncodeElement(_bcba.TxBody, _egcbe)
	if _bcba.Choice != nil {
		_bcba.Choice.MarshalXML(e, _g.StartElement{})
	}
	if _bcba.ExtLst != nil {
		_efdb := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_bcba.ExtLst, _efdb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_afgc *CT_HslColor) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_afgc.HueAttr = 0
	for _, _fcdca := range start.Attr {
		if _fcdca.Name.Local == "hue" {
			_bbce, _dacag := _e.ParseInt(_fcdca.Value, 10, 32)
			if _dacag != nil {
				return _dacag
			}
			_afgc.HueAttr = int32(_bbce)
			continue
		}
		if _fcdca.Name.Local == "sat" {
			_eeaaa, _ggba := ParseUnionST_Percentage(_fcdca.Value)
			if _ggba != nil {
				return _ggba
			}
			_afgc.SatAttr = _eeaaa
			continue
		}
		if _fcdca.Name.Local == "lum" {
			_fbadf, _deegd := ParseUnionST_Percentage(_fcdca.Value)
			if _deegd != nil {
				return _deegd
			}
			_afgc.LumAttr = _fbadf
			continue
		}
	}
_gdbef:
	for {
		_aegdc, _aafe := d.Token()
		if _aafe != nil {
			return _aafe
		}
		switch _ccga := _aegdc.(type) {
		case _g.StartElement:
			switch _ccga.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_bcbgf := NewEG_ColorTransform()
				_bcbgf.Tint = NewCT_PositiveFixedPercentage()
				if _fgcgf := d.DecodeElement(_bcbgf.Tint, &_ccga); _fgcgf != nil {
					return _fgcgf
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _bcbgf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "shade"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "shade"}:
				_dgggd := NewEG_ColorTransform()
				_dgggd.Shade = NewCT_PositiveFixedPercentage()
				if _fdgfe := d.DecodeElement(_dgggd.Shade, &_ccga); _fdgfe != nil {
					return _fdgfe
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _dgggd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "comp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "comp"}:
				_egbdf := NewEG_ColorTransform()
				_egbdf.Comp = NewCT_ComplementTransform()
				if _dfbg := d.DecodeElement(_egbdf.Comp, &_ccga); _dfbg != nil {
					return _dfbg
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _egbdf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "inv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "inv"}:
				_fgag := NewEG_ColorTransform()
				_fgag.Inv = NewCT_InverseTransform()
				if _fdcda := d.DecodeElement(_fgag.Inv, &_ccga); _fdcda != nil {
					return _fdcda
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _fgag)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gray"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gray"}:
				_befd := NewEG_ColorTransform()
				_befd.Gray = NewCT_GrayscaleTransform()
				if _cedge := d.DecodeElement(_befd.Gray, &_ccga); _cedge != nil {
					return _cedge
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _befd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alpha"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alpha"}:
				_bacfb := NewEG_ColorTransform()
				_bacfb.Alpha = NewCT_PositiveFixedPercentage()
				if _dbgc := d.DecodeElement(_bacfb.Alpha, &_ccga); _dbgc != nil {
					return _dbgc
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _bacfb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaOff"}:
				_bacfc := NewEG_ColorTransform()
				_bacfc.AlphaOff = NewCT_FixedPercentage()
				if _aebc := d.DecodeElement(_bacfc.AlphaOff, &_ccga); _aebc != nil {
					return _aebc
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _bacfc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_eefc := NewEG_ColorTransform()
				_eefc.AlphaMod = NewCT_PositivePercentage()
				if _agbbc := d.DecodeElement(_eefc.AlphaMod, &_ccga); _agbbc != nil {
					return _agbbc
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _eefc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hue"}:
				_befa := NewEG_ColorTransform()
				_befa.Hue = NewCT_PositiveFixedAngle()
				if _fbfd := d.DecodeElement(_befa.Hue, &_ccga); _fbfd != nil {
					return _fbfd
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _befa)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueOff"}:
				_becee := NewEG_ColorTransform()
				_becee.HueOff = NewCT_Angle()
				if _fdbdd := d.DecodeElement(_becee.HueOff, &_ccga); _fdbdd != nil {
					return _fdbdd
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _becee)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueMod"}:
				_fefd := NewEG_ColorTransform()
				_fefd.HueMod = NewCT_PositivePercentage()
				if _afff := d.DecodeElement(_fefd.HueMod, &_ccga); _afff != nil {
					return _afff
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _fefd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sat"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sat"}:
				_cbgda := NewEG_ColorTransform()
				_cbgda.Sat = NewCT_Percentage()
				if _eecgg := d.DecodeElement(_cbgda.Sat, &_ccga); _eecgg != nil {
					return _eecgg
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _cbgda)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satOff"}:
				_cbeag := NewEG_ColorTransform()
				_cbeag.SatOff = NewCT_Percentage()
				if _geff := d.DecodeElement(_cbeag.SatOff, &_ccga); _geff != nil {
					return _geff
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _cbeag)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satMod"}:
				_febg := NewEG_ColorTransform()
				_febg.SatMod = NewCT_Percentage()
				if _egccf := d.DecodeElement(_febg.SatMod, &_ccga); _egccf != nil {
					return _egccf
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _febg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_bebb := NewEG_ColorTransform()
				_bebb.Lum = NewCT_Percentage()
				if _bbga := d.DecodeElement(_bebb.Lum, &_ccga); _bbga != nil {
					return _bbga
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _bebb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumOff"}:
				_ecab := NewEG_ColorTransform()
				_ecab.LumOff = NewCT_Percentage()
				if _gccfb := d.DecodeElement(_ecab.LumOff, &_ccga); _gccfb != nil {
					return _gccfb
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _ecab)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumMod"}:
				_dfcade := NewEG_ColorTransform()
				_dfcade.LumMod = NewCT_Percentage()
				if _fcaf := d.DecodeElement(_dfcade.LumMod, &_ccga); _fcaf != nil {
					return _fcaf
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _dfcade)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "red"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "red"}:
				_dbegd := NewEG_ColorTransform()
				_dbegd.Red = NewCT_Percentage()
				if _dcgafg := d.DecodeElement(_dbegd.Red, &_ccga); _dcgafg != nil {
					return _dcgafg
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _dbegd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redOff"}:
				_ecbg := NewEG_ColorTransform()
				_ecbg.RedOff = NewCT_Percentage()
				if _fcfcc := d.DecodeElement(_ecbg.RedOff, &_ccga); _fcfcc != nil {
					return _fcfcc
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _ecbg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redMod"}:
				_dbbab := NewEG_ColorTransform()
				_dbbab.RedMod = NewCT_Percentage()
				if _dddb := d.DecodeElement(_dbbab.RedMod, &_ccga); _dddb != nil {
					return _dddb
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _dbbab)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "green"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "green"}:
				_cafe := NewEG_ColorTransform()
				_cafe.Green = NewCT_Percentage()
				if _agecg := d.DecodeElement(_cafe.Green, &_ccga); _agecg != nil {
					return _agecg
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _cafe)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenOff"}:
				_cdfg := NewEG_ColorTransform()
				_cdfg.GreenOff = NewCT_Percentage()
				if _bbfbc := d.DecodeElement(_cdfg.GreenOff, &_ccga); _bbfbc != nil {
					return _bbfbc
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _cdfg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenMod"}:
				_bcdf := NewEG_ColorTransform()
				_bcdf.GreenMod = NewCT_Percentage()
				if _gfcbbb := d.DecodeElement(_bcdf.GreenMod, &_ccga); _gfcbbb != nil {
					return _gfcbbb
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _bcdf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blue"}:
				_bbdeg := NewEG_ColorTransform()
				_bbdeg.Blue = NewCT_Percentage()
				if _fcef := d.DecodeElement(_bbdeg.Blue, &_ccga); _fcef != nil {
					return _fcef
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _bbdeg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueOff"}:
				_acfed := NewEG_ColorTransform()
				_acfed.BlueOff = NewCT_Percentage()
				if _ccdb := d.DecodeElement(_acfed.BlueOff, &_ccga); _ccdb != nil {
					return _ccdb
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _acfed)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueMod"}:
				_ceeb := NewEG_ColorTransform()
				_ceeb.BlueMod = NewCT_Percentage()
				if _cbbg := d.DecodeElement(_ceeb.BlueMod, &_ccga); _cbbg != nil {
					return _cbbg
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _ceeb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gamma"}:
				_gafff := NewEG_ColorTransform()
				_gafff.Gamma = NewCT_GammaTransform()
				if _bccfg := d.DecodeElement(_gafff.Gamma, &_ccga); _bccfg != nil {
					return _bccfg
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _gafff)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "invGamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "invGamma"}:
				_fbfda := NewEG_ColorTransform()
				_fbfda.InvGamma = NewCT_InverseGammaTransform()
				if _eaaf := d.DecodeElement(_fbfda.InvGamma, &_ccga); _eaaf != nil {
					return _eaaf
				}
				_afgc.EG_ColorTransform = append(_afgc.EG_ColorTransform, _fbfda)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_HslColor\u0020\u0025v", _ccga.Name)
				if _cfddg := d.Skip(); _cfddg != nil {
					return _cfddg
				}
			}
		case _g.EndElement:
			break _gdbef
		case _g.CharData:
		}
	}
	return nil
}
func (_bagdg ST_Coordinate) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _bagdg.ST_CoordinateUnqualified != nil {
		e.EncodeToken(_g.CharData(_dcf.Sprintf("\u0025d", *_bagdg.ST_CoordinateUnqualified)))
	}
	if _bagdg.ST_UniversalMeasure != nil {
		e.EncodeToken(_g.CharData(*_bagdg.ST_UniversalMeasure))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}
func NewCT_Transform2D() *CT_Transform2D           { _adafd := &CT_Transform2D{}; return _adafd }
func (_eaeaa ST_PresetCameraType) Validate() error { return _eaeaa.ValidateWithPath("") }

// Validate validates the CT_PictureLocking and its children
func (_cfad *CT_PictureLocking) Validate() error { return _cfad.ValidateWithPath("CT_PictureLocking") }

// Validate validates the Tbl and its children
func (_cbgbb *Tbl) Validate() error { return _cbgbb.ValidateWithPath("Tbl") }

const (
	ST_PitchFamilyUnset ST_PitchFamily = 0
	ST_PitchFamily00    ST_PitchFamily = 1
	ST_PitchFamily01    ST_PitchFamily = 2
	ST_PitchFamily02    ST_PitchFamily = 3
	ST_PitchFamily16    ST_PitchFamily = 4
	ST_PitchFamily17    ST_PitchFamily = 5
	ST_PitchFamily18    ST_PitchFamily = 6
	ST_PitchFamily32    ST_PitchFamily = 7
	ST_PitchFamily33    ST_PitchFamily = 8
	ST_PitchFamily34    ST_PitchFamily = 9
	ST_PitchFamily48    ST_PitchFamily = 10
	ST_PitchFamily49    ST_PitchFamily = 11
	ST_PitchFamily50    ST_PitchFamily = 12
	ST_PitchFamily64    ST_PitchFamily = 13
	ST_PitchFamily65    ST_PitchFamily = 14
	ST_PitchFamily66    ST_PitchFamily = 15
	ST_PitchFamily80    ST_PitchFamily = 16
	ST_PitchFamily81    ST_PitchFamily = 17
	ST_PitchFamily82    ST_PitchFamily = 18
)

func (_aeed *CT_PresetShadowEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_aeed.PrstAttr = ST_PresetShadowVal(1)
	for _, _beabe := range start.Attr {
		if _beabe.Name.Local == "prst" {
			_aeed.PrstAttr.UnmarshalXMLAttr(_beabe)
			continue
		}
		if _beabe.Name.Local == "dist" {
			_gccfd, _dgade := _e.ParseInt(_beabe.Value, 10, 64)
			if _dgade != nil {
				return _dgade
			}
			_aeed.DistAttr = &_gccfd
			continue
		}
		if _beabe.Name.Local == "dir" {
			_dagdf, _deefc := _e.ParseInt(_beabe.Value, 10, 32)
			if _deefc != nil {
				return _deefc
			}
			_aacba := int32(_dagdf)
			_aeed.DirAttr = &_aacba
			continue
		}
	}
_cabdc:
	for {
		_gacb, _ecdb := d.Token()
		if _ecdb != nil {
			return _ecdb
		}
		switch _cdbff := _gacb.(type) {
		case _g.StartElement:
			switch _cdbff.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_aeed.ScrgbClr = NewCT_ScRgbColor()
				if _aceae := d.DecodeElement(_aeed.ScrgbClr, &_cdbff); _aceae != nil {
					return _aceae
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_aeed.SrgbClr = NewCT_SRgbColor()
				if _fgbfb := d.DecodeElement(_aeed.SrgbClr, &_cdbff); _fgbfb != nil {
					return _fgbfb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_aeed.HslClr = NewCT_HslColor()
				if _bfdba := d.DecodeElement(_aeed.HslClr, &_cdbff); _bfdba != nil {
					return _bfdba
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_aeed.SysClr = NewCT_SystemColor()
				if _acgbg := d.DecodeElement(_aeed.SysClr, &_cdbff); _acgbg != nil {
					return _acgbg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_aeed.SchemeClr = NewCT_SchemeColor()
				if _gdage := d.DecodeElement(_aeed.SchemeClr, &_cdbff); _gdage != nil {
					return _gdage
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_aeed.PrstClr = NewCT_PresetColor()
				if _feca := d.DecodeElement(_aeed.PrstClr, &_cdbff); _feca != nil {
					return _feca
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_PresetShadowEffect\u0020\u0025v", _cdbff.Name)
				if _dbgee := d.Skip(); _dbgee != nil {
					return _dbgee
				}
			}
		case _g.EndElement:
			break _cabdc
		case _g.CharData:
		}
	}
	return nil
}
func (_feebga ST_PresetLineDashVal) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_gcegf := _g.Attr{}
	_gcegf.Name = name
	switch _feebga {
	case ST_PresetLineDashValUnset:
		_gcegf.Value = ""
	case ST_PresetLineDashValSolid:
		_gcegf.Value = "solid"
	case ST_PresetLineDashValDot:
		_gcegf.Value = "dot"
	case ST_PresetLineDashValDash:
		_gcegf.Value = "dash"
	case ST_PresetLineDashValLgDash:
		_gcegf.Value = "lgDash"
	case ST_PresetLineDashValDashDot:
		_gcegf.Value = "dashDot"
	case ST_PresetLineDashValLgDashDot:
		_gcegf.Value = "lgDashDot"
	case ST_PresetLineDashValLgDashDotDot:
		_gcegf.Value = "lgDashDotDot"
	case ST_PresetLineDashValSysDash:
		_gcegf.Value = "sysDash"
	case ST_PresetLineDashValSysDot:
		_gcegf.Value = "sysDot"
	case ST_PresetLineDashValSysDashDot:
		_gcegf.Value = "sysDashDot"
	case ST_PresetLineDashValSysDashDotDot:
		_gcegf.Value = "sysDashDotDot"
	}
	return _gcegf, nil
}

// ValidateWithPath validates the CT_Cell3D and its children, prefixing error messages with path
func (_gbfd *CT_Cell3D) ValidateWithPath(path string) error {
	if _deae := _gbfd.PrstMaterialAttr.ValidateWithPath(path + "\u002fPrstMaterialAttr"); _deae != nil {
		return _deae
	}
	if _ffcb := _gbfd.Bevel.ValidateWithPath(path + "\u002fBevel"); _ffcb != nil {
		return _ffcb
	}
	if _gbfd.LightRig != nil {
		if _dcbg := _gbfd.LightRig.ValidateWithPath(path + "\u002fLightRig"); _dcbg != nil {
			return _dcbg
		}
	}
	if _gbfd.ExtLst != nil {
		if _ebbgc := _gbfd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ebbgc != nil {
			return _ebbgc
		}
	}
	return nil
}

type ST_LightRigType byte

func (_cafbc *CT_WholeE2oFormatting) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_ggdgc:
	for {
		_afgea, _cbefa := d.Token()
		if _cbefa != nil {
			return _cbefa
		}
		switch _afdfdf := _afgea.(type) {
		case _g.StartElement:
			switch _afdfdf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ln"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ln"}:
				_cafbc.Ln = NewCT_LineProperties()
				if _bfabc := d.DecodeElement(_cafbc.Ln, &_afdfdf); _bfabc != nil {
					return _bfabc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectLst"}:
				_cafbc.EffectLst = NewCT_EffectList()
				if _bcbeb := d.DecodeElement(_cafbc.EffectLst, &_afdfdf); _bcbeb != nil {
					return _bcbeb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectDag"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectDag"}:
				_cafbc.EffectDag = NewCT_EffectContainer()
				if _fdefe := d.DecodeElement(_cafbc.EffectDag, &_afdfdf); _fdefe != nil {
					return _fdefe
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_WholeE2oFormatting\u0020\u0025v", _afdfdf.Name)
				if _cdgegf := d.Skip(); _cdgegf != nil {
					return _cdgegf
				}
			}
		case _g.EndElement:
			break _ggdgc
		case _g.CharData:
		}
	}
	return nil
}
func (_egcc *CT_BackgroundFormatting) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fff:
	for {
		_ddge, _gbgd := d.Token()
		if _gbgd != nil {
			return _gbgd
		}
		switch _gca := _ddge.(type) {
		case _g.StartElement:
			switch _gca.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_egcc.NoFill = NewCT_NoFillProperties()
				if _gcce := d.DecodeElement(_egcc.NoFill, &_gca); _gcce != nil {
					return _gcce
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_egcc.SolidFill = NewCT_SolidColorFillProperties()
				if _aabg := d.DecodeElement(_egcc.SolidFill, &_gca); _aabg != nil {
					return _aabg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_egcc.GradFill = NewCT_GradientFillProperties()
				if _afd := d.DecodeElement(_egcc.GradFill, &_gca); _afd != nil {
					return _afd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_egcc.BlipFill = NewCT_BlipFillProperties()
				if _ffdb := d.DecodeElement(_egcc.BlipFill, &_gca); _ffdb != nil {
					return _ffdb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_egcc.PattFill = NewCT_PatternFillProperties()
				if _dedb := d.DecodeElement(_egcc.PattFill, &_gca); _dedb != nil {
					return _dedb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_egcc.GrpFill = NewCT_GroupFillProperties()
				if _cdga := d.DecodeElement(_egcc.GrpFill, &_gca); _cdga != nil {
					return _cdga
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectLst"}:
				_egcc.EffectLst = NewCT_EffectList()
				if _fbdg := d.DecodeElement(_egcc.EffectLst, &_gca); _fbdg != nil {
					return _fbdg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectDag"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectDag"}:
				_egcc.EffectDag = NewCT_EffectContainer()
				if _geb := d.DecodeElement(_egcc.EffectDag, &_gca); _geb != nil {
					return _geb
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_BackgroundFormatting \u0025v", _gca.Name)
				if _accf := d.Skip(); _accf != nil {
					return _accf
				}
			}
		case _g.EndElement:
			break _fff
		case _g.CharData:
		}
	}
	return nil
}
func (_cebdfe ST_PathFillMode) Validate() error { return _cebdfe.ValidateWithPath("") }

type CT_SphereCoords struct {
	LatAttr int32
	LonAttr int32
	RevAttr int32
}

func NewCT_TextBulletSizeFollowText() *CT_TextBulletSizeFollowText {
	_ebbec := &CT_TextBulletSizeFollowText{}
	return _ebbec
}

// ValidateWithPath validates the CT_PresetColor and its children, prefixing error messages with path
func (_ggbdd *CT_PresetColor) ValidateWithPath(path string) error {
	if _ggbdd.ValAttr == ST_PresetColorValUnset {
		return _dcf.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _dfbb := _ggbdd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _dfbb != nil {
		return _dfbb
	}
	for _cggegg, _dbgfg := range _ggbdd.EG_ColorTransform {
		if _ecbbc := _dbgfg.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fEG_ColorTransform\u005b\u0025d\u005d", path, _cggegg)); _ecbbc != nil {
			return _ecbbc
		}
	}
	return nil
}

// Validate validates the CT_StretchInfoProperties and its children
func (_daged *CT_StretchInfoProperties) Validate() error {
	return _daged.ValidateWithPath("CT_StretchInfoProperties")
}

// ValidateWithPath validates the CT_TransformEffect and its children, prefixing error messages with path
func (_aedcd *CT_TransformEffect) ValidateWithPath(path string) error {
	if _aedcd.SxAttr != nil {
		if _aeafc := _aedcd.SxAttr.ValidateWithPath(path + "\u002fSxAttr"); _aeafc != nil {
			return _aeafc
		}
	}
	if _aedcd.SyAttr != nil {
		if _dbea := _aedcd.SyAttr.ValidateWithPath(path + "\u002fSyAttr"); _dbea != nil {
			return _dbea
		}
	}
	if _aedcd.KxAttr != nil {
		if *_aedcd.KxAttr <= -5400000 {
			return _dcf.Errorf("%s\u002fm\u002eKxAttr\u0020must\u0020be \u003e\u0020\u002d5400000 (have\u0020%v\u0029", path, *_aedcd.KxAttr)
		}
		if *_aedcd.KxAttr >= 5400000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eKxAttr\u0020must\u0020be\u0020<\u00205400000\u0020\u0028have\u0020\u0025v\u0029", path, *_aedcd.KxAttr)
		}
	}
	if _aedcd.KyAttr != nil {
		if *_aedcd.KyAttr <= -5400000 {
			return _dcf.Errorf("%s\u002fm\u002eKyAttr\u0020must\u0020be \u003e\u0020\u002d5400000 (have\u0020%v\u0029", path, *_aedcd.KyAttr)
		}
		if *_aedcd.KyAttr >= 5400000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eKyAttr\u0020must\u0020be\u0020<\u00205400000\u0020\u0028have\u0020\u0025v\u0029", path, *_aedcd.KyAttr)
		}
	}
	if _aedcd.TxAttr != nil {
		if _cgabff := _aedcd.TxAttr.ValidateWithPath(path + "\u002fTxAttr"); _cgabff != nil {
			return _cgabff
		}
	}
	if _aedcd.TyAttr != nil {
		if _dddeag := _aedcd.TyAttr.ValidateWithPath(path + "\u002fTyAttr"); _dddeag != nil {
			return _dddeag
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ScRgbColor and its children, prefixing error messages with path
func (_cbfcc *CT_ScRgbColor) ValidateWithPath(path string) error {
	if _ggbdc := _cbfcc.RAttr.ValidateWithPath(path + "\u002fRAttr"); _ggbdc != nil {
		return _ggbdc
	}
	if _dfdca := _cbfcc.GAttr.ValidateWithPath(path + "\u002fGAttr"); _dfdca != nil {
		return _dfdca
	}
	if _edca := _cbfcc.BAttr.ValidateWithPath(path + "\u002fBAttr"); _edca != nil {
		return _edca
	}
	for _ffbca, _gggge := range _cbfcc.EG_ColorTransform {
		if _gbecg := _gggge.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fEG_ColorTransform\u005b\u0025d\u005d", path, _ffbca)); _gbecg != nil {
			return _gbecg
		}
	}
	return nil
}
func NewCT_Ratio() *CT_Ratio { _feegc := &CT_Ratio{}; return _feegc }

// ValidateWithPath validates the CT_VideoFile and its children, prefixing error messages with path
func (_gabef *CT_VideoFile) ValidateWithPath(path string) error {
	if _gabef.ExtLst != nil {
		if _ccbdb := _gabef.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ccbdb != nil {
			return _ccbdb
		}
	}
	return nil
}
func (_edcce *CT_Ratio) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fffeb := range start.Attr {
		if _fffeb.Name.Local == "n" {
			_ggdab, _gddgf := _e.ParseInt(_fffeb.Value, 10, 64)
			if _gddgf != nil {
				return _gddgf
			}
			_edcce.NAttr = _ggdab
			continue
		}
		if _fffeb.Name.Local == "d" {
			_eebeg, _feaaa := _e.ParseInt(_fffeb.Value, 10, 64)
			if _feaaa != nil {
				return _feaaa
			}
			_edcce.DAttr = _eebeg
			continue
		}
	}
	for {
		_ggffb, _ecbcb := d.Token()
		if _ecbcb != nil {
			return _dcf.Errorf("parsing\u0020CT_Ratio: \u0025s", _ecbcb)
		}
		if _fgagc, _gcedf := _ggffb.(_g.EndElement); _gcedf && _fgagc.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_CustomColorList and its children
func (_dcba *CT_CustomColorList) Validate() error {
	return _dcba.ValidateWithPath("CT_CustomColorList")
}
func (_gecga *CT_TintEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _gecga.HueAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "hue"}, Value: _dcf.Sprintf("\u0025v", *_gecga.HueAttr)})
	}
	if _gecga.AmtAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "amt"}, Value: _dcf.Sprintf("\u0025v", *_gecga.AmtAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_LineJoinRound struct{}

func (_bebd *CT_ConnectorLocking) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ddba := range start.Attr {
		if _ddba.Name.Local == "noGrp" {
			_dbdba, _bgff := _e.ParseBool(_ddba.Value)
			if _bgff != nil {
				return _bgff
			}
			_bebd.NoGrpAttr = &_dbdba
			continue
		}
		if _ddba.Name.Local == "noSelect" {
			_bcaa, _gdcd := _e.ParseBool(_ddba.Value)
			if _gdcd != nil {
				return _gdcd
			}
			_bebd.NoSelectAttr = &_bcaa
			continue
		}
		if _ddba.Name.Local == "noRot" {
			_affg, _cfef := _e.ParseBool(_ddba.Value)
			if _cfef != nil {
				return _cfef
			}
			_bebd.NoRotAttr = &_affg
			continue
		}
		if _ddba.Name.Local == "noChangeAspect" {
			_afgb, _eegb := _e.ParseBool(_ddba.Value)
			if _eegb != nil {
				return _eegb
			}
			_bebd.NoChangeAspectAttr = &_afgb
			continue
		}
		if _ddba.Name.Local == "noMove" {
			_gdec, _adac := _e.ParseBool(_ddba.Value)
			if _adac != nil {
				return _adac
			}
			_bebd.NoMoveAttr = &_gdec
			continue
		}
		if _ddba.Name.Local == "noResize" {
			_egffa, _dfac := _e.ParseBool(_ddba.Value)
			if _dfac != nil {
				return _dfac
			}
			_bebd.NoResizeAttr = &_egffa
			continue
		}
		if _ddba.Name.Local == "noEditPoints" {
			_cadee, _cdaa := _e.ParseBool(_ddba.Value)
			if _cdaa != nil {
				return _cdaa
			}
			_bebd.NoEditPointsAttr = &_cadee
			continue
		}
		if _ddba.Name.Local == "noAdjustHandles" {
			_cgeg, _ffaa := _e.ParseBool(_ddba.Value)
			if _ffaa != nil {
				return _ffaa
			}
			_bebd.NoAdjustHandlesAttr = &_cgeg
			continue
		}
		if _ddba.Name.Local == "noChangeArrowheads" {
			_fedb, _eacc := _e.ParseBool(_ddba.Value)
			if _eacc != nil {
				return _eacc
			}
			_bebd.NoChangeArrowheadsAttr = &_fedb
			continue
		}
		if _ddba.Name.Local == "noChangeShapeType" {
			_egdgb, _ddcab := _e.ParseBool(_ddba.Value)
			if _ddcab != nil {
				return _ddcab
			}
			_bebd.NoChangeShapeTypeAttr = &_egdgb
			continue
		}
	}
_fbcg:
	for {
		_gbgba, _edfcb := d.Token()
		if _edfcb != nil {
			return _edfcb
		}
		switch _cfgd := _gbgba.(type) {
		case _g.StartElement:
			switch _cfgd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_bebd.ExtLst = NewCT_OfficeArtExtensionList()
				if _fccd := d.DecodeElement(_bebd.ExtLst, &_cfgd); _fccd != nil {
					return _fccd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ConnectorLocking\u0020\u0025v", _cfgd.Name)
				if _ggaea := d.Skip(); _ggaea != nil {
					return _ggaea
				}
			}
		case _g.EndElement:
			break _fbcg
		case _g.CharData:
		}
	}
	return nil
}
func (_aaga *CT_AudioCD) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_aaga.St = NewCT_AudioCDTime()
	_aaga.End = NewCT_AudioCDTime()
_cde:
	for {
		_bbge, _fddf := d.Token()
		if _fddf != nil {
			return _fddf
		}
		switch _eee := _bbge.(type) {
		case _g.StartElement:
			switch _eee.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "st"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "st"}:
				if _ggg := d.DecodeElement(_aaga.St, &_eee); _ggg != nil {
					return _ggg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "end"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "end"}:
				if _cbec := d.DecodeElement(_aaga.End, &_eee); _cbec != nil {
					return _cbec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_aaga.ExtLst = NewCT_OfficeArtExtensionList()
				if _fdab := d.DecodeElement(_aaga.ExtLst, &_eee); _fdab != nil {
					return _fdab
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_AudioCD\u0020\u0025v", _eee.Name)
				if _cbbc := d.Skip(); _cbbc != nil {
					return _cbbc
				}
			}
		case _g.EndElement:
			break _cde
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_ColorSchemeList() *CT_ColorSchemeList { _fcde := &CT_ColorSchemeList{}; return _fcde }

// ValidateWithPath validates the EG_ShadeProperties and its children, prefixing error messages with path
func (_dbbfg *EG_ShadeProperties) ValidateWithPath(path string) error {
	if _dbbfg.Lin != nil {
		if _fagega := _dbbfg.Lin.ValidateWithPath(path + "\u002fLin"); _fagega != nil {
			return _fagega
		}
	}
	if _dbbfg.Path != nil {
		if _ddgfb := _dbbfg.Path.ValidateWithPath(path + "\u002fPath"); _ddgfb != nil {
			return _ddgfb
		}
	}
	return nil
}
func (_bgcbf ST_PresetColorVal) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dcgb := _g.Attr{}
	_dcgb.Name = name
	switch _bgcbf {
	case ST_PresetColorValUnset:
		_dcgb.Value = ""
	case ST_PresetColorValAliceBlue:
		_dcgb.Value = "aliceBlue"
	case ST_PresetColorValAntiqueWhite:
		_dcgb.Value = "antiqueWhite"
	case ST_PresetColorValAqua:
		_dcgb.Value = "aqua"
	case ST_PresetColorValAquamarine:
		_dcgb.Value = "aquamarine"
	case ST_PresetColorValAzure:
		_dcgb.Value = "azure"
	case ST_PresetColorValBeige:
		_dcgb.Value = "beige"
	case ST_PresetColorValBisque:
		_dcgb.Value = "bisque"
	case ST_PresetColorValBlack:
		_dcgb.Value = "black"
	case ST_PresetColorValBlanchedAlmond:
		_dcgb.Value = "blanchedAlmond"
	case ST_PresetColorValBlue:
		_dcgb.Value = "blue"
	case ST_PresetColorValBlueViolet:
		_dcgb.Value = "blueViolet"
	case ST_PresetColorValBrown:
		_dcgb.Value = "brown"
	case ST_PresetColorValBurlyWood:
		_dcgb.Value = "burlyWood"
	case ST_PresetColorValCadetBlue:
		_dcgb.Value = "cadetBlue"
	case ST_PresetColorValChartreuse:
		_dcgb.Value = "chartreuse"
	case ST_PresetColorValChocolate:
		_dcgb.Value = "chocolate"
	case ST_PresetColorValCoral:
		_dcgb.Value = "coral"
	case ST_PresetColorValCornflowerBlue:
		_dcgb.Value = "cornflowerBlue"
	case ST_PresetColorValCornsilk:
		_dcgb.Value = "cornsilk"
	case ST_PresetColorValCrimson:
		_dcgb.Value = "crimson"
	case ST_PresetColorValCyan:
		_dcgb.Value = "cyan"
	case ST_PresetColorValDarkBlue:
		_dcgb.Value = "darkBlue"
	case ST_PresetColorValDarkCyan:
		_dcgb.Value = "darkCyan"
	case ST_PresetColorValDarkGoldenrod:
		_dcgb.Value = "darkGoldenrod"
	case ST_PresetColorValDarkGray:
		_dcgb.Value = "darkGray"
	case ST_PresetColorValDarkGrey:
		_dcgb.Value = "darkGrey"
	case ST_PresetColorValDarkGreen:
		_dcgb.Value = "darkGreen"
	case ST_PresetColorValDarkKhaki:
		_dcgb.Value = "darkKhaki"
	case ST_PresetColorValDarkMagenta:
		_dcgb.Value = "darkMagenta"
	case ST_PresetColorValDarkOliveGreen:
		_dcgb.Value = "darkOliveGreen"
	case ST_PresetColorValDarkOrange:
		_dcgb.Value = "darkOrange"
	case ST_PresetColorValDarkOrchid:
		_dcgb.Value = "darkOrchid"
	case ST_PresetColorValDarkRed:
		_dcgb.Value = "darkRed"
	case ST_PresetColorValDarkSalmon:
		_dcgb.Value = "darkSalmon"
	case ST_PresetColorValDarkSeaGreen:
		_dcgb.Value = "darkSeaGreen"
	case ST_PresetColorValDarkSlateBlue:
		_dcgb.Value = "darkSlateBlue"
	case ST_PresetColorValDarkSlateGray:
		_dcgb.Value = "darkSlateGray"
	case ST_PresetColorValDarkSlateGrey:
		_dcgb.Value = "darkSlateGrey"
	case ST_PresetColorValDarkTurquoise:
		_dcgb.Value = "darkTurquoise"
	case ST_PresetColorValDarkViolet:
		_dcgb.Value = "darkViolet"
	case ST_PresetColorValDkBlue:
		_dcgb.Value = "dkBlue"
	case ST_PresetColorValDkCyan:
		_dcgb.Value = "dkCyan"
	case ST_PresetColorValDkGoldenrod:
		_dcgb.Value = "dkGoldenrod"
	case ST_PresetColorValDkGray:
		_dcgb.Value = "dkGray"
	case ST_PresetColorValDkGrey:
		_dcgb.Value = "dkGrey"
	case ST_PresetColorValDkGreen:
		_dcgb.Value = "dkGreen"
	case ST_PresetColorValDkKhaki:
		_dcgb.Value = "dkKhaki"
	case ST_PresetColorValDkMagenta:
		_dcgb.Value = "dkMagenta"
	case ST_PresetColorValDkOliveGreen:
		_dcgb.Value = "dkOliveGreen"
	case ST_PresetColorValDkOrange:
		_dcgb.Value = "dkOrange"
	case ST_PresetColorValDkOrchid:
		_dcgb.Value = "dkOrchid"
	case ST_PresetColorValDkRed:
		_dcgb.Value = "dkRed"
	case ST_PresetColorValDkSalmon:
		_dcgb.Value = "dkSalmon"
	case ST_PresetColorValDkSeaGreen:
		_dcgb.Value = "dkSeaGreen"
	case ST_PresetColorValDkSlateBlue:
		_dcgb.Value = "dkSlateBlue"
	case ST_PresetColorValDkSlateGray:
		_dcgb.Value = "dkSlateGray"
	case ST_PresetColorValDkSlateGrey:
		_dcgb.Value = "dkSlateGrey"
	case ST_PresetColorValDkTurquoise:
		_dcgb.Value = "dkTurquoise"
	case ST_PresetColorValDkViolet:
		_dcgb.Value = "dkViolet"
	case ST_PresetColorValDeepPink:
		_dcgb.Value = "deepPink"
	case ST_PresetColorValDeepSkyBlue:
		_dcgb.Value = "deepSkyBlue"
	case ST_PresetColorValDimGray:
		_dcgb.Value = "dimGray"
	case ST_PresetColorValDimGrey:
		_dcgb.Value = "dimGrey"
	case ST_PresetColorValDodgerBlue:
		_dcgb.Value = "dodgerBlue"
	case ST_PresetColorValFirebrick:
		_dcgb.Value = "firebrick"
	case ST_PresetColorValFloralWhite:
		_dcgb.Value = "floralWhite"
	case ST_PresetColorValForestGreen:
		_dcgb.Value = "forestGreen"
	case ST_PresetColorValFuchsia:
		_dcgb.Value = "fuchsia"
	case ST_PresetColorValGainsboro:
		_dcgb.Value = "gainsboro"
	case ST_PresetColorValGhostWhite:
		_dcgb.Value = "ghostWhite"
	case ST_PresetColorValGold:
		_dcgb.Value = "gold"
	case ST_PresetColorValGoldenrod:
		_dcgb.Value = "goldenrod"
	case ST_PresetColorValGray:
		_dcgb.Value = "gray"
	case ST_PresetColorValGrey:
		_dcgb.Value = "grey"
	case ST_PresetColorValGreen:
		_dcgb.Value = "green"
	case ST_PresetColorValGreenYellow:
		_dcgb.Value = "greenYellow"
	case ST_PresetColorValHoneydew:
		_dcgb.Value = "honeydew"
	case ST_PresetColorValHotPink:
		_dcgb.Value = "hotPink"
	case ST_PresetColorValIndianRed:
		_dcgb.Value = "indianRed"
	case ST_PresetColorValIndigo:
		_dcgb.Value = "indigo"
	case ST_PresetColorValIvory:
		_dcgb.Value = "ivory"
	case ST_PresetColorValKhaki:
		_dcgb.Value = "khaki"
	case ST_PresetColorValLavender:
		_dcgb.Value = "lavender"
	case ST_PresetColorValLavenderBlush:
		_dcgb.Value = "lavenderBlush"
	case ST_PresetColorValLawnGreen:
		_dcgb.Value = "lawnGreen"
	case ST_PresetColorValLemonChiffon:
		_dcgb.Value = "lemonChiffon"
	case ST_PresetColorValLightBlue:
		_dcgb.Value = "lightBlue"
	case ST_PresetColorValLightCoral:
		_dcgb.Value = "lightCoral"
	case ST_PresetColorValLightCyan:
		_dcgb.Value = "lightCyan"
	case ST_PresetColorValLightGoldenrodYellow:
		_dcgb.Value = "lightGoldenrodYellow"
	case ST_PresetColorValLightGray:
		_dcgb.Value = "lightGray"
	case ST_PresetColorValLightGrey:
		_dcgb.Value = "lightGrey"
	case ST_PresetColorValLightGreen:
		_dcgb.Value = "lightGreen"
	case ST_PresetColorValLightPink:
		_dcgb.Value = "lightPink"
	case ST_PresetColorValLightSalmon:
		_dcgb.Value = "lightSalmon"
	case ST_PresetColorValLightSeaGreen:
		_dcgb.Value = "lightSeaGreen"
	case ST_PresetColorValLightSkyBlue:
		_dcgb.Value = "lightSkyBlue"
	case ST_PresetColorValLightSlateGray:
		_dcgb.Value = "lightSlateGray"
	case ST_PresetColorValLightSlateGrey:
		_dcgb.Value = "lightSlateGrey"
	case ST_PresetColorValLightSteelBlue:
		_dcgb.Value = "lightSteelBlue"
	case ST_PresetColorValLightYellow:
		_dcgb.Value = "lightYellow"
	case ST_PresetColorValLtBlue:
		_dcgb.Value = "ltBlue"
	case ST_PresetColorValLtCoral:
		_dcgb.Value = "ltCoral"
	case ST_PresetColorValLtCyan:
		_dcgb.Value = "ltCyan"
	case ST_PresetColorValLtGoldenrodYellow:
		_dcgb.Value = "ltGoldenrodYellow"
	case ST_PresetColorValLtGray:
		_dcgb.Value = "ltGray"
	case ST_PresetColorValLtGrey:
		_dcgb.Value = "ltGrey"
	case ST_PresetColorValLtGreen:
		_dcgb.Value = "ltGreen"
	case ST_PresetColorValLtPink:
		_dcgb.Value = "ltPink"
	case ST_PresetColorValLtSalmon:
		_dcgb.Value = "ltSalmon"
	case ST_PresetColorValLtSeaGreen:
		_dcgb.Value = "ltSeaGreen"
	case ST_PresetColorValLtSkyBlue:
		_dcgb.Value = "ltSkyBlue"
	case ST_PresetColorValLtSlateGray:
		_dcgb.Value = "ltSlateGray"
	case ST_PresetColorValLtSlateGrey:
		_dcgb.Value = "ltSlateGrey"
	case ST_PresetColorValLtSteelBlue:
		_dcgb.Value = "ltSteelBlue"
	case ST_PresetColorValLtYellow:
		_dcgb.Value = "ltYellow"
	case ST_PresetColorValLime:
		_dcgb.Value = "lime"
	case ST_PresetColorValLimeGreen:
		_dcgb.Value = "limeGreen"
	case ST_PresetColorValLinen:
		_dcgb.Value = "linen"
	case ST_PresetColorValMagenta:
		_dcgb.Value = "magenta"
	case ST_PresetColorValMaroon:
		_dcgb.Value = "maroon"
	case ST_PresetColorValMedAquamarine:
		_dcgb.Value = "medAquamarine"
	case ST_PresetColorValMedBlue:
		_dcgb.Value = "medBlue"
	case ST_PresetColorValMedOrchid:
		_dcgb.Value = "medOrchid"
	case ST_PresetColorValMedPurple:
		_dcgb.Value = "medPurple"
	case ST_PresetColorValMedSeaGreen:
		_dcgb.Value = "medSeaGreen"
	case ST_PresetColorValMedSlateBlue:
		_dcgb.Value = "medSlateBlue"
	case ST_PresetColorValMedSpringGreen:
		_dcgb.Value = "medSpringGreen"
	case ST_PresetColorValMedTurquoise:
		_dcgb.Value = "medTurquoise"
	case ST_PresetColorValMedVioletRed:
		_dcgb.Value = "medVioletRed"
	case ST_PresetColorValMediumAquamarine:
		_dcgb.Value = "mediumAquamarine"
	case ST_PresetColorValMediumBlue:
		_dcgb.Value = "mediumBlue"
	case ST_PresetColorValMediumOrchid:
		_dcgb.Value = "mediumOrchid"
	case ST_PresetColorValMediumPurple:
		_dcgb.Value = "mediumPurple"
	case ST_PresetColorValMediumSeaGreen:
		_dcgb.Value = "mediumSeaGreen"
	case ST_PresetColorValMediumSlateBlue:
		_dcgb.Value = "mediumSlateBlue"
	case ST_PresetColorValMediumSpringGreen:
		_dcgb.Value = "mediumSpringGreen"
	case ST_PresetColorValMediumTurquoise:
		_dcgb.Value = "mediumTurquoise"
	case ST_PresetColorValMediumVioletRed:
		_dcgb.Value = "mediumVioletRed"
	case ST_PresetColorValMidnightBlue:
		_dcgb.Value = "midnightBlue"
	case ST_PresetColorValMintCream:
		_dcgb.Value = "mintCream"
	case ST_PresetColorValMistyRose:
		_dcgb.Value = "mistyRose"
	case ST_PresetColorValMoccasin:
		_dcgb.Value = "moccasin"
	case ST_PresetColorValNavajoWhite:
		_dcgb.Value = "navajoWhite"
	case ST_PresetColorValNavy:
		_dcgb.Value = "navy"
	case ST_PresetColorValOldLace:
		_dcgb.Value = "oldLace"
	case ST_PresetColorValOlive:
		_dcgb.Value = "olive"
	case ST_PresetColorValOliveDrab:
		_dcgb.Value = "oliveDrab"
	case ST_PresetColorValOrange:
		_dcgb.Value = "orange"
	case ST_PresetColorValOrangeRed:
		_dcgb.Value = "orangeRed"
	case ST_PresetColorValOrchid:
		_dcgb.Value = "orchid"
	case ST_PresetColorValPaleGoldenrod:
		_dcgb.Value = "paleGoldenrod"
	case ST_PresetColorValPaleGreen:
		_dcgb.Value = "paleGreen"
	case ST_PresetColorValPaleTurquoise:
		_dcgb.Value = "paleTurquoise"
	case ST_PresetColorValPaleVioletRed:
		_dcgb.Value = "paleVioletRed"
	case ST_PresetColorValPapayaWhip:
		_dcgb.Value = "papayaWhip"
	case ST_PresetColorValPeachPuff:
		_dcgb.Value = "peachPuff"
	case ST_PresetColorValPeru:
		_dcgb.Value = "peru"
	case ST_PresetColorValPink:
		_dcgb.Value = "pink"
	case ST_PresetColorValPlum:
		_dcgb.Value = "plum"
	case ST_PresetColorValPowderBlue:
		_dcgb.Value = "powderBlue"
	case ST_PresetColorValPurple:
		_dcgb.Value = "purple"
	case ST_PresetColorValRed:
		_dcgb.Value = "red"
	case ST_PresetColorValRosyBrown:
		_dcgb.Value = "rosyBrown"
	case ST_PresetColorValRoyalBlue:
		_dcgb.Value = "royalBlue"
	case ST_PresetColorValSaddleBrown:
		_dcgb.Value = "saddleBrown"
	case ST_PresetColorValSalmon:
		_dcgb.Value = "salmon"
	case ST_PresetColorValSandyBrown:
		_dcgb.Value = "sandyBrown"
	case ST_PresetColorValSeaGreen:
		_dcgb.Value = "seaGreen"
	case ST_PresetColorValSeaShell:
		_dcgb.Value = "seaShell"
	case ST_PresetColorValSienna:
		_dcgb.Value = "sienna"
	case ST_PresetColorValSilver:
		_dcgb.Value = "silver"
	case ST_PresetColorValSkyBlue:
		_dcgb.Value = "skyBlue"
	case ST_PresetColorValSlateBlue:
		_dcgb.Value = "slateBlue"
	case ST_PresetColorValSlateGray:
		_dcgb.Value = "slateGray"
	case ST_PresetColorValSlateGrey:
		_dcgb.Value = "slateGrey"
	case ST_PresetColorValSnow:
		_dcgb.Value = "snow"
	case ST_PresetColorValSpringGreen:
		_dcgb.Value = "springGreen"
	case ST_PresetColorValSteelBlue:
		_dcgb.Value = "steelBlue"
	case ST_PresetColorValTan:
		_dcgb.Value = "tan"
	case ST_PresetColorValTeal:
		_dcgb.Value = "teal"
	case ST_PresetColorValThistle:
		_dcgb.Value = "thistle"
	case ST_PresetColorValTomato:
		_dcgb.Value = "tomato"
	case ST_PresetColorValTurquoise:
		_dcgb.Value = "turquoise"
	case ST_PresetColorValViolet:
		_dcgb.Value = "violet"
	case ST_PresetColorValWheat:
		_dcgb.Value = "wheat"
	case ST_PresetColorValWhite:
		_dcgb.Value = "white"
	case ST_PresetColorValWhiteSmoke:
		_dcgb.Value = "whiteSmoke"
	case ST_PresetColorValYellow:
		_dcgb.Value = "yellow"
	case ST_PresetColorValYellowGreen:
		_dcgb.Value = "yellowGreen"
	}
	return _dcgb, nil
}
func (_dbab *CT_AnimationChartElement) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dbab.BldStepAttr = ST_ChartBuildStep(1)
	for _, _gfcb := range start.Attr {
		if _gfcb.Name.Local == "seriesIdx" {
			_gbb, _cdg := _e.ParseInt(_gfcb.Value, 10, 32)
			if _cdg != nil {
				return _cdg
			}
			_fbe := int32(_gbb)
			_dbab.SeriesIdxAttr = &_fbe
			continue
		}
		if _gfcb.Name.Local == "categoryIdx" {
			_gaa, _beb := _e.ParseInt(_gfcb.Value, 10, 32)
			if _beb != nil {
				return _beb
			}
			_bcgd := int32(_gaa)
			_dbab.CategoryIdxAttr = &_bcgd
			continue
		}
		if _gfcb.Name.Local == "bldStep" {
			_dbab.BldStepAttr.UnmarshalXMLAttr(_gfcb)
			continue
		}
	}
	for {
		_gde, _ecge := d.Token()
		if _ecge != nil {
			return _dcf.Errorf("parsing CT_AnimationChartElement:\u0020%s", _ecge)
		}
		if _fdd, _baff := _gde.(_g.EndElement); _baff && _fdd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gbfbd *ST_PathShadeType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_eabgcd, _ceeee := d.Token()
	if _ceeee != nil {
		return _ceeee
	}
	if _gdfdg, _daebec := _eabgcd.(_g.EndElement); _daebec && _gdfdg.Name == start.Name {
		*_gbfbd = 1
		return nil
	}
	if _eabaa, _bdcaba := _eabgcd.(_g.CharData); !_bdcaba {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eabgcd)
	} else {
		switch string(_eabaa) {
		case "":
			*_gbfbd = 0
		case "shape":
			*_gbfbd = 1
		case "circle":
			*_gbfbd = 2
		case "rect":
			*_gbfbd = 3
		}
	}
	_eabgcd, _ceeee = d.Token()
	if _ceeee != nil {
		return _ceeee
	}
	if _faebe, _afce := _eabgcd.(_g.EndElement); _afce && _faebe.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eabgcd)
}

// ValidateWithPath validates the CT_RelativeOffsetEffect and its children, prefixing error messages with path
func (_gfga *CT_RelativeOffsetEffect) ValidateWithPath(path string) error {
	if _gfga.TxAttr != nil {
		if _egcbb := _gfga.TxAttr.ValidateWithPath(path + "\u002fTxAttr"); _egcbb != nil {
			return _egcbb
		}
	}
	if _gfga.TyAttr != nil {
		if _abae := _gfga.TyAttr.ValidateWithPath(path + "\u002fTyAttr"); _abae != nil {
			return _abae
		}
	}
	return nil
}
func NewCT_Color() *CT_Color { _ffee := &CT_Color{}; return _ffee }
func (_efddg *CT_TransformEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _efddg.SxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sx"}, Value: _dcf.Sprintf("\u0025v", *_efddg.SxAttr)})
	}
	if _efddg.SyAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sy"}, Value: _dcf.Sprintf("\u0025v", *_efddg.SyAttr)})
	}
	if _efddg.KxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "kx"}, Value: _dcf.Sprintf("\u0025v", *_efddg.KxAttr)})
	}
	if _efddg.KyAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "ky"}, Value: _dcf.Sprintf("\u0025v", *_efddg.KyAttr)})
	}
	if _efddg.TxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "tx"}, Value: _dcf.Sprintf("\u0025v", *_efddg.TxAttr)})
	}
	if _efddg.TyAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "ty"}, Value: _dcf.Sprintf("\u0025v", *_efddg.TyAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_TableCol() *CT_TableCol { _dggdg := &CT_TableCol{}; return _dggdg }
func NewCT_TextBody() *CT_TextBody {
	_egbbf := &CT_TextBody{}
	_egbbf.BodyPr = NewCT_TextBodyProperties()
	return _egbbf
}

// ValidateWithPath validates the CT_BlipChoice and its children, prefixing error messages with path
func (_ccgf *CT_BlipChoice) ValidateWithPath(path string) error {
	for _deb, _bgbga := range _ccgf.AlphaBiLevel {
		if _gbee := _bgbga.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fAlphaBiLevel\u005b\u0025d\u005d", path, _deb)); _gbee != nil {
			return _gbee
		}
	}
	for _cdgf, _cfca := range _ccgf.AlphaCeiling {
		if _ggfcc := _cfca.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fAlphaCeiling\u005b\u0025d\u005d", path, _cdgf)); _ggfcc != nil {
			return _ggfcc
		}
	}
	for _eadf, _gcbad := range _ccgf.AlphaFloor {
		if _bccg := _gcbad.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fAlphaFloor\u005b\u0025d\u005d", path, _eadf)); _bccg != nil {
			return _bccg
		}
	}
	for _ade, _geeeg := range _ccgf.AlphaInv {
		if _dggdf := _geeeg.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fAlphaInv\u005b\u0025d\u005d", path, _ade)); _dggdf != nil {
			return _dggdf
		}
	}
	for _geae, _ffbe := range _ccgf.AlphaMod {
		if _dbbd := _ffbe.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fAlphaMod\u005b\u0025d\u005d", path, _geae)); _dbbd != nil {
			return _dbbd
		}
	}
	for _baed, _abad := range _ccgf.AlphaModFix {
		if _aagad := _abad.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fAlphaModFix\u005b\u0025d\u005d", path, _baed)); _aagad != nil {
			return _aagad
		}
	}
	for _gfcf, _ffbg := range _ccgf.AlphaRepl {
		if _cdfe := _ffbg.ValidateWithPath(_dcf.Sprintf("\u0025s/AlphaRepl\u005b\u0025d\u005d", path, _gfcf)); _cdfe != nil {
			return _cdfe
		}
	}
	for _bca, _fbaff := range _ccgf.BiLevel {
		if _befg := _fbaff.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fBiLevel\u005b\u0025d\u005d", path, _bca)); _befg != nil {
			return _befg
		}
	}
	for _efaf, _gabc := range _ccgf.Blur {
		if _eeae := _gabc.ValidateWithPath(_dcf.Sprintf("%s\u002fBlur\u005b\u0025d\u005d", path, _efaf)); _eeae != nil {
			return _eeae
		}
	}
	for _aagge, _cdee := range _ccgf.ClrChange {
		if _bdbb := _cdee.ValidateWithPath(_dcf.Sprintf("\u0025s/ClrChange\u005b\u0025d\u005d", path, _aagge)); _bdbb != nil {
			return _bdbb
		}
	}
	for _fbec, _cdgb := range _ccgf.ClrRepl {
		if _ddebc := _cdgb.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fClrRepl\u005b\u0025d\u005d", path, _fbec)); _ddebc != nil {
			return _ddebc
		}
	}
	for _eecf, _gbbe := range _ccgf.Duotone {
		if _ccac := _gbbe.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fDuotone\u005b\u0025d\u005d", path, _eecf)); _ccac != nil {
			return _ccac
		}
	}
	for _ddfdd, _eefb := range _ccgf.FillOverlay {
		if _cfg := _eefb.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fFillOverlay\u005b\u0025d\u005d", path, _ddfdd)); _cfg != nil {
			return _cfg
		}
	}
	for _fead, _gcddc := range _ccgf.Grayscl {
		if _acbf := _gcddc.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fGrayscl\u005b\u0025d\u005d", path, _fead)); _acbf != nil {
			return _acbf
		}
	}
	for _ggfdf, _cdfb := range _ccgf.Hsl {
		if _eed := _cdfb.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fHsl\u005b\u0025d\u005d", path, _ggfdf)); _eed != nil {
			return _eed
		}
	}
	for _dgb, _ccff := range _ccgf.Lum {
		if _gcfd := _ccff.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fLum\u005b\u0025d\u005d", path, _dgb)); _gcfd != nil {
			return _gcfd
		}
	}
	for _fee, _fffc := range _ccgf.Tint {
		if _egge := _fffc.ValidateWithPath(_dcf.Sprintf("%s\u002fTint\u005b\u0025d\u005d", path, _fee)); _egge != nil {
			return _egge
		}
	}
	return nil
}

const (
	ST_AnimationDgmOnlyBuildTypeUnset     ST_AnimationDgmOnlyBuildType = 0
	ST_AnimationDgmOnlyBuildTypeOne       ST_AnimationDgmOnlyBuildType = 1
	ST_AnimationDgmOnlyBuildTypeLvlOne    ST_AnimationDgmOnlyBuildType = 2
	ST_AnimationDgmOnlyBuildTypeLvlAtOnce ST_AnimationDgmOnlyBuildType = 3
)

// ValidateWithPath validates the EG_TextRun and its children, prefixing error messages with path
func (_acabf *EG_TextRun) ValidateWithPath(path string) error {
	if _acabf.R != nil {
		if _beaae := _acabf.R.ValidateWithPath(path + "\u002fR"); _beaae != nil {
			return _beaae
		}
	}
	if _acabf.Br != nil {
		if _eeage := _acabf.Br.ValidateWithPath(path + "\u002fBr"); _eeage != nil {
			return _eeage
		}
	}
	if _acabf.Fld != nil {
		if _eacedc := _acabf.Fld.ValidateWithPath(path + "\u002fFld"); _eacedc != nil {
			return _eacedc
		}
	}
	return nil
}
func (_efbcb *Theme) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "a:theme"
	return _efbcb.CT_OfficeStyleSheet.MarshalXML(e, start)
}
func NewCT_AnimationDgmElement() *CT_AnimationDgmElement {
	_agd := &CT_AnimationDgmElement{}
	return _agd
}

type CT_Path2DMoveTo struct{ Pt *CT_AdjPoint2D }

func (_fbbbe *CT_GvmlPicture) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_cbcf := _g.StartElement{Name: _g.Name{Local: "a:nvPicPr"}}
	e.EncodeElement(_fbbbe.NvPicPr, _cbcf)
	_acdbe := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
	e.EncodeElement(_fbbbe.BlipFill, _acdbe)
	_gaaef := _g.StartElement{Name: _g.Name{Local: "a:spPr"}}
	e.EncodeElement(_fbbbe.SpPr, _gaaef)
	if _fbbbe.Style != nil {
		_cgdc := _g.StartElement{Name: _g.Name{Local: "a:style"}}
		e.EncodeElement(_fbbbe.Style, _cgdc)
	}
	if _fbbbe.ExtLst != nil {
		_baada := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_fbbbe.ExtLst, _baada)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_bdgcf *ST_RectAlignment) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_abfcf, _edccb := d.Token()
	if _edccb != nil {
		return _edccb
	}
	if _gbbda, _bcdegd := _abfcf.(_g.EndElement); _bcdegd && _gbbda.Name == start.Name {
		*_bdgcf = 1
		return nil
	}
	if _adedb, _adbbe := _abfcf.(_g.CharData); !_adbbe {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _abfcf)
	} else {
		switch string(_adedb) {
		case "":
			*_bdgcf = 0
		case "tl":
			*_bdgcf = 1
		case "t":
			*_bdgcf = 2
		case "tr":
			*_bdgcf = 3
		case "l":
			*_bdgcf = 4
		case "ctr":
			*_bdgcf = 5
		case "r":
			*_bdgcf = 6
		case "bl":
			*_bdgcf = 7
		case "b":
			*_bdgcf = 8
		case "br":
			*_bdgcf = 9
		}
	}
	_abfcf, _edccb = d.Token()
	if _edccb != nil {
		return _edccb
	}
	if _eebg, _gbfeac := _abfcf.(_g.EndElement); _gbfeac && _eebg.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _abfcf)
}

type CT_PolarAdjustHandle struct {
	GdRefRAttr   *string
	MinRAttr     *ST_AdjCoordinate
	MaxRAttr     *ST_AdjCoordinate
	GdRefAngAttr *string
	MinAngAttr   *ST_AdjAngle
	MaxAngAttr   *ST_AdjAngle
	Pos          *CT_AdjPoint2D
}

func (_cebd *CT_LineJoinRound) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_aagfc, _cbga := d.Token()
		if _cbga != nil {
			return _dcf.Errorf("parsing\u0020CT_LineJoinRound: \u0025s", _cbga)
		}
		if _bffed, _eaad := _aagfc.(_g.EndElement); _eaad && _bffed.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TableCol and its children, prefixing error messages with path
func (_efefgc *CT_TableCol) ValidateWithPath(path string) error {
	if _gfage := _efefgc.WAttr.ValidateWithPath(path + "\u002fWAttr"); _gfage != nil {
		return _gfage
	}
	if _efefgc.ExtLst != nil {
		if _faagf := _efefgc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _faagf != nil {
			return _faagf
		}
	}
	return nil
}

// ValidateWithPath validates the VideoFile and its children, prefixing error messages with path
func (_cfdab *VideoFile) ValidateWithPath(path string) error {
	if _eggab := _cfdab.CT_VideoFile.ValidateWithPath(path); _eggab != nil {
		return _eggab
	}
	return nil
}
func (_gbdaf ST_LineEndLength) String() string {
	switch _gbdaf {
	case 0:
		return ""
	case 1:
		return "sm"
	case 2:
		return "med"
	case 3:
		return "lg"
	}
	return ""
}
func (_abadfe ST_SystemColorVal) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_babef := _g.Attr{}
	_babef.Name = name
	switch _abadfe {
	case ST_SystemColorValUnset:
		_babef.Value = ""
	case ST_SystemColorValScrollBar:
		_babef.Value = "scrollBar"
	case ST_SystemColorValBackground:
		_babef.Value = "background"
	case ST_SystemColorValActiveCaption:
		_babef.Value = "activeCaption"
	case ST_SystemColorValInactiveCaption:
		_babef.Value = "inactiveCaption"
	case ST_SystemColorValMenu:
		_babef.Value = "menu"
	case ST_SystemColorValWindow:
		_babef.Value = "window"
	case ST_SystemColorValWindowFrame:
		_babef.Value = "windowFrame"
	case ST_SystemColorValMenuText:
		_babef.Value = "menuText"
	case ST_SystemColorValWindowText:
		_babef.Value = "windowText"
	case ST_SystemColorValCaptionText:
		_babef.Value = "captionText"
	case ST_SystemColorValActiveBorder:
		_babef.Value = "activeBorder"
	case ST_SystemColorValInactiveBorder:
		_babef.Value = "inactiveBorder"
	case ST_SystemColorValAppWorkspace:
		_babef.Value = "appWorkspace"
	case ST_SystemColorValHighlight:
		_babef.Value = "highlight"
	case ST_SystemColorValHighlightText:
		_babef.Value = "highlightText"
	case ST_SystemColorValBtnFace:
		_babef.Value = "btnFace"
	case ST_SystemColorValBtnShadow:
		_babef.Value = "btnShadow"
	case ST_SystemColorValGrayText:
		_babef.Value = "grayText"
	case ST_SystemColorValBtnText:
		_babef.Value = "btnText"
	case ST_SystemColorValInactiveCaptionText:
		_babef.Value = "inactiveCaptionText"
	case ST_SystemColorValBtnHighlight:
		_babef.Value = "btnHighlight"
	case ST_SystemColorVal3dDkShadow:
		_babef.Value = "3dDkShadow"
	case ST_SystemColorVal3dLight:
		_babef.Value = "3dLight"
	case ST_SystemColorValInfoText:
		_babef.Value = "infoText"
	case ST_SystemColorValInfoBk:
		_babef.Value = "infoBk"
	case ST_SystemColorValHotLight:
		_babef.Value = "hotLight"
	case ST_SystemColorValGradientActiveCaption:
		_babef.Value = "gradientActiveCaption"
	case ST_SystemColorValGradientInactiveCaption:
		_babef.Value = "gradientInactiveCaption"
	case ST_SystemColorValMenuHighlight:
		_babef.Value = "menuHighlight"
	case ST_SystemColorValMenuBar:
		_babef.Value = "menuBar"
	}
	return _babef, nil
}

type ThemeOverride struct{ CT_BaseStylesOverride }

func (_dccga *CT_TableGrid) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gfbbb:
	for {
		_ebed, _dbebc := d.Token()
		if _dbebc != nil {
			return _dbebc
		}
		switch _efgff := _ebed.(type) {
		case _g.StartElement:
			switch _efgff.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gridCol"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gridCol"}:
				_gbbdc := NewCT_TableCol()
				if _ceae := d.DecodeElement(_gbbdc, &_efgff); _ceae != nil {
					return _ceae
				}
				_dccga.GridCol = append(_dccga.GridCol, _gbbdc)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TableGrid\u0020\u0025v", _efgff.Name)
				if _cagecd := d.Skip(); _cagecd != nil {
					return _cagecd
				}
			}
		case _g.EndElement:
			break _gfbbb
		case _g.CharData:
		}
	}
	return nil
}
func (_gcagdc ST_ShapeType) String() string {
	switch _gcagdc {
	case 0:
		return ""
	case 1:
		return "line"
	case 2:
		return "lineInv"
	case 3:
		return "triangle"
	case 4:
		return "rtTriangle"
	case 5:
		return "rect"
	case 6:
		return "diamond"
	case 7:
		return "parallelogram"
	case 8:
		return "trapezoid"
	case 9:
		return "nonIsoscelesTrapezoid"
	case 10:
		return "pentagon"
	case 11:
		return "hexagon"
	case 12:
		return "heptagon"
	case 13:
		return "octagon"
	case 14:
		return "decagon"
	case 15:
		return "dodecagon"
	case 16:
		return "star4"
	case 17:
		return "star5"
	case 18:
		return "star6"
	case 19:
		return "star7"
	case 20:
		return "star8"
	case 21:
		return "star10"
	case 22:
		return "star12"
	case 23:
		return "star16"
	case 24:
		return "star24"
	case 25:
		return "star32"
	case 26:
		return "roundRect"
	case 27:
		return "round1Rect"
	case 28:
		return "round2SameRect"
	case 29:
		return "round2DiagRect"
	case 30:
		return "snipRoundRect"
	case 31:
		return "snip1Rect"
	case 32:
		return "snip2SameRect"
	case 33:
		return "snip2DiagRect"
	case 34:
		return "plaque"
	case 35:
		return "ellipse"
	case 36:
		return "teardrop"
	case 37:
		return "homePlate"
	case 38:
		return "chevron"
	case 39:
		return "pieWedge"
	case 40:
		return "pie"
	case 41:
		return "blockArc"
	case 42:
		return "donut"
	case 43:
		return "noSmoking"
	case 44:
		return "rightArrow"
	case 45:
		return "leftArrow"
	case 46:
		return "upArrow"
	case 47:
		return "downArrow"
	case 48:
		return "stripedRightArrow"
	case 49:
		return "notchedRightArrow"
	case 50:
		return "bentUpArrow"
	case 51:
		return "leftRightArrow"
	case 52:
		return "upDownArrow"
	case 53:
		return "leftUpArrow"
	case 54:
		return "leftRightUpArrow"
	case 55:
		return "quadArrow"
	case 56:
		return "leftArrowCallout"
	case 57:
		return "rightArrowCallout"
	case 58:
		return "upArrowCallout"
	case 59:
		return "downArrowCallout"
	case 60:
		return "leftRightArrowCallout"
	case 61:
		return "upDownArrowCallout"
	case 62:
		return "quadArrowCallout"
	case 63:
		return "bentArrow"
	case 64:
		return "uturnArrow"
	case 65:
		return "circularArrow"
	case 66:
		return "leftCircularArrow"
	case 67:
		return "leftRightCircularArrow"
	case 68:
		return "curvedRightArrow"
	case 69:
		return "curvedLeftArrow"
	case 70:
		return "curvedUpArrow"
	case 71:
		return "curvedDownArrow"
	case 72:
		return "swooshArrow"
	case 73:
		return "cube"
	case 74:
		return "can"
	case 75:
		return "lightningBolt"
	case 76:
		return "heart"
	case 77:
		return "sun"
	case 78:
		return "moon"
	case 79:
		return "smileyFace"
	case 80:
		return "irregularSeal1"
	case 81:
		return "irregularSeal2"
	case 82:
		return "foldedCorner"
	case 83:
		return "bevel"
	case 84:
		return "frame"
	case 85:
		return "halfFrame"
	case 86:
		return "corner"
	case 87:
		return "diagStripe"
	case 88:
		return "chord"
	case 89:
		return "arc"
	case 90:
		return "leftBracket"
	case 91:
		return "rightBracket"
	case 92:
		return "leftBrace"
	case 93:
		return "rightBrace"
	case 94:
		return "bracketPair"
	case 95:
		return "bracePair"
	case 96:
		return "straightConnector1"
	case 97:
		return "bentConnector2"
	case 98:
		return "bentConnector3"
	case 99:
		return "bentConnector4"
	case 100:
		return "bentConnector5"
	case 101:
		return "curvedConnector2"
	case 102:
		return "curvedConnector3"
	case 103:
		return "curvedConnector4"
	case 104:
		return "curvedConnector5"
	case 105:
		return "callout1"
	case 106:
		return "callout2"
	case 107:
		return "callout3"
	case 108:
		return "accentCallout1"
	case 109:
		return "accentCallout2"
	case 110:
		return "accentCallout3"
	case 111:
		return "borderCallout1"
	case 112:
		return "borderCallout2"
	case 113:
		return "borderCallout3"
	case 114:
		return "accentBorderCallout1"
	case 115:
		return "accentBorderCallout2"
	case 116:
		return "accentBorderCallout3"
	case 117:
		return "wedgeRectCallout"
	case 118:
		return "wedgeRoundRectCallout"
	case 119:
		return "wedgeEllipseCallout"
	case 120:
		return "cloudCallout"
	case 121:
		return "cloud"
	case 122:
		return "ribbon"
	case 123:
		return "ribbon2"
	case 124:
		return "ellipseRibbon"
	case 125:
		return "ellipseRibbon2"
	case 126:
		return "leftRightRibbon"
	case 127:
		return "verticalScroll"
	case 128:
		return "horizontalScroll"
	case 129:
		return "wave"
	case 130:
		return "doubleWave"
	case 131:
		return "plus"
	case 132:
		return "flowChartProcess"
	case 133:
		return "flowChartDecision"
	case 134:
		return "flowChartInputOutput"
	case 135:
		return "flowChartPredefinedProcess"
	case 136:
		return "flowChartInternalStorage"
	case 137:
		return "flowChartDocument"
	case 138:
		return "flowChartMultidocument"
	case 139:
		return "flowChartTerminator"
	case 140:
		return "flowChartPreparation"
	case 141:
		return "flowChartManualInput"
	case 142:
		return "flowChartManualOperation"
	case 143:
		return "flowChartConnector"
	case 144:
		return "flowChartPunchedCard"
	case 145:
		return "flowChartPunchedTape"
	case 146:
		return "flowChartSummingJunction"
	case 147:
		return "flowChartOr"
	case 148:
		return "flowChartCollate"
	case 149:
		return "flowChartSort"
	case 150:
		return "flowChartExtract"
	case 151:
		return "flowChartMerge"
	case 152:
		return "flowChartOfflineStorage"
	case 153:
		return "flowChartOnlineStorage"
	case 154:
		return "flowChartMagneticTape"
	case 155:
		return "flowChartMagneticDisk"
	case 156:
		return "flowChartMagneticDrum"
	case 157:
		return "flowChartDisplay"
	case 158:
		return "flowChartDelay"
	case 159:
		return "flowChartAlternateProcess"
	case 160:
		return "flowChartOffpageConnector"
	case 161:
		return "actionButtonBlank"
	case 162:
		return "actionButtonHome"
	case 163:
		return "actionButtonHelp"
	case 164:
		return "actionButtonInformation"
	case 165:
		return "actionButtonForwardNext"
	case 166:
		return "actionButtonBackPrevious"
	case 167:
		return "actionButtonEnd"
	case 168:
		return "actionButtonBeginning"
	case 169:
		return "actionButtonReturn"
	case 170:
		return "actionButtonDocument"
	case 171:
		return "actionButtonSound"
	case 172:
		return "actionButtonMovie"
	case 173:
		return "gear6"
	case 174:
		return "gear9"
	case 175:
		return "funnel"
	case 176:
		return "mathPlus"
	case 177:
		return "mathMinus"
	case 178:
		return "mathMultiply"
	case 179:
		return "mathDivide"
	case 180:
		return "mathEqual"
	case 181:
		return "mathNotEqual"
	case 182:
		return "cornerTabs"
	case 183:
		return "squareTabs"
	case 184:
		return "plaqueTabs"
	case 185:
		return "chartX"
	case 186:
		return "chartStar"
	case 187:
		return "chartPlus"
	}
	return ""
}
func (_baafe *CT_TextBulletColorFollowText) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_fcggg, _ggade := d.Token()
		if _ggade != nil {
			return _dcf.Errorf("parsing\u0020CT_TextBulletColorFollowText: \u0025s", _ggade)
		}
		if _egfce, _gfacb := _fcggg.(_g.EndElement); _gfacb && _egfce.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cgdcf *CT_StyleMatrix) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cgdcf.FillStyleLst = NewCT_FillStyleList()
	_cgdcf.LnStyleLst = NewCT_LineStyleList()
	_cgdcf.EffectStyleLst = NewCT_EffectStyleList()
	_cgdcf.BgFillStyleLst = NewCT_BackgroundFillStyleList()
	for _, _gaccc := range start.Attr {
		if _gaccc.Name.Local == "name" {
			_afege, _cadec := _gaccc.Value, error(nil)
			if _cadec != nil {
				return _cadec
			}
			_cgdcf.NameAttr = &_afege
			continue
		}
	}
_baagg:
	for {
		_gafeg, _bdadd := d.Token()
		if _bdadd != nil {
			return _bdadd
		}
		switch _afaca := _gafeg.(type) {
		case _g.StartElement:
			switch _afaca.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillStyleLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillStyleLst"}:
				if _dbfgd := d.DecodeElement(_cgdcf.FillStyleLst, &_afaca); _dbfgd != nil {
					return _dbfgd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnStyleLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnStyleLst"}:
				if _ccbab := d.DecodeElement(_cgdcf.LnStyleLst, &_afaca); _ccbab != nil {
					return _ccbab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectStyleLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectStyleLst"}:
				if _dcffg := d.DecodeElement(_cgdcf.EffectStyleLst, &_afaca); _dcffg != nil {
					return _dcffg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bgFillStyleLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bgFillStyleLst"}:
				if _facge := d.DecodeElement(_cgdcf.BgFillStyleLst, &_afaca); _facge != nil {
					return _facge
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_StyleMatrix\u0020\u0025v", _afaca.Name)
				if _gbdae := d.Skip(); _gbdae != nil {
					return _gbdae
				}
			}
		case _g.EndElement:
			break _baagg
		case _g.CharData:
		}
	}
	return nil
}
func (_egfg *EG_ThemeableFontStyles) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_eefce:
	for {
		_gbgedd, _adbea := d.Token()
		if _adbea != nil {
			return _adbea
		}
		switch _fbgae := _gbgedd.(type) {
		case _g.StartElement:
			switch _fbgae.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "font"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "font"}:
				_egfg.Font = NewCT_FontCollection()
				if _ddeea := d.DecodeElement(_egfg.Font, &_fbgae); _ddeea != nil {
					return _ddeea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fontRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fontRef"}:
				_egfg.FontRef = NewCT_FontReference()
				if _fedgd := d.DecodeElement(_egfg.FontRef, &_fbgae); _fedgd != nil {
					return _fedgd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_ThemeableFontStyles\u0020\u0025v", _fbgae.Name)
				if _gbgegc := d.Skip(); _gbgegc != nil {
					return _gbgegc
				}
			}
		case _g.EndElement:
			break _eefce
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_TextTabStopList() *CT_TextTabStopList { _bcfbfe := &CT_TextTabStopList{}; return _bcfbfe }

// ValidateWithPath validates the CT_GvmlConnectorNonVisual and its children, prefixing error messages with path
func (_aaebc *CT_GvmlConnectorNonVisual) ValidateWithPath(path string) error {
	if _geegc := _aaebc.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _geegc != nil {
		return _geegc
	}
	if _deaag := _aaebc.CNvCxnSpPr.ValidateWithPath(path + "/CNvCxnSpPr"); _deaag != nil {
		return _deaag
	}
	return nil
}

type CT_ClipboardStyleSheet struct {
	ThemeElements *CT_BaseStyles
	ClrMap        *CT_ColorMapping
}

func (_efff *CT_GvmlConnectorNonVisual) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_efff.CNvPr = NewCT_NonVisualDrawingProps()
	_efff.CNvCxnSpPr = NewCT_NonVisualConnectorProperties()
_dfde:
	for {
		_eceeg, _abcad := d.Token()
		if _abcad != nil {
			return _abcad
		}
		switch _dfcae := _eceeg.(type) {
		case _g.StartElement:
			switch _dfcae.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cNvPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cNvPr"}:
				if _bdbfg := d.DecodeElement(_efff.CNvPr, &_dfcae); _bdbfg != nil {
					return _bdbfg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cNvCxnSpPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cNvCxnSpPr"}:
				if _gfce := d.DecodeElement(_efff.CNvCxnSpPr, &_dfcae); _gfce != nil {
					return _gfce
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GvmlConnectorNonVisual\u0020\u0025v", _dfcae.Name)
				if _agebe := d.Skip(); _agebe != nil {
					return _agebe
				}
			}
		case _g.EndElement:
			break _dfde
		case _g.CharData:
		}
	}
	return nil
}
func (_fgddd *CT_TextSpacingPoint) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fgddd.ValAttr = 0
	for _, _bcegc := range start.Attr {
		if _bcegc.Name.Local == "val" {
			_cbdbb, _eddba := _e.ParseInt(_bcegc.Value, 10, 32)
			if _eddba != nil {
				return _eddba
			}
			_fgddd.ValAttr = int32(_cbdbb)
			continue
		}
	}
	for {
		_cfgbd, _cfdac := d.Token()
		if _cfdac != nil {
			return _dcf.Errorf("parsing\u0020CT_TextSpacingPoint:\u0020\u0025s", _cfdac)
		}
		if _affa, _defdg := _cfgbd.(_g.EndElement); _defdg && _affa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_caabc *CT_TextSpacing) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _caabc.SpcPct != nil {
		_fefgb := _g.StartElement{Name: _g.Name{Local: "a:spcPct"}}
		e.EncodeElement(_caabc.SpcPct, _fefgb)
	}
	if _caabc.SpcPts != nil {
		_gbddd := _g.StartElement{Name: _g.Name{Local: "a:spcPts"}}
		e.EncodeElement(_caabc.SpcPts, _gbddd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_gagcb ST_TextHorzOverflowType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_gagcb.String(), start)
}
func NewCT_PolarAdjustHandle() *CT_PolarAdjustHandle {
	_beaee := &CT_PolarAdjustHandle{}
	_beaee.Pos = NewCT_AdjPoint2D()
	return _beaee
}

// ValidateWithPath validates the CT_TextBulletColorFollowText and its children, prefixing error messages with path
func (_aeegc *CT_TextBulletColorFollowText) ValidateWithPath(path string) error { return nil }
func (_ebcb *ST_BlipCompression) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_geffee, _efdaf := d.Token()
	if _efdaf != nil {
		return _efdaf
	}
	if _aecff, _caefe := _geffee.(_g.EndElement); _caefe && _aecff.Name == start.Name {
		*_ebcb = 1
		return nil
	}
	if _bgfef, _eeddb := _geffee.(_g.CharData); !_eeddb {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _geffee)
	} else {
		switch string(_bgfef) {
		case "":
			*_ebcb = 0
		case "email":
			*_ebcb = 1
		case "screen":
			*_ebcb = 2
		case "print":
			*_ebcb = 3
		case "hqprint":
			*_ebcb = 4
		case "none":
			*_ebcb = 5
		}
	}
	_geffee, _efdaf = d.Token()
	if _efdaf != nil {
		return _efdaf
	}
	if _aadaf, _ccdafg := _geffee.(_g.EndElement); _ccdafg && _aadaf.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _geffee)
}
func NewCT_OuterShadowEffect() *CT_OuterShadowEffect {
	_bdfaf := &CT_OuterShadowEffect{}
	return _bdfaf
}

// Validate validates the CT_GvmlConnectorNonVisual and its children
func (_bgebf *CT_GvmlConnectorNonVisual) Validate() error {
	return _bgebf.ValidateWithPath("CT_GvmlConnectorNonVisual")
}

const (
	ST_AnimationBuildTypeUnset     ST_AnimationBuildType = 0
	ST_AnimationBuildTypeAllAtOnce ST_AnimationBuildType = 1
)

func NewCT_CustomColorList() *CT_CustomColorList { _gccd := &CT_CustomColorList{}; return _gccd }

const (
	ST_BevelPresetTypeUnset        ST_BevelPresetType = 0
	ST_BevelPresetTypeRelaxedInset ST_BevelPresetType = 1
	ST_BevelPresetTypeCircle       ST_BevelPresetType = 2
	ST_BevelPresetTypeSlope        ST_BevelPresetType = 3
	ST_BevelPresetTypeCross        ST_BevelPresetType = 4
	ST_BevelPresetTypeAngle        ST_BevelPresetType = 5
	ST_BevelPresetTypeSoftRound    ST_BevelPresetType = 6
	ST_BevelPresetTypeConvex       ST_BevelPresetType = 7
	ST_BevelPresetTypeCoolSlant    ST_BevelPresetType = 8
	ST_BevelPresetTypeDivot        ST_BevelPresetType = 9
	ST_BevelPresetTypeRiblet       ST_BevelPresetType = 10
	ST_BevelPresetTypeHardEdge     ST_BevelPresetType = 11
	ST_BevelPresetTypeArtDeco      ST_BevelPresetType = 12
)

type CT_ColorSchemeList struct{ ExtraClrScheme []*CT_ColorSchemeAndMapping }
type CT_BiLevelEffect struct{ ThreshAttr ST_PositiveFixedPercentage }

func (_fdac *ST_LineEndLength) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_becbdb, _fegff := d.Token()
	if _fegff != nil {
		return _fegff
	}
	if _febbd, _fgdbfe := _becbdb.(_g.EndElement); _fgdbfe && _febbd.Name == start.Name {
		*_fdac = 1
		return nil
	}
	if _gccff, _cefdc := _becbdb.(_g.CharData); !_cefdc {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _becbdb)
	} else {
		switch string(_gccff) {
		case "":
			*_fdac = 0
		case "sm":
			*_fdac = 1
		case "med":
			*_fdac = 2
		case "lg":
			*_fdac = 3
		}
	}
	_becbdb, _fegff = d.Token()
	if _fegff != nil {
		return _fegff
	}
	if _dccbf, _fcbgdf := _becbdb.(_g.EndElement); _fcbgdf && _dccbf.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _becbdb)
}

// ValidateWithPath validates the CT_AlphaInverseEffect and its children, prefixing error messages with path
func (_afg *CT_AlphaInverseEffect) ValidateWithPath(path string) error {
	if _afg.ScrgbClr != nil {
		if _dgg := _afg.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _dgg != nil {
			return _dgg
		}
	}
	if _afg.SrgbClr != nil {
		if _ea := _afg.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _ea != nil {
			return _ea
		}
	}
	if _afg.HslClr != nil {
		if _ecd := _afg.HslClr.ValidateWithPath(path + "\u002fHslClr"); _ecd != nil {
			return _ecd
		}
	}
	if _afg.SysClr != nil {
		if _dgfd := _afg.SysClr.ValidateWithPath(path + "\u002fSysClr"); _dgfd != nil {
			return _dgfd
		}
	}
	if _afg.SchemeClr != nil {
		if _cggf := _afg.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _cggf != nil {
			return _cggf
		}
	}
	if _afg.PrstClr != nil {
		if _ffc := _afg.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _ffc != nil {
			return _ffc
		}
	}
	return nil
}

type CT_AlphaFloorEffect struct{}

func (_fddcc *ST_Percentage) Validate() error { return _fddcc.ValidateWithPath("") }

type CT_GroupLocking struct {
	NoGrpAttr          *bool
	NoUngrpAttr        *bool
	NoSelectAttr       *bool
	NoRotAttr          *bool
	NoChangeAspectAttr *bool
	NoMoveAttr         *bool
	NoResizeAttr       *bool
	ExtLst             *CT_OfficeArtExtensionList
}

func (_geefbg ST_TextAutonumberScheme) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_eeddd := _g.Attr{}
	_eeddd.Name = name
	switch _geefbg {
	case ST_TextAutonumberSchemeUnset:
		_eeddd.Value = ""
	case ST_TextAutonumberSchemeAlphaLcParenBoth:
		_eeddd.Value = "alphaLcParenBoth"
	case ST_TextAutonumberSchemeAlphaUcParenBoth:
		_eeddd.Value = "alphaUcParenBoth"
	case ST_TextAutonumberSchemeAlphaLcParenR:
		_eeddd.Value = "alphaLcParenR"
	case ST_TextAutonumberSchemeAlphaUcParenR:
		_eeddd.Value = "alphaUcParenR"
	case ST_TextAutonumberSchemeAlphaLcPeriod:
		_eeddd.Value = "alphaLcPeriod"
	case ST_TextAutonumberSchemeAlphaUcPeriod:
		_eeddd.Value = "alphaUcPeriod"
	case ST_TextAutonumberSchemeArabicParenBoth:
		_eeddd.Value = "arabicParenBoth"
	case ST_TextAutonumberSchemeArabicParenR:
		_eeddd.Value = "arabicParenR"
	case ST_TextAutonumberSchemeArabicPeriod:
		_eeddd.Value = "arabicPeriod"
	case ST_TextAutonumberSchemeArabicPlain:
		_eeddd.Value = "arabicPlain"
	case ST_TextAutonumberSchemeRomanLcParenBoth:
		_eeddd.Value = "romanLcParenBoth"
	case ST_TextAutonumberSchemeRomanUcParenBoth:
		_eeddd.Value = "romanUcParenBoth"
	case ST_TextAutonumberSchemeRomanLcParenR:
		_eeddd.Value = "romanLcParenR"
	case ST_TextAutonumberSchemeRomanUcParenR:
		_eeddd.Value = "romanUcParenR"
	case ST_TextAutonumberSchemeRomanLcPeriod:
		_eeddd.Value = "romanLcPeriod"
	case ST_TextAutonumberSchemeRomanUcPeriod:
		_eeddd.Value = "romanUcPeriod"
	case ST_TextAutonumberSchemeCircleNumDbPlain:
		_eeddd.Value = "circleNumDbPlain"
	case ST_TextAutonumberSchemeCircleNumWdBlackPlain:
		_eeddd.Value = "circleNumWdBlackPlain"
	case ST_TextAutonumberSchemeCircleNumWdWhitePlain:
		_eeddd.Value = "circleNumWdWhitePlain"
	case ST_TextAutonumberSchemeArabicDbPeriod:
		_eeddd.Value = "arabicDbPeriod"
	case ST_TextAutonumberSchemeArabicDbPlain:
		_eeddd.Value = "arabicDbPlain"
	case ST_TextAutonumberSchemeEa1ChsPeriod:
		_eeddd.Value = "ea1ChsPeriod"
	case ST_TextAutonumberSchemeEa1ChsPlain:
		_eeddd.Value = "ea1ChsPlain"
	case ST_TextAutonumberSchemeEa1ChtPeriod:
		_eeddd.Value = "ea1ChtPeriod"
	case ST_TextAutonumberSchemeEa1ChtPlain:
		_eeddd.Value = "ea1ChtPlain"
	case ST_TextAutonumberSchemeEa1JpnChsDbPeriod:
		_eeddd.Value = "ea1JpnChsDbPeriod"
	case ST_TextAutonumberSchemeEa1JpnKorPlain:
		_eeddd.Value = "ea1JpnKorPlain"
	case ST_TextAutonumberSchemeEa1JpnKorPeriod:
		_eeddd.Value = "ea1JpnKorPeriod"
	case ST_TextAutonumberSchemeArabic1Minus:
		_eeddd.Value = "arabic1Minus"
	case ST_TextAutonumberSchemeArabic2Minus:
		_eeddd.Value = "arabic2Minus"
	case ST_TextAutonumberSchemeHebrew2Minus:
		_eeddd.Value = "hebrew2Minus"
	case ST_TextAutonumberSchemeThaiAlphaPeriod:
		_eeddd.Value = "thaiAlphaPeriod"
	case ST_TextAutonumberSchemeThaiAlphaParenR:
		_eeddd.Value = "thaiAlphaParenR"
	case ST_TextAutonumberSchemeThaiAlphaParenBoth:
		_eeddd.Value = "thaiAlphaParenBoth"
	case ST_TextAutonumberSchemeThaiNumPeriod:
		_eeddd.Value = "thaiNumPeriod"
	case ST_TextAutonumberSchemeThaiNumParenR:
		_eeddd.Value = "thaiNumParenR"
	case ST_TextAutonumberSchemeThaiNumParenBoth:
		_eeddd.Value = "thaiNumParenBoth"
	case ST_TextAutonumberSchemeHindiAlphaPeriod:
		_eeddd.Value = "hindiAlphaPeriod"
	case ST_TextAutonumberSchemeHindiNumPeriod:
		_eeddd.Value = "hindiNumPeriod"
	case ST_TextAutonumberSchemeHindiNumParenR:
		_eeddd.Value = "hindiNumParenR"
	case ST_TextAutonumberSchemeHindiAlpha1Period:
		_eeddd.Value = "hindiAlpha1Period"
	}
	return _eeddd, nil
}

type CT_TextParagraph struct {
	PPr        *CT_TextParagraphProperties
	EG_TextRun []*EG_TextRun
	EndParaRPr *CT_TextCharacterProperties
}

func NewCT_GvmlGroupShape() *CT_GvmlGroupShape {
	_bggfd := &CT_GvmlGroupShape{}
	_bggfd.NvGrpSpPr = NewCT_GvmlGroupShapeNonVisual()
	_bggfd.GrpSpPr = NewCT_GroupShapeProperties()
	return _bggfd
}
func (_dgadg *CT_PolarAdjustHandle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dgadg.GdRefRAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "gdRefR"}, Value: _dcf.Sprintf("\u0025v", *_dgadg.GdRefRAttr)})
	}
	if _dgadg.MinRAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "minR"}, Value: _dcf.Sprintf("\u0025v", *_dgadg.MinRAttr)})
	}
	if _dgadg.MaxRAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "maxR"}, Value: _dcf.Sprintf("\u0025v", *_dgadg.MaxRAttr)})
	}
	if _dgadg.GdRefAngAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "gdRefAng"}, Value: _dcf.Sprintf("\u0025v", *_dgadg.GdRefAngAttr)})
	}
	if _dgadg.MinAngAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "minAng"}, Value: _dcf.Sprintf("\u0025v", *_dgadg.MinAngAttr)})
	}
	if _dgadg.MaxAngAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "maxAng"}, Value: _dcf.Sprintf("\u0025v", *_dgadg.MaxAngAttr)})
	}
	e.EncodeToken(start)
	_ddgfe := _g.StartElement{Name: _g.Name{Local: "a:pos"}}
	e.EncodeElement(_dgadg.Pos, _ddgfe)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_gggfc *EG_OfficeArtExtensionList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _gggfc.Ext != nil {
		_bcace := _g.StartElement{Name: _g.Name{Local: "a:ext"}}
		for _, _gbgeg := range _gggfc.Ext {
			e.EncodeElement(_gbgeg, _bcace)
		}
	}
	return nil
}
func (_gaeebc ST_PositivePercentage) String() string {
	if _gaeebc.ST_PositivePercentageDecimal != nil {
		return _dcf.Sprintf("\u0025v", *_gaeebc.ST_PositivePercentageDecimal)
	}
	if _gaeebc.ST_PositivePercentage != nil {
		return _gaeebc.ST_PositivePercentage.String()
	}
	return ""
}
func (_dfbgc *CT_TableCellProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ccgcc := range start.Attr {
		if _ccgcc.Name.Local == "marR" {
			_caagf, _agaad := ParseUnionST_Coordinate32(_ccgcc.Value)
			if _agaad != nil {
				return _agaad
			}
			_dfbgc.MarRAttr = &_caagf
			continue
		}
		if _ccgcc.Name.Local == "marB" {
			_ageae, _egefb := ParseUnionST_Coordinate32(_ccgcc.Value)
			if _egefb != nil {
				return _egefb
			}
			_dfbgc.MarBAttr = &_ageae
			continue
		}
		if _ccgcc.Name.Local == "anchor" {
			_dfbgc.AnchorAttr.UnmarshalXMLAttr(_ccgcc)
			continue
		}
		if _ccgcc.Name.Local == "horzOverflow" {
			_dfbgc.HorzOverflowAttr.UnmarshalXMLAttr(_ccgcc)
			continue
		}
		if _ccgcc.Name.Local == "anchorCtr" {
			_cbaea, _ccfgc := _e.ParseBool(_ccgcc.Value)
			if _ccfgc != nil {
				return _ccfgc
			}
			_dfbgc.AnchorCtrAttr = &_cbaea
			continue
		}
		if _ccgcc.Name.Local == "vert" {
			_dfbgc.VertAttr.UnmarshalXMLAttr(_ccgcc)
			continue
		}
		if _ccgcc.Name.Local == "marL" {
			_ecffe, _fbfca := ParseUnionST_Coordinate32(_ccgcc.Value)
			if _fbfca != nil {
				return _fbfca
			}
			_dfbgc.MarLAttr = &_ecffe
			continue
		}
		if _ccgcc.Name.Local == "marT" {
			_aeeeb, _cgede := ParseUnionST_Coordinate32(_ccgcc.Value)
			if _cgede != nil {
				return _cgede
			}
			_dfbgc.MarTAttr = &_aeeeb
			continue
		}
	}
_eabg:
	for {
		_dabge, _efcee := d.Token()
		if _efcee != nil {
			return _efcee
		}
		switch _bdccab := _dabge.(type) {
		case _g.StartElement:
			switch _bdccab.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnL"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnL"}:
				_dfbgc.LnL = NewCT_LineProperties()
				if _gaegc := d.DecodeElement(_dfbgc.LnL, &_bdccab); _gaegc != nil {
					return _gaegc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnR"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnR"}:
				_dfbgc.LnR = NewCT_LineProperties()
				if _dgddb := d.DecodeElement(_dfbgc.LnR, &_bdccab); _dgddb != nil {
					return _dgddb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnT"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnT"}:
				_dfbgc.LnT = NewCT_LineProperties()
				if _eddcd := d.DecodeElement(_dfbgc.LnT, &_bdccab); _eddcd != nil {
					return _eddcd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnB"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnB"}:
				_dfbgc.LnB = NewCT_LineProperties()
				if _edgaf := d.DecodeElement(_dfbgc.LnB, &_bdccab); _edgaf != nil {
					return _edgaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnTlToBr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnTlToBr"}:
				_dfbgc.LnTlToBr = NewCT_LineProperties()
				if _ffgaf := d.DecodeElement(_dfbgc.LnTlToBr, &_bdccab); _ffgaf != nil {
					return _ffgaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnBlToTr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnBlToTr"}:
				_dfbgc.LnBlToTr = NewCT_LineProperties()
				if _bced := d.DecodeElement(_dfbgc.LnBlToTr, &_bdccab); _bced != nil {
					return _bced
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cell3D"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cell3D"}:
				_dfbgc.Cell3D = NewCT_Cell3D()
				if _gfacd := d.DecodeElement(_dfbgc.Cell3D, &_bdccab); _gfacd != nil {
					return _gfacd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_dfbgc.NoFill = NewCT_NoFillProperties()
				if _aaeed := d.DecodeElement(_dfbgc.NoFill, &_bdccab); _aaeed != nil {
					return _aaeed
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_dfbgc.SolidFill = NewCT_SolidColorFillProperties()
				if _cgfb := d.DecodeElement(_dfbgc.SolidFill, &_bdccab); _cgfb != nil {
					return _cgfb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_dfbgc.GradFill = NewCT_GradientFillProperties()
				if _fcdcf := d.DecodeElement(_dfbgc.GradFill, &_bdccab); _fcdcf != nil {
					return _fcdcf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_dfbgc.BlipFill = NewCT_BlipFillProperties()
				if _agcdf := d.DecodeElement(_dfbgc.BlipFill, &_bdccab); _agcdf != nil {
					return _agcdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_dfbgc.PattFill = NewCT_PatternFillProperties()
				if _ggfe := d.DecodeElement(_dfbgc.PattFill, &_bdccab); _ggfe != nil {
					return _ggfe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_dfbgc.GrpFill = NewCT_GroupFillProperties()
				if _fcag := d.DecodeElement(_dfbgc.GrpFill, &_bdccab); _fcag != nil {
					return _fcag
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "headers"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "headers"}:
				_dfbgc.Headers = NewCT_Headers()
				if _cbdg := d.DecodeElement(_dfbgc.Headers, &_bdccab); _cbdg != nil {
					return _cbdg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_dfbgc.ExtLst = NewCT_OfficeArtExtensionList()
				if _aceab := d.DecodeElement(_dfbgc.ExtLst, &_bdccab); _aceab != nil {
					return _aceab
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TableCellProperties\u0020\u0025v", _bdccab.Name)
				if _feddg := d.Skip(); _feddg != nil {
					return _feddg
				}
			}
		case _g.EndElement:
			break _eabg
		case _g.CharData:
		}
	}
	return nil
}

type CT_TextSpacingPercent struct {
	ValAttr ST_TextSpacingPercentOrPercentString
}

func (_geaef *ST_LineEndWidth) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_geaef = 0
	case "sm":
		*_geaef = 1
	case "med":
		*_geaef = 2
	case "lg":
		*_geaef = 3
	}
	return nil
}
func (_dgbeg *EG_Effect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_bbgaa:
	for {
		_fdgdg, _bcgdg := d.Token()
		if _bcgdg != nil {
			return _bcgdg
		}
		switch _gfcag := _fdgdg.(type) {
		case _g.StartElement:
			switch _gfcag.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cont"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cont"}:
				_dgbeg.Cont = NewCT_EffectContainer()
				if _beagf := d.DecodeElement(_dgbeg.Cont, &_gfcag); _beagf != nil {
					return _beagf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effect"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effect"}:
				_dgbeg.Effect = NewCT_EffectReference()
				if _ggcdf := d.DecodeElement(_dgbeg.Effect, &_gfcag); _ggcdf != nil {
					return _ggcdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaBiLevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaBiLevel"}:
				_dgbeg.AlphaBiLevel = NewCT_AlphaBiLevelEffect()
				if _gdacac := d.DecodeElement(_dgbeg.AlphaBiLevel, &_gfcag); _gdacac != nil {
					return _gdacac
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaCeiling"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaCeiling"}:
				_dgbeg.AlphaCeiling = NewCT_AlphaCeilingEffect()
				if _eggdf := d.DecodeElement(_dgbeg.AlphaCeiling, &_gfcag); _eggdf != nil {
					return _eggdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaFloor"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaFloor"}:
				_dgbeg.AlphaFloor = NewCT_AlphaFloorEffect()
				if _deacb := d.DecodeElement(_dgbeg.AlphaFloor, &_gfcag); _deacb != nil {
					return _deacb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaInv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaInv"}:
				_dgbeg.AlphaInv = NewCT_AlphaInverseEffect()
				if _efbf := d.DecodeElement(_dgbeg.AlphaInv, &_gfcag); _efbf != nil {
					return _efbf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_dgbeg.AlphaMod = NewCT_AlphaModulateEffect()
				if _dcgfe := d.DecodeElement(_dgbeg.AlphaMod, &_gfcag); _dcgfe != nil {
					return _dcgfe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaModFix"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaModFix"}:
				_dgbeg.AlphaModFix = NewCT_AlphaModulateFixedEffect()
				if _ggbe := d.DecodeElement(_dgbeg.AlphaModFix, &_gfcag); _ggbe != nil {
					return _ggbe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaOutset"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaOutset"}:
				_dgbeg.AlphaOutset = NewCT_AlphaOutsetEffect()
				if _gddgd := d.DecodeElement(_dgbeg.AlphaOutset, &_gfcag); _gddgd != nil {
					return _gddgd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaRepl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaRepl"}:
				_dgbeg.AlphaRepl = NewCT_AlphaReplaceEffect()
				if _febba := d.DecodeElement(_dgbeg.AlphaRepl, &_gfcag); _febba != nil {
					return _febba
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "biLevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "biLevel"}:
				_dgbeg.BiLevel = NewCT_BiLevelEffect()
				if _addba := d.DecodeElement(_dgbeg.BiLevel, &_gfcag); _addba != nil {
					return _addba
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blend"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blend"}:
				_dgbeg.Blend = NewCT_BlendEffect()
				if _bcadb := d.DecodeElement(_dgbeg.Blend, &_gfcag); _bcadb != nil {
					return _bcadb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blur"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blur"}:
				_dgbeg.Blur = NewCT_BlurEffect()
				if _cfbg := d.DecodeElement(_dgbeg.Blur, &_gfcag); _cfbg != nil {
					return _cfbg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrChange"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrChange"}:
				_dgbeg.ClrChange = NewCT_ColorChangeEffect()
				if _bccfa := d.DecodeElement(_dgbeg.ClrChange, &_gfcag); _bccfa != nil {
					return _bccfa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrRepl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrRepl"}:
				_dgbeg.ClrRepl = NewCT_ColorReplaceEffect()
				if _bcdbac := d.DecodeElement(_dgbeg.ClrRepl, &_gfcag); _bcdbac != nil {
					return _bcdbac
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "duotone"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "duotone"}:
				_dgbeg.Duotone = NewCT_DuotoneEffect()
				if _fgcdd := d.DecodeElement(_dgbeg.Duotone, &_gfcag); _fgcdd != nil {
					return _fgcdd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fill"}:
				_dgbeg.Fill = NewCT_FillEffect()
				if _debfab := d.DecodeElement(_dgbeg.Fill, &_gfcag); _debfab != nil {
					return _debfab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillOverlay"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillOverlay"}:
				_dgbeg.FillOverlay = NewCT_FillOverlayEffect()
				if _gdgbg := d.DecodeElement(_dgbeg.FillOverlay, &_gfcag); _gdgbg != nil {
					return _gdgbg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "glow"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "glow"}:
				_dgbeg.Glow = NewCT_GlowEffect()
				if _bbgcf := d.DecodeElement(_dgbeg.Glow, &_gfcag); _bbgcf != nil {
					return _bbgcf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grayscl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grayscl"}:
				_dgbeg.Grayscl = NewCT_GrayscaleEffect()
				if _cfcge := d.DecodeElement(_dgbeg.Grayscl, &_gfcag); _cfcge != nil {
					return _cfcge
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hsl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hsl"}:
				_dgbeg.Hsl = NewCT_HSLEffect()
				if _ceged := d.DecodeElement(_dgbeg.Hsl, &_gfcag); _ceged != nil {
					return _ceged
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "innerShdw"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "innerShdw"}:
				_dgbeg.InnerShdw = NewCT_InnerShadowEffect()
				if _bfcfg := d.DecodeElement(_dgbeg.InnerShdw, &_gfcag); _bfcfg != nil {
					return _bfcfg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_dgbeg.Lum = NewCT_LuminanceEffect()
				if _bebe := d.DecodeElement(_dgbeg.Lum, &_gfcag); _bebe != nil {
					return _bebe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "outerShdw"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "outerShdw"}:
				_dgbeg.OuterShdw = NewCT_OuterShadowEffect()
				if _baaeb := d.DecodeElement(_dgbeg.OuterShdw, &_gfcag); _baaeb != nil {
					return _baaeb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstShdw"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstShdw"}:
				_dgbeg.PrstShdw = NewCT_PresetShadowEffect()
				if _acbdf := d.DecodeElement(_dgbeg.PrstShdw, &_gfcag); _acbdf != nil {
					return _acbdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "reflection"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "reflection"}:
				_dgbeg.Reflection = NewCT_ReflectionEffect()
				if _gbbceg := d.DecodeElement(_dgbeg.Reflection, &_gfcag); _gbbceg != nil {
					return _gbbceg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "relOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "relOff"}:
				_dgbeg.RelOff = NewCT_RelativeOffsetEffect()
				if _aaca := d.DecodeElement(_dgbeg.RelOff, &_gfcag); _aaca != nil {
					return _aaca
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "softEdge"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "softEdge"}:
				_dgbeg.SoftEdge = NewCT_SoftEdgesEffect()
				if _daaag := d.DecodeElement(_dgbeg.SoftEdge, &_gfcag); _daaag != nil {
					return _daaag
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_dgbeg.Tint = NewCT_TintEffect()
				if _dddca := d.DecodeElement(_dgbeg.Tint, &_gfcag); _dddca != nil {
					return _dddca
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "xfrm"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "xfrm"}:
				_dgbeg.Xfrm = NewCT_TransformEffect()
				if _adeedg := d.DecodeElement(_dgbeg.Xfrm, &_gfcag); _adeedg != nil {
					return _adeedg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on EG_Effect \u0025v", _gfcag.Name)
				if _gefda := d.Skip(); _gefda != nil {
					return _gefda
				}
			}
		case _g.EndElement:
			break _bbgaa
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_Path2D() *CT_Path2D { _bfdcc := &CT_Path2D{}; return _bfdcc }

// ValidateWithPath validates the CT_TextAutonumberBullet and its children, prefixing error messages with path
func (_bbdga *CT_TextAutonumberBullet) ValidateWithPath(path string) error {
	if _bbdga.TypeAttr == ST_TextAutonumberSchemeUnset {
		return _dcf.Errorf("\u0025s\u002fTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _fbaeb := _bbdga.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _fbaeb != nil {
		return _fbaeb
	}
	if _bbdga.StartAtAttr != nil {
		if *_bbdga.StartAtAttr < 1 {
			return _dcf.Errorf("\u0025s\u002fm\u002eStartAtAttr\u0020must\u0020be\u0020\u003e\u003d\u00201\u0020\u0028have\u0020\u0025v\u0029", path, *_bbdga.StartAtAttr)
		}
		if *_bbdga.StartAtAttr > 32767 {
			return _dcf.Errorf("\u0025s\u002fm\u002eStartAtAttr must\u0020be\u0020\u003c\u003d\u002032767\u0020\u0028have\u0020\u0025v\u0029", path, *_bbdga.StartAtAttr)
		}
	}
	return nil
}

type CT_TextCharBullet struct{ CharAttr string }

// ValidateWithPath validates the CT_GvmlTextShape and its children, prefixing error messages with path
func (_egfc *CT_GvmlTextShape) ValidateWithPath(path string) error {
	if _gbecf := _egfc.TxBody.ValidateWithPath(path + "\u002fTxBody"); _gbecf != nil {
		return _gbecf
	}
	if _egfc.Choice != nil {
		if _daaef := _egfc.Choice.ValidateWithPath(path + "\u002fChoice"); _daaef != nil {
			return _daaef
		}
	}
	if _egfc.ExtLst != nil {
		if _bgdgd := _egfc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bgdgd != nil {
			return _bgdgd
		}
	}
	return nil
}

type CT_Ratio struct {
	NAttr int64
	DAttr int64
}

func (_bcaac ST_PenAlignment) Validate() error { return _bcaac.ValidateWithPath("") }

type CT_BackgroundFormatting struct {
	NoFill    *CT_NoFillProperties
	SolidFill *CT_SolidColorFillProperties
	GradFill  *CT_GradientFillProperties
	BlipFill  *CT_BlipFillProperties
	PattFill  *CT_PatternFillProperties
	GrpFill   *CT_GroupFillProperties
	EffectLst *CT_EffectList
	EffectDag *CT_EffectContainer
}

func (_bffg *CT_TextCharacterProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _dacad := range start.Attr {
		if _dacad.Name.Local == "lang" {
			_abdcc, _ebeac := _dacad.Value, error(nil)
			if _ebeac != nil {
				return _ebeac
			}
			_bffg.LangAttr = &_abdcc
			continue
		}
		if _dacad.Name.Local == "sz" {
			_bgfcd, _fefae := _e.ParseInt(_dacad.Value, 10, 32)
			if _fefae != nil {
				return _fefae
			}
			_bcbaf := int32(_bgfcd)
			_bffg.SzAttr = &_bcbaf
			continue
		}
		if _dacad.Name.Local == "kumimoji" {
			_bgdfd, _dcegg := _e.ParseBool(_dacad.Value)
			if _dcegg != nil {
				return _dcegg
			}
			_bffg.KumimojiAttr = &_bgdfd
			continue
		}
		if _dacad.Name.Local == "strike" {
			_bffg.StrikeAttr.UnmarshalXMLAttr(_dacad)
			continue
		}
		if _dacad.Name.Local == "cap" {
			_bffg.CapAttr.UnmarshalXMLAttr(_dacad)
			continue
		}
		if _dacad.Name.Local == "b" {
			_aagaag, _fafb := _e.ParseBool(_dacad.Value)
			if _fafb != nil {
				return _fafb
			}
			_bffg.BAttr = &_aagaag
			continue
		}
		if _dacad.Name.Local == "i" {
			_ffcgg, _edcecf := _e.ParseBool(_dacad.Value)
			if _edcecf != nil {
				return _edcecf
			}
			_bffg.IAttr = &_ffcgg
			continue
		}
		if _dacad.Name.Local == "smtClean" {
			_ffadb, _baae := _e.ParseBool(_dacad.Value)
			if _baae != nil {
				return _baae
			}
			_bffg.SmtCleanAttr = &_ffadb
			continue
		}
		if _dacad.Name.Local == "kern" {
			_bcedd, _gcbae := _e.ParseInt(_dacad.Value, 10, 32)
			if _gcbae != nil {
				return _gcbae
			}
			_bafcc := int32(_bcedd)
			_bffg.KernAttr = &_bafcc
			continue
		}
		if _dacad.Name.Local == "err" {
			_ebfeg, _deeag := _e.ParseBool(_dacad.Value)
			if _deeag != nil {
				return _deeag
			}
			_bffg.ErrAttr = &_ebfeg
			continue
		}
		if _dacad.Name.Local == "altLang" {
			_dcec, _fedbd := _dacad.Value, error(nil)
			if _fedbd != nil {
				return _fedbd
			}
			_bffg.AltLangAttr = &_dcec
			continue
		}
		if _dacad.Name.Local == "noProof" {
			_abfef, _geddc := _e.ParseBool(_dacad.Value)
			if _geddc != nil {
				return _geddc
			}
			_bffg.NoProofAttr = &_abfef
			continue
		}
		if _dacad.Name.Local == "u" {
			_bffg.UAttr.UnmarshalXMLAttr(_dacad)
			continue
		}
		if _dacad.Name.Local == "smtId" {
			_gaggfb, _bacda := _e.ParseUint(_dacad.Value, 10, 32)
			if _bacda != nil {
				return _bacda
			}
			_gedfe := uint32(_gaggfb)
			_bffg.SmtIdAttr = &_gedfe
			continue
		}
		if _dacad.Name.Local == "spc" {
			_dagdee, _gbgda := ParseUnionST_TextPoint(_dacad.Value)
			if _gbgda != nil {
				return _gbgda
			}
			_bffg.SpcAttr = &_dagdee
			continue
		}
		if _dacad.Name.Local == "baseline" {
			_cfegf, _bccef := ParseUnionST_Percentage(_dacad.Value)
			if _bccef != nil {
				return _bccef
			}
			_bffg.BaselineAttr = &_cfegf
			continue
		}
		if _dacad.Name.Local == "dirty" {
			_dbfeg, _bgbag := _e.ParseBool(_dacad.Value)
			if _bgbag != nil {
				return _bgbag
			}
			_bffg.DirtyAttr = &_dbfeg
			continue
		}
		if _dacad.Name.Local == "bmk" {
			_dbeef, _edceb := _dacad.Value, error(nil)
			if _edceb != nil {
				return _edceb
			}
			_bffg.BmkAttr = &_dbeef
			continue
		}
		if _dacad.Name.Local == "normalizeH" {
			_cagaf, _debef := _e.ParseBool(_dacad.Value)
			if _debef != nil {
				return _debef
			}
			_bffg.NormalizeHAttr = &_cagaf
			continue
		}
	}
_acadg:
	for {
		_fdeg, _begg := d.Token()
		if _begg != nil {
			return _begg
		}
		switch _abaed := _fdeg.(type) {
		case _g.StartElement:
			switch _abaed.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ln"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ln"}:
				_bffg.Ln = NewCT_LineProperties()
				if _bdbed := d.DecodeElement(_bffg.Ln, &_abaed); _bdbed != nil {
					return _bdbed
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_bffg.NoFill = NewCT_NoFillProperties()
				if _abfdc := d.DecodeElement(_bffg.NoFill, &_abaed); _abfdc != nil {
					return _abfdc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_bffg.SolidFill = NewCT_SolidColorFillProperties()
				if _dcegcg := d.DecodeElement(_bffg.SolidFill, &_abaed); _dcegcg != nil {
					return _dcegcg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_bffg.GradFill = NewCT_GradientFillProperties()
				if _ddcad := d.DecodeElement(_bffg.GradFill, &_abaed); _ddcad != nil {
					return _ddcad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_bffg.BlipFill = NewCT_BlipFillProperties()
				if _ebege := d.DecodeElement(_bffg.BlipFill, &_abaed); _ebege != nil {
					return _ebege
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_bffg.PattFill = NewCT_PatternFillProperties()
				if _dadea := d.DecodeElement(_bffg.PattFill, &_abaed); _dadea != nil {
					return _dadea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_bffg.GrpFill = NewCT_GroupFillProperties()
				if _cdgfg := d.DecodeElement(_bffg.GrpFill, &_abaed); _cdgfg != nil {
					return _cdgfg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectLst"}:
				_bffg.EffectLst = NewCT_EffectList()
				if _cggbg := d.DecodeElement(_bffg.EffectLst, &_abaed); _cggbg != nil {
					return _cggbg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectDag"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectDag"}:
				_bffg.EffectDag = NewCT_EffectContainer()
				if _dddbe := d.DecodeElement(_bffg.EffectDag, &_abaed); _dddbe != nil {
					return _dddbe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "highlight"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "highlight"}:
				_bffg.Highlight = NewCT_Color()
				if _bfca := d.DecodeElement(_bffg.Highlight, &_abaed); _bfca != nil {
					return _bfca
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "uLnTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "uLnTx"}:
				_bffg.ULnTx = NewCT_TextUnderlineLineFollowText()
				if _dcead := d.DecodeElement(_bffg.ULnTx, &_abaed); _dcead != nil {
					return _dcead
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "uLn"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "uLn"}:
				_bffg.ULn = NewCT_LineProperties()
				if _abbb := d.DecodeElement(_bffg.ULn, &_abaed); _abbb != nil {
					return _abbb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "uFillTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "uFillTx"}:
				_bffg.UFillTx = NewCT_TextUnderlineFillFollowText()
				if _aeedd := d.DecodeElement(_bffg.UFillTx, &_abaed); _aeedd != nil {
					return _aeedd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "uFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "uFill"}:
				_bffg.UFill = NewCT_TextUnderlineFillGroupWrapper()
				if _aafaf := d.DecodeElement(_bffg.UFill, &_abaed); _aafaf != nil {
					return _aafaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "latin"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "latin"}:
				_bffg.Latin = NewCT_TextFont()
				if _defda := d.DecodeElement(_bffg.Latin, &_abaed); _defda != nil {
					return _defda
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ea"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ea"}:
				_bffg.Ea = NewCT_TextFont()
				if _dfed := d.DecodeElement(_bffg.Ea, &_abaed); _dfed != nil {
					return _dfed
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cs"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cs"}:
				_bffg.Cs = NewCT_TextFont()
				if _gdged := d.DecodeElement(_bffg.Cs, &_abaed); _gdged != nil {
					return _gdged
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sym"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sym"}:
				_bffg.Sym = NewCT_TextFont()
				if _fgabd := d.DecodeElement(_bffg.Sym, &_abaed); _fgabd != nil {
					return _fgabd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hlinkClick"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hlinkClick"}:
				_bffg.HlinkClick = NewCT_Hyperlink()
				if _fgadb := d.DecodeElement(_bffg.HlinkClick, &_abaed); _fgadb != nil {
					return _fgadb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hlinkMouseOver"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hlinkMouseOver"}:
				_bffg.HlinkMouseOver = NewCT_Hyperlink()
				if _fggb := d.DecodeElement(_bffg.HlinkMouseOver, &_abaed); _fggb != nil {
					return _fggb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "rtl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "rtl"}:
				_bffg.Rtl = NewCT_Boolean()
				if _dbgcc := d.DecodeElement(_bffg.Rtl, &_abaed); _dbgcc != nil {
					return _dbgcc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_bffg.ExtLst = NewCT_OfficeArtExtensionList()
				if _gbcea := d.DecodeElement(_bffg.ExtLst, &_abaed); _gbcea != nil {
					return _gbcea
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TextCharacterProperties\u0020\u0025v", _abaed.Name)
				if _fgef := d.Skip(); _fgef != nil {
					return _fgef
				}
			}
		case _g.EndElement:
			break _acadg
		case _g.CharData:
		}
	}
	return nil
}
func (_afbdf *CT_ScRgbColor) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r"}, Value: _dcf.Sprintf("\u0025v", _afbdf.RAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "g"}, Value: _dcf.Sprintf("\u0025v", _afbdf.GAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "b"}, Value: _dcf.Sprintf("\u0025v", _afbdf.BAttr)})
	e.EncodeToken(start)
	if _afbdf.EG_ColorTransform != nil {
		for _, _eedbe := range _afbdf.EG_ColorTransform {
			_eedbe.MarshalXML(e, _g.StartElement{})
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_eagd *CT_Path2D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _agdg := range start.Attr {
		if _agdg.Name.Local == "w" {
			_afdea, _ebfdg := _e.ParseInt(_agdg.Value, 10, 64)
			if _ebfdg != nil {
				return _ebfdg
			}
			_eagd.WAttr = &_afdea
			continue
		}
		if _agdg.Name.Local == "h" {
			_becc, _dfae := _e.ParseInt(_agdg.Value, 10, 64)
			if _dfae != nil {
				return _dfae
			}
			_eagd.HAttr = &_becc
			continue
		}
		if _agdg.Name.Local == "fill" {
			_eagd.FillAttr.UnmarshalXMLAttr(_agdg)
			continue
		}
		if _agdg.Name.Local == "stroke" {
			_ecebf, _fbdc := _e.ParseBool(_agdg.Value)
			if _fbdc != nil {
				return _fbdc
			}
			_eagd.StrokeAttr = &_ecebf
			continue
		}
		if _agdg.Name.Local == "extrusionOk" {
			_dgbb, _febd := _e.ParseBool(_agdg.Value)
			if _febd != nil {
				return _febd
			}
			_eagd.ExtrusionOkAttr = &_dgbb
			continue
		}
	}
_aadfe:
	for {
		_fcdcb, _ecgbf := d.Token()
		if _ecgbf != nil {
			return _ecgbf
		}
		switch _ggegd := _fcdcb.(type) {
		case _g.StartElement:
			switch _ggegd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "close"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "close"}:
				_eafef := NewCT_Path2DClose()
				if _bcga := d.DecodeElement(_eafef, &_ggegd); _bcga != nil {
					return _bcga
				}
				_eagd.Close = append(_eagd.Close, _eafef)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "moveTo"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "moveTo"}:
				_gfffc := NewCT_Path2DMoveTo()
				if _dfgde := d.DecodeElement(_gfffc, &_ggegd); _dfgde != nil {
					return _dfgde
				}
				_eagd.MoveTo = append(_eagd.MoveTo, _gfffc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnTo"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnTo"}:
				_fdbfa := NewCT_Path2DLineTo()
				if _cbfd := d.DecodeElement(_fdbfa, &_ggegd); _cbfd != nil {
					return _cbfd
				}
				_eagd.LnTo = append(_eagd.LnTo, _fdbfa)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "arcTo"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "arcTo"}:
				_ceafd := NewCT_Path2DArcTo()
				if _cdcf := d.DecodeElement(_ceafd, &_ggegd); _cdcf != nil {
					return _cdcf
				}
				_eagd.ArcTo = append(_eagd.ArcTo, _ceafd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "quadBezTo"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "quadBezTo"}:
				_ggdfg := NewCT_Path2DQuadBezierTo()
				if _cbaef := d.DecodeElement(_ggdfg, &_ggegd); _cbaef != nil {
					return _cbaef
				}
				_eagd.QuadBezTo = append(_eagd.QuadBezTo, _ggdfg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cubicBezTo"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cubicBezTo"}:
				_bgdc := NewCT_Path2DCubicBezierTo()
				if _cadf := d.DecodeElement(_bgdc, &_ggegd); _cadf != nil {
					return _cadf
				}
				_eagd.CubicBezTo = append(_eagd.CubicBezTo, _bgdc)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on CT_Path2D \u0025v", _ggegd.Name)
				if _bdcag := d.Skip(); _bdcag != nil {
					return _bdcag
				}
			}
		case _g.EndElement:
			break _aadfe
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Path2DArcTo and its children
func (_bdege *CT_Path2DArcTo) Validate() error { return _bdege.ValidateWithPath("CT_Path2DArcTo") }
func NewCT_TableStyleList() *CT_TableStyleList {
	_dagfb := &CT_TableStyleList{}
	_dagfb.DefAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	return _dagfb
}

type CT_TextBodyProperties struct {
	RotAttr              *int32
	SpcFirstLastParaAttr *bool
	VertOverflowAttr     ST_TextVertOverflowType
	HorzOverflowAttr     ST_TextHorzOverflowType
	VertAttr             ST_TextVerticalType
	WrapAttr             ST_TextWrappingType
	LInsAttr             *ST_Coordinate32
	TInsAttr             *ST_Coordinate32
	RInsAttr             *ST_Coordinate32
	BInsAttr             *ST_Coordinate32
	NumColAttr           *int32
	SpcColAttr           *int32
	RtlColAttr           *bool
	FromWordArtAttr      *bool
	AnchorAttr           ST_TextAnchoringType
	AnchorCtrAttr        *bool
	ForceAAAttr          *bool
	UprightAttr          *bool
	CompatLnSpcAttr      *bool
	PrstTxWarp           *CT_PresetTextShape
	NoAutofit            *CT_TextNoAutofit
	NormAutofit          *CT_TextNormalAutofit
	SpAutoFit            *CT_TextShapeAutofit
	Scene3d              *CT_Scene3D
	Sp3d                 *CT_Shape3D
	FlatTx               *CT_FlatText
	ExtLst               *CT_OfficeArtExtensionList
}

func NewCT_SoftEdgesEffect() *CT_SoftEdgesEffect {
	_ecbcba := &CT_SoftEdgesEffect{}
	_ecbcba.RadAttr = 0
	return _ecbcba
}
func (_gacgf ST_BlipCompression) Validate() error { return _gacgf.ValidateWithPath("") }

// ValidateWithPath validates the CT_Ratio and its children, prefixing error messages with path
func (_cbegd *CT_Ratio) ValidateWithPath(path string) error { return nil }
func (_facae *ST_PositivePercentage) Validate() error       { return _facae.ValidateWithPath("") }
func (_gfda *CT_GraphicalObject) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_egggf := _g.StartElement{Name: _g.Name{Local: "a:graphicData"}}
	e.EncodeElement(_gfda.GraphicData, _egggf)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TextCharBullet and its children
func (_cedff *CT_TextCharBullet) Validate() error {
	return _cedff.ValidateWithPath("CT_TextCharBullet")
}

// Validate validates the CT_GraphicalObject and its children
func (_gfbe *CT_GraphicalObject) Validate() error {
	return _gfbe.ValidateWithPath("CT_GraphicalObject")
}
func (_fgaeg *EG_Geometry) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fgaeg.CustGeom != nil {
		_fadcd := _g.StartElement{Name: _g.Name{Local: "a:custGeom"}}
		e.EncodeElement(_fgaeg.CustGeom, _fadcd)
	}
	if _fgaeg.PrstGeom != nil {
		_ecfdcd := _g.StartElement{Name: _g.Name{Local: "a:prstGeom"}}
		e.EncodeElement(_fgaeg.PrstGeom, _ecfdcd)
	}
	return nil
}
func (_abbc *CT_TextTabStopList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_bdefd:
	for {
		_fgcgfb, _bcdba := d.Token()
		if _bcdba != nil {
			return _bcdba
		}
		switch _bdega := _fgcgfb.(type) {
		case _g.StartElement:
			switch _bdega.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tab"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tab"}:
				_dfaa := NewCT_TextTabStop()
				if _effcf := d.DecodeElement(_dfaa, &_bdega); _effcf != nil {
					return _effcf
				}
				_abbc.Tab = append(_abbc.Tab, _dfaa)
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_TextTabStopList\u0020\u0025v", _bdega.Name)
				if _aafef := d.Skip(); _aafef != nil {
					return _aafef
				}
			}
		case _g.EndElement:
			break _bdefd
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TextFont and its children, prefixing error messages with path
func (_gbecb *CT_TextFont) ValidateWithPath(path string) error {
	if _egaeabe := _gbecb.PitchFamilyAttr.ValidateWithPath(path + "\u002fPitchFamilyAttr"); _egaeabe != nil {
		return _egaeabe
	}
	return nil
}
func (_gebgg ST_TextPoint) String() string {
	if _gebgg.ST_TextPointUnqualified != nil {
		return _dcf.Sprintf("\u0025v", *_gebgg.ST_TextPointUnqualified)
	}
	if _gebgg.ST_UniversalMeasure != nil {
		return _dcf.Sprintf("\u0025v", *_gebgg.ST_UniversalMeasure)
	}
	return ""
}
func (_adaee *CT_NonVisualGraphicFrameProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_acgde:
	for {
		_gbga, _bebfg := d.Token()
		if _bebfg != nil {
			return _bebfg
		}
		switch _fcafc := _gbga.(type) {
		case _g.StartElement:
			switch _fcafc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "graphicFrameLocks"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "graphicFrameLocks"}:
				_adaee.GraphicFrameLocks = NewCT_GraphicalObjectFrameLocking()
				if _dgcce := d.DecodeElement(_adaee.GraphicFrameLocks, &_fcafc); _dgcce != nil {
					return _dgcce
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_adaee.ExtLst = NewCT_OfficeArtExtensionList()
				if _aegg := d.DecodeElement(_adaee.ExtLst, &_fcafc); _aegg != nil {
					return _aegg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_NonVisualGraphicFrameProperties\u0020%v", _fcafc.Name)
				if _efag := d.Skip(); _efag != nil {
					return _efag
				}
			}
		case _g.EndElement:
			break _acgde
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_ColorReplaceEffect() *CT_ColorReplaceEffect {
	_addf := &CT_ColorReplaceEffect{}
	return _addf
}

// ValidateWithPath validates the CT_AudioFile and its children, prefixing error messages with path
func (_bdcg *CT_AudioFile) ValidateWithPath(path string) error {
	if _bdcg.ExtLst != nil {
		if _gbag := _bdcg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gbag != nil {
			return _gbag
		}
	}
	return nil
}

type CT_LineStyleList struct{ Ln []*CT_LineProperties }
type CT_Path2DLineTo struct{ Pt *CT_AdjPoint2D }

// ValidateWithPath validates the CT_SphereCoords and its children, prefixing error messages with path
func (_adbeg *CT_SphereCoords) ValidateWithPath(path string) error {
	if _adbeg.LatAttr < 0 {
		return _dcf.Errorf("%s\u002fm\u002eLatAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _adbeg.LatAttr)
	}
	if _adbeg.LatAttr >= 21600000 {
		return _dcf.Errorf("\u0025s\u002fm\u002eLatAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, _adbeg.LatAttr)
	}
	if _adbeg.LonAttr < 0 {
		return _dcf.Errorf("%s\u002fm\u002eLonAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _adbeg.LonAttr)
	}
	if _adbeg.LonAttr >= 21600000 {
		return _dcf.Errorf("\u0025s\u002fm\u002eLonAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, _adbeg.LonAttr)
	}
	if _adbeg.RevAttr < 0 {
		return _dcf.Errorf("%s\u002fm\u002eRevAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _adbeg.RevAttr)
	}
	if _adbeg.RevAttr >= 21600000 {
		return _dcf.Errorf("\u0025s\u002fm\u002eRevAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, _adbeg.RevAttr)
	}
	return nil
}

type ST_PitchFamily byte

// Validate validates the CT_ScRgbColor and its children
func (_bdee *CT_ScRgbColor) Validate() error { return _bdee.ValidateWithPath("CT_ScRgbColor") }
func (_ccbgd *CT_TableCellBorderStyle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_dceeg:
	for {
		_eafcf, _bdgac := d.Token()
		if _bdgac != nil {
			return _bdgac
		}
		switch _bgge := _eafcf.(type) {
		case _g.StartElement:
			switch _bgge.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "left"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "left"}:
				_ccbgd.Left = NewCT_ThemeableLineStyle()
				if _bfgbc := d.DecodeElement(_ccbgd.Left, &_bgge); _bfgbc != nil {
					return _bfgbc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "right"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "right"}:
				_ccbgd.Right = NewCT_ThemeableLineStyle()
				if _bdgbg := d.DecodeElement(_ccbgd.Right, &_bgge); _bdgbg != nil {
					return _bdgbg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "top"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "top"}:
				_ccbgd.Top = NewCT_ThemeableLineStyle()
				if _ddgeb := d.DecodeElement(_ccbgd.Top, &_bgge); _ddgeb != nil {
					return _ddgeb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bottom"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bottom"}:
				_ccbgd.Bottom = NewCT_ThemeableLineStyle()
				if _fdefa := d.DecodeElement(_ccbgd.Bottom, &_bgge); _fdefa != nil {
					return _fdefa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "insideH"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "insideH"}:
				_ccbgd.InsideH = NewCT_ThemeableLineStyle()
				if _dcfc := d.DecodeElement(_ccbgd.InsideH, &_bgge); _dcfc != nil {
					return _dcfc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "insideV"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "insideV"}:
				_ccbgd.InsideV = NewCT_ThemeableLineStyle()
				if _cadeea := d.DecodeElement(_ccbgd.InsideV, &_bgge); _cadeea != nil {
					return _cadeea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tl2br"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tl2br"}:
				_ccbgd.Tl2br = NewCT_ThemeableLineStyle()
				if _bdedg := d.DecodeElement(_ccbgd.Tl2br, &_bgge); _bdedg != nil {
					return _bdedg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tr2bl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tr2bl"}:
				_ccbgd.Tr2bl = NewCT_ThemeableLineStyle()
				if _cfffg := d.DecodeElement(_ccbgd.Tr2bl, &_bgge); _cfffg != nil {
					return _cfffg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_ccbgd.ExtLst = NewCT_OfficeArtExtensionList()
				if _fbeaf := d.DecodeElement(_ccbgd.ExtLst, &_bgge); _fbeaf != nil {
					return _fbeaf
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_TableCellBorderStyle \u0025v", _bgge.Name)
				if _degfe := d.Skip(); _degfe != nil {
					return _degfe
				}
			}
		case _g.EndElement:
			break _dceeg
		case _g.CharData:
		}
	}
	return nil
}
func (_aefdf *CT_TableGrid) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _aefdf.GridCol != nil {
		_bbadc := _g.StartElement{Name: _g.Name{Local: "a:gridCol"}}
		for _, _fdeeee := range _aefdf.GridCol {
			e.EncodeElement(_fdeeee, _bbadc)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

const (
	ST_LightRigTypeUnset         ST_LightRigType = 0
	ST_LightRigTypeLegacyFlat1   ST_LightRigType = 1
	ST_LightRigTypeLegacyFlat2   ST_LightRigType = 2
	ST_LightRigTypeLegacyFlat3   ST_LightRigType = 3
	ST_LightRigTypeLegacyFlat4   ST_LightRigType = 4
	ST_LightRigTypeLegacyNormal1 ST_LightRigType = 5
	ST_LightRigTypeLegacyNormal2 ST_LightRigType = 6
	ST_LightRigTypeLegacyNormal3 ST_LightRigType = 7
	ST_LightRigTypeLegacyNormal4 ST_LightRigType = 8
	ST_LightRigTypeLegacyHarsh1  ST_LightRigType = 9
	ST_LightRigTypeLegacyHarsh2  ST_LightRigType = 10
	ST_LightRigTypeLegacyHarsh3  ST_LightRigType = 11
	ST_LightRigTypeLegacyHarsh4  ST_LightRigType = 12
	ST_LightRigTypeThreePt       ST_LightRigType = 13
	ST_LightRigTypeBalanced      ST_LightRigType = 14
	ST_LightRigTypeSoft          ST_LightRigType = 15
	ST_LightRigTypeHarsh         ST_LightRigType = 16
	ST_LightRigTypeFlood         ST_LightRigType = 17
	ST_LightRigTypeContrasting   ST_LightRigType = 18
	ST_LightRigTypeMorning       ST_LightRigType = 19
	ST_LightRigTypeSunrise       ST_LightRigType = 20
	ST_LightRigTypeSunset        ST_LightRigType = 21
	ST_LightRigTypeChilly        ST_LightRigType = 22
	ST_LightRigTypeFreezing      ST_LightRigType = 23
	ST_LightRigTypeFlat          ST_LightRigType = 24
	ST_LightRigTypeTwoPt         ST_LightRigType = 25
	ST_LightRigTypeGlow          ST_LightRigType = 26
	ST_LightRigTypeBrightRoom    ST_LightRigType = 27
)

func (_cgbda *EG_TextUnderlineFill) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _cgbda.UFillTx != nil {
		_defff := _g.StartElement{Name: _g.Name{Local: "a:uFillTx"}}
		e.EncodeElement(_cgbda.UFillTx, _defff)
	}
	if _cgbda.UFill != nil {
		_cfaee := _g.StartElement{Name: _g.Name{Local: "a:uFill"}}
		e.EncodeElement(_cgbda.UFill, _cfaee)
	}
	return nil
}
func (_caaab *CT_Scene3D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_ceabf := _g.StartElement{Name: _g.Name{Local: "a:camera"}}
	e.EncodeElement(_caaab.Camera, _ceabf)
	_egab := _g.StartElement{Name: _g.Name{Local: "a:lightRig"}}
	e.EncodeElement(_caaab.LightRig, _egab)
	if _caaab.Backdrop != nil {
		_agcdc := _g.StartElement{Name: _g.Name{Local: "a:backdrop"}}
		e.EncodeElement(_caaab.Backdrop, _agcdc)
	}
	if _caaab.ExtLst != nil {
		_fbfeb := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_caaab.ExtLst, _fbfeb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_gcfdd ST_PresetCameraType) String() string {
	switch _gcfdd {
	case 0:
		return ""
	case 1:
		return "legacyObliqueTopLeft"
	case 2:
		return "legacyObliqueTop"
	case 3:
		return "legacyObliqueTopRight"
	case 4:
		return "legacyObliqueLeft"
	case 5:
		return "legacyObliqueFront"
	case 6:
		return "legacyObliqueRight"
	case 7:
		return "legacyObliqueBottomLeft"
	case 8:
		return "legacyObliqueBottom"
	case 9:
		return "legacyObliqueBottomRight"
	case 10:
		return "legacyPerspectiveTopLeft"
	case 11:
		return "legacyPerspectiveTop"
	case 12:
		return "legacyPerspectiveTopRight"
	case 13:
		return "legacyPerspectiveLeft"
	case 14:
		return "legacyPerspectiveFront"
	case 15:
		return "legacyPerspectiveRight"
	case 16:
		return "legacyPerspectiveBottomLeft"
	case 17:
		return "legacyPerspectiveBottom"
	case 18:
		return "legacyPerspectiveBottomRight"
	case 19:
		return "orthographicFront"
	case 20:
		return "isometricTopUp"
	case 21:
		return "isometricTopDown"
	case 22:
		return "isometricBottomUp"
	case 23:
		return "isometricBottomDown"
	case 24:
		return "isometricLeftUp"
	case 25:
		return "isometricLeftDown"
	case 26:
		return "isometricRightUp"
	case 27:
		return "isometricRightDown"
	case 28:
		return "isometricOffAxis1Left"
	case 29:
		return "isometricOffAxis1Right"
	case 30:
		return "isometricOffAxis1Top"
	case 31:
		return "isometricOffAxis2Left"
	case 32:
		return "isometricOffAxis2Right"
	case 33:
		return "isometricOffAxis2Top"
	case 34:
		return "isometricOffAxis3Left"
	case 35:
		return "isometricOffAxis3Right"
	case 36:
		return "isometricOffAxis3Bottom"
	case 37:
		return "isometricOffAxis4Left"
	case 38:
		return "isometricOffAxis4Right"
	case 39:
		return "isometricOffAxis4Bottom"
	case 40:
		return "obliqueTopLeft"
	case 41:
		return "obliqueTop"
	case 42:
		return "obliqueTopRight"
	case 43:
		return "obliqueLeft"
	case 44:
		return "obliqueRight"
	case 45:
		return "obliqueBottomLeft"
	case 46:
		return "obliqueBottom"
	case 47:
		return "obliqueBottomRight"
	case 48:
		return "perspectiveFront"
	case 49:
		return "perspectiveLeft"
	case 50:
		return "perspectiveRight"
	case 51:
		return "perspectiveAbove"
	case 52:
		return "perspectiveBelow"
	case 53:
		return "perspectiveAboveLeftFacing"
	case 54:
		return "perspectiveAboveRightFacing"
	case 55:
		return "perspectiveContrastingLeftFacing"
	case 56:
		return "perspectiveContrastingRightFacing"
	case 57:
		return "perspectiveHeroicLeftFacing"
	case 58:
		return "perspectiveHeroicRightFacing"
	case 59:
		return "perspectiveHeroicExtremeLeftFacing"
	case 60:
		return "perspectiveHeroicExtremeRightFacing"
	case 61:
		return "perspectiveRelaxed"
	case 62:
		return "perspectiveRelaxedModerately"
	}
	return ""
}
func (_cbfc *CT_EffectStyleList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_cggc:
	for {
		_dccde, _gcdgd := d.Token()
		if _gcdgd != nil {
			return _gcdgd
		}
		switch _affb := _dccde.(type) {
		case _g.StartElement:
			switch _affb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectStyle"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectStyle"}:
				_fccdc := NewCT_EffectStyleItem()
				if _ggde := d.DecodeElement(_fccdc, &_affb); _ggde != nil {
					return _ggde
				}
				_cbfc.EffectStyle = append(_cbfc.EffectStyle, _fccdc)
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_EffectStyleList\u0020\u0025v", _affb.Name)
				if _aafbdb := d.Skip(); _aafbdb != nil {
					return _aafbdb
				}
			}
		case _g.EndElement:
			break _cggc
		case _g.CharData:
		}
	}
	return nil
}
func (_gcfff *CT_Headers) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_egbgc:
	for {
		_ceca, _abdg := d.Token()
		if _abdg != nil {
			return _abdg
		}
		switch _gfbd := _ceca.(type) {
		case _g.StartElement:
			switch _gfbd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "header"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "header"}:
				var _dbgf string
				if _ceaaf := d.DecodeElement(&_dbgf, &_gfbd); _ceaaf != nil {
					return _ceaaf
				}
				_gcfff.Header = append(_gcfff.Header, _dbgf)
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_Headers\u0020\u0025v", _gfbd.Name)
				if _dbcb := d.Skip(); _dbcb != nil {
					return _dbcb
				}
			}
		case _g.EndElement:
			break _egbgc
		case _g.CharData:
		}
	}
	return nil
}
func (_ca *CT_AdjPoint2D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _daa := range start.Attr {
		if _daa.Name.Local == "x" {
			_dag, _fae := ParseUnionST_AdjCoordinate(_daa.Value)
			if _fae != nil {
				return _fae
			}
			_ca.XAttr = _dag
			continue
		}
		if _daa.Name.Local == "y" {
			_fabe, _cbce := ParseUnionST_AdjCoordinate(_daa.Value)
			if _cbce != nil {
				return _cbce
			}
			_ca.YAttr = _fabe
			continue
		}
	}
	for {
		_bbb, _dbg := d.Token()
		if _dbg != nil {
			return _dcf.Errorf("parsing\u0020CT_AdjPoint2D:\u0020\u0025s", _dbg)
		}
		if _aff, _bcdg := _bbb.(_g.EndElement); _bcdg && _aff.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_InverseGammaTransform and its children, prefixing error messages with path
func (_bedb *CT_InverseGammaTransform) ValidateWithPath(path string) error { return nil }
func NewAG_Locking() *AG_Locking                                           { _gg := &AG_Locking{}; return _gg }

type CT_ColorMappingOverride struct {
	Choice *CT_ColorMappingOverrideChoice
}
type ST_LightRigDirection byte

// ValidateWithPath validates the CT_CustomGeometry2D and its children, prefixing error messages with path
func (_bcgdd *CT_CustomGeometry2D) ValidateWithPath(path string) error {
	if _bcgdd.AvLst != nil {
		if _bdab := _bcgdd.AvLst.ValidateWithPath(path + "\u002fAvLst"); _bdab != nil {
			return _bdab
		}
	}
	if _bcgdd.GdLst != nil {
		if _aga := _bcgdd.GdLst.ValidateWithPath(path + "\u002fGdLst"); _aga != nil {
			return _aga
		}
	}
	if _bcgdd.AhLst != nil {
		if _ggcc := _bcgdd.AhLst.ValidateWithPath(path + "\u002fAhLst"); _ggcc != nil {
			return _ggcc
		}
	}
	if _bcgdd.CxnLst != nil {
		if _ddbe := _bcgdd.CxnLst.ValidateWithPath(path + "\u002fCxnLst"); _ddbe != nil {
			return _ddbe
		}
	}
	if _bcgdd.Rect != nil {
		if _agcac := _bcgdd.Rect.ValidateWithPath(path + "\u002fRect"); _agcac != nil {
			return _agcac
		}
	}
	if _daca := _bcgdd.PathLst.ValidateWithPath(path + "\u002fPathLst"); _daca != nil {
		return _daca
	}
	return nil
}
func (_faaab ST_FixedPercentage) String() string {
	if _faaab.ST_FixedPercentageDecimal != nil {
		return _dcf.Sprintf("\u0025v", *_faaab.ST_FixedPercentageDecimal)
	}
	if _faaab.ST_FixedPercentage != nil {
		return _faaab.ST_FixedPercentage.String()
	}
	return ""
}

type CT_BlendEffect struct {
	BlendAttr ST_BlendMode
	Cont      *CT_EffectContainer
}
type CT_TextBulletSizePoint struct{ ValAttr int32 }

func NewCT_NonVisualDrawingShapeProps() *CT_NonVisualDrawingShapeProps {
	_adbfg := &CT_NonVisualDrawingShapeProps{}
	return _adbfg
}
func (_cbecf ST_PresetMaterialType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_cccbab := _g.Attr{}
	_cccbab.Name = name
	switch _cbecf {
	case ST_PresetMaterialTypeUnset:
		_cccbab.Value = ""
	case ST_PresetMaterialTypeLegacyMatte:
		_cccbab.Value = "legacyMatte"
	case ST_PresetMaterialTypeLegacyPlastic:
		_cccbab.Value = "legacyPlastic"
	case ST_PresetMaterialTypeLegacyMetal:
		_cccbab.Value = "legacyMetal"
	case ST_PresetMaterialTypeLegacyWireframe:
		_cccbab.Value = "legacyWireframe"
	case ST_PresetMaterialTypeMatte:
		_cccbab.Value = "matte"
	case ST_PresetMaterialTypePlastic:
		_cccbab.Value = "plastic"
	case ST_PresetMaterialTypeMetal:
		_cccbab.Value = "metal"
	case ST_PresetMaterialTypeWarmMatte:
		_cccbab.Value = "warmMatte"
	case ST_PresetMaterialTypeTranslucentPowder:
		_cccbab.Value = "translucentPowder"
	case ST_PresetMaterialTypePowder:
		_cccbab.Value = "powder"
	case ST_PresetMaterialTypeDkEdge:
		_cccbab.Value = "dkEdge"
	case ST_PresetMaterialTypeSoftEdge:
		_cccbab.Value = "softEdge"
	case ST_PresetMaterialTypeClear:
		_cccbab.Value = "clear"
	case ST_PresetMaterialTypeFlat:
		_cccbab.Value = "flat"
	case ST_PresetMaterialTypeSoftmetal:
		_cccbab.Value = "softmetal"
	}
	return _cccbab, nil
}

// Validate validates the CT_GvmlUseShapeRectangle and its children
func (_baeef *CT_GvmlUseShapeRectangle) Validate() error {
	return _baeef.ValidateWithPath("CT_GvmlUseShapeRectangle")
}

// Validate validates the CT_ShapeProperties and its children
func (_dbcdg *CT_ShapeProperties) Validate() error {
	return _dbcdg.ValidateWithPath("CT_ShapeProperties")
}
func (_bgcfe *ST_PositiveFixedPercentage) Validate() error { return _bgcfe.ValidateWithPath("") }

const ST_TextBulletSizePercentPattern = "0\u002a\u0028\u00282\u005b5\u002d9\u005d\u0029\u007c([3\u002d9\u005d\u005b0-9\u005d\u0029\u007c\u0028\u005b1\u002d3\u005d\u005b0\u002d9\u005d[0\u002d9\u005d\u0029\u007c400\u0029\u0025"

func (_dfdd *CT_GraphicalObject) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dfdd.GraphicData = NewCT_GraphicalObjectData()
_eedg:
	for {
		_gcagdg, _dbedf := d.Token()
		if _dbedf != nil {
			return _dbedf
		}
		switch _gcbaae := _gcagdg.(type) {
		case _g.StartElement:
			switch _gcbaae.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "graphicData"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "graphicData"}:
				if _cfaeg := d.DecodeElement(_dfdd.GraphicData, &_gcbaae); _cfaeg != nil {
					return _cfaeg
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_GraphicalObject\u0020\u0025v", _gcbaae.Name)
				if _gaed := d.Skip(); _gaed != nil {
					return _gaed
				}
			}
		case _g.EndElement:
			break _eedg
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_AnimationChartElement and its children
func (_adf *CT_AnimationChartElement) Validate() error {
	return _adf.ValidateWithPath("CT_AnimationChartElement")
}

// ValidateWithPath validates the CT_TextParagraphProperties and its children, prefixing error messages with path
func (_eeged *CT_TextParagraphProperties) ValidateWithPath(path string) error {
	if _eeged.MarLAttr != nil {
		if *_eeged.MarLAttr < 0 {
			return _dcf.Errorf("\u0025s/m\u002eMarLAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_eeged.MarLAttr)
		}
		if *_eeged.MarLAttr > 51206400 {
			return _dcf.Errorf("\u0025s\u002fm\u002eMarLAttr\u0020must\u0020be\u0020\u003c\u003d\u002051206400\u0020\u0028have\u0020\u0025v\u0029", path, *_eeged.MarLAttr)
		}
	}
	if _eeged.MarRAttr != nil {
		if *_eeged.MarRAttr < 0 {
			return _dcf.Errorf("\u0025s/m\u002eMarRAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_eeged.MarRAttr)
		}
		if *_eeged.MarRAttr > 51206400 {
			return _dcf.Errorf("\u0025s\u002fm\u002eMarRAttr\u0020must\u0020be\u0020\u003c\u003d\u002051206400\u0020\u0028have\u0020\u0025v\u0029", path, *_eeged.MarRAttr)
		}
	}
	if _eeged.LvlAttr != nil {
		if *_eeged.LvlAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eLvlAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_eeged.LvlAttr)
		}
		if *_eeged.LvlAttr > 8 {
			return _dcf.Errorf("%s\u002fm\u002eLvlAttr\u0020must\u0020be\u0020\u003c=\u00208\u0020\u0028have\u0020\u0025v\u0029", path, *_eeged.LvlAttr)
		}
	}
	if _eeged.IndentAttr != nil {
		if *_eeged.IndentAttr < -51206400 {
			return _dcf.Errorf("\u0025s/m\u002eIndentAttr\u0020must\u0020be\u0020\u003e\u003d\u0020\u002d51206400\u0020\u0028have\u0020\u0025v\u0029", path, *_eeged.IndentAttr)
		}
		if *_eeged.IndentAttr > 51206400 {
			return _dcf.Errorf("\u0025s\u002fm.IndentAttr\u0020must\u0020be \u003c\u003d\u002051206400 \u0028have\u0020\u0025v\u0029", path, *_eeged.IndentAttr)
		}
	}
	if _ebee := _eeged.AlgnAttr.ValidateWithPath(path + "\u002fAlgnAttr"); _ebee != nil {
		return _ebee
	}
	if _eeged.DefTabSzAttr != nil {
		if _aaagb := _eeged.DefTabSzAttr.ValidateWithPath(path + "\u002fDefTabSzAttr"); _aaagb != nil {
			return _aaagb
		}
	}
	if _ggfaa := _eeged.FontAlgnAttr.ValidateWithPath(path + "\u002fFontAlgnAttr"); _ggfaa != nil {
		return _ggfaa
	}
	if _eeged.LnSpc != nil {
		if _caggg := _eeged.LnSpc.ValidateWithPath(path + "\u002fLnSpc"); _caggg != nil {
			return _caggg
		}
	}
	if _eeged.SpcBef != nil {
		if _eafd := _eeged.SpcBef.ValidateWithPath(path + "\u002fSpcBef"); _eafd != nil {
			return _eafd
		}
	}
	if _eeged.SpcAft != nil {
		if _gebdf := _eeged.SpcAft.ValidateWithPath(path + "\u002fSpcAft"); _gebdf != nil {
			return _gebdf
		}
	}
	if _eeged.BuClrTx != nil {
		if _fffb := _eeged.BuClrTx.ValidateWithPath(path + "\u002fBuClrTx"); _fffb != nil {
			return _fffb
		}
	}
	if _eeged.BuClr != nil {
		if _bffc := _eeged.BuClr.ValidateWithPath(path + "\u002fBuClr"); _bffc != nil {
			return _bffc
		}
	}
	if _eeged.BuSzTx != nil {
		if _aface := _eeged.BuSzTx.ValidateWithPath(path + "\u002fBuSzTx"); _aface != nil {
			return _aface
		}
	}
	if _eeged.BuSzPct != nil {
		if _ffbea := _eeged.BuSzPct.ValidateWithPath(path + "\u002fBuSzPct"); _ffbea != nil {
			return _ffbea
		}
	}
	if _eeged.BuSzPts != nil {
		if _ebcdf := _eeged.BuSzPts.ValidateWithPath(path + "\u002fBuSzPts"); _ebcdf != nil {
			return _ebcdf
		}
	}
	if _eeged.BuFontTx != nil {
		if _gfgad := _eeged.BuFontTx.ValidateWithPath(path + "\u002fBuFontTx"); _gfgad != nil {
			return _gfgad
		}
	}
	if _eeged.BuFont != nil {
		if _fgefd := _eeged.BuFont.ValidateWithPath(path + "\u002fBuFont"); _fgefd != nil {
			return _fgefd
		}
	}
	if _eeged.BuNone != nil {
		if _efbcg := _eeged.BuNone.ValidateWithPath(path + "\u002fBuNone"); _efbcg != nil {
			return _efbcg
		}
	}
	if _eeged.BuAutoNum != nil {
		if _geddf := _eeged.BuAutoNum.ValidateWithPath(path + "\u002fBuAutoNum"); _geddf != nil {
			return _geddf
		}
	}
	if _eeged.BuChar != nil {
		if _efefd := _eeged.BuChar.ValidateWithPath(path + "\u002fBuChar"); _efefd != nil {
			return _efefd
		}
	}
	if _eeged.BuBlip != nil {
		if _gddag := _eeged.BuBlip.ValidateWithPath(path + "\u002fBuBlip"); _gddag != nil {
			return _gddag
		}
	}
	if _eeged.TabLst != nil {
		if _dfgfa := _eeged.TabLst.ValidateWithPath(path + "\u002fTabLst"); _dfgfa != nil {
			return _dfgfa
		}
	}
	if _eeged.DefRPr != nil {
		if _ddcbg := _eeged.DefRPr.ValidateWithPath(path + "\u002fDefRPr"); _ddcbg != nil {
			return _ddcbg
		}
	}
	if _eeged.ExtLst != nil {
		if _dcbgc := _eeged.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dcbgc != nil {
			return _dcbgc
		}
	}
	return nil
}
func (_gadda *CT_EffectStyleItem) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _gadda.EffectLst != nil {
		_cdgff := _g.StartElement{Name: _g.Name{Local: "a:effectLst"}}
		e.EncodeElement(_gadda.EffectLst, _cdgff)
	}
	if _gadda.EffectDag != nil {
		_dgdfc := _g.StartElement{Name: _g.Name{Local: "a:effectDag"}}
		e.EncodeElement(_gadda.EffectDag, _dgdfc)
	}
	if _gadda.Scene3d != nil {
		_agad := _g.StartElement{Name: _g.Name{Local: "a:scene3d"}}
		e.EncodeElement(_gadda.Scene3d, _agad)
	}
	if _gadda.Sp3d != nil {
		_gbfe := _g.StartElement{Name: _g.Name{Local: "a:sp3d"}}
		e.EncodeElement(_gadda.Sp3d, _gbfe)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_TableRow() *CT_TableRow { _gdeeea := &CT_TableRow{}; return _gdeeea }
func NewCT_TextBlipBullet() *CT_TextBlipBullet {
	_eefg := &CT_TextBlipBullet{}
	_eefg.Blip = NewCT_Blip()
	return _eefg
}

// Validate validates the CT_OuterShadowEffect and its children
func (_feafa *CT_OuterShadowEffect) Validate() error {
	return _feafa.ValidateWithPath("CT_OuterShadowEffect")
}

// ValidateWithPath validates the CT_Path2DClose and its children, prefixing error messages with path
func (_ebggf *CT_Path2DClose) ValidateWithPath(path string) error { return nil }

type CT_OfficeStyleSheet struct {
	NameAttr          *string
	ThemeElements     *CT_BaseStyles
	ObjectDefaults    *CT_ObjectStyleDefaults
	ExtraClrSchemeLst *CT_ColorSchemeList
	CustClrLst        *CT_CustomColorList
	ExtLst            *CT_OfficeArtExtensionList
}

func (_egafge *ST_RectAlignment) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_egafge = 0
	case "tl":
		*_egafge = 1
	case "t":
		*_egafge = 2
	case "tr":
		*_egafge = 3
	case "l":
		*_egafge = 4
	case "ctr":
		*_egafge = 5
	case "r":
		*_egafge = 6
	case "bl":
		*_egafge = 7
	case "b":
		*_egafge = 8
	case "br":
		*_egafge = 9
	}
	return nil
}
func (_cgga *EG_LineFillProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_cggcc:
	for {
		_dbdfc, _acbdc := d.Token()
		if _acbdc != nil {
			return _acbdc
		}
		switch _cfcab := _dbdfc.(type) {
		case _g.StartElement:
			switch _cfcab.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_cgga.NoFill = NewCT_NoFillProperties()
				if _fdggdc := d.DecodeElement(_cgga.NoFill, &_cfcab); _fdggdc != nil {
					return _fdggdc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_cgga.SolidFill = NewCT_SolidColorFillProperties()
				if _ggffe := d.DecodeElement(_cgga.SolidFill, &_cfcab); _ggffe != nil {
					return _ggffe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_cgga.GradFill = NewCT_GradientFillProperties()
				if _beagd := d.DecodeElement(_cgga.GradFill, &_cfcab); _beagd != nil {
					return _beagd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_cgga.PattFill = NewCT_PatternFillProperties()
				if _efda := d.DecodeElement(_cgga.PattFill, &_cfcab); _efda != nil {
					return _efda
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on EG_LineFillProperties\u0020\u0025v", _cfcab.Name)
				if _gcgee := d.Skip(); _gcgee != nil {
					return _gcgee
				}
			}
		case _g.EndElement:
			break _cggcc
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_BaseStylesOverride and its children, prefixing error messages with path
func (_gccgg *CT_BaseStylesOverride) ValidateWithPath(path string) error {
	if _gccgg.ClrScheme != nil {
		if _fbeg := _gccgg.ClrScheme.ValidateWithPath(path + "\u002fClrScheme"); _fbeg != nil {
			return _fbeg
		}
	}
	if _gccgg.FontScheme != nil {
		if _bebc := _gccgg.FontScheme.ValidateWithPath(path + "/FontScheme"); _bebc != nil {
			return _bebc
		}
	}
	if _gccgg.FmtScheme != nil {
		if _acec := _gccgg.FmtScheme.ValidateWithPath(path + "\u002fFmtScheme"); _acec != nil {
			return _acec
		}
	}
	return nil
}
func (_fdgfab *ST_BlackWhiteMode) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gfbcd, _cacbf := d.Token()
	if _cacbf != nil {
		return _cacbf
	}
	if _abbgg, _aggce := _gfbcd.(_g.EndElement); _aggce && _abbgg.Name == start.Name {
		*_fdgfab = 1
		return nil
	}
	if _afecg, _fbeae := _gfbcd.(_g.CharData); !_fbeae {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gfbcd)
	} else {
		switch string(_afecg) {
		case "":
			*_fdgfab = 0
		case "clr":
			*_fdgfab = 1
		case "auto":
			*_fdgfab = 2
		case "gray":
			*_fdgfab = 3
		case "ltGray":
			*_fdgfab = 4
		case "invGray":
			*_fdgfab = 5
		case "grayWhite":
			*_fdgfab = 6
		case "blackGray":
			*_fdgfab = 7
		case "blackWhite":
			*_fdgfab = 8
		case "black":
			*_fdgfab = 9
		case "white":
			*_fdgfab = 10
		case "hidden":
			*_fdgfab = 11
		}
	}
	_gfbcd, _cacbf = d.Token()
	if _cacbf != nil {
		return _cacbf
	}
	if _eaedg, _gecgaa := _gfbcd.(_g.EndElement); _gecgaa && _eaedg.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gfbcd)
}
func (_ffgda *CT_LuminanceEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _gdaca := range start.Attr {
		if _gdaca.Name.Local == "bright" {
			_ebgbg, _cege := ParseUnionST_FixedPercentage(_gdaca.Value)
			if _cege != nil {
				return _cege
			}
			_ffgda.BrightAttr = &_ebgbg
			continue
		}
		if _gdaca.Name.Local == "contrast" {
			_geegb, _dceab := ParseUnionST_FixedPercentage(_gdaca.Value)
			if _dceab != nil {
				return _dceab
			}
			_ffgda.ContrastAttr = &_geegb
			continue
		}
	}
	for {
		_facga, _bfegb := d.Token()
		if _bfegb != nil {
			return _dcf.Errorf("parsing\u0020CT_LuminanceEffect:\u0020\u0025s", _bfegb)
		}
		if _cbgdgb, _bbgde := _facga.(_g.EndElement); _bbgde && _cbgdgb.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_TextCapsTypeUnset ST_TextCapsType = 0
	ST_TextCapsTypeNone  ST_TextCapsType = 1
	ST_TextCapsTypeSmall ST_TextCapsType = 2
	ST_TextCapsTypeAll   ST_TextCapsType = 3
)

func (_fbbge *CT_SchemeColor) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fbbge.ValAttr = ST_SchemeColorVal(1)
	for _, _ebge := range start.Attr {
		if _ebge.Name.Local == "val" {
			_fbbge.ValAttr.UnmarshalXMLAttr(_ebge)
			continue
		}
	}
_fbbee:
	for {
		_cbdec, _dfcc := d.Token()
		if _dfcc != nil {
			return _dfcc
		}
		switch _cddgd := _cbdec.(type) {
		case _g.StartElement:
			switch _cddgd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_cabda := NewEG_ColorTransform()
				_cabda.Tint = NewCT_PositiveFixedPercentage()
				if _eaecd := d.DecodeElement(_cabda.Tint, &_cddgd); _eaecd != nil {
					return _eaecd
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _cabda)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "shade"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "shade"}:
				_acfaa := NewEG_ColorTransform()
				_acfaa.Shade = NewCT_PositiveFixedPercentage()
				if _eabd := d.DecodeElement(_acfaa.Shade, &_cddgd); _eabd != nil {
					return _eabd
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _acfaa)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "comp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "comp"}:
				_bebcb := NewEG_ColorTransform()
				_bebcb.Comp = NewCT_ComplementTransform()
				if _caaga := d.DecodeElement(_bebcb.Comp, &_cddgd); _caaga != nil {
					return _caaga
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _bebcb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "inv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "inv"}:
				_gcedc := NewEG_ColorTransform()
				_gcedc.Inv = NewCT_InverseTransform()
				if _begbc := d.DecodeElement(_gcedc.Inv, &_cddgd); _begbc != nil {
					return _begbc
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _gcedc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gray"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gray"}:
				_gcbfcf := NewEG_ColorTransform()
				_gcbfcf.Gray = NewCT_GrayscaleTransform()
				if _dgbe := d.DecodeElement(_gcbfcf.Gray, &_cddgd); _dgbe != nil {
					return _dgbe
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _gcbfcf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alpha"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alpha"}:
				_edeff := NewEG_ColorTransform()
				_edeff.Alpha = NewCT_PositiveFixedPercentage()
				if _efabd := d.DecodeElement(_edeff.Alpha, &_cddgd); _efabd != nil {
					return _efabd
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _edeff)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaOff"}:
				_bcdb := NewEG_ColorTransform()
				_bcdb.AlphaOff = NewCT_FixedPercentage()
				if _baefc := d.DecodeElement(_bcdb.AlphaOff, &_cddgd); _baefc != nil {
					return _baefc
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _bcdb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_dabg := NewEG_ColorTransform()
				_dabg.AlphaMod = NewCT_PositivePercentage()
				if _eaced := d.DecodeElement(_dabg.AlphaMod, &_cddgd); _eaced != nil {
					return _eaced
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _dabg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hue"}:
				_bgcac := NewEG_ColorTransform()
				_bgcac.Hue = NewCT_PositiveFixedAngle()
				if _ffdad := d.DecodeElement(_bgcac.Hue, &_cddgd); _ffdad != nil {
					return _ffdad
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _bgcac)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueOff"}:
				_fgdc := NewEG_ColorTransform()
				_fgdc.HueOff = NewCT_Angle()
				if _fcffgb := d.DecodeElement(_fgdc.HueOff, &_cddgd); _fcffgb != nil {
					return _fcffgb
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _fgdc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueMod"}:
				_geegcg := NewEG_ColorTransform()
				_geegcg.HueMod = NewCT_PositivePercentage()
				if _bcgef := d.DecodeElement(_geegcg.HueMod, &_cddgd); _bcgef != nil {
					return _bcgef
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _geegcg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sat"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sat"}:
				_eadba := NewEG_ColorTransform()
				_eadba.Sat = NewCT_Percentage()
				if _gcdagd := d.DecodeElement(_eadba.Sat, &_cddgd); _gcdagd != nil {
					return _gcdagd
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _eadba)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satOff"}:
				_eedde := NewEG_ColorTransform()
				_eedde.SatOff = NewCT_Percentage()
				if _caadb := d.DecodeElement(_eedde.SatOff, &_cddgd); _caadb != nil {
					return _caadb
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _eedde)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satMod"}:
				_bdgab := NewEG_ColorTransform()
				_bdgab.SatMod = NewCT_Percentage()
				if _aada := d.DecodeElement(_bdgab.SatMod, &_cddgd); _aada != nil {
					return _aada
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _bdgab)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_cddef := NewEG_ColorTransform()
				_cddef.Lum = NewCT_Percentage()
				if _bacfac := d.DecodeElement(_cddef.Lum, &_cddgd); _bacfac != nil {
					return _bacfac
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _cddef)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumOff"}:
				_dbaea := NewEG_ColorTransform()
				_dbaea.LumOff = NewCT_Percentage()
				if _abcd := d.DecodeElement(_dbaea.LumOff, &_cddgd); _abcd != nil {
					return _abcd
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _dbaea)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumMod"}:
				_eaefa := NewEG_ColorTransform()
				_eaefa.LumMod = NewCT_Percentage()
				if _cgabe := d.DecodeElement(_eaefa.LumMod, &_cddgd); _cgabe != nil {
					return _cgabe
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _eaefa)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "red"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "red"}:
				_bdffc := NewEG_ColorTransform()
				_bdffc.Red = NewCT_Percentage()
				if _agfda := d.DecodeElement(_bdffc.Red, &_cddgd); _agfda != nil {
					return _agfda
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _bdffc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redOff"}:
				_bfcecd := NewEG_ColorTransform()
				_bfcecd.RedOff = NewCT_Percentage()
				if _dedbb := d.DecodeElement(_bfcecd.RedOff, &_cddgd); _dedbb != nil {
					return _dedbb
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _bfcecd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redMod"}:
				_ccfg := NewEG_ColorTransform()
				_ccfg.RedMod = NewCT_Percentage()
				if _faagg := d.DecodeElement(_ccfg.RedMod, &_cddgd); _faagg != nil {
					return _faagg
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _ccfg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "green"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "green"}:
				_afcae := NewEG_ColorTransform()
				_afcae.Green = NewCT_Percentage()
				if _gfed := d.DecodeElement(_afcae.Green, &_cddgd); _gfed != nil {
					return _gfed
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _afcae)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenOff"}:
				_dbfc := NewEG_ColorTransform()
				_dbfc.GreenOff = NewCT_Percentage()
				if _bcffb := d.DecodeElement(_dbfc.GreenOff, &_cddgd); _bcffb != nil {
					return _bcffb
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _dbfc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenMod"}:
				_ecgfff := NewEG_ColorTransform()
				_ecgfff.GreenMod = NewCT_Percentage()
				if _dcccb := d.DecodeElement(_ecgfff.GreenMod, &_cddgd); _dcccb != nil {
					return _dcccb
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _ecgfff)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blue"}:
				_gefgd := NewEG_ColorTransform()
				_gefgd.Blue = NewCT_Percentage()
				if _cebgda := d.DecodeElement(_gefgd.Blue, &_cddgd); _cebgda != nil {
					return _cebgda
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _gefgd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueOff"}:
				_bfdgc := NewEG_ColorTransform()
				_bfdgc.BlueOff = NewCT_Percentage()
				if _gfgeb := d.DecodeElement(_bfdgc.BlueOff, &_cddgd); _gfgeb != nil {
					return _gfgeb
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _bfdgc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueMod"}:
				_cgfad := NewEG_ColorTransform()
				_cgfad.BlueMod = NewCT_Percentage()
				if _eddgg := d.DecodeElement(_cgfad.BlueMod, &_cddgd); _eddgg != nil {
					return _eddgg
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _cgfad)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gamma"}:
				_facd := NewEG_ColorTransform()
				_facd.Gamma = NewCT_GammaTransform()
				if _gbge := d.DecodeElement(_facd.Gamma, &_cddgd); _gbge != nil {
					return _gbge
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _facd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "invGamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "invGamma"}:
				_gaccd := NewEG_ColorTransform()
				_gaccd.InvGamma = NewCT_InverseGammaTransform()
				if _cbccca := d.DecodeElement(_gaccd.InvGamma, &_cddgd); _cbccca != nil {
					return _cbccca
				}
				_fbbge.EG_ColorTransform = append(_fbbge.EG_ColorTransform, _gaccd)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SchemeColor\u0020\u0025v", _cddgd.Name)
				if _bcadg := d.Skip(); _bcadg != nil {
					return _bcadg
				}
			}
		case _g.EndElement:
			break _fbbee
		case _g.CharData:
		}
	}
	return nil
}
func (_ebg *CT_Angle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _edc := range start.Attr {
		if _edc.Name.Local == "val" {
			_bea, _gdf := _e.ParseInt(_edc.Value, 10, 32)
			if _gdf != nil {
				return _gdf
			}
			_ebg.ValAttr = int32(_bea)
			continue
		}
	}
	for {
		_fec, _gbgc := d.Token()
		if _gbgc != nil {
			return _dcf.Errorf("parsing\u0020CT_Angle: \u0025s", _gbgc)
		}
		if _fca, _eecb := _fec.(_g.EndElement); _eecb && _fca.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_LuminanceEffect struct {
	BrightAttr   *ST_FixedPercentage
	ContrastAttr *ST_FixedPercentage
}

func NewCT_ShapeProperties() *CT_ShapeProperties { _dcfba := &CT_ShapeProperties{}; return _dcfba }

// Validate validates the CT_TextBodyProperties and its children
func (_dcadb *CT_TextBodyProperties) Validate() error {
	return _dcadb.ValidateWithPath("CT_TextBodyProperties")
}
func NewCT_QuickTimeFile() *CT_QuickTimeFile { _dedd := &CT_QuickTimeFile{}; return _dedd }
func (_gaedg *CT_TextNoBullet) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ecfgcd ST_Coordinate32) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _ecfgcd.ST_Coordinate32Unqualified != nil {
		e.EncodeToken(_g.CharData(_dcf.Sprintf("\u0025d", *_ecfgcd.ST_Coordinate32Unqualified)))
	}
	if _ecfgcd.ST_UniversalMeasure != nil {
		e.EncodeToken(_g.CharData(*_ecfgcd.ST_UniversalMeasure))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}
func (_bdagd *CT_NonVisualContentPartProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _bdagd.IsCommentAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "isComment"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_bdagd.IsCommentAttr))})
	}
	e.EncodeToken(start)
	if _bdagd.CpLocks != nil {
		_eafc := _g.StartElement{Name: _g.Name{Local: "a:cpLocks"}}
		e.EncodeElement(_bdagd.CpLocks, _eafc)
	}
	if _bdagd.ExtLst != nil {
		_dgca := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_bdagd.ExtLst, _dgca)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_gfbbd *CT_TileInfoProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _gfbbd.TxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "tx"}, Value: _dcf.Sprintf("\u0025v", *_gfbbd.TxAttr)})
	}
	if _gfbbd.TyAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "ty"}, Value: _dcf.Sprintf("\u0025v", *_gfbbd.TyAttr)})
	}
	if _gfbbd.SxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sx"}, Value: _dcf.Sprintf("\u0025v", *_gfbbd.SxAttr)})
	}
	if _gfbbd.SyAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sy"}, Value: _dcf.Sprintf("\u0025v", *_gfbbd.SyAttr)})
	}
	if _gfbbd.FlipAttr != ST_TileFlipModeUnset {
		_dcdcd, _cadcc := _gfbbd.FlipAttr.MarshalXMLAttr(_g.Name{Local: "flip"})
		if _cadcc != nil {
			return _cadcc
		}
		start.Attr = append(start.Attr, _dcdcd)
	}
	if _gfbbd.AlgnAttr != ST_RectAlignmentUnset {
		_bgecab, _ffgfe := _gfbbd.AlgnAttr.MarshalXMLAttr(_g.Name{Local: "algn"})
		if _ffgfe != nil {
			return _ffgfe
		}
		start.Attr = append(start.Attr, _bgecab)
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_FillStyleList and its children
func (_eedfc *CT_FillStyleList) Validate() error { return _eedfc.ValidateWithPath("CT_FillStyleList") }

type CT_FontCollection struct {
	Latin  *CT_TextFont
	Ea     *CT_TextFont
	Cs     *CT_TextFont
	Font   []*CT_SupplementalFont
	ExtLst *CT_OfficeArtExtensionList
}

// Validate validates the CT_Scene3D and its children
func (_fgbga *CT_Scene3D) Validate() error { return _fgbga.ValidateWithPath("CT_Scene3D") }

// ValidateWithPath validates the CT_DefaultShapeDefinition and its children, prefixing error messages with path
func (_cbda *CT_DefaultShapeDefinition) ValidateWithPath(path string) error {
	if _fdga := _cbda.SpPr.ValidateWithPath(path + "\u002fSpPr"); _fdga != nil {
		return _fdga
	}
	if _fbef := _cbda.BodyPr.ValidateWithPath(path + "\u002fBodyPr"); _fbef != nil {
		return _fbef
	}
	if _edfg := _cbda.LstStyle.ValidateWithPath(path + "\u002fLstStyle"); _edfg != nil {
		return _edfg
	}
	if _cbda.Style != nil {
		if _aead := _cbda.Style.ValidateWithPath(path + "\u002fStyle"); _aead != nil {
			return _aead
		}
	}
	if _cbda.ExtLst != nil {
		if _aed := _cbda.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _aed != nil {
			return _aed
		}
	}
	return nil
}
func (_feda *CT_BackgroundFillStyleList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_ebgc:
	for {
		_bfag, _cbcbc := d.Token()
		if _cbcbc != nil {
			return _cbcbc
		}
		switch _bbbf := _bfag.(type) {
		case _g.StartElement:
			switch _bbbf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_ecb := NewEG_FillProperties()
				_ecb.NoFill = NewCT_NoFillProperties()
				if _bebg := d.DecodeElement(_ecb.NoFill, &_bbbf); _bebg != nil {
					return _bebg
				}
				_feda.EG_FillProperties = append(_feda.EG_FillProperties, _ecb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_aeef := NewEG_FillProperties()
				_aeef.SolidFill = NewCT_SolidColorFillProperties()
				if _fad := d.DecodeElement(_aeef.SolidFill, &_bbbf); _fad != nil {
					return _fad
				}
				_feda.EG_FillProperties = append(_feda.EG_FillProperties, _aeef)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_ddgd := NewEG_FillProperties()
				_ddgd.GradFill = NewCT_GradientFillProperties()
				if _dfeg := d.DecodeElement(_ddgd.GradFill, &_bbbf); _dfeg != nil {
					return _dfeg
				}
				_feda.EG_FillProperties = append(_feda.EG_FillProperties, _ddgd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_dcab := NewEG_FillProperties()
				_dcab.BlipFill = NewCT_BlipFillProperties()
				if _gfa := d.DecodeElement(_dcab.BlipFill, &_bbbf); _gfa != nil {
					return _gfa
				}
				_feda.EG_FillProperties = append(_feda.EG_FillProperties, _dcab)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_cdb := NewEG_FillProperties()
				_cdb.PattFill = NewCT_PatternFillProperties()
				if _aab := d.DecodeElement(_cdb.PattFill, &_bbbf); _aab != nil {
					return _aab
				}
				_feda.EG_FillProperties = append(_feda.EG_FillProperties, _cdb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_gega := NewEG_FillProperties()
				_gega.GrpFill = NewCT_GroupFillProperties()
				if _eeag := d.DecodeElement(_gega.GrpFill, &_bbbf); _eeag != nil {
					return _eeag
				}
				_feda.EG_FillProperties = append(_feda.EG_FillProperties, _gega)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BackgroundFillStyleList\u0020\u0025v", _bbbf.Name)
				if _ece := d.Skip(); _ece != nil {
					return _ece
				}
			}
		case _g.EndElement:
			break _ebgc
		case _g.CharData:
		}
	}
	return nil
}
func (_agacb ST_TextWrappingType) Validate() error { return _agacb.ValidateWithPath("") }
func NewCT_ScRgbColor() *CT_ScRgbColor             { _ggca := &CT_ScRgbColor{}; return _ggca }
func (_gaec *CT_BackgroundFormatting) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _gaec.NoFill != nil {
		_aafg := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_gaec.NoFill, _aafg)
	}
	if _gaec.SolidFill != nil {
		_bfae := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_gaec.SolidFill, _bfae)
	}
	if _gaec.GradFill != nil {
		_ebag := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_gaec.GradFill, _ebag)
	}
	if _gaec.BlipFill != nil {
		_gbf := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
		e.EncodeElement(_gaec.BlipFill, _gbf)
	}
	if _gaec.PattFill != nil {
		_fage := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_gaec.PattFill, _fage)
	}
	if _gaec.GrpFill != nil {
		_bbc := _g.StartElement{Name: _g.Name{Local: "a:grpFill"}}
		e.EncodeElement(_gaec.GrpFill, _bbc)
	}
	if _gaec.EffectLst != nil {
		_dee := _g.StartElement{Name: _g.Name{Local: "a:effectLst"}}
		e.EncodeElement(_gaec.EffectLst, _dee)
	}
	if _gaec.EffectDag != nil {
		_egga := _g.StartElement{Name: _g.Name{Local: "a:effectDag"}}
		e.EncodeElement(_gaec.EffectDag, _egga)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_PositiveFixedPercentage() *CT_PositiveFixedPercentage {
	_adbd := &CT_PositiveFixedPercentage{}
	return _adbd
}
func (_a *AG_Blob) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fa := range start.Attr {
		if _fa.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _fa.Name.Local == "embed" {
			_bb, _ae := _fa.Value, error(nil)
			if _ae != nil {
				return _ae
			}
			_a.EmbedAttr = &_bb
			continue
		}
		if _fa.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _fa.Name.Local == "link" {
			_db, _ba := _fa.Value, error(nil)
			if _ba != nil {
				return _ba
			}
			_a.LinkAttr = &_db
			continue
		}
	}
	for {
		_ff, _eb := d.Token()
		if _eb != nil {
			return _dcf.Errorf("parsing\u0020AG_Blob:\u0020\u0025s", _eb)
		}
		if _gd, _eg := _ff.(_g.EndElement); _eg && _gd.Name == start.Name {
			break
		}
	}
	return nil
}

// ST_PositivePercentage is a union type
type ST_PositivePercentage struct {
	ST_PositivePercentageDecimal *int32
	ST_PositivePercentage        *ST_Percentage
}

func NewCT_FillOverlayEffect() *CT_FillOverlayEffect {
	_dbef := &CT_FillOverlayEffect{}
	_dbef.BlendAttr = ST_BlendMode(1)
	return _dbef
}
func NewCT_PathShadeProperties() *CT_PathShadeProperties {
	_dacfd := &CT_PathShadeProperties{}
	return _dacfd
}

type CT_TablePropertiesChoice struct {
	TableStyle   *CT_TableStyle
	TableStyleId *string
}

// Validate validates the EG_LineDashProperties and its children
func (_gafedb *EG_LineDashProperties) Validate() error {
	return _gafedb.ValidateWithPath("EG_LineDashProperties")
}

type CT_XYAdjustHandle struct {
	GdRefXAttr *string
	MinXAttr   *ST_AdjCoordinate
	MaxXAttr   *ST_AdjCoordinate
	GdRefYAttr *string
	MinYAttr   *ST_AdjCoordinate
	MaxYAttr   *ST_AdjCoordinate
	Pos        *CT_AdjPoint2D
}

// Validate validates the CT_Path2DLineTo and its children
func (_dfgag *CT_Path2DLineTo) Validate() error { return _dfgag.ValidateWithPath("CT_Path2DLineTo") }

type CT_EffectProperties struct {
	EffectLst *CT_EffectList
	EffectDag *CT_EffectContainer
}
type CT_TextFont struct {
	TypefaceAttr    string
	PanoseAttr      *string
	PitchFamilyAttr ST_PitchFamily
	CharsetAttr     *int8
}

// ValidateWithPath validates the CT_BlendEffect and its children, prefixing error messages with path
func (_daac *CT_BlendEffect) ValidateWithPath(path string) error {
	if _daac.BlendAttr == ST_BlendModeUnset {
		return _dcf.Errorf("\u0025s\u002fBlendAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _ebec := _daac.BlendAttr.ValidateWithPath(path + "\u002fBlendAttr"); _ebec != nil {
		return _ebec
	}
	if _egdf := _daac.Cont.ValidateWithPath(path + "\u002fCont"); _egdf != nil {
		return _egdf
	}
	return nil
}
func (_bedg *CT_LineEndProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _bedg.TypeAttr != ST_LineEndTypeUnset {
		_efcgcf, _gedab := _bedg.TypeAttr.MarshalXMLAttr(_g.Name{Local: "type"})
		if _gedab != nil {
			return _gedab
		}
		start.Attr = append(start.Attr, _efcgcf)
	}
	if _bedg.WAttr != ST_LineEndWidthUnset {
		_dadee, _fdbb := _bedg.WAttr.MarshalXMLAttr(_g.Name{Local: "w"})
		if _fdbb != nil {
			return _fdbb
		}
		start.Attr = append(start.Attr, _dadee)
	}
	if _bedg.LenAttr != ST_LineEndLengthUnset {
		_ceaae, _acfb := _bedg.LenAttr.MarshalXMLAttr(_g.Name{Local: "len"})
		if _acfb != nil {
			return _acfb
		}
		start.Attr = append(start.Attr, _ceaae)
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_FillProperties struct {
	NoFill    *CT_NoFillProperties
	SolidFill *CT_SolidColorFillProperties
	GradFill  *CT_GradientFillProperties
	BlipFill  *CT_BlipFillProperties
	PattFill  *CT_PatternFillProperties
	GrpFill   *CT_GroupFillProperties
}

// ValidateWithPath validates the CT_PositivePercentage and its children, prefixing error messages with path
func (_ggagfb *CT_PositivePercentage) ValidateWithPath(path string) error {
	if _eedcg := _ggagfb.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _eedcg != nil {
		return _eedcg
	}
	return nil
}
func (_fgcbf *ST_AnimationDgmBuildType) ValidateWithPath(path string) error {
	_cdcecb := []string{}
	if _fgcbf.ST_AnimationBuildType != ST_AnimationBuildTypeUnset {
		_cdcecb = append(_cdcecb, "ST_AnimationBuildType")
	}
	if _fgcbf.ST_AnimationDgmOnlyBuildType != ST_AnimationDgmOnlyBuildTypeUnset {
		_cdcecb = append(_cdcecb, "ST_AnimationDgmOnlyBuildType")
	}
	if len(_cdcecb) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _cdcecb)
	}
	return nil
}

const (
	ST_BlackWhiteModeUnset      ST_BlackWhiteMode = 0
	ST_BlackWhiteModeClr        ST_BlackWhiteMode = 1
	ST_BlackWhiteModeAuto       ST_BlackWhiteMode = 2
	ST_BlackWhiteModeGray       ST_BlackWhiteMode = 3
	ST_BlackWhiteModeLtGray     ST_BlackWhiteMode = 4
	ST_BlackWhiteModeInvGray    ST_BlackWhiteMode = 5
	ST_BlackWhiteModeGrayWhite  ST_BlackWhiteMode = 6
	ST_BlackWhiteModeBlackGray  ST_BlackWhiteMode = 7
	ST_BlackWhiteModeBlackWhite ST_BlackWhiteMode = 8
	ST_BlackWhiteModeBlack      ST_BlackWhiteMode = 9
	ST_BlackWhiteModeWhite      ST_BlackWhiteMode = 10
	ST_BlackWhiteModeHidden     ST_BlackWhiteMode = 11
)

// ValidateWithPath validates the CT_PositiveSize2D and its children, prefixing error messages with path
func (_bgbee *CT_PositiveSize2D) ValidateWithPath(path string) error {
	if _bgbee.CxAttr < 0 {
		return _dcf.Errorf("\u0025s\u002fm.CxAttr\u0020must be\u0020>\u003d\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _bgbee.CxAttr)
	}
	if _bgbee.CxAttr > 27273042316900 {
		return _dcf.Errorf("%s\u002fm\u002eCxAttr\u0020must\u0020be \u003c\u003d\u002027273042316900\u0020(have\u0020\u0025v\u0029", path, _bgbee.CxAttr)
	}
	if _bgbee.CyAttr < 0 {
		return _dcf.Errorf("\u0025s\u002fm.CyAttr\u0020must be\u0020>\u003d\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _bgbee.CyAttr)
	}
	if _bgbee.CyAttr > 27273042316900 {
		return _dcf.Errorf("%s\u002fm\u002eCyAttr\u0020must\u0020be \u003c\u003d\u002027273042316900\u0020(have\u0020\u0025v\u0029", path, _bgbee.CyAttr)
	}
	return nil
}

type ST_TextStrikeType byte

func (_agadg *CT_LineJoinBevel) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_dfdag, _aggd := d.Token()
		if _aggd != nil {
			return _dcf.Errorf("parsing\u0020CT_LineJoinBevel: \u0025s", _aggd)
		}
		if _bedf, _eggge := _dfdag.(_g.EndElement); _eggge && _bedf.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the VideoFile and its children
func (_bdeefa *VideoFile) Validate() error { return _bdeefa.ValidateWithPath("VideoFile") }
func NewCT_EffectList() *CT_EffectList     { _bcag := &CT_EffectList{}; return _bcag }

type CT_PathShadeProperties struct {
	PathAttr   ST_PathShadeType
	FillToRect *CT_RelativeRect
}

func (_ffcbba *ST_BevelPresetType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_ffcbba = 0
	case "relaxedInset":
		*_ffcbba = 1
	case "circle":
		*_ffcbba = 2
	case "slope":
		*_ffcbba = 3
	case "cross":
		*_ffcbba = 4
	case "angle":
		*_ffcbba = 5
	case "softRound":
		*_ffcbba = 6
	case "convex":
		*_ffcbba = 7
	case "coolSlant":
		*_ffcbba = 8
	case "divot":
		*_ffcbba = 9
	case "riblet":
		*_ffcbba = 10
	case "hardEdge":
		*_ffcbba = 11
	case "artDeco":
		*_ffcbba = 12
	}
	return nil
}
func (_cfdad ST_TextVertOverflowType) ValidateWithPath(path string) error {
	switch _cfdad {
	case 0, 1, 2, 3:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cfdad))
	}
	return nil
}
func (_degd *CT_GvmlTextShape) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_degd.TxBody = NewCT_TextBody()
_gcfdf:
	for {
		_fdebb, _gefd := d.Token()
		if _gefd != nil {
			return _gefd
		}
		switch _cfgag := _fdebb.(type) {
		case _g.StartElement:
			switch _cfgag.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "txBody"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "txBody"}:
				if _bcac := d.DecodeElement(_degd.TxBody, &_cfgag); _bcac != nil {
					return _bcac
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "useSpRect"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "useSpRect"}:
				_degd.Choice = NewCT_GvmlTextShapeChoice()
				if _bbbab := d.DecodeElement(&_degd.Choice.UseSpRect, &_cfgag); _bbbab != nil {
					return _bbbab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "xfrm"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "xfrm"}:
				_degd.Choice = NewCT_GvmlTextShapeChoice()
				if _fece := d.DecodeElement(&_degd.Choice.Xfrm, &_cfgag); _fece != nil {
					return _fece
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_degd.ExtLst = NewCT_OfficeArtExtensionList()
				if _agfeg := d.DecodeElement(_degd.ExtLst, &_cfgag); _agfeg != nil {
					return _agfeg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GvmlTextShape\u0020\u0025v", _cfgag.Name)
				if _gagc := d.Skip(); _gagc != nil {
					return _gagc
				}
			}
		case _g.EndElement:
			break _gcfdf
		case _g.CharData:
		}
	}
	return nil
}
func (_ebgef ST_SystemColorVal) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ebgef.String(), start)
}
func NewCT_DefaultShapeDefinition() *CT_DefaultShapeDefinition {
	_caf := &CT_DefaultShapeDefinition{}
	_caf.SpPr = NewCT_ShapeProperties()
	_caf.BodyPr = NewCT_TextBodyProperties()
	_caf.LstStyle = NewCT_TextListStyle()
	return _caf
}
func (_dbged *ST_PresetColorVal) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_dbged = 0
	case "aliceBlue":
		*_dbged = 1
	case "antiqueWhite":
		*_dbged = 2
	case "aqua":
		*_dbged = 3
	case "aquamarine":
		*_dbged = 4
	case "azure":
		*_dbged = 5
	case "beige":
		*_dbged = 6
	case "bisque":
		*_dbged = 7
	case "black":
		*_dbged = 8
	case "blanchedAlmond":
		*_dbged = 9
	case "blue":
		*_dbged = 10
	case "blueViolet":
		*_dbged = 11
	case "brown":
		*_dbged = 12
	case "burlyWood":
		*_dbged = 13
	case "cadetBlue":
		*_dbged = 14
	case "chartreuse":
		*_dbged = 15
	case "chocolate":
		*_dbged = 16
	case "coral":
		*_dbged = 17
	case "cornflowerBlue":
		*_dbged = 18
	case "cornsilk":
		*_dbged = 19
	case "crimson":
		*_dbged = 20
	case "cyan":
		*_dbged = 21
	case "darkBlue":
		*_dbged = 22
	case "darkCyan":
		*_dbged = 23
	case "darkGoldenrod":
		*_dbged = 24
	case "darkGray":
		*_dbged = 25
	case "darkGrey":
		*_dbged = 26
	case "darkGreen":
		*_dbged = 27
	case "darkKhaki":
		*_dbged = 28
	case "darkMagenta":
		*_dbged = 29
	case "darkOliveGreen":
		*_dbged = 30
	case "darkOrange":
		*_dbged = 31
	case "darkOrchid":
		*_dbged = 32
	case "darkRed":
		*_dbged = 33
	case "darkSalmon":
		*_dbged = 34
	case "darkSeaGreen":
		*_dbged = 35
	case "darkSlateBlue":
		*_dbged = 36
	case "darkSlateGray":
		*_dbged = 37
	case "darkSlateGrey":
		*_dbged = 38
	case "darkTurquoise":
		*_dbged = 39
	case "darkViolet":
		*_dbged = 40
	case "dkBlue":
		*_dbged = 41
	case "dkCyan":
		*_dbged = 42
	case "dkGoldenrod":
		*_dbged = 43
	case "dkGray":
		*_dbged = 44
	case "dkGrey":
		*_dbged = 45
	case "dkGreen":
		*_dbged = 46
	case "dkKhaki":
		*_dbged = 47
	case "dkMagenta":
		*_dbged = 48
	case "dkOliveGreen":
		*_dbged = 49
	case "dkOrange":
		*_dbged = 50
	case "dkOrchid":
		*_dbged = 51
	case "dkRed":
		*_dbged = 52
	case "dkSalmon":
		*_dbged = 53
	case "dkSeaGreen":
		*_dbged = 54
	case "dkSlateBlue":
		*_dbged = 55
	case "dkSlateGray":
		*_dbged = 56
	case "dkSlateGrey":
		*_dbged = 57
	case "dkTurquoise":
		*_dbged = 58
	case "dkViolet":
		*_dbged = 59
	case "deepPink":
		*_dbged = 60
	case "deepSkyBlue":
		*_dbged = 61
	case "dimGray":
		*_dbged = 62
	case "dimGrey":
		*_dbged = 63
	case "dodgerBlue":
		*_dbged = 64
	case "firebrick":
		*_dbged = 65
	case "floralWhite":
		*_dbged = 66
	case "forestGreen":
		*_dbged = 67
	case "fuchsia":
		*_dbged = 68
	case "gainsboro":
		*_dbged = 69
	case "ghostWhite":
		*_dbged = 70
	case "gold":
		*_dbged = 71
	case "goldenrod":
		*_dbged = 72
	case "gray":
		*_dbged = 73
	case "grey":
		*_dbged = 74
	case "green":
		*_dbged = 75
	case "greenYellow":
		*_dbged = 76
	case "honeydew":
		*_dbged = 77
	case "hotPink":
		*_dbged = 78
	case "indianRed":
		*_dbged = 79
	case "indigo":
		*_dbged = 80
	case "ivory":
		*_dbged = 81
	case "khaki":
		*_dbged = 82
	case "lavender":
		*_dbged = 83
	case "lavenderBlush":
		*_dbged = 84
	case "lawnGreen":
		*_dbged = 85
	case "lemonChiffon":
		*_dbged = 86
	case "lightBlue":
		*_dbged = 87
	case "lightCoral":
		*_dbged = 88
	case "lightCyan":
		*_dbged = 89
	case "lightGoldenrodYellow":
		*_dbged = 90
	case "lightGray":
		*_dbged = 91
	case "lightGrey":
		*_dbged = 92
	case "lightGreen":
		*_dbged = 93
	case "lightPink":
		*_dbged = 94
	case "lightSalmon":
		*_dbged = 95
	case "lightSeaGreen":
		*_dbged = 96
	case "lightSkyBlue":
		*_dbged = 97
	case "lightSlateGray":
		*_dbged = 98
	case "lightSlateGrey":
		*_dbged = 99
	case "lightSteelBlue":
		*_dbged = 100
	case "lightYellow":
		*_dbged = 101
	case "ltBlue":
		*_dbged = 102
	case "ltCoral":
		*_dbged = 103
	case "ltCyan":
		*_dbged = 104
	case "ltGoldenrodYellow":
		*_dbged = 105
	case "ltGray":
		*_dbged = 106
	case "ltGrey":
		*_dbged = 107
	case "ltGreen":
		*_dbged = 108
	case "ltPink":
		*_dbged = 109
	case "ltSalmon":
		*_dbged = 110
	case "ltSeaGreen":
		*_dbged = 111
	case "ltSkyBlue":
		*_dbged = 112
	case "ltSlateGray":
		*_dbged = 113
	case "ltSlateGrey":
		*_dbged = 114
	case "ltSteelBlue":
		*_dbged = 115
	case "ltYellow":
		*_dbged = 116
	case "lime":
		*_dbged = 117
	case "limeGreen":
		*_dbged = 118
	case "linen":
		*_dbged = 119
	case "magenta":
		*_dbged = 120
	case "maroon":
		*_dbged = 121
	case "medAquamarine":
		*_dbged = 122
	case "medBlue":
		*_dbged = 123
	case "medOrchid":
		*_dbged = 124
	case "medPurple":
		*_dbged = 125
	case "medSeaGreen":
		*_dbged = 126
	case "medSlateBlue":
		*_dbged = 127
	case "medSpringGreen":
		*_dbged = 128
	case "medTurquoise":
		*_dbged = 129
	case "medVioletRed":
		*_dbged = 130
	case "mediumAquamarine":
		*_dbged = 131
	case "mediumBlue":
		*_dbged = 132
	case "mediumOrchid":
		*_dbged = 133
	case "mediumPurple":
		*_dbged = 134
	case "mediumSeaGreen":
		*_dbged = 135
	case "mediumSlateBlue":
		*_dbged = 136
	case "mediumSpringGreen":
		*_dbged = 137
	case "mediumTurquoise":
		*_dbged = 138
	case "mediumVioletRed":
		*_dbged = 139
	case "midnightBlue":
		*_dbged = 140
	case "mintCream":
		*_dbged = 141
	case "mistyRose":
		*_dbged = 142
	case "moccasin":
		*_dbged = 143
	case "navajoWhite":
		*_dbged = 144
	case "navy":
		*_dbged = 145
	case "oldLace":
		*_dbged = 146
	case "olive":
		*_dbged = 147
	case "oliveDrab":
		*_dbged = 148
	case "orange":
		*_dbged = 149
	case "orangeRed":
		*_dbged = 150
	case "orchid":
		*_dbged = 151
	case "paleGoldenrod":
		*_dbged = 152
	case "paleGreen":
		*_dbged = 153
	case "paleTurquoise":
		*_dbged = 154
	case "paleVioletRed":
		*_dbged = 155
	case "papayaWhip":
		*_dbged = 156
	case "peachPuff":
		*_dbged = 157
	case "peru":
		*_dbged = 158
	case "pink":
		*_dbged = 159
	case "plum":
		*_dbged = 160
	case "powderBlue":
		*_dbged = 161
	case "purple":
		*_dbged = 162
	case "red":
		*_dbged = 163
	case "rosyBrown":
		*_dbged = 164
	case "royalBlue":
		*_dbged = 165
	case "saddleBrown":
		*_dbged = 166
	case "salmon":
		*_dbged = 167
	case "sandyBrown":
		*_dbged = 168
	case "seaGreen":
		*_dbged = 169
	case "seaShell":
		*_dbged = 170
	case "sienna":
		*_dbged = 171
	case "silver":
		*_dbged = 172
	case "skyBlue":
		*_dbged = 173
	case "slateBlue":
		*_dbged = 174
	case "slateGray":
		*_dbged = 175
	case "slateGrey":
		*_dbged = 176
	case "snow":
		*_dbged = 177
	case "springGreen":
		*_dbged = 178
	case "steelBlue":
		*_dbged = 179
	case "tan":
		*_dbged = 180
	case "teal":
		*_dbged = 181
	case "thistle":
		*_dbged = 182
	case "tomato":
		*_dbged = 183
	case "turquoise":
		*_dbged = 184
	case "violet":
		*_dbged = 185
	case "wheat":
		*_dbged = 186
	case "white":
		*_dbged = 187
	case "whiteSmoke":
		*_dbged = 188
	case "yellow":
		*_dbged = 189
	case "yellowGreen":
		*_dbged = 190
	}
	return nil
}

// ValidateWithPath validates the CT_TableStyle and its children, prefixing error messages with path
func (_bfdce *CT_TableStyle) ValidateWithPath(path string) error {
	if !_f.ST_GuidPatternRe.MatchString(_bfdce.StyleIdAttr) {
		return _dcf.Errorf("\u0025s\u002fm\u002eStyleIdAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020(have\u0020\u0025v\u0029", path, _f.ST_GuidPatternRe, _bfdce.StyleIdAttr)
	}
	if _bfdce.TblBg != nil {
		if _bgdfe := _bfdce.TblBg.ValidateWithPath(path + "\u002fTblBg"); _bgdfe != nil {
			return _bgdfe
		}
	}
	if _bfdce.WholeTbl != nil {
		if _bbcab := _bfdce.WholeTbl.ValidateWithPath(path + "\u002fWholeTbl"); _bbcab != nil {
			return _bbcab
		}
	}
	if _bfdce.Band1H != nil {
		if _gbdgf := _bfdce.Band1H.ValidateWithPath(path + "\u002fBand1H"); _gbdgf != nil {
			return _gbdgf
		}
	}
	if _bfdce.Band2H != nil {
		if _edbag := _bfdce.Band2H.ValidateWithPath(path + "\u002fBand2H"); _edbag != nil {
			return _edbag
		}
	}
	if _bfdce.Band1V != nil {
		if _fabab := _bfdce.Band1V.ValidateWithPath(path + "\u002fBand1V"); _fabab != nil {
			return _fabab
		}
	}
	if _bfdce.Band2V != nil {
		if _gfadd := _bfdce.Band2V.ValidateWithPath(path + "\u002fBand2V"); _gfadd != nil {
			return _gfadd
		}
	}
	if _bfdce.LastCol != nil {
		if _cbaggc := _bfdce.LastCol.ValidateWithPath(path + "\u002fLastCol"); _cbaggc != nil {
			return _cbaggc
		}
	}
	if _bfdce.FirstCol != nil {
		if _accc := _bfdce.FirstCol.ValidateWithPath(path + "\u002fFirstCol"); _accc != nil {
			return _accc
		}
	}
	if _bfdce.LastRow != nil {
		if _bcege := _bfdce.LastRow.ValidateWithPath(path + "\u002fLastRow"); _bcege != nil {
			return _bcege
		}
	}
	if _bfdce.SeCell != nil {
		if _dafdc := _bfdce.SeCell.ValidateWithPath(path + "\u002fSeCell"); _dafdc != nil {
			return _dafdc
		}
	}
	if _bfdce.SwCell != nil {
		if _efgb := _bfdce.SwCell.ValidateWithPath(path + "\u002fSwCell"); _efgb != nil {
			return _efgb
		}
	}
	if _bfdce.FirstRow != nil {
		if _dcbdb := _bfdce.FirstRow.ValidateWithPath(path + "\u002fFirstRow"); _dcbdb != nil {
			return _dcbdb
		}
	}
	if _bfdce.NeCell != nil {
		if _adab := _bfdce.NeCell.ValidateWithPath(path + "\u002fNeCell"); _adab != nil {
			return _adab
		}
	}
	if _bfdce.NwCell != nil {
		if _bbadg := _bfdce.NwCell.ValidateWithPath(path + "\u002fNwCell"); _bbadg != nil {
			return _bbadg
		}
	}
	if _bfdce.ExtLst != nil {
		if _agafe := _bfdce.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _agafe != nil {
			return _agafe
		}
	}
	return nil
}
func (_gdceg *CT_GradientFillProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fcdg := range start.Attr {
		if _fcdg.Name.Local == "flip" {
			_gdceg.FlipAttr.UnmarshalXMLAttr(_fcdg)
			continue
		}
		if _fcdg.Name.Local == "rotWithShape" {
			_agfc, _agfee := _e.ParseBool(_fcdg.Value)
			if _agfee != nil {
				return _agfee
			}
			_gdceg.RotWithShapeAttr = &_agfc
			continue
		}
	}
_gggc:
	for {
		_eeabf, _dbfd := d.Token()
		if _dbfd != nil {
			return _dbfd
		}
		switch _dbgea := _eeabf.(type) {
		case _g.StartElement:
			switch _dbgea.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gsLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gsLst"}:
				_gdceg.GsLst = NewCT_GradientStopList()
				if _dbbb := d.DecodeElement(_gdceg.GsLst, &_dbgea); _dbbb != nil {
					return _dbbb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lin"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lin"}:
				_gdceg.Lin = NewCT_LinearShadeProperties()
				if _gcadc := d.DecodeElement(_gdceg.Lin, &_dbgea); _gcadc != nil {
					return _gcadc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "path"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "path"}:
				_gdceg.Path = NewCT_PathShadeProperties()
				if _egeb := d.DecodeElement(_gdceg.Path, &_dbgea); _egeb != nil {
					return _egeb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tileRect"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tileRect"}:
				_gdceg.TileRect = NewCT_RelativeRect()
				if _ccffa := d.DecodeElement(_gdceg.TileRect, &_dbgea); _ccffa != nil {
					return _ccffa
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GradientFillProperties\u0020\u0025v", _dbgea.Name)
				if _ffdgb := d.Skip(); _ffdgb != nil {
					return _ffdgb
				}
			}
		case _g.EndElement:
			break _gggc
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_FontReference() *CT_FontReference {
	_cffbg := &CT_FontReference{}
	_cffbg.IdxAttr = ST_FontCollectionIndex(1)
	return _cffbg
}
func (_cgcaea ST_SystemColorVal) Validate() error { return _cgcaea.ValidateWithPath("") }
func (_ffccdg ST_TextAnchoringType) String() string {
	switch _ffccdg {
	case 0:
		return ""
	case 1:
		return "t"
	case 2:
		return "ctr"
	case 3:
		return "b"
	case 4:
		return "just"
	case 5:
		return "dist"
	}
	return ""
}
func (_df *CT_AlphaBiLevelEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bdd := range start.Attr {
		if _bdd.Name.Local == "thresh" {
			_ceg, _ddg := ParseUnionST_PositiveFixedPercentage(_bdd.Value)
			if _ddg != nil {
				return _ddg
			}
			_df.ThreshAttr = _ceg
			continue
		}
	}
	for {
		_dccf, _ac := d.Token()
		if _ac != nil {
			return _dcf.Errorf("parsing\u0020CT_AlphaBiLevelEffect:\u0020\u0025s", _ac)
		}
		if _gce, _dbge := _dccf.(_g.EndElement); _dbge && _gce.Name == start.Name {
			break
		}
	}
	return nil
}
func (_abf *CT_AnimationChartBuildProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _abf.BldAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "bld"}, Value: _dcf.Sprintf("\u0025v", *_abf.BldAttr)})
	}
	if _abf.AnimBgAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "animBg"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_abf.AnimBgAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_StyleMatrix() *CT_StyleMatrix {
	_bdafg := &CT_StyleMatrix{}
	_bdafg.FillStyleLst = NewCT_FillStyleList()
	_bdafg.LnStyleLst = NewCT_LineStyleList()
	_bdafg.EffectStyleLst = NewCT_EffectStyleList()
	_bdafg.BgFillStyleLst = NewCT_BackgroundFillStyleList()
	return _bdafg
}
func (_agaaf *EG_TextBulletColor) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_bdefb:
	for {
		_cbbcg, _aeeed := d.Token()
		if _aeeed != nil {
			return _aeeed
		}
		switch _aaged := _cbbcg.(type) {
		case _g.StartElement:
			switch _aaged.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buClrTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buClrTx"}:
				_agaaf.BuClrTx = NewCT_TextBulletColorFollowText()
				if _cgfag := d.DecodeElement(_agaaf.BuClrTx, &_aaged); _cgfag != nil {
					return _cgfag
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buClr"}:
				_agaaf.BuClr = NewCT_Color()
				if _fedg := d.DecodeElement(_agaaf.BuClr, &_aaged); _fedg != nil {
					return _fedg
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020EG_TextBulletColor\u0020\u0025v", _aaged.Name)
				if _degfce := d.Skip(); _degfce != nil {
					return _degfce
				}
			}
		case _g.EndElement:
			break _bdefb
		case _g.CharData:
		}
	}
	return nil
}
func (_ecee *CT_ColorSchemeList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gdad:
	for {
		_bagge, _fbgf := d.Token()
		if _fbgf != nil {
			return _fbgf
		}
		switch _fgba := _bagge.(type) {
		case _g.StartElement:
			switch _fgba.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extraClrScheme"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extraClrScheme"}:
				_acff := NewCT_ColorSchemeAndMapping()
				if _afeb := d.DecodeElement(_acff, &_fgba); _afeb != nil {
					return _afeb
				}
				_ecee.ExtraClrScheme = append(_ecee.ExtraClrScheme, _acff)
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_ColorSchemeList\u0020\u0025v", _fgba.Name)
				if _dgdcb := d.Skip(); _dgdcb != nil {
					return _dgdcb
				}
			}
		case _g.EndElement:
			break _gdad
		case _g.CharData:
		}
	}
	return nil
}

type EG_LineDashProperties struct {
	PrstDash *CT_PresetLineDashProperties
	CustDash *CT_DashStopList
}

func (_gadgad *ST_TextShapeType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_gadgad = 0
	case "textNoShape":
		*_gadgad = 1
	case "textPlain":
		*_gadgad = 2
	case "textStop":
		*_gadgad = 3
	case "textTriangle":
		*_gadgad = 4
	case "textTriangleInverted":
		*_gadgad = 5
	case "textChevron":
		*_gadgad = 6
	case "textChevronInverted":
		*_gadgad = 7
	case "textRingInside":
		*_gadgad = 8
	case "textRingOutside":
		*_gadgad = 9
	case "textArchUp":
		*_gadgad = 10
	case "textArchDown":
		*_gadgad = 11
	case "textCircle":
		*_gadgad = 12
	case "textButton":
		*_gadgad = 13
	case "textArchUpPour":
		*_gadgad = 14
	case "textArchDownPour":
		*_gadgad = 15
	case "textCirclePour":
		*_gadgad = 16
	case "textButtonPour":
		*_gadgad = 17
	case "textCurveUp":
		*_gadgad = 18
	case "textCurveDown":
		*_gadgad = 19
	case "textCanUp":
		*_gadgad = 20
	case "textCanDown":
		*_gadgad = 21
	case "textWave1":
		*_gadgad = 22
	case "textWave2":
		*_gadgad = 23
	case "textDoubleWave1":
		*_gadgad = 24
	case "textWave4":
		*_gadgad = 25
	case "textInflate":
		*_gadgad = 26
	case "textDeflate":
		*_gadgad = 27
	case "textInflateBottom":
		*_gadgad = 28
	case "textDeflateBottom":
		*_gadgad = 29
	case "textInflateTop":
		*_gadgad = 30
	case "textDeflateTop":
		*_gadgad = 31
	case "textDeflateInflate":
		*_gadgad = 32
	case "textDeflateInflateDeflate":
		*_gadgad = 33
	case "textFadeRight":
		*_gadgad = 34
	case "textFadeLeft":
		*_gadgad = 35
	case "textFadeUp":
		*_gadgad = 36
	case "textFadeDown":
		*_gadgad = 37
	case "textSlantUp":
		*_gadgad = 38
	case "textSlantDown":
		*_gadgad = 39
	case "textCascadeUp":
		*_gadgad = 40
	case "textCascadeDown":
		*_gadgad = 41
	}
	return nil
}
func (_fbgge *ST_AnimationBuildType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fbgge = 0
	case "allAtOnce":
		*_fbgge = 1
	}
	return nil
}
func (_agcbf *CT_GvmlGraphicFrameNonVisual) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_bfebf := _g.StartElement{Name: _g.Name{Local: "a:cNvPr"}}
	e.EncodeElement(_agcbf.CNvPr, _bfebf)
	_cacaf := _g.StartElement{Name: _g.Name{Local: "a:cNvGraphicFramePr"}}
	e.EncodeElement(_agcbf.CNvGraphicFramePr, _cacaf)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_dfgga ST_LightRigType) String() string {
	switch _dfgga {
	case 0:
		return ""
	case 1:
		return "legacyFlat1"
	case 2:
		return "legacyFlat2"
	case 3:
		return "legacyFlat3"
	case 4:
		return "legacyFlat4"
	case 5:
		return "legacyNormal1"
	case 6:
		return "legacyNormal2"
	case 7:
		return "legacyNormal3"
	case 8:
		return "legacyNormal4"
	case 9:
		return "legacyHarsh1"
	case 10:
		return "legacyHarsh2"
	case 11:
		return "legacyHarsh3"
	case 12:
		return "legacyHarsh4"
	case 13:
		return "threePt"
	case 14:
		return "balanced"
	case 15:
		return "soft"
	case 16:
		return "harsh"
	case 17:
		return "flood"
	case 18:
		return "contrasting"
	case 19:
		return "morning"
	case 20:
		return "sunrise"
	case 21:
		return "sunset"
	case 22:
		return "chilly"
	case 23:
		return "freezing"
	case 24:
		return "flat"
	case 25:
		return "twoPt"
	case 26:
		return "glow"
	case 27:
		return "brightRoom"
	}
	return ""
}
func NewCT_LineJoinRound() *CT_LineJoinRound { _gged := &CT_LineJoinRound{}; return _gged }

// Validate validates the CT_AudioCD and its children
func (_gfb *CT_AudioCD) Validate() error { return _gfb.ValidateWithPath("CT_AudioCD") }

type EG_FillProperties struct {
	NoFill    *CT_NoFillProperties
	SolidFill *CT_SolidColorFillProperties
	GradFill  *CT_GradientFillProperties
	BlipFill  *CT_BlipFillProperties
	PattFill  *CT_PatternFillProperties
	GrpFill   *CT_GroupFillProperties
}

// ValidateWithPath validates the EG_TextBulletTypeface and its children, prefixing error messages with path
func (_fddfb *EG_TextBulletTypeface) ValidateWithPath(path string) error {
	if _fddfb.BuFontTx != nil {
		if _fbfbe := _fddfb.BuFontTx.ValidateWithPath(path + "\u002fBuFontTx"); _fbfbe != nil {
			return _fbfbe
		}
	}
	if _fddfb.BuFont != nil {
		if _affeb := _fddfb.BuFont.ValidateWithPath(path + "\u002fBuFont"); _affeb != nil {
			return _affeb
		}
	}
	return nil
}

type ST_ColorSchemeIndex byte

func (_bfgee *CT_BlipFillProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _bfgee.DpiAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dpi"}, Value: _dcf.Sprintf("\u0025v", *_bfgee.DpiAttr)})
	}
	if _bfgee.RotWithShapeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rotWithShape"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_bfgee.RotWithShapeAttr))})
	}
	e.EncodeToken(start)
	if _bfgee.Blip != nil {
		_ccae := _g.StartElement{Name: _g.Name{Local: "a:blip"}}
		e.EncodeElement(_bfgee.Blip, _ccae)
	}
	if _bfgee.SrcRect != nil {
		_fbae := _g.StartElement{Name: _g.Name{Local: "a:srcRect"}}
		e.EncodeElement(_bfgee.SrcRect, _fbae)
	}
	if _bfgee.Tile != nil {
		_dfbe := _g.StartElement{Name: _g.Name{Local: "a:tile"}}
		e.EncodeElement(_bfgee.Tile, _dfbe)
	}
	if _bfgee.Stretch != nil {
		_afbg := _g.StartElement{Name: _g.Name{Local: "a:stretch"}}
		e.EncodeElement(_bfgee.Stretch, _afbg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_fdfgc ST_TextAlignType) String() string {
	switch _fdfgc {
	case 0:
		return ""
	case 1:
		return "l"
	case 2:
		return "ctr"
	case 3:
		return "r"
	case 4:
		return "just"
	case 5:
		return "justLow"
	case 6:
		return "dist"
	case 7:
		return "thaiDist"
	}
	return ""
}
func (_gebeb ST_PresetShadowVal) Validate() error { return _gebeb.ValidateWithPath("") }
func (_agbff *CT_LineStyleList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_ecag := _g.StartElement{Name: _g.Name{Local: "a:ln"}}
	for _, _bgca := range _agbff.Ln {
		e.EncodeElement(_bgca, _ecag)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SolidColorFillProperties and its children
func (_fecg *CT_SolidColorFillProperties) Validate() error {
	return _fecg.ValidateWithPath("CT_SolidColorFillProperties")
}

// Validate validates the CT_AlphaBiLevelEffect and its children
func (_ggc *CT_AlphaBiLevelEffect) Validate() error {
	return _ggc.ValidateWithPath("CT_AlphaBiLevelEffect")
}
func (_bddgd *CT_EffectList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_bdgb:
	for {
		_dfee, _dfdc := d.Token()
		if _dfdc != nil {
			return _dfdc
		}
		switch _bfeg := _dfee.(type) {
		case _g.StartElement:
			switch _bfeg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blur"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blur"}:
				_bddgd.Blur = NewCT_BlurEffect()
				if _fgbe := d.DecodeElement(_bddgd.Blur, &_bfeg); _fgbe != nil {
					return _fgbe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillOverlay"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillOverlay"}:
				_bddgd.FillOverlay = NewCT_FillOverlayEffect()
				if _debg := d.DecodeElement(_bddgd.FillOverlay, &_bfeg); _debg != nil {
					return _debg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "glow"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "glow"}:
				_bddgd.Glow = NewCT_GlowEffect()
				if _abcb := d.DecodeElement(_bddgd.Glow, &_bfeg); _abcb != nil {
					return _abcb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "innerShdw"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "innerShdw"}:
				_bddgd.InnerShdw = NewCT_InnerShadowEffect()
				if _dfga := d.DecodeElement(_bddgd.InnerShdw, &_bfeg); _dfga != nil {
					return _dfga
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "outerShdw"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "outerShdw"}:
				_bddgd.OuterShdw = NewCT_OuterShadowEffect()
				if _bgda := d.DecodeElement(_bddgd.OuterShdw, &_bfeg); _bgda != nil {
					return _bgda
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstShdw"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstShdw"}:
				_bddgd.PrstShdw = NewCT_PresetShadowEffect()
				if _fefe := d.DecodeElement(_bddgd.PrstShdw, &_bfeg); _fefe != nil {
					return _fefe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "reflection"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "reflection"}:
				_bddgd.Reflection = NewCT_ReflectionEffect()
				if _afdfd := d.DecodeElement(_bddgd.Reflection, &_bfeg); _afdfd != nil {
					return _afdfd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "softEdge"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "softEdge"}:
				_bddgd.SoftEdge = NewCT_SoftEdgesEffect()
				if _faab := d.DecodeElement(_bddgd.SoftEdge, &_bfeg); _faab != nil {
					return _faab
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_EffectList \u0025v", _bfeg.Name)
				if _fafe := d.Skip(); _fafe != nil {
					return _fafe
				}
			}
		case _g.EndElement:
			break _bdgb
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_LineJoinRound and its children, prefixing error messages with path
func (_dgggf *CT_LineJoinRound) ValidateWithPath(path string) error { return nil }

// Validate validates the EG_TextUnderlineLine and its children
func (_dfgcd *EG_TextUnderlineLine) Validate() error {
	return _dfgcd.ValidateWithPath("EG_TextUnderlineLine")
}
func NewCT_EffectProperties() *CT_EffectProperties { _fbba := &CT_EffectProperties{}; return _fbba }
func NewEG_ThemeableFontStyles() *EG_ThemeableFontStyles {
	_dbcdff := &EG_ThemeableFontStyles{}
	return _dbcdff
}

type CT_GrayscaleEffect struct{}

func NewCT_AnimationDgmBuildProperties() *CT_AnimationDgmBuildProperties {
	_adbg := &CT_AnimationDgmBuildProperties{}
	return _adbg
}
func (_fdgea ST_ShapeType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_bdbde := _g.Attr{}
	_bdbde.Name = name
	switch _fdgea {
	case ST_ShapeTypeUnset:
		_bdbde.Value = ""
	case ST_ShapeTypeLine:
		_bdbde.Value = "line"
	case ST_ShapeTypeLineInv:
		_bdbde.Value = "lineInv"
	case ST_ShapeTypeTriangle:
		_bdbde.Value = "triangle"
	case ST_ShapeTypeRtTriangle:
		_bdbde.Value = "rtTriangle"
	case ST_ShapeTypeRect:
		_bdbde.Value = "rect"
	case ST_ShapeTypeDiamond:
		_bdbde.Value = "diamond"
	case ST_ShapeTypeParallelogram:
		_bdbde.Value = "parallelogram"
	case ST_ShapeTypeTrapezoid:
		_bdbde.Value = "trapezoid"
	case ST_ShapeTypeNonIsoscelesTrapezoid:
		_bdbde.Value = "nonIsoscelesTrapezoid"
	case ST_ShapeTypePentagon:
		_bdbde.Value = "pentagon"
	case ST_ShapeTypeHexagon:
		_bdbde.Value = "hexagon"
	case ST_ShapeTypeHeptagon:
		_bdbde.Value = "heptagon"
	case ST_ShapeTypeOctagon:
		_bdbde.Value = "octagon"
	case ST_ShapeTypeDecagon:
		_bdbde.Value = "decagon"
	case ST_ShapeTypeDodecagon:
		_bdbde.Value = "dodecagon"
	case ST_ShapeTypeStar4:
		_bdbde.Value = "star4"
	case ST_ShapeTypeStar5:
		_bdbde.Value = "star5"
	case ST_ShapeTypeStar6:
		_bdbde.Value = "star6"
	case ST_ShapeTypeStar7:
		_bdbde.Value = "star7"
	case ST_ShapeTypeStar8:
		_bdbde.Value = "star8"
	case ST_ShapeTypeStar10:
		_bdbde.Value = "star10"
	case ST_ShapeTypeStar12:
		_bdbde.Value = "star12"
	case ST_ShapeTypeStar16:
		_bdbde.Value = "star16"
	case ST_ShapeTypeStar24:
		_bdbde.Value = "star24"
	case ST_ShapeTypeStar32:
		_bdbde.Value = "star32"
	case ST_ShapeTypeRoundRect:
		_bdbde.Value = "roundRect"
	case ST_ShapeTypeRound1Rect:
		_bdbde.Value = "round1Rect"
	case ST_ShapeTypeRound2SameRect:
		_bdbde.Value = "round2SameRect"
	case ST_ShapeTypeRound2DiagRect:
		_bdbde.Value = "round2DiagRect"
	case ST_ShapeTypeSnipRoundRect:
		_bdbde.Value = "snipRoundRect"
	case ST_ShapeTypeSnip1Rect:
		_bdbde.Value = "snip1Rect"
	case ST_ShapeTypeSnip2SameRect:
		_bdbde.Value = "snip2SameRect"
	case ST_ShapeTypeSnip2DiagRect:
		_bdbde.Value = "snip2DiagRect"
	case ST_ShapeTypePlaque:
		_bdbde.Value = "plaque"
	case ST_ShapeTypeEllipse:
		_bdbde.Value = "ellipse"
	case ST_ShapeTypeTeardrop:
		_bdbde.Value = "teardrop"
	case ST_ShapeTypeHomePlate:
		_bdbde.Value = "homePlate"
	case ST_ShapeTypeChevron:
		_bdbde.Value = "chevron"
	case ST_ShapeTypePieWedge:
		_bdbde.Value = "pieWedge"
	case ST_ShapeTypePie:
		_bdbde.Value = "pie"
	case ST_ShapeTypeBlockArc:
		_bdbde.Value = "blockArc"
	case ST_ShapeTypeDonut:
		_bdbde.Value = "donut"
	case ST_ShapeTypeNoSmoking:
		_bdbde.Value = "noSmoking"
	case ST_ShapeTypeRightArrow:
		_bdbde.Value = "rightArrow"
	case ST_ShapeTypeLeftArrow:
		_bdbde.Value = "leftArrow"
	case ST_ShapeTypeUpArrow:
		_bdbde.Value = "upArrow"
	case ST_ShapeTypeDownArrow:
		_bdbde.Value = "downArrow"
	case ST_ShapeTypeStripedRightArrow:
		_bdbde.Value = "stripedRightArrow"
	case ST_ShapeTypeNotchedRightArrow:
		_bdbde.Value = "notchedRightArrow"
	case ST_ShapeTypeBentUpArrow:
		_bdbde.Value = "bentUpArrow"
	case ST_ShapeTypeLeftRightArrow:
		_bdbde.Value = "leftRightArrow"
	case ST_ShapeTypeUpDownArrow:
		_bdbde.Value = "upDownArrow"
	case ST_ShapeTypeLeftUpArrow:
		_bdbde.Value = "leftUpArrow"
	case ST_ShapeTypeLeftRightUpArrow:
		_bdbde.Value = "leftRightUpArrow"
	case ST_ShapeTypeQuadArrow:
		_bdbde.Value = "quadArrow"
	case ST_ShapeTypeLeftArrowCallout:
		_bdbde.Value = "leftArrowCallout"
	case ST_ShapeTypeRightArrowCallout:
		_bdbde.Value = "rightArrowCallout"
	case ST_ShapeTypeUpArrowCallout:
		_bdbde.Value = "upArrowCallout"
	case ST_ShapeTypeDownArrowCallout:
		_bdbde.Value = "downArrowCallout"
	case ST_ShapeTypeLeftRightArrowCallout:
		_bdbde.Value = "leftRightArrowCallout"
	case ST_ShapeTypeUpDownArrowCallout:
		_bdbde.Value = "upDownArrowCallout"
	case ST_ShapeTypeQuadArrowCallout:
		_bdbde.Value = "quadArrowCallout"
	case ST_ShapeTypeBentArrow:
		_bdbde.Value = "bentArrow"
	case ST_ShapeTypeUturnArrow:
		_bdbde.Value = "uturnArrow"
	case ST_ShapeTypeCircularArrow:
		_bdbde.Value = "circularArrow"
	case ST_ShapeTypeLeftCircularArrow:
		_bdbde.Value = "leftCircularArrow"
	case ST_ShapeTypeLeftRightCircularArrow:
		_bdbde.Value = "leftRightCircularArrow"
	case ST_ShapeTypeCurvedRightArrow:
		_bdbde.Value = "curvedRightArrow"
	case ST_ShapeTypeCurvedLeftArrow:
		_bdbde.Value = "curvedLeftArrow"
	case ST_ShapeTypeCurvedUpArrow:
		_bdbde.Value = "curvedUpArrow"
	case ST_ShapeTypeCurvedDownArrow:
		_bdbde.Value = "curvedDownArrow"
	case ST_ShapeTypeSwooshArrow:
		_bdbde.Value = "swooshArrow"
	case ST_ShapeTypeCube:
		_bdbde.Value = "cube"
	case ST_ShapeTypeCan:
		_bdbde.Value = "can"
	case ST_ShapeTypeLightningBolt:
		_bdbde.Value = "lightningBolt"
	case ST_ShapeTypeHeart:
		_bdbde.Value = "heart"
	case ST_ShapeTypeSun:
		_bdbde.Value = "sun"
	case ST_ShapeTypeMoon:
		_bdbde.Value = "moon"
	case ST_ShapeTypeSmileyFace:
		_bdbde.Value = "smileyFace"
	case ST_ShapeTypeIrregularSeal1:
		_bdbde.Value = "irregularSeal1"
	case ST_ShapeTypeIrregularSeal2:
		_bdbde.Value = "irregularSeal2"
	case ST_ShapeTypeFoldedCorner:
		_bdbde.Value = "foldedCorner"
	case ST_ShapeTypeBevel:
		_bdbde.Value = "bevel"
	case ST_ShapeTypeFrame:
		_bdbde.Value = "frame"
	case ST_ShapeTypeHalfFrame:
		_bdbde.Value = "halfFrame"
	case ST_ShapeTypeCorner:
		_bdbde.Value = "corner"
	case ST_ShapeTypeDiagStripe:
		_bdbde.Value = "diagStripe"
	case ST_ShapeTypeChord:
		_bdbde.Value = "chord"
	case ST_ShapeTypeArc:
		_bdbde.Value = "arc"
	case ST_ShapeTypeLeftBracket:
		_bdbde.Value = "leftBracket"
	case ST_ShapeTypeRightBracket:
		_bdbde.Value = "rightBracket"
	case ST_ShapeTypeLeftBrace:
		_bdbde.Value = "leftBrace"
	case ST_ShapeTypeRightBrace:
		_bdbde.Value = "rightBrace"
	case ST_ShapeTypeBracketPair:
		_bdbde.Value = "bracketPair"
	case ST_ShapeTypeBracePair:
		_bdbde.Value = "bracePair"
	case ST_ShapeTypeStraightConnector1:
		_bdbde.Value = "straightConnector1"
	case ST_ShapeTypeBentConnector2:
		_bdbde.Value = "bentConnector2"
	case ST_ShapeTypeBentConnector3:
		_bdbde.Value = "bentConnector3"
	case ST_ShapeTypeBentConnector4:
		_bdbde.Value = "bentConnector4"
	case ST_ShapeTypeBentConnector5:
		_bdbde.Value = "bentConnector5"
	case ST_ShapeTypeCurvedConnector2:
		_bdbde.Value = "curvedConnector2"
	case ST_ShapeTypeCurvedConnector3:
		_bdbde.Value = "curvedConnector3"
	case ST_ShapeTypeCurvedConnector4:
		_bdbde.Value = "curvedConnector4"
	case ST_ShapeTypeCurvedConnector5:
		_bdbde.Value = "curvedConnector5"
	case ST_ShapeTypeCallout1:
		_bdbde.Value = "callout1"
	case ST_ShapeTypeCallout2:
		_bdbde.Value = "callout2"
	case ST_ShapeTypeCallout3:
		_bdbde.Value = "callout3"
	case ST_ShapeTypeAccentCallout1:
		_bdbde.Value = "accentCallout1"
	case ST_ShapeTypeAccentCallout2:
		_bdbde.Value = "accentCallout2"
	case ST_ShapeTypeAccentCallout3:
		_bdbde.Value = "accentCallout3"
	case ST_ShapeTypeBorderCallout1:
		_bdbde.Value = "borderCallout1"
	case ST_ShapeTypeBorderCallout2:
		_bdbde.Value = "borderCallout2"
	case ST_ShapeTypeBorderCallout3:
		_bdbde.Value = "borderCallout3"
	case ST_ShapeTypeAccentBorderCallout1:
		_bdbde.Value = "accentBorderCallout1"
	case ST_ShapeTypeAccentBorderCallout2:
		_bdbde.Value = "accentBorderCallout2"
	case ST_ShapeTypeAccentBorderCallout3:
		_bdbde.Value = "accentBorderCallout3"
	case ST_ShapeTypeWedgeRectCallout:
		_bdbde.Value = "wedgeRectCallout"
	case ST_ShapeTypeWedgeRoundRectCallout:
		_bdbde.Value = "wedgeRoundRectCallout"
	case ST_ShapeTypeWedgeEllipseCallout:
		_bdbde.Value = "wedgeEllipseCallout"
	case ST_ShapeTypeCloudCallout:
		_bdbde.Value = "cloudCallout"
	case ST_ShapeTypeCloud:
		_bdbde.Value = "cloud"
	case ST_ShapeTypeRibbon:
		_bdbde.Value = "ribbon"
	case ST_ShapeTypeRibbon2:
		_bdbde.Value = "ribbon2"
	case ST_ShapeTypeEllipseRibbon:
		_bdbde.Value = "ellipseRibbon"
	case ST_ShapeTypeEllipseRibbon2:
		_bdbde.Value = "ellipseRibbon2"
	case ST_ShapeTypeLeftRightRibbon:
		_bdbde.Value = "leftRightRibbon"
	case ST_ShapeTypeVerticalScroll:
		_bdbde.Value = "verticalScroll"
	case ST_ShapeTypeHorizontalScroll:
		_bdbde.Value = "horizontalScroll"
	case ST_ShapeTypeWave:
		_bdbde.Value = "wave"
	case ST_ShapeTypeDoubleWave:
		_bdbde.Value = "doubleWave"
	case ST_ShapeTypePlus:
		_bdbde.Value = "plus"
	case ST_ShapeTypeFlowChartProcess:
		_bdbde.Value = "flowChartProcess"
	case ST_ShapeTypeFlowChartDecision:
		_bdbde.Value = "flowChartDecision"
	case ST_ShapeTypeFlowChartInputOutput:
		_bdbde.Value = "flowChartInputOutput"
	case ST_ShapeTypeFlowChartPredefinedProcess:
		_bdbde.Value = "flowChartPredefinedProcess"
	case ST_ShapeTypeFlowChartInternalStorage:
		_bdbde.Value = "flowChartInternalStorage"
	case ST_ShapeTypeFlowChartDocument:
		_bdbde.Value = "flowChartDocument"
	case ST_ShapeTypeFlowChartMultidocument:
		_bdbde.Value = "flowChartMultidocument"
	case ST_ShapeTypeFlowChartTerminator:
		_bdbde.Value = "flowChartTerminator"
	case ST_ShapeTypeFlowChartPreparation:
		_bdbde.Value = "flowChartPreparation"
	case ST_ShapeTypeFlowChartManualInput:
		_bdbde.Value = "flowChartManualInput"
	case ST_ShapeTypeFlowChartManualOperation:
		_bdbde.Value = "flowChartManualOperation"
	case ST_ShapeTypeFlowChartConnector:
		_bdbde.Value = "flowChartConnector"
	case ST_ShapeTypeFlowChartPunchedCard:
		_bdbde.Value = "flowChartPunchedCard"
	case ST_ShapeTypeFlowChartPunchedTape:
		_bdbde.Value = "flowChartPunchedTape"
	case ST_ShapeTypeFlowChartSummingJunction:
		_bdbde.Value = "flowChartSummingJunction"
	case ST_ShapeTypeFlowChartOr:
		_bdbde.Value = "flowChartOr"
	case ST_ShapeTypeFlowChartCollate:
		_bdbde.Value = "flowChartCollate"
	case ST_ShapeTypeFlowChartSort:
		_bdbde.Value = "flowChartSort"
	case ST_ShapeTypeFlowChartExtract:
		_bdbde.Value = "flowChartExtract"
	case ST_ShapeTypeFlowChartMerge:
		_bdbde.Value = "flowChartMerge"
	case ST_ShapeTypeFlowChartOfflineStorage:
		_bdbde.Value = "flowChartOfflineStorage"
	case ST_ShapeTypeFlowChartOnlineStorage:
		_bdbde.Value = "flowChartOnlineStorage"
	case ST_ShapeTypeFlowChartMagneticTape:
		_bdbde.Value = "flowChartMagneticTape"
	case ST_ShapeTypeFlowChartMagneticDisk:
		_bdbde.Value = "flowChartMagneticDisk"
	case ST_ShapeTypeFlowChartMagneticDrum:
		_bdbde.Value = "flowChartMagneticDrum"
	case ST_ShapeTypeFlowChartDisplay:
		_bdbde.Value = "flowChartDisplay"
	case ST_ShapeTypeFlowChartDelay:
		_bdbde.Value = "flowChartDelay"
	case ST_ShapeTypeFlowChartAlternateProcess:
		_bdbde.Value = "flowChartAlternateProcess"
	case ST_ShapeTypeFlowChartOffpageConnector:
		_bdbde.Value = "flowChartOffpageConnector"
	case ST_ShapeTypeActionButtonBlank:
		_bdbde.Value = "actionButtonBlank"
	case ST_ShapeTypeActionButtonHome:
		_bdbde.Value = "actionButtonHome"
	case ST_ShapeTypeActionButtonHelp:
		_bdbde.Value = "actionButtonHelp"
	case ST_ShapeTypeActionButtonInformation:
		_bdbde.Value = "actionButtonInformation"
	case ST_ShapeTypeActionButtonForwardNext:
		_bdbde.Value = "actionButtonForwardNext"
	case ST_ShapeTypeActionButtonBackPrevious:
		_bdbde.Value = "actionButtonBackPrevious"
	case ST_ShapeTypeActionButtonEnd:
		_bdbde.Value = "actionButtonEnd"
	case ST_ShapeTypeActionButtonBeginning:
		_bdbde.Value = "actionButtonBeginning"
	case ST_ShapeTypeActionButtonReturn:
		_bdbde.Value = "actionButtonReturn"
	case ST_ShapeTypeActionButtonDocument:
		_bdbde.Value = "actionButtonDocument"
	case ST_ShapeTypeActionButtonSound:
		_bdbde.Value = "actionButtonSound"
	case ST_ShapeTypeActionButtonMovie:
		_bdbde.Value = "actionButtonMovie"
	case ST_ShapeTypeGear6:
		_bdbde.Value = "gear6"
	case ST_ShapeTypeGear9:
		_bdbde.Value = "gear9"
	case ST_ShapeTypeFunnel:
		_bdbde.Value = "funnel"
	case ST_ShapeTypeMathPlus:
		_bdbde.Value = "mathPlus"
	case ST_ShapeTypeMathMinus:
		_bdbde.Value = "mathMinus"
	case ST_ShapeTypeMathMultiply:
		_bdbde.Value = "mathMultiply"
	case ST_ShapeTypeMathDivide:
		_bdbde.Value = "mathDivide"
	case ST_ShapeTypeMathEqual:
		_bdbde.Value = "mathEqual"
	case ST_ShapeTypeMathNotEqual:
		_bdbde.Value = "mathNotEqual"
	case ST_ShapeTypeCornerTabs:
		_bdbde.Value = "cornerTabs"
	case ST_ShapeTypeSquareTabs:
		_bdbde.Value = "squareTabs"
	case ST_ShapeTypePlaqueTabs:
		_bdbde.Value = "plaqueTabs"
	case ST_ShapeTypeChartX:
		_bdbde.Value = "chartX"
	case ST_ShapeTypeChartStar:
		_bdbde.Value = "chartStar"
	case ST_ShapeTypeChartPlus:
		_bdbde.Value = "chartPlus"
	}
	return _bdbde, nil
}
func NewCT_SchemeColor() *CT_SchemeColor {
	_bdebe := &CT_SchemeColor{}
	_bdebe.ValAttr = ST_SchemeColorVal(1)
	return _bdebe
}
func (_gfae *CT_DuotoneEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	for _, _dbdc := range _gfae.EG_ColorChoice {
		_dbdc.MarshalXML(e, _g.StartElement{})
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewEG_LineDashProperties() *EG_LineDashProperties {
	_ddcdef := &EG_LineDashProperties{}
	return _ddcdef
}
func (_gcdda *CT_FillProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _gcdda.NoFill != nil {
		_bce := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_gcdda.NoFill, _bce)
	}
	if _gcdda.SolidFill != nil {
		_ccda := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_gcdda.SolidFill, _ccda)
	}
	if _gcdda.GradFill != nil {
		_abfa := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_gcdda.GradFill, _abfa)
	}
	if _gcdda.BlipFill != nil {
		_fafd := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
		e.EncodeElement(_gcdda.BlipFill, _fafd)
	}
	if _gcdda.PattFill != nil {
		_gddcd := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_gcdda.PattFill, _gddcd)
	}
	if _gcdda.GrpFill != nil {
		_ggbdb := _g.StartElement{Name: _g.Name{Local: "a:grpFill"}}
		e.EncodeElement(_gcdda.GrpFill, _ggbdb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ColorReplaceEffect and its children, prefixing error messages with path
func (_fecf *CT_ColorReplaceEffect) ValidateWithPath(path string) error {
	if _fecf.ScrgbClr != nil {
		if _eggg := _fecf.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _eggg != nil {
			return _eggg
		}
	}
	if _fecf.SrgbClr != nil {
		if _dacg := _fecf.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _dacg != nil {
			return _dacg
		}
	}
	if _fecf.HslClr != nil {
		if _afga := _fecf.HslClr.ValidateWithPath(path + "\u002fHslClr"); _afga != nil {
			return _afga
		}
	}
	if _fecf.SysClr != nil {
		if _cbbf := _fecf.SysClr.ValidateWithPath(path + "\u002fSysClr"); _cbbf != nil {
			return _cbbf
		}
	}
	if _fecf.SchemeClr != nil {
		if _bbgdb := _fecf.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _bbgdb != nil {
			return _bbgdb
		}
	}
	if _fecf.PrstClr != nil {
		if _eeaed := _fecf.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _eeaed != nil {
			return _eeaed
		}
	}
	return nil
}
func (_bfdab ST_PresetPatternVal) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_debaf := _g.Attr{}
	_debaf.Name = name
	switch _bfdab {
	case ST_PresetPatternValUnset:
		_debaf.Value = ""
	case ST_PresetPatternValPct5:
		_debaf.Value = "pct5"
	case ST_PresetPatternValPct10:
		_debaf.Value = "pct10"
	case ST_PresetPatternValPct20:
		_debaf.Value = "pct20"
	case ST_PresetPatternValPct25:
		_debaf.Value = "pct25"
	case ST_PresetPatternValPct30:
		_debaf.Value = "pct30"
	case ST_PresetPatternValPct40:
		_debaf.Value = "pct40"
	case ST_PresetPatternValPct50:
		_debaf.Value = "pct50"
	case ST_PresetPatternValPct60:
		_debaf.Value = "pct60"
	case ST_PresetPatternValPct70:
		_debaf.Value = "pct70"
	case ST_PresetPatternValPct75:
		_debaf.Value = "pct75"
	case ST_PresetPatternValPct80:
		_debaf.Value = "pct80"
	case ST_PresetPatternValPct90:
		_debaf.Value = "pct90"
	case ST_PresetPatternValHorz:
		_debaf.Value = "horz"
	case ST_PresetPatternValVert:
		_debaf.Value = "vert"
	case ST_PresetPatternValLtHorz:
		_debaf.Value = "ltHorz"
	case ST_PresetPatternValLtVert:
		_debaf.Value = "ltVert"
	case ST_PresetPatternValDkHorz:
		_debaf.Value = "dkHorz"
	case ST_PresetPatternValDkVert:
		_debaf.Value = "dkVert"
	case ST_PresetPatternValNarHorz:
		_debaf.Value = "narHorz"
	case ST_PresetPatternValNarVert:
		_debaf.Value = "narVert"
	case ST_PresetPatternValDashHorz:
		_debaf.Value = "dashHorz"
	case ST_PresetPatternValDashVert:
		_debaf.Value = "dashVert"
	case ST_PresetPatternValCross:
		_debaf.Value = "cross"
	case ST_PresetPatternValDnDiag:
		_debaf.Value = "dnDiag"
	case ST_PresetPatternValUpDiag:
		_debaf.Value = "upDiag"
	case ST_PresetPatternValLtDnDiag:
		_debaf.Value = "ltDnDiag"
	case ST_PresetPatternValLtUpDiag:
		_debaf.Value = "ltUpDiag"
	case ST_PresetPatternValDkDnDiag:
		_debaf.Value = "dkDnDiag"
	case ST_PresetPatternValDkUpDiag:
		_debaf.Value = "dkUpDiag"
	case ST_PresetPatternValWdDnDiag:
		_debaf.Value = "wdDnDiag"
	case ST_PresetPatternValWdUpDiag:
		_debaf.Value = "wdUpDiag"
	case ST_PresetPatternValDashDnDiag:
		_debaf.Value = "dashDnDiag"
	case ST_PresetPatternValDashUpDiag:
		_debaf.Value = "dashUpDiag"
	case ST_PresetPatternValDiagCross:
		_debaf.Value = "diagCross"
	case ST_PresetPatternValSmCheck:
		_debaf.Value = "smCheck"
	case ST_PresetPatternValLgCheck:
		_debaf.Value = "lgCheck"
	case ST_PresetPatternValSmGrid:
		_debaf.Value = "smGrid"
	case ST_PresetPatternValLgGrid:
		_debaf.Value = "lgGrid"
	case ST_PresetPatternValDotGrid:
		_debaf.Value = "dotGrid"
	case ST_PresetPatternValSmConfetti:
		_debaf.Value = "smConfetti"
	case ST_PresetPatternValLgConfetti:
		_debaf.Value = "lgConfetti"
	case ST_PresetPatternValHorzBrick:
		_debaf.Value = "horzBrick"
	case ST_PresetPatternValDiagBrick:
		_debaf.Value = "diagBrick"
	case ST_PresetPatternValSolidDmnd:
		_debaf.Value = "solidDmnd"
	case ST_PresetPatternValOpenDmnd:
		_debaf.Value = "openDmnd"
	case ST_PresetPatternValDotDmnd:
		_debaf.Value = "dotDmnd"
	case ST_PresetPatternValPlaid:
		_debaf.Value = "plaid"
	case ST_PresetPatternValSphere:
		_debaf.Value = "sphere"
	case ST_PresetPatternValWeave:
		_debaf.Value = "weave"
	case ST_PresetPatternValDivot:
		_debaf.Value = "divot"
	case ST_PresetPatternValShingle:
		_debaf.Value = "shingle"
	case ST_PresetPatternValWave:
		_debaf.Value = "wave"
	case ST_PresetPatternValTrellis:
		_debaf.Value = "trellis"
	case ST_PresetPatternValZigZag:
		_debaf.Value = "zigZag"
	}
	return _debaf, nil
}
func (_aegcaf *EG_FillModeProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_ccafg:
	for {
		_cafbd, _egdac := d.Token()
		if _egdac != nil {
			return _egdac
		}
		switch _becac := _cafbd.(type) {
		case _g.StartElement:
			switch _becac.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tile"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tile"}:
				_aegcaf.Tile = NewCT_TileInfoProperties()
				if _dafc := d.DecodeElement(_aegcaf.Tile, &_becac); _dafc != nil {
					return _dafc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "stretch"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "stretch"}:
				_aegcaf.Stretch = NewCT_StretchInfoProperties()
				if _gdbbg := d.DecodeElement(_aegcaf.Stretch, &_becac); _gdbbg != nil {
					return _gdbbg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on EG_FillModeProperties\u0020\u0025v", _becac.Name)
				if _egacf := d.Skip(); _egacf != nil {
					return _egacf
				}
			}
		case _g.EndElement:
			break _ccafg
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TileInfoProperties and its children, prefixing error messages with path
func (_eedba *CT_TileInfoProperties) ValidateWithPath(path string) error {
	if _eedba.TxAttr != nil {
		if _cbeeb := _eedba.TxAttr.ValidateWithPath(path + "\u002fTxAttr"); _cbeeb != nil {
			return _cbeeb
		}
	}
	if _eedba.TyAttr != nil {
		if _gbbgg := _eedba.TyAttr.ValidateWithPath(path + "\u002fTyAttr"); _gbbgg != nil {
			return _gbbgg
		}
	}
	if _eedba.SxAttr != nil {
		if _bgde := _eedba.SxAttr.ValidateWithPath(path + "\u002fSxAttr"); _bgde != nil {
			return _bgde
		}
	}
	if _eedba.SyAttr != nil {
		if _gdgee := _eedba.SyAttr.ValidateWithPath(path + "\u002fSyAttr"); _gdgee != nil {
			return _gdgee
		}
	}
	if _ggfab := _eedba.FlipAttr.ValidateWithPath(path + "\u002fFlipAttr"); _ggfab != nil {
		return _ggfab
	}
	if _ecdea := _eedba.AlgnAttr.ValidateWithPath(path + "\u002fAlgnAttr"); _ecdea != nil {
		return _ecdea
	}
	return nil
}
func NewEG_TextGeometry() *EG_TextGeometry { _bffcf := &EG_TextGeometry{}; return _bffcf }

type CT_Point2D struct {
	XAttr ST_Coordinate
	YAttr ST_Coordinate
}

// ST_TextBulletSize is a union type
type ST_TextBulletSize struct {
	ST_TextBulletSizePercent *string
	ST_TextBulletSizeDecimal *int32
}

func NewCT_WholeE2oFormatting() *CT_WholeE2oFormatting {
	_ffccbf := &CT_WholeE2oFormatting{}
	return _ffccbf
}

// ValidateWithPath validates the CT_CustomColorList and its children, prefixing error messages with path
func (_cbea *CT_CustomColorList) ValidateWithPath(path string) error {
	for _dcbb, _fbdad := range _cbea.CustClr {
		if _bebf := _fbdad.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fCustClr\u005b\u0025d\u005d", path, _dcbb)); _bebf != nil {
			return _bebf
		}
	}
	return nil
}
func (_ceedc *CT_RegularTextRun) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _ceedc.RPr != nil {
		_affed := _g.StartElement{Name: _g.Name{Local: "a:rPr"}}
		e.EncodeElement(_ceedc.RPr, _affed)
	}
	_fddaa := _g.StartElement{Name: _g.Name{Local: "a:t"}}
	_ee.AddPreserveSpaceAttr(&_fddaa, _ceedc.T)
	e.EncodeElement(_ceedc.T, _fddaa)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_befe *CT_ConnectionSiteList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _befe.Cxn != nil {
		_ggdg := _g.StartElement{Name: _g.Name{Local: "a:cxn"}}
		for _, _gaag := range _befe.Cxn {
			e.EncodeElement(_gaag, _ggdg)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_LineEndProperties and its children, prefixing error messages with path
func (_ebgca *CT_LineEndProperties) ValidateWithPath(path string) error {
	if _aedg := _ebgca.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _aedg != nil {
		return _aedg
	}
	if _eedd := _ebgca.WAttr.ValidateWithPath(path + "\u002fWAttr"); _eedd != nil {
		return _eedd
	}
	if _ecgce := _ebgca.LenAttr.ValidateWithPath(path + "\u002fLenAttr"); _ecgce != nil {
		return _ecgce
	}
	return nil
}
func NewCT_GradientStopList() *CT_GradientStopList { _cfec := &CT_GradientStopList{}; return _cfec }

type CT_PresetTextShape struct {
	PrstAttr ST_TextShapeType
	AvLst    *CT_GeomGuideList
}

func (_ecgad ST_TextUnderlineType) Validate() error { return _ecgad.ValidateWithPath("") }

type Graphic struct{ CT_GraphicalObject }

// ValidateWithPath validates the CT_GeomGuideList and its children, prefixing error messages with path
func (_dgaad *CT_GeomGuideList) ValidateWithPath(path string) error {
	for _abgf, _bgea := range _dgaad.Gd {
		if _fgdb := _bgea.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fGd\u005b\u0025d]", path, _abgf)); _fgdb != nil {
			return _fgdb
		}
	}
	return nil
}
func (_feebg *CT_NonVisualGroupDrawingShapeProps) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _feebg.GrpSpLocks != nil {
		_gecad := _g.StartElement{Name: _g.Name{Local: "a:grpSpLocks"}}
		e.EncodeElement(_feebg.GrpSpLocks, _gecad)
	}
	if _feebg.ExtLst != nil {
		_fgca := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_feebg.ExtLst, _fgca)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_dgafa *CT_GradientStopList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gdaf:
	for {
		_cdba, _aaefd := d.Token()
		if _aaefd != nil {
			return _aaefd
		}
		switch _gcae := _cdba.(type) {
		case _g.StartElement:
			switch _gcae.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gs"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gs"}:
				_bbfg := NewCT_GradientStop()
				if _eddd := d.DecodeElement(_bbfg, &_gcae); _eddd != nil {
					return _eddd
				}
				_dgafa.Gs = append(_dgafa.Gs, _bbfg)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GradientStopList\u0020\u0025v", _gcae.Name)
				if _caged := d.Skip(); _caged != nil {
					return _caged
				}
			}
		case _g.EndElement:
			break _gdaf
		case _g.CharData:
		}
	}
	return nil
}
func (_bdbgfe ST_TextAlignType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_bdbgfe.String(), start)
}
func (_gaecc *CT_SphereCoords) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lat"}, Value: _dcf.Sprintf("\u0025v", _gaecc.LatAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lon"}, Value: _dcf.Sprintf("\u0025v", _gaecc.LonAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rev"}, Value: _dcf.Sprintf("\u0025v", _gaecc.RevAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_cgag ST_ChartBuildStep) Validate() error { return _cgag.ValidateWithPath("") }

// Validate validates the CT_ObjectStyleDefaults and its children
func (_cdfee *CT_ObjectStyleDefaults) Validate() error {
	return _cdfee.ValidateWithPath("CT_ObjectStyleDefaults")
}

type EG_ShadeProperties struct {
	Lin  *CT_LinearShadeProperties
	Path *CT_PathShadeProperties
}

// ValidateWithPath validates the CT_NonVisualDrawingShapeProps and its children, prefixing error messages with path
func (_edagf *CT_NonVisualDrawingShapeProps) ValidateWithPath(path string) error {
	if _edagf.SpLocks != nil {
		if _ecfbd := _edagf.SpLocks.ValidateWithPath(path + "\u002fSpLocks"); _ecfbd != nil {
			return _ecfbd
		}
	}
	if _edagf.ExtLst != nil {
		if _gfbdd := _edagf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gfbdd != nil {
			return _gfbdd
		}
	}
	return nil
}

// Validate validates the CT_PresetColor and its children
func (_ddce *CT_PresetColor) Validate() error { return _ddce.ValidateWithPath("CT_PresetColor") }

// Validate validates the CT_TablePropertiesChoice and its children
func (_faecc *CT_TablePropertiesChoice) Validate() error {
	return _faecc.ValidateWithPath("CT_TablePropertiesChoice")
}

// Validate validates the CT_ContentPartLocking and its children
func (_dgfdg *CT_ContentPartLocking) Validate() error {
	return _dgfdg.ValidateWithPath("CT_ContentPartLocking")
}

// Validate validates the CT_BlipChoice and its children
func (_bbfc *CT_BlipChoice) Validate() error { return _bbfc.ValidateWithPath("CT_BlipChoice") }

// ValidateWithPath validates the Theme and its children, prefixing error messages with path
func (_cccee *Theme) ValidateWithPath(path string) error {
	if _gcaad := _cccee.CT_OfficeStyleSheet.ValidateWithPath(path); _gcaad != nil {
		return _gcaad
	}
	return nil
}
func (_dbfbe ST_LineEndWidth) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dfcde := _g.Attr{}
	_dfcde.Name = name
	switch _dbfbe {
	case ST_LineEndWidthUnset:
		_dfcde.Value = ""
	case ST_LineEndWidthSm:
		_dfcde.Value = "sm"
	case ST_LineEndWidthMed:
		_dfcde.Value = "med"
	case ST_LineEndWidthLg:
		_dfcde.Value = "lg"
	}
	return _dfcde, nil
}

// ValidateWithPath validates the CT_GvmlGroupShape and its children, prefixing error messages with path
func (_fabd *CT_GvmlGroupShape) ValidateWithPath(path string) error {
	if _cbfcg := _fabd.NvGrpSpPr.ValidateWithPath(path + "\u002fNvGrpSpPr"); _cbfcg != nil {
		return _cbfcg
	}
	if _ggdff := _fabd.GrpSpPr.ValidateWithPath(path + "\u002fGrpSpPr"); _ggdff != nil {
		return _ggdff
	}
	for _gbgcb, _gaefa := range _fabd.Choice {
		if _fbdga := _gaefa.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fChoice\u005b\u0025d\u005d", path, _gbgcb)); _fbdga != nil {
			return _fbdga
		}
	}
	if _fabd.ExtLst != nil {
		if _acefa := _fabd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _acefa != nil {
			return _acefa
		}
	}
	return nil
}
func NewCT_HslColor() *CT_HslColor { _ccgc := &CT_HslColor{}; _ccgc.HueAttr = 0; return _ccgc }
func (_bbg *CT_AdjustHandleList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _bbg.AhXY != nil {
		_afef := _g.StartElement{Name: _g.Name{Local: "a:ahXY"}}
		for _, _gbg := range _bbg.AhXY {
			e.EncodeElement(_gbg, _afef)
		}
	}
	if _bbg.AhPolar != nil {
		_gcd := _g.StartElement{Name: _g.Name{Local: "a:ahPolar"}}
		for _, _bfd := range _bbg.AhPolar {
			e.EncodeElement(_bfd, _gcd)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Path2DClose and its children
func (_dcgc *CT_Path2DClose) Validate() error { return _dcgc.ValidateWithPath("CT_Path2DClose") }

// ValidateWithPath validates the CT_GvmlShape and its children, prefixing error messages with path
func (_agced *CT_GvmlShape) ValidateWithPath(path string) error {
	if _baba := _agced.NvSpPr.ValidateWithPath(path + "\u002fNvSpPr"); _baba != nil {
		return _baba
	}
	if _adcb := _agced.SpPr.ValidateWithPath(path + "\u002fSpPr"); _adcb != nil {
		return _adcb
	}
	if _agced.TxSp != nil {
		if _bagbb := _agced.TxSp.ValidateWithPath(path + "\u002fTxSp"); _bagbb != nil {
			return _bagbb
		}
	}
	if _agced.Style != nil {
		if _effec := _agced.Style.ValidateWithPath(path + "\u002fStyle"); _effec != nil {
			return _effec
		}
	}
	if _agced.ExtLst != nil {
		if _dbfde := _agced.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dbfde != nil {
			return _dbfde
		}
	}
	return nil
}

// ValidateWithPath validates the CT_DashStop and its children, prefixing error messages with path
func (_badd *CT_DashStop) ValidateWithPath(path string) error {
	if _dfab := _badd.DAttr.ValidateWithPath(path + "\u002fDAttr"); _dfab != nil {
		return _dfab
	}
	if _fagb := _badd.SpAttr.ValidateWithPath(path + "\u002fSpAttr"); _fagb != nil {
		return _fagb
	}
	return nil
}
func (_befaa *CT_TextSpacing) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_dgbac:
	for {
		_dgbgf, _cbcef := d.Token()
		if _cbcef != nil {
			return _cbcef
		}
		switch _eddda := _dgbgf.(type) {
		case _g.StartElement:
			switch _eddda.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spcPct"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spcPct"}:
				_befaa.SpcPct = NewCT_TextSpacingPercent()
				if _aebg := d.DecodeElement(_befaa.SpcPct, &_eddda); _aebg != nil {
					return _aebg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spcPts"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spcPts"}:
				_befaa.SpcPts = NewCT_TextSpacingPoint()
				if _abcfe := d.DecodeElement(_befaa.SpcPts, &_eddda); _abcfe != nil {
					return _abcfe
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TextSpacing\u0020\u0025v", _eddda.Name)
				if _gbgff := d.Skip(); _gbgff != nil {
					return _gbgff
				}
			}
		case _g.EndElement:
			break _dgbac
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the EG_FillProperties and its children, prefixing error messages with path
func (_fbcfa *EG_FillProperties) ValidateWithPath(path string) error {
	if _fbcfa.NoFill != nil {
		if _gaecg := _fbcfa.NoFill.ValidateWithPath(path + "\u002fNoFill"); _gaecg != nil {
			return _gaecg
		}
	}
	if _fbcfa.SolidFill != nil {
		if _cadaa := _fbcfa.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _cadaa != nil {
			return _cadaa
		}
	}
	if _fbcfa.GradFill != nil {
		if _agcdb := _fbcfa.GradFill.ValidateWithPath(path + "\u002fGradFill"); _agcdb != nil {
			return _agcdb
		}
	}
	if _fbcfa.BlipFill != nil {
		if _bfdbg := _fbcfa.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _bfdbg != nil {
			return _bfdbg
		}
	}
	if _fbcfa.PattFill != nil {
		if _dbgbc := _fbcfa.PattFill.ValidateWithPath(path + "\u002fPattFill"); _dbgbc != nil {
			return _dbgbc
		}
	}
	if _fbcfa.GrpFill != nil {
		if _adabb := _fbcfa.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _adabb != nil {
			return _adabb
		}
	}
	return nil
}

type ST_TextAnchoringType byte

func (_ccggcg *CT_TextUnderlineLineFollowText) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_AlphaCeilingEffect() *CT_AlphaCeilingEffect { _adb := &CT_AlphaCeilingEffect{}; return _adb }

// ValidateWithPath validates the CT_CustomColor and its children, prefixing error messages with path
func (_cgc *CT_CustomColor) ValidateWithPath(path string) error {
	if _cgc.ScrgbClr != nil {
		if _dagcg := _cgc.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _dagcg != nil {
			return _dagcg
		}
	}
	if _cgc.SrgbClr != nil {
		if _dfea := _cgc.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _dfea != nil {
			return _dfea
		}
	}
	if _cgc.HslClr != nil {
		if _gbba := _cgc.HslClr.ValidateWithPath(path + "\u002fHslClr"); _gbba != nil {
			return _gbba
		}
	}
	if _cgc.SysClr != nil {
		if _edcff := _cgc.SysClr.ValidateWithPath(path + "\u002fSysClr"); _edcff != nil {
			return _edcff
		}
	}
	if _cgc.SchemeClr != nil {
		if _eabe := _cgc.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _eabe != nil {
			return _eabe
		}
	}
	if _cgc.PrstClr != nil {
		if _fefc := _cgc.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _fefc != nil {
			return _fefc
		}
	}
	return nil
}

type CT_LinearShadeProperties struct {
	AngAttr    *int32
	ScaledAttr *bool
}
type CT_AnimationChartElement struct {
	SeriesIdxAttr   *int32
	CategoryIdxAttr *int32
	BldStepAttr     ST_ChartBuildStep
}
type CT_Table struct {
	TblPr   *CT_TableProperties
	TblGrid *CT_TableGrid
	Tr      []*CT_TableRow
}

func (_fgdgc *EG_LineJoinProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fgdgc.Round != nil {
		_dfdcfe := _g.StartElement{Name: _g.Name{Local: "a:round"}}
		e.EncodeElement(_fgdgc.Round, _dfdcfe)
	}
	if _fgdgc.Bevel != nil {
		_ddbef := _g.StartElement{Name: _g.Name{Local: "a:bevel"}}
		e.EncodeElement(_fgdgc.Bevel, _ddbef)
	}
	if _fgdgc.Miter != nil {
		_cdeec := _g.StartElement{Name: _g.Name{Local: "a:miter"}}
		e.EncodeElement(_fgdgc.Miter, _cdeec)
	}
	return nil
}
func NewCT_Path2DCubicBezierTo() *CT_Path2DCubicBezierTo {
	_ebef := &CT_Path2DCubicBezierTo{}
	return _ebef
}

type CT_TableGrid struct{ GridCol []*CT_TableCol }

func (_ffefa *CT_PositiveSize2D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ffefa.CxAttr = 0
	_ffefa.CyAttr = 0
	for _, _febgc := range start.Attr {
		if _febgc.Name.Local == "cx" {
			_ccee, _bfggf := _e.ParseInt(_febgc.Value, 10, 64)
			if _bfggf != nil {
				return _bfggf
			}
			_ffefa.CxAttr = _ccee
			continue
		}
		if _febgc.Name.Local == "cy" {
			_dfaf, _feed := _e.ParseInt(_febgc.Value, 10, 64)
			if _feed != nil {
				return _feed
			}
			_ffefa.CyAttr = _dfaf
			continue
		}
	}
	for {
		_dcgcc, _dggbd := d.Token()
		if _dggbd != nil {
			return _dcf.Errorf("parsing\u0020CT_PositiveSize2D: \u0025s", _dggbd)
		}
		if _bedfd, _cefdb := _dcgcc.(_g.EndElement); _cefdb && _bedfd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bdeff ST_TextAnchoringType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_afeag := _g.Attr{}
	_afeag.Name = name
	switch _bdeff {
	case ST_TextAnchoringTypeUnset:
		_afeag.Value = ""
	case ST_TextAnchoringTypeT:
		_afeag.Value = "t"
	case ST_TextAnchoringTypeCtr:
		_afeag.Value = "ctr"
	case ST_TextAnchoringTypeB:
		_afeag.Value = "b"
	case ST_TextAnchoringTypeJust:
		_afeag.Value = "just"
	case ST_TextAnchoringTypeDist:
		_afeag.Value = "dist"
	}
	return _afeag, nil
}
func NewCT_HSLEffect() *CT_HSLEffect { _bbgec := &CT_HSLEffect{}; return _bbgec }

type CT_TableStyleTextStyle struct {
	BAttr     ST_OnOffStyleType
	IAttr     ST_OnOffStyleType
	Font      *CT_FontCollection
	FontRef   *CT_FontReference
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
	ExtLst    *CT_OfficeArtExtensionList
}

func (_ccgbf ST_PositiveFixedPercentage) String() string {
	if _ccgbf.ST_PositiveFixedPercentageDecimal != nil {
		return _dcf.Sprintf("\u0025v", *_ccgbf.ST_PositiveFixedPercentageDecimal)
	}
	if _ccgbf.ST_PositiveFixedPercentage != nil {
		return _ccgbf.ST_PositiveFixedPercentage.String()
	}
	return ""
}
func (_fbcf *CT_GammaTransform) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_faec, _aegb := d.Token()
		if _aegb != nil {
			return _dcf.Errorf("parsing\u0020CT_GammaTransform: \u0025s", _aegb)
		}
		if _aedc, _cddg := _faec.(_g.EndElement); _cddg && _aedc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dgefa *CT_SoftEdgesEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rad"}, Value: _dcf.Sprintf("\u0025v", _dgefa.RadAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_GeomGuideList struct{ Gd []*CT_GeomGuide }

func (_eabac *CT_TextParagraph) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _eabac.PPr != nil {
		_gdafg := _g.StartElement{Name: _g.Name{Local: "a:pPr"}}
		e.EncodeElement(_eabac.PPr, _gdafg)
	}
	if _eabac.EG_TextRun != nil {
		for _, _gafeb := range _eabac.EG_TextRun {
			_gafeb.MarshalXML(e, _g.StartElement{})
		}
	}
	if _eabac.EndParaRPr != nil {
		_deab := _g.StartElement{Name: _g.Name{Local: "a:endParaRPr"}}
		e.EncodeElement(_eabac.EndParaRPr, _deab)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TextField and its children
func (_gcffc *CT_TextField) Validate() error { return _gcffc.ValidateWithPath("CT_TextField") }
func (_dcadf *CT_GroupLocking) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dcadf.NoGrpAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noGrp"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcadf.NoGrpAttr))})
	}
	if _dcadf.NoUngrpAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noUngrp"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcadf.NoUngrpAttr))})
	}
	if _dcadf.NoSelectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noSelect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcadf.NoSelectAttr))})
	}
	if _dcadf.NoRotAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noRot"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcadf.NoRotAttr))})
	}
	if _dcadf.NoChangeAspectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeAspect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcadf.NoChangeAspectAttr))})
	}
	if _dcadf.NoMoveAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noMove"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcadf.NoMoveAttr))})
	}
	if _dcadf.NoResizeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noResize"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcadf.NoResizeAttr))})
	}
	e.EncodeToken(start)
	if _dcadf.ExtLst != nil {
		_caagb := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dcadf.ExtLst, _caagb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_LineProperties and its children, prefixing error messages with path
func (_ggce *CT_LineProperties) ValidateWithPath(path string) error {
	if _ggce.WAttr != nil {
		if *_ggce.WAttr < 0 {
			return _dcf.Errorf("\u0025s\u002fm\u002eWAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_ggce.WAttr)
		}
		if *_ggce.WAttr > 20116800 {
			return _dcf.Errorf("%s\u002fm\u002eWAttr\u0020must\u0020be\u0020<\u003d\u002020116800 (have\u0020%v\u0029", path, *_ggce.WAttr)
		}
	}
	if _cgfg := _ggce.CapAttr.ValidateWithPath(path + "\u002fCapAttr"); _cgfg != nil {
		return _cgfg
	}
	if _eadbeg := _ggce.CmpdAttr.ValidateWithPath(path + "\u002fCmpdAttr"); _eadbeg != nil {
		return _eadbeg
	}
	if _gcdfd := _ggce.AlgnAttr.ValidateWithPath(path + "\u002fAlgnAttr"); _gcdfd != nil {
		return _gcdfd
	}
	if _ggce.NoFill != nil {
		if _ebgag := _ggce.NoFill.ValidateWithPath(path + "\u002fNoFill"); _ebgag != nil {
			return _ebgag
		}
	}
	if _ggce.SolidFill != nil {
		if _afbbc := _ggce.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _afbbc != nil {
			return _afbbc
		}
	}
	if _ggce.GradFill != nil {
		if _fcgag := _ggce.GradFill.ValidateWithPath(path + "\u002fGradFill"); _fcgag != nil {
			return _fcgag
		}
	}
	if _ggce.PattFill != nil {
		if _edeef := _ggce.PattFill.ValidateWithPath(path + "\u002fPattFill"); _edeef != nil {
			return _edeef
		}
	}
	if _ggce.PrstDash != nil {
		if _bfdb := _ggce.PrstDash.ValidateWithPath(path + "\u002fPrstDash"); _bfdb != nil {
			return _bfdb
		}
	}
	if _ggce.CustDash != nil {
		if _acgce := _ggce.CustDash.ValidateWithPath(path + "\u002fCustDash"); _acgce != nil {
			return _acgce
		}
	}
	if _ggce.Round != nil {
		if _ebegb := _ggce.Round.ValidateWithPath(path + "\u002fRound"); _ebegb != nil {
			return _ebegb
		}
	}
	if _ggce.Bevel != nil {
		if _egafg := _ggce.Bevel.ValidateWithPath(path + "\u002fBevel"); _egafg != nil {
			return _egafg
		}
	}
	if _ggce.Miter != nil {
		if _bagd := _ggce.Miter.ValidateWithPath(path + "\u002fMiter"); _bagd != nil {
			return _bagd
		}
	}
	if _ggce.HeadEnd != nil {
		if _ebacg := _ggce.HeadEnd.ValidateWithPath(path + "\u002fHeadEnd"); _ebacg != nil {
			return _ebacg
		}
	}
	if _ggce.TailEnd != nil {
		if _dadfb := _ggce.TailEnd.ValidateWithPath(path + "\u002fTailEnd"); _dadfb != nil {
			return _dadfb
		}
	}
	if _ggce.ExtLst != nil {
		if _affc := _ggce.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _affc != nil {
			return _affc
		}
	}
	return nil
}
func (_baaeg ST_TextFontScalePercentOrPercentString) String() string {
	if _baaeg.ST_TextFontScalePercent != nil {
		return _dcf.Sprintf("\u0025v", *_baaeg.ST_TextFontScalePercent)
	}
	if _baaeg.ST_Percentage != nil {
		return _dcf.Sprintf("\u0025v", *_baaeg.ST_Percentage)
	}
	return ""
}

// ValidateWithPath validates the AG_Locking and its children, prefixing error messages with path
func (_ab *AG_Locking) ValidateWithPath(path string) error { return nil }
func (_gbeb *CT_TextUnderlineFillGroupWrapper) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gdffg:
	for {
		_eaeea, _bfgff := d.Token()
		if _bfgff != nil {
			return _bfgff
		}
		switch _dbaae := _eaeea.(type) {
		case _g.StartElement:
			switch _dbaae.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_gbeb.NoFill = NewCT_NoFillProperties()
				if _gdcbg := d.DecodeElement(_gbeb.NoFill, &_dbaae); _gdcbg != nil {
					return _gdcbg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_gbeb.SolidFill = NewCT_SolidColorFillProperties()
				if _aggee := d.DecodeElement(_gbeb.SolidFill, &_dbaae); _aggee != nil {
					return _aggee
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_gbeb.GradFill = NewCT_GradientFillProperties()
				if _febcc := d.DecodeElement(_gbeb.GradFill, &_dbaae); _febcc != nil {
					return _febcc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_gbeb.BlipFill = NewCT_BlipFillProperties()
				if _gbbcb := d.DecodeElement(_gbeb.BlipFill, &_dbaae); _gbbcb != nil {
					return _gbbcb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_gbeb.PattFill = NewCT_PatternFillProperties()
				if _ggfaad := d.DecodeElement(_gbeb.PattFill, &_dbaae); _ggfaad != nil {
					return _ggfaad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_gbeb.GrpFill = NewCT_GroupFillProperties()
				if _ggccd := d.DecodeElement(_gbeb.GrpFill, &_dbaae); _ggccd != nil {
					return _ggccd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TextUnderlineFillGroupWrapper\u0020\u0025v", _dbaae.Name)
				if _aaadg := d.Skip(); _aaadg != nil {
					return _aaadg
				}
			}
		case _g.EndElement:
			break _gdffg
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_CustomColor() *CT_CustomColor { _eccd := &CT_CustomColor{}; return _eccd }
func (_ccfab *CT_TableCell) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _ccfab.RowSpanAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rowSpan"}, Value: _dcf.Sprintf("\u0025v", *_ccfab.RowSpanAttr)})
	}
	if _ccfab.GridSpanAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "gridSpan"}, Value: _dcf.Sprintf("\u0025v", *_ccfab.GridSpanAttr)})
	}
	if _ccfab.HMergeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "hMerge"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ccfab.HMergeAttr))})
	}
	if _ccfab.VMergeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "vMerge"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ccfab.VMergeAttr))})
	}
	if _ccfab.IdAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "id"}, Value: _dcf.Sprintf("\u0025v", *_ccfab.IdAttr)})
	}
	e.EncodeToken(start)
	if _ccfab.TxBody != nil {
		_gdgag := _g.StartElement{Name: _g.Name{Local: "a:txBody"}}
		e.EncodeElement(_ccfab.TxBody, _gdgag)
	}
	if _ccfab.TcPr != nil {
		_eccae := _g.StartElement{Name: _g.Name{Local: "a:tcPr"}}
		e.EncodeElement(_ccfab.TcPr, _eccae)
	}
	if _ccfab.ExtLst != nil {
		_ccgfg := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_ccfab.ExtLst, _ccgfg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the EG_ThemeableFillStyle and its children
func (_cgecg *EG_ThemeableFillStyle) Validate() error {
	return _cgecg.ValidateWithPath("EG_ThemeableFillStyle")
}
func NewCT_GraphicalObjectFrameLocking() *CT_GraphicalObjectFrameLocking {
	_deaa := &CT_GraphicalObjectFrameLocking{}
	return _deaa
}

// Validate validates the CT_NonVisualPictureProperties and its children
func (_dcgef *CT_NonVisualPictureProperties) Validate() error {
	return _dcgef.ValidateWithPath("CT_NonVisualPictureProperties")
}
func ParseUnionST_FixedPercentage(s string) (ST_FixedPercentage, error) {
	_ceabfc := ST_FixedPercentage{}
	if _f.ST_FixedPercentagePatternRe.MatchString(s) {
		_ceabfc.ST_FixedPercentage = &ST_Percentage{}
		_ceabfc.ST_FixedPercentage.ST_Percentage = &s
	} else {
		_bbeeg, _gdfgd := _e.ParseInt(s, 10, 64)
		if _gdfgd != nil {
			return _ceabfc, _dcf.Errorf("parsing\u0020\u0025s\u0020as\u0020int", _gdfgd)
		}
		_afbdfc := int32(_bbeeg)
		_ceabfc.ST_FixedPercentageDecimal = &_afbdfc
	}
	return _ceabfc, nil
}

type CT_AudioCD struct {
	St     *CT_AudioCDTime
	End    *CT_AudioCDTime
	ExtLst *CT_OfficeArtExtensionList
}

func (_dfaeg ST_CompoundLine) Validate() error { return _dfaeg.ValidateWithPath("") }
func (_dcefb *CT_ColorMappingOverrideChoice) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dcefb.MasterClrMapping != nil {
		_gffg := _g.StartElement{Name: _g.Name{Local: "a:masterClrMapping"}}
		e.EncodeElement(_dcefb.MasterClrMapping, _gffg)
	}
	if _dcefb.OverrideClrMapping != nil {
		_dbff := _g.StartElement{Name: _g.Name{Local: "a:overrideClrMapping"}}
		e.EncodeElement(_dcefb.OverrideClrMapping, _dbff)
	}
	return nil
}
func NewCT_AdjustHandleList() *CT_AdjustHandleList { _cef := &CT_AdjustHandleList{}; return _cef }

// Validate validates the CT_FlatText and its children
func (_dafdgg *CT_FlatText) Validate() error { return _dafdgg.ValidateWithPath("CT_FlatText") }
func (_fbffe *CT_Vector3D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dx"}, Value: _dcf.Sprintf("\u0025v", _fbffe.DxAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dy"}, Value: _dcf.Sprintf("\u0025v", _fbffe.DyAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dz"}, Value: _dcf.Sprintf("\u0025v", _fbffe.DzAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type ST_PresetPatternVal byte

func (_adddd *CT_FontReference) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_gdce, _cbada := _adddd.IdxAttr.MarshalXMLAttr(_g.Name{Local: "idx"})
	if _cbada != nil {
		return _cbada
	}
	start.Attr = append(start.Attr, _gdce)
	e.EncodeToken(start)
	if _adddd.ScrgbClr != nil {
		_dggfb := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_adddd.ScrgbClr, _dggfb)
	}
	if _adddd.SrgbClr != nil {
		_cbbae := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_adddd.SrgbClr, _cbbae)
	}
	if _adddd.HslClr != nil {
		_cgfegf := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_adddd.HslClr, _cgfegf)
	}
	if _adddd.SysClr != nil {
		_agadd := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_adddd.SysClr, _agadd)
	}
	if _adddd.SchemeClr != nil {
		_bccf := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_adddd.SchemeClr, _bccf)
	}
	if _adddd.PrstClr != nil {
		_ecff := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_adddd.PrstClr, _ecff)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_RegularTextRun and its children
func (_caefc *CT_RegularTextRun) Validate() error {
	return _caefc.ValidateWithPath("CT_RegularTextRun")
}
func (_egfdcd *ST_AdjCoordinate) ValidateWithPath(path string) error {
	_dabbf := []string{}
	if _egfdcd.ST_Coordinate != nil {
		if _edaba := _egfdcd.ST_Coordinate.ValidateWithPath(path + "\u002fST_Coordinate"); _edaba != nil {
			return _edaba
		}
		_dabbf = append(_dabbf, "ST_Coordinate")
	}
	if _egfdcd.ST_GeomGuideName != nil {
		_dabbf = append(_dabbf, "ST_GeomGuideName")
	}
	if len(_dabbf) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _dabbf)
	}
	return nil
}
func (_eacba ST_PenAlignment) String() string {
	switch _eacba {
	case 0:
		return ""
	case 1:
		return "ctr"
	case 2:
		return "in"
	}
	return ""
}
func (_cdddf ST_TextAnchoringType) Validate() error { return _cdddf.ValidateWithPath("") }

// Validate validates the CT_ConnectionSite and its children
func (_eaf *CT_ConnectionSite) Validate() error { return _eaf.ValidateWithPath("CT_ConnectionSite") }

const (
	ST_BlipCompressionUnset   ST_BlipCompression = 0
	ST_BlipCompressionEmail   ST_BlipCompression = 1
	ST_BlipCompressionScreen  ST_BlipCompression = 2
	ST_BlipCompressionPrint   ST_BlipCompression = 3
	ST_BlipCompressionHqprint ST_BlipCompression = 4
	ST_BlipCompressionNone    ST_BlipCompression = 5
)

// Validate validates the EG_ThemeableFontStyles and its children
func (_eebec *EG_ThemeableFontStyles) Validate() error {
	return _eebec.ValidateWithPath("EG_ThemeableFontStyles")
}

type CT_TextLineBreak struct{ RPr *CT_TextCharacterProperties }

// ValidateWithPath validates the EG_ColorChoice and its children, prefixing error messages with path
func (_ebgcag *EG_ColorChoice) ValidateWithPath(path string) error {
	if _ebgcag.ScrgbClr != nil {
		if _bged := _ebgcag.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _bged != nil {
			return _bged
		}
	}
	if _ebgcag.SrgbClr != nil {
		if _bfabf := _ebgcag.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _bfabf != nil {
			return _bfabf
		}
	}
	if _ebgcag.HslClr != nil {
		if _deccg := _ebgcag.HslClr.ValidateWithPath(path + "\u002fHslClr"); _deccg != nil {
			return _deccg
		}
	}
	if _ebgcag.SysClr != nil {
		if _bbbg := _ebgcag.SysClr.ValidateWithPath(path + "\u002fSysClr"); _bbbg != nil {
			return _bbbg
		}
	}
	if _ebgcag.SchemeClr != nil {
		if _dbddb := _ebgcag.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _dbddb != nil {
			return _dbddb
		}
	}
	if _ebgcag.PrstClr != nil {
		if _gffff := _ebgcag.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _gffff != nil {
			return _gffff
		}
	}
	return nil
}
func (_beage *CT_Scene3D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_beage.Camera = NewCT_Camera()
	_beage.LightRig = NewCT_LightRig()
_bbagg:
	for {
		_acdd, _ddddbf := d.Token()
		if _ddddbf != nil {
			return _ddddbf
		}
		switch _baefd := _acdd.(type) {
		case _g.StartElement:
			switch _baefd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "camera"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "camera"}:
				if _acab := d.DecodeElement(_beage.Camera, &_baefd); _acab != nil {
					return _acab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lightRig"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lightRig"}:
				if _aacbb := d.DecodeElement(_beage.LightRig, &_baefd); _aacbb != nil {
					return _aacbb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "backdrop"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "backdrop"}:
				_beage.Backdrop = NewCT_Backdrop()
				if _ddaff := d.DecodeElement(_beage.Backdrop, &_baefd); _ddaff != nil {
					return _ddaff
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_beage.ExtLst = NewCT_OfficeArtExtensionList()
				if _bgdge := d.DecodeElement(_beage.ExtLst, &_baefd); _bgdge != nil {
					return _bgdge
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_Scene3D\u0020\u0025v", _baefd.Name)
				if _cgbd := d.Skip(); _cgbd != nil {
					return _cgbd
				}
			}
		case _g.EndElement:
			break _bbagg
		case _g.CharData:
		}
	}
	return nil
}
func (_ggae *CT_BiLevelEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "thresh"}, Value: _dcf.Sprintf("\u0025v", _ggae.ThreshAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TableStyleTextStyle and its children
func (_eceed *CT_TableStyleTextStyle) Validate() error {
	return _eceed.ValidateWithPath("CT_TableStyleTextStyle")
}
func NewCT_GrayscaleEffect() *CT_GrayscaleEffect { _cgda := &CT_GrayscaleEffect{}; return _cgda }
func NewCT_NonVisualContentPartProperties() *CT_NonVisualContentPartProperties {
	_aggdd := &CT_NonVisualContentPartProperties{}
	return _aggdd
}

// ValidateWithPath validates the CT_PresetTextShape and its children, prefixing error messages with path
func (_fgbgb *CT_PresetTextShape) ValidateWithPath(path string) error {
	if _fgbgb.PrstAttr == ST_TextShapeTypeUnset {
		return _dcf.Errorf("\u0025s\u002fPrstAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _dcaac := _fgbgb.PrstAttr.ValidateWithPath(path + "\u002fPrstAttr"); _dcaac != nil {
		return _dcaac
	}
	if _fgbgb.AvLst != nil {
		if _dded := _fgbgb.AvLst.ValidateWithPath(path + "\u002fAvLst"); _dded != nil {
			return _dded
		}
	}
	return nil
}
func NewCT_PresetLineDashProperties() *CT_PresetLineDashProperties {
	_cbadb := &CT_PresetLineDashProperties{}
	return _cbadb
}
func (_cgdba ST_LineCap) String() string {
	switch _cgdba {
	case 0:
		return ""
	case 1:
		return "rnd"
	case 2:
		return "sq"
	case 3:
		return "flat"
	}
	return ""
}
func (_edag *CT_FillProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_cgdg:
	for {
		_bebac, _acgd := d.Token()
		if _acgd != nil {
			return _acgd
		}
		switch _cgge := _bebac.(type) {
		case _g.StartElement:
			switch _cgge.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_edag.NoFill = NewCT_NoFillProperties()
				if _aeee := d.DecodeElement(_edag.NoFill, &_cgge); _aeee != nil {
					return _aeee
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_edag.SolidFill = NewCT_SolidColorFillProperties()
				if _bcee := d.DecodeElement(_edag.SolidFill, &_cgge); _bcee != nil {
					return _bcee
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_edag.GradFill = NewCT_GradientFillProperties()
				if _bgdad := d.DecodeElement(_edag.GradFill, &_cgge); _bgdad != nil {
					return _bgdad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_edag.BlipFill = NewCT_BlipFillProperties()
				if _abed := d.DecodeElement(_edag.BlipFill, &_cgge); _abed != nil {
					return _abed
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_edag.PattFill = NewCT_PatternFillProperties()
				if _bdga := d.DecodeElement(_edag.PattFill, &_cgge); _bdga != nil {
					return _bdga
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_edag.GrpFill = NewCT_GroupFillProperties()
				if _bbdc := d.DecodeElement(_edag.GrpFill, &_cgge); _bbdc != nil {
					return _bbdc
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_FillProperties\u0020\u0025v", _cgge.Name)
				if _fgggb := d.Skip(); _fgggb != nil {
					return _fgggb
				}
			}
		case _g.EndElement:
			break _cgdg
		case _g.CharData:
		}
	}
	return nil
}

type CT_GvmlShapeNonVisual struct {
	CNvPr   *CT_NonVisualDrawingProps
	CNvSpPr *CT_NonVisualDrawingShapeProps
}

// Validate validates the CT_OfficeStyleSheet and its children
func (_ddcdg *CT_OfficeStyleSheet) Validate() error {
	return _ddcdg.ValidateWithPath("CT_OfficeStyleSheet")
}
func (_accfc *CT_LineJoinRound) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ccaadg ST_TextShapeType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ccaadg.String(), start)
}
func (_eba *CT_AlphaModulateEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_ged := _g.StartElement{Name: _g.Name{Local: "a:cont"}}
	e.EncodeElement(_eba.Cont, _ged)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_gbdfb ST_TileFlipMode) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_fbdaag := _g.Attr{}
	_fbdaag.Name = name
	switch _gbdfb {
	case ST_TileFlipModeUnset:
		_fbdaag.Value = ""
	case ST_TileFlipModeNone:
		_fbdaag.Value = "none"
	case ST_TileFlipModeX:
		_fbdaag.Value = "x"
	case ST_TileFlipModeY:
		_fbdaag.Value = "y"
	case ST_TileFlipModeXy:
		_fbdaag.Value = "xy"
	}
	return _fbdaag, nil
}
func NewCT_TextParagraph() *CT_TextParagraph { _cagcc := &CT_TextParagraph{}; return _cagcc }

// ST_AnimationChartBuildType is a union type
type ST_AnimationChartBuildType struct {
	ST_AnimationBuildType          ST_AnimationBuildType
	ST_AnimationChartOnlyBuildType ST_AnimationChartOnlyBuildType
}

func NewEG_Effect() *EG_Effect { _acdca := &EG_Effect{}; return _acdca }

// ST_Percentage is a union type
type ST_Percentage struct {
	ST_PercentageDecimal *int32
	ST_Percentage        *string
}

// ValidateWithPath validates the CT_TextParagraph and its children, prefixing error messages with path
func (_ceebe *CT_TextParagraph) ValidateWithPath(path string) error {
	if _ceebe.PPr != nil {
		if _dbdgd := _ceebe.PPr.ValidateWithPath(path + "\u002fPPr"); _dbdgd != nil {
			return _dbdgd
		}
	}
	for _cbaec, _cffge := range _ceebe.EG_TextRun {
		if _dadde := _cffge.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fEG_TextRun\u005b\u0025d\u005d", path, _cbaec)); _dadde != nil {
			return _dadde
		}
	}
	if _ceebe.EndParaRPr != nil {
		if _bdefe := _ceebe.EndParaRPr.ValidateWithPath(path + "/EndParaRPr"); _bdefe != nil {
			return _bdefe
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ConnectorLocking and its children, prefixing error messages with path
func (_dabb *CT_ConnectorLocking) ValidateWithPath(path string) error {
	if _dabb.ExtLst != nil {
		if _gabd := _dabb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gabd != nil {
			return _gabd
		}
	}
	return nil
}
func (_adgab *CT_ShapeStyle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_eedae := _g.StartElement{Name: _g.Name{Local: "a:lnRef"}}
	e.EncodeElement(_adgab.LnRef, _eedae)
	_bedcg := _g.StartElement{Name: _g.Name{Local: "a:fillRef"}}
	e.EncodeElement(_adgab.FillRef, _bedcg)
	_fagd := _g.StartElement{Name: _g.Name{Local: "a:effectRef"}}
	e.EncodeElement(_adgab.EffectRef, _fagd)
	_dfbga := _g.StartElement{Name: _g.Name{Local: "a:fontRef"}}
	e.EncodeElement(_adgab.FontRef, _dfbga)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_SRgbColor() *CT_SRgbColor             { _dgegc := &CT_SRgbColor{}; return _dgegc }
func (_adfecg ST_TextAlignType) Validate() error { return _adfecg.ValidateWithPath("") }
func (_cdeca *CT_OfficeStyleSheet) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cdeca.ThemeElements = NewCT_BaseStyles()
	for _, _beefb := range start.Attr {
		if _beefb.Name.Local == "name" {
			_bgeaf, _eabef := _beefb.Value, error(nil)
			if _eabef != nil {
				return _eabef
			}
			_cdeca.NameAttr = &_bgeaf
			continue
		}
	}
_feaa:
	for {
		_abgg, _bfgad := d.Token()
		if _bfgad != nil {
			return _bfgad
		}
		switch _dbadc := _abgg.(type) {
		case _g.StartElement:
			switch _dbadc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "themeElements"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "themeElements"}:
				if _fbeef := d.DecodeElement(_cdeca.ThemeElements, &_dbadc); _fbeef != nil {
					return _fbeef
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "objectDefaults"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "objectDefaults"}:
				_cdeca.ObjectDefaults = NewCT_ObjectStyleDefaults()
				if _eedfa := d.DecodeElement(_cdeca.ObjectDefaults, &_dbadc); _eedfa != nil {
					return _eedfa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extraClrSchemeLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extraClrSchemeLst"}:
				_cdeca.ExtraClrSchemeLst = NewCT_ColorSchemeList()
				if _dcda := d.DecodeElement(_cdeca.ExtraClrSchemeLst, &_dbadc); _dcda != nil {
					return _dcda
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "custClrLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "custClrLst"}:
				_cdeca.CustClrLst = NewCT_CustomColorList()
				if _bded := d.DecodeElement(_cdeca.CustClrLst, &_dbadc); _bded != nil {
					return _bded
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_cdeca.ExtLst = NewCT_OfficeArtExtensionList()
				if _gcbgd := d.DecodeElement(_cdeca.ExtLst, &_dbadc); _gcbgd != nil {
					return _gcbgd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OfficeStyleSheet\u0020\u0025v", _dbadc.Name)
				if _gegff := d.Skip(); _gegff != nil {
					return _gegff
				}
			}
		case _g.EndElement:
			break _feaa
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_PositivePercentage() *CT_PositivePercentage {
	_eaagfa := &CT_PositivePercentage{}
	return _eaagfa
}

// Validate validates the EG_TextGeometry and its children
func (_bbbaff *EG_TextGeometry) Validate() error { return _bbbaff.ValidateWithPath("EG_TextGeometry") }
func (_cecac *CT_TextField) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "id"}, Value: _dcf.Sprintf("\u0025v", _cecac.IdAttr)})
	if _cecac.TypeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "type"}, Value: _dcf.Sprintf("\u0025v", *_cecac.TypeAttr)})
	}
	e.EncodeToken(start)
	if _cecac.RPr != nil {
		_adfd := _g.StartElement{Name: _g.Name{Local: "a:rPr"}}
		e.EncodeElement(_cecac.RPr, _adfd)
	}
	if _cecac.PPr != nil {
		_gbgdf := _g.StartElement{Name: _g.Name{Local: "a:pPr"}}
		e.EncodeElement(_cecac.PPr, _gbgdf)
	}
	if _cecac.T != nil {
		_fgeb := _g.StartElement{Name: _g.Name{Local: "a:t"}}
		_ee.AddPreserveSpaceAttr(&_fgeb, *_cecac.T)
		e.EncodeElement(_cecac.T, _fgeb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the EG_ColorChoice and its children
func (_fgaee *EG_ColorChoice) Validate() error { return _fgaee.ValidateWithPath("EG_ColorChoice") }

// Validate validates the CT_TextUnderlineLineFollowText and its children
func (_becff *CT_TextUnderlineLineFollowText) Validate() error {
	return _becff.ValidateWithPath("CT_TextUnderlineLineFollowText")
}

// ValidateWithPath validates the CT_Boolean and its children, prefixing error messages with path
func (_bfeb *CT_Boolean) ValidateWithPath(path string) error {
	if _bfeb.ValAttr != nil {
		if _badf := _bfeb.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _badf != nil {
			return _badf
		}
	}
	return nil
}
func (_aeabd *CT_ContentPartLocking) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _aeabd.NoGrpAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noGrp"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aeabd.NoGrpAttr))})
	}
	if _aeabd.NoSelectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noSelect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aeabd.NoSelectAttr))})
	}
	if _aeabd.NoRotAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noRot"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aeabd.NoRotAttr))})
	}
	if _aeabd.NoChangeAspectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeAspect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aeabd.NoChangeAspectAttr))})
	}
	if _aeabd.NoMoveAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noMove"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aeabd.NoMoveAttr))})
	}
	if _aeabd.NoResizeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noResize"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aeabd.NoResizeAttr))})
	}
	if _aeabd.NoEditPointsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noEditPoints"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aeabd.NoEditPointsAttr))})
	}
	if _aeabd.NoAdjustHandlesAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noAdjustHandles"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aeabd.NoAdjustHandlesAttr))})
	}
	if _aeabd.NoChangeArrowheadsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeArrowheads"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aeabd.NoChangeArrowheadsAttr))})
	}
	if _aeabd.NoChangeShapeTypeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeShapeType"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aeabd.NoChangeShapeTypeAttr))})
	}
	e.EncodeToken(start)
	if _aeabd.ExtLst != nil {
		_ccfd := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_aeabd.ExtLst, _ccfd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_cgabba ST_PresetMaterialType) String() string {
	switch _cgabba {
	case 0:
		return ""
	case 1:
		return "legacyMatte"
	case 2:
		return "legacyPlastic"
	case 3:
		return "legacyMetal"
	case 4:
		return "legacyWireframe"
	case 5:
		return "matte"
	case 6:
		return "plastic"
	case 7:
		return "metal"
	case 8:
		return "warmMatte"
	case 9:
		return "translucentPowder"
	case 10:
		return "powder"
	case 11:
		return "dkEdge"
	case 12:
		return "softEdge"
	case 13:
		return "clear"
	case 14:
		return "flat"
	case 15:
		return "softmetal"
	}
	return ""
}
func NewCT_GvmlTextShape() *CT_GvmlTextShape {
	_dafg := &CT_GvmlTextShape{}
	_dafg.TxBody = NewCT_TextBody()
	return _dafg
}

type CT_GvmlGroupShapeNonVisual struct {
	CNvPr      *CT_NonVisualDrawingProps
	CNvGrpSpPr *CT_NonVisualGroupDrawingShapeProps
}

func ParseUnionST_PositivePercentage(s string) (ST_PositivePercentage, error) {
	_ebfae := ST_PositivePercentage{}
	if _f.ST_PositivePercentagePatternRe.MatchString(s) {
		_ebfae.ST_PositivePercentage = &ST_Percentage{}
		_ebfae.ST_PositivePercentage.ST_Percentage = &s
	} else {
		_cgeab, _adadb := _e.ParseInt(s, 10, 32)
		if _adadb != nil {
			return _ebfae, _dcf.Errorf("parsing\u0020\u0025s\u0020as\u0020int", _adadb)
		}
		_cfdeae := int32(_cgeab)
		_ebfae.ST_PositivePercentageDecimal = &_cfdeae
	}
	return _ebfae, nil
}

// Validate validates the CT_GroupLocking and its children
func (_egdfb *CT_GroupLocking) Validate() error { return _egdfb.ValidateWithPath("CT_GroupLocking") }

// ValidateWithPath validates the CT_RelativeRect and its children, prefixing error messages with path
func (_egafa *CT_RelativeRect) ValidateWithPath(path string) error {
	if _egafa.LAttr != nil {
		if _caggd := _egafa.LAttr.ValidateWithPath(path + "\u002fLAttr"); _caggd != nil {
			return _caggd
		}
	}
	if _egafa.TAttr != nil {
		if _daag := _egafa.TAttr.ValidateWithPath(path + "\u002fTAttr"); _daag != nil {
			return _daag
		}
	}
	if _egafa.RAttr != nil {
		if _egfdfb := _egafa.RAttr.ValidateWithPath(path + "\u002fRAttr"); _egfdfb != nil {
			return _egfdfb
		}
	}
	if _egafa.BAttr != nil {
		if _bggb := _egafa.BAttr.ValidateWithPath(path + "\u002fBAttr"); _bggb != nil {
			return _bggb
		}
	}
	return nil
}

// Validate validates the CT_NonVisualGroupDrawingShapeProps and its children
func (_dfgeb *CT_NonVisualGroupDrawingShapeProps) Validate() error {
	return _dfgeb.ValidateWithPath("CT_NonVisualGroupDrawingShapeProps")
}
func (_dagf *CT_ConnectionSite) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dagf.Pos = NewCT_AdjPoint2D()
	for _, _bgcd := range start.Attr {
		if _bgcd.Name.Local == "ang" {
			_eddg, _gcagd := ParseUnionST_AdjAngle(_bgcd.Value)
			if _gcagd != nil {
				return _gcagd
			}
			_dagf.AngAttr = _eddg
			continue
		}
	}
_eag:
	for {
		_gbcb, _ebfe := d.Token()
		if _ebfe != nil {
			return _ebfe
		}
		switch _afaf := _gbcb.(type) {
		case _g.StartElement:
			switch _afaf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pos"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pos"}:
				if _gbfcg := d.DecodeElement(_dagf.Pos, &_afaf); _gbfcg != nil {
					return _gbfcg
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_ConnectionSite\u0020\u0025v", _afaf.Name)
				if _ffec := d.Skip(); _ffec != nil {
					return _ffec
				}
			}
		case _g.EndElement:
			break _eag
		case _g.CharData:
		}
	}
	return nil
}
func (_gadff *ST_ColorSchemeIndex) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ddfcb, _aeffga := d.Token()
	if _aeffga != nil {
		return _aeffga
	}
	if _adfab, _bfba := _ddfcb.(_g.EndElement); _bfba && _adfab.Name == start.Name {
		*_gadff = 1
		return nil
	}
	if _eeffc, _gfadbf := _ddfcb.(_g.CharData); !_gfadbf {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ddfcb)
	} else {
		switch string(_eeffc) {
		case "":
			*_gadff = 0
		case "dk1":
			*_gadff = 1
		case "lt1":
			*_gadff = 2
		case "dk2":
			*_gadff = 3
		case "lt2":
			*_gadff = 4
		case "accent1":
			*_gadff = 5
		case "accent2":
			*_gadff = 6
		case "accent3":
			*_gadff = 7
		case "accent4":
			*_gadff = 8
		case "accent5":
			*_gadff = 9
		case "accent6":
			*_gadff = 10
		case "hlink":
			*_gadff = 11
		case "folHlink":
			*_gadff = 12
		}
	}
	_ddfcb, _aeffga = d.Token()
	if _aeffga != nil {
		return _aeffga
	}
	if _cdbga, _edabb := _ddfcb.(_g.EndElement); _edabb && _cdbga.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ddfcb)
}

type CT_ColorScheme struct {
	NameAttr string
	Dk1      *CT_Color
	Lt1      *CT_Color
	Dk2      *CT_Color
	Lt2      *CT_Color
	Accent1  *CT_Color
	Accent2  *CT_Color
	Accent3  *CT_Color
	Accent4  *CT_Color
	Accent5  *CT_Color
	Accent6  *CT_Color
	Hlink    *CT_Color
	FolHlink *CT_Color
	ExtLst   *CT_OfficeArtExtensionList
}
type ST_SchemeColorVal byte
type CT_GraphicalObject struct{ GraphicData *CT_GraphicalObjectData }
type ST_BlackWhiteMode byte

func (_dbddc *CT_GvmlConnector) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_faaga := _g.StartElement{Name: _g.Name{Local: "a:nvCxnSpPr"}}
	e.EncodeElement(_dbddc.NvCxnSpPr, _faaga)
	_fgcc := _g.StartElement{Name: _g.Name{Local: "a:spPr"}}
	e.EncodeElement(_dbddc.SpPr, _fgcc)
	if _dbddc.Style != nil {
		_gbbgc := _g.StartElement{Name: _g.Name{Local: "a:style"}}
		e.EncodeElement(_dbddc.Style, _gbbgc)
	}
	if _dbddc.ExtLst != nil {
		_afge := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dbddc.ExtLst, _afge)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_dadda *CT_LineStyleList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_efacb:
	for {
		_fbedf, _fgfad := d.Token()
		if _fgfad != nil {
			return _fgfad
		}
		switch _bcgfb := _fbedf.(type) {
		case _g.StartElement:
			switch _bcgfb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ln"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ln"}:
				_dgdg := NewCT_LineProperties()
				if _cafa := d.DecodeElement(_dgdg, &_bcgfb); _cafa != nil {
					return _cafa
				}
				_dadda.Ln = append(_dadda.Ln, _dgdg)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_LineStyleList\u0020\u0025v", _bcgfb.Name)
				if _fabbe := d.Skip(); _fabbe != nil {
					return _fabbe
				}
			}
		case _g.EndElement:
			break _efacb
		case _g.CharData:
		}
	}
	return nil
}
func (_ggfd *CT_AudioFile) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r:link"}, Value: _dcf.Sprintf("\u0025v", _ggfd.LinkAttr)})
	if _ggfd.ContentTypeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "contentType"}, Value: _dcf.Sprintf("\u0025v", *_ggfd.ContentTypeAttr)})
	}
	e.EncodeToken(start)
	if _ggfd.ExtLst != nil {
		_ggee := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_ggfd.ExtLst, _ggee)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_beecg ST_BlendMode) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_beecg.String(), start)
}
func (_ddea *CT_TableStyleCellStyle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _ddea.TcBdr != nil {
		_cdffe := _g.StartElement{Name: _g.Name{Local: "a:tcBdr"}}
		e.EncodeElement(_ddea.TcBdr, _cdffe)
	}
	if _ddea.Fill != nil {
		_dbffg := _g.StartElement{Name: _g.Name{Local: "a:fill"}}
		e.EncodeElement(_ddea.Fill, _dbffg)
	}
	if _ddea.FillRef != nil {
		_ffcaa := _g.StartElement{Name: _g.Name{Local: "a:fillRef"}}
		e.EncodeElement(_ddea.FillRef, _ffcaa)
	}
	if _ddea.Cell3D != nil {
		_cgad := _g.StartElement{Name: _g.Name{Local: "a:cell3D"}}
		e.EncodeElement(_ddea.Cell3D, _cgad)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_aaebg *CT_ThemeableLineStyle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _aaebg.Ln != nil {
		_adfga := _g.StartElement{Name: _g.Name{Local: "a:ln"}}
		e.EncodeElement(_aaebg.Ln, _adfga)
	}
	if _aaebg.LnRef != nil {
		_ddgdd := _g.StartElement{Name: _g.Name{Local: "a:lnRef"}}
		e.EncodeElement(_aaebg.LnRef, _ddgdd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_PictureLocking() *CT_PictureLocking { _aedd := &CT_PictureLocking{}; return _aedd }
func (_egebb ST_PathFillMode) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_fbfdd := _g.Attr{}
	_fbfdd.Name = name
	switch _egebb {
	case ST_PathFillModeUnset:
		_fbfdd.Value = ""
	case ST_PathFillModeNone:
		_fbfdd.Value = "none"
	case ST_PathFillModeNorm:
		_fbfdd.Value = "norm"
	case ST_PathFillModeLighten:
		_fbfdd.Value = "lighten"
	case ST_PathFillModeLightenLess:
		_fbfdd.Value = "lightenLess"
	case ST_PathFillModeDarken:
		_fbfdd.Value = "darken"
	case ST_PathFillModeDarkenLess:
		_fbfdd.Value = "darkenLess"
	}
	return _fbfdd, nil
}
func (_efec *CT_TableStyleList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "def"}, Value: _dcf.Sprintf("\u0025v", _efec.DefAttr)})
	e.EncodeToken(start)
	if _efec.TblStyle != nil {
		_agfa := _g.StartElement{Name: _g.Name{Local: "a:tblStyle"}}
		for _, _adcag := range _efec.TblStyle {
			e.EncodeElement(_adcag, _agfa)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ffecb ST_LineEndLength) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ecgcg := _g.Attr{}
	_ecgcg.Name = name
	switch _ffecb {
	case ST_LineEndLengthUnset:
		_ecgcg.Value = ""
	case ST_LineEndLengthSm:
		_ecgcg.Value = "sm"
	case ST_LineEndLengthMed:
		_ecgcg.Value = "med"
	case ST_LineEndLengthLg:
		_ecgcg.Value = "lg"
	}
	return _ecgcg, nil
}

// ValidateWithPath validates the CT_SystemColor and its children, prefixing error messages with path
func (_fgfcd *CT_SystemColor) ValidateWithPath(path string) error {
	if _fgfcd.ValAttr == ST_SystemColorValUnset {
		return _dcf.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _efdbb := _fgfcd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _efdbb != nil {
		return _efdbb
	}
	for _cbaaf, _eafa := range _fgfcd.EG_ColorTransform {
		if _ebadc := _eafa.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fEG_ColorTransform\u005b\u0025d\u005d", path, _cbaaf)); _ebadc != nil {
			return _ebadc
		}
	}
	return nil
}

// Validate validates the CT_GraphicalObjectData and its children
func (_cbde *CT_GraphicalObjectData) Validate() error {
	return _cbde.ValidateWithPath("CT_GraphicalObjectData")
}

// ValidateWithPath validates the CT_GroupFillProperties and its children, prefixing error messages with path
func (_dege *CT_GroupFillProperties) ValidateWithPath(path string) error { return nil }

type CT_AudioCDTime struct {
	TrackAttr uint8
	TimeAttr  *uint32
}

func (_bcfg *CT_BlurEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _bcfg.RadAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rad"}, Value: _dcf.Sprintf("\u0025v", *_bcfg.RadAttr)})
	}
	if _bcfg.GrowAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "grow"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_bcfg.GrowAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_fdda *CT_CustomColorList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_bfac:
	for {
		_dcbc, _fgec := d.Token()
		if _fgec != nil {
			return _fgec
		}
		switch _dbbc := _dcbc.(type) {
		case _g.StartElement:
			switch _dbbc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "custClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "custClr"}:
				_fcab := NewCT_CustomColor()
				if _efef := d.DecodeElement(_fcab, &_dbbc); _efef != nil {
					return _efef
				}
				_fdda.CustClr = append(_fdda.CustClr, _fcab)
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_CustomColorList\u0020\u0025v", _dbbc.Name)
				if _agde := d.Skip(); _agde != nil {
					return _agde
				}
			}
		case _g.EndElement:
			break _bfac
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PictureLocking and its children, prefixing error messages with path
func (_aggdb *CT_PictureLocking) ValidateWithPath(path string) error {
	if _aggdb.ExtLst != nil {
		if _gacf := _aggdb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gacf != nil {
			return _gacf
		}
	}
	return nil
}
func NewCT_ShapeStyle() *CT_ShapeStyle {
	_bddec := &CT_ShapeStyle{}
	_bddec.LnRef = NewCT_StyleMatrixReference()
	_bddec.FillRef = NewCT_StyleMatrixReference()
	_bddec.EffectRef = NewCT_StyleMatrixReference()
	_bddec.FontRef = NewCT_FontReference()
	return _bddec
}

// Validate validates the CT_TextBulletSizePercent and its children
func (_cdcaa *CT_TextBulletSizePercent) Validate() error {
	return _cdcaa.ValidateWithPath("CT_TextBulletSizePercent")
}
func (_abgc *CT_EffectReference) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fcdea := range start.Attr {
		if _fcdea.Name.Local == "ref" {
			_accaf, _fcae := _fcdea.Value, error(nil)
			if _fcae != nil {
				return _fcae
			}
			_abgc.RefAttr = _accaf
			continue
		}
	}
	for {
		_gceb, _bffd := d.Token()
		if _bffd != nil {
			return _dcf.Errorf("parsing\u0020CT_EffectReference:\u0020\u0025s", _bffd)
		}
		if _ggcd, _gfcbac := _gceb.(_g.EndElement); _gfcbac && _ggcd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_baacc *CT_GvmlUseShapeRectangle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_VideoFile() *CT_VideoFile { _bagbd := &CT_VideoFile{}; return _bagbd }
func (_geacc *CT_VideoFile) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _agfcb := range start.Attr {
		if _agfcb.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _agfcb.Name.Local == "link" || _agfcb.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _agfcb.Name.Local == "link" {
			_aefag, _eaeae := _agfcb.Value, error(nil)
			if _eaeae != nil {
				return _eaeae
			}
			_geacc.LinkAttr = _aefag
			continue
		}
		if _agfcb.Name.Local == "contentType" {
			_bfdfe, _fgded := _agfcb.Value, error(nil)
			if _fgded != nil {
				return _fgded
			}
			_geacc.ContentTypeAttr = &_bfdfe
			continue
		}
	}
_ddeee:
	for {
		_eacgg, _edcffb := d.Token()
		if _edcffb != nil {
			return _edcffb
		}
		switch _bffgb := _eacgg.(type) {
		case _g.StartElement:
			switch _bffgb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_geacc.ExtLst = NewCT_OfficeArtExtensionList()
				if _bfaff := d.DecodeElement(_geacc.ExtLst, &_bffgb); _bfaff != nil {
					return _bfaff
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_VideoFile\u0020\u0025v", _bffgb.Name)
				if _gebbg := d.Skip(); _gebbg != nil {
					return _gebbg
				}
			}
		case _g.EndElement:
			break _ddeee
		case _g.CharData:
		}
	}
	return nil
}
func (_gda *CT_Blip) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _gda.CstateAttr != ST_BlipCompressionUnset {
		_dccd, _eaed := _gda.CstateAttr.MarshalXMLAttr(_g.Name{Local: "cstate"})
		if _eaed != nil {
			return _eaed
		}
		start.Attr = append(start.Attr, _dccd)
	}
	if _gda.EmbedAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r:embed"}, Value: _dcf.Sprintf("\u0025v", *_gda.EmbedAttr)})
	}
	if _gda.LinkAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r:link"}, Value: _dcf.Sprintf("\u0025v", *_gda.LinkAttr)})
	}
	e.EncodeToken(start)
	if _gda.Choice != nil {
		for _, _afba := range _gda.Choice {
			_afba.MarshalXML(e, _g.StartElement{})
		}
	}
	if _gda.ExtLst != nil {
		_ead := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_gda.ExtLst, _ead)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SRgbColor and its children
func (_bfeff *CT_SRgbColor) Validate() error { return _bfeff.ValidateWithPath("CT_SRgbColor") }

type CT_FillStyleList struct{ EG_FillProperties []*EG_FillProperties }
type CT_RelativeRect struct {
	LAttr *ST_Percentage
	TAttr *ST_Percentage
	RAttr *ST_Percentage
	BAttr *ST_Percentage
}

func (_fdcdg *CT_ShapeLocking) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fffgc := range start.Attr {
		if _fffgc.Name.Local == "noTextEdit" {
			_gafe, _gcdcd := _e.ParseBool(_fffgc.Value)
			if _gcdcd != nil {
				return _gcdcd
			}
			_fdcdg.NoTextEditAttr = &_gafe
			continue
		}
		if _fffgc.Name.Local == "noGrp" {
			_edbae, _ccffb := _e.ParseBool(_fffgc.Value)
			if _ccffb != nil {
				return _ccffb
			}
			_fdcdg.NoGrpAttr = &_edbae
			continue
		}
		if _fffgc.Name.Local == "noSelect" {
			_ccedg, _ebffc := _e.ParseBool(_fffgc.Value)
			if _ebffc != nil {
				return _ebffc
			}
			_fdcdg.NoSelectAttr = &_ccedg
			continue
		}
		if _fffgc.Name.Local == "noRot" {
			_fcdaa, _beebeb := _e.ParseBool(_fffgc.Value)
			if _beebeb != nil {
				return _beebeb
			}
			_fdcdg.NoRotAttr = &_fcdaa
			continue
		}
		if _fffgc.Name.Local == "noChangeAspect" {
			_fedba, _eacea := _e.ParseBool(_fffgc.Value)
			if _eacea != nil {
				return _eacea
			}
			_fdcdg.NoChangeAspectAttr = &_fedba
			continue
		}
		if _fffgc.Name.Local == "noMove" {
			_afgfe, _dfgdef := _e.ParseBool(_fffgc.Value)
			if _dfgdef != nil {
				return _dfgdef
			}
			_fdcdg.NoMoveAttr = &_afgfe
			continue
		}
		if _fffgc.Name.Local == "noResize" {
			_ccage, _gbdfc := _e.ParseBool(_fffgc.Value)
			if _gbdfc != nil {
				return _gbdfc
			}
			_fdcdg.NoResizeAttr = &_ccage
			continue
		}
		if _fffgc.Name.Local == "noEditPoints" {
			_cebaee, _bbfcba := _e.ParseBool(_fffgc.Value)
			if _bbfcba != nil {
				return _bbfcba
			}
			_fdcdg.NoEditPointsAttr = &_cebaee
			continue
		}
		if _fffgc.Name.Local == "noAdjustHandles" {
			_egaag, _gegef := _e.ParseBool(_fffgc.Value)
			if _gegef != nil {
				return _gegef
			}
			_fdcdg.NoAdjustHandlesAttr = &_egaag
			continue
		}
		if _fffgc.Name.Local == "noChangeArrowheads" {
			_ebggd, _ggbbd := _e.ParseBool(_fffgc.Value)
			if _ggbbd != nil {
				return _ggbbd
			}
			_fdcdg.NoChangeArrowheadsAttr = &_ebggd
			continue
		}
		if _fffgc.Name.Local == "noChangeShapeType" {
			_eebegd, _bccb := _e.ParseBool(_fffgc.Value)
			if _bccb != nil {
				return _bccb
			}
			_fdcdg.NoChangeShapeTypeAttr = &_eebegd
			continue
		}
	}
_cbcbgc:
	for {
		_daage, _bedcb := d.Token()
		if _bedcb != nil {
			return _bedcb
		}
		switch _becge := _daage.(type) {
		case _g.StartElement:
			switch _becge.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_fdcdg.ExtLst = NewCT_OfficeArtExtensionList()
				if _gdcega := d.DecodeElement(_fdcdg.ExtLst, &_becge); _gdcega != nil {
					return _gdcega
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ShapeLocking\u0020\u0025v", _becge.Name)
				if _gacca := d.Skip(); _gacca != nil {
					return _gacca
				}
			}
		case _g.EndElement:
			break _cbcbgc
		case _g.CharData:
		}
	}
	return nil
}
func (_defc ST_FontCollectionIndex) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_bedce := _g.Attr{}
	_bedce.Name = name
	switch _defc {
	case ST_FontCollectionIndexUnset:
		_bedce.Value = ""
	case ST_FontCollectionIndexMajor:
		_bedce.Value = "major"
	case ST_FontCollectionIndexMinor:
		_bedce.Value = "minor"
	case ST_FontCollectionIndexNone:
		_bedce.Value = "none"
	}
	return _bedce, nil
}
func (_dbefc ST_TextStrikeType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_fgeac := _g.Attr{}
	_fgeac.Name = name
	switch _dbefc {
	case ST_TextStrikeTypeUnset:
		_fgeac.Value = ""
	case ST_TextStrikeTypeNoStrike:
		_fgeac.Value = "noStrike"
	case ST_TextStrikeTypeSngStrike:
		_fgeac.Value = "sngStrike"
	case ST_TextStrikeTypeDblStrike:
		_fgeac.Value = "dblStrike"
	}
	return _fgeac, nil
}

// ValidateWithPath validates the CT_ShapeLocking and its children, prefixing error messages with path
func (_abbfe *CT_ShapeLocking) ValidateWithPath(path string) error {
	if _abbfe.ExtLst != nil {
		if _adgfba := _abbfe.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _adgfba != nil {
			return _adgfba
		}
	}
	return nil
}
func (_fbccc *CT_TextCharacterProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fbccc.KumimojiAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "kumimoji"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fbccc.KumimojiAttr))})
	}
	if _fbccc.LangAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lang"}, Value: _dcf.Sprintf("\u0025v", *_fbccc.LangAttr)})
	}
	if _fbccc.AltLangAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "altLang"}, Value: _dcf.Sprintf("\u0025v", *_fbccc.AltLangAttr)})
	}
	if _fbccc.SzAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sz"}, Value: _dcf.Sprintf("\u0025v", *_fbccc.SzAttr)})
	}
	if _fbccc.BAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "b"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fbccc.BAttr))})
	}
	if _fbccc.IAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "i"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fbccc.IAttr))})
	}
	if _fbccc.UAttr != ST_TextUnderlineTypeUnset {
		_fabef, _affbg := _fbccc.UAttr.MarshalXMLAttr(_g.Name{Local: "u"})
		if _affbg != nil {
			return _affbg
		}
		start.Attr = append(start.Attr, _fabef)
	}
	if _fbccc.StrikeAttr != ST_TextStrikeTypeUnset {
		_eecace, _ebbcd := _fbccc.StrikeAttr.MarshalXMLAttr(_g.Name{Local: "strike"})
		if _ebbcd != nil {
			return _ebbcd
		}
		start.Attr = append(start.Attr, _eecace)
	}
	if _fbccc.KernAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "kern"}, Value: _dcf.Sprintf("\u0025v", *_fbccc.KernAttr)})
	}
	if _fbccc.CapAttr != ST_TextCapsTypeUnset {
		_gaced, _fgffe := _fbccc.CapAttr.MarshalXMLAttr(_g.Name{Local: "cap"})
		if _fgffe != nil {
			return _fgffe
		}
		start.Attr = append(start.Attr, _gaced)
	}
	if _fbccc.SpcAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "spc"}, Value: _dcf.Sprintf("\u0025v", *_fbccc.SpcAttr)})
	}
	if _fbccc.NormalizeHAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "normalizeH"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fbccc.NormalizeHAttr))})
	}
	if _fbccc.BaselineAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "baseline"}, Value: _dcf.Sprintf("\u0025v", *_fbccc.BaselineAttr)})
	}
	if _fbccc.NoProofAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noProof"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fbccc.NoProofAttr))})
	}
	if _fbccc.DirtyAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dirty"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fbccc.DirtyAttr))})
	}
	if _fbccc.ErrAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "err"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fbccc.ErrAttr))})
	}
	if _fbccc.SmtCleanAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "smtClean"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fbccc.SmtCleanAttr))})
	}
	if _fbccc.SmtIdAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "smtId"}, Value: _dcf.Sprintf("\u0025v", *_fbccc.SmtIdAttr)})
	}
	if _fbccc.BmkAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "bmk"}, Value: _dcf.Sprintf("\u0025v", *_fbccc.BmkAttr)})
	}
	e.EncodeToken(start)
	if _fbccc.Ln != nil {
		_cdcggg := _g.StartElement{Name: _g.Name{Local: "a:ln"}}
		e.EncodeElement(_fbccc.Ln, _cdcggg)
	}
	if _fbccc.NoFill != nil {
		_bafc := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_fbccc.NoFill, _bafc)
	}
	if _fbccc.SolidFill != nil {
		_bafde := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_fbccc.SolidFill, _bafde)
	}
	if _fbccc.GradFill != nil {
		_dedge := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_fbccc.GradFill, _dedge)
	}
	if _fbccc.BlipFill != nil {
		_dgdce := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
		e.EncodeElement(_fbccc.BlipFill, _dgdce)
	}
	if _fbccc.PattFill != nil {
		_beabba := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_fbccc.PattFill, _beabba)
	}
	if _fbccc.GrpFill != nil {
		_bgbdd := _g.StartElement{Name: _g.Name{Local: "a:grpFill"}}
		e.EncodeElement(_fbccc.GrpFill, _bgbdd)
	}
	if _fbccc.EffectLst != nil {
		_cbbaa := _g.StartElement{Name: _g.Name{Local: "a:effectLst"}}
		e.EncodeElement(_fbccc.EffectLst, _cbbaa)
	}
	if _fbccc.EffectDag != nil {
		_bbcfc := _g.StartElement{Name: _g.Name{Local: "a:effectDag"}}
		e.EncodeElement(_fbccc.EffectDag, _bbcfc)
	}
	if _fbccc.Highlight != nil {
		_gfaca := _g.StartElement{Name: _g.Name{Local: "a:highlight"}}
		e.EncodeElement(_fbccc.Highlight, _gfaca)
	}
	if _fbccc.ULnTx != nil {
		_ecaae := _g.StartElement{Name: _g.Name{Local: "a:uLnTx"}}
		e.EncodeElement(_fbccc.ULnTx, _ecaae)
	}
	if _fbccc.ULn != nil {
		_gdcdf := _g.StartElement{Name: _g.Name{Local: "a:uLn"}}
		e.EncodeElement(_fbccc.ULn, _gdcdf)
	}
	if _fbccc.UFillTx != nil {
		_cffbc := _g.StartElement{Name: _g.Name{Local: "a:uFillTx"}}
		e.EncodeElement(_fbccc.UFillTx, _cffbc)
	}
	if _fbccc.UFill != nil {
		_ebcdg := _g.StartElement{Name: _g.Name{Local: "a:uFill"}}
		e.EncodeElement(_fbccc.UFill, _ebcdg)
	}
	if _fbccc.Latin != nil {
		_gacae := _g.StartElement{Name: _g.Name{Local: "a:latin"}}
		e.EncodeElement(_fbccc.Latin, _gacae)
	}
	if _fbccc.Ea != nil {
		_gfccb := _g.StartElement{Name: _g.Name{Local: "a:ea"}}
		e.EncodeElement(_fbccc.Ea, _gfccb)
	}
	if _fbccc.Cs != nil {
		_dfbaf := _g.StartElement{Name: _g.Name{Local: "a:cs"}}
		e.EncodeElement(_fbccc.Cs, _dfbaf)
	}
	if _fbccc.Sym != nil {
		_ecfdca := _g.StartElement{Name: _g.Name{Local: "a:sym"}}
		e.EncodeElement(_fbccc.Sym, _ecfdca)
	}
	if _fbccc.HlinkClick != nil {
		_gbbca := _g.StartElement{Name: _g.Name{Local: "a:hlinkClick"}}
		e.EncodeElement(_fbccc.HlinkClick, _gbbca)
	}
	if _fbccc.HlinkMouseOver != nil {
		_cgafa := _g.StartElement{Name: _g.Name{Local: "a:hlinkMouseOver"}}
		e.EncodeElement(_fbccc.HlinkMouseOver, _cgafa)
	}
	if _fbccc.Rtl != nil {
		_cddgfa := _g.StartElement{Name: _g.Name{Local: "a:rtl"}}
		e.EncodeElement(_fbccc.Rtl, _cddgfa)
	}
	if _fbccc.ExtLst != nil {
		_gfbbba := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_fbccc.ExtLst, _gfbbba)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_QuickTimeFile and its children, prefixing error messages with path
func (_edcdc *CT_QuickTimeFile) ValidateWithPath(path string) error {
	if _edcdc.ExtLst != nil {
		if _ccbdc := _edcdc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ccbdc != nil {
			return _ccbdc
		}
	}
	return nil
}
func NewCT_Headers() *CT_Headers { _cebgd := &CT_Headers{}; return _cebgd }

// ValidateWithPath validates the CT_SupplementalFont and its children, prefixing error messages with path
func (_egcg *CT_SupplementalFont) ValidateWithPath(path string) error { return nil }

type EG_ThemeableFontStyles struct {
	Font    *CT_FontCollection
	FontRef *CT_FontReference
}

func (_fgdbg *CT_RegularTextRun) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gfdbf:
	for {
		_cbadbb, _ggced := d.Token()
		if _ggced != nil {
			return _ggced
		}
		switch _bcbeg := _cbadbb.(type) {
		case _g.StartElement:
			switch _bcbeg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "rPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "rPr"}:
				_fgdbg.RPr = NewCT_TextCharacterProperties()
				if _abdf := d.DecodeElement(_fgdbg.RPr, &_bcbeg); _abdf != nil {
					return _abdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "t"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "t"}:
				if _gbefce := d.DecodeElement(&_fgdbg.T, &_bcbeg); _gbefce != nil {
					return _gbefce
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_RegularTextRun\u0020\u0025v", _bcbeg.Name)
				if _bccda := d.Skip(); _bccda != nil {
					return _bccda
				}
			}
		case _g.EndElement:
			break _gfdbf
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_XYAdjustHandle() *CT_XYAdjustHandle {
	_gcefg := &CT_XYAdjustHandle{}
	_gcefg.Pos = NewCT_AdjPoint2D()
	return _gcefg
}

// Validate validates the EG_LineFillProperties and its children
func (_gfdeg *EG_LineFillProperties) Validate() error {
	return _gfdeg.ValidateWithPath("EG_LineFillProperties")
}
func (_dggaae *ST_TextAnchoringType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_dggaae = 0
	case "t":
		*_dggaae = 1
	case "ctr":
		*_dggaae = 2
	case "b":
		*_dggaae = 3
	case "just":
		*_dggaae = 4
	case "dist":
		*_dggaae = 5
	}
	return nil
}

type TblStyleLst struct{ CT_TableStyleList }

func (_gffd ST_FontCollectionIndex) ValidateWithPath(path string) error {
	switch _gffd {
	case 0, 1, 2, 3:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gffd))
	}
	return nil
}
func (_gfgbgf *ST_SystemColorVal) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cdabb, _cccc := d.Token()
	if _cccc != nil {
		return _cccc
	}
	if _abdba, _fecab := _cdabb.(_g.EndElement); _fecab && _abdba.Name == start.Name {
		*_gfgbgf = 1
		return nil
	}
	if _aeebec, _ecddb := _cdabb.(_g.CharData); !_ecddb {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cdabb)
	} else {
		switch string(_aeebec) {
		case "":
			*_gfgbgf = 0
		case "scrollBar":
			*_gfgbgf = 1
		case "background":
			*_gfgbgf = 2
		case "activeCaption":
			*_gfgbgf = 3
		case "inactiveCaption":
			*_gfgbgf = 4
		case "menu":
			*_gfgbgf = 5
		case "window":
			*_gfgbgf = 6
		case "windowFrame":
			*_gfgbgf = 7
		case "menuText":
			*_gfgbgf = 8
		case "windowText":
			*_gfgbgf = 9
		case "captionText":
			*_gfgbgf = 10
		case "activeBorder":
			*_gfgbgf = 11
		case "inactiveBorder":
			*_gfgbgf = 12
		case "appWorkspace":
			*_gfgbgf = 13
		case "highlight":
			*_gfgbgf = 14
		case "highlightText":
			*_gfgbgf = 15
		case "btnFace":
			*_gfgbgf = 16
		case "btnShadow":
			*_gfgbgf = 17
		case "grayText":
			*_gfgbgf = 18
		case "btnText":
			*_gfgbgf = 19
		case "inactiveCaptionText":
			*_gfgbgf = 20
		case "btnHighlight":
			*_gfgbgf = 21
		case "3dDkShadow":
			*_gfgbgf = 22
		case "3dLight":
			*_gfgbgf = 23
		case "infoText":
			*_gfgbgf = 24
		case "infoBk":
			*_gfgbgf = 25
		case "hotLight":
			*_gfgbgf = 26
		case "gradientActiveCaption":
			*_gfgbgf = 27
		case "gradientInactiveCaption":
			*_gfgbgf = 28
		case "menuHighlight":
			*_gfgbgf = 29
		case "menuBar":
			*_gfgbgf = 30
		}
	}
	_cdabb, _cccc = d.Token()
	if _cccc != nil {
		return _cccc
	}
	if _degfa, _bafaa := _cdabb.(_g.EndElement); _bafaa && _degfa.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cdabb)
}
func (_fgebg ST_AnimationBuildType) ValidateWithPath(path string) error {
	switch _fgebg {
	case 0, 1:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fgebg))
	}
	return nil
}
func NewCT_AudioCDTime() *CT_AudioCDTime { _fdf := &CT_AudioCDTime{}; return _fdf }
func (_bgfbc *ST_ChartBuildStep) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_bgfbc = 0
	case "category":
		*_bgfbc = 1
	case "ptInCategory":
		*_bgfbc = 2
	case "series":
		*_bgfbc = 3
	case "ptInSeries":
		*_bgfbc = 4
	case "allPts":
		*_bgfbc = 5
	case "gridLegend":
		*_bgfbc = 6
	}
	return nil
}
func NewCT_TextField() *CT_TextField {
	_cgca := &CT_TextField{}
	_cgca.IdAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	return _cgca
}
func (_feaae *CT_TableRow) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bebgf := range start.Attr {
		if _bebgf.Name.Local == "h" {
			_fccce, _caagfc := ParseUnionST_Coordinate(_bebgf.Value)
			if _caagfc != nil {
				return _caagfc
			}
			_feaae.HAttr = _fccce
			continue
		}
	}
_fega:
	for {
		_acfea, _efbad := d.Token()
		if _efbad != nil {
			return _efbad
		}
		switch _cegc := _acfea.(type) {
		case _g.StartElement:
			switch _cegc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tc"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tc"}:
				_baafd := NewCT_TableCell()
				if _gfcad := d.DecodeElement(_baafd, &_cegc); _gfcad != nil {
					return _gfcad
				}
				_feaae.Tc = append(_feaae.Tc, _baafd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_feaae.ExtLst = NewCT_OfficeArtExtensionList()
				if _aabb := d.DecodeElement(_feaae.ExtLst, &_cegc); _aabb != nil {
					return _aabb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TableRow\u0020\u0025v", _cegc.Name)
				if _fafdg := d.Skip(); _fafdg != nil {
					return _fafdg
				}
			}
		case _g.EndElement:
			break _fega
		case _g.CharData:
		}
	}
	return nil
}

type CT_TextShapeAutofit struct{}

func (_eeb *CT_BlipFillProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _gggf := range start.Attr {
		if _gggf.Name.Local == "dpi" {
			_aceeb, _fdbe := _e.ParseUint(_gggf.Value, 10, 32)
			if _fdbe != nil {
				return _fdbe
			}
			_egff := uint32(_aceeb)
			_eeb.DpiAttr = &_egff
			continue
		}
		if _gggf.Name.Local == "rotWithShape" {
			_fcfa, _agbdc := _e.ParseBool(_gggf.Value)
			if _agbdc != nil {
				return _agbdc
			}
			_eeb.RotWithShapeAttr = &_fcfa
			continue
		}
	}
_fcfcg:
	for {
		_fcdd, _gced := d.Token()
		if _gced != nil {
			return _gced
		}
		switch _dbdd := _fcdd.(type) {
		case _g.StartElement:
			switch _dbdd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blip"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blip"}:
				_eeb.Blip = NewCT_Blip()
				if _abac := d.DecodeElement(_eeb.Blip, &_dbdd); _abac != nil {
					return _abac
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srcRect"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srcRect"}:
				_eeb.SrcRect = NewCT_RelativeRect()
				if _ccaf := d.DecodeElement(_eeb.SrcRect, &_dbdd); _ccaf != nil {
					return _ccaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tile"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tile"}:
				_eeb.Tile = NewCT_TileInfoProperties()
				if _cdfc := d.DecodeElement(_eeb.Tile, &_dbdd); _cdfc != nil {
					return _cdfc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "stretch"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "stretch"}:
				_eeb.Stretch = NewCT_StretchInfoProperties()
				if _dafa := d.DecodeElement(_eeb.Stretch, &_dbdd); _dafa != nil {
					return _dafa
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_BlipFillProperties\u0020\u0025v", _dbdd.Name)
				if _befge := d.Skip(); _befge != nil {
					return _befge
				}
			}
		case _g.EndElement:
			break _fcfcg
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_BlurEffect() *CT_BlurEffect { _ecfgc := &CT_BlurEffect{}; return _ecfgc }

// ValidateWithPath validates the CT_TextCharacterProperties and its children, prefixing error messages with path
func (_afeae *CT_TextCharacterProperties) ValidateWithPath(path string) error {
	if _afeae.SzAttr != nil {
		if *_afeae.SzAttr < 100 {
			return _dcf.Errorf("\u0025s/m\u002eSzAttr\u0020must be\u0020\u003e\u003d\u0020100 \u0028have\u0020\u0025v\u0029", path, *_afeae.SzAttr)
		}
		if *_afeae.SzAttr > 400000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eSzAttr\u0020must\u0020be\u0020<\u003d\u0020400000\u0020\u0028have\u0020\u0025v\u0029", path, *_afeae.SzAttr)
		}
	}
	if _cbeee := _afeae.UAttr.ValidateWithPath(path + "\u002fUAttr"); _cbeee != nil {
		return _cbeee
	}
	if _bdeeb := _afeae.StrikeAttr.ValidateWithPath(path + "/StrikeAttr"); _bdeeb != nil {
		return _bdeeb
	}
	if _afeae.KernAttr != nil {
		if *_afeae.KernAttr < 0 {
			return _dcf.Errorf("\u0025s/m\u002eKernAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_afeae.KernAttr)
		}
		if *_afeae.KernAttr > 400000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eKernAttr\u0020must\u0020be\u0020\u003c\u003d\u0020400000\u0020\u0028have\u0020\u0025v\u0029", path, *_afeae.KernAttr)
		}
	}
	if _gaefb := _afeae.CapAttr.ValidateWithPath(path + "\u002fCapAttr"); _gaefb != nil {
		return _gaefb
	}
	if _afeae.SpcAttr != nil {
		if _cfcfe := _afeae.SpcAttr.ValidateWithPath(path + "\u002fSpcAttr"); _cfcfe != nil {
			return _cfcfe
		}
	}
	if _afeae.BaselineAttr != nil {
		if _dcaace := _afeae.BaselineAttr.ValidateWithPath(path + "\u002fBaselineAttr"); _dcaace != nil {
			return _dcaace
		}
	}
	if _afeae.Ln != nil {
		if _ecdgd := _afeae.Ln.ValidateWithPath(path + "\u002fLn"); _ecdgd != nil {
			return _ecdgd
		}
	}
	if _afeae.NoFill != nil {
		if _effg := _afeae.NoFill.ValidateWithPath(path + "\u002fNoFill"); _effg != nil {
			return _effg
		}
	}
	if _afeae.SolidFill != nil {
		if _fgggf := _afeae.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _fgggf != nil {
			return _fgggf
		}
	}
	if _afeae.GradFill != nil {
		if _dcdcf := _afeae.GradFill.ValidateWithPath(path + "\u002fGradFill"); _dcdcf != nil {
			return _dcdcf
		}
	}
	if _afeae.BlipFill != nil {
		if _cedce := _afeae.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _cedce != nil {
			return _cedce
		}
	}
	if _afeae.PattFill != nil {
		if _bgffa := _afeae.PattFill.ValidateWithPath(path + "\u002fPattFill"); _bgffa != nil {
			return _bgffa
		}
	}
	if _afeae.GrpFill != nil {
		if _cbbb := _afeae.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _cbbb != nil {
			return _cbbb
		}
	}
	if _afeae.EffectLst != nil {
		if _ecfdd := _afeae.EffectLst.ValidateWithPath(path + "\u002fEffectLst"); _ecfdd != nil {
			return _ecfdd
		}
	}
	if _afeae.EffectDag != nil {
		if _dccge := _afeae.EffectDag.ValidateWithPath(path + "\u002fEffectDag"); _dccge != nil {
			return _dccge
		}
	}
	if _afeae.Highlight != nil {
		if _ceeef := _afeae.Highlight.ValidateWithPath(path + "\u002fHighlight"); _ceeef != nil {
			return _ceeef
		}
	}
	if _afeae.ULnTx != nil {
		if _afcc := _afeae.ULnTx.ValidateWithPath(path + "\u002fULnTx"); _afcc != nil {
			return _afcc
		}
	}
	if _afeae.ULn != nil {
		if _dgacg := _afeae.ULn.ValidateWithPath(path + "\u002fULn"); _dgacg != nil {
			return _dgacg
		}
	}
	if _afeae.UFillTx != nil {
		if _edcge := _afeae.UFillTx.ValidateWithPath(path + "\u002fUFillTx"); _edcge != nil {
			return _edcge
		}
	}
	if _afeae.UFill != nil {
		if _caece := _afeae.UFill.ValidateWithPath(path + "\u002fUFill"); _caece != nil {
			return _caece
		}
	}
	if _afeae.Latin != nil {
		if _fdbee := _afeae.Latin.ValidateWithPath(path + "\u002fLatin"); _fdbee != nil {
			return _fdbee
		}
	}
	if _afeae.Ea != nil {
		if _addbg := _afeae.Ea.ValidateWithPath(path + "\u002fEa"); _addbg != nil {
			return _addbg
		}
	}
	if _afeae.Cs != nil {
		if _fedccd := _afeae.Cs.ValidateWithPath(path + "\u002fCs"); _fedccd != nil {
			return _fedccd
		}
	}
	if _afeae.Sym != nil {
		if _eebbc := _afeae.Sym.ValidateWithPath(path + "\u002fSym"); _eebbc != nil {
			return _eebbc
		}
	}
	if _afeae.HlinkClick != nil {
		if _cfeb := _afeae.HlinkClick.ValidateWithPath(path + "/HlinkClick"); _cfeb != nil {
			return _cfeb
		}
	}
	if _afeae.HlinkMouseOver != nil {
		if _aggfd := _afeae.HlinkMouseOver.ValidateWithPath(path + "\u002fHlinkMouseOver"); _aggfd != nil {
			return _aggfd
		}
	}
	if _afeae.Rtl != nil {
		if _gebd := _afeae.Rtl.ValidateWithPath(path + "\u002fRtl"); _gebd != nil {
			return _gebd
		}
	}
	if _afeae.ExtLst != nil {
		if _egdca := _afeae.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _egdca != nil {
			return _egdca
		}
	}
	return nil
}

type CT_TextField struct {
	IdAttr   string
	TypeAttr *string
	RPr      *CT_TextCharacterProperties
	PPr      *CT_TextParagraphProperties
	T        *string
}

// ValidateWithPath validates the CT_TableStyleList and its children, prefixing error messages with path
func (_cfdc *CT_TableStyleList) ValidateWithPath(path string) error {
	if !_f.ST_GuidPatternRe.MatchString(_cfdc.DefAttr) {
		return _dcf.Errorf("\u0025s\u002fm\u002eDefAttr\u0020must\u0020match\u0020'\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _f.ST_GuidPatternRe, _cfdc.DefAttr)
	}
	for _ggcdb, _dcded := range _cfdc.TblStyle {
		if _edagc := _dcded.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fTblStyle\u005b\u0025d\u005d", path, _ggcdb)); _edagc != nil {
			return _edagc
		}
	}
	return nil
}
func NewCT_ClipboardStyleSheet() *CT_ClipboardStyleSheet {
	_bbgd := &CT_ClipboardStyleSheet{}
	_bbgd.ThemeElements = NewCT_BaseStyles()
	_bbgd.ClrMap = NewCT_ColorMapping()
	return _bbgd
}

type EG_FillModeProperties struct {
	Tile    *CT_TileInfoProperties
	Stretch *CT_StretchInfoProperties
}

func (_fgfac *CT_GraphicalObjectData) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bffbb := range start.Attr {
		if _bffbb.Name.Local == "uri" {
			_gbagb, _eedce := _bffbb.Value, error(nil)
			if _eedce != nil {
				return _eedce
			}
			_fgfac.UriAttr = _gbagb
			continue
		}
	}
_aebec:
	for {
		_cggeg, _bacaa := d.Token()
		if _bacaa != nil {
			return _bacaa
		}
		switch _cffe := _cggeg.(type) {
		case _g.StartElement:
			switch _cffe.Name {
			default:
				if _eggbd, _baeff := _ee.CreateElement(_cffe); _baeff != nil {
					return _baeff
				} else {
					if _ddbga := d.DecodeElement(_eggbd, &_cffe); _ddbga != nil {
						return _ddbga
					}
					_fgfac.Any = append(_fgfac.Any, _eggbd)
				}
			}
		case _g.EndElement:
			break _aebec
		case _g.CharData:
		}
	}
	return nil
}
func NewEG_EffectProperties() *EG_EffectProperties { _efgccf := &EG_EffectProperties{}; return _efgccf }
func (_fegda ST_PresetShadowVal) ValidateWithPath(path string) error {
	switch _fegda {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fegda))
	}
	return nil
}

// ValidateWithPath validates the CT_StyleMatrixReference and its children, prefixing error messages with path
func (_fddc *CT_StyleMatrixReference) ValidateWithPath(path string) error {
	if _fddc.ScrgbClr != nil {
		if _dbbef := _fddc.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _dbbef != nil {
			return _dbbef
		}
	}
	if _fddc.SrgbClr != nil {
		if _fbbga := _fddc.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _fbbga != nil {
			return _fbbga
		}
	}
	if _fddc.HslClr != nil {
		if _dfegd := _fddc.HslClr.ValidateWithPath(path + "\u002fHslClr"); _dfegd != nil {
			return _dfegd
		}
	}
	if _fddc.SysClr != nil {
		if _bgbaa := _fddc.SysClr.ValidateWithPath(path + "\u002fSysClr"); _bgbaa != nil {
			return _bgbaa
		}
	}
	if _fddc.SchemeClr != nil {
		if _bcfcd := _fddc.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _bcfcd != nil {
			return _bcfcd
		}
	}
	if _fddc.PrstClr != nil {
		if _gdgfad := _fddc.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _gdgfad != nil {
			return _gdgfad
		}
	}
	return nil
}
func NewCT_TextNormalAutofit() *CT_TextNormalAutofit {
	_gecaa := &CT_TextNormalAutofit{}
	return _gecaa
}
func (_edgg *CT_NonVisualDrawingShapeProps) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _egfea := range start.Attr {
		if _egfea.Name.Local == "txBox" {
			_gbabc, _bdgag := _e.ParseBool(_egfea.Value)
			if _bdgag != nil {
				return _bdgag
			}
			_edgg.TxBoxAttr = &_gbabc
			continue
		}
	}
_ffbc:
	for {
		_cebccb, _agcef := d.Token()
		if _agcef != nil {
			return _agcef
		}
		switch _fadeb := _cebccb.(type) {
		case _g.StartElement:
			switch _fadeb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spLocks"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spLocks"}:
				_edgg.SpLocks = NewCT_ShapeLocking()
				if _cgde := d.DecodeElement(_edgg.SpLocks, &_fadeb); _cgde != nil {
					return _cgde
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_edgg.ExtLst = NewCT_OfficeArtExtensionList()
				if _ecgeg := d.DecodeElement(_edgg.ExtLst, &_fadeb); _ecgeg != nil {
					return _ecgeg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_NonVisualDrawingShapeProps\u0020%v", _fadeb.Name)
				if _adcf := d.Skip(); _adcf != nil {
					return _adcf
				}
			}
		case _g.EndElement:
			break _ffbc
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_InnerShadowEffect and its children
func (_fccb *CT_InnerShadowEffect) Validate() error {
	return _fccb.ValidateWithPath("CT_InnerShadowEffect")
}

// Validate validates the CT_RelativeOffsetEffect and its children
func (_afeff *CT_RelativeOffsetEffect) Validate() error {
	return _afeff.ValidateWithPath("CT_RelativeOffsetEffect")
}

// ValidateWithPath validates the CT_GradientFillProperties and its children, prefixing error messages with path
func (_eeea *CT_GradientFillProperties) ValidateWithPath(path string) error {
	if _cdcge := _eeea.FlipAttr.ValidateWithPath(path + "\u002fFlipAttr"); _cdcge != nil {
		return _cdcge
	}
	if _eeea.GsLst != nil {
		if _caggb := _eeea.GsLst.ValidateWithPath(path + "\u002fGsLst"); _caggb != nil {
			return _caggb
		}
	}
	if _eeea.Lin != nil {
		if _bega := _eeea.Lin.ValidateWithPath(path + "\u002fLin"); _bega != nil {
			return _bega
		}
	}
	if _eeea.Path != nil {
		if _fadg := _eeea.Path.ValidateWithPath(path + "\u002fPath"); _fadg != nil {
			return _fadg
		}
	}
	if _eeea.TileRect != nil {
		if _cbbe := _eeea.TileRect.ValidateWithPath(path + "\u002fTileRect"); _cbbe != nil {
			return _cbbe
		}
	}
	return nil
}
func (_fcegb *EG_TextBulletTypeface) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gbaea:
	for {
		_ffdf, _gacdc := d.Token()
		if _gacdc != nil {
			return _gacdc
		}
		switch _dcfaa := _ffdf.(type) {
		case _g.StartElement:
			switch _dcfaa.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buFontTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buFontTx"}:
				_fcegb.BuFontTx = NewCT_TextBulletTypefaceFollowText()
				if _dacfdf := d.DecodeElement(_fcegb.BuFontTx, &_dcfaa); _dacfdf != nil {
					return _dacfdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buFont"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buFont"}:
				_fcegb.BuFont = NewCT_TextFont()
				if _gbgea := d.DecodeElement(_fcegb.BuFont, &_dcfaa); _gbgea != nil {
					return _gbgea
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on EG_TextBulletTypeface\u0020\u0025v", _dcfaa.Name)
				if _eaece := d.Skip(); _eaece != nil {
					return _eaece
				}
			}
		case _g.EndElement:
			break _gbaea
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_TextNoBullet and its children
func (_fcaa *CT_TextNoBullet) Validate() error { return _fcaa.ValidateWithPath("CT_TextNoBullet") }

// Validate validates the CT_LineJoinRound and its children
func (_bdag *CT_LineJoinRound) Validate() error { return _bdag.ValidateWithPath("CT_LineJoinRound") }
func (_bgec *CT_ColorSchemeList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _bgec.ExtraClrScheme != nil {
		_eaae := _g.StartElement{Name: _g.Name{Local: "a:extraClrScheme"}}
		for _, _bgfe := range _bgec.ExtraClrScheme {
			e.EncodeElement(_bgfe, _eaae)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_NonVisualPictureProperties and its children, prefixing error messages with path
func (_aggdf *CT_NonVisualPictureProperties) ValidateWithPath(path string) error {
	if _aggdf.PicLocks != nil {
		if _geaed := _aggdf.PicLocks.ValidateWithPath(path + "\u002fPicLocks"); _geaed != nil {
			return _geaed
		}
	}
	if _aggdf.ExtLst != nil {
		if _bcfeb := _aggdf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bcfeb != nil {
			return _bcfeb
		}
	}
	return nil
}
func (_gabca *CT_TablePartStyle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_ceeaec:
	for {
		_ecggf, _eafeb := d.Token()
		if _eafeb != nil {
			return _eafeb
		}
		switch _dcfcc := _ecggf.(type) {
		case _g.StartElement:
			switch _dcfcc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tcTxStyle"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tcTxStyle"}:
				_gabca.TcTxStyle = NewCT_TableStyleTextStyle()
				if _gbacbe := d.DecodeElement(_gabca.TcTxStyle, &_dcfcc); _gbacbe != nil {
					return _gbacbe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tcStyle"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tcStyle"}:
				_gabca.TcStyle = NewCT_TableStyleCellStyle()
				if _dabc := d.DecodeElement(_gabca.TcStyle, &_dcfcc); _dabc != nil {
					return _dabc
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_TablePartStyle\u0020\u0025v", _dcfcc.Name)
				if _cefb := d.Skip(); _cefb != nil {
					return _cefb
				}
			}
		case _g.EndElement:
			break _ceeaec
		case _g.CharData:
		}
	}
	return nil
}
func (_bdfc *CT_GlowEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _bdfc.RadAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rad"}, Value: _dcf.Sprintf("\u0025v", *_bdfc.RadAttr)})
	}
	e.EncodeToken(start)
	if _bdfc.ScrgbClr != nil {
		_bfgg := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_bdfc.ScrgbClr, _bfgg)
	}
	if _bdfc.SrgbClr != nil {
		_eeef := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_bdfc.SrgbClr, _eeef)
	}
	if _bdfc.HslClr != nil {
		_egda := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_bdfc.HslClr, _egda)
	}
	if _bdfc.SysClr != nil {
		_acdg := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_bdfc.SysClr, _acdg)
	}
	if _bdfc.SchemeClr != nil {
		_addec := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_bdfc.SchemeClr, _addec)
	}
	if _bdfc.PrstClr != nil {
		_bfdd := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_bdfc.PrstClr, _bfdd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_daed ST_SchemeColorVal) ValidateWithPath(path string) error {
	switch _daed {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_daed))
	}
	return nil
}
func (_eceeb *ST_ShapeType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bcage, _fcee := d.Token()
	if _fcee != nil {
		return _fcee
	}
	if _gfbad, _bbeca := _bcage.(_g.EndElement); _bbeca && _gfbad.Name == start.Name {
		*_eceeb = 1
		return nil
	}
	if _bebefc, _adffd := _bcage.(_g.CharData); !_adffd {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bcage)
	} else {
		switch string(_bebefc) {
		case "":
			*_eceeb = 0
		case "line":
			*_eceeb = 1
		case "lineInv":
			*_eceeb = 2
		case "triangle":
			*_eceeb = 3
		case "rtTriangle":
			*_eceeb = 4
		case "rect":
			*_eceeb = 5
		case "diamond":
			*_eceeb = 6
		case "parallelogram":
			*_eceeb = 7
		case "trapezoid":
			*_eceeb = 8
		case "nonIsoscelesTrapezoid":
			*_eceeb = 9
		case "pentagon":
			*_eceeb = 10
		case "hexagon":
			*_eceeb = 11
		case "heptagon":
			*_eceeb = 12
		case "octagon":
			*_eceeb = 13
		case "decagon":
			*_eceeb = 14
		case "dodecagon":
			*_eceeb = 15
		case "star4":
			*_eceeb = 16
		case "star5":
			*_eceeb = 17
		case "star6":
			*_eceeb = 18
		case "star7":
			*_eceeb = 19
		case "star8":
			*_eceeb = 20
		case "star10":
			*_eceeb = 21
		case "star12":
			*_eceeb = 22
		case "star16":
			*_eceeb = 23
		case "star24":
			*_eceeb = 24
		case "star32":
			*_eceeb = 25
		case "roundRect":
			*_eceeb = 26
		case "round1Rect":
			*_eceeb = 27
		case "round2SameRect":
			*_eceeb = 28
		case "round2DiagRect":
			*_eceeb = 29
		case "snipRoundRect":
			*_eceeb = 30
		case "snip1Rect":
			*_eceeb = 31
		case "snip2SameRect":
			*_eceeb = 32
		case "snip2DiagRect":
			*_eceeb = 33
		case "plaque":
			*_eceeb = 34
		case "ellipse":
			*_eceeb = 35
		case "teardrop":
			*_eceeb = 36
		case "homePlate":
			*_eceeb = 37
		case "chevron":
			*_eceeb = 38
		case "pieWedge":
			*_eceeb = 39
		case "pie":
			*_eceeb = 40
		case "blockArc":
			*_eceeb = 41
		case "donut":
			*_eceeb = 42
		case "noSmoking":
			*_eceeb = 43
		case "rightArrow":
			*_eceeb = 44
		case "leftArrow":
			*_eceeb = 45
		case "upArrow":
			*_eceeb = 46
		case "downArrow":
			*_eceeb = 47
		case "stripedRightArrow":
			*_eceeb = 48
		case "notchedRightArrow":
			*_eceeb = 49
		case "bentUpArrow":
			*_eceeb = 50
		case "leftRightArrow":
			*_eceeb = 51
		case "upDownArrow":
			*_eceeb = 52
		case "leftUpArrow":
			*_eceeb = 53
		case "leftRightUpArrow":
			*_eceeb = 54
		case "quadArrow":
			*_eceeb = 55
		case "leftArrowCallout":
			*_eceeb = 56
		case "rightArrowCallout":
			*_eceeb = 57
		case "upArrowCallout":
			*_eceeb = 58
		case "downArrowCallout":
			*_eceeb = 59
		case "leftRightArrowCallout":
			*_eceeb = 60
		case "upDownArrowCallout":
			*_eceeb = 61
		case "quadArrowCallout":
			*_eceeb = 62
		case "bentArrow":
			*_eceeb = 63
		case "uturnArrow":
			*_eceeb = 64
		case "circularArrow":
			*_eceeb = 65
		case "leftCircularArrow":
			*_eceeb = 66
		case "leftRightCircularArrow":
			*_eceeb = 67
		case "curvedRightArrow":
			*_eceeb = 68
		case "curvedLeftArrow":
			*_eceeb = 69
		case "curvedUpArrow":
			*_eceeb = 70
		case "curvedDownArrow":
			*_eceeb = 71
		case "swooshArrow":
			*_eceeb = 72
		case "cube":
			*_eceeb = 73
		case "can":
			*_eceeb = 74
		case "lightningBolt":
			*_eceeb = 75
		case "heart":
			*_eceeb = 76
		case "sun":
			*_eceeb = 77
		case "moon":
			*_eceeb = 78
		case "smileyFace":
			*_eceeb = 79
		case "irregularSeal1":
			*_eceeb = 80
		case "irregularSeal2":
			*_eceeb = 81
		case "foldedCorner":
			*_eceeb = 82
		case "bevel":
			*_eceeb = 83
		case "frame":
			*_eceeb = 84
		case "halfFrame":
			*_eceeb = 85
		case "corner":
			*_eceeb = 86
		case "diagStripe":
			*_eceeb = 87
		case "chord":
			*_eceeb = 88
		case "arc":
			*_eceeb = 89
		case "leftBracket":
			*_eceeb = 90
		case "rightBracket":
			*_eceeb = 91
		case "leftBrace":
			*_eceeb = 92
		case "rightBrace":
			*_eceeb = 93
		case "bracketPair":
			*_eceeb = 94
		case "bracePair":
			*_eceeb = 95
		case "straightConnector1":
			*_eceeb = 96
		case "bentConnector2":
			*_eceeb = 97
		case "bentConnector3":
			*_eceeb = 98
		case "bentConnector4":
			*_eceeb = 99
		case "bentConnector5":
			*_eceeb = 100
		case "curvedConnector2":
			*_eceeb = 101
		case "curvedConnector3":
			*_eceeb = 102
		case "curvedConnector4":
			*_eceeb = 103
		case "curvedConnector5":
			*_eceeb = 104
		case "callout1":
			*_eceeb = 105
		case "callout2":
			*_eceeb = 106
		case "callout3":
			*_eceeb = 107
		case "accentCallout1":
			*_eceeb = 108
		case "accentCallout2":
			*_eceeb = 109
		case "accentCallout3":
			*_eceeb = 110
		case "borderCallout1":
			*_eceeb = 111
		case "borderCallout2":
			*_eceeb = 112
		case "borderCallout3":
			*_eceeb = 113
		case "accentBorderCallout1":
			*_eceeb = 114
		case "accentBorderCallout2":
			*_eceeb = 115
		case "accentBorderCallout3":
			*_eceeb = 116
		case "wedgeRectCallout":
			*_eceeb = 117
		case "wedgeRoundRectCallout":
			*_eceeb = 118
		case "wedgeEllipseCallout":
			*_eceeb = 119
		case "cloudCallout":
			*_eceeb = 120
		case "cloud":
			*_eceeb = 121
		case "ribbon":
			*_eceeb = 122
		case "ribbon2":
			*_eceeb = 123
		case "ellipseRibbon":
			*_eceeb = 124
		case "ellipseRibbon2":
			*_eceeb = 125
		case "leftRightRibbon":
			*_eceeb = 126
		case "verticalScroll":
			*_eceeb = 127
		case "horizontalScroll":
			*_eceeb = 128
		case "wave":
			*_eceeb = 129
		case "doubleWave":
			*_eceeb = 130
		case "plus":
			*_eceeb = 131
		case "flowChartProcess":
			*_eceeb = 132
		case "flowChartDecision":
			*_eceeb = 133
		case "flowChartInputOutput":
			*_eceeb = 134
		case "flowChartPredefinedProcess":
			*_eceeb = 135
		case "flowChartInternalStorage":
			*_eceeb = 136
		case "flowChartDocument":
			*_eceeb = 137
		case "flowChartMultidocument":
			*_eceeb = 138
		case "flowChartTerminator":
			*_eceeb = 139
		case "flowChartPreparation":
			*_eceeb = 140
		case "flowChartManualInput":
			*_eceeb = 141
		case "flowChartManualOperation":
			*_eceeb = 142
		case "flowChartConnector":
			*_eceeb = 143
		case "flowChartPunchedCard":
			*_eceeb = 144
		case "flowChartPunchedTape":
			*_eceeb = 145
		case "flowChartSummingJunction":
			*_eceeb = 146
		case "flowChartOr":
			*_eceeb = 147
		case "flowChartCollate":
			*_eceeb = 148
		case "flowChartSort":
			*_eceeb = 149
		case "flowChartExtract":
			*_eceeb = 150
		case "flowChartMerge":
			*_eceeb = 151
		case "flowChartOfflineStorage":
			*_eceeb = 152
		case "flowChartOnlineStorage":
			*_eceeb = 153
		case "flowChartMagneticTape":
			*_eceeb = 154
		case "flowChartMagneticDisk":
			*_eceeb = 155
		case "flowChartMagneticDrum":
			*_eceeb = 156
		case "flowChartDisplay":
			*_eceeb = 157
		case "flowChartDelay":
			*_eceeb = 158
		case "flowChartAlternateProcess":
			*_eceeb = 159
		case "flowChartOffpageConnector":
			*_eceeb = 160
		case "actionButtonBlank":
			*_eceeb = 161
		case "actionButtonHome":
			*_eceeb = 162
		case "actionButtonHelp":
			*_eceeb = 163
		case "actionButtonInformation":
			*_eceeb = 164
		case "actionButtonForwardNext":
			*_eceeb = 165
		case "actionButtonBackPrevious":
			*_eceeb = 166
		case "actionButtonEnd":
			*_eceeb = 167
		case "actionButtonBeginning":
			*_eceeb = 168
		case "actionButtonReturn":
			*_eceeb = 169
		case "actionButtonDocument":
			*_eceeb = 170
		case "actionButtonSound":
			*_eceeb = 171
		case "actionButtonMovie":
			*_eceeb = 172
		case "gear6":
			*_eceeb = 173
		case "gear9":
			*_eceeb = 174
		case "funnel":
			*_eceeb = 175
		case "mathPlus":
			*_eceeb = 176
		case "mathMinus":
			*_eceeb = 177
		case "mathMultiply":
			*_eceeb = 178
		case "mathDivide":
			*_eceeb = 179
		case "mathEqual":
			*_eceeb = 180
		case "mathNotEqual":
			*_eceeb = 181
		case "cornerTabs":
			*_eceeb = 182
		case "squareTabs":
			*_eceeb = 183
		case "plaqueTabs":
			*_eceeb = 184
		case "chartX":
			*_eceeb = 185
		case "chartStar":
			*_eceeb = 186
		case "chartPlus":
			*_eceeb = 187
		}
	}
	_bcage, _fcee = d.Token()
	if _fcee != nil {
		return _fcee
	}
	if _agfce, _cccgc := _bcage.(_g.EndElement); _cccgc && _agfce.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bcage)
}

type CT_SystemColor struct {
	ValAttr           ST_SystemColorVal
	LastClrAttr       *string
	EG_ColorTransform []*EG_ColorTransform
}

func (_beaed *CT_CustomColor) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _beaed.NameAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "name"}, Value: _dcf.Sprintf("\u0025v", *_beaed.NameAttr)})
	}
	e.EncodeToken(start)
	if _beaed.ScrgbClr != nil {
		_cggfe := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_beaed.ScrgbClr, _cggfe)
	}
	if _beaed.SrgbClr != nil {
		_dgde := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_beaed.SrgbClr, _dgde)
	}
	if _beaed.HslClr != nil {
		_gfge := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_beaed.HslClr, _gfge)
	}
	if _beaed.SysClr != nil {
		_ecae := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_beaed.SysClr, _ecae)
	}
	if _beaed.SchemeClr != nil {
		_dbdad := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_beaed.SchemeClr, _dbdad)
	}
	if _beaed.PrstClr != nil {
		_bcgbf := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_beaed.PrstClr, _bcgbf)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_dcccbb *ST_TextBulletSize) ValidateWithPath(path string) error {
	_gfggd := []string{}
	if _dcccbb.ST_TextBulletSizePercent != nil {
		_gfggd = append(_gfggd, "ST_TextBulletSizePercent")
	}
	if _dcccbb.ST_TextBulletSizeDecimal != nil {
		_gfggd = append(_gfggd, "ST_TextBulletSizeDecimal")
	}
	if len(_gfggd) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _gfggd)
	}
	return nil
}
func NewCT_Hyperlink() *CT_Hyperlink { _defa := &CT_Hyperlink{}; return _defa }
func (_dceff ST_LineEndLength) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_dceff.String(), start)
}

type CT_AnimationDgmBuildProperties struct {
	BldAttr *ST_AnimationDgmBuildType
	RevAttr *bool
}

// Validate validates the CT_GvmlPictureNonVisual and its children
func (_badaf *CT_GvmlPictureNonVisual) Validate() error {
	return _badaf.ValidateWithPath("CT_GvmlPictureNonVisual")
}
func (_afabe *CT_PatternFillProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _dfbaa := range start.Attr {
		if _dfbaa.Name.Local == "prst" {
			_afabe.PrstAttr.UnmarshalXMLAttr(_dfbaa)
			continue
		}
	}
_bacc:
	for {
		_egad, _gfada := d.Token()
		if _gfada != nil {
			return _gfada
		}
		switch _egeaa := _egad.(type) {
		case _g.StartElement:
			switch _egeaa.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fgClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fgClr"}:
				_afabe.FgClr = NewCT_Color()
				if _aefdee := d.DecodeElement(_afabe.FgClr, &_egeaa); _aefdee != nil {
					return _aefdee
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bgClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bgClr"}:
				_afabe.BgClr = NewCT_Color()
				if _beeaea := d.DecodeElement(_afabe.BgClr, &_egeaa); _beeaea != nil {
					return _beeaea
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_PatternFillProperties\u0020%v", _egeaa.Name)
				if _cccga := d.Skip(); _cccga != nil {
					return _cccga
				}
			}
		case _g.EndElement:
			break _bacc
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_EffectContainer and its children
func (_fadf *CT_EffectContainer) Validate() error {
	return _fadf.ValidateWithPath("CT_EffectContainer")
}
func NewCT_FillStyleList() *CT_FillStyleList { _ffdbf := &CT_FillStyleList{}; return _ffdbf }

// ValidateWithPath validates the CT_OfficeArtExtension and its children, prefixing error messages with path
func (_gdddc *CT_OfficeArtExtension) ValidateWithPath(path string) error { return nil }
func (_cbadae ST_TextSpacingPercentOrPercentString) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _cbadae.ST_TextSpacingPercent != nil {
		e.EncodeToken(_g.CharData(_dcf.Sprintf("\u0025d", *_cbadae.ST_TextSpacingPercent)))
	}
	if _cbadae.ST_Percentage != nil {
		e.EncodeToken(_g.CharData(*_cbadae.ST_Percentage))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

// ValidateWithPath validates the CT_Path2DArcTo and its children, prefixing error messages with path
func (_bdgf *CT_Path2DArcTo) ValidateWithPath(path string) error {
	if _cgcc := _bdgf.WRAttr.ValidateWithPath(path + "\u002fWRAttr"); _cgcc != nil {
		return _cgcc
	}
	if _agdf := _bdgf.HRAttr.ValidateWithPath(path + "\u002fHRAttr"); _agdf != nil {
		return _agdf
	}
	if _cdac := _bdgf.StAngAttr.ValidateWithPath(path + "\u002fStAngAttr"); _cdac != nil {
		return _cdac
	}
	if _dbggc := _bdgf.SwAngAttr.ValidateWithPath(path + "\u002fSwAngAttr"); _dbggc != nil {
		return _dbggc
	}
	return nil
}

// ValidateWithPath validates the CT_GraphicalObjectData and its children, prefixing error messages with path
func (_cafc *CT_GraphicalObjectData) ValidateWithPath(path string) error { return nil }
func (_efe *CT_Camera) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_cfdd, _befc := _efe.PrstAttr.MarshalXMLAttr(_g.Name{Local: "prst"})
	if _befc != nil {
		return _befc
	}
	start.Attr = append(start.Attr, _cfdd)
	if _efe.FovAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "fov"}, Value: _dcf.Sprintf("\u0025v", *_efe.FovAttr)})
	}
	if _efe.ZoomAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "zoom"}, Value: _dcf.Sprintf("\u0025v", *_efe.ZoomAttr)})
	}
	e.EncodeToken(start)
	if _efe.Rot != nil {
		_abbg := _g.StartElement{Name: _g.Name{Local: "a:rot"}}
		e.EncodeElement(_efe.Rot, _abbg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewEG_TextBulletSize() *EG_TextBulletSize { _dggaa := &EG_TextBulletSize{}; return _dggaa }
func (_cbafc *CT_OfficeArtExtension) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ecec := range start.Attr {
		if _ecec.Name.Local == "uri" {
			_bbgcb, _efaa := _ecec.Value, error(nil)
			if _efaa != nil {
				return _efaa
			}
			_cbafc.UriAttr = _bbgcb
			continue
		}
	}
_cdcec:
	for {
		_gaceb, _geeegg := d.Token()
		if _geeegg != nil {
			return _geeegg
		}
		switch _cggfed := _gaceb.(type) {
		case _g.StartElement:
			switch _cggfed.Name {
			default:
				if _gaab, _daeb := _ee.CreateElement(_cggfed); _daeb != nil {
					return _daeb
				} else {
					if _abead := d.DecodeElement(_gaab, &_cggfed); _abead != nil {
						return _abead
					}
					_cbafc.Any = append(_cbafc.Any, _gaab)
				}
			}
		case _g.EndElement:
			break _cdcec
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_AnimationChartBuildProperties and its children, prefixing error messages with path
func (_acge *CT_AnimationChartBuildProperties) ValidateWithPath(path string) error {
	if _acge.BldAttr != nil {
		if _aad := _acge.BldAttr.ValidateWithPath(path + "\u002fBldAttr"); _aad != nil {
			return _aad
		}
	}
	return nil
}

// Validate validates the CT_TransformEffect and its children
func (_afdcf *CT_TransformEffect) Validate() error {
	return _afdcf.ValidateWithPath("CT_TransformEffect")
}
func (_ggdfb *EG_ThemeableFontStyles) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _ggdfb.Font != nil {
		_dddbf := _g.StartElement{Name: _g.Name{Local: "a:font"}}
		e.EncodeElement(_ggdfb.Font, _dddbf)
	}
	if _ggdfb.FontRef != nil {
		_badbd := _g.StartElement{Name: _g.Name{Local: "a:fontRef"}}
		e.EncodeElement(_ggdfb.FontRef, _badbd)
	}
	return nil
}
func (_fcffdbf *CT_TileInfoProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _deace := range start.Attr {
		if _deace.Name.Local == "tx" {
			_eeagac, _gaebb := ParseUnionST_Coordinate(_deace.Value)
			if _gaebb != nil {
				return _gaebb
			}
			_fcffdbf.TxAttr = &_eeagac
			continue
		}
		if _deace.Name.Local == "ty" {
			_ccfca, _bbfed := ParseUnionST_Coordinate(_deace.Value)
			if _bbfed != nil {
				return _bbfed
			}
			_fcffdbf.TyAttr = &_ccfca
			continue
		}
		if _deace.Name.Local == "sx" {
			_baeebd, _ecfbb := ParseUnionST_Percentage(_deace.Value)
			if _ecfbb != nil {
				return _ecfbb
			}
			_fcffdbf.SxAttr = &_baeebd
			continue
		}
		if _deace.Name.Local == "sy" {
			_begge, _gfdde := ParseUnionST_Percentage(_deace.Value)
			if _gfdde != nil {
				return _gfdde
			}
			_fcffdbf.SyAttr = &_begge
			continue
		}
		if _deace.Name.Local == "flip" {
			_fcffdbf.FlipAttr.UnmarshalXMLAttr(_deace)
			continue
		}
		if _deace.Name.Local == "algn" {
			_fcffdbf.AlgnAttr.UnmarshalXMLAttr(_deace)
			continue
		}
	}
	for {
		_bdbcc, _fffec := d.Token()
		if _fffec != nil {
			return _dcf.Errorf("parsing\u0020CT_TileInfoProperties:\u0020\u0025s", _fffec)
		}
		if _bceec, _cgadg := _bdbcc.(_g.EndElement); _cgadg && _bceec.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gaceae ST_AdjAngle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _gaceae.ST_Angle != nil {
		e.EncodeToken(_g.CharData(_dcf.Sprintf("\u0025d", *_gaceae.ST_Angle)))
	}
	if _gaceae.ST_GeomGuideName != nil {
		e.EncodeToken(_g.CharData(*_gaceae.ST_GeomGuideName))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

// ValidateWithPath validates the CT_Hyperlink and its children, prefixing error messages with path
func (_edeab *CT_Hyperlink) ValidateWithPath(path string) error {
	if _edeab.Snd != nil {
		if _bgfd := _edeab.Snd.ValidateWithPath(path + "\u002fSnd"); _bgfd != nil {
			return _bgfd
		}
	}
	if _edeab.ExtLst != nil {
		if _fddb := _edeab.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fddb != nil {
			return _fddb
		}
	}
	return nil
}

type ST_LineEndWidth byte

func (_cfgac ST_DgmBuildStep) ValidateWithPath(path string) error {
	switch _cfgac {
	case 0, 1, 2:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cfgac))
	}
	return nil
}
func (_cdcgge *CT_Percentage) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _eebe := range start.Attr {
		if _eebe.Name.Local == "val" {
			_ccfbb, _edaab := ParseUnionST_Percentage(_eebe.Value)
			if _edaab != nil {
				return _edaab
			}
			_cdcgge.ValAttr = _ccfbb
			continue
		}
	}
	for {
		_cfdee, _cbfdf := d.Token()
		if _cbfdf != nil {
			return _dcf.Errorf("parsing\u0020CT_Percentage:\u0020\u0025s", _cbfdf)
		}
		if _deegdb, _cdccdc := _cfdee.(_g.EndElement); _cdccdc && _deegdb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gffe *CT_DashStop) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "d"}, Value: _dcf.Sprintf("\u0025v", _gffe.DAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sp"}, Value: _dcf.Sprintf("\u0025v", _gffe.SpAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_ThemeableLineStyle() *CT_ThemeableLineStyle {
	_afbdc := &CT_ThemeableLineStyle{}
	return _afbdc
}

// Validate validates the CT_AdjPoint2D and its children
func (_gf *CT_AdjPoint2D) Validate() error { return _gf.ValidateWithPath("CT_AdjPoint2D") }
func (_fcaeg *CT_Path2DMoveTo) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fcaeg.Pt = NewCT_AdjPoint2D()
_cfedf:
	for {
		_bgcag, _cabd := d.Token()
		if _cabd != nil {
			return _cabd
		}
		switch _addeb := _bgcag.(type) {
		case _g.StartElement:
			switch _addeb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pt"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pt"}:
				if _gfaeg := d.DecodeElement(_fcaeg.Pt, &_addeb); _gfaeg != nil {
					return _gfaeg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Path2DMoveTo\u0020\u0025v", _addeb.Name)
				if _fgceg := d.Skip(); _fgceg != nil {
					return _fgceg
				}
			}
		case _g.EndElement:
			break _cfedf
		case _g.CharData:
		}
	}
	return nil
}
func (_eebc *CT_NoFillProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_eedcee, _cbaag := d.Token()
		if _cbaag != nil {
			return _dcf.Errorf("parsing\u0020CT_NoFillProperties:\u0020\u0025s", _cbaag)
		}
		if _ccag, _ggad := _eedcee.(_g.EndElement); _ggad && _ccag.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ddfdf *CT_GraphicalObjectFrameLocking) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	if _ddfdf.NoGrpAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noGrp"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddfdf.NoGrpAttr))})
	}
	if _ddfdf.NoDrilldownAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noDrilldown"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddfdf.NoDrilldownAttr))})
	}
	if _ddfdf.NoSelectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noSelect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddfdf.NoSelectAttr))})
	}
	if _ddfdf.NoChangeAspectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeAspect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddfdf.NoChangeAspectAttr))})
	}
	if _ddfdf.NoMoveAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noMove"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddfdf.NoMoveAttr))})
	}
	if _ddfdf.NoResizeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noResize"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddfdf.NoResizeAttr))})
	}
	e.EncodeToken(start)
	if _ddfdf.ExtLst != nil {
		_effcc := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_ddfdf.ExtLst, _effcc)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TableCellProperties and its children
func (_cdccfa *CT_TableCellProperties) Validate() error {
	return _cdccfa.ValidateWithPath("CT_TableCellProperties")
}
func (_bacbf *ST_PathFillMode) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_bacbf = 0
	case "none":
		*_bacbf = 1
	case "norm":
		*_bacbf = 2
	case "lighten":
		*_bacbf = 3
	case "lightenLess":
		*_bacbf = 4
	case "darken":
		*_bacbf = 5
	case "darkenLess":
		*_bacbf = 6
	}
	return nil
}
func (_ddee *CT_Cell3D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _ddee.PrstMaterialAttr != ST_PresetMaterialTypeUnset {
		_cged, _fdfe := _ddee.PrstMaterialAttr.MarshalXMLAttr(_g.Name{Local: "prstMaterial"})
		if _fdfe != nil {
			return _fdfe
		}
		start.Attr = append(start.Attr, _cged)
	}
	e.EncodeToken(start)
	_agbfb := _g.StartElement{Name: _g.Name{Local: "a:bevel"}}
	e.EncodeElement(_ddee.Bevel, _agbfb)
	if _ddee.LightRig != nil {
		_cbf := _g.StartElement{Name: _g.Name{Local: "a:lightRig"}}
		e.EncodeElement(_ddee.LightRig, _cbf)
	}
	if _ddee.ExtLst != nil {
		_faee := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_ddee.ExtLst, _faee)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_acadd *CT_GradientStop) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "pos"}, Value: _dcf.Sprintf("\u0025v", _acadd.PosAttr)})
	e.EncodeToken(start)
	if _acadd.ScrgbClr != nil {
		_ggeb := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_acadd.ScrgbClr, _ggeb)
	}
	if _acadd.SrgbClr != nil {
		_bgfae := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_acadd.SrgbClr, _bgfae)
	}
	if _acadd.HslClr != nil {
		_eeacd := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_acadd.HslClr, _eeacd)
	}
	if _acadd.SysClr != nil {
		_cfdbe := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_acadd.SysClr, _cfdbe)
	}
	if _acadd.SchemeClr != nil {
		_gbab := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_acadd.SchemeClr, _gbab)
	}
	if _acadd.PrstClr != nil {
		_fcebd := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_acadd.PrstClr, _fcebd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_geabf *CT_InverseGammaTransform) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_gcdba *EG_TextBullet) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _gcdba.BuNone != nil {
		_gbbec := _g.StartElement{Name: _g.Name{Local: "a:buNone"}}
		e.EncodeElement(_gcdba.BuNone, _gbbec)
	}
	if _gcdba.BuAutoNum != nil {
		_bddaff := _g.StartElement{Name: _g.Name{Local: "a:buAutoNum"}}
		e.EncodeElement(_gcdba.BuAutoNum, _bddaff)
	}
	if _gcdba.BuChar != nil {
		_bdbeb := _g.StartElement{Name: _g.Name{Local: "a:buChar"}}
		e.EncodeElement(_gcdba.BuChar, _bdbeb)
	}
	if _gcdba.BuBlip != nil {
		_fbefb := _g.StartElement{Name: _g.Name{Local: "a:buBlip"}}
		e.EncodeElement(_gcdba.BuBlip, _fbefb)
	}
	return nil
}
func (_bagf *CT_Color) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _bagf.ScrgbClr != nil {
		_eeaga := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_bagf.ScrgbClr, _eeaga)
	}
	if _bagf.SrgbClr != nil {
		_add := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_bagf.SrgbClr, _add)
	}
	if _bagf.HslClr != nil {
		_adef := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_bagf.HslClr, _adef)
	}
	if _bagf.SysClr != nil {
		_ccde := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_bagf.SysClr, _ccde)
	}
	if _bagf.SchemeClr != nil {
		_babg := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_bagf.SchemeClr, _babg)
	}
	if _bagf.PrstClr != nil {
		_egea := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_bagf.PrstClr, _egea)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_TextNoBullet() *CT_TextNoBullet     { _ecdcd := &CT_TextNoBullet{}; return _ecdcd }
func (_abcdd ST_DgmBuildStep) Validate() error { return _abcdd.ValidateWithPath("") }

type ST_PathFillMode byte

// Validate validates the EG_Geometry and its children
func (_aefce *EG_Geometry) Validate() error { return _aefce.ValidateWithPath("EG_Geometry") }

type CT_AlphaCeilingEffect struct{}
type CT_ColorSchemeAndMapping struct {
	ClrScheme *CT_ColorScheme
	ClrMap    *CT_ColorMapping
}

func NewCT_TileInfoProperties() *CT_TileInfoProperties {
	_cbbdb := &CT_TileInfoProperties{}
	return _cbbdb
}
func NewCT_Percentage() *CT_Percentage { _dcaga := &CT_Percentage{}; return _dcaga }
func (_dagec *CT_DefaultShapeDefinition) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dagec.SpPr = NewCT_ShapeProperties()
	_dagec.BodyPr = NewCT_TextBodyProperties()
	_dagec.LstStyle = NewCT_TextListStyle()
_daadd:
	for {
		_ggda, _efgad := d.Token()
		if _efgad != nil {
			return _efgad
		}
		switch _bfce := _ggda.(type) {
		case _g.StartElement:
			switch _bfce.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spPr"}:
				if _ecbd := d.DecodeElement(_dagec.SpPr, &_bfce); _ecbd != nil {
					return _ecbd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bodyPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bodyPr"}:
				if _ggdf := d.DecodeElement(_dagec.BodyPr, &_bfce); _ggdf != nil {
					return _ggdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lstStyle"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lstStyle"}:
				if _fadd := d.DecodeElement(_dagec.LstStyle, &_bfce); _fadd != nil {
					return _fadd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "style"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "style"}:
				_dagec.Style = NewCT_ShapeStyle()
				if _fdabf := d.DecodeElement(_dagec.Style, &_bfce); _fdabf != nil {
					return _fdabf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_dagec.ExtLst = NewCT_OfficeArtExtensionList()
				if _bbbff := d.DecodeElement(_dagec.ExtLst, &_bfce); _bbbff != nil {
					return _bbbff
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DefaultShapeDefinition\u0020\u0025v", _bfce.Name)
				if _cgbf := d.Skip(); _cgbf != nil {
					return _cgbf
				}
			}
		case _g.EndElement:
			break _daadd
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ThemeableLineStyle and its children, prefixing error messages with path
func (_ebcdd *CT_ThemeableLineStyle) ValidateWithPath(path string) error {
	if _ebcdd.Ln != nil {
		if _abbfg := _ebcdd.Ln.ValidateWithPath(path + "\u002fLn"); _abbfg != nil {
			return _abbfg
		}
	}
	if _ebcdd.LnRef != nil {
		if _egeaf := _ebcdd.LnRef.ValidateWithPath(path + "\u002fLnRef"); _egeaf != nil {
			return _egeaf
		}
	}
	return nil
}
func NewCT_DashStop() *CT_DashStop { _geeg := &CT_DashStop{}; return _geeg }
func (_gcdg *CT_BaseStylesOverride) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fge:
	for {
		_cbg, _dae := d.Token()
		if _dae != nil {
			return _dae
		}
		switch _efga := _cbg.(type) {
		case _g.StartElement:
			switch _efga.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrScheme"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrScheme"}:
				_gcdg.ClrScheme = NewCT_ColorScheme()
				if _dbgg := d.DecodeElement(_gcdg.ClrScheme, &_efga); _dbgg != nil {
					return _dbgg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fontScheme"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fontScheme"}:
				_gcdg.FontScheme = NewCT_FontScheme()
				if _bdce := d.DecodeElement(_gcdg.FontScheme, &_efga); _bdce != nil {
					return _bdce
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fmtScheme"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fmtScheme"}:
				_gcdg.FmtScheme = NewCT_StyleMatrix()
				if _dbcf := d.DecodeElement(_gcdg.FmtScheme, &_efga); _dbcf != nil {
					return _dbcf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_BaseStylesOverride\u0020\u0025v", _efga.Name)
				if _dacf := d.Skip(); _dacf != nil {
					return _dacf
				}
			}
		case _g.EndElement:
			break _fge
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_Backdrop() *CT_Backdrop {
	_cegb := &CT_Backdrop{}
	_cegb.Anchor = NewCT_Point3D()
	_cegb.Norm = NewCT_Vector3D()
	_cegb.Up = NewCT_Vector3D()
	return _cegb
}
func (_fgbfff *ST_SystemColorVal) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fgbfff = 0
	case "scrollBar":
		*_fgbfff = 1
	case "background":
		*_fgbfff = 2
	case "activeCaption":
		*_fgbfff = 3
	case "inactiveCaption":
		*_fgbfff = 4
	case "menu":
		*_fgbfff = 5
	case "window":
		*_fgbfff = 6
	case "windowFrame":
		*_fgbfff = 7
	case "menuText":
		*_fgbfff = 8
	case "windowText":
		*_fgbfff = 9
	case "captionText":
		*_fgbfff = 10
	case "activeBorder":
		*_fgbfff = 11
	case "inactiveBorder":
		*_fgbfff = 12
	case "appWorkspace":
		*_fgbfff = 13
	case "highlight":
		*_fgbfff = 14
	case "highlightText":
		*_fgbfff = 15
	case "btnFace":
		*_fgbfff = 16
	case "btnShadow":
		*_fgbfff = 17
	case "grayText":
		*_fgbfff = 18
	case "btnText":
		*_fgbfff = 19
	case "inactiveCaptionText":
		*_fgbfff = 20
	case "btnHighlight":
		*_fgbfff = 21
	case "3dDkShadow":
		*_fgbfff = 22
	case "3dLight":
		*_fgbfff = 23
	case "infoText":
		*_fgbfff = 24
	case "infoBk":
		*_fgbfff = 25
	case "hotLight":
		*_fgbfff = 26
	case "gradientActiveCaption":
		*_fgbfff = 27
	case "gradientInactiveCaption":
		*_fgbfff = 28
	case "menuHighlight":
		*_fgbfff = 29
	case "menuBar":
		*_fgbfff = 30
	}
	return nil
}

// Validate validates the CT_HslColor and its children
func (_eaafc *CT_HslColor) Validate() error { return _eaafc.ValidateWithPath("CT_HslColor") }
func (_bdaab *CT_SupplementalFont) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _afcga := range start.Attr {
		if _afcga.Name.Local == "script" {
			_cffed, _ggbf := _afcga.Value, error(nil)
			if _ggbf != nil {
				return _ggbf
			}
			_bdaab.ScriptAttr = _cffed
			continue
		}
		if _afcga.Name.Local == "typeface" {
			_ffde, _bcbgc := _afcga.Value, error(nil)
			if _bcbgc != nil {
				return _bcbgc
			}
			_bdaab.TypefaceAttr = _ffde
			continue
		}
	}
	for {
		_dgfca, _abcc := d.Token()
		if _abcc != nil {
			return _dcf.Errorf("parsing\u0020CT_SupplementalFont:\u0020\u0025s", _abcc)
		}
		if _cdfdc, _dcfgf := _dgfca.(_g.EndElement); _dcfgf && _cdfdc.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_FontScheme struct {
	NameAttr  string
	MajorFont *CT_FontCollection
	MinorFont *CT_FontCollection
	ExtLst    *CT_OfficeArtExtensionList
}

func ParseUnionST_AdjCoordinate(s string) (ST_AdjCoordinate, error) {
	_abecb := ST_AdjCoordinate{}
	if _f.ST_UniversalMeasurePatternRe.MatchString(s) {
		_abecb.ST_Coordinate = &ST_Coordinate{}
		_abecb.ST_Coordinate.ST_UniversalMeasure = &s
	} else {
		_gbffb, _fgfgd := _e.ParseInt(s, 10, 64)
		if _fgfgd != nil {
			_abecb.ST_GeomGuideName = &s
		} else {
			_abecb.ST_Coordinate = &ST_Coordinate{}
			_abecb.ST_Coordinate.ST_CoordinateUnqualified = &_gbffb
		}
	}
	return _abecb, nil
}
func (_ggaf *CT_GvmlPicture) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ggaf.NvPicPr = NewCT_GvmlPictureNonVisual()
	_ggaf.BlipFill = NewCT_BlipFillProperties()
	_ggaf.SpPr = NewCT_ShapeProperties()
_fbfc:
	for {
		_edaa, _cbagg := d.Token()
		if _cbagg != nil {
			return _cbagg
		}
		switch _afda := _edaa.(type) {
		case _g.StartElement:
			switch _afda.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "nvPicPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "nvPicPr"}:
				if _ggdag := d.DecodeElement(_ggaf.NvPicPr, &_afda); _ggdag != nil {
					return _ggdag
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				if _ffbec := d.DecodeElement(_ggaf.BlipFill, &_afda); _ffbec != nil {
					return _ffbec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spPr"}:
				if _cecda := d.DecodeElement(_ggaf.SpPr, &_afda); _cecda != nil {
					return _cecda
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "style"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "style"}:
				_ggaf.Style = NewCT_ShapeStyle()
				if _aefc := d.DecodeElement(_ggaf.Style, &_afda); _aefc != nil {
					return _aefc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_ggaf.ExtLst = NewCT_OfficeArtExtensionList()
				if _dace := d.DecodeElement(_ggaf.ExtLst, &_afda); _dace != nil {
					return _dace
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GvmlPicture\u0020\u0025v", _afda.Name)
				if _aggf := d.Skip(); _aggf != nil {
					return _aggf
				}
			}
		case _g.EndElement:
			break _fbfc
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_HslColor and its children, prefixing error messages with path
func (_fbbaef *CT_HslColor) ValidateWithPath(path string) error {
	if _fbbaef.HueAttr < 0 {
		return _dcf.Errorf("%s\u002fm\u002eHueAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _fbbaef.HueAttr)
	}
	if _fbbaef.HueAttr >= 21600000 {
		return _dcf.Errorf("\u0025s\u002fm\u002eHueAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, _fbbaef.HueAttr)
	}
	if _fbab := _fbbaef.SatAttr.ValidateWithPath(path + "\u002fSatAttr"); _fbab != nil {
		return _fbab
	}
	if _abgag := _fbbaef.LumAttr.ValidateWithPath(path + "\u002fLumAttr"); _abgag != nil {
		return _abgag
	}
	for _aeda, _geggb := range _fbbaef.EG_ColorTransform {
		if _ebgfc := _geggb.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fEG_ColorTransform\u005b\u0025d\u005d", path, _aeda)); _ebgfc != nil {
			return _ebgfc
		}
	}
	return nil
}

// ValidateWithPath validates the CT_AlphaModulateEffect and its children, prefixing error messages with path
func (_gcc *CT_AlphaModulateEffect) ValidateWithPath(path string) error {
	if _efc := _gcc.Cont.ValidateWithPath(path + "\u002fCont"); _efc != nil {
		return _efc
	}
	return nil
}

// Validate validates the CT_PolarAdjustHandle and its children
func (_ccfba *CT_PolarAdjustHandle) Validate() error {
	return _ccfba.ValidateWithPath("CT_PolarAdjustHandle")
}
func (_fgagga *ST_Percentage) ValidateWithPath(path string) error {
	_ecdgf := []string{}
	if _fgagga.ST_PercentageDecimal != nil {
		_ecdgf = append(_ecdgf, "ST_PercentageDecimal")
	}
	if _fgagga.ST_Percentage != nil {
		_ecdgf = append(_ecdgf, "ST_Percentage")
	}
	if len(_ecdgf) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _ecdgf)
	}
	return nil
}

type ST_PresetShadowVal byte

// ValidateWithPath validates the EG_EffectProperties and its children, prefixing error messages with path
func (_fgbbb *EG_EffectProperties) ValidateWithPath(path string) error {
	if _fgbbb.EffectLst != nil {
		if _aadab := _fgbbb.EffectLst.ValidateWithPath(path + "\u002fEffectLst"); _aadab != nil {
			return _aadab
		}
	}
	if _fgbbb.EffectDag != nil {
		if _feedee := _fgbbb.EffectDag.ValidateWithPath(path + "\u002fEffectDag"); _feedee != nil {
			return _feedee
		}
	}
	return nil
}
func ParseUnionST_OnOff(s string) (_f.ST_OnOff, error) { return _f.ST_OnOff{}, nil }

type ST_PathShadeType byte

func ParseUnionST_TextFontScalePercentOrPercentString(s string) (ST_TextFontScalePercentOrPercentString, error) {
	_bbgb := ST_TextFontScalePercentOrPercentString{}
	if _f.ST_PercentagePatternRe.MatchString(s) {
		_bbgb.ST_Percentage = &s
	} else {
		_aabeg, _bdbgd := _e.ParseInt(s, 10, 64)
		if _bdbgd != nil {
			return _bbgb, _dcf.Errorf("parsing\u0020\u0025s\u0020as\u0020int", _bdbgd)
		}
		_eeecb := int32(_aabeg)
		_bbgb.ST_TextFontScalePercent = &_eeecb
	}
	return _bbgb, nil
}
func (_acdbfb ST_PathShadeType) String() string {
	switch _acdbfb {
	case 0:
		return ""
	case 1:
		return "shape"
	case 2:
		return "circle"
	case 3:
		return "rect"
	}
	return ""
}
func (_ceeade *ST_EffectContainerType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_ceeade = 0
	case "sib":
		*_ceeade = 1
	case "tree":
		*_ceeade = 2
	}
	return nil
}

// Validate validates the CT_FontScheme and its children
func (_edef *CT_FontScheme) Validate() error { return _edef.ValidateWithPath("CT_FontScheme") }

// Validate validates the EG_TextBulletColor and its children
func (_ggbdg *EG_TextBulletColor) Validate() error {
	return _ggbdg.ValidateWithPath("EG_TextBulletColor")
}
func (_cface *CT_TextParagraphProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bgbdbe := range start.Attr {
		if _bgbdbe.Name.Local == "marL" {
			_cbcdb, _bccbbg := _e.ParseInt(_bgbdbe.Value, 10, 32)
			if _bccbbg != nil {
				return _bccbbg
			}
			_bgggb := int32(_cbcdb)
			_cface.MarLAttr = &_bgggb
			continue
		}
		if _bgbdbe.Name.Local == "lvl" {
			_ecafg, _gbfef := _e.ParseInt(_bgbdbe.Value, 10, 32)
			if _gbfef != nil {
				return _gbfef
			}
			_afffg := int32(_ecafg)
			_cface.LvlAttr = &_afffg
			continue
		}
		if _bgbdbe.Name.Local == "algn" {
			_cface.AlgnAttr.UnmarshalXMLAttr(_bgbdbe)
			continue
		}
		if _bgbdbe.Name.Local == "rtl" {
			_gggef, _bbffb := _e.ParseBool(_bgbdbe.Value)
			if _bbffb != nil {
				return _bbffb
			}
			_cface.RtlAttr = &_gggef
			continue
		}
		if _bgbdbe.Name.Local == "fontAlgn" {
			_cface.FontAlgnAttr.UnmarshalXMLAttr(_bgbdbe)
			continue
		}
		if _bgbdbe.Name.Local == "marR" {
			_ggfgfc, _cagdg := _e.ParseInt(_bgbdbe.Value, 10, 32)
			if _cagdg != nil {
				return _cagdg
			}
			_bbgdea := int32(_ggfgfc)
			_cface.MarRAttr = &_bbgdea
			continue
		}
		if _bgbdbe.Name.Local == "latinLnBrk" {
			_eecgbg, _ecgdc := _e.ParseBool(_bgbdbe.Value)
			if _ecgdc != nil {
				return _ecgdc
			}
			_cface.LatinLnBrkAttr = &_eecgbg
			continue
		}
		if _bgbdbe.Name.Local == "indent" {
			_gbgfe, _deefg := _e.ParseInt(_bgbdbe.Value, 10, 32)
			if _deefg != nil {
				return _deefg
			}
			_abaeg := int32(_gbgfe)
			_cface.IndentAttr = &_abaeg
			continue
		}
		if _bgbdbe.Name.Local == "eaLnBrk" {
			_ffcbe, _edaag := _e.ParseBool(_bgbdbe.Value)
			if _edaag != nil {
				return _edaag
			}
			_cface.EaLnBrkAttr = &_ffcbe
			continue
		}
		if _bgbdbe.Name.Local == "hangingPunct" {
			_aeegca, _eabeg := _e.ParseBool(_bgbdbe.Value)
			if _eabeg != nil {
				return _eabeg
			}
			_cface.HangingPunctAttr = &_aeegca
			continue
		}
		if _bgbdbe.Name.Local == "defTabSz" {
			_efggb, _fgbc := ParseUnionST_Coordinate32(_bgbdbe.Value)
			if _fgbc != nil {
				return _fgbc
			}
			_cface.DefTabSzAttr = &_efggb
			continue
		}
	}
_cffce:
	for {
		_ffabe, _dgcfgb := d.Token()
		if _dgcfgb != nil {
			return _dgcfgb
		}
		switch _dbgca := _ffabe.(type) {
		case _g.StartElement:
			switch _dbgca.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnSpc"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnSpc"}:
				_cface.LnSpc = NewCT_TextSpacing()
				if _cgade := d.DecodeElement(_cface.LnSpc, &_dbgca); _cgade != nil {
					return _cgade
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spcBef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spcBef"}:
				_cface.SpcBef = NewCT_TextSpacing()
				if _dcfbc := d.DecodeElement(_cface.SpcBef, &_dbgca); _dcfbc != nil {
					return _dcfbc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spcAft"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spcAft"}:
				_cface.SpcAft = NewCT_TextSpacing()
				if _becgb := d.DecodeElement(_cface.SpcAft, &_dbgca); _becgb != nil {
					return _becgb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buClrTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buClrTx"}:
				_cface.BuClrTx = NewCT_TextBulletColorFollowText()
				if _dfbca := d.DecodeElement(_cface.BuClrTx, &_dbgca); _dfbca != nil {
					return _dfbca
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buClr"}:
				_cface.BuClr = NewCT_Color()
				if _efbaf := d.DecodeElement(_cface.BuClr, &_dbgca); _efbaf != nil {
					return _efbaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buSzTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buSzTx"}:
				_cface.BuSzTx = NewCT_TextBulletSizeFollowText()
				if _feafaa := d.DecodeElement(_cface.BuSzTx, &_dbgca); _feafaa != nil {
					return _feafaa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buSzPct"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buSzPct"}:
				_cface.BuSzPct = NewCT_TextBulletSizePercent()
				if _abfg := d.DecodeElement(_cface.BuSzPct, &_dbgca); _abfg != nil {
					return _abfg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buSzPts"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buSzPts"}:
				_cface.BuSzPts = NewCT_TextBulletSizePoint()
				if _fcbgde := d.DecodeElement(_cface.BuSzPts, &_dbgca); _fcbgde != nil {
					return _fcbgde
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buFontTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buFontTx"}:
				_cface.BuFontTx = NewCT_TextBulletTypefaceFollowText()
				if _aecgg := d.DecodeElement(_cface.BuFontTx, &_dbgca); _aecgg != nil {
					return _aecgg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buFont"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buFont"}:
				_cface.BuFont = NewCT_TextFont()
				if _aeaed := d.DecodeElement(_cface.BuFont, &_dbgca); _aeaed != nil {
					return _aeaed
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buNone"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buNone"}:
				_cface.BuNone = NewCT_TextNoBullet()
				if _fcadb := d.DecodeElement(_cface.BuNone, &_dbgca); _fcadb != nil {
					return _fcadb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buAutoNum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buAutoNum"}:
				_cface.BuAutoNum = NewCT_TextAutonumberBullet()
				if _ccaaa := d.DecodeElement(_cface.BuAutoNum, &_dbgca); _ccaaa != nil {
					return _ccaaa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buChar"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buChar"}:
				_cface.BuChar = NewCT_TextCharBullet()
				if _decac := d.DecodeElement(_cface.BuChar, &_dbgca); _decac != nil {
					return _decac
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buBlip"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buBlip"}:
				_cface.BuBlip = NewCT_TextBlipBullet()
				if _efgadaa := d.DecodeElement(_cface.BuBlip, &_dbgca); _efgadaa != nil {
					return _efgadaa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tabLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tabLst"}:
				_cface.TabLst = NewCT_TextTabStopList()
				if _eabed := d.DecodeElement(_cface.TabLst, &_dbgca); _eabed != nil {
					return _eabed
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "defRPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "defRPr"}:
				_cface.DefRPr = NewCT_TextCharacterProperties()
				if _fdec := d.DecodeElement(_cface.DefRPr, &_dbgca); _fdec != nil {
					return _fdec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_cface.ExtLst = NewCT_OfficeArtExtensionList()
				if _ccdf := d.DecodeElement(_cface.ExtLst, &_dbgca); _ccdf != nil {
					return _ccdf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TextParagraphProperties\u0020\u0025v", _dbgca.Name)
				if _adefb := d.Skip(); _adefb != nil {
					return _adefb
				}
			}
		case _g.EndElement:
			break _cffce
		case _g.CharData:
		}
	}
	return nil
}
func (_egg *CT_AdjPoint2D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "x"}, Value: _dcf.Sprintf("\u0025v", _egg.XAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "y"}, Value: _dcf.Sprintf("\u0025v", _egg.YAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_GroupLocking() *CT_GroupLocking { _adee := &CT_GroupLocking{}; return _adee }

type CT_TableRow struct {
	HAttr  ST_Coordinate
	Tc     []*CT_TableCell
	ExtLst *CT_OfficeArtExtensionList
}

func (_agaa *CT_GammaTransform) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_PresetShadowEffect struct {
	PrstAttr  ST_PresetShadowVal
	DistAttr  *int64
	DirAttr   *int32
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
}

func (_bbgca ST_TextTabAlignType) Validate() error { return _bbgca.ValidateWithPath("") }

type ST_TextVertOverflowType byte

func (_cgcfd *CT_Transform2D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ddeef := range start.Attr {
		if _ddeef.Name.Local == "rot" {
			_bbaec, _gecc := _e.ParseInt(_ddeef.Value, 10, 32)
			if _gecc != nil {
				return _gecc
			}
			_ecefe := int32(_bbaec)
			_cgcfd.RotAttr = &_ecefe
			continue
		}
		if _ddeef.Name.Local == "flipH" {
			_egcfb, _abgae := _e.ParseBool(_ddeef.Value)
			if _abgae != nil {
				return _abgae
			}
			_cgcfd.FlipHAttr = &_egcfb
			continue
		}
		if _ddeef.Name.Local == "flipV" {
			_addef, _eaede := _e.ParseBool(_ddeef.Value)
			if _eaede != nil {
				return _eaede
			}
			_cgcfd.FlipVAttr = &_addef
			continue
		}
	}
_ecfceb:
	for {
		_bdeab, _gcffca := d.Token()
		if _gcffca != nil {
			return _gcffca
		}
		switch _fgfd := _bdeab.(type) {
		case _g.StartElement:
			switch _fgfd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "off"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "off"}:
				_cgcfd.Off = NewCT_Point2D()
				if _cdefg := d.DecodeElement(_cgcfd.Off, &_fgfd); _cdefg != nil {
					return _cdefg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ext"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ext"}:
				_cgcfd.Ext = NewCT_PositiveSize2D()
				if _gfccbd := d.DecodeElement(_cgcfd.Ext, &_fgfd); _gfccbd != nil {
					return _gfccbd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Transform2D\u0020\u0025v", _fgfd.Name)
				if _dgaac := d.Skip(); _dgaac != nil {
					return _dgaac
				}
			}
		case _g.EndElement:
			break _ecfceb
		case _g.CharData:
		}
	}
	return nil
}
func (_degf *CT_OfficeArtExtension) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "uri"}, Value: _dcf.Sprintf("\u0025v", _degf.UriAttr)})
	e.EncodeToken(start)
	if _degf.Any != nil {
		for _, _agdd := range _degf.Any {
			_agdd.MarshalXML(e, _g.StartElement{})
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_aggeg ST_ShapeType) ValidateWithPath(path string) error {
	switch _aggeg {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aggeg))
	}
	return nil
}

// ValidateWithPath validates the CT_TablePropertiesChoice and its children, prefixing error messages with path
func (_cbdbc *CT_TablePropertiesChoice) ValidateWithPath(path string) error {
	if _cbdbc.TableStyle != nil {
		if _adedc := _cbdbc.TableStyle.ValidateWithPath(path + "/TableStyle"); _adedc != nil {
			return _adedc
		}
	}
	if _cbdbc.TableStyleId != nil {
		if !_f.ST_GuidPatternRe.MatchString(*_cbdbc.TableStyleId) {
			return _dcf.Errorf("\u0025s\u002fm\u002eTableStyleId\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _f.ST_GuidPatternRe, *_cbdbc.TableStyleId)
		}
	}
	return nil
}
func NewCT_GroupTransform2D() *CT_GroupTransform2D { _gdbfd := &CT_GroupTransform2D{}; return _gdbfd }

// Validate validates the CT_AlphaModulateEffect and its children
func (_gaea *CT_AlphaModulateEffect) Validate() error {
	return _gaea.ValidateWithPath("CT_AlphaModulateEffect")
}

type EG_TextBullet struct {
	BuNone    *CT_TextNoBullet
	BuAutoNum *CT_TextAutonumberBullet
	BuChar    *CT_TextCharBullet
	BuBlip    *CT_TextBlipBullet
}

// Validate validates the CT_Headers and its children
func (_bebdd *CT_Headers) Validate() error { return _bebdd.ValidateWithPath("CT_Headers") }
func (_cfegb ST_FontCollectionIndex) String() string {
	switch _cfegb {
	case 0:
		return ""
	case 1:
		return "major"
	case 2:
		return "minor"
	case 3:
		return "none"
	}
	return ""
}

// Validate validates the CT_ColorScheme and its children
func (_dgfbf *CT_ColorScheme) Validate() error { return _dgfbf.ValidateWithPath("CT_ColorScheme") }

// ValidateWithPath validates the CT_EffectStyleItem and its children, prefixing error messages with path
func (_dfcf *CT_EffectStyleItem) ValidateWithPath(path string) error {
	if _dfcf.EffectLst != nil {
		if _egeg := _dfcf.EffectLst.ValidateWithPath(path + "\u002fEffectLst"); _egeg != nil {
			return _egeg
		}
	}
	if _dfcf.EffectDag != nil {
		if _befbf := _dfcf.EffectDag.ValidateWithPath(path + "\u002fEffectDag"); _befbf != nil {
			return _befbf
		}
	}
	if _dfcf.Scene3d != nil {
		if _effdg := _dfcf.Scene3d.ValidateWithPath(path + "\u002fScene3d"); _effdg != nil {
			return _effdg
		}
	}
	if _dfcf.Sp3d != nil {
		if _gcdf := _dfcf.Sp3d.ValidateWithPath(path + "\u002fSp3d"); _gcdf != nil {
			return _gcdf
		}
	}
	return nil
}
func ParseUnionST_PositiveFixedPercentage(s string) (ST_PositiveFixedPercentage, error) {
	_cdcbc := ST_PositiveFixedPercentage{}
	if _f.ST_PercentagePatternRe.MatchString(s) {
		_cdcbc.ST_PositiveFixedPercentage = &ST_Percentage{}
		_cdcbc.ST_PositiveFixedPercentage.ST_Percentage = &s
	} else {
		_eccacb, _ccaace := _e.ParseInt(s, 10, 64)
		if _ccaace != nil {
			return _cdcbc, _dcf.Errorf("parsing\u0020\u0025s\u0020as\u0020int", _ccaace)
		}
		_ceaec := int32(_eccacb)
		_cdcbc.ST_PositiveFixedPercentageDecimal = &_ceaec
	}
	return _cdcbc, nil
}
func NewCT_TableCell() *CT_TableCell { _ceead := &CT_TableCell{}; return _ceead }

// ValidateWithPath validates the CT_InverseTransform and its children, prefixing error messages with path
func (_egfda *CT_InverseTransform) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_AdjustHandleList and its children
func (_ddf *CT_AdjustHandleList) Validate() error {
	return _ddf.ValidateWithPath("CT_AdjustHandleList")
}
func (_afced *ST_BlendMode) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_afced = 0
	case "over":
		*_afced = 1
	case "mult":
		*_afced = 2
	case "screen":
		*_afced = 3
	case "darken":
		*_afced = 4
	case "lighten":
		*_afced = 5
	}
	return nil
}
func (_bfbgd ST_LineCap) ValidateWithPath(path string) error {
	switch _bfbgd {
	case 0, 1, 2, 3:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bfbgd))
	}
	return nil
}
func (_aabbb ST_FixedPercentage) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _aabbb.ST_FixedPercentageDecimal != nil {
		e.EncodeToken(_g.CharData(_dcf.Sprintf("\u0025d", *_aabbb.ST_FixedPercentageDecimal)))
	}
	if _aabbb.ST_FixedPercentage != nil {
		e.Encode(_aabbb.ST_FixedPercentage)
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

type CT_GvmlGroupShape struct {
	NvGrpSpPr *CT_GvmlGroupShapeNonVisual
	GrpSpPr   *CT_GroupShapeProperties
	Choice    []*CT_GvmlGroupShapeChoice
	ExtLst    *CT_OfficeArtExtensionList
}

// Validate validates the CT_GrayscaleTransform and its children
func (_ffdcf *CT_GrayscaleTransform) Validate() error {
	return _ffdcf.ValidateWithPath("CT_GrayscaleTransform")
}
func (_dgef *CT_AnimationGraphicalObjectBuildProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_ecfc:
	for {
		_edfc, _dfa := d.Token()
		if _dfa != nil {
			return _dfa
		}
		switch _gagg := _edfc.(type) {
		case _g.StartElement:
			switch _gagg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bldDgm"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bldDgm"}:
				_dgef.BldDgm = NewCT_AnimationDgmBuildProperties()
				if _gdbg := d.DecodeElement(_dgef.BldDgm, &_gagg); _gdbg != nil {
					return _gdbg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bldChart"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bldChart"}:
				_dgef.BldChart = NewCT_AnimationChartBuildProperties()
				if _beef := d.DecodeElement(_dgef.BldChart, &_gagg); _beef != nil {
					return _beef
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_AnimationGraphicalObjectBuildProperties\u0020\u0025v", _gagg.Name)
				if _dgcd := d.Skip(); _dgcd != nil {
					return _dgcd
				}
			}
		case _g.EndElement:
			break _ecfc
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the EG_ThemeableEffectStyle and its children
func (_aacaa *EG_ThemeableEffectStyle) Validate() error {
	return _aacaa.ValidateWithPath("EG_ThemeableEffectStyle")
}
func (_ddddf *CT_Blip) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _geaa := range start.Attr {
		if _geaa.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _geaa.Name.Local == "embed" {
			_gccea, _eeed := _geaa.Value, error(nil)
			if _eeed != nil {
				return _eeed
			}
			_ddddf.EmbedAttr = &_gccea
			continue
		}
		if _geaa.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _geaa.Name.Local == "link" {
			_bfga, _ggfc := _geaa.Value, error(nil)
			if _ggfc != nil {
				return _ggfc
			}
			_ddddf.LinkAttr = &_bfga
			continue
		}
		if _geaa.Name.Local == "cstate" {
			_ddddf.CstateAttr.UnmarshalXMLAttr(_geaa)
			continue
		}
	}
_adag:
	for {
		_dabe, _ccfe := d.Token()
		if _ccfe != nil {
			return _ccfe
		}
		switch _fadc := _dabe.(type) {
		case _g.StartElement:
			switch _fadc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaBiLevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaBiLevel"}:
				_dafdb := NewCT_BlipChoice()
				if _dbag := d.DecodeElement(&_dafdb.AlphaBiLevel, &_fadc); _dbag != nil {
					return _dbag
				}
				_ddddf.Choice = append(_ddddf.Choice, _dafdb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaCeiling"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaCeiling"}:
				_gdfb := NewCT_BlipChoice()
				if _adfc := d.DecodeElement(&_gdfb.AlphaCeiling, &_fadc); _adfc != nil {
					return _adfc
				}
				_ddddf.Choice = append(_ddddf.Choice, _gdfb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaFloor"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaFloor"}:
				_fdb := NewCT_BlipChoice()
				if _aage := d.DecodeElement(&_fdb.AlphaFloor, &_fadc); _aage != nil {
					return _aage
				}
				_ddddf.Choice = append(_ddddf.Choice, _fdb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaInv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaInv"}:
				_bdaf := NewCT_BlipChoice()
				if _dgd := d.DecodeElement(&_bdaf.AlphaInv, &_fadc); _dgd != nil {
					return _dgd
				}
				_ddddf.Choice = append(_ddddf.Choice, _bdaf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_fedc := NewCT_BlipChoice()
				if _bdaa := d.DecodeElement(&_fedc.AlphaMod, &_fadc); _bdaa != nil {
					return _bdaa
				}
				_ddddf.Choice = append(_ddddf.Choice, _fedc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaModFix"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaModFix"}:
				_fcdc := NewCT_BlipChoice()
				if _aba := d.DecodeElement(&_fcdc.AlphaModFix, &_fadc); _aba != nil {
					return _aba
				}
				_ddddf.Choice = append(_ddddf.Choice, _fcdc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaRepl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaRepl"}:
				_ecgg := NewCT_BlipChoice()
				if _aeeae := d.DecodeElement(&_ecgg.AlphaRepl, &_fadc); _aeeae != nil {
					return _aeeae
				}
				_ddddf.Choice = append(_ddddf.Choice, _ecgg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "biLevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "biLevel"}:
				_dfec := NewCT_BlipChoice()
				if _fgb := d.DecodeElement(&_dfec.BiLevel, &_fadc); _fgb != nil {
					return _fgb
				}
				_ddddf.Choice = append(_ddddf.Choice, _dfec)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blur"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blur"}:
				_cagg := NewCT_BlipChoice()
				if _eeg := d.DecodeElement(&_cagg.Blur, &_fadc); _eeg != nil {
					return _eeg
				}
				_ddddf.Choice = append(_ddddf.Choice, _cagg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrChange"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrChange"}:
				_daad := NewCT_BlipChoice()
				if _gddd := d.DecodeElement(&_daad.ClrChange, &_fadc); _gddd != nil {
					return _gddd
				}
				_ddddf.Choice = append(_ddddf.Choice, _daad)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrRepl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrRepl"}:
				_cbae := NewCT_BlipChoice()
				if _edee := d.DecodeElement(&_cbae.ClrRepl, &_fadc); _edee != nil {
					return _edee
				}
				_ddddf.Choice = append(_ddddf.Choice, _cbae)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "duotone"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "duotone"}:
				_gddf := NewCT_BlipChoice()
				if _ddbf := d.DecodeElement(&_gddf.Duotone, &_fadc); _ddbf != nil {
					return _ddbf
				}
				_ddddf.Choice = append(_ddddf.Choice, _gddf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillOverlay"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillOverlay"}:
				_gdc := NewCT_BlipChoice()
				if _bag := d.DecodeElement(&_gdc.FillOverlay, &_fadc); _bag != nil {
					return _bag
				}
				_ddddf.Choice = append(_ddddf.Choice, _gdc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grayscl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grayscl"}:
				_cbad := NewCT_BlipChoice()
				if _gfff := d.DecodeElement(&_cbad.Grayscl, &_fadc); _gfff != nil {
					return _gfff
				}
				_ddddf.Choice = append(_ddddf.Choice, _cbad)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hsl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hsl"}:
				_bace := NewCT_BlipChoice()
				if _cded := d.DecodeElement(&_bace.Hsl, &_fadc); _cded != nil {
					return _cded
				}
				_ddddf.Choice = append(_ddddf.Choice, _bace)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_bffbd := NewCT_BlipChoice()
				if _fbce := d.DecodeElement(&_bffbd.Lum, &_fadc); _fbce != nil {
					return _fbce
				}
				_ddddf.Choice = append(_ddddf.Choice, _bffbd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_bdbd := NewCT_BlipChoice()
				if _aced := d.DecodeElement(&_bdbd.Tint, &_fadc); _aced != nil {
					return _aced
				}
				_ddddf.Choice = append(_ddddf.Choice, _bdbd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_ddddf.ExtLst = NewCT_OfficeArtExtensionList()
				if _fbda := d.DecodeElement(_ddddf.ExtLst, &_fadc); _fbda != nil {
					return _fbda
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Blip\u0020\u0025v", _fadc.Name)
				if _bbbe := d.Skip(); _bbbe != nil {
					return _bbbe
				}
			}
		case _g.EndElement:
			break _adag
		case _g.CharData:
		}
	}
	return nil
}
func (_ggcgb ST_AnimationDgmBuildType) String() string {
	if _ggcgb.ST_AnimationBuildType != ST_AnimationBuildTypeUnset {
		return _ggcgb.ST_AnimationBuildType.String()
	}
	if _ggcgb.ST_AnimationDgmOnlyBuildType != ST_AnimationDgmOnlyBuildTypeUnset {
		return _ggcgb.ST_AnimationDgmOnlyBuildType.String()
	}
	return ""
}

// Validate validates the CT_ThemeableLineStyle and its children
func (_cebcf *CT_ThemeableLineStyle) Validate() error {
	return _cebcf.ValidateWithPath("CT_ThemeableLineStyle")
}

// Validate validates the CT_GvmlGraphicFrameNonVisual and its children
func (_abada *CT_GvmlGraphicFrameNonVisual) Validate() error {
	return _abada.ValidateWithPath("CT_GvmlGraphicFrameNonVisual")
}
func (_fbgbge *CT_PatternFillProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fbgbge.PrstAttr != ST_PresetPatternValUnset {
		_ecbdg, _fcegd := _fbgbge.PrstAttr.MarshalXMLAttr(_g.Name{Local: "prst"})
		if _fcegd != nil {
			return _fcegd
		}
		start.Attr = append(start.Attr, _ecbdg)
	}
	e.EncodeToken(start)
	if _fbgbge.FgClr != nil {
		_fggfd := _g.StartElement{Name: _g.Name{Local: "a:fgClr"}}
		e.EncodeElement(_fbgbge.FgClr, _fggfd)
	}
	if _fbgbge.BgClr != nil {
		_bgdbb := _g.StartElement{Name: _g.Name{Local: "a:bgClr"}}
		e.EncodeElement(_fbgbge.BgClr, _bgdbb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_GrayscaleTransform() *CT_GrayscaleTransform {
	_cabf := &CT_GrayscaleTransform{}
	return _cabf
}

type CT_ColorMapping struct {
	Bg1Attr      ST_ColorSchemeIndex
	Tx1Attr      ST_ColorSchemeIndex
	Bg2Attr      ST_ColorSchemeIndex
	Tx2Attr      ST_ColorSchemeIndex
	Accent1Attr  ST_ColorSchemeIndex
	Accent2Attr  ST_ColorSchemeIndex
	Accent3Attr  ST_ColorSchemeIndex
	Accent4Attr  ST_ColorSchemeIndex
	Accent5Attr  ST_ColorSchemeIndex
	Accent6Attr  ST_ColorSchemeIndex
	HlinkAttr    ST_ColorSchemeIndex
	FolHlinkAttr ST_ColorSchemeIndex
	ExtLst       *CT_OfficeArtExtensionList
}

func (_dgegf ST_TextPoint) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _dgegf.ST_TextPointUnqualified != nil {
		e.EncodeToken(_g.CharData(_dcf.Sprintf("\u0025d", *_dgegf.ST_TextPointUnqualified)))
	}
	if _dgegf.ST_UniversalMeasure != nil {
		e.EncodeToken(_g.CharData(*_dgegf.ST_UniversalMeasure))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

// ValidateWithPath validates the CT_GvmlConnector and its children, prefixing error messages with path
func (_dbaa *CT_GvmlConnector) ValidateWithPath(path string) error {
	if _bbebc := _dbaa.NvCxnSpPr.ValidateWithPath(path + "\u002fNvCxnSpPr"); _bbebc != nil {
		return _bbebc
	}
	if _bfbf := _dbaa.SpPr.ValidateWithPath(path + "\u002fSpPr"); _bfbf != nil {
		return _bfbf
	}
	if _dbaa.Style != nil {
		if _bccag := _dbaa.Style.ValidateWithPath(path + "\u002fStyle"); _bccag != nil {
			return _bccag
		}
	}
	if _dbaa.ExtLst != nil {
		if _ffgd := _dbaa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ffgd != nil {
			return _ffgd
		}
	}
	return nil
}
func (_fdgg *CT_DuotoneEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_cefe:
	for {
		_aaae, _egffaa := d.Token()
		if _egffaa != nil {
			return _egffaa
		}
		switch _ffdc := _aaae.(type) {
		case _g.StartElement:
			switch _ffdc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_cdccd := NewEG_ColorChoice()
				_cdccd.ScrgbClr = NewCT_ScRgbColor()
				if _bbgg := d.DecodeElement(_cdccd.ScrgbClr, &_ffdc); _bbgg != nil {
					return _bbgg
				}
				_fdgg.EG_ColorChoice = append(_fdgg.EG_ColorChoice, _cdccd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_bgcdg := NewEG_ColorChoice()
				_bgcdg.SrgbClr = NewCT_SRgbColor()
				if _fabfc := d.DecodeElement(_bgcdg.SrgbClr, &_ffdc); _fabfc != nil {
					return _fabfc
				}
				_fdgg.EG_ColorChoice = append(_fdgg.EG_ColorChoice, _bgcdg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_egfd := NewEG_ColorChoice()
				_egfd.HslClr = NewCT_HslColor()
				if _cdce := d.DecodeElement(_egfd.HslClr, &_ffdc); _cdce != nil {
					return _cdce
				}
				_fdgg.EG_ColorChoice = append(_fdgg.EG_ColorChoice, _egfd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_cgcg := NewEG_ColorChoice()
				_cgcg.SysClr = NewCT_SystemColor()
				if _bacfe := d.DecodeElement(_cgcg.SysClr, &_ffdc); _bacfe != nil {
					return _bacfe
				}
				_fdgg.EG_ColorChoice = append(_fdgg.EG_ColorChoice, _cgcg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_dcee := NewEG_ColorChoice()
				_dcee.SchemeClr = NewCT_SchemeColor()
				if _agcf := d.DecodeElement(_dcee.SchemeClr, &_ffdc); _agcf != nil {
					return _agcf
				}
				_fdgg.EG_ColorChoice = append(_fdgg.EG_ColorChoice, _dcee)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_ggag := NewEG_ColorChoice()
				_ggag.PrstClr = NewCT_PresetColor()
				if _bddag := d.DecodeElement(_ggag.PrstClr, &_ffdc); _bddag != nil {
					return _bddag
				}
				_fdgg.EG_ColorChoice = append(_fdgg.EG_ColorChoice, _ggag)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DuotoneEffect\u0020\u0025v", _ffdc.Name)
				if _bfdgb := d.Skip(); _bfdgb != nil {
					return _bfdgb
				}
			}
		case _g.EndElement:
			break _cefe
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TableBackgroundStyle and its children, prefixing error messages with path
func (_adfgd *CT_TableBackgroundStyle) ValidateWithPath(path string) error {
	if _adfgd.Fill != nil {
		if _gbbce := _adfgd.Fill.ValidateWithPath(path + "\u002fFill"); _gbbce != nil {
			return _gbbce
		}
	}
	if _adfgd.FillRef != nil {
		if _dagbd := _adfgd.FillRef.ValidateWithPath(path + "\u002fFillRef"); _dagbd != nil {
			return _dagbd
		}
	}
	if _adfgd.Effect != nil {
		if _ecdg := _adfgd.Effect.ValidateWithPath(path + "\u002fEffect"); _ecdg != nil {
			return _ecdg
		}
	}
	if _adfgd.EffectRef != nil {
		if _eccab := _adfgd.EffectRef.ValidateWithPath(path + "\u002fEffectRef"); _eccab != nil {
			return _eccab
		}
	}
	return nil
}

type CT_GradientStop struct {
	PosAttr   ST_PositiveFixedPercentage
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
}

// Validate validates the CT_NonVisualContentPartProperties and its children
func (_gcgbc *CT_NonVisualContentPartProperties) Validate() error {
	return _gcgbc.ValidateWithPath("CT_NonVisualContentPartProperties")
}
func (_dageb ST_TextWrappingType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ffecd := _g.Attr{}
	_ffecd.Name = name
	switch _dageb {
	case ST_TextWrappingTypeUnset:
		_ffecd.Value = ""
	case ST_TextWrappingTypeNone:
		_ffecd.Value = "none"
	case ST_TextWrappingTypeSquare:
		_ffecd.Value = "square"
	}
	return _ffecd, nil
}

type CT_QuickTimeFile struct {
	LinkAttr string
	ExtLst   *CT_OfficeArtExtensionList
}

func (_ffgad ST_PresetMaterialType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ffgad.String(), start)
}
func (_be *CT_AlphaModulateFixedEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _be.AmtAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "amt"}, Value: _dcf.Sprintf("\u0025v", *_be.AmtAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_InverseTransform and its children
func (_eeee *CT_InverseTransform) Validate() error {
	return _eeee.ValidateWithPath("CT_InverseTransform")
}
func (_baade ST_TextWrappingType) String() string {
	switch _baade {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "square"
	}
	return ""
}
func (_aaedf *VideoFile) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "a:videoFile"
	return _aaedf.CT_VideoFile.MarshalXML(e, start)
}
func (_dbdgg ST_ChartBuildStep) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_dbdgg.String(), start)
}

type CT_PatternFillProperties struct {
	PrstAttr ST_PresetPatternVal
	FgClr    *CT_Color
	BgClr    *CT_Color
}

func ParseUnionST_AnimationChartBuildType(s string) (ST_AnimationChartBuildType, error) {
	_gfbdb := ST_AnimationChartBuildType{}
	switch s {
	case "allAtOnce":
		_gfbdb.ST_AnimationBuildType = ST_AnimationBuildTypeAllAtOnce
	case "series":
		_gfbdb.ST_AnimationChartOnlyBuildType = ST_AnimationChartOnlyBuildTypeSeries
	case "category":
		_gfbdb.ST_AnimationChartOnlyBuildType = ST_AnimationChartOnlyBuildTypeCategory
	case "seriesEl":
		_gfbdb.ST_AnimationChartOnlyBuildType = ST_AnimationChartOnlyBuildTypeSeriesEl
	case "categoryEl":
		_gfbdb.ST_AnimationChartOnlyBuildType = ST_AnimationChartOnlyBuildTypeCategoryEl
	}
	return _gfbdb, nil
}
func NewCT_PositiveSize2D() *CT_PositiveSize2D {
	_bdfcg := &CT_PositiveSize2D{}
	_bdfcg.CxAttr = 0
	_bdfcg.CyAttr = 0
	return _bdfcg
}
func (_gggfe ST_BlendMode) String() string {
	switch _gggfe {
	case 0:
		return ""
	case 1:
		return "over"
	case 2:
		return "mult"
	case 3:
		return "screen"
	case 4:
		return "darken"
	case 5:
		return "lighten"
	}
	return ""
}
func (_daga *CT_LineJoinMiterProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bcfba := range start.Attr {
		if _bcfba.Name.Local == "lim" {
			_ccfce, _afbaa := ParseUnionST_PositivePercentage(_bcfba.Value)
			if _afbaa != nil {
				return _afbaa
			}
			_daga.LimAttr = &_ccfce
			continue
		}
	}
	for {
		_fbfdf, _feae := d.Token()
		if _feae != nil {
			return _dcf.Errorf("parsing\u0020CT_LineJoinMiterProperties:\u0020\u0025s", _feae)
		}
		if _eecdc, _ffcg := _fbfdf.(_g.EndElement); _ffcg && _eecdc.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_ColorSchemeList and its children
func (_bgfa *CT_ColorSchemeList) Validate() error {
	return _bgfa.ValidateWithPath("CT_ColorSchemeList")
}

// Validate validates the CT_ColorChangeEffect and its children
func (_dgfc *CT_ColorChangeEffect) Validate() error {
	return _dgfc.ValidateWithPath("CT_ColorChangeEffect")
}
func (_gfbb *CT_CustomColor) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _eeec := range start.Attr {
		if _eeec.Name.Local == "name" {
			_ecbb, _gabee := _eeec.Value, error(nil)
			if _gabee != nil {
				return _gabee
			}
			_gfbb.NameAttr = &_ecbb
			continue
		}
	}
_baad:
	for {
		_fga, _bbaa := d.Token()
		if _bbaa != nil {
			return _bbaa
		}
		switch _gaac := _fga.(type) {
		case _g.StartElement:
			switch _gaac.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_gfbb.ScrgbClr = NewCT_ScRgbColor()
				if _eaag := d.DecodeElement(_gfbb.ScrgbClr, &_gaac); _eaag != nil {
					return _eaag
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_gfbb.SrgbClr = NewCT_SRgbColor()
				if _cbff := d.DecodeElement(_gfbb.SrgbClr, &_gaac); _cbff != nil {
					return _cbff
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_gfbb.HslClr = NewCT_HslColor()
				if _ebab := d.DecodeElement(_gfbb.HslClr, &_gaac); _ebab != nil {
					return _ebab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_gfbb.SysClr = NewCT_SystemColor()
				if _ebece := d.DecodeElement(_gfbb.SysClr, &_gaac); _ebece != nil {
					return _ebece
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_gfbb.SchemeClr = NewCT_SchemeColor()
				if _bcfd := d.DecodeElement(_gfbb.SchemeClr, &_gaac); _bcfd != nil {
					return _bcfd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_gfbb.PrstClr = NewCT_PresetColor()
				if _cacb := d.DecodeElement(_gfbb.PrstClr, &_gaac); _cacb != nil {
					return _cacb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CustomColor\u0020\u0025v", _gaac.Name)
				if _dagb := d.Skip(); _dagb != nil {
					return _dagb
				}
			}
		case _g.EndElement:
			break _baad
		case _g.CharData:
		}
	}
	return nil
}

type EG_TextBulletSize struct {
	BuSzTx  *CT_TextBulletSizeFollowText
	BuSzPct *CT_TextBulletSizePercent
	BuSzPts *CT_TextBulletSizePoint
}

func (_cggec ST_PresetShadowVal) String() string {
	switch _cggec {
	case 0:
		return ""
	case 1:
		return "shdw1"
	case 2:
		return "shdw2"
	case 3:
		return "shdw3"
	case 4:
		return "shdw4"
	case 5:
		return "shdw5"
	case 6:
		return "shdw6"
	case 7:
		return "shdw7"
	case 8:
		return "shdw8"
	case 9:
		return "shdw9"
	case 10:
		return "shdw10"
	case 11:
		return "shdw11"
	case 12:
		return "shdw12"
	case 13:
		return "shdw13"
	case 14:
		return "shdw14"
	case 15:
		return "shdw15"
	case 16:
		return "shdw16"
	case 17:
		return "shdw17"
	case 18:
		return "shdw18"
	case 19:
		return "shdw19"
	case 20:
		return "shdw20"
	}
	return ""
}

type ST_ShapeType byte
type CT_TableStyleCellStyle struct {
	TcBdr   *CT_TableCellBorderStyle
	Fill    *CT_FillProperties
	FillRef *CT_StyleMatrixReference
	Cell3D  *CT_Cell3D
}
type CT_GvmlPicture struct {
	NvPicPr  *CT_GvmlPictureNonVisual
	BlipFill *CT_BlipFillProperties
	SpPr     *CT_ShapeProperties
	Style    *CT_ShapeStyle
	ExtLst   *CT_OfficeArtExtensionList
}
type EG_OfficeArtExtensionList struct{ Ext []*CT_OfficeArtExtension }
type CT_StyleMatrixReference struct {
	IdxAttr   uint32
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
}

// Validate validates the CT_NonVisualConnectorProperties and its children
func (_cabgd *CT_NonVisualConnectorProperties) Validate() error {
	return _cabgd.ValidateWithPath("CT_NonVisualConnectorProperties")
}
func (_cdddc ST_TextVerticalType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cdddc.String(), start)
}
func NewCT_Path2DQuadBezierTo() *CT_Path2DQuadBezierTo {
	_gfdg := &CT_Path2DQuadBezierTo{}
	return _gfdg
}
func ParseUnionST_Percentage(s string) (ST_Percentage, error) {
	_fadga := ST_Percentage{}
	if _f.ST_PercentagePatternRe.MatchString(s) {
		_fadga.ST_Percentage = &s
	} else {
		_geffg, _abcfef := _e.ParseInt(s, 10, 64)
		if _abcfef != nil {
			return _fadga, _dcf.Errorf("parsing\u0020\u0025s\u0020as\u0020int", _abcfef)
		}
		_gdcea := int32(_geffg)
		_fadga.ST_PercentageDecimal = &_gdcea
	}
	return _fadga, nil
}

type CT_GradientStopList struct{ Gs []*CT_GradientStop }

func (_eea *CT_AlphaOutsetEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _eea.RadAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rad"}, Value: _dcf.Sprintf("\u0025v", *_eea.RadAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_NonVisualGraphicFrameProperties() *CT_NonVisualGraphicFrameProperties {
	_fcebda := &CT_NonVisualGraphicFrameProperties{}
	return _fcebda
}

// Validate validates the CT_SchemeColor and its children
func (_cecc *CT_SchemeColor) Validate() error { return _cecc.ValidateWithPath("CT_SchemeColor") }

type CT_StretchInfoProperties struct{ FillRect *CT_RelativeRect }
type CT_BackgroundFillStyleList struct{ EG_FillProperties []*EG_FillProperties }
type CT_Percentage struct{ ValAttr ST_Percentage }

func (_cdgg *CT_Point3D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _cgdb := range start.Attr {
		if _cgdb.Name.Local == "x" {
			_ccagc, _fbfg := ParseUnionST_Coordinate(_cgdb.Value)
			if _fbfg != nil {
				return _fbfg
			}
			_cdgg.XAttr = _ccagc
			continue
		}
		if _cgdb.Name.Local == "y" {
			_eeeec, _deeb := ParseUnionST_Coordinate(_cgdb.Value)
			if _deeb != nil {
				return _deeb
			}
			_cdgg.YAttr = _eeeec
			continue
		}
		if _cgdb.Name.Local == "z" {
			_eface, _faccg := ParseUnionST_Coordinate(_cgdb.Value)
			if _faccg != nil {
				return _faccg
			}
			_cdgg.ZAttr = _eface
			continue
		}
	}
	for {
		_gbfgc, _egbfe := d.Token()
		if _egbfe != nil {
			return _dcf.Errorf("parsing\u0020CT_Point3D:\u0020%s", _egbfe)
		}
		if _faaba, _fecb := _gbfgc.(_g.EndElement); _fecb && _faaba.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gcagf ST_TextStrikeType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_gcagf.String(), start)
}

const (
	ST_PresetShadowValUnset  ST_PresetShadowVal = 0
	ST_PresetShadowValShdw1  ST_PresetShadowVal = 1
	ST_PresetShadowValShdw2  ST_PresetShadowVal = 2
	ST_PresetShadowValShdw3  ST_PresetShadowVal = 3
	ST_PresetShadowValShdw4  ST_PresetShadowVal = 4
	ST_PresetShadowValShdw5  ST_PresetShadowVal = 5
	ST_PresetShadowValShdw6  ST_PresetShadowVal = 6
	ST_PresetShadowValShdw7  ST_PresetShadowVal = 7
	ST_PresetShadowValShdw8  ST_PresetShadowVal = 8
	ST_PresetShadowValShdw9  ST_PresetShadowVal = 9
	ST_PresetShadowValShdw10 ST_PresetShadowVal = 10
	ST_PresetShadowValShdw11 ST_PresetShadowVal = 11
	ST_PresetShadowValShdw12 ST_PresetShadowVal = 12
	ST_PresetShadowValShdw13 ST_PresetShadowVal = 13
	ST_PresetShadowValShdw14 ST_PresetShadowVal = 14
	ST_PresetShadowValShdw15 ST_PresetShadowVal = 15
	ST_PresetShadowValShdw16 ST_PresetShadowVal = 16
	ST_PresetShadowValShdw17 ST_PresetShadowVal = 17
	ST_PresetShadowValShdw18 ST_PresetShadowVal = 18
	ST_PresetShadowValShdw19 ST_PresetShadowVal = 19
	ST_PresetShadowValShdw20 ST_PresetShadowVal = 20
)

// Validate validates the CT_EffectStyleList and its children
func (_cbba *CT_EffectStyleList) Validate() error {
	return _cbba.ValidateWithPath("CT_EffectStyleList")
}

type CT_TableStyle struct {
	StyleIdAttr   string
	StyleNameAttr string
	TblBg         *CT_TableBackgroundStyle
	WholeTbl      *CT_TablePartStyle
	Band1H        *CT_TablePartStyle
	Band2H        *CT_TablePartStyle
	Band1V        *CT_TablePartStyle
	Band2V        *CT_TablePartStyle
	LastCol       *CT_TablePartStyle
	FirstCol      *CT_TablePartStyle
	LastRow       *CT_TablePartStyle
	SeCell        *CT_TablePartStyle
	SwCell        *CT_TablePartStyle
	FirstRow      *CT_TablePartStyle
	NeCell        *CT_TablePartStyle
	NwCell        *CT_TablePartStyle
	ExtLst        *CT_OfficeArtExtensionList
}

func NewCT_ConnectionSiteList() *CT_ConnectionSiteList {
	_dafbe := &CT_ConnectionSiteList{}
	return _dafbe
}
func (_gaeec *EG_TextGeometry) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_dabec:
	for {
		_bbdf, _baage := d.Token()
		if _baage != nil {
			return _baage
		}
		switch _baeec := _bbdf.(type) {
		case _g.StartElement:
			switch _baeec.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "custGeom"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "custGeom"}:
				_gaeec.CustGeom = NewCT_CustomGeometry2D()
				if _dbfdbd := d.DecodeElement(_gaeec.CustGeom, &_baeec); _dbfdbd != nil {
					return _dbfdbd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstTxWarp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstTxWarp"}:
				_gaeec.PrstTxWarp = NewCT_PresetTextShape()
				if _ecdfg := d.DecodeElement(_gaeec.PrstTxWarp, &_baeec); _ecdfg != nil {
					return _ecdfg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_TextGeometry\u0020\u0025v", _baeec.Name)
				if _dgcee := d.Skip(); _dgcee != nil {
					return _dgcee
				}
			}
		case _g.EndElement:
			break _dabec
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_CustomGeometry2D and its children
func (_ceab *CT_CustomGeometry2D) Validate() error {
	return _ceab.ValidateWithPath("CT_CustomGeometry2D")
}

type CT_TextCharacterProperties struct {
	KumimojiAttr   *bool
	LangAttr       *string
	AltLangAttr    *string
	SzAttr         *int32
	BAttr          *bool
	IAttr          *bool
	UAttr          ST_TextUnderlineType
	StrikeAttr     ST_TextStrikeType
	KernAttr       *int32
	CapAttr        ST_TextCapsType
	SpcAttr        *ST_TextPoint
	NormalizeHAttr *bool
	BaselineAttr   *ST_Percentage
	NoProofAttr    *bool
	DirtyAttr      *bool
	ErrAttr        *bool
	SmtCleanAttr   *bool
	SmtIdAttr      *uint32
	BmkAttr        *string
	Ln             *CT_LineProperties
	NoFill         *CT_NoFillProperties
	SolidFill      *CT_SolidColorFillProperties
	GradFill       *CT_GradientFillProperties
	BlipFill       *CT_BlipFillProperties
	PattFill       *CT_PatternFillProperties
	GrpFill        *CT_GroupFillProperties
	EffectLst      *CT_EffectList
	EffectDag      *CT_EffectContainer
	Highlight      *CT_Color
	ULnTx          *CT_TextUnderlineLineFollowText
	ULn            *CT_LineProperties
	UFillTx        *CT_TextUnderlineFillFollowText
	UFill          *CT_TextUnderlineFillGroupWrapper
	Latin          *CT_TextFont
	Ea             *CT_TextFont
	Cs             *CT_TextFont
	Sym            *CT_TextFont
	HlinkClick     *CT_Hyperlink
	HlinkMouseOver *CT_Hyperlink
	Rtl            *CT_Boolean
	ExtLst         *CT_OfficeArtExtensionList
}

func (_daba *CT_EffectProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_cfac:
	for {
		_bgbe, _aacd := d.Token()
		if _aacd != nil {
			return _aacd
		}
		switch _dgfa := _bgbe.(type) {
		case _g.StartElement:
			switch _dgfa.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectLst"}:
				_daba.EffectLst = NewCT_EffectList()
				if _fbdab := d.DecodeElement(_daba.EffectLst, &_dgfa); _fbdab != nil {
					return _fbdab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectDag"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectDag"}:
				_daba.EffectDag = NewCT_EffectContainer()
				if _dcefg := d.DecodeElement(_daba.EffectDag, &_dgfa); _dcefg != nil {
					return _dcefg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_EffectProperties\u0020\u0025v", _dgfa.Name)
				if _dfad := d.Skip(); _dfad != nil {
					return _dfad
				}
			}
		case _g.EndElement:
			break _cfac
		case _g.CharData:
		}
	}
	return nil
}

type CT_Path2DQuadBezierTo struct{ Pt []*CT_AdjPoint2D }

// Validate validates the CT_GradientStopList and its children
func (_bede *CT_GradientStopList) Validate() error {
	return _bede.ValidateWithPath("CT_GradientStopList")
}
func (_bdcab *CT_GvmlPictureNonVisual) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bdcab.CNvPr = NewCT_NonVisualDrawingProps()
	_bdcab.CNvPicPr = NewCT_NonVisualPictureProperties()
_bgaa:
	for {
		_ecca, _feac := d.Token()
		if _feac != nil {
			return _feac
		}
		switch _dbcgb := _ecca.(type) {
		case _g.StartElement:
			switch _dbcgb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cNvPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cNvPr"}:
				if _fbbgd := d.DecodeElement(_bdcab.CNvPr, &_dbcgb); _fbbgd != nil {
					return _fbbgd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cNvPicPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cNvPicPr"}:
				if _gbfgd := d.DecodeElement(_bdcab.CNvPicPr, &_dbcgb); _gbfgd != nil {
					return _gbfgd
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_GvmlPictureNonVisual \u0025v", _dbcgb.Name)
				if _aefcb := d.Skip(); _aefcb != nil {
					return _aefcb
				}
			}
		case _g.EndElement:
			break _bgaa
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_NonVisualDrawingShapeProps and its children
func (_gbefc *CT_NonVisualDrawingShapeProps) Validate() error {
	return _gbefc.ValidateWithPath("CT_NonVisualDrawingShapeProps")
}
func (_ecfd *CT_GraphicalObjectData) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "uri"}, Value: _dcf.Sprintf("\u0025v", _ecfd.UriAttr)})
	e.EncodeToken(start)
	if _ecfd.Any != nil {
		for _, _edad := range _ecfd.Any {
			_edad.MarshalXML(e, _g.StartElement{})
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_Blip() *CT_Blip                   { _gff := &CT_Blip{}; return _gff }
func NewCT_TextLineBreak() *CT_TextLineBreak { _eeaec := &CT_TextLineBreak{}; return _eeaec }
func (_cabcc ST_DgmBuildStep) String() string {
	switch _cabcc {
	case 0:
		return ""
	case 1:
		return "sp"
	case 2:
		return "bg"
	}
	return ""
}
func (_adacc *CT_VideoFile) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r:link"}, Value: _dcf.Sprintf("\u0025v", _adacc.LinkAttr)})
	if _adacc.ContentTypeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "contentType"}, Value: _dcf.Sprintf("\u0025v", *_adacc.ContentTypeAttr)})
	}
	e.EncodeToken(start)
	if _adacc.ExtLst != nil {
		_dgbdb := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_adacc.ExtLst, _dgbdb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_PositivePercentage and its children
func (_acdgc *CT_PositivePercentage) Validate() error {
	return _acdgc.ValidateWithPath("CT_PositivePercentage")
}
func (_cccg *CT_ConnectionSite) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "ang"}, Value: _dcf.Sprintf("\u0025v", _cccg.AngAttr)})
	e.EncodeToken(start)
	_afaa := _g.StartElement{Name: _g.Name{Local: "a:pos"}}
	e.EncodeElement(_cccg.Pos, _afaa)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_GvmlGroupShapeChoice() *CT_GvmlGroupShapeChoice {
	_fdcef := &CT_GvmlGroupShapeChoice{}
	return _fdcef
}

// Validate validates the CT_SphereCoords and its children
func (_gdabd *CT_SphereCoords) Validate() error  { return _gdabd.ValidateWithPath("CT_SphereCoords") }
func NewCT_EffectContainer() *CT_EffectContainer { _gbda := &CT_EffectContainer{}; return _gbda }

// ValidateWithPath validates the CT_ColorScheme and its children, prefixing error messages with path
func (_ecfce *CT_ColorScheme) ValidateWithPath(path string) error {
	if _gfde := _ecfce.Dk1.ValidateWithPath(path + "\u002fDk1"); _gfde != nil {
		return _gfde
	}
	if _dgdcf := _ecfce.Lt1.ValidateWithPath(path + "\u002fLt1"); _dgdcf != nil {
		return _dgdcf
	}
	if _ccdg := _ecfce.Dk2.ValidateWithPath(path + "\u002fDk2"); _ccdg != nil {
		return _ccdg
	}
	if _deac := _ecfce.Lt2.ValidateWithPath(path + "\u002fLt2"); _deac != nil {
		return _deac
	}
	if _adde := _ecfce.Accent1.ValidateWithPath(path + "\u002fAccent1"); _adde != nil {
		return _adde
	}
	if _ffaf := _ecfce.Accent2.ValidateWithPath(path + "\u002fAccent2"); _ffaf != nil {
		return _ffaf
	}
	if _gbfdeb := _ecfce.Accent3.ValidateWithPath(path + "\u002fAccent3"); _gbfdeb != nil {
		return _gbfdeb
	}
	if _bdeg := _ecfce.Accent4.ValidateWithPath(path + "\u002fAccent4"); _bdeg != nil {
		return _bdeg
	}
	if _gbed := _ecfce.Accent5.ValidateWithPath(path + "\u002fAccent5"); _gbed != nil {
		return _gbed
	}
	if _gaeaf := _ecfce.Accent6.ValidateWithPath(path + "\u002fAccent6"); _gaeaf != nil {
		return _gaeaf
	}
	if _fgfa := _ecfce.Hlink.ValidateWithPath(path + "\u002fHlink"); _fgfa != nil {
		return _fgfa
	}
	if _dfeca := _ecfce.FolHlink.ValidateWithPath(path + "\u002fFolHlink"); _dfeca != nil {
		return _dfeca
	}
	if _ecfce.ExtLst != nil {
		if _acdcg := _ecfce.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _acdcg != nil {
			return _acdcg
		}
	}
	return nil
}
func (_cffdga ST_PresetLineDashVal) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cffdga.String(), start)
}
func (_faeada *CT_Scale2D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_cfege := _g.StartElement{Name: _g.Name{Local: "a:sx"}}
	e.EncodeElement(_faeada.Sx, _cfege)
	_gfdbg := _g.StartElement{Name: _g.Name{Local: "a:sy"}}
	e.EncodeElement(_faeada.Sy, _gfdbg)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SupplementalFont and its children
func (_ggfad *CT_SupplementalFont) Validate() error {
	return _ggfad.ValidateWithPath("CT_SupplementalFont")
}
func (_cegf *CT_ComplementTransform) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_bafd, _afa := d.Token()
		if _afa != nil {
			return _dcf.Errorf("parsing\u0020CT_ComplementTransform:\u0020\u0025s", _afa)
		}
		if _gfcbb, _eadga := _bafd.(_g.EndElement); _eadga && _gfcbb.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_FillProperties() *CT_FillProperties { _daec := &CT_FillProperties{}; return _daec }

// ValidateWithPath validates the CT_Bevel and its children, prefixing error messages with path
func (_bbad *CT_Bevel) ValidateWithPath(path string) error {
	if _bbad.WAttr != nil {
		if *_bbad.WAttr < 0 {
			return _dcf.Errorf("\u0025s\u002fm\u002eWAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_bbad.WAttr)
		}
		if *_bbad.WAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s/m\u002eWAttr\u0020must\u0020be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_bbad.WAttr)
		}
	}
	if _bbad.HAttr != nil {
		if *_bbad.HAttr < 0 {
			return _dcf.Errorf("\u0025s\u002fm\u002eHAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_bbad.HAttr)
		}
		if *_bbad.HAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s/m\u002eHAttr\u0020must\u0020be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_bbad.HAttr)
		}
	}
	if _eef := _bbad.PrstAttr.ValidateWithPath(path + "\u002fPrstAttr"); _eef != nil {
		return _eef
	}
	return nil
}
func (_eebb *CT_ColorScheme) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "name"}, Value: _dcf.Sprintf("\u0025v", _eebb.NameAttr)})
	e.EncodeToken(start)
	_gdbe := _g.StartElement{Name: _g.Name{Local: "a:dk1"}}
	e.EncodeElement(_eebb.Dk1, _gdbe)
	_dbeb := _g.StartElement{Name: _g.Name{Local: "a:lt1"}}
	e.EncodeElement(_eebb.Lt1, _dbeb)
	_dbda := _g.StartElement{Name: _g.Name{Local: "a:dk2"}}
	e.EncodeElement(_eebb.Dk2, _dbda)
	_effe := _g.StartElement{Name: _g.Name{Local: "a:lt2"}}
	e.EncodeElement(_eebb.Lt2, _effe)
	_abec := _g.StartElement{Name: _g.Name{Local: "a:accent1"}}
	e.EncodeElement(_eebb.Accent1, _abec)
	_bcgb := _g.StartElement{Name: _g.Name{Local: "a:accent2"}}
	e.EncodeElement(_eebb.Accent2, _bcgb)
	_cdcg := _g.StartElement{Name: _g.Name{Local: "a:accent3"}}
	e.EncodeElement(_eebb.Accent3, _cdcg)
	_afecb := _g.StartElement{Name: _g.Name{Local: "a:accent4"}}
	e.EncodeElement(_eebb.Accent4, _afecb)
	_bfgcb := _g.StartElement{Name: _g.Name{Local: "a:accent5"}}
	e.EncodeElement(_eebb.Accent5, _bfgcb)
	_aafbd := _g.StartElement{Name: _g.Name{Local: "a:accent6"}}
	e.EncodeElement(_eebb.Accent6, _aafbd)
	_bcfa := _g.StartElement{Name: _g.Name{Local: "a:hlink"}}
	e.EncodeElement(_eebb.Hlink, _bcfa)
	_acad := _g.StartElement{Name: _g.Name{Local: "a:folHlink"}}
	e.EncodeElement(_eebb.FolHlink, _acad)
	if _eebb.ExtLst != nil {
		_gcg := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_eebb.ExtLst, _gcg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func ParseUnionST_Coordinate32(s string) (ST_Coordinate32, error) {
	_bfgd := ST_Coordinate32{}
	if _f.ST_UniversalMeasurePatternRe.MatchString(s) {
		_bfgd.ST_UniversalMeasure = &s
	} else {
		_eedcd, _daccc := _e.ParseInt(s, 10, 32)
		if _daccc != nil {
			return _bfgd, _dcf.Errorf("parsing\u0020\u0025s\u0020as\u0020int", _daccc)
		}
		_decag := int32(_eedcd)
		_bfgd.ST_Coordinate32Unqualified = &_decag
	}
	return _bfgd, nil
}
func (_ddffd *CT_LinearShadeProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _ddffd.AngAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "ang"}, Value: _dcf.Sprintf("\u0025v", *_ddffd.AngAttr)})
	}
	if _ddffd.ScaledAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "scaled"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddffd.ScaledAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_StretchInfoProperties() *CT_StretchInfoProperties {
	_fffad := &CT_StretchInfoProperties{}
	return _fffad
}

// ST_AnimationDgmBuildType is a union type
type ST_AnimationDgmBuildType struct {
	ST_AnimationBuildType        ST_AnimationBuildType
	ST_AnimationDgmOnlyBuildType ST_AnimationDgmOnlyBuildType
}

// Validate validates the EG_FillModeProperties and its children
func (_gdbeb *EG_FillModeProperties) Validate() error {
	return _gdbeb.ValidateWithPath("EG_FillModeProperties")
}

// Validate validates the CT_ColorSchemeAndMapping and its children
func (_egde *CT_ColorSchemeAndMapping) Validate() error {
	return _egde.ValidateWithPath("CT_ColorSchemeAndMapping")
}
func (_eddfe *EG_LineDashProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _eddfe.PrstDash != nil {
		_gcgef := _g.StartElement{Name: _g.Name{Local: "a:prstDash"}}
		e.EncodeElement(_eddfe.PrstDash, _gcgef)
	}
	if _eddfe.CustDash != nil {
		_ebbcc := _g.StartElement{Name: _g.Name{Local: "a:custDash"}}
		e.EncodeElement(_eddfe.CustDash, _ebbcc)
	}
	return nil
}
func NewCT_TextTabStop() *CT_TextTabStop { _fbgbc := &CT_TextTabStop{}; return _fbgbc }

type ST_BevelPresetType byte
type CT_TextUnderlineFillFollowText struct{}

func NewCT_AnimationGraphicalObjectBuildProperties() *CT_AnimationGraphicalObjectBuildProperties {
	_ggf := &CT_AnimationGraphicalObjectBuildProperties{}
	return _ggf
}
func (_dagcb *CT_Path2DClose) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_fbedb, _gagfd := d.Token()
		if _gagfd != nil {
			return _dcf.Errorf("parsing\u0020CT_Path2DClose:\u0020\u0025s", _gagfd)
		}
		if _cdbca, _acdea := _fbedb.(_g.EndElement); _acdea && _cdbca.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cbef *CT_BlurEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _efgc := range start.Attr {
		if _efgc.Name.Local == "rad" {
			_cgbee, _dccb := _e.ParseInt(_efgc.Value, 10, 64)
			if _dccb != nil {
				return _dccb
			}
			_cbef.RadAttr = &_cgbee
			continue
		}
		if _efgc.Name.Local == "grow" {
			_eaa, _deg := _e.ParseBool(_efgc.Value)
			if _deg != nil {
				return _deg
			}
			_cbef.GrowAttr = &_eaa
			continue
		}
	}
	for {
		_ebbg, _cbgd := d.Token()
		if _cbgd != nil {
			return _dcf.Errorf("parsing\u0020CT_BlurEffect:\u0020\u0025s", _cbgd)
		}
		if _ecfge, _gfdc := _ebbg.(_g.EndElement); _gfdc && _ecfge.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_WholeE2oFormatting and its children
func (_baege *CT_WholeE2oFormatting) Validate() error {
	return _baege.ValidateWithPath("CT_WholeE2oFormatting")
}

// ValidateWithPath validates the CT_FillOverlayEffect and its children, prefixing error messages with path
func (_ccfdc *CT_FillOverlayEffect) ValidateWithPath(path string) error {
	if _ccfdc.BlendAttr == ST_BlendModeUnset {
		return _dcf.Errorf("\u0025s\u002fBlendAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _gbea := _ccfdc.BlendAttr.ValidateWithPath(path + "\u002fBlendAttr"); _gbea != nil {
		return _gbea
	}
	if _ccfdc.NoFill != nil {
		if _gegbc := _ccfdc.NoFill.ValidateWithPath(path + "\u002fNoFill"); _gegbc != nil {
			return _gegbc
		}
	}
	if _ccfdc.SolidFill != nil {
		if _babgb := _ccfdc.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _babgb != nil {
			return _babgb
		}
	}
	if _ccfdc.GradFill != nil {
		if _cgab := _ccfdc.GradFill.ValidateWithPath(path + "\u002fGradFill"); _cgab != nil {
			return _cgab
		}
	}
	if _ccfdc.BlipFill != nil {
		if _bgdgb := _ccfdc.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _bgdgb != nil {
			return _bgdgb
		}
	}
	if _ccfdc.PattFill != nil {
		if _dccbc := _ccfdc.PattFill.ValidateWithPath(path + "\u002fPattFill"); _dccbc != nil {
			return _dccbc
		}
	}
	if _ccfdc.GrpFill != nil {
		if _bdgd := _ccfdc.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _bdgd != nil {
			return _bdgd
		}
	}
	return nil
}

// ValidateWithPath validates the CT_BlipFillProperties and its children, prefixing error messages with path
func (_bdfe *CT_BlipFillProperties) ValidateWithPath(path string) error {
	if _bdfe.Blip != nil {
		if _acbbe := _bdfe.Blip.ValidateWithPath(path + "\u002fBlip"); _acbbe != nil {
			return _acbbe
		}
	}
	if _bdfe.SrcRect != nil {
		if _cdc := _bdfe.SrcRect.ValidateWithPath(path + "\u002fSrcRect"); _cdc != nil {
			return _cdc
		}
	}
	if _bdfe.Tile != nil {
		if _egca := _bdfe.Tile.ValidateWithPath(path + "\u002fTile"); _egca != nil {
			return _egca
		}
	}
	if _bdfe.Stretch != nil {
		if _afbc := _bdfe.Stretch.ValidateWithPath(path + "\u002fStretch"); _afbc != nil {
			return _afbc
		}
	}
	return nil
}

type CT_EffectStyleItem struct {
	EffectLst *CT_EffectList
	EffectDag *CT_EffectContainer
	Scene3d   *CT_Scene3D
	Sp3d      *CT_Shape3D
}
type CT_LineJoinMiterProperties struct{ LimAttr *ST_PositivePercentage }

func NewCT_GradientFillProperties() *CT_GradientFillProperties {
	_gccf := &CT_GradientFillProperties{}
	return _gccf
}

// Validate validates the CT_Shape3D and its children
func (_cfbda *CT_Shape3D) Validate() error { return _cfbda.ValidateWithPath("CT_Shape3D") }
func (_bfed *CT_OfficeArtExtensionList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _bfed.Ext != nil {
		_ecfe := _g.StartElement{Name: _g.Name{Local: "a:ext"}}
		for _, _gffcg := range _bfed.Ext {
			e.EncodeElement(_gffcg, _ecfe)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_acacc *ST_TextSpacingPercentOrPercentString) ValidateWithPath(path string) error {
	_gadcc := []string{}
	if _acacc.ST_TextSpacingPercent != nil {
		_gadcc = append(_gadcc, "ST_TextSpacingPercent")
	}
	if _acacc.ST_Percentage != nil {
		_gadcc = append(_gadcc, "ST_Percentage")
	}
	if len(_gadcc) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _gadcc)
	}
	return nil
}
func NewCT_GammaTransform() *CT_GammaTransform { _cdef := &CT_GammaTransform{}; return _cdef }

// ValidateWithPath validates the CT_GvmlUseShapeRectangle and its children, prefixing error messages with path
func (_bfagc *CT_GvmlUseShapeRectangle) ValidateWithPath(path string) error { return nil }

type CT_TextBody struct {
	BodyPr   *CT_TextBodyProperties
	LstStyle *CT_TextListStyle
	P        []*CT_TextParagraph
}

// ValidateWithPath validates the CT_TextListStyle and its children, prefixing error messages with path
func (_ccddfb *CT_TextListStyle) ValidateWithPath(path string) error {
	if _ccddfb.DefPPr != nil {
		if _geafe := _ccddfb.DefPPr.ValidateWithPath(path + "\u002fDefPPr"); _geafe != nil {
			return _geafe
		}
	}
	if _ccddfb.Lvl1pPr != nil {
		if _dfebd := _ccddfb.Lvl1pPr.ValidateWithPath(path + "\u002fLvl1pPr"); _dfebd != nil {
			return _dfebd
		}
	}
	if _ccddfb.Lvl2pPr != nil {
		if _ebba := _ccddfb.Lvl2pPr.ValidateWithPath(path + "\u002fLvl2pPr"); _ebba != nil {
			return _ebba
		}
	}
	if _ccddfb.Lvl3pPr != nil {
		if _egbfb := _ccddfb.Lvl3pPr.ValidateWithPath(path + "\u002fLvl3pPr"); _egbfb != nil {
			return _egbfb
		}
	}
	if _ccddfb.Lvl4pPr != nil {
		if _eacad := _ccddfb.Lvl4pPr.ValidateWithPath(path + "\u002fLvl4pPr"); _eacad != nil {
			return _eacad
		}
	}
	if _ccddfb.Lvl5pPr != nil {
		if _aegfd := _ccddfb.Lvl5pPr.ValidateWithPath(path + "\u002fLvl5pPr"); _aegfd != nil {
			return _aegfd
		}
	}
	if _ccddfb.Lvl6pPr != nil {
		if _ggdgg := _ccddfb.Lvl6pPr.ValidateWithPath(path + "\u002fLvl6pPr"); _ggdgg != nil {
			return _ggdgg
		}
	}
	if _ccddfb.Lvl7pPr != nil {
		if _feeaa := _ccddfb.Lvl7pPr.ValidateWithPath(path + "\u002fLvl7pPr"); _feeaa != nil {
			return _feeaa
		}
	}
	if _ccddfb.Lvl8pPr != nil {
		if _dgefe := _ccddfb.Lvl8pPr.ValidateWithPath(path + "\u002fLvl8pPr"); _dgefe != nil {
			return _dgefe
		}
	}
	if _ccddfb.Lvl9pPr != nil {
		if _ffbbb := _ccddfb.Lvl9pPr.ValidateWithPath(path + "\u002fLvl9pPr"); _ffbbb != nil {
			return _ffbbb
		}
	}
	if _ccddfb.ExtLst != nil {
		if _dgfaab := _ccddfb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dgfaab != nil {
			return _dgfaab
		}
	}
	return nil
}
func NewAG_Blob() *AG_Blob { _fc := &AG_Blob{}; return _fc }
func (_bdcae *CT_TextFont) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ecfcc := range start.Attr {
		if _ecfcc.Name.Local == "typeface" {
			_fggdb, _gfgd := _ecfcc.Value, error(nil)
			if _gfgd != nil {
				return _gfgd
			}
			_bdcae.TypefaceAttr = _fggdb
			continue
		}
		if _ecfcc.Name.Local == "panose" {
			_egedb, _bdafgb := _ecfcc.Value, error(nil)
			if _bdafgb != nil {
				return _bdafgb
			}
			_bdcae.PanoseAttr = &_egedb
			continue
		}
		if _ecfcc.Name.Local == "pitchFamily" {
			_bdcae.PitchFamilyAttr.UnmarshalXMLAttr(_ecfcc)
			continue
		}
		if _ecfcc.Name.Local == "charset" {
			_gebcb, _aecda := _e.ParseInt(_ecfcc.Value, 10, 8)
			if _aecda != nil {
				return _aecda
			}
			_cdddb := int8(_gebcb)
			_bdcae.CharsetAttr = &_cdddb
			continue
		}
	}
	for {
		_ecdgg, _gdbac := d.Token()
		if _gdbac != nil {
			return _dcf.Errorf("parsing\u0020CT_TextFont:\u0020\u0025s", _gdbac)
		}
		if _abcbg, _fgdcg := _ecdgg.(_g.EndElement); _fgdcg && _abcbg.Name == start.Name {
			break
		}
	}
	return nil
}

type ThemeManager struct{ CT_EmptyElement }

// ValidateWithPath validates the CT_GvmlGroupShapeNonVisual and its children, prefixing error messages with path
func (_cbdd *CT_GvmlGroupShapeNonVisual) ValidateWithPath(path string) error {
	if _cbbd := _cbdd.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _cbbd != nil {
		return _cbbd
	}
	if _bfaca := _cbdd.CNvGrpSpPr.ValidateWithPath(path + "/CNvGrpSpPr"); _bfaca != nil {
		return _bfaca
	}
	return nil
}
func (_dfebc ST_CompoundLine) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_bfadf := _g.Attr{}
	_bfadf.Name = name
	switch _dfebc {
	case ST_CompoundLineUnset:
		_bfadf.Value = ""
	case ST_CompoundLineSng:
		_bfadf.Value = "sng"
	case ST_CompoundLineDbl:
		_bfadf.Value = "dbl"
	case ST_CompoundLineThickThin:
		_bfadf.Value = "thickThin"
	case ST_CompoundLineThinThick:
		_bfadf.Value = "thinThick"
	case ST_CompoundLineTri:
		_bfadf.Value = "tri"
	}
	return _bfadf, nil
}

// Validate validates the CT_FontReference and its children
func (_fgbgc *CT_FontReference) Validate() error { return _fgbgc.ValidateWithPath("CT_FontReference") }

type ST_ChartBuildStep byte

func (_cfebd *ST_PresetLineDashVal) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ebgae, _beeaec := d.Token()
	if _beeaec != nil {
		return _beeaec
	}
	if _agdcb, _bdgdb := _ebgae.(_g.EndElement); _bdgdb && _agdcb.Name == start.Name {
		*_cfebd = 1
		return nil
	}
	if _gcfca, _bedea := _ebgae.(_g.CharData); !_bedea {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ebgae)
	} else {
		switch string(_gcfca) {
		case "":
			*_cfebd = 0
		case "solid":
			*_cfebd = 1
		case "dot":
			*_cfebd = 2
		case "dash":
			*_cfebd = 3
		case "lgDash":
			*_cfebd = 4
		case "dashDot":
			*_cfebd = 5
		case "lgDashDot":
			*_cfebd = 6
		case "lgDashDotDot":
			*_cfebd = 7
		case "sysDash":
			*_cfebd = 8
		case "sysDot":
			*_cfebd = 9
		case "sysDashDot":
			*_cfebd = 10
		case "sysDashDotDot":
			*_cfebd = 11
		}
	}
	_ebgae, _beeaec = d.Token()
	if _beeaec != nil {
		return _beeaec
	}
	if _cffea, _ffeff := _ebgae.(_g.EndElement); _ffeff && _cffea.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ebgae)
}
func NewCT_ConnectorLocking() *CT_ConnectorLocking { _bdcc := &CT_ConnectorLocking{}; return _bdcc }

type CT_TextListStyle struct {
	DefPPr  *CT_TextParagraphProperties
	Lvl1pPr *CT_TextParagraphProperties
	Lvl2pPr *CT_TextParagraphProperties
	Lvl3pPr *CT_TextParagraphProperties
	Lvl4pPr *CT_TextParagraphProperties
	Lvl5pPr *CT_TextParagraphProperties
	Lvl6pPr *CT_TextParagraphProperties
	Lvl7pPr *CT_TextParagraphProperties
	Lvl8pPr *CT_TextParagraphProperties
	Lvl9pPr *CT_TextParagraphProperties
	ExtLst  *CT_OfficeArtExtensionList
}

func NewVideoFile() *VideoFile {
	_egece := &VideoFile{}
	_egece.CT_VideoFile = *NewCT_VideoFile()
	return _egece
}
func (_aaffb ST_AnimationDgmOnlyBuildType) Validate() error { return _aaffb.ValidateWithPath("") }

// Validate validates the CT_AudioFile and its children
func (_gfg *CT_AudioFile) Validate() error { return _gfg.ValidateWithPath("CT_AudioFile") }
func NewCT_FontScheme() *CT_FontScheme {
	_dcbgf := &CT_FontScheme{}
	_dcbgf.MajorFont = NewCT_FontCollection()
	_dcbgf.MinorFont = NewCT_FontCollection()
	return _dcbgf
}

// ValidateWithPath validates the ThemeManager and its children, prefixing error messages with path
func (_bggged *ThemeManager) ValidateWithPath(path string) error {
	if _cbedba := _bggged.CT_EmptyElement.ValidateWithPath(path); _cbedba != nil {
		return _cbedba
	}
	return nil
}

// Validate validates the CT_OfficeArtExtension and its children
func (_feged *CT_OfficeArtExtension) Validate() error {
	return _feged.ValidateWithPath("CT_OfficeArtExtension")
}
func (_cdaef ST_LineEndType) String() string {
	switch _cdaef {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "triangle"
	case 3:
		return "stealth"
	case 4:
		return "diamond"
	case 5:
		return "oval"
	case 6:
		return "arrow"
	}
	return ""
}

// Validate validates the CT_LineJoinMiterProperties and its children
func (_bcggd *CT_LineJoinMiterProperties) Validate() error {
	return _bcggd.ValidateWithPath("CT_LineJoinMiterProperties")
}

type CT_Connection struct {
	IdAttr  uint32
	IdxAttr uint32
}

func NewCT_GroupShapeProperties() *CT_GroupShapeProperties {
	_dcgde := &CT_GroupShapeProperties{}
	return _dcgde
}
func ParseUnionST_TextPoint(s string) (ST_TextPoint, error) {
	_debd := ST_TextPoint{}
	if _f.ST_UniversalMeasurePatternRe.MatchString(s) {
		_debd.ST_UniversalMeasure = &s
	} else {
		_befea, _cbgdd := _e.ParseInt(s, 10, 32)
		if _cbgdd != nil {
			return _debd, _dcf.Errorf("parsing\u0020\u0025s\u0020as\u0020int", _cbgdd)
		}
		_ggeab := int32(_befea)
		_debd.ST_TextPointUnqualified = &_ggeab
	}
	return _debd, nil
}
func NewCT_TextSpacingPoint() *CT_TextSpacingPoint {
	_dggac := &CT_TextSpacingPoint{}
	_dggac.ValAttr = 0
	return _dggac
}
func (_dedeg *CT_TableStyleTextStyle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dedeg.BAttr != ST_OnOffStyleTypeUnset {
		_abgbd, _afaffg := _dedeg.BAttr.MarshalXMLAttr(_g.Name{Local: "b"})
		if _afaffg != nil {
			return _afaffg
		}
		start.Attr = append(start.Attr, _abgbd)
	}
	if _dedeg.IAttr != ST_OnOffStyleTypeUnset {
		_aegbe, _aefegf := _dedeg.IAttr.MarshalXMLAttr(_g.Name{Local: "i"})
		if _aefegf != nil {
			return _aefegf
		}
		start.Attr = append(start.Attr, _aegbe)
	}
	e.EncodeToken(start)
	if _dedeg.Font != nil {
		_cedaa := _g.StartElement{Name: _g.Name{Local: "a:font"}}
		e.EncodeElement(_dedeg.Font, _cedaa)
	}
	if _dedeg.FontRef != nil {
		_geafb := _g.StartElement{Name: _g.Name{Local: "a:fontRef"}}
		e.EncodeElement(_dedeg.FontRef, _geafb)
	}
	if _dedeg.ScrgbClr != nil {
		_fegaa := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_dedeg.ScrgbClr, _fegaa)
	}
	if _dedeg.SrgbClr != nil {
		_aeabg := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_dedeg.SrgbClr, _aeabg)
	}
	if _dedeg.HslClr != nil {
		_cdecg := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_dedeg.HslClr, _cdecg)
	}
	if _dedeg.SysClr != nil {
		_bgbfd := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_dedeg.SysClr, _bgbfd)
	}
	if _dedeg.SchemeClr != nil {
		_fedcc := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_dedeg.SchemeClr, _fedcc)
	}
	if _dedeg.PrstClr != nil {
		_dbcag := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_dedeg.PrstClr, _dbcag)
	}
	if _dedeg.ExtLst != nil {
		_gdefb := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dedeg.ExtLst, _gdefb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_bdbgf *CT_Path2DQuadBezierTo) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_gdgca := _g.StartElement{Name: _g.Name{Local: "a:pt"}}
	for _, _bgeca := range _bdbgf.Pt {
		e.EncodeElement(_bgeca, _gdgca)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_OfficeStyleSheet() *CT_OfficeStyleSheet {
	_gbbag := &CT_OfficeStyleSheet{}
	_gbbag.ThemeElements = NewCT_BaseStyles()
	return _gbbag
}
func NewCT_TableCellBorderStyle() *CT_TableCellBorderStyle {
	_cdbd := &CT_TableCellBorderStyle{}
	return _cdbd
}

type ST_LineEndLength byte

func (_ddbgcg *CT_TextBodyProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _ddbgcg.RotAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rot"}, Value: _dcf.Sprintf("\u0025v", *_ddbgcg.RotAttr)})
	}
	if _ddbgcg.SpcFirstLastParaAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "spcFirstLastPara"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddbgcg.SpcFirstLastParaAttr))})
	}
	if _ddbgcg.VertOverflowAttr != ST_TextVertOverflowTypeUnset {
		_abacf, _cffcg := _ddbgcg.VertOverflowAttr.MarshalXMLAttr(_g.Name{Local: "vertOverflow"})
		if _cffcg != nil {
			return _cffcg
		}
		start.Attr = append(start.Attr, _abacf)
	}
	if _ddbgcg.HorzOverflowAttr != ST_TextHorzOverflowTypeUnset {
		_abdbcb, _eefd := _ddbgcg.HorzOverflowAttr.MarshalXMLAttr(_g.Name{Local: "horzOverflow"})
		if _eefd != nil {
			return _eefd
		}
		start.Attr = append(start.Attr, _abdbcb)
	}
	if _ddbgcg.VertAttr != ST_TextVerticalTypeUnset {
		_cbgacg, _aeacg := _ddbgcg.VertAttr.MarshalXMLAttr(_g.Name{Local: "vert"})
		if _aeacg != nil {
			return _aeacg
		}
		start.Attr = append(start.Attr, _cbgacg)
	}
	if _ddbgcg.WrapAttr != ST_TextWrappingTypeUnset {
		_gade, _dafef := _ddbgcg.WrapAttr.MarshalXMLAttr(_g.Name{Local: "wrap"})
		if _dafef != nil {
			return _dafef
		}
		start.Attr = append(start.Attr, _gade)
	}
	if _ddbgcg.LInsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lIns"}, Value: _dcf.Sprintf("\u0025v", *_ddbgcg.LInsAttr)})
	}
	if _ddbgcg.TInsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "tIns"}, Value: _dcf.Sprintf("\u0025v", *_ddbgcg.TInsAttr)})
	}
	if _ddbgcg.RInsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rIns"}, Value: _dcf.Sprintf("\u0025v", *_ddbgcg.RInsAttr)})
	}
	if _ddbgcg.BInsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "bIns"}, Value: _dcf.Sprintf("\u0025v", *_ddbgcg.BInsAttr)})
	}
	if _ddbgcg.NumColAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "numCol"}, Value: _dcf.Sprintf("\u0025v", *_ddbgcg.NumColAttr)})
	}
	if _ddbgcg.SpcColAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "spcCol"}, Value: _dcf.Sprintf("\u0025v", *_ddbgcg.SpcColAttr)})
	}
	if _ddbgcg.RtlColAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rtlCol"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddbgcg.RtlColAttr))})
	}
	if _ddbgcg.FromWordArtAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "fromWordArt"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddbgcg.FromWordArtAttr))})
	}
	if _ddbgcg.AnchorAttr != ST_TextAnchoringTypeUnset {
		_eceab, _ccdbf := _ddbgcg.AnchorAttr.MarshalXMLAttr(_g.Name{Local: "anchor"})
		if _ccdbf != nil {
			return _ccdbf
		}
		start.Attr = append(start.Attr, _eceab)
	}
	if _ddbgcg.AnchorCtrAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "anchorCtr"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddbgcg.AnchorCtrAttr))})
	}
	if _ddbgcg.ForceAAAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "forceAA"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddbgcg.ForceAAAttr))})
	}
	if _ddbgcg.UprightAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "upright"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddbgcg.UprightAttr))})
	}
	if _ddbgcg.CompatLnSpcAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "compatLnSpc"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ddbgcg.CompatLnSpcAttr))})
	}
	e.EncodeToken(start)
	if _ddbgcg.PrstTxWarp != nil {
		_bacgd := _g.StartElement{Name: _g.Name{Local: "a:prstTxWarp"}}
		e.EncodeElement(_ddbgcg.PrstTxWarp, _bacgd)
	}
	if _ddbgcg.NoAutofit != nil {
		_ddada := _g.StartElement{Name: _g.Name{Local: "a:noAutofit"}}
		e.EncodeElement(_ddbgcg.NoAutofit, _ddada)
	}
	if _ddbgcg.NormAutofit != nil {
		_bcab := _g.StartElement{Name: _g.Name{Local: "a:normAutofit"}}
		e.EncodeElement(_ddbgcg.NormAutofit, _bcab)
	}
	if _ddbgcg.SpAutoFit != nil {
		_fefaa := _g.StartElement{Name: _g.Name{Local: "a:spAutoFit"}}
		e.EncodeElement(_ddbgcg.SpAutoFit, _fefaa)
	}
	if _ddbgcg.Scene3d != nil {
		_fgbdf := _g.StartElement{Name: _g.Name{Local: "a:scene3d"}}
		e.EncodeElement(_ddbgcg.Scene3d, _fgbdf)
	}
	if _ddbgcg.Sp3d != nil {
		_cfceab := _g.StartElement{Name: _g.Name{Local: "a:sp3d"}}
		e.EncodeElement(_ddbgcg.Sp3d, _cfceab)
	}
	if _ddbgcg.FlatTx != nil {
		_beedd := _g.StartElement{Name: _g.Name{Local: "a:flatTx"}}
		e.EncodeElement(_ddbgcg.FlatTx, _beedd)
	}
	if _ddbgcg.ExtLst != nil {
		_dbfcc := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_ddbgcg.ExtLst, _dbfcc)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_DefaultShapeDefinition struct {
	SpPr     *CT_ShapeProperties
	BodyPr   *CT_TextBodyProperties
	LstStyle *CT_TextListStyle
	Style    *CT_ShapeStyle
	ExtLst   *CT_OfficeArtExtensionList
}

func NewCT_DuotoneEffect() *CT_DuotoneEffect { _eaba := &CT_DuotoneEffect{}; return _eaba }
func NewCT_GvmlUseShapeRectangle() *CT_GvmlUseShapeRectangle {
	_ffgdd := &CT_GvmlUseShapeRectangle{}
	return _ffgdd
}

type EG_Text3D struct {
	Sp3d   *CT_Shape3D
	FlatTx *CT_FlatText
}
type EG_TextBulletTypeface struct {
	BuFontTx *CT_TextBulletTypefaceFollowText
	BuFont   *CT_TextFont
}

// ValidateWithPath validates the CT_ColorMappingOverrideChoice and its children, prefixing error messages with path
func (_dbaef *CT_ColorMappingOverrideChoice) ValidateWithPath(path string) error {
	if _dbaef.MasterClrMapping != nil {
		if _gebb := _dbaef.MasterClrMapping.ValidateWithPath(path + "\u002fMasterClrMapping"); _gebb != nil {
			return _gebb
		}
	}
	if _dbaef.OverrideClrMapping != nil {
		if _gfbc := _dbaef.OverrideClrMapping.ValidateWithPath(path + "\u002fOverrideClrMapping"); _gfbc != nil {
			return _gfbc
		}
	}
	return nil
}
func (_cddb *CT_Boolean) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _cddb.ValAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", *_cddb.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ecfdc *CT_PresetTextShape) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ecfdc.PrstAttr = ST_TextShapeType(1)
	for _, _afage := range start.Attr {
		if _afage.Name.Local == "prst" {
			_ecfdc.PrstAttr.UnmarshalXMLAttr(_afage)
			continue
		}
	}
_cdebb:
	for {
		_gdaef, _gcgdac := d.Token()
		if _gcgdac != nil {
			return _gcgdac
		}
		switch _cdbb := _gdaef.(type) {
		case _g.StartElement:
			switch _cdbb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "avLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "avLst"}:
				_ecfdc.AvLst = NewCT_GeomGuideList()
				if _cgeda := d.DecodeElement(_ecfdc.AvLst, &_cdbb); _cgeda != nil {
					return _cgeda
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_PresetTextShape\u0020\u0025v", _cdbb.Name)
				if _dcgfg := d.Skip(); _dcgfg != nil {
					return _dcgfg
				}
			}
		case _g.EndElement:
			break _cdebb
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_FontCollection() *CT_FontCollection {
	_aede := &CT_FontCollection{}
	_aede.Latin = NewCT_TextFont()
	_aede.Ea = NewCT_TextFont()
	_aede.Cs = NewCT_TextFont()
	return _aede
}
func (_ecbaa ST_PresetColorVal) String() string {
	switch _ecbaa {
	case 0:
		return ""
	case 1:
		return "aliceBlue"
	case 2:
		return "antiqueWhite"
	case 3:
		return "aqua"
	case 4:
		return "aquamarine"
	case 5:
		return "azure"
	case 6:
		return "beige"
	case 7:
		return "bisque"
	case 8:
		return "black"
	case 9:
		return "blanchedAlmond"
	case 10:
		return "blue"
	case 11:
		return "blueViolet"
	case 12:
		return "brown"
	case 13:
		return "burlyWood"
	case 14:
		return "cadetBlue"
	case 15:
		return "chartreuse"
	case 16:
		return "chocolate"
	case 17:
		return "coral"
	case 18:
		return "cornflowerBlue"
	case 19:
		return "cornsilk"
	case 20:
		return "crimson"
	case 21:
		return "cyan"
	case 22:
		return "darkBlue"
	case 23:
		return "darkCyan"
	case 24:
		return "darkGoldenrod"
	case 25:
		return "darkGray"
	case 26:
		return "darkGrey"
	case 27:
		return "darkGreen"
	case 28:
		return "darkKhaki"
	case 29:
		return "darkMagenta"
	case 30:
		return "darkOliveGreen"
	case 31:
		return "darkOrange"
	case 32:
		return "darkOrchid"
	case 33:
		return "darkRed"
	case 34:
		return "darkSalmon"
	case 35:
		return "darkSeaGreen"
	case 36:
		return "darkSlateBlue"
	case 37:
		return "darkSlateGray"
	case 38:
		return "darkSlateGrey"
	case 39:
		return "darkTurquoise"
	case 40:
		return "darkViolet"
	case 41:
		return "dkBlue"
	case 42:
		return "dkCyan"
	case 43:
		return "dkGoldenrod"
	case 44:
		return "dkGray"
	case 45:
		return "dkGrey"
	case 46:
		return "dkGreen"
	case 47:
		return "dkKhaki"
	case 48:
		return "dkMagenta"
	case 49:
		return "dkOliveGreen"
	case 50:
		return "dkOrange"
	case 51:
		return "dkOrchid"
	case 52:
		return "dkRed"
	case 53:
		return "dkSalmon"
	case 54:
		return "dkSeaGreen"
	case 55:
		return "dkSlateBlue"
	case 56:
		return "dkSlateGray"
	case 57:
		return "dkSlateGrey"
	case 58:
		return "dkTurquoise"
	case 59:
		return "dkViolet"
	case 60:
		return "deepPink"
	case 61:
		return "deepSkyBlue"
	case 62:
		return "dimGray"
	case 63:
		return "dimGrey"
	case 64:
		return "dodgerBlue"
	case 65:
		return "firebrick"
	case 66:
		return "floralWhite"
	case 67:
		return "forestGreen"
	case 68:
		return "fuchsia"
	case 69:
		return "gainsboro"
	case 70:
		return "ghostWhite"
	case 71:
		return "gold"
	case 72:
		return "goldenrod"
	case 73:
		return "gray"
	case 74:
		return "grey"
	case 75:
		return "green"
	case 76:
		return "greenYellow"
	case 77:
		return "honeydew"
	case 78:
		return "hotPink"
	case 79:
		return "indianRed"
	case 80:
		return "indigo"
	case 81:
		return "ivory"
	case 82:
		return "khaki"
	case 83:
		return "lavender"
	case 84:
		return "lavenderBlush"
	case 85:
		return "lawnGreen"
	case 86:
		return "lemonChiffon"
	case 87:
		return "lightBlue"
	case 88:
		return "lightCoral"
	case 89:
		return "lightCyan"
	case 90:
		return "lightGoldenrodYellow"
	case 91:
		return "lightGray"
	case 92:
		return "lightGrey"
	case 93:
		return "lightGreen"
	case 94:
		return "lightPink"
	case 95:
		return "lightSalmon"
	case 96:
		return "lightSeaGreen"
	case 97:
		return "lightSkyBlue"
	case 98:
		return "lightSlateGray"
	case 99:
		return "lightSlateGrey"
	case 100:
		return "lightSteelBlue"
	case 101:
		return "lightYellow"
	case 102:
		return "ltBlue"
	case 103:
		return "ltCoral"
	case 104:
		return "ltCyan"
	case 105:
		return "ltGoldenrodYellow"
	case 106:
		return "ltGray"
	case 107:
		return "ltGrey"
	case 108:
		return "ltGreen"
	case 109:
		return "ltPink"
	case 110:
		return "ltSalmon"
	case 111:
		return "ltSeaGreen"
	case 112:
		return "ltSkyBlue"
	case 113:
		return "ltSlateGray"
	case 114:
		return "ltSlateGrey"
	case 115:
		return "ltSteelBlue"
	case 116:
		return "ltYellow"
	case 117:
		return "lime"
	case 118:
		return "limeGreen"
	case 119:
		return "linen"
	case 120:
		return "magenta"
	case 121:
		return "maroon"
	case 122:
		return "medAquamarine"
	case 123:
		return "medBlue"
	case 124:
		return "medOrchid"
	case 125:
		return "medPurple"
	case 126:
		return "medSeaGreen"
	case 127:
		return "medSlateBlue"
	case 128:
		return "medSpringGreen"
	case 129:
		return "medTurquoise"
	case 130:
		return "medVioletRed"
	case 131:
		return "mediumAquamarine"
	case 132:
		return "mediumBlue"
	case 133:
		return "mediumOrchid"
	case 134:
		return "mediumPurple"
	case 135:
		return "mediumSeaGreen"
	case 136:
		return "mediumSlateBlue"
	case 137:
		return "mediumSpringGreen"
	case 138:
		return "mediumTurquoise"
	case 139:
		return "mediumVioletRed"
	case 140:
		return "midnightBlue"
	case 141:
		return "mintCream"
	case 142:
		return "mistyRose"
	case 143:
		return "moccasin"
	case 144:
		return "navajoWhite"
	case 145:
		return "navy"
	case 146:
		return "oldLace"
	case 147:
		return "olive"
	case 148:
		return "oliveDrab"
	case 149:
		return "orange"
	case 150:
		return "orangeRed"
	case 151:
		return "orchid"
	case 152:
		return "paleGoldenrod"
	case 153:
		return "paleGreen"
	case 154:
		return "paleTurquoise"
	case 155:
		return "paleVioletRed"
	case 156:
		return "papayaWhip"
	case 157:
		return "peachPuff"
	case 158:
		return "peru"
	case 159:
		return "pink"
	case 160:
		return "plum"
	case 161:
		return "powderBlue"
	case 162:
		return "purple"
	case 163:
		return "red"
	case 164:
		return "rosyBrown"
	case 165:
		return "royalBlue"
	case 166:
		return "saddleBrown"
	case 167:
		return "salmon"
	case 168:
		return "sandyBrown"
	case 169:
		return "seaGreen"
	case 170:
		return "seaShell"
	case 171:
		return "sienna"
	case 172:
		return "silver"
	case 173:
		return "skyBlue"
	case 174:
		return "slateBlue"
	case 175:
		return "slateGray"
	case 176:
		return "slateGrey"
	case 177:
		return "snow"
	case 178:
		return "springGreen"
	case 179:
		return "steelBlue"
	case 180:
		return "tan"
	case 181:
		return "teal"
	case 182:
		return "thistle"
	case 183:
		return "tomato"
	case 184:
		return "turquoise"
	case 185:
		return "violet"
	case 186:
		return "wheat"
	case 187:
		return "white"
	case 188:
		return "whiteSmoke"
	case 189:
		return "yellow"
	case 190:
		return "yellowGreen"
	}
	return ""
}
func (_bcdae *CT_PresetLineDashProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _bcdae.ValAttr != ST_PresetLineDashValUnset {
		_decdc, _afbcc := _bcdae.ValAttr.MarshalXMLAttr(_g.Name{Local: "val"})
		if _afbcc != nil {
			return _afbcc
		}
		start.Attr = append(start.Attr, _decdc)
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TextNormalAutofit and its children, prefixing error messages with path
func (_cfcggf *CT_TextNormalAutofit) ValidateWithPath(path string) error {
	if _cfcggf.FontScaleAttr != nil {
		if _dbgdb := _cfcggf.FontScaleAttr.ValidateWithPath(path + "\u002fFontScaleAttr"); _dbgdb != nil {
			return _dbgdb
		}
	}
	if _cfcggf.LnSpcReductionAttr != nil {
		if _cgdd := _cfcggf.LnSpcReductionAttr.ValidateWithPath(path + "\u002fLnSpcReductionAttr"); _cgdd != nil {
			return _cgdd
		}
	}
	return nil
}
func NewCT_Path2DArcTo() *CT_Path2DArcTo { _gddgea := &CT_Path2DArcTo{}; return _gddgea }
func (_ddcf *CT_PositiveFixedAngle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ddcf.ValAttr = 0
	for _, _ddfdb := range start.Attr {
		if _ddfdb.Name.Local == "val" {
			_fgbgf, _afcg := _e.ParseInt(_ddfdb.Value, 10, 32)
			if _afcg != nil {
				return _afcg
			}
			_ddcf.ValAttr = int32(_fgbgf)
			continue
		}
	}
	for {
		_ccddf, _aefeg := d.Token()
		if _aefeg != nil {
			return _dcf.Errorf("parsing\u0020CT_PositiveFixedAngle:\u0020\u0025s", _aefeg)
		}
		if _fgdee, _cfccc := _ccddf.(_g.EndElement); _cfccc && _fgdee.Name == start.Name {
			break
		}
	}
	return nil
}
func (_acba *CT_GeomGuide) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _geda := range start.Attr {
		if _geda.Name.Local == "name" {
			_ebcff, _fddaf := _geda.Value, error(nil)
			if _fddaf != nil {
				return _fddaf
			}
			_acba.NameAttr = _ebcff
			continue
		}
		if _geda.Name.Local == "fmla" {
			_bacfa, _cage := _geda.Value, error(nil)
			if _cage != nil {
				return _cage
			}
			_acba.FmlaAttr = _bacfa
			continue
		}
	}
	for {
		_egfa, _ecgfd := d.Token()
		if _ecgfd != nil {
			return _dcf.Errorf("parsing\u0020CT_GeomGuide:\u0020\u0025s", _ecgfd)
		}
		if _fbbb, _fedd := _egfa.(_g.EndElement); _fedd && _fbbb.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_TableCellBorderStyle and its children
func (_cgbcc *CT_TableCellBorderStyle) Validate() error {
	return _cgbcc.ValidateWithPath("CT_TableCellBorderStyle")
}
func (_ggcdc *ST_CompoundLine) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_adabf, _gbgfa := d.Token()
	if _gbgfa != nil {
		return _gbgfa
	}
	if _eefbgb, _cbbcgb := _adabf.(_g.EndElement); _cbbcgb && _eefbgb.Name == start.Name {
		*_ggcdc = 1
		return nil
	}
	if _cbcdc, _egcfa := _adabf.(_g.CharData); !_egcfa {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _adabf)
	} else {
		switch string(_cbcdc) {
		case "":
			*_ggcdc = 0
		case "sng":
			*_ggcdc = 1
		case "dbl":
			*_ggcdc = 2
		case "thickThin":
			*_ggcdc = 3
		case "thinThick":
			*_ggcdc = 4
		case "tri":
			*_ggcdc = 5
		}
	}
	_adabf, _gbgfa = d.Token()
	if _gbgfa != nil {
		return _gbgfa
	}
	if _egebf, _bgga := _adabf.(_g.EndElement); _bgga && _egebf.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _adabf)
}

const (
	ST_DgmBuildStepUnset ST_DgmBuildStep = 0
	ST_DgmBuildStepSp    ST_DgmBuildStep = 1
	ST_DgmBuildStepBg    ST_DgmBuildStep = 2
)

type CT_FillEffect struct {
	NoFill    *CT_NoFillProperties
	SolidFill *CT_SolidColorFillProperties
	GradFill  *CT_GradientFillProperties
	BlipFill  *CT_BlipFillProperties
	PattFill  *CT_PatternFillProperties
	GrpFill   *CT_GroupFillProperties
}

func (_cega *CT_NonVisualDrawingShapeProps) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _cega.TxBoxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "txBox"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_cega.TxBoxAttr))})
	}
	e.EncodeToken(start)
	if _cega.SpLocks != nil {
		_eacca := _g.StartElement{Name: _g.Name{Local: "a:spLocks"}}
		e.EncodeElement(_cega.SpLocks, _eacca)
	}
	if _cega.ExtLst != nil {
		_gcgf := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_cega.ExtLst, _gcgf)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_AdjPoint2D struct {
	XAttr ST_AdjCoordinate
	YAttr ST_AdjCoordinate
}

// ValidateWithPath validates the CT_AudioCD and its children, prefixing error messages with path
func (_dgcc *CT_AudioCD) ValidateWithPath(path string) error {
	if _cbed := _dgcc.St.ValidateWithPath(path + "\u002fSt"); _cbed != nil {
		return _cbed
	}
	if _gga := _dgcc.End.ValidateWithPath(path + "\u002fEnd"); _gga != nil {
		return _gga
	}
	if _dgcc.ExtLst != nil {
		if _bde := _dgcc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bde != nil {
			return _bde
		}
	}
	return nil
}
func NewCT_GvmlGraphicFrameNonVisual() *CT_GvmlGraphicFrameNonVisual {
	_ddafb := &CT_GvmlGraphicFrameNonVisual{}
	_ddafb.CNvPr = NewCT_NonVisualDrawingProps()
	_ddafb.CNvGraphicFramePr = NewCT_NonVisualGraphicFrameProperties()
	return _ddafb
}
func (_dgfba *CT_TextBulletSizePercent) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", _dgfba.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_cbgc *CT_FlatText) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _cbgc.ZAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "z"}, Value: _dcf.Sprintf("\u0025v", *_cbgc.ZAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_VideoFile struct {
	LinkAttr        string
	ContentTypeAttr *string
	ExtLst          *CT_OfficeArtExtensionList
}

func NewCT_PatternFillProperties() *CT_PatternFillProperties {
	_afaee := &CT_PatternFillProperties{}
	return _afaee
}
func (_edfef *EG_TextGeometry) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Name.Local = "a:EG_TextGeometry"
	if _edfef.CustGeom != nil {
		_bfdae := _g.StartElement{Name: _g.Name{Local: "a:custGeom"}}
		e.EncodeElement(_edfef.CustGeom, _bfdae)
	}
	if _edfef.PrstTxWarp != nil {
		_agga := _g.StartElement{Name: _g.Name{Local: "a:prstTxWarp"}}
		e.EncodeElement(_edfef.PrstTxWarp, _agga)
	}
	return nil
}

type CT_GeomGuide struct {
	NameAttr string
	FmlaAttr string
}

// ValidateWithPath validates the EG_TextGeometry and its children, prefixing error messages with path
func (_gfbab *EG_TextGeometry) ValidateWithPath(path string) error {
	if _gfbab.CustGeom != nil {
		if _bdfbab := _gfbab.CustGeom.ValidateWithPath(path + "\u002fCustGeom"); _bdfbab != nil {
			return _bdfbab
		}
	}
	if _gfbab.PrstTxWarp != nil {
		if _dgefad := _gfbab.PrstTxWarp.ValidateWithPath(path + "/PrstTxWarp"); _dgefad != nil {
			return _dgefad
		}
	}
	return nil
}
func NewEG_TextBulletTypeface() *EG_TextBulletTypeface {
	_gfcda := &EG_TextBulletTypeface{}
	return _gfcda
}
func (_ecdag *ST_TextTabAlignType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_ecdag = 0
	case "l":
		*_ecdag = 1
	case "ctr":
		*_ecdag = 2
	case "r":
		*_ecdag = 3
	case "dec":
		*_ecdag = 4
	}
	return nil
}
func NewCT_AudioCD() *CT_AudioCD {
	_faga := &CT_AudioCD{}
	_faga.St = NewCT_AudioCDTime()
	_faga.End = NewCT_AudioCDTime()
	return _faga
}

// ValidateWithPath validates the CT_FontReference and its children, prefixing error messages with path
func (_gabf *CT_FontReference) ValidateWithPath(path string) error {
	if _gabf.IdxAttr == ST_FontCollectionIndexUnset {
		return _dcf.Errorf("\u0025s\u002fIdxAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _dffcc := _gabf.IdxAttr.ValidateWithPath(path + "\u002fIdxAttr"); _dffcc != nil {
		return _dffcc
	}
	if _gabf.ScrgbClr != nil {
		if _dedgc := _gabf.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _dedgc != nil {
			return _dedgc
		}
	}
	if _gabf.SrgbClr != nil {
		if _feeb := _gabf.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _feeb != nil {
			return _feeb
		}
	}
	if _gabf.HslClr != nil {
		if _eccf := _gabf.HslClr.ValidateWithPath(path + "\u002fHslClr"); _eccf != nil {
			return _eccf
		}
	}
	if _gabf.SysClr != nil {
		if _aaee := _gabf.SysClr.ValidateWithPath(path + "\u002fSysClr"); _aaee != nil {
			return _aaee
		}
	}
	if _gabf.SchemeClr != nil {
		if _cdgbf := _gabf.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _cdgbf != nil {
			return _cdgbf
		}
	}
	if _gabf.PrstClr != nil {
		if _eeace := _gabf.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _eeace != nil {
			return _eeace
		}
	}
	return nil
}
func (_ccbdfe *ST_TextShapeType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_aacgb, _gebbd := d.Token()
	if _gebbd != nil {
		return _gebbd
	}
	if _daagf, _egeed := _aacgb.(_g.EndElement); _egeed && _daagf.Name == start.Name {
		*_ccbdfe = 1
		return nil
	}
	if _eadffd, _bagae := _aacgb.(_g.CharData); !_bagae {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aacgb)
	} else {
		switch string(_eadffd) {
		case "":
			*_ccbdfe = 0
		case "textNoShape":
			*_ccbdfe = 1
		case "textPlain":
			*_ccbdfe = 2
		case "textStop":
			*_ccbdfe = 3
		case "textTriangle":
			*_ccbdfe = 4
		case "textTriangleInverted":
			*_ccbdfe = 5
		case "textChevron":
			*_ccbdfe = 6
		case "textChevronInverted":
			*_ccbdfe = 7
		case "textRingInside":
			*_ccbdfe = 8
		case "textRingOutside":
			*_ccbdfe = 9
		case "textArchUp":
			*_ccbdfe = 10
		case "textArchDown":
			*_ccbdfe = 11
		case "textCircle":
			*_ccbdfe = 12
		case "textButton":
			*_ccbdfe = 13
		case "textArchUpPour":
			*_ccbdfe = 14
		case "textArchDownPour":
			*_ccbdfe = 15
		case "textCirclePour":
			*_ccbdfe = 16
		case "textButtonPour":
			*_ccbdfe = 17
		case "textCurveUp":
			*_ccbdfe = 18
		case "textCurveDown":
			*_ccbdfe = 19
		case "textCanUp":
			*_ccbdfe = 20
		case "textCanDown":
			*_ccbdfe = 21
		case "textWave1":
			*_ccbdfe = 22
		case "textWave2":
			*_ccbdfe = 23
		case "textDoubleWave1":
			*_ccbdfe = 24
		case "textWave4":
			*_ccbdfe = 25
		case "textInflate":
			*_ccbdfe = 26
		case "textDeflate":
			*_ccbdfe = 27
		case "textInflateBottom":
			*_ccbdfe = 28
		case "textDeflateBottom":
			*_ccbdfe = 29
		case "textInflateTop":
			*_ccbdfe = 30
		case "textDeflateTop":
			*_ccbdfe = 31
		case "textDeflateInflate":
			*_ccbdfe = 32
		case "textDeflateInflateDeflate":
			*_ccbdfe = 33
		case "textFadeRight":
			*_ccbdfe = 34
		case "textFadeLeft":
			*_ccbdfe = 35
		case "textFadeUp":
			*_ccbdfe = 36
		case "textFadeDown":
			*_ccbdfe = 37
		case "textSlantUp":
			*_ccbdfe = 38
		case "textSlantDown":
			*_ccbdfe = 39
		case "textCascadeUp":
			*_ccbdfe = 40
		case "textCascadeDown":
			*_ccbdfe = 41
		}
	}
	_aacgb, _gebbd = d.Token()
	if _gebbd != nil {
		return _gebbd
	}
	if _cabdff, _dbage := _aacgb.(_g.EndElement); _dbage && _cabdff.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aacgb)
}
func (_dafcg *ST_AdjAngle) ValidateWithPath(path string) error {
	_abccc := []string{}
	if _dafcg.ST_Angle != nil {
		_abccc = append(_abccc, "ST_Angle")
	}
	if _dafcg.ST_GeomGuideName != nil {
		_abccc = append(_abccc, "ST_GeomGuideName")
	}
	if len(_abccc) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _abccc)
	}
	return nil
}

// Validate validates the CT_Color and its children
func (_bage *CT_Color) Validate() error { return _bage.ValidateWithPath("CT_Color") }
func (_bgbg *CT_BlipChoice) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _bgbg.AlphaBiLevel != nil {
		_agg := _g.StartElement{Name: _g.Name{Local: "a:alphaBiLevel"}}
		for _, _dggd := range _bgbg.AlphaBiLevel {
			e.EncodeElement(_dggd, _agg)
		}
	}
	if _bgbg.AlphaCeiling != nil {
		_agbd := _g.StartElement{Name: _g.Name{Local: "a:alphaCeiling"}}
		for _, _fgcg := range _bgbg.AlphaCeiling {
			e.EncodeElement(_fgcg, _agbd)
		}
	}
	if _bgbg.AlphaFloor != nil {
		_dgaf := _g.StartElement{Name: _g.Name{Local: "a:alphaFloor"}}
		for _, _dgdc := range _bgbg.AlphaFloor {
			e.EncodeElement(_dgdc, _dgaf)
		}
	}
	if _bgbg.AlphaInv != nil {
		_bgbc := _g.StartElement{Name: _g.Name{Local: "a:alphaInv"}}
		for _, _fde := range _bgbg.AlphaInv {
			e.EncodeElement(_fde, _bgbc)
		}
	}
	if _bgbg.AlphaMod != nil {
		_ddddb := _g.StartElement{Name: _g.Name{Local: "a:alphaMod"}}
		for _, _ffceb := range _bgbg.AlphaMod {
			e.EncodeElement(_ffceb, _ddddb)
		}
	}
	if _bgbg.AlphaModFix != nil {
		_dfef := _g.StartElement{Name: _g.Name{Local: "a:alphaModFix"}}
		for _, _acga := range _bgbg.AlphaModFix {
			e.EncodeElement(_acga, _dfef)
		}
	}
	if _bgbg.AlphaRepl != nil {
		_bgf := _g.StartElement{Name: _g.Name{Local: "a:alphaRepl"}}
		for _, _age := range _bgbg.AlphaRepl {
			e.EncodeElement(_age, _bgf)
		}
	}
	if _bgbg.BiLevel != nil {
		_dffg := _g.StartElement{Name: _g.Name{Local: "a:biLevel"}}
		for _, _gcacg := range _bgbg.BiLevel {
			e.EncodeElement(_gcacg, _dffg)
		}
	}
	if _bgbg.Blur != nil {
		_aeffg := _g.StartElement{Name: _g.Name{Local: "a:blur"}}
		for _, _aafd := range _bgbg.Blur {
			e.EncodeElement(_aafd, _aeffg)
		}
	}
	if _bgbg.ClrChange != nil {
		_gaggf := _g.StartElement{Name: _g.Name{Local: "a:clrChange"}}
		for _, _agff := range _bgbg.ClrChange {
			e.EncodeElement(_agff, _gaggf)
		}
	}
	if _bgbg.ClrRepl != nil {
		_cgfeg := _g.StartElement{Name: _g.Name{Local: "a:clrRepl"}}
		for _, _eff := range _bgbg.ClrRepl {
			e.EncodeElement(_eff, _cgfeg)
		}
	}
	if _bgbg.Duotone != nil {
		_gbfc := _g.StartElement{Name: _g.Name{Local: "a:duotone"}}
		for _, _cfd := range _bgbg.Duotone {
			e.EncodeElement(_cfd, _gbfc)
		}
	}
	if _bgbg.FillOverlay != nil {
		_ggfg := _g.StartElement{Name: _g.Name{Local: "a:fillOverlay"}}
		for _, _cgaf := range _bgbg.FillOverlay {
			e.EncodeElement(_cgaf, _ggfg)
		}
	}
	if _bgbg.Grayscl != nil {
		_abbe := _g.StartElement{Name: _g.Name{Local: "a:grayscl"}}
		for _, _eabc := range _bgbg.Grayscl {
			e.EncodeElement(_eabc, _abbe)
		}
	}
	if _bgbg.Hsl != nil {
		_gdfg := _g.StartElement{Name: _g.Name{Local: "a:hsl"}}
		for _, _dcffc := range _bgbg.Hsl {
			e.EncodeElement(_dcffc, _gdfg)
		}
	}
	if _bgbg.Lum != nil {
		_ccaad := _g.StartElement{Name: _g.Name{Local: "a:lum"}}
		for _, _fedaf := range _bgbg.Lum {
			e.EncodeElement(_fedaf, _ccaad)
		}
	}
	if _bgbg.Tint != nil {
		_aeab := _g.StartElement{Name: _g.Name{Local: "a:tint"}}
		for _, _edfcf := range _bgbg.Tint {
			e.EncodeElement(_edfcf, _aeab)
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Connection and its children, prefixing error messages with path
func (_eadff *CT_Connection) ValidateWithPath(path string) error { return nil }
func (_gagda *ST_AnimationDgmBuildType) Validate() error         { return _gagda.ValidateWithPath("") }
func NewCT_TextSpacingPercent() *CT_TextSpacingPercent {
	_bbfda := &CT_TextSpacingPercent{}
	return _bbfda
}

// ValidateWithPath validates the CT_SoftEdgesEffect and its children, prefixing error messages with path
func (_aadfd *CT_SoftEdgesEffect) ValidateWithPath(path string) error {
	if _aadfd.RadAttr < 0 {
		return _dcf.Errorf("%s\u002fm\u002eRadAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _aadfd.RadAttr)
	}
	if _aadfd.RadAttr > 27273042316900 {
		return _dcf.Errorf("\u0025s\u002fm\u002eRadAttr must\u0020be \u003c\u003d\u002027273042316900\u0020\u0028have\u0020%v\u0029", path, _aadfd.RadAttr)
	}
	return nil
}
func (_eecg *CT_DefaultShapeDefinition) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_bcgba := _g.StartElement{Name: _g.Name{Local: "a:spPr"}}
	e.EncodeElement(_eecg.SpPr, _bcgba)
	_ebbd := _g.StartElement{Name: _g.Name{Local: "a:bodyPr"}}
	e.EncodeElement(_eecg.BodyPr, _ebbd)
	_aaeb := _g.StartElement{Name: _g.Name{Local: "a:lstStyle"}}
	e.EncodeElement(_eecg.LstStyle, _aaeb)
	if _eecg.Style != nil {
		_cadc := _g.StartElement{Name: _g.Name{Local: "a:style"}}
		e.EncodeElement(_eecg.Style, _cadc)
	}
	if _eecg.ExtLst != nil {
		_adca := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_eecg.ExtLst, _adca)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_dfcgg *EG_Media) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gccad:
	for {
		_dfgdg, _cfebf := d.Token()
		if _cfebf != nil {
			return _cfebf
		}
		switch _fcbdc := _dfgdg.(type) {
		case _g.StartElement:
			switch _fcbdc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "audioCd"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "audioCd"}:
				_dfcgg.AudioCd = NewCT_AudioCD()
				if _cffdf := d.DecodeElement(_dfcgg.AudioCd, &_fcbdc); _cffdf != nil {
					return _cffdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "wavAudioFile"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "wavAudioFile"}:
				_dfcgg.WavAudioFile = NewCT_EmbeddedWAVAudioFile()
				if _efgce := d.DecodeElement(_dfcgg.WavAudioFile, &_fcbdc); _efgce != nil {
					return _efgce
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "audioFile"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "audioFile"}:
				_dfcgg.AudioFile = NewCT_AudioFile()
				if _dcbff := d.DecodeElement(_dfcgg.AudioFile, &_fcbdc); _dcbff != nil {
					return _dcbff
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "videoFile"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "videoFile"}:
				_dfcgg.VideoFile = NewCT_VideoFile()
				if _dgcdg := d.DecodeElement(_dfcgg.VideoFile, &_fcbdc); _dgcdg != nil {
					return _dgcdg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "quickTimeFile"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "quickTimeFile"}:
				_dfcgg.QuickTimeFile = NewCT_QuickTimeFile()
				if _cafgf := d.DecodeElement(_dfcgg.QuickTimeFile, &_fcbdc); _cafgf != nil {
					return _cafgf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_Media\u0020\u0025v", _fcbdc.Name)
				if _dbga := d.Skip(); _dbga != nil {
					return _dbga
				}
			}
		case _g.EndElement:
			break _gccad
		case _g.CharData:
		}
	}
	return nil
}
func (_befcgf ST_LightRigType) Validate() error { return _befcgf.ValidateWithPath("") }

// Validate validates the CT_Table and its children
func (_aecbd *CT_Table) Validate() error { return _aecbd.ValidateWithPath("CT_Table") }

type CT_Path2D struct {
	WAttr           *int64
	HAttr           *int64
	FillAttr        ST_PathFillMode
	StrokeAttr      *bool
	ExtrusionOkAttr *bool
	Close           []*CT_Path2DClose
	MoveTo          []*CT_Path2DMoveTo
	LnTo            []*CT_Path2DLineTo
	ArcTo           []*CT_Path2DArcTo
	QuadBezTo       []*CT_Path2DQuadBezierTo
	CubicBezTo      []*CT_Path2DCubicBezierTo
}

func (_feefa ST_PresetLineDashVal) ValidateWithPath(path string) error {
	switch _feefa {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_feefa))
	}
	return nil
}

// ValidateWithPath validates the CT_GeomGuide and its children, prefixing error messages with path
func (_fdaae *CT_GeomGuide) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_TextSpacingPoint and its children, prefixing error messages with path
func (_decfcc *CT_TextSpacingPoint) ValidateWithPath(path string) error {
	if _decfcc.ValAttr < 0 {
		return _dcf.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _decfcc.ValAttr)
	}
	if _decfcc.ValAttr > 158400 {
		return _dcf.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003c\u003d\u0020158400 (have\u0020%v\u0029", path, _decfcc.ValAttr)
	}
	return nil
}
func (_aeabe *EG_TextRun) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _aeabe.R != nil {
		_cafbf := _g.StartElement{Name: _g.Name{Local: "a:r"}}
		e.EncodeElement(_aeabe.R, _cafbf)
	}
	if _aeabe.Br != nil {
		_baafc := _g.StartElement{Name: _g.Name{Local: "a:br"}}
		e.EncodeElement(_aeabe.Br, _baafc)
	}
	if _aeabe.Fld != nil {
		_aafca := _g.StartElement{Name: _g.Name{Local: "a:fld"}}
		e.EncodeElement(_aeabe.Fld, _aafca)
	}
	return nil
}
func NewThemeOverride() *ThemeOverride {
	_eceac := &ThemeOverride{}
	_eceac.CT_BaseStylesOverride = *NewCT_BaseStylesOverride()
	return _eceac
}
func (_bade *CT_TextBlipBullet) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_gbaba := _g.StartElement{Name: _g.Name{Local: "a:blip"}}
	e.EncodeElement(_bade.Blip, _gbaba)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TablePartStyle and its children, prefixing error messages with path
func (_bcccg *CT_TablePartStyle) ValidateWithPath(path string) error {
	if _bcccg.TcTxStyle != nil {
		if _bfbg := _bcccg.TcTxStyle.ValidateWithPath(path + "\u002fTcTxStyle"); _bfbg != nil {
			return _bfbg
		}
	}
	if _bcccg.TcStyle != nil {
		if _dabad := _bcccg.TcStyle.ValidateWithPath(path + "\u002fTcStyle"); _dabad != nil {
			return _dabad
		}
	}
	return nil
}

type ST_TextTabAlignType byte

// Validate validates the CT_TextListStyle and its children
func (_bfdbe *CT_TextListStyle) Validate() error { return _bfdbe.ValidateWithPath("CT_TextListStyle") }

// Validate validates the ThemeManager and its children
func (_bbgce *ThemeManager) Validate() error { return _bbgce.ValidateWithPath("ThemeManager") }

// ValidateWithPath validates the CT_FixedPercentage and its children, prefixing error messages with path
func (_gdgc *CT_FixedPercentage) ValidateWithPath(path string) error {
	if _cccgf := _gdgc.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _cccgf != nil {
		return _cccgf
	}
	return nil
}

// ValidateWithPath validates the CT_TableCellProperties and its children, prefixing error messages with path
func (_fcfgg *CT_TableCellProperties) ValidateWithPath(path string) error {
	if _fcfgg.MarLAttr != nil {
		if _ffddb := _fcfgg.MarLAttr.ValidateWithPath(path + "\u002fMarLAttr"); _ffddb != nil {
			return _ffddb
		}
	}
	if _fcfgg.MarRAttr != nil {
		if _aade := _fcfgg.MarRAttr.ValidateWithPath(path + "\u002fMarRAttr"); _aade != nil {
			return _aade
		}
	}
	if _fcfgg.MarTAttr != nil {
		if _gbacb := _fcfgg.MarTAttr.ValidateWithPath(path + "\u002fMarTAttr"); _gbacb != nil {
			return _gbacb
		}
	}
	if _fcfgg.MarBAttr != nil {
		if _eegd := _fcfgg.MarBAttr.ValidateWithPath(path + "\u002fMarBAttr"); _eegd != nil {
			return _eegd
		}
	}
	if _gfdage := _fcfgg.VertAttr.ValidateWithPath(path + "\u002fVertAttr"); _gfdage != nil {
		return _gfdage
	}
	if _abcbd := _fcfgg.AnchorAttr.ValidateWithPath(path + "/AnchorAttr"); _abcbd != nil {
		return _abcbd
	}
	if _aeabc := _fcfgg.HorzOverflowAttr.ValidateWithPath(path + "\u002fHorzOverflowAttr"); _aeabc != nil {
		return _aeabc
	}
	if _fcfgg.LnL != nil {
		if _gdbefe := _fcfgg.LnL.ValidateWithPath(path + "\u002fLnL"); _gdbefe != nil {
			return _gdbefe
		}
	}
	if _fcfgg.LnR != nil {
		if _aagef := _fcfgg.LnR.ValidateWithPath(path + "\u002fLnR"); _aagef != nil {
			return _aagef
		}
	}
	if _fcfgg.LnT != nil {
		if _dgcea := _fcfgg.LnT.ValidateWithPath(path + "\u002fLnT"); _dgcea != nil {
			return _dgcea
		}
	}
	if _fcfgg.LnB != nil {
		if _aefdc := _fcfgg.LnB.ValidateWithPath(path + "\u002fLnB"); _aefdc != nil {
			return _aefdc
		}
	}
	if _fcfgg.LnTlToBr != nil {
		if _eeeef := _fcfgg.LnTlToBr.ValidateWithPath(path + "\u002fLnTlToBr"); _eeeef != nil {
			return _eeeef
		}
	}
	if _fcfgg.LnBlToTr != nil {
		if _dabgef := _fcfgg.LnBlToTr.ValidateWithPath(path + "\u002fLnBlToTr"); _dabgef != nil {
			return _dabgef
		}
	}
	if _fcfgg.Cell3D != nil {
		if _dacaeb := _fcfgg.Cell3D.ValidateWithPath(path + "\u002fCell3D"); _dacaeb != nil {
			return _dacaeb
		}
	}
	if _fcfgg.NoFill != nil {
		if _ebdfe := _fcfgg.NoFill.ValidateWithPath(path + "\u002fNoFill"); _ebdfe != nil {
			return _ebdfe
		}
	}
	if _fcfgg.SolidFill != nil {
		if _ecbgf := _fcfgg.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _ecbgf != nil {
			return _ecbgf
		}
	}
	if _fcfgg.GradFill != nil {
		if _abgbe := _fcfgg.GradFill.ValidateWithPath(path + "\u002fGradFill"); _abgbe != nil {
			return _abgbe
		}
	}
	if _fcfgg.BlipFill != nil {
		if _fdfebg := _fcfgg.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _fdfebg != nil {
			return _fdfebg
		}
	}
	if _fcfgg.PattFill != nil {
		if _acdace := _fcfgg.PattFill.ValidateWithPath(path + "\u002fPattFill"); _acdace != nil {
			return _acdace
		}
	}
	if _fcfgg.GrpFill != nil {
		if _dbede := _fcfgg.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _dbede != nil {
			return _dbede
		}
	}
	if _fcfgg.Headers != nil {
		if _feab := _fcfgg.Headers.ValidateWithPath(path + "\u002fHeaders"); _feab != nil {
			return _feab
		}
	}
	if _fcfgg.ExtLst != nil {
		if _bbfbb := _fcfgg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bbfbb != nil {
			return _bbfbb
		}
	}
	return nil
}
func NewEG_Geometry() *EG_Geometry { _fgede := &EG_Geometry{}; return _fgede }

// ValidateWithPath validates the CT_TextBulletTypefaceFollowText and its children, prefixing error messages with path
func (_gaddc *CT_TextBulletTypefaceFollowText) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_EffectStyleItem and its children
func (_eedc *CT_EffectStyleItem) Validate() error {
	return _eedc.ValidateWithPath("CT_EffectStyleItem")
}

// Validate validates the CT_GradientFillProperties and its children
func (_ceee *CT_GradientFillProperties) Validate() error {
	return _ceee.ValidateWithPath("CT_GradientFillProperties")
}
func (_gggb *TblStyleLst) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "a:tblStyleLst"
	return _gggb.CT_TableStyleList.MarshalXML(e, start)
}
func (_acddb *ST_Coordinate32) ValidateWithPath(path string) error {
	_dgcba := []string{}
	if _acddb.ST_Coordinate32Unqualified != nil {
		_dgcba = append(_dgcba, "ST_Coordinate32Unqualified")
	}
	if _acddb.ST_UniversalMeasure != nil {
		_dgcba = append(_dgcba, "ST_UniversalMeasure")
	}
	if len(_dgcba) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _dgcba)
	}
	return nil
}
func (_efdfe ST_PathShadeType) Validate() error { return _efdfe.ValidateWithPath("") }
func NewCT_TextNoAutofit() *CT_TextNoAutofit    { _deegg := &CT_TextNoAutofit{}; return _deegg }

type Tbl struct{ CT_Table }

// Validate validates the CT_PresetTextShape and its children
func (_aedad *CT_PresetTextShape) Validate() error {
	return _aedad.ValidateWithPath("CT_PresetTextShape")
}

// ValidateWithPath validates the CT_ConnectionSite and its children, prefixing error messages with path
func (_babd *CT_ConnectionSite) ValidateWithPath(path string) error {
	if _afdf := _babd.AngAttr.ValidateWithPath(path + "\u002fAngAttr"); _afdf != nil {
		return _afdf
	}
	if _ccaae := _babd.Pos.ValidateWithPath(path + "\u002fPos"); _ccaae != nil {
		return _ccaae
	}
	return nil
}
func NewEG_Text3D() *EG_Text3D { _eceae := &EG_Text3D{}; return _eceae }
func NewCT_GraphicalObjectData() *CT_GraphicalObjectData {
	_fbgad := &CT_GraphicalObjectData{}
	return _fbgad
}

type CT_TextAutonumberBullet struct {
	TypeAttr    ST_TextAutonumberScheme
	StartAtAttr *int32
}

func (_faeee *CT_PolarAdjustHandle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_faeee.Pos = NewCT_AdjPoint2D()
	for _, _ebgba := range start.Attr {
		if _ebgba.Name.Local == "gdRefR" {
			_fbebb, _dafae := _ebgba.Value, error(nil)
			if _dafae != nil {
				return _dafae
			}
			_faeee.GdRefRAttr = &_fbebb
			continue
		}
		if _ebgba.Name.Local == "minR" {
			_bcggeb, _bcgebd := ParseUnionST_AdjCoordinate(_ebgba.Value)
			if _bcgebd != nil {
				return _bcgebd
			}
			_faeee.MinRAttr = &_bcggeb
			continue
		}
		if _ebgba.Name.Local == "maxR" {
			_bcef, _gbcbdd := ParseUnionST_AdjCoordinate(_ebgba.Value)
			if _gbcbdd != nil {
				return _gbcbdd
			}
			_faeee.MaxRAttr = &_bcef
			continue
		}
		if _ebgba.Name.Local == "gdRefAng" {
			_bdfgf, _acgaf := _ebgba.Value, error(nil)
			if _acgaf != nil {
				return _acgaf
			}
			_faeee.GdRefAngAttr = &_bdfgf
			continue
		}
		if _ebgba.Name.Local == "minAng" {
			_ccbdf, _fagae := ParseUnionST_AdjAngle(_ebgba.Value)
			if _fagae != nil {
				return _fagae
			}
			_faeee.MinAngAttr = &_ccbdf
			continue
		}
		if _ebgba.Name.Local == "maxAng" {
			_dbaf, _ecaa := ParseUnionST_AdjAngle(_ebgba.Value)
			if _ecaa != nil {
				return _ecaa
			}
			_faeee.MaxAngAttr = &_dbaf
			continue
		}
	}
_gcfbb:
	for {
		_cbded, _gbgcd := d.Token()
		if _gbgcd != nil {
			return _gbgcd
		}
		switch _bddcf := _cbded.(type) {
		case _g.StartElement:
			switch _bddcf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pos"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pos"}:
				if _aadd := d.DecodeElement(_faeee.Pos, &_bddcf); _aadd != nil {
					return _aadd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_PolarAdjustHandle\u0020\u0025v", _bddcf.Name)
				if _aecfd := d.Skip(); _aecfd != nil {
					return _aecfd
				}
			}
		case _g.EndElement:
			break _gcfbb
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_QuickTimeFile and its children
func (_fadec *CT_QuickTimeFile) Validate() error { return _fadec.ValidateWithPath("CT_QuickTimeFile") }

type CT_DashStop struct {
	DAttr  ST_PositivePercentage
	SpAttr ST_PositivePercentage
}
type CT_RegularTextRun struct {
	RPr *CT_TextCharacterProperties
	T   string
}

// Validate validates the CT_Bevel and its children
func (_gabe *CT_Bevel) Validate() error { return _gabe.ValidateWithPath("CT_Bevel") }

// Validate validates the CT_ColorMRU and its children
func (_fdbf *CT_ColorMRU) Validate() error { return _fdbf.ValidateWithPath("CT_ColorMRU") }

// ValidateWithPath validates the CT_Point2D and its children, prefixing error messages with path
func (_feef *CT_Point2D) ValidateWithPath(path string) error {
	if _begbf := _feef.XAttr.ValidateWithPath(path + "\u002fXAttr"); _begbf != nil {
		return _begbf
	}
	if _eecag := _feef.YAttr.ValidateWithPath(path + "\u002fYAttr"); _eecag != nil {
		return _eecag
	}
	return nil
}
func (_cecg *CT_TableCol) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "w"}, Value: _dcf.Sprintf("\u0025v", _cecg.WAttr)})
	e.EncodeToken(start)
	if _cecg.ExtLst != nil {
		_fdcg := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_cecg.ExtLst, _fdcg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_EmbeddedWAVAudioFile and its children, prefixing error messages with path
func (_gfcgd *CT_EmbeddedWAVAudioFile) ValidateWithPath(path string) error { return nil }
func (_cbabb *CT_GeomRect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "l"}, Value: _dcf.Sprintf("\u0025v", _cbabb.LAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "t"}, Value: _dcf.Sprintf("\u0025v", _cbabb.TAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r"}, Value: _dcf.Sprintf("\u0025v", _cbabb.RAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "b"}, Value: _dcf.Sprintf("\u0025v", _cbabb.BAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TableCell and its children, prefixing error messages with path
func (_adbdf *CT_TableCell) ValidateWithPath(path string) error {
	if _adbdf.TxBody != nil {
		if _agecb := _adbdf.TxBody.ValidateWithPath(path + "\u002fTxBody"); _agecb != nil {
			return _agecb
		}
	}
	if _adbdf.TcPr != nil {
		if _dbefe := _adbdf.TcPr.ValidateWithPath(path + "\u002fTcPr"); _dbefe != nil {
			return _dbefe
		}
	}
	if _adbdf.ExtLst != nil {
		if _fedbc := _adbdf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fedbc != nil {
			return _fedbc
		}
	}
	return nil
}
func NewCT_EmptyElement() *CT_EmptyElement { _abcg := &CT_EmptyElement{}; return _abcg }

const (
	ST_TextFontAlignTypeUnset ST_TextFontAlignType = 0
	ST_TextFontAlignTypeAuto  ST_TextFontAlignType = 1
	ST_TextFontAlignTypeT     ST_TextFontAlignType = 2
	ST_TextFontAlignTypeCtr   ST_TextFontAlignType = 3
	ST_TextFontAlignTypeBase  ST_TextFontAlignType = 4
	ST_TextFontAlignTypeB     ST_TextFontAlignType = 5
)

func NewCT_TablePartStyle() *CT_TablePartStyle { _aaagf := &CT_TablePartStyle{}; return _aaagf }

type CT_Path2DList struct{ Path []*CT_Path2D }

// Validate validates the CT_Path2DCubicBezierTo and its children
func (_bbeg *CT_Path2DCubicBezierTo) Validate() error {
	return _bbeg.ValidateWithPath("CT_Path2DCubicBezierTo")
}

// ValidateWithPath validates the ThemeOverride and its children, prefixing error messages with path
func (_efcbf *ThemeOverride) ValidateWithPath(path string) error {
	if _edabac := _efcbf.CT_BaseStylesOverride.ValidateWithPath(path); _edabac != nil {
		return _edabac
	}
	return nil
}
func (_gfdf *CT_Shape3D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _gfdf.ZAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "z"}, Value: _dcf.Sprintf("\u0025v", *_gfdf.ZAttr)})
	}
	if _gfdf.ExtrusionHAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "extrusionH"}, Value: _dcf.Sprintf("\u0025v", *_gfdf.ExtrusionHAttr)})
	}
	if _gfdf.ContourWAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "contourW"}, Value: _dcf.Sprintf("\u0025v", *_gfdf.ContourWAttr)})
	}
	if _gfdf.PrstMaterialAttr != ST_PresetMaterialTypeUnset {
		_bbfcb, _afbga := _gfdf.PrstMaterialAttr.MarshalXMLAttr(_g.Name{Local: "prstMaterial"})
		if _afbga != nil {
			return _afbga
		}
		start.Attr = append(start.Attr, _bbfcb)
	}
	e.EncodeToken(start)
	if _gfdf.BevelT != nil {
		_fbecf := _g.StartElement{Name: _g.Name{Local: "a:bevelT"}}
		e.EncodeElement(_gfdf.BevelT, _fbecf)
	}
	if _gfdf.BevelB != nil {
		_eadc := _g.StartElement{Name: _g.Name{Local: "a:bevelB"}}
		e.EncodeElement(_gfdf.BevelB, _eadc)
	}
	if _gfdf.ExtrusionClr != nil {
		_fadegf := _g.StartElement{Name: _g.Name{Local: "a:extrusionClr"}}
		e.EncodeElement(_gfdf.ExtrusionClr, _fadegf)
	}
	if _gfdf.ContourClr != nil {
		_feddd := _g.StartElement{Name: _g.Name{Local: "a:contourClr"}}
		e.EncodeElement(_gfdf.ContourClr, _feddd)
	}
	if _gfdf.ExtLst != nil {
		_agffeb := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_gfdf.ExtLst, _agffeb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_acbdb ST_LineEndLength) Validate() error { return _acbdb.ValidateWithPath("") }
func NewCT_GvmlConnector() *CT_GvmlConnector {
	_efee := &CT_GvmlConnector{}
	_efee.NvCxnSpPr = NewCT_GvmlConnectorNonVisual()
	_efee.SpPr = NewCT_ShapeProperties()
	return _efee
}

type CT_GammaTransform struct{}

func (_gbbbc *ST_TextStrikeType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_acbcgc, _eadfc := d.Token()
	if _eadfc != nil {
		return _eadfc
	}
	if _edege, _beefba := _acbcgc.(_g.EndElement); _beefba && _edege.Name == start.Name {
		*_gbbbc = 1
		return nil
	}
	if _ccaef, _fgcbe := _acbcgc.(_g.CharData); !_fgcbe {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _acbcgc)
	} else {
		switch string(_ccaef) {
		case "":
			*_gbbbc = 0
		case "noStrike":
			*_gbbbc = 1
		case "sngStrike":
			*_gbbbc = 2
		case "dblStrike":
			*_gbbbc = 3
		}
	}
	_acbcgc, _eadfc = d.Token()
	if _eadfc != nil {
		return _eadfc
	}
	if _fagce, _eebgb := _acbcgc.(_g.EndElement); _eebgb && _fagce.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _acbcgc)
}
func (_bge *CT_AlphaBiLevelEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "thresh"}, Value: _dcf.Sprintf("\u0025v", _bge.ThreshAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_EffectContainer and its children, prefixing error messages with path
func (_afcdb *CT_EffectContainer) ValidateWithPath(path string) error {
	if _baffb := _afcdb.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _baffb != nil {
		return _baffb
	}
	if _afcdb.Cont != nil {
		if _eacd := _afcdb.Cont.ValidateWithPath(path + "\u002fCont"); _eacd != nil {
			return _eacd
		}
	}
	if _afcdb.Effect != nil {
		if _eddgc := _afcdb.Effect.ValidateWithPath(path + "\u002fEffect"); _eddgc != nil {
			return _eddgc
		}
	}
	if _afcdb.AlphaBiLevel != nil {
		if _gdea := _afcdb.AlphaBiLevel.ValidateWithPath(path + "\u002fAlphaBiLevel"); _gdea != nil {
			return _gdea
		}
	}
	if _afcdb.AlphaCeiling != nil {
		if _ebbc := _afcdb.AlphaCeiling.ValidateWithPath(path + "\u002fAlphaCeiling"); _ebbc != nil {
			return _ebbc
		}
	}
	if _afcdb.AlphaFloor != nil {
		if _agdef := _afcdb.AlphaFloor.ValidateWithPath(path + "/AlphaFloor"); _agdef != nil {
			return _agdef
		}
	}
	if _afcdb.AlphaInv != nil {
		if _faef := _afcdb.AlphaInv.ValidateWithPath(path + "\u002fAlphaInv"); _faef != nil {
			return _faef
		}
	}
	if _afcdb.AlphaMod != nil {
		if _ebgb := _afcdb.AlphaMod.ValidateWithPath(path + "\u002fAlphaMod"); _ebgb != nil {
			return _ebgb
		}
	}
	if _afcdb.AlphaModFix != nil {
		if _cebf := _afcdb.AlphaModFix.ValidateWithPath(path + "\u002fAlphaModFix"); _cebf != nil {
			return _cebf
		}
	}
	if _afcdb.AlphaOutset != nil {
		if _bgdfb := _afcdb.AlphaOutset.ValidateWithPath(path + "\u002fAlphaOutset"); _bgdfb != nil {
			return _bgdfb
		}
	}
	if _afcdb.AlphaRepl != nil {
		if _efed := _afcdb.AlphaRepl.ValidateWithPath(path + "\u002fAlphaRepl"); _efed != nil {
			return _efed
		}
	}
	if _afcdb.BiLevel != nil {
		if _ecbc := _afcdb.BiLevel.ValidateWithPath(path + "\u002fBiLevel"); _ecbc != nil {
			return _ecbc
		}
	}
	if _afcdb.Blend != nil {
		if _dedbd := _afcdb.Blend.ValidateWithPath(path + "\u002fBlend"); _dedbd != nil {
			return _dedbd
		}
	}
	if _afcdb.Blur != nil {
		if _gfbf := _afcdb.Blur.ValidateWithPath(path + "\u002fBlur"); _gfbf != nil {
			return _gfbf
		}
	}
	if _afcdb.ClrChange != nil {
		if _ecgc := _afcdb.ClrChange.ValidateWithPath(path + "\u002fClrChange"); _ecgc != nil {
			return _ecgc
		}
	}
	if _afcdb.ClrRepl != nil {
		if _gbaga := _afcdb.ClrRepl.ValidateWithPath(path + "\u002fClrRepl"); _gbaga != nil {
			return _gbaga
		}
	}
	if _afcdb.Duotone != nil {
		if _fbebf := _afcdb.Duotone.ValidateWithPath(path + "\u002fDuotone"); _fbebf != nil {
			return _fbebf
		}
	}
	if _afcdb.Fill != nil {
		if _dabef := _afcdb.Fill.ValidateWithPath(path + "\u002fFill"); _dabef != nil {
			return _dabef
		}
	}
	if _afcdb.FillOverlay != nil {
		if _bcce := _afcdb.FillOverlay.ValidateWithPath(path + "\u002fFillOverlay"); _bcce != nil {
			return _bcce
		}
	}
	if _afcdb.Glow != nil {
		if _eddca := _afcdb.Glow.ValidateWithPath(path + "\u002fGlow"); _eddca != nil {
			return _eddca
		}
	}
	if _afcdb.Grayscl != nil {
		if _cedb := _afcdb.Grayscl.ValidateWithPath(path + "\u002fGrayscl"); _cedb != nil {
			return _cedb
		}
	}
	if _afcdb.Hsl != nil {
		if _dfbed := _afcdb.Hsl.ValidateWithPath(path + "\u002fHsl"); _dfbed != nil {
			return _dfbed
		}
	}
	if _afcdb.InnerShdw != nil {
		if _gbaaa := _afcdb.InnerShdw.ValidateWithPath(path + "\u002fInnerShdw"); _gbaaa != nil {
			return _gbaaa
		}
	}
	if _afcdb.Lum != nil {
		if _cede := _afcdb.Lum.ValidateWithPath(path + "\u002fLum"); _cede != nil {
			return _cede
		}
	}
	if _afcdb.OuterShdw != nil {
		if _afae := _afcdb.OuterShdw.ValidateWithPath(path + "\u002fOuterShdw"); _afae != nil {
			return _afae
		}
	}
	if _afcdb.PrstShdw != nil {
		if _cgaa := _afcdb.PrstShdw.ValidateWithPath(path + "\u002fPrstShdw"); _cgaa != nil {
			return _cgaa
		}
	}
	if _afcdb.Reflection != nil {
		if _dbacf := _afcdb.Reflection.ValidateWithPath(path + "/Reflection"); _dbacf != nil {
			return _dbacf
		}
	}
	if _afcdb.RelOff != nil {
		if _fbga := _afcdb.RelOff.ValidateWithPath(path + "\u002fRelOff"); _fbga != nil {
			return _fbga
		}
	}
	if _afcdb.SoftEdge != nil {
		if _dfda := _afcdb.SoftEdge.ValidateWithPath(path + "\u002fSoftEdge"); _dfda != nil {
			return _dfda
		}
	}
	if _afcdb.Tint != nil {
		if _dcffce := _afcdb.Tint.ValidateWithPath(path + "\u002fTint"); _dcffce != nil {
			return _dcffce
		}
	}
	if _afcdb.Xfrm != nil {
		if _cecdb := _afcdb.Xfrm.ValidateWithPath(path + "\u002fXfrm"); _cecdb != nil {
			return _cecdb
		}
	}
	return nil
}
func (_gaegb ST_LineCap) Validate() error { return _gaegb.ValidateWithPath("") }
func (_ggeafg *ST_TextVertOverflowType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_egcdc, _cagefa := d.Token()
	if _cagefa != nil {
		return _cagefa
	}
	if _egbce, _efcfg := _egcdc.(_g.EndElement); _efcfg && _egbce.Name == start.Name {
		*_ggeafg = 1
		return nil
	}
	if _ecegf, _daedd := _egcdc.(_g.CharData); !_daedd {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _egcdc)
	} else {
		switch string(_ecegf) {
		case "":
			*_ggeafg = 0
		case "overflow":
			*_ggeafg = 1
		case "ellipsis":
			*_ggeafg = 2
		case "clip":
			*_ggeafg = 3
		}
	}
	_egcdc, _cagefa = d.Token()
	if _cagefa != nil {
		return _cagefa
	}
	if _beeeb, _effbac := _egcdc.(_g.EndElement); _effbac && _beeeb.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _egcdc)
}
func (_ddabd *ST_TextWrappingType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_ddabd = 0
	case "none":
		*_ddabd = 1
	case "square":
		*_ddabd = 2
	}
	return nil
}

// Validate validates the CT_LineStyleList and its children
func (_bcdegf *CT_LineStyleList) Validate() error {
	return _bcdegf.ValidateWithPath("CT_LineStyleList")
}
func (_gefeb ST_EffectContainerType) String() string {
	switch _gefeb {
	case 0:
		return ""
	case 1:
		return "sib"
	case 2:
		return "tree"
	}
	return ""
}
func (_abcgd *ST_PresetShadowVal) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_abcgd = 0
	case "shdw1":
		*_abcgd = 1
	case "shdw2":
		*_abcgd = 2
	case "shdw3":
		*_abcgd = 3
	case "shdw4":
		*_abcgd = 4
	case "shdw5":
		*_abcgd = 5
	case "shdw6":
		*_abcgd = 6
	case "shdw7":
		*_abcgd = 7
	case "shdw8":
		*_abcgd = 8
	case "shdw9":
		*_abcgd = 9
	case "shdw10":
		*_abcgd = 10
	case "shdw11":
		*_abcgd = 11
	case "shdw12":
		*_abcgd = 12
	case "shdw13":
		*_abcgd = 13
	case "shdw14":
		*_abcgd = 14
	case "shdw15":
		*_abcgd = 15
	case "shdw16":
		*_abcgd = 16
	case "shdw17":
		*_abcgd = 17
	case "shdw18":
		*_abcgd = 18
	case "shdw19":
		*_abcgd = 19
	case "shdw20":
		*_abcgd = 20
	}
	return nil
}

type CT_PictureLocking struct {
	NoCropAttr             *bool
	ExtLst                 *CT_OfficeArtExtensionList
	NoGrpAttr              *bool
	NoSelectAttr           *bool
	NoRotAttr              *bool
	NoChangeAspectAttr     *bool
	NoMoveAttr             *bool
	NoResizeAttr           *bool
	NoEditPointsAttr       *bool
	NoAdjustHandlesAttr    *bool
	NoChangeArrowheadsAttr *bool
	NoChangeShapeTypeAttr  *bool
}

func NewThemeManager() *ThemeManager {
	_ebfag := &ThemeManager{}
	_ebfag.CT_EmptyElement = *NewCT_EmptyElement()
	return _ebfag
}
func (_daaf ST_TextStrikeType) ValidateWithPath(path string) error {
	switch _daaf {
	case 0, 1, 2, 3:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_daaf))
	}
	return nil
}
func NewCT_ColorMappingOverrideChoice() *CT_ColorMappingOverrideChoice {
	_fgde := &CT_ColorMappingOverrideChoice{}
	return _fgde
}

// Validate validates the CT_BlendEffect and its children
func (_dbd *CT_BlendEffect) Validate() error { return _dbd.ValidateWithPath("CT_BlendEffect") }
func (_ddcgg ST_Percentage) String() string {
	if _ddcgg.ST_PercentageDecimal != nil {
		return _dcf.Sprintf("\u0025v", *_ddcgg.ST_PercentageDecimal)
	}
	if _ddcgg.ST_Percentage != nil {
		return _dcf.Sprintf("\u0025v", *_ddcgg.ST_Percentage)
	}
	return ""
}

// Validate validates the CT_DashStopList and its children
func (_aeage *CT_DashStopList) Validate() error { return _aeage.ValidateWithPath("CT_DashStopList") }

// ValidateWithPath validates the CT_TextUnderlineLineFollowText and its children, prefixing error messages with path
func (_bbcca *CT_TextUnderlineLineFollowText) ValidateWithPath(path string) error { return nil }

const (
	ST_PresetColorValUnset                ST_PresetColorVal = 0
	ST_PresetColorValAliceBlue            ST_PresetColorVal = 1
	ST_PresetColorValAntiqueWhite         ST_PresetColorVal = 2
	ST_PresetColorValAqua                 ST_PresetColorVal = 3
	ST_PresetColorValAquamarine           ST_PresetColorVal = 4
	ST_PresetColorValAzure                ST_PresetColorVal = 5
	ST_PresetColorValBeige                ST_PresetColorVal = 6
	ST_PresetColorValBisque               ST_PresetColorVal = 7
	ST_PresetColorValBlack                ST_PresetColorVal = 8
	ST_PresetColorValBlanchedAlmond       ST_PresetColorVal = 9
	ST_PresetColorValBlue                 ST_PresetColorVal = 10
	ST_PresetColorValBlueViolet           ST_PresetColorVal = 11
	ST_PresetColorValBrown                ST_PresetColorVal = 12
	ST_PresetColorValBurlyWood            ST_PresetColorVal = 13
	ST_PresetColorValCadetBlue            ST_PresetColorVal = 14
	ST_PresetColorValChartreuse           ST_PresetColorVal = 15
	ST_PresetColorValChocolate            ST_PresetColorVal = 16
	ST_PresetColorValCoral                ST_PresetColorVal = 17
	ST_PresetColorValCornflowerBlue       ST_PresetColorVal = 18
	ST_PresetColorValCornsilk             ST_PresetColorVal = 19
	ST_PresetColorValCrimson              ST_PresetColorVal = 20
	ST_PresetColorValCyan                 ST_PresetColorVal = 21
	ST_PresetColorValDarkBlue             ST_PresetColorVal = 22
	ST_PresetColorValDarkCyan             ST_PresetColorVal = 23
	ST_PresetColorValDarkGoldenrod        ST_PresetColorVal = 24
	ST_PresetColorValDarkGray             ST_PresetColorVal = 25
	ST_PresetColorValDarkGrey             ST_PresetColorVal = 26
	ST_PresetColorValDarkGreen            ST_PresetColorVal = 27
	ST_PresetColorValDarkKhaki            ST_PresetColorVal = 28
	ST_PresetColorValDarkMagenta          ST_PresetColorVal = 29
	ST_PresetColorValDarkOliveGreen       ST_PresetColorVal = 30
	ST_PresetColorValDarkOrange           ST_PresetColorVal = 31
	ST_PresetColorValDarkOrchid           ST_PresetColorVal = 32
	ST_PresetColorValDarkRed              ST_PresetColorVal = 33
	ST_PresetColorValDarkSalmon           ST_PresetColorVal = 34
	ST_PresetColorValDarkSeaGreen         ST_PresetColorVal = 35
	ST_PresetColorValDarkSlateBlue        ST_PresetColorVal = 36
	ST_PresetColorValDarkSlateGray        ST_PresetColorVal = 37
	ST_PresetColorValDarkSlateGrey        ST_PresetColorVal = 38
	ST_PresetColorValDarkTurquoise        ST_PresetColorVal = 39
	ST_PresetColorValDarkViolet           ST_PresetColorVal = 40
	ST_PresetColorValDkBlue               ST_PresetColorVal = 41
	ST_PresetColorValDkCyan               ST_PresetColorVal = 42
	ST_PresetColorValDkGoldenrod          ST_PresetColorVal = 43
	ST_PresetColorValDkGray               ST_PresetColorVal = 44
	ST_PresetColorValDkGrey               ST_PresetColorVal = 45
	ST_PresetColorValDkGreen              ST_PresetColorVal = 46
	ST_PresetColorValDkKhaki              ST_PresetColorVal = 47
	ST_PresetColorValDkMagenta            ST_PresetColorVal = 48
	ST_PresetColorValDkOliveGreen         ST_PresetColorVal = 49
	ST_PresetColorValDkOrange             ST_PresetColorVal = 50
	ST_PresetColorValDkOrchid             ST_PresetColorVal = 51
	ST_PresetColorValDkRed                ST_PresetColorVal = 52
	ST_PresetColorValDkSalmon             ST_PresetColorVal = 53
	ST_PresetColorValDkSeaGreen           ST_PresetColorVal = 54
	ST_PresetColorValDkSlateBlue          ST_PresetColorVal = 55
	ST_PresetColorValDkSlateGray          ST_PresetColorVal = 56
	ST_PresetColorValDkSlateGrey          ST_PresetColorVal = 57
	ST_PresetColorValDkTurquoise          ST_PresetColorVal = 58
	ST_PresetColorValDkViolet             ST_PresetColorVal = 59
	ST_PresetColorValDeepPink             ST_PresetColorVal = 60
	ST_PresetColorValDeepSkyBlue          ST_PresetColorVal = 61
	ST_PresetColorValDimGray              ST_PresetColorVal = 62
	ST_PresetColorValDimGrey              ST_PresetColorVal = 63
	ST_PresetColorValDodgerBlue           ST_PresetColorVal = 64
	ST_PresetColorValFirebrick            ST_PresetColorVal = 65
	ST_PresetColorValFloralWhite          ST_PresetColorVal = 66
	ST_PresetColorValForestGreen          ST_PresetColorVal = 67
	ST_PresetColorValFuchsia              ST_PresetColorVal = 68
	ST_PresetColorValGainsboro            ST_PresetColorVal = 69
	ST_PresetColorValGhostWhite           ST_PresetColorVal = 70
	ST_PresetColorValGold                 ST_PresetColorVal = 71
	ST_PresetColorValGoldenrod            ST_PresetColorVal = 72
	ST_PresetColorValGray                 ST_PresetColorVal = 73
	ST_PresetColorValGrey                 ST_PresetColorVal = 74
	ST_PresetColorValGreen                ST_PresetColorVal = 75
	ST_PresetColorValGreenYellow          ST_PresetColorVal = 76
	ST_PresetColorValHoneydew             ST_PresetColorVal = 77
	ST_PresetColorValHotPink              ST_PresetColorVal = 78
	ST_PresetColorValIndianRed            ST_PresetColorVal = 79
	ST_PresetColorValIndigo               ST_PresetColorVal = 80
	ST_PresetColorValIvory                ST_PresetColorVal = 81
	ST_PresetColorValKhaki                ST_PresetColorVal = 82
	ST_PresetColorValLavender             ST_PresetColorVal = 83
	ST_PresetColorValLavenderBlush        ST_PresetColorVal = 84
	ST_PresetColorValLawnGreen            ST_PresetColorVal = 85
	ST_PresetColorValLemonChiffon         ST_PresetColorVal = 86
	ST_PresetColorValLightBlue            ST_PresetColorVal = 87
	ST_PresetColorValLightCoral           ST_PresetColorVal = 88
	ST_PresetColorValLightCyan            ST_PresetColorVal = 89
	ST_PresetColorValLightGoldenrodYellow ST_PresetColorVal = 90
	ST_PresetColorValLightGray            ST_PresetColorVal = 91
	ST_PresetColorValLightGrey            ST_PresetColorVal = 92
	ST_PresetColorValLightGreen           ST_PresetColorVal = 93
	ST_PresetColorValLightPink            ST_PresetColorVal = 94
	ST_PresetColorValLightSalmon          ST_PresetColorVal = 95
	ST_PresetColorValLightSeaGreen        ST_PresetColorVal = 96
	ST_PresetColorValLightSkyBlue         ST_PresetColorVal = 97
	ST_PresetColorValLightSlateGray       ST_PresetColorVal = 98
	ST_PresetColorValLightSlateGrey       ST_PresetColorVal = 99
	ST_PresetColorValLightSteelBlue       ST_PresetColorVal = 100
	ST_PresetColorValLightYellow          ST_PresetColorVal = 101
	ST_PresetColorValLtBlue               ST_PresetColorVal = 102
	ST_PresetColorValLtCoral              ST_PresetColorVal = 103
	ST_PresetColorValLtCyan               ST_PresetColorVal = 104
	ST_PresetColorValLtGoldenrodYellow    ST_PresetColorVal = 105
	ST_PresetColorValLtGray               ST_PresetColorVal = 106
	ST_PresetColorValLtGrey               ST_PresetColorVal = 107
	ST_PresetColorValLtGreen              ST_PresetColorVal = 108
	ST_PresetColorValLtPink               ST_PresetColorVal = 109
	ST_PresetColorValLtSalmon             ST_PresetColorVal = 110
	ST_PresetColorValLtSeaGreen           ST_PresetColorVal = 111
	ST_PresetColorValLtSkyBlue            ST_PresetColorVal = 112
	ST_PresetColorValLtSlateGray          ST_PresetColorVal = 113
	ST_PresetColorValLtSlateGrey          ST_PresetColorVal = 114
	ST_PresetColorValLtSteelBlue          ST_PresetColorVal = 115
	ST_PresetColorValLtYellow             ST_PresetColorVal = 116
	ST_PresetColorValLime                 ST_PresetColorVal = 117
	ST_PresetColorValLimeGreen            ST_PresetColorVal = 118
	ST_PresetColorValLinen                ST_PresetColorVal = 119
	ST_PresetColorValMagenta              ST_PresetColorVal = 120
	ST_PresetColorValMaroon               ST_PresetColorVal = 121
	ST_PresetColorValMedAquamarine        ST_PresetColorVal = 122
	ST_PresetColorValMedBlue              ST_PresetColorVal = 123
	ST_PresetColorValMedOrchid            ST_PresetColorVal = 124
	ST_PresetColorValMedPurple            ST_PresetColorVal = 125
	ST_PresetColorValMedSeaGreen          ST_PresetColorVal = 126
	ST_PresetColorValMedSlateBlue         ST_PresetColorVal = 127
	ST_PresetColorValMedSpringGreen       ST_PresetColorVal = 128
	ST_PresetColorValMedTurquoise         ST_PresetColorVal = 129
	ST_PresetColorValMedVioletRed         ST_PresetColorVal = 130
	ST_PresetColorValMediumAquamarine     ST_PresetColorVal = 131
	ST_PresetColorValMediumBlue           ST_PresetColorVal = 132
	ST_PresetColorValMediumOrchid         ST_PresetColorVal = 133
	ST_PresetColorValMediumPurple         ST_PresetColorVal = 134
	ST_PresetColorValMediumSeaGreen       ST_PresetColorVal = 135
	ST_PresetColorValMediumSlateBlue      ST_PresetColorVal = 136
	ST_PresetColorValMediumSpringGreen    ST_PresetColorVal = 137
	ST_PresetColorValMediumTurquoise      ST_PresetColorVal = 138
	ST_PresetColorValMediumVioletRed      ST_PresetColorVal = 139
	ST_PresetColorValMidnightBlue         ST_PresetColorVal = 140
	ST_PresetColorValMintCream            ST_PresetColorVal = 141
	ST_PresetColorValMistyRose            ST_PresetColorVal = 142
	ST_PresetColorValMoccasin             ST_PresetColorVal = 143
	ST_PresetColorValNavajoWhite          ST_PresetColorVal = 144
	ST_PresetColorValNavy                 ST_PresetColorVal = 145
	ST_PresetColorValOldLace              ST_PresetColorVal = 146
	ST_PresetColorValOlive                ST_PresetColorVal = 147
	ST_PresetColorValOliveDrab            ST_PresetColorVal = 148
	ST_PresetColorValOrange               ST_PresetColorVal = 149
	ST_PresetColorValOrangeRed            ST_PresetColorVal = 150
	ST_PresetColorValOrchid               ST_PresetColorVal = 151
	ST_PresetColorValPaleGoldenrod        ST_PresetColorVal = 152
	ST_PresetColorValPaleGreen            ST_PresetColorVal = 153
	ST_PresetColorValPaleTurquoise        ST_PresetColorVal = 154
	ST_PresetColorValPaleVioletRed        ST_PresetColorVal = 155
	ST_PresetColorValPapayaWhip           ST_PresetColorVal = 156
	ST_PresetColorValPeachPuff            ST_PresetColorVal = 157
	ST_PresetColorValPeru                 ST_PresetColorVal = 158
	ST_PresetColorValPink                 ST_PresetColorVal = 159
	ST_PresetColorValPlum                 ST_PresetColorVal = 160
	ST_PresetColorValPowderBlue           ST_PresetColorVal = 161
	ST_PresetColorValPurple               ST_PresetColorVal = 162
	ST_PresetColorValRed                  ST_PresetColorVal = 163
	ST_PresetColorValRosyBrown            ST_PresetColorVal = 164
	ST_PresetColorValRoyalBlue            ST_PresetColorVal = 165
	ST_PresetColorValSaddleBrown          ST_PresetColorVal = 166
	ST_PresetColorValSalmon               ST_PresetColorVal = 167
	ST_PresetColorValSandyBrown           ST_PresetColorVal = 168
	ST_PresetColorValSeaGreen             ST_PresetColorVal = 169
	ST_PresetColorValSeaShell             ST_PresetColorVal = 170
	ST_PresetColorValSienna               ST_PresetColorVal = 171
	ST_PresetColorValSilver               ST_PresetColorVal = 172
	ST_PresetColorValSkyBlue              ST_PresetColorVal = 173
	ST_PresetColorValSlateBlue            ST_PresetColorVal = 174
	ST_PresetColorValSlateGray            ST_PresetColorVal = 175
	ST_PresetColorValSlateGrey            ST_PresetColorVal = 176
	ST_PresetColorValSnow                 ST_PresetColorVal = 177
	ST_PresetColorValSpringGreen          ST_PresetColorVal = 178
	ST_PresetColorValSteelBlue            ST_PresetColorVal = 179
	ST_PresetColorValTan                  ST_PresetColorVal = 180
	ST_PresetColorValTeal                 ST_PresetColorVal = 181
	ST_PresetColorValThistle              ST_PresetColorVal = 182
	ST_PresetColorValTomato               ST_PresetColorVal = 183
	ST_PresetColorValTurquoise            ST_PresetColorVal = 184
	ST_PresetColorValViolet               ST_PresetColorVal = 185
	ST_PresetColorValWheat                ST_PresetColorVal = 186
	ST_PresetColorValWhite                ST_PresetColorVal = 187
	ST_PresetColorValWhiteSmoke           ST_PresetColorVal = 188
	ST_PresetColorValYellow               ST_PresetColorVal = 189
	ST_PresetColorValYellowGreen          ST_PresetColorVal = 190
)

func (_aecgd *CT_TextBody) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_cfgg := _g.StartElement{Name: _g.Name{Local: "a:bodyPr"}}
	e.EncodeElement(_aecgd.BodyPr, _cfgg)
	if _aecgd.LstStyle != nil {
		_becbe := _g.StartElement{Name: _g.Name{Local: "a:lstStyle"}}
		e.EncodeElement(_aecgd.LstStyle, _becbe)
	}
	_fccgc := _g.StartElement{Name: _g.Name{Local: "a:p"}}
	for _, _cacad := range _aecgd.P {
		e.EncodeElement(_cacad, _fccgc)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

const (
	ST_PresetLineDashValUnset         ST_PresetLineDashVal = 0
	ST_PresetLineDashValSolid         ST_PresetLineDashVal = 1
	ST_PresetLineDashValDot           ST_PresetLineDashVal = 2
	ST_PresetLineDashValDash          ST_PresetLineDashVal = 3
	ST_PresetLineDashValLgDash        ST_PresetLineDashVal = 4
	ST_PresetLineDashValDashDot       ST_PresetLineDashVal = 5
	ST_PresetLineDashValLgDashDot     ST_PresetLineDashVal = 6
	ST_PresetLineDashValLgDashDotDot  ST_PresetLineDashVal = 7
	ST_PresetLineDashValSysDash       ST_PresetLineDashVal = 8
	ST_PresetLineDashValSysDot        ST_PresetLineDashVal = 9
	ST_PresetLineDashValSysDashDot    ST_PresetLineDashVal = 10
	ST_PresetLineDashValSysDashDotDot ST_PresetLineDashVal = 11
)

// ValidateWithPath validates the CT_EffectProperties and its children, prefixing error messages with path
func (_ddcd *CT_EffectProperties) ValidateWithPath(path string) error {
	if _ddcd.EffectLst != nil {
		if _cedag := _ddcd.EffectLst.ValidateWithPath(path + "\u002fEffectLst"); _cedag != nil {
			return _cedag
		}
	}
	if _ddcd.EffectDag != nil {
		if _cbgb := _ddcd.EffectDag.ValidateWithPath(path + "\u002fEffectDag"); _cbgb != nil {
			return _cbgb
		}
	}
	return nil
}
func (_fegf *CT_TablePropertiesChoice) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fegf.TableStyle != nil {
		_fbadc := _g.StartElement{Name: _g.Name{Local: "a:tableStyle"}}
		e.EncodeElement(_fegf.TableStyle, _fbadc)
	}
	if _fegf.TableStyleId != nil {
		_dbccgb := _g.StartElement{Name: _g.Name{Local: "a:tableStyleId"}}
		_ee.AddPreserveSpaceAttr(&_dbccgb, *_fegf.TableStyleId)
		e.EncodeElement(_fegf.TableStyleId, _dbccgb)
	}
	return nil
}
func (_ebdc *CT_SRgbColor) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", _ebdc.ValAttr)})
	e.EncodeToken(start)
	if _ebdc.EG_ColorTransform != nil {
		for _, _ggga := range _ebdc.EG_ColorTransform {
			_ggga.MarshalXML(e, _g.StartElement{})
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ColorMRU and its children, prefixing error messages with path
func (_ceaa *CT_ColorMRU) ValidateWithPath(path string) error {
	for _cgbc, _abfe := range _ceaa.EG_ColorChoice {
		if _aadc := _abfe.ValidateWithPath(_dcf.Sprintf("%s\u002fEG_ColorChoice\u005b\u0025d\u005d", path, _cgbc)); _aadc != nil {
			return _aadc
		}
	}
	return nil
}
func (_dfcfa *CT_LineEndProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _cdabg := range start.Attr {
		if _cdabg.Name.Local == "type" {
			_dfcfa.TypeAttr.UnmarshalXMLAttr(_cdabg)
			continue
		}
		if _cdabg.Name.Local == "w" {
			_dfcfa.WAttr.UnmarshalXMLAttr(_cdabg)
			continue
		}
		if _cdabg.Name.Local == "len" {
			_dfcfa.LenAttr.UnmarshalXMLAttr(_cdabg)
			continue
		}
	}
	for {
		_fcafg, _gedfa := d.Token()
		if _gedfa != nil {
			return _dcf.Errorf("parsing\u0020CT_LineEndProperties:\u0020\u0025s", _gedfa)
		}
		if _adda, _fadcc := _fcafg.(_g.EndElement); _fadcc && _adda.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_TextShapeAutofit and its children
func (_adfaf *CT_TextShapeAutofit) Validate() error {
	return _adfaf.ValidateWithPath("CT_TextShapeAutofit")
}

// ValidateWithPath validates the EG_TextBulletColor and its children, prefixing error messages with path
func (_fdgbf *EG_TextBulletColor) ValidateWithPath(path string) error {
	if _fdgbf.BuClrTx != nil {
		if _dfgdee := _fdgbf.BuClrTx.ValidateWithPath(path + "\u002fBuClrTx"); _dfgdee != nil {
			return _dfgdee
		}
	}
	if _fdgbf.BuClr != nil {
		if _gfaaf := _fdgbf.BuClr.ValidateWithPath(path + "\u002fBuClr"); _gfaaf != nil {
			return _gfaaf
		}
	}
	return nil
}
func (_fcded *CT_GvmlShapeNonVisual) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fcded.CNvPr = NewCT_NonVisualDrawingProps()
	_fcded.CNvSpPr = NewCT_NonVisualDrawingShapeProps()
_dbbe:
	for {
		_gdeee, _adce := d.Token()
		if _adce != nil {
			return _adce
		}
		switch _accad := _gdeee.(type) {
		case _g.StartElement:
			switch _accad.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cNvPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cNvPr"}:
				if _efcgg := d.DecodeElement(_fcded.CNvPr, &_accad); _efcgg != nil {
					return _efcgg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cNvSpPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cNvSpPr"}:
				if _fdgf := d.DecodeElement(_fcded.CNvSpPr, &_accad); _fdgf != nil {
					return _fdgf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_GvmlShapeNonVisual\u0020\u0025v", _accad.Name)
				if _cdfec := d.Skip(); _cdfec != nil {
					return _cdfec
				}
			}
		case _g.EndElement:
			break _dbbe
		case _g.CharData:
		}
	}
	return nil
}
func (_acbef *CT_TextSpacingPoint) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", _acbef.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TextNormalAutofit and its children
func (_addgf *CT_TextNormalAutofit) Validate() error {
	return _addgf.ValidateWithPath("CT_TextNormalAutofit")
}

type CT_Boolean struct{ ValAttr *_f.ST_OnOff }

func NewCT_GvmlConnectorNonVisual() *CT_GvmlConnectorNonVisual {
	_fcce := &CT_GvmlConnectorNonVisual{}
	_fcce.CNvPr = NewCT_NonVisualDrawingProps()
	_fcce.CNvCxnSpPr = NewCT_NonVisualConnectorProperties()
	return _fcce
}
func (_dcada *CT_Hyperlink) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dcada.IdAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r:id"}, Value: _dcf.Sprintf("\u0025v", *_dcada.IdAttr)})
	}
	if _dcada.InvalidUrlAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "invalidUrl"}, Value: _dcf.Sprintf("\u0025v", *_dcada.InvalidUrlAttr)})
	}
	if _dcada.ActionAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "action"}, Value: _dcf.Sprintf("\u0025v", *_dcada.ActionAttr)})
	}
	if _dcada.TgtFrameAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "tgtFrame"}, Value: _dcf.Sprintf("\u0025v", *_dcada.TgtFrameAttr)})
	}
	if _dcada.TooltipAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "tooltip"}, Value: _dcf.Sprintf("\u0025v", *_dcada.TooltipAttr)})
	}
	if _dcada.HistoryAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "history"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcada.HistoryAttr))})
	}
	if _dcada.HighlightClickAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "highlightClick"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcada.HighlightClickAttr))})
	}
	if _dcada.EndSndAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "endSnd"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcada.EndSndAttr))})
	}
	e.EncodeToken(start)
	if _dcada.Snd != nil {
		_bdac := _g.StartElement{Name: _g.Name{Local: "a:snd"}}
		e.EncodeElement(_dcada.Snd, _bdac)
	}
	if _dcada.ExtLst != nil {
		_afdb := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dcada.ExtLst, _afdb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ffefdg *EG_FillModeProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _ffefdg.Tile != nil {
		_cccba := _g.StartElement{Name: _g.Name{Local: "a:tile"}}
		e.EncodeElement(_ffefdg.Tile, _cccba)
	}
	if _ffefdg.Stretch != nil {
		_fffba := _g.StartElement{Name: _g.Name{Local: "a:stretch"}}
		e.EncodeElement(_ffefdg.Stretch, _fffba)
	}
	return nil
}
func (_facf *CT_FillOverlayEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_gbcce, _gbgbf := _facf.BlendAttr.MarshalXMLAttr(_g.Name{Local: "blend"})
	if _gbgbf != nil {
		return _gbgbf
	}
	start.Attr = append(start.Attr, _gbcce)
	e.EncodeToken(start)
	if _facf.NoFill != nil {
		_bbcf := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_facf.NoFill, _bbcf)
	}
	if _facf.SolidFill != nil {
		_ggec := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_facf.SolidFill, _ggec)
	}
	if _facf.GradFill != nil {
		_dfacd := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_facf.GradFill, _dfacd)
	}
	if _facf.BlipFill != nil {
		_dagd := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
		e.EncodeElement(_facf.BlipFill, _dagd)
	}
	if _facf.PattFill != nil {
		_debe := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_facf.PattFill, _debe)
	}
	if _facf.GrpFill != nil {
		_dfca := _g.StartElement{Name: _g.Name{Local: "a:grpFill"}}
		e.EncodeElement(_facf.GrpFill, _dfca)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_afbe *CT_FlatText) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fgdg := range start.Attr {
		if _fgdg.Name.Local == "z" {
			_daef, _gdae := ParseUnionST_Coordinate(_fgdg.Value)
			if _gdae != nil {
				return _gdae
			}
			_afbe.ZAttr = &_daef
			continue
		}
	}
	for {
		_edg, _cgegg := d.Token()
		if _cgegg != nil {
			return _dcf.Errorf("parsing\u0020CT_FlatText:\u0020\u0025s", _cgegg)
		}
		if _fdefd, _fgbac := _edg.(_g.EndElement); _fgbac && _fdefd.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Scene3D struct {
	Camera   *CT_Camera
	LightRig *CT_LightRig
	Backdrop *CT_Backdrop
	ExtLst   *CT_OfficeArtExtensionList
}

func (_bcfbf *CT_PresetGeometry2D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bcfbf.PrstAttr = ST_ShapeType(1)
	for _, _degbd := range start.Attr {
		if _degbd.Name.Local == "prst" {
			_bcfbf.PrstAttr.UnmarshalXMLAttr(_degbd)
			continue
		}
	}
_beaeb:
	for {
		_dcgae, _ebgd := d.Token()
		if _ebgd != nil {
			return _ebgd
		}
		switch _eeeab := _dcgae.(type) {
		case _g.StartElement:
			switch _eeeab.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "avLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "avLst"}:
				_bcfbf.AvLst = NewCT_GeomGuideList()
				if _fdag := d.DecodeElement(_bcfbf.AvLst, &_eeeab); _fdag != nil {
					return _fdag
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PresetGeometry2D\u0020\u0025v", _eeeab.Name)
				if _ggagc := d.Skip(); _ggagc != nil {
					return _ggagc
				}
			}
		case _g.EndElement:
			break _beaeb
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_TextListStyle() *CT_TextListStyle { _dadfba := &CT_TextListStyle{}; return _dadfba }
func NewCT_Vector3D() *CT_Vector3D           { _fbfbc := &CT_Vector3D{}; return _fbfbc }
func (_bfdg *CT_ColorScheme) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bfdg.Dk1 = NewCT_Color()
	_bfdg.Lt1 = NewCT_Color()
	_bfdg.Dk2 = NewCT_Color()
	_bfdg.Lt2 = NewCT_Color()
	_bfdg.Accent1 = NewCT_Color()
	_bfdg.Accent2 = NewCT_Color()
	_bfdg.Accent3 = NewCT_Color()
	_bfdg.Accent4 = NewCT_Color()
	_bfdg.Accent5 = NewCT_Color()
	_bfdg.Accent6 = NewCT_Color()
	_bfdg.Hlink = NewCT_Color()
	_bfdg.FolHlink = NewCT_Color()
	for _, _agbg := range start.Attr {
		if _agbg.Name.Local == "name" {
			_fcgef, _geca := _agbg.Value, error(nil)
			if _geca != nil {
				return _geca
			}
			_bfdg.NameAttr = _fcgef
			continue
		}
	}
_ggbb:
	for {
		_ccbd, _dbaee := d.Token()
		if _dbaee != nil {
			return _dbaee
		}
		switch _egbga := _ccbd.(type) {
		case _g.StartElement:
			switch _egbga.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "dk1"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "dk1"}:
				if _fcc := d.DecodeElement(_bfdg.Dk1, &_egbga); _fcc != nil {
					return _fcc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lt1"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lt1"}:
				if _afdg := d.DecodeElement(_bfdg.Lt1, &_egbga); _afdg != nil {
					return _afdg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "dk2"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "dk2"}:
				if _bacge := d.DecodeElement(_bfdg.Dk2, &_egbga); _bacge != nil {
					return _bacge
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lt2"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lt2"}:
				if _fdce := d.DecodeElement(_bfdg.Lt2, &_egbga); _fdce != nil {
					return _fdce
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "accent1"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "accent1"}:
				if _eefbf := d.DecodeElement(_bfdg.Accent1, &_egbga); _eefbf != nil {
					return _eefbf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "accent2"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "accent2"}:
				if _aaag := d.DecodeElement(_bfdg.Accent2, &_egbga); _aaag != nil {
					return _aaag
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "accent3"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "accent3"}:
				if _afegg := d.DecodeElement(_bfdg.Accent3, &_egbga); _afegg != nil {
					return _afegg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "accent4"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "accent4"}:
				if _efcd := d.DecodeElement(_bfdg.Accent4, &_egbga); _efcd != nil {
					return _efcd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "accent5"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "accent5"}:
				if _afdgg := d.DecodeElement(_bfdg.Accent5, &_egbga); _afdgg != nil {
					return _afdgg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "accent6"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "accent6"}:
				if _facce := d.DecodeElement(_bfdg.Accent6, &_egbga); _facce != nil {
					return _facce
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hlink"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hlink"}:
				if _adad := d.DecodeElement(_bfdg.Hlink, &_egbga); _adad != nil {
					return _adad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "folHlink"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "folHlink"}:
				if _ddac := d.DecodeElement(_bfdg.FolHlink, &_egbga); _ddac != nil {
					return _ddac
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_bfdg.ExtLst = NewCT_OfficeArtExtensionList()
				if _dafe := d.DecodeElement(_bfdg.ExtLst, &_egbga); _dafe != nil {
					return _dafe
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ColorScheme\u0020\u0025v", _egbga.Name)
				if _bcgcad := d.Skip(); _bcgcad != nil {
					return _bcgcad
				}
			}
		case _g.EndElement:
			break _ggbb
		case _g.CharData:
		}
	}
	return nil
}

type CT_AlphaModulateEffect struct{ Cont *CT_EffectContainer }

// Validate validates the CT_BaseStylesOverride and its children
func (_gdfc *CT_BaseStylesOverride) Validate() error {
	return _gdfc.ValidateWithPath("CT_BaseStylesOverride")
}

// Validate validates the CT_TextUnderlineFillFollowText and its children
func (_deecca *CT_TextUnderlineFillFollowText) Validate() error {
	return _deecca.ValidateWithPath("CT_TextUnderlineFillFollowText")
}

// ValidateWithPath validates the CT_ColorSchemeList and its children, prefixing error messages with path
func (_bbcd *CT_ColorSchemeList) ValidateWithPath(path string) error {
	for _bbbcd, _eceg := range _bbcd.ExtraClrScheme {
		if _gfcba := _eceg.ValidateWithPath(_dcf.Sprintf("%s\u002fExtraClrScheme\u005b\u0025d\u005d", path, _bbbcd)); _gfcba != nil {
			return _gfcba
		}
	}
	return nil
}

type CT_GvmlTextShape struct {
	TxBody *CT_TextBody
	Choice *CT_GvmlTextShapeChoice
	ExtLst *CT_OfficeArtExtensionList
}

func (_dgacc *CT_FixedPercentage) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", _dgacc.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_eafda ST_TextWrappingType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_eafda.String(), start)
}
func (_ddcaa *CT_DashStopList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _ddcaa.Ds != nil {
		_fgge := _g.StartElement{Name: _g.Name{Local: "a:ds"}}
		for _, _bbde := range _ddcaa.Ds {
			e.EncodeElement(_bbde, _fgge)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_affgef *ST_LineEndLength) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_affgef = 0
	case "sm":
		*_affgef = 1
	case "med":
		*_affgef = 2
	case "lg":
		*_affgef = 3
	}
	return nil
}

type CT_TextBlipBullet struct{ Blip *CT_Blip }

func (_dgcbe *ST_AnimationChartBuildType) Validate() error { return _dgcbe.ValidateWithPath("") }
func (_dedcc *ST_TextAnchoringType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_abbbce, _ffccd := d.Token()
	if _ffccd != nil {
		return _ffccd
	}
	if _ecbff, _fgaff := _abbbce.(_g.EndElement); _fgaff && _ecbff.Name == start.Name {
		*_dedcc = 1
		return nil
	}
	if _cbfcd, _efacbb := _abbbce.(_g.CharData); !_efacbb {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _abbbce)
	} else {
		switch string(_cbfcd) {
		case "":
			*_dedcc = 0
		case "t":
			*_dedcc = 1
		case "ctr":
			*_dedcc = 2
		case "b":
			*_dedcc = 3
		case "just":
			*_dedcc = 4
		case "dist":
			*_dedcc = 5
		}
	}
	_abbbce, _ffccd = d.Token()
	if _ffccd != nil {
		return _ffccd
	}
	if _aeegd, _fafec := _abbbce.(_g.EndElement); _fafec && _aeegd.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _abbbce)
}

// ValidateWithPath validates the Blip and its children, prefixing error messages with path
func (_geg *Blip) ValidateWithPath(path string) error {
	if _fb := _geg.CT_Blip.ValidateWithPath(path); _fb != nil {
		return _fb
	}
	return nil
}
func (_dagaa ST_BlackWhiteMode) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_faafa := _g.Attr{}
	_faafa.Name = name
	switch _dagaa {
	case ST_BlackWhiteModeUnset:
		_faafa.Value = ""
	case ST_BlackWhiteModeClr:
		_faafa.Value = "clr"
	case ST_BlackWhiteModeAuto:
		_faafa.Value = "auto"
	case ST_BlackWhiteModeGray:
		_faafa.Value = "gray"
	case ST_BlackWhiteModeLtGray:
		_faafa.Value = "ltGray"
	case ST_BlackWhiteModeInvGray:
		_faafa.Value = "invGray"
	case ST_BlackWhiteModeGrayWhite:
		_faafa.Value = "grayWhite"
	case ST_BlackWhiteModeBlackGray:
		_faafa.Value = "blackGray"
	case ST_BlackWhiteModeBlackWhite:
		_faafa.Value = "blackWhite"
	case ST_BlackWhiteModeBlack:
		_faafa.Value = "black"
	case ST_BlackWhiteModeWhite:
		_faafa.Value = "white"
	case ST_BlackWhiteModeHidden:
		_faafa.Value = "hidden"
	}
	return _faafa, nil
}

// ValidateWithPath validates the EG_ColorTransform and its children, prefixing error messages with path
func (_afecbc *EG_ColorTransform) ValidateWithPath(path string) error {
	if _afecbc.Tint != nil {
		if _ggcdbg := _afecbc.Tint.ValidateWithPath(path + "\u002fTint"); _ggcdbg != nil {
			return _ggcdbg
		}
	}
	if _afecbc.Shade != nil {
		if _faabg := _afecbc.Shade.ValidateWithPath(path + "\u002fShade"); _faabg != nil {
			return _faabg
		}
	}
	if _afecbc.Comp != nil {
		if _gefdea := _afecbc.Comp.ValidateWithPath(path + "\u002fComp"); _gefdea != nil {
			return _gefdea
		}
	}
	if _afecbc.Inv != nil {
		if _gabce := _afecbc.Inv.ValidateWithPath(path + "\u002fInv"); _gabce != nil {
			return _gabce
		}
	}
	if _afecbc.Gray != nil {
		if _dgee := _afecbc.Gray.ValidateWithPath(path + "\u002fGray"); _dgee != nil {
			return _dgee
		}
	}
	if _afecbc.Alpha != nil {
		if _aebca := _afecbc.Alpha.ValidateWithPath(path + "\u002fAlpha"); _aebca != nil {
			return _aebca
		}
	}
	if _afecbc.AlphaOff != nil {
		if _gadc := _afecbc.AlphaOff.ValidateWithPath(path + "\u002fAlphaOff"); _gadc != nil {
			return _gadc
		}
	}
	if _afecbc.AlphaMod != nil {
		if _egedf := _afecbc.AlphaMod.ValidateWithPath(path + "\u002fAlphaMod"); _egedf != nil {
			return _egedf
		}
	}
	if _afecbc.Hue != nil {
		if _gccbb := _afecbc.Hue.ValidateWithPath(path + "\u002fHue"); _gccbb != nil {
			return _gccbb
		}
	}
	if _afecbc.HueOff != nil {
		if _ecfga := _afecbc.HueOff.ValidateWithPath(path + "\u002fHueOff"); _ecfga != nil {
			return _ecfga
		}
	}
	if _afecbc.HueMod != nil {
		if _ffff := _afecbc.HueMod.ValidateWithPath(path + "\u002fHueMod"); _ffff != nil {
			return _ffff
		}
	}
	if _afecbc.Sat != nil {
		if _eaagb := _afecbc.Sat.ValidateWithPath(path + "\u002fSat"); _eaagb != nil {
			return _eaagb
		}
	}
	if _afecbc.SatOff != nil {
		if _cfadf := _afecbc.SatOff.ValidateWithPath(path + "\u002fSatOff"); _cfadf != nil {
			return _cfadf
		}
	}
	if _afecbc.SatMod != nil {
		if _bgdcfe := _afecbc.SatMod.ValidateWithPath(path + "\u002fSatMod"); _bgdcfe != nil {
			return _bgdcfe
		}
	}
	if _afecbc.Lum != nil {
		if _bcggc := _afecbc.Lum.ValidateWithPath(path + "\u002fLum"); _bcggc != nil {
			return _bcggc
		}
	}
	if _afecbc.LumOff != nil {
		if _dcacc := _afecbc.LumOff.ValidateWithPath(path + "\u002fLumOff"); _dcacc != nil {
			return _dcacc
		}
	}
	if _afecbc.LumMod != nil {
		if _fagee := _afecbc.LumMod.ValidateWithPath(path + "\u002fLumMod"); _fagee != nil {
			return _fagee
		}
	}
	if _afecbc.Red != nil {
		if _gcfec := _afecbc.Red.ValidateWithPath(path + "\u002fRed"); _gcfec != nil {
			return _gcfec
		}
	}
	if _afecbc.RedOff != nil {
		if _gaged := _afecbc.RedOff.ValidateWithPath(path + "\u002fRedOff"); _gaged != nil {
			return _gaged
		}
	}
	if _afecbc.RedMod != nil {
		if _baaac := _afecbc.RedMod.ValidateWithPath(path + "\u002fRedMod"); _baaac != nil {
			return _baaac
		}
	}
	if _afecbc.Green != nil {
		if _afecad := _afecbc.Green.ValidateWithPath(path + "\u002fGreen"); _afecad != nil {
			return _afecad
		}
	}
	if _afecbc.GreenOff != nil {
		if _fegc := _afecbc.GreenOff.ValidateWithPath(path + "\u002fGreenOff"); _fegc != nil {
			return _fegc
		}
	}
	if _afecbc.GreenMod != nil {
		if _gdaae := _afecbc.GreenMod.ValidateWithPath(path + "\u002fGreenMod"); _gdaae != nil {
			return _gdaae
		}
	}
	if _afecbc.Blue != nil {
		if _cbdfb := _afecbc.Blue.ValidateWithPath(path + "\u002fBlue"); _cbdfb != nil {
			return _cbdfb
		}
	}
	if _afecbc.BlueOff != nil {
		if _dagagd := _afecbc.BlueOff.ValidateWithPath(path + "\u002fBlueOff"); _dagagd != nil {
			return _dagagd
		}
	}
	if _afecbc.BlueMod != nil {
		if _bdgdfd := _afecbc.BlueMod.ValidateWithPath(path + "\u002fBlueMod"); _bdgdfd != nil {
			return _bdgdfd
		}
	}
	if _afecbc.Gamma != nil {
		if _edcaf := _afecbc.Gamma.ValidateWithPath(path + "\u002fGamma"); _edcaf != nil {
			return _edcaf
		}
	}
	if _afecbc.InvGamma != nil {
		if _agdggg := _afecbc.InvGamma.ValidateWithPath(path + "\u002fInvGamma"); _agdggg != nil {
			return _agdggg
		}
	}
	return nil
}
func (_gffgb *ST_TextHorzOverflowType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_gffgb = 0
	case "overflow":
		*_gffgb = 1
	case "clip":
		*_gffgb = 2
	}
	return nil
}

type CT_ThemeableLineStyle struct {
	Ln    *CT_LineProperties
	LnRef *CT_StyleMatrixReference
}

func (_febffe ST_AnimationChartBuildType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _febffe.ST_AnimationBuildType != ST_AnimationBuildTypeUnset {
		e.EncodeToken(_g.CharData(_febffe.ST_AnimationBuildType.String()))
	}
	if _febffe.ST_AnimationChartOnlyBuildType != ST_AnimationChartOnlyBuildTypeUnset {
		e.EncodeToken(_g.CharData(_febffe.ST_AnimationChartOnlyBuildType.String()))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

// Validate validates the CT_TextTabStop and its children
func (_gceae *CT_TextTabStop) Validate() error { return _gceae.ValidateWithPath("CT_TextTabStop") }
func (_cecd *CT_ColorMRU) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_dbcfg:
	for {
		_caaaf, _beca := d.Token()
		if _beca != nil {
			return _beca
		}
		switch _dafdg := _caaaf.(type) {
		case _g.StartElement:
			switch _dafdg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_addd := NewEG_ColorChoice()
				_addd.ScrgbClr = NewCT_ScRgbColor()
				if _eedf := d.DecodeElement(_addd.ScrgbClr, &_dafdg); _eedf != nil {
					return _eedf
				}
				_cecd.EG_ColorChoice = append(_cecd.EG_ColorChoice, _addd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_dbdb := NewEG_ColorChoice()
				_dbdb.SrgbClr = NewCT_SRgbColor()
				if _dcfeg := d.DecodeElement(_dbdb.SrgbClr, &_dafdg); _dcfeg != nil {
					return _dcfeg
				}
				_cecd.EG_ColorChoice = append(_cecd.EG_ColorChoice, _dbdb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_effc := NewEG_ColorChoice()
				_effc.HslClr = NewCT_HslColor()
				if _eeedc := d.DecodeElement(_effc.HslClr, &_dafdg); _eeedc != nil {
					return _eeedc
				}
				_cecd.EG_ColorChoice = append(_cecd.EG_ColorChoice, _effc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_edce := NewEG_ColorChoice()
				_edce.SysClr = NewCT_SystemColor()
				if _afca := d.DecodeElement(_edce.SysClr, &_dafdg); _afca != nil {
					return _afca
				}
				_cecd.EG_ColorChoice = append(_cecd.EG_ColorChoice, _edce)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_abgd := NewEG_ColorChoice()
				_abgd.SchemeClr = NewCT_SchemeColor()
				if _aaeg := d.DecodeElement(_abgd.SchemeClr, &_dafdg); _aaeg != nil {
					return _aaeg
				}
				_cecd.EG_ColorChoice = append(_cecd.EG_ColorChoice, _abgd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_dada := NewEG_ColorChoice()
				_dada.PrstClr = NewCT_PresetColor()
				if _aaed := d.DecodeElement(_dada.PrstClr, &_dafdg); _aaed != nil {
					return _aaed
				}
				_cecd.EG_ColorChoice = append(_cecd.EG_ColorChoice, _dada)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ColorMRU\u0020\u0025v", _dafdg.Name)
				if _efgd := d.Skip(); _efgd != nil {
					return _efgd
				}
			}
		case _g.EndElement:
			break _dbcfg
		case _g.CharData:
		}
	}
	return nil
}

type CT_NonVisualDrawingProps struct {
	IdAttr     uint32
	NameAttr   string
	DescrAttr  *string
	HiddenAttr *bool
	TitleAttr  *string
	HlinkClick *CT_Hyperlink
	HlinkHover *CT_Hyperlink
	ExtLst     *CT_OfficeArtExtensionList
}

func (_fagbg *ST_ChartBuildStep) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bbaf, _dbggg := d.Token()
	if _dbggg != nil {
		return _dbggg
	}
	if _cgdaa, _ggedf := _bbaf.(_g.EndElement); _ggedf && _cgdaa.Name == start.Name {
		*_fagbg = 1
		return nil
	}
	if _fbbeg, _agfag := _bbaf.(_g.CharData); !_agfag {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bbaf)
	} else {
		switch string(_fbbeg) {
		case "":
			*_fagbg = 0
		case "category":
			*_fagbg = 1
		case "ptInCategory":
			*_fagbg = 2
		case "series":
			*_fagbg = 3
		case "ptInSeries":
			*_fagbg = 4
		case "allPts":
			*_fagbg = 5
		case "gridLegend":
			*_fagbg = 6
		}
	}
	_bbaf, _dbggg = d.Token()
	if _dbggg != nil {
		return _dbggg
	}
	if _fcbef, _dacdf := _bbaf.(_g.EndElement); _dacdf && _fcbef.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bbaf)
}

type ST_AnimationDgmOnlyBuildType byte

func (_dfafc *EG_ColorChoice) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fddaaf:
	for {
		_baffg, _egeea := d.Token()
		if _egeea != nil {
			return _egeea
		}
		switch _aafbg := _baffg.(type) {
		case _g.StartElement:
			switch _aafbg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_dfafc.ScrgbClr = NewCT_ScRgbColor()
				if _cgcdb := d.DecodeElement(_dfafc.ScrgbClr, &_aafbg); _cgcdb != nil {
					return _cgcdb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_dfafc.SrgbClr = NewCT_SRgbColor()
				if _bgffc := d.DecodeElement(_dfafc.SrgbClr, &_aafbg); _bgffc != nil {
					return _bgffc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_dfafc.HslClr = NewCT_HslColor()
				if _deebd := d.DecodeElement(_dfafc.HslClr, &_aafbg); _deebd != nil {
					return _deebd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_dfafc.SysClr = NewCT_SystemColor()
				if _eegdb := d.DecodeElement(_dfafc.SysClr, &_aafbg); _eegdb != nil {
					return _eegdb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_dfafc.SchemeClr = NewCT_SchemeColor()
				if _daebf := d.DecodeElement(_dfafc.SchemeClr, &_aafbg); _daebf != nil {
					return _daebf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_dfafc.PrstClr = NewCT_PresetColor()
				if _cabbc := d.DecodeElement(_dfafc.PrstClr, &_aafbg); _cabbc != nil {
					return _cabbc
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_ColorChoice\u0020\u0025v", _aafbg.Name)
				if _abffc := d.Skip(); _abffc != nil {
					return _abffc
				}
			}
		case _g.EndElement:
			break _fddaaf
		case _g.CharData:
		}
	}
	return nil
}
func (_efecc ST_LineEndWidth) String() string {
	switch _efecc {
	case 0:
		return ""
	case 1:
		return "sm"
	case 2:
		return "med"
	case 3:
		return "lg"
	}
	return ""
}
func NewCT_TextUnderlineFillFollowText() *CT_TextUnderlineFillFollowText {
	_bffce := &CT_TextUnderlineFillFollowText{}
	return _bffce
}
func (_ecdfc ST_LineEndWidth) Validate() error { return _ecdfc.ValidateWithPath("") }

const (
	ST_AnimationChartOnlyBuildTypeUnset      ST_AnimationChartOnlyBuildType = 0
	ST_AnimationChartOnlyBuildTypeSeries     ST_AnimationChartOnlyBuildType = 1
	ST_AnimationChartOnlyBuildTypeCategory   ST_AnimationChartOnlyBuildType = 2
	ST_AnimationChartOnlyBuildTypeSeriesEl   ST_AnimationChartOnlyBuildType = 3
	ST_AnimationChartOnlyBuildTypeCategoryEl ST_AnimationChartOnlyBuildType = 4
)

// ValidateWithPath validates the TblStyleLst and its children, prefixing error messages with path
func (_cccad *TblStyleLst) ValidateWithPath(path string) error {
	if _ecbda := _cccad.CT_TableStyleList.ValidateWithPath(path); _ecbda != nil {
		return _ecbda
	}
	return nil
}

// Validate validates the CT_GvmlGroupShapeNonVisual and its children
func (_ffabde *CT_GvmlGroupShapeNonVisual) Validate() error {
	return _ffabde.ValidateWithPath("CT_GvmlGroupShapeNonVisual")
}
func (_fbcc *CT_ColorReplaceEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_bdbe:
	for {
		_cee, _caggf := d.Token()
		if _caggf != nil {
			return _caggf
		}
		switch _abff := _cee.(type) {
		case _g.StartElement:
			switch _abff.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_fbcc.ScrgbClr = NewCT_ScRgbColor()
				if _fbcb := d.DecodeElement(_fbcc.ScrgbClr, &_abff); _fbcb != nil {
					return _fbcb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_fbcc.SrgbClr = NewCT_SRgbColor()
				if _cgae := d.DecodeElement(_fbcc.SrgbClr, &_abff); _cgae != nil {
					return _cgae
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_fbcc.HslClr = NewCT_HslColor()
				if _gfffd := d.DecodeElement(_fbcc.HslClr, &_abff); _gfffd != nil {
					return _gfffd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_fbcc.SysClr = NewCT_SystemColor()
				if _gbeg := d.DecodeElement(_fbcc.SysClr, &_abff); _gbeg != nil {
					return _gbeg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_fbcc.SchemeClr = NewCT_SchemeColor()
				if _cbd := d.DecodeElement(_fbcc.SchemeClr, &_abff); _cbd != nil {
					return _cbd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_fbcc.PrstClr = NewCT_PresetColor()
				if _cbge := d.DecodeElement(_fbcc.PrstClr, &_abff); _cbge != nil {
					return _cbge
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_ColorReplaceEffect\u0020\u0025v", _abff.Name)
				if _eeaa := d.Skip(); _eeaa != nil {
					return _eeaa
				}
			}
		case _g.EndElement:
			break _bdbe
		case _g.CharData:
		}
	}
	return nil
}

type ST_AnimationChartOnlyBuildType byte

func (_fgcacf ST_TextTabAlignType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_efdfg := _g.Attr{}
	_efdfg.Name = name
	switch _fgcacf {
	case ST_TextTabAlignTypeUnset:
		_efdfg.Value = ""
	case ST_TextTabAlignTypeL:
		_efdfg.Value = "l"
	case ST_TextTabAlignTypeCtr:
		_efdfg.Value = "ctr"
	case ST_TextTabAlignTypeR:
		_efdfg.Value = "r"
	case ST_TextTabAlignTypeDec:
		_efdfg.Value = "dec"
	}
	return _efdfg, nil
}

// ValidateWithPath validates the EG_LineFillProperties and its children, prefixing error messages with path
func (_caac *EG_LineFillProperties) ValidateWithPath(path string) error {
	if _caac.NoFill != nil {
		if _cfdaa := _caac.NoFill.ValidateWithPath(path + "\u002fNoFill"); _cfdaa != nil {
			return _cfdaa
		}
	}
	if _caac.SolidFill != nil {
		if _dfceb := _caac.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _dfceb != nil {
			return _dfceb
		}
	}
	if _caac.GradFill != nil {
		if _fadag := _caac.GradFill.ValidateWithPath(path + "\u002fGradFill"); _fadag != nil {
			return _fadag
		}
	}
	if _caac.PattFill != nil {
		if _eaaee := _caac.PattFill.ValidateWithPath(path + "\u002fPattFill"); _eaaee != nil {
			return _eaaee
		}
	}
	return nil
}

// ValidateWithPath validates the CT_GammaTransform and its children, prefixing error messages with path
func (_eade *CT_GammaTransform) ValidateWithPath(path string) error { return nil }

type ST_LineCap byte

// ValidateWithPath validates the CT_BackgroundFormatting and its children, prefixing error messages with path
func (_geab *CT_BackgroundFormatting) ValidateWithPath(path string) error {
	if _geab.NoFill != nil {
		if _bda := _geab.NoFill.ValidateWithPath(path + "\u002fNoFill"); _bda != nil {
			return _bda
		}
	}
	if _geab.SolidFill != nil {
		if _gfbg := _geab.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _gfbg != nil {
			return _gfbg
		}
	}
	if _geab.GradFill != nil {
		if _ddc := _geab.GradFill.ValidateWithPath(path + "\u002fGradFill"); _ddc != nil {
			return _ddc
		}
	}
	if _geab.BlipFill != nil {
		if _acf := _geab.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _acf != nil {
			return _acf
		}
	}
	if _geab.PattFill != nil {
		if _agf := _geab.PattFill.ValidateWithPath(path + "\u002fPattFill"); _agf != nil {
			return _agf
		}
	}
	if _geab.GrpFill != nil {
		if _egccb := _geab.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _egccb != nil {
			return _egccb
		}
	}
	if _geab.EffectLst != nil {
		if _bcgf := _geab.EffectLst.ValidateWithPath(path + "\u002fEffectLst"); _bcgf != nil {
			return _bcgf
		}
	}
	if _geab.EffectDag != nil {
		if _cdfd := _geab.EffectDag.ValidateWithPath(path + "\u002fEffectDag"); _cdfd != nil {
			return _cdfd
		}
	}
	return nil
}
func (_dfgdd ST_LightRigDirection) ValidateWithPath(path string) error {
	switch _dfgdd {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dfgdd))
	}
	return nil
}

// ValidateWithPath validates the CT_ComplementTransform and its children, prefixing error messages with path
func (_bagfe *CT_ComplementTransform) ValidateWithPath(path string) error { return nil }

type CT_FixedPercentage struct{ ValAttr ST_FixedPercentage }

func NewEG_TextUnderlineFill() *EG_TextUnderlineFill {
	_cggefb := &EG_TextUnderlineFill{}
	return _cggefb
}
func (_afacf *CT_SolidColorFillProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_beebebg:
	for {
		_cgaef, _gccggb := d.Token()
		if _gccggb != nil {
			return _gccggb
		}
		switch _babad := _cgaef.(type) {
		case _g.StartElement:
			switch _babad.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_afacf.ScrgbClr = NewCT_ScRgbColor()
				if _gfgae := d.DecodeElement(_afacf.ScrgbClr, &_babad); _gfgae != nil {
					return _gfgae
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_afacf.SrgbClr = NewCT_SRgbColor()
				if _febga := d.DecodeElement(_afacf.SrgbClr, &_babad); _febga != nil {
					return _febga
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_afacf.HslClr = NewCT_HslColor()
				if _egacb := d.DecodeElement(_afacf.HslClr, &_babad); _egacb != nil {
					return _egacb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_afacf.SysClr = NewCT_SystemColor()
				if _efffa := d.DecodeElement(_afacf.SysClr, &_babad); _efffa != nil {
					return _efffa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_afacf.SchemeClr = NewCT_SchemeColor()
				if _bdafc := d.DecodeElement(_afacf.SchemeClr, &_babad); _bdafc != nil {
					return _bdafc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_afacf.PrstClr = NewCT_PresetColor()
				if _ddbba := d.DecodeElement(_afacf.PrstClr, &_babad); _ddbba != nil {
					return _ddbba
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SolidColorFillProperties\u0020\u0025v", _babad.Name)
				if _addbe := d.Skip(); _addbe != nil {
					return _addbe
				}
			}
		case _g.EndElement:
			break _beebebg
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_Scale2D() *CT_Scale2D {
	_bgbea := &CT_Scale2D{}
	_bgbea.Sx = NewCT_Ratio()
	_bgbea.Sy = NewCT_Ratio()
	return _bgbea
}
func (_eegdf *CT_TextBulletColorFollowText) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type ST_EffectContainerType byte

func (_cafd ST_PitchFamily) String() string {
	switch _cafd {
	case 0:
		return ""
	case 1:
		return "00"
	case 2:
		return "01"
	case 3:
		return "02"
	case 4:
		return "16"
	case 5:
		return "17"
	case 6:
		return "18"
	case 7:
		return "32"
	case 8:
		return "33"
	case 9:
		return "34"
	case 10:
		return "48"
	case 11:
		return "49"
	case 12:
		return "50"
	case 13:
		return "64"
	case 14:
		return "65"
	case 15:
		return "66"
	case 16:
		return "80"
	case 17:
		return "81"
	case 18:
		return "82"
	}
	return ""
}
func (_aacbef *EG_Geometry) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_efagbe:
	for {
		_ggggf, _eddgb := d.Token()
		if _eddgb != nil {
			return _eddgb
		}
		switch _agdcd := _ggggf.(type) {
		case _g.StartElement:
			switch _agdcd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "custGeom"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "custGeom"}:
				_aacbef.CustGeom = NewCT_CustomGeometry2D()
				if _egeae := d.DecodeElement(_aacbef.CustGeom, &_agdcd); _egeae != nil {
					return _egeae
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstGeom"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstGeom"}:
				_aacbef.PrstGeom = NewCT_PresetGeometry2D()
				if _agfbg := d.DecodeElement(_aacbef.PrstGeom, &_agdcd); _agfbg != nil {
					return _agfbg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_Geometry\u0020\u0025v", _agdcd.Name)
				if _fdbba := d.Skip(); _fdbba != nil {
					return _fdbba
				}
			}
		case _g.EndElement:
			break _efagbe
		case _g.CharData:
		}
	}
	return nil
}

type CT_EmptyElement struct{}
type EG_ThemeableFillStyle struct {
	Fill    *CT_FillProperties
	FillRef *CT_StyleMatrixReference
}

// ValidateWithPath validates the CT_SolidColorFillProperties and its children, prefixing error messages with path
func (_eaefe *CT_SolidColorFillProperties) ValidateWithPath(path string) error {
	if _eaefe.ScrgbClr != nil {
		if _bfagd := _eaefe.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _bfagd != nil {
			return _bfagd
		}
	}
	if _eaefe.SrgbClr != nil {
		if _dgge := _eaefe.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _dgge != nil {
			return _dgge
		}
	}
	if _eaefe.HslClr != nil {
		if _fabba := _eaefe.HslClr.ValidateWithPath(path + "\u002fHslClr"); _fabba != nil {
			return _fabba
		}
	}
	if _eaefe.SysClr != nil {
		if _gcbaf := _eaefe.SysClr.ValidateWithPath(path + "\u002fSysClr"); _gcbaf != nil {
			return _gcbaf
		}
	}
	if _eaefe.SchemeClr != nil {
		if _cebdf := _eaefe.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _cebdf != nil {
			return _cebdf
		}
	}
	if _eaefe.PrstClr != nil {
		if _gfcac := _eaefe.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _gfcac != nil {
			return _gfcac
		}
	}
	return nil
}

type EG_TextRun struct {
	R   *CT_RegularTextRun
	Br  *CT_TextLineBreak
	Fld *CT_TextField
}

func (_eedcb ST_AdjAngle) String() string {
	if _eedcb.ST_Angle != nil {
		return _dcf.Sprintf("\u0025v", *_eedcb.ST_Angle)
	}
	if _eedcb.ST_GeomGuideName != nil {
		return _dcf.Sprintf("\u0025v", *_eedcb.ST_GeomGuideName)
	}
	return ""
}
func (_gcceb *CT_GvmlGraphicFrameNonVisual) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gcceb.CNvPr = NewCT_NonVisualDrawingProps()
	_gcceb.CNvGraphicFramePr = NewCT_NonVisualGraphicFrameProperties()
_dagce:
	for {
		_decd, _gbce := d.Token()
		if _gbce != nil {
			return _gbce
		}
		switch _acbba := _decd.(type) {
		case _g.StartElement:
			switch _acbba.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cNvPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cNvPr"}:
				if _bgead := d.DecodeElement(_gcceb.CNvPr, &_acbba); _bgead != nil {
					return _bgead
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cNvGraphicFramePr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cNvGraphicFramePr"}:
				if _cagf := d.DecodeElement(_gcceb.CNvGraphicFramePr, &_acbba); _cagf != nil {
					return _cagf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_GvmlGraphicFrameNonVisual\u0020\u0025v", _acbba.Name)
				if _bcfb := d.Skip(); _bcfb != nil {
					return _bcfb
				}
			}
		case _g.EndElement:
			break _dagce
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_GrayscaleEffect and its children, prefixing error messages with path
func (_egedg *CT_GrayscaleEffect) ValidateWithPath(path string) error { return nil }
func (_afgeaf *TblStyleLst) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_afgeaf.CT_TableStyleList = *NewCT_TableStyleList()
	for _, _effag := range start.Attr {
		if _effag.Name.Local == "def" {
			_cfacbb, _bebec := _effag.Value, error(nil)
			if _bebec != nil {
				return _bebec
			}
			_afgeaf.DefAttr = _cfacbb
			continue
		}
	}
_cffeg:
	for {
		_gbedc, _dffgf := d.Token()
		if _dffgf != nil {
			return _dffgf
		}
		switch _ecefg := _gbedc.(type) {
		case _g.StartElement:
			switch _ecefg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tblStyle"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tblStyle"}:
				_fgegb := NewCT_TableStyle()
				if _gggea := d.DecodeElement(_fgegb, &_ecefg); _gggea != nil {
					return _gggea
				}
				_afgeaf.TblStyle = append(_afgeaf.TblStyle, _fgegb)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020TblStyleLst\u0020\u0025v", _ecefg.Name)
				if _befcg := d.Skip(); _befcg != nil {
					return _befcg
				}
			}
		case _g.EndElement:
			break _cffeg
		case _g.CharData:
		}
	}
	return nil
}
func (_daadg *ST_TextAlignType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_daadg = 0
	case "l":
		*_daadg = 1
	case "ctr":
		*_daadg = 2
	case "r":
		*_daadg = 3
	case "just":
		*_daadg = 4
	case "justLow":
		*_daadg = 5
	case "dist":
		*_daadg = 6
	case "thaiDist":
		*_daadg = 7
	}
	return nil
}
func (_gdaff ST_TextVertOverflowType) String() string {
	switch _gdaff {
	case 0:
		return ""
	case 1:
		return "overflow"
	case 2:
		return "ellipsis"
	case 3:
		return "clip"
	}
	return ""
}
func (_bcgfe ST_SchemeColorVal) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_bcgfe.String(), start)
}

const (
	ST_TextTabAlignTypeUnset ST_TextTabAlignType = 0
	ST_TextTabAlignTypeL     ST_TextTabAlignType = 1
	ST_TextTabAlignTypeCtr   ST_TextTabAlignType = 2
	ST_TextTabAlignTypeR     ST_TextTabAlignType = 3
	ST_TextTabAlignTypeDec   ST_TextTabAlignType = 4
)
const (
	ST_SystemColorValUnset                   ST_SystemColorVal = 0
	ST_SystemColorValScrollBar               ST_SystemColorVal = 1
	ST_SystemColorValBackground              ST_SystemColorVal = 2
	ST_SystemColorValActiveCaption           ST_SystemColorVal = 3
	ST_SystemColorValInactiveCaption         ST_SystemColorVal = 4
	ST_SystemColorValMenu                    ST_SystemColorVal = 5
	ST_SystemColorValWindow                  ST_SystemColorVal = 6
	ST_SystemColorValWindowFrame             ST_SystemColorVal = 7
	ST_SystemColorValMenuText                ST_SystemColorVal = 8
	ST_SystemColorValWindowText              ST_SystemColorVal = 9
	ST_SystemColorValCaptionText             ST_SystemColorVal = 10
	ST_SystemColorValActiveBorder            ST_SystemColorVal = 11
	ST_SystemColorValInactiveBorder          ST_SystemColorVal = 12
	ST_SystemColorValAppWorkspace            ST_SystemColorVal = 13
	ST_SystemColorValHighlight               ST_SystemColorVal = 14
	ST_SystemColorValHighlightText           ST_SystemColorVal = 15
	ST_SystemColorValBtnFace                 ST_SystemColorVal = 16
	ST_SystemColorValBtnShadow               ST_SystemColorVal = 17
	ST_SystemColorValGrayText                ST_SystemColorVal = 18
	ST_SystemColorValBtnText                 ST_SystemColorVal = 19
	ST_SystemColorValInactiveCaptionText     ST_SystemColorVal = 20
	ST_SystemColorValBtnHighlight            ST_SystemColorVal = 21
	ST_SystemColorVal3dDkShadow              ST_SystemColorVal = 22
	ST_SystemColorVal3dLight                 ST_SystemColorVal = 23
	ST_SystemColorValInfoText                ST_SystemColorVal = 24
	ST_SystemColorValInfoBk                  ST_SystemColorVal = 25
	ST_SystemColorValHotLight                ST_SystemColorVal = 26
	ST_SystemColorValGradientActiveCaption   ST_SystemColorVal = 27
	ST_SystemColorValGradientInactiveCaption ST_SystemColorVal = 28
	ST_SystemColorValMenuHighlight           ST_SystemColorVal = 29
	ST_SystemColorValMenuBar                 ST_SystemColorVal = 30
)

func (_bcfef *ST_BlackWhiteMode) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_bcfef = 0
	case "clr":
		*_bcfef = 1
	case "auto":
		*_bcfef = 2
	case "gray":
		*_bcfef = 3
	case "ltGray":
		*_bcfef = 4
	case "invGray":
		*_bcfef = 5
	case "grayWhite":
		*_bcfef = 6
	case "blackGray":
		*_bcfef = 7
	case "blackWhite":
		*_bcfef = 8
	case "black":
		*_bcfef = 9
	case "white":
		*_bcfef = 10
	case "hidden":
		*_bcfef = 11
	}
	return nil
}
func (_eadfe *CT_LightRig) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_eadfe.RigAttr = ST_LightRigType(1)
	_eadfe.DirAttr = ST_LightRigDirection(1)
	for _, _bbcfa := range start.Attr {
		if _bbcfa.Name.Local == "rig" {
			_eadfe.RigAttr.UnmarshalXMLAttr(_bbcfa)
			continue
		}
		if _bbcfa.Name.Local == "dir" {
			_eadfe.DirAttr.UnmarshalXMLAttr(_bbcfa)
			continue
		}
	}
_aagaa:
	for {
		_eeca, _fdgb := d.Token()
		if _fdgb != nil {
			return _fdgb
		}
		switch _fgad := _eeca.(type) {
		case _g.StartElement:
			switch _fgad.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "rot"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "rot"}:
				_eadfe.Rot = NewCT_SphereCoords()
				if _gacg := d.DecodeElement(_eadfe.Rot, &_fgad); _gacg != nil {
					return _gacg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_LightRig\u0020\u0025v", _fgad.Name)
				if _fefab := d.Skip(); _fefab != nil {
					return _fefab
				}
			}
		case _g.EndElement:
			break _aagaa
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the EG_FillModeProperties and its children, prefixing error messages with path
func (_bafgg *EG_FillModeProperties) ValidateWithPath(path string) error {
	if _bafgg.Tile != nil {
		if _aebbd := _bafgg.Tile.ValidateWithPath(path + "\u002fTile"); _aebbd != nil {
			return _aebbd
		}
	}
	if _bafgg.Stretch != nil {
		if _bccdg := _bafgg.Stretch.ValidateWithPath(path + "\u002fStretch"); _bccdg != nil {
			return _bccdg
		}
	}
	return nil
}
func (_dffaf ST_EffectContainerType) Validate() error { return _dffaf.ValidateWithPath("") }
func (_eafaf ST_PathFillMode) String() string {
	switch _eafaf {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "norm"
	case 3:
		return "lighten"
	case 4:
		return "lightenLess"
	case 5:
		return "darken"
	case 6:
		return "darkenLess"
	}
	return ""
}
func (_beabb *CT_ShapeProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _dfaga := range start.Attr {
		if _dfaga.Name.Local == "bwMode" {
			_beabb.BwModeAttr.UnmarshalXMLAttr(_dfaga)
			continue
		}
	}
_gabgg:
	for {
		_cedc, _gebf := d.Token()
		if _gebf != nil {
			return _gebf
		}
		switch _bfde := _cedc.(type) {
		case _g.StartElement:
			switch _bfde.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "xfrm"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "xfrm"}:
				_beabb.Xfrm = NewCT_Transform2D()
				if _dggbe := d.DecodeElement(_beabb.Xfrm, &_bfde); _dggbe != nil {
					return _dggbe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "custGeom"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "custGeom"}:
				_beabb.CustGeom = NewCT_CustomGeometry2D()
				if _dacae := d.DecodeElement(_beabb.CustGeom, &_bfde); _dacae != nil {
					return _dacae
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstGeom"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstGeom"}:
				_beabb.PrstGeom = NewCT_PresetGeometry2D()
				if _egfca := d.DecodeElement(_beabb.PrstGeom, &_bfde); _egfca != nil {
					return _egfca
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_beabb.NoFill = NewCT_NoFillProperties()
				if _bgeafe := d.DecodeElement(_beabb.NoFill, &_bfde); _bgeafe != nil {
					return _bgeafe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_beabb.SolidFill = NewCT_SolidColorFillProperties()
				if _gaeab := d.DecodeElement(_beabb.SolidFill, &_bfde); _gaeab != nil {
					return _gaeab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_beabb.GradFill = NewCT_GradientFillProperties()
				if _fegeg := d.DecodeElement(_beabb.GradFill, &_bfde); _fegeg != nil {
					return _fegeg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_beabb.BlipFill = NewCT_BlipFillProperties()
				if _dffgb := d.DecodeElement(_beabb.BlipFill, &_bfde); _dffgb != nil {
					return _dffgb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_beabb.PattFill = NewCT_PatternFillProperties()
				if _defgd := d.DecodeElement(_beabb.PattFill, &_bfde); _defgd != nil {
					return _defgd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_beabb.GrpFill = NewCT_GroupFillProperties()
				if _dacgca := d.DecodeElement(_beabb.GrpFill, &_bfde); _dacgca != nil {
					return _dacgca
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ln"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ln"}:
				_beabb.Ln = NewCT_LineProperties()
				if _facab := d.DecodeElement(_beabb.Ln, &_bfde); _facab != nil {
					return _facab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectLst"}:
				_beabb.EffectLst = NewCT_EffectList()
				if _feeec := d.DecodeElement(_beabb.EffectLst, &_bfde); _feeec != nil {
					return _feeec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectDag"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectDag"}:
				_beabb.EffectDag = NewCT_EffectContainer()
				if _gggcc := d.DecodeElement(_beabb.EffectDag, &_bfde); _gggcc != nil {
					return _gggcc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scene3d"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scene3d"}:
				_beabb.Scene3d = NewCT_Scene3D()
				if _ccbad := d.DecodeElement(_beabb.Scene3d, &_bfde); _ccbad != nil {
					return _ccbad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sp3d"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sp3d"}:
				_beabb.Sp3d = NewCT_Shape3D()
				if _cfdbb := d.DecodeElement(_beabb.Sp3d, &_bfde); _cfdbb != nil {
					return _cfdbb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_beabb.ExtLst = NewCT_OfficeArtExtensionList()
				if _aecb := d.DecodeElement(_beabb.ExtLst, &_bfde); _aecb != nil {
					return _aecb
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_ShapeProperties\u0020\u0025v", _bfde.Name)
				if _cccfa := d.Skip(); _cccfa != nil {
					return _cccfa
				}
			}
		case _g.EndElement:
			break _gabgg
		case _g.CharData:
		}
	}
	return nil
}
func (_caadd ST_LineCap) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_caadd.String(), start)
}

type CT_ColorMappingOverrideChoice struct {
	MasterClrMapping   *CT_EmptyElement
	OverrideClrMapping *CT_ColorMapping
}

func (_dfebe ST_AnimationChartOnlyBuildType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_bfgadb := _g.Attr{}
	_bfgadb.Name = name
	switch _dfebe {
	case ST_AnimationChartOnlyBuildTypeUnset:
		_bfgadb.Value = ""
	case ST_AnimationChartOnlyBuildTypeSeries:
		_bfgadb.Value = "series"
	case ST_AnimationChartOnlyBuildTypeCategory:
		_bfgadb.Value = "category"
	case ST_AnimationChartOnlyBuildTypeSeriesEl:
		_bfgadb.Value = "seriesEl"
	case ST_AnimationChartOnlyBuildTypeCategoryEl:
		_bfgadb.Value = "categoryEl"
	}
	return _bfgadb, nil
}

// Validate validates the CT_TextLineBreak and its children
func (_decdd *CT_TextLineBreak) Validate() error { return _decdd.ValidateWithPath("CT_TextLineBreak") }
func NewCT_TextBodyProperties() *CT_TextBodyProperties {
	_gfadgf := &CT_TextBodyProperties{}
	return _gfadgf
}
func (_cgbec *CT_GradientStopList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_ggbbe := _g.StartElement{Name: _g.Name{Local: "a:gs"}}
	for _, _dgefb := range _cgbec.Gs {
		e.EncodeElement(_dgefb, _ggbbe)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_aafbe ST_LightRigDirection) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dgddbe := _g.Attr{}
	_dgddbe.Name = name
	switch _aafbe {
	case ST_LightRigDirectionUnset:
		_dgddbe.Value = ""
	case ST_LightRigDirectionTl:
		_dgddbe.Value = "tl"
	case ST_LightRigDirectionT:
		_dgddbe.Value = "t"
	case ST_LightRigDirectionTr:
		_dgddbe.Value = "tr"
	case ST_LightRigDirectionL:
		_dgddbe.Value = "l"
	case ST_LightRigDirectionR:
		_dgddbe.Value = "r"
	case ST_LightRigDirectionBl:
		_dgddbe.Value = "bl"
	case ST_LightRigDirectionB:
		_dgddbe.Value = "b"
	case ST_LightRigDirectionBr:
		_dgddbe.Value = "br"
	}
	return _dgddbe, nil
}
func (_aedec *CT_OuterShadowEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _aedec.BlurRadAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "blurRad"}, Value: _dcf.Sprintf("\u0025v", *_aedec.BlurRadAttr)})
	}
	if _aedec.DistAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dist"}, Value: _dcf.Sprintf("\u0025v", *_aedec.DistAttr)})
	}
	if _aedec.DirAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dir"}, Value: _dcf.Sprintf("\u0025v", *_aedec.DirAttr)})
	}
	if _aedec.SxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sx"}, Value: _dcf.Sprintf("\u0025v", *_aedec.SxAttr)})
	}
	if _aedec.SyAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sy"}, Value: _dcf.Sprintf("\u0025v", *_aedec.SyAttr)})
	}
	if _aedec.KxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "kx"}, Value: _dcf.Sprintf("\u0025v", *_aedec.KxAttr)})
	}
	if _aedec.KyAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "ky"}, Value: _dcf.Sprintf("\u0025v", *_aedec.KyAttr)})
	}
	if _aedec.AlgnAttr != ST_RectAlignmentUnset {
		_eabab, _ebgfb := _aedec.AlgnAttr.MarshalXMLAttr(_g.Name{Local: "algn"})
		if _ebgfb != nil {
			return _ebgfb
		}
		start.Attr = append(start.Attr, _eabab)
	}
	if _aedec.RotWithShapeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rotWithShape"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aedec.RotWithShapeAttr))})
	}
	e.EncodeToken(start)
	if _aedec.ScrgbClr != nil {
		_ggfb := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_aedec.ScrgbClr, _ggfb)
	}
	if _aedec.SrgbClr != nil {
		_cgbbe := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_aedec.SrgbClr, _cgbbe)
	}
	if _aedec.HslClr != nil {
		_gddfb := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_aedec.HslClr, _gddfb)
	}
	if _aedec.SysClr != nil {
		_gecea := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_aedec.SysClr, _gecea)
	}
	if _aedec.SchemeClr != nil {
		_cfcgg := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_aedec.SchemeClr, _cfcgg)
	}
	if _aedec.PrstClr != nil {
		_fadce := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_aedec.PrstClr, _fadce)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_ClipboardStyleSheet and its children
func (_cfcg *CT_ClipboardStyleSheet) Validate() error {
	return _cfcg.ValidateWithPath("CT_ClipboardStyleSheet")
}
func NewEG_TextBullet() *EG_TextBullet { _gebee := &EG_TextBullet{}; return _gebee }

type CT_Vector3D struct {
	DxAttr ST_Coordinate
	DyAttr ST_Coordinate
	DzAttr ST_Coordinate
}

// Validate validates the CT_TextParagraphProperties and its children
func (_cbbfa *CT_TextParagraphProperties) Validate() error {
	return _cbbfa.ValidateWithPath("CT_TextParagraphProperties")
}
func (_gdbff *ST_TileFlipMode) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gbeeb, _efdad := d.Token()
	if _efdad != nil {
		return _efdad
	}
	if _ebaf, _begbb := _gbeeb.(_g.EndElement); _begbb && _ebaf.Name == start.Name {
		*_gdbff = 1
		return nil
	}
	if _ccffaf, _dacff := _gbeeb.(_g.CharData); !_dacff {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gbeeb)
	} else {
		switch string(_ccffaf) {
		case "":
			*_gdbff = 0
		case "none":
			*_gdbff = 1
		case "x":
			*_gdbff = 2
		case "y":
			*_gdbff = 3
		case "xy":
			*_gdbff = 4
		}
	}
	_gbeeb, _efdad = d.Token()
	if _efdad != nil {
		return _efdad
	}
	if _acbebg, _efdab := _gbeeb.(_g.EndElement); _efdab && _acbebg.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gbeeb)
}

// Validate validates the CT_InverseGammaTransform and its children
func (_cfdba *CT_InverseGammaTransform) Validate() error {
	return _cfdba.ValidateWithPath("CT_InverseGammaTransform")
}

type CT_Angle struct{ ValAttr int32 }

func (_dccdbd *ThemeManager) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "a:themeManager"
	return _dccdbd.CT_EmptyElement.MarshalXML(e, start)
}

// Validate validates the CT_PathShadeProperties and its children
func (_efefg *CT_PathShadeProperties) Validate() error {
	return _efefg.ValidateWithPath("CT_PathShadeProperties")
}

type EG_LineJoinProperties struct {
	Round *CT_LineJoinRound
	Bevel *CT_LineJoinBevel
	Miter *CT_LineJoinMiterProperties
}

func (_bbcdc *CT_Scale2D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bbcdc.Sx = NewCT_Ratio()
	_bbcdc.Sy = NewCT_Ratio()
_gdeg:
	for {
		_cfeec, _bcfdg := d.Token()
		if _bcfdg != nil {
			return _bcfdg
		}
		switch _ccffaa := _cfeec.(type) {
		case _g.StartElement:
			switch _ccffaa.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sx"}:
				if _fdbefa := d.DecodeElement(_bbcdc.Sx, &_ccffaa); _fdbefa != nil {
					return _fdbefa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sy"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sy"}:
				if _afgcg := d.DecodeElement(_bbcdc.Sy, &_ccffaa); _afgcg != nil {
					return _afgcg
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_Scale2D\u0020\u0025v", _ccffaa.Name)
				if _baecc := d.Skip(); _baecc != nil {
					return _baecc
				}
			}
		case _g.EndElement:
			break _gdeg
		case _g.CharData:
		}
	}
	return nil
}
func (_fabdf ST_BevelPresetType) ValidateWithPath(path string) error {
	switch _fabdf {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fabdf))
	}
	return nil
}
func (_gdcdb *CT_TextBulletSizeFollowText) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_gaeafd, _abef := d.Token()
		if _abef != nil {
			return _dcf.Errorf("parsing\u0020CT_TextBulletSizeFollowText:\u0020\u0025s", _abef)
		}
		if _ccaac, _eddbd := _gaeafd.(_g.EndElement); _eddbd && _ccaac.Name == start.Name {
			break
		}
	}
	return nil
}
func (_decfg *CT_TableRow) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "h"}, Value: _dcf.Sprintf("\u0025v", _decfg.HAttr)})
	e.EncodeToken(start)
	if _decfg.Tc != nil {
		_dcdb := _g.StartElement{Name: _g.Name{Local: "a:tc"}}
		for _, _egec := range _decfg.Tc {
			e.EncodeElement(_egec, _dcdb)
		}
	}
	if _decfg.ExtLst != nil {
		_bdefa := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_decfg.ExtLst, _bdefa)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the EG_TextAutofit and its children, prefixing error messages with path
func (_gdfbf *EG_TextAutofit) ValidateWithPath(path string) error {
	if _gdfbf.NoAutofit != nil {
		if _ddcfee := _gdfbf.NoAutofit.ValidateWithPath(path + "\u002fNoAutofit"); _ddcfee != nil {
			return _ddcfee
		}
	}
	if _gdfbf.NormAutofit != nil {
		if _deeaed := _gdfbf.NormAutofit.ValidateWithPath(path + "\u002fNormAutofit"); _deeaed != nil {
			return _deeaed
		}
	}
	if _gdfbf.SpAutoFit != nil {
		if _addaga := _gdfbf.SpAutoFit.ValidateWithPath(path + "\u002fSpAutoFit"); _addaga != nil {
			return _addaga
		}
	}
	return nil
}

type ST_DgmBuildStep byte

func (_bedc *CT_GeomRect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _becg := range start.Attr {
		if _becg.Name.Local == "l" {
			_gdef, _aabc := ParseUnionST_AdjCoordinate(_becg.Value)
			if _aabc != nil {
				return _aabc
			}
			_bedc.LAttr = _gdef
			continue
		}
		if _becg.Name.Local == "t" {
			_ddfeg, _ggfgf := ParseUnionST_AdjCoordinate(_becg.Value)
			if _ggfgf != nil {
				return _ggfgf
			}
			_bedc.TAttr = _ddfeg
			continue
		}
		if _becg.Name.Local == "r" {
			_adfe, _gfgcf := ParseUnionST_AdjCoordinate(_becg.Value)
			if _gfgcf != nil {
				return _gfgcf
			}
			_bedc.RAttr = _adfe
			continue
		}
		if _becg.Name.Local == "b" {
			_cfce, _aageg := ParseUnionST_AdjCoordinate(_becg.Value)
			if _aageg != nil {
				return _aageg
			}
			_bedc.BAttr = _cfce
			continue
		}
	}
	for {
		_daadf, _geaeg := d.Token()
		if _geaeg != nil {
			return _dcf.Errorf("parsing\u0020CT_GeomRect:\u0020\u0025s", _geaeg)
		}
		if _bdbdd, _bcec := _daadf.(_g.EndElement); _bcec && _bdbdd.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the EG_TextBullet and its children, prefixing error messages with path
func (_cbdaff *EG_TextBullet) ValidateWithPath(path string) error {
	if _cbdaff.BuNone != nil {
		if _bgbgg := _cbdaff.BuNone.ValidateWithPath(path + "\u002fBuNone"); _bgbgg != nil {
			return _bgbgg
		}
	}
	if _cbdaff.BuAutoNum != nil {
		if _gabbca := _cbdaff.BuAutoNum.ValidateWithPath(path + "\u002fBuAutoNum"); _gabbca != nil {
			return _gabbca
		}
	}
	if _cbdaff.BuChar != nil {
		if _afgca := _cbdaff.BuChar.ValidateWithPath(path + "\u002fBuChar"); _afgca != nil {
			return _afgca
		}
	}
	if _cbdaff.BuBlip != nil {
		if _ddcgc := _cbdaff.BuBlip.ValidateWithPath(path + "\u002fBuBlip"); _ddcgc != nil {
			return _ddcgc
		}
	}
	return nil
}

type CT_ColorMRU struct{ EG_ColorChoice []*EG_ColorChoice }

func (_dfgb ST_TextUnderlineType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_babga := _g.Attr{}
	_babga.Name = name
	switch _dfgb {
	case ST_TextUnderlineTypeUnset:
		_babga.Value = ""
	case ST_TextUnderlineTypeNone:
		_babga.Value = "none"
	case ST_TextUnderlineTypeWords:
		_babga.Value = "words"
	case ST_TextUnderlineTypeSng:
		_babga.Value = "sng"
	case ST_TextUnderlineTypeDbl:
		_babga.Value = "dbl"
	case ST_TextUnderlineTypeHeavy:
		_babga.Value = "heavy"
	case ST_TextUnderlineTypeDotted:
		_babga.Value = "dotted"
	case ST_TextUnderlineTypeDottedHeavy:
		_babga.Value = "dottedHeavy"
	case ST_TextUnderlineTypeDash:
		_babga.Value = "dash"
	case ST_TextUnderlineTypeDashHeavy:
		_babga.Value = "dashHeavy"
	case ST_TextUnderlineTypeDashLong:
		_babga.Value = "dashLong"
	case ST_TextUnderlineTypeDashLongHeavy:
		_babga.Value = "dashLongHeavy"
	case ST_TextUnderlineTypeDotDash:
		_babga.Value = "dotDash"
	case ST_TextUnderlineTypeDotDashHeavy:
		_babga.Value = "dotDashHeavy"
	case ST_TextUnderlineTypeDotDotDash:
		_babga.Value = "dotDotDash"
	case ST_TextUnderlineTypeDotDotDashHeavy:
		_babga.Value = "dotDotDashHeavy"
	case ST_TextUnderlineTypeWavy:
		_babga.Value = "wavy"
	case ST_TextUnderlineTypeWavyHeavy:
		_babga.Value = "wavyHeavy"
	case ST_TextUnderlineTypeWavyDbl:
		_babga.Value = "wavyDbl"
	}
	return _babga, nil
}

// ValidateWithPath validates the CT_SchemeColor and its children, prefixing error messages with path
func (_agcg *CT_SchemeColor) ValidateWithPath(path string) error {
	if _agcg.ValAttr == ST_SchemeColorValUnset {
		return _dcf.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _gabbf := _agcg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _gabbf != nil {
		return _gabbf
	}
	for _gbecd, _adbab := range _agcg.EG_ColorTransform {
		if _gfcbba := _adbab.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fEG_ColorTransform\u005b\u0025d\u005d", path, _gbecd)); _gfcbba != nil {
			return _gfcbba
		}
	}
	return nil
}
func (_bdbc *CT_InverseGammaTransform) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_aacdf, _dgegb := d.Token()
		if _dgegb != nil {
			return _dcf.Errorf("parsing CT_InverseGammaTransform:\u0020%s", _dgegb)
		}
		if _bbbb, _aeaf := _aacdf.(_g.EndElement); _aeaf && _bbbb.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_GroupShapeProperties and its children
func (_efcgc *CT_GroupShapeProperties) Validate() error {
	return _efcgc.ValidateWithPath("CT_GroupShapeProperties")
}

type CT_InverseTransform struct{}

// Validate validates the CT_GroupFillProperties and its children
func (_caca *CT_GroupFillProperties) Validate() error {
	return _caca.ValidateWithPath("CT_GroupFillProperties")
}

// Validate validates the CT_Path2D and its children
func (_cafbb *CT_Path2D) Validate() error { return _cafbb.ValidateWithPath("CT_Path2D") }
func (_bcacf *ST_TextStrikeType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_bcacf = 0
	case "noStrike":
		*_bcacf = 1
	case "sngStrike":
		*_bcacf = 2
	case "dblStrike":
		*_bcacf = 3
	}
	return nil
}
func NewCT_GeomGuideList() *CT_GeomGuideList { _bgab := &CT_GeomGuideList{}; return _bgab }

// Validate validates the CT_OfficeArtExtensionList and its children
func (_bbacf *CT_OfficeArtExtensionList) Validate() error {
	return _bbacf.ValidateWithPath("CT_OfficeArtExtensionList")
}

// ValidateWithPath validates the CT_TableProperties and its children, prefixing error messages with path
func (_agggg *CT_TableProperties) ValidateWithPath(path string) error {
	if _agggg.NoFill != nil {
		if _feede := _agggg.NoFill.ValidateWithPath(path + "\u002fNoFill"); _feede != nil {
			return _feede
		}
	}
	if _agggg.SolidFill != nil {
		if _efgcc := _agggg.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _efgcc != nil {
			return _efgcc
		}
	}
	if _agggg.GradFill != nil {
		if _ggfccb := _agggg.GradFill.ValidateWithPath(path + "\u002fGradFill"); _ggfccb != nil {
			return _ggfccb
		}
	}
	if _agggg.BlipFill != nil {
		if _eedgc := _agggg.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _eedgc != nil {
			return _eedgc
		}
	}
	if _agggg.PattFill != nil {
		if _cgbdf := _agggg.PattFill.ValidateWithPath(path + "\u002fPattFill"); _cgbdf != nil {
			return _cgbdf
		}
	}
	if _agggg.GrpFill != nil {
		if _bbffg := _agggg.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _bbffg != nil {
			return _bbffg
		}
	}
	if _agggg.EffectLst != nil {
		if _ebbdd := _agggg.EffectLst.ValidateWithPath(path + "\u002fEffectLst"); _ebbdd != nil {
			return _ebbdd
		}
	}
	if _agggg.EffectDag != nil {
		if _ddfa := _agggg.EffectDag.ValidateWithPath(path + "\u002fEffectDag"); _ddfa != nil {
			return _ddfa
		}
	}
	if _agggg.Choice != nil {
		if _eecgb := _agggg.Choice.ValidateWithPath(path + "\u002fChoice"); _eecgb != nil {
			return _eecgb
		}
	}
	if _agggg.ExtLst != nil {
		if _dacgfa := _agggg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dacgfa != nil {
			return _dacgfa
		}
	}
	return nil
}

type CT_EffectContainer struct {
	TypeAttr     ST_EffectContainerType
	NameAttr     *string
	Cont         *CT_EffectContainer
	Effect       *CT_EffectReference
	AlphaBiLevel *CT_AlphaBiLevelEffect
	AlphaCeiling *CT_AlphaCeilingEffect
	AlphaFloor   *CT_AlphaFloorEffect
	AlphaInv     *CT_AlphaInverseEffect
	AlphaMod     *CT_AlphaModulateEffect
	AlphaModFix  *CT_AlphaModulateFixedEffect
	AlphaOutset  *CT_AlphaOutsetEffect
	AlphaRepl    *CT_AlphaReplaceEffect
	BiLevel      *CT_BiLevelEffect
	Blend        *CT_BlendEffect
	Blur         *CT_BlurEffect
	ClrChange    *CT_ColorChangeEffect
	ClrRepl      *CT_ColorReplaceEffect
	Duotone      *CT_DuotoneEffect
	Fill         *CT_FillEffect
	FillOverlay  *CT_FillOverlayEffect
	Glow         *CT_GlowEffect
	Grayscl      *CT_GrayscaleEffect
	Hsl          *CT_HSLEffect
	InnerShdw    *CT_InnerShadowEffect
	Lum          *CT_LuminanceEffect
	OuterShdw    *CT_OuterShadowEffect
	PrstShdw     *CT_PresetShadowEffect
	Reflection   *CT_ReflectionEffect
	RelOff       *CT_RelativeOffsetEffect
	SoftEdge     *CT_SoftEdgesEffect
	Tint         *CT_TintEffect
	Xfrm         *CT_TransformEffect
}

const (
	ST_TextAutonumberSchemeUnset                 ST_TextAutonumberScheme = 0
	ST_TextAutonumberSchemeAlphaLcParenBoth      ST_TextAutonumberScheme = 1
	ST_TextAutonumberSchemeAlphaUcParenBoth      ST_TextAutonumberScheme = 2
	ST_TextAutonumberSchemeAlphaLcParenR         ST_TextAutonumberScheme = 3
	ST_TextAutonumberSchemeAlphaUcParenR         ST_TextAutonumberScheme = 4
	ST_TextAutonumberSchemeAlphaLcPeriod         ST_TextAutonumberScheme = 5
	ST_TextAutonumberSchemeAlphaUcPeriod         ST_TextAutonumberScheme = 6
	ST_TextAutonumberSchemeArabicParenBoth       ST_TextAutonumberScheme = 7
	ST_TextAutonumberSchemeArabicParenR          ST_TextAutonumberScheme = 8
	ST_TextAutonumberSchemeArabicPeriod          ST_TextAutonumberScheme = 9
	ST_TextAutonumberSchemeArabicPlain           ST_TextAutonumberScheme = 10
	ST_TextAutonumberSchemeRomanLcParenBoth      ST_TextAutonumberScheme = 11
	ST_TextAutonumberSchemeRomanUcParenBoth      ST_TextAutonumberScheme = 12
	ST_TextAutonumberSchemeRomanLcParenR         ST_TextAutonumberScheme = 13
	ST_TextAutonumberSchemeRomanUcParenR         ST_TextAutonumberScheme = 14
	ST_TextAutonumberSchemeRomanLcPeriod         ST_TextAutonumberScheme = 15
	ST_TextAutonumberSchemeRomanUcPeriod         ST_TextAutonumberScheme = 16
	ST_TextAutonumberSchemeCircleNumDbPlain      ST_TextAutonumberScheme = 17
	ST_TextAutonumberSchemeCircleNumWdBlackPlain ST_TextAutonumberScheme = 18
	ST_TextAutonumberSchemeCircleNumWdWhitePlain ST_TextAutonumberScheme = 19
	ST_TextAutonumberSchemeArabicDbPeriod        ST_TextAutonumberScheme = 20
	ST_TextAutonumberSchemeArabicDbPlain         ST_TextAutonumberScheme = 21
	ST_TextAutonumberSchemeEa1ChsPeriod          ST_TextAutonumberScheme = 22
	ST_TextAutonumberSchemeEa1ChsPlain           ST_TextAutonumberScheme = 23
	ST_TextAutonumberSchemeEa1ChtPeriod          ST_TextAutonumberScheme = 24
	ST_TextAutonumberSchemeEa1ChtPlain           ST_TextAutonumberScheme = 25
	ST_TextAutonumberSchemeEa1JpnChsDbPeriod     ST_TextAutonumberScheme = 26
	ST_TextAutonumberSchemeEa1JpnKorPlain        ST_TextAutonumberScheme = 27
	ST_TextAutonumberSchemeEa1JpnKorPeriod       ST_TextAutonumberScheme = 28
	ST_TextAutonumberSchemeArabic1Minus          ST_TextAutonumberScheme = 29
	ST_TextAutonumberSchemeArabic2Minus          ST_TextAutonumberScheme = 30
	ST_TextAutonumberSchemeHebrew2Minus          ST_TextAutonumberScheme = 31
	ST_TextAutonumberSchemeThaiAlphaPeriod       ST_TextAutonumberScheme = 32
	ST_TextAutonumberSchemeThaiAlphaParenR       ST_TextAutonumberScheme = 33
	ST_TextAutonumberSchemeThaiAlphaParenBoth    ST_TextAutonumberScheme = 34
	ST_TextAutonumberSchemeThaiNumPeriod         ST_TextAutonumberScheme = 35
	ST_TextAutonumberSchemeThaiNumParenR         ST_TextAutonumberScheme = 36
	ST_TextAutonumberSchemeThaiNumParenBoth      ST_TextAutonumberScheme = 37
	ST_TextAutonumberSchemeHindiAlphaPeriod      ST_TextAutonumberScheme = 38
	ST_TextAutonumberSchemeHindiNumPeriod        ST_TextAutonumberScheme = 39
	ST_TextAutonumberSchemeHindiNumParenR        ST_TextAutonumberScheme = 40
	ST_TextAutonumberSchemeHindiAlpha1Period     ST_TextAutonumberScheme = 41
)

func (_gcgc *CT_InverseTransform) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TextSpacing and its children
func (_gbdfg *CT_TextSpacing) Validate() error { return _gbdfg.ValidateWithPath("CT_TextSpacing") }
func (_fgbee ST_BlipCompression) ValidateWithPath(path string) error {
	switch _fgbee {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fgbee))
	}
	return nil
}
func (_aaaaa ST_ColorSchemeIndex) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_aaaaa.String(), start)
}
func (_gfcbg *CT_AnimationElementChoice) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _gfcbg.Dgm != nil {
		_gdd := _g.StartElement{Name: _g.Name{Local: "a:dgm"}}
		e.EncodeElement(_gfcbg.Dgm, _gdd)
	}
	if _gfcbg.Chart != nil {
		_aegd := _g.StartElement{Name: _g.Name{Local: "a:chart"}}
		e.EncodeElement(_gfcbg.Chart, _aegd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ecgcd *CT_TextUnderlineLineFollowText) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_ffagb, _gedgd := d.Token()
		if _gedgd != nil {
			return _dcf.Errorf("parsing\u0020CT_TextUnderlineLineFollowText:\u0020\u0025s", _gedgd)
		}
		if _aegca, _edace := _ffagb.(_g.EndElement); _edace && _aegca.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cgdeg *CT_OfficeArtExtensionList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_degfc:
	for {
		_gfcbfe, _gfgb := d.Token()
		if _gfgb != nil {
			return _gfgb
		}
		switch _bfadg := _gfcbfe.(type) {
		case _g.StartElement:
			switch _bfadg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ext"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ext"}:
				_dbbcg := NewCT_OfficeArtExtension()
				if _cbfe := d.DecodeElement(_dbbcg, &_bfadg); _cbfe != nil {
					return _cbfe
				}
				_cgdeg.Ext = append(_cgdeg.Ext, _dbbcg)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OfficeArtExtensionList\u0020\u0025v", _bfadg.Name)
				if _ecebg := d.Skip(); _ecebg != nil {
					return _ecebg
				}
			}
		case _g.EndElement:
			break _degfc
		case _g.CharData:
		}
	}
	return nil
}
func NewTblStyleLst() *TblStyleLst {
	_edgcb := &TblStyleLst{}
	_edgcb.CT_TableStyleList = *NewCT_TableStyleList()
	return _edgcb
}

// ValidateWithPath validates the CT_PresetLineDashProperties and its children, prefixing error messages with path
func (_cafef *CT_PresetLineDashProperties) ValidateWithPath(path string) error {
	if _deebf := _cafef.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _deebf != nil {
		return _deebf
	}
	return nil
}

// Validate validates the CT_FixedPercentage and its children
func (_ddfe *CT_FixedPercentage) Validate() error {
	return _ddfe.ValidateWithPath("CT_FixedPercentage")
}
func (_fgcace ST_TextShapeType) String() string {
	switch _fgcace {
	case 0:
		return ""
	case 1:
		return "textNoShape"
	case 2:
		return "textPlain"
	case 3:
		return "textStop"
	case 4:
		return "textTriangle"
	case 5:
		return "textTriangleInverted"
	case 6:
		return "textChevron"
	case 7:
		return "textChevronInverted"
	case 8:
		return "textRingInside"
	case 9:
		return "textRingOutside"
	case 10:
		return "textArchUp"
	case 11:
		return "textArchDown"
	case 12:
		return "textCircle"
	case 13:
		return "textButton"
	case 14:
		return "textArchUpPour"
	case 15:
		return "textArchDownPour"
	case 16:
		return "textCirclePour"
	case 17:
		return "textButtonPour"
	case 18:
		return "textCurveUp"
	case 19:
		return "textCurveDown"
	case 20:
		return "textCanUp"
	case 21:
		return "textCanDown"
	case 22:
		return "textWave1"
	case 23:
		return "textWave2"
	case 24:
		return "textDoubleWave1"
	case 25:
		return "textWave4"
	case 26:
		return "textInflate"
	case 27:
		return "textDeflate"
	case 28:
		return "textInflateBottom"
	case 29:
		return "textDeflateBottom"
	case 30:
		return "textInflateTop"
	case 31:
		return "textDeflateTop"
	case 32:
		return "textDeflateInflate"
	case 33:
		return "textDeflateInflateDeflate"
	case 34:
		return "textFadeRight"
	case 35:
		return "textFadeLeft"
	case 36:
		return "textFadeUp"
	case 37:
		return "textFadeDown"
	case 38:
		return "textSlantUp"
	case 39:
		return "textSlantDown"
	case 40:
		return "textCascadeUp"
	case 41:
		return "textCascadeDown"
	}
	return ""
}
func (_abeeb ST_BlipCompression) String() string {
	switch _abeeb {
	case 0:
		return ""
	case 1:
		return "email"
	case 2:
		return "screen"
	case 3:
		return "print"
	case 4:
		return "hqprint"
	case 5:
		return "none"
	}
	return ""
}

// Validate validates the CT_TextNoAutofit and its children
func (_aaagc *CT_TextNoAutofit) Validate() error { return _aaagc.ValidateWithPath("CT_TextNoAutofit") }
func (_cfcfea ST_BlipCompression) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_fdeag := _g.Attr{}
	_fdeag.Name = name
	switch _cfcfea {
	case ST_BlipCompressionUnset:
		_fdeag.Value = ""
	case ST_BlipCompressionEmail:
		_fdeag.Value = "email"
	case ST_BlipCompressionScreen:
		_fdeag.Value = "screen"
	case ST_BlipCompressionPrint:
		_fdeag.Value = "print"
	case ST_BlipCompressionHqprint:
		_fdeag.Value = "hqprint"
	case ST_BlipCompressionNone:
		_fdeag.Value = "none"
	}
	return _fdeag, nil
}

// ValidateWithPath validates the CT_TintEffect and its children, prefixing error messages with path
func (_cecfac *CT_TintEffect) ValidateWithPath(path string) error {
	if _cecfac.HueAttr != nil {
		if *_cecfac.HueAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eHueAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_cecfac.HueAttr)
		}
		if *_cecfac.HueAttr >= 21600000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eHueAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, *_cecfac.HueAttr)
		}
	}
	if _cecfac.AmtAttr != nil {
		if _ggcdd := _cecfac.AmtAttr.ValidateWithPath(path + "\u002fAmtAttr"); _ggcdd != nil {
			return _ggcdd
		}
	}
	return nil
}

type CT_EffectStyleList struct{ EffectStyle []*CT_EffectStyleItem }

func (_ebcf *CT_Connection) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _gcad := range start.Attr {
		if _gcad.Name.Local == "id" {
			_egba, _fgcb := _e.ParseUint(_gcad.Value, 10, 32)
			if _fgcb != nil {
				return _fgcb
			}
			_ebcf.IdAttr = uint32(_egba)
			continue
		}
		if _gcad.Name.Local == "idx" {
			_babc, _effd := _e.ParseUint(_gcad.Value, 10, 32)
			if _effd != nil {
				return _effd
			}
			_ebcf.IdxAttr = uint32(_babc)
			continue
		}
	}
	for {
		_efac, _ceaad := d.Token()
		if _ceaad != nil {
			return _dcf.Errorf("parsing\u0020CT_Connection:\u0020\u0025s", _ceaad)
		}
		if _fdbc, _cdde := _efac.(_g.EndElement); _cdde && _fdbc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_daaaa *CT_Path2DMoveTo) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_cfaf := _g.StartElement{Name: _g.Name{Local: "a:pt"}}
	e.EncodeElement(_daaaa.Pt, _cfaf)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Path2DQuadBezierTo and its children, prefixing error messages with path
func (_gfadg *CT_Path2DQuadBezierTo) ValidateWithPath(path string) error {
	for _bebbf, _fdebe := range _gfadg.Pt {
		if _agcd := _fdebe.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fPt\u005b\u0025d]", path, _bebbf)); _agcd != nil {
			return _agcd
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Vector3D and its children, prefixing error messages with path
func (_dadbb *CT_Vector3D) ValidateWithPath(path string) error {
	if _cfeeb := _dadbb.DxAttr.ValidateWithPath(path + "\u002fDxAttr"); _cfeeb != nil {
		return _cfeeb
	}
	if _eagdg := _dadbb.DyAttr.ValidateWithPath(path + "\u002fDyAttr"); _eagdg != nil {
		return _eagdg
	}
	if _adade := _dadbb.DzAttr.ValidateWithPath(path + "\u002fDzAttr"); _adade != nil {
		return _adade
	}
	return nil
}
func (_gfaggb ST_LightRigType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_gfaggb.String(), start)
}
func (_dgfad *ThemeManager) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dgfad.CT_EmptyElement = *NewCT_EmptyElement()
	for {
		_dacaeg, _cgdefa := d.Token()
		if _cgdefa != nil {
			return _dcf.Errorf("parsing\u0020ThemeManager:\u0020\u0025s", _cgdefa)
		}
		if _baadc, _efegc := _dacaeg.(_g.EndElement); _efegc && _baadc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dgbc *CT_TableStyleTextStyle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _cedgf := range start.Attr {
		if _cedgf.Name.Local == "b" {
			_dgbc.BAttr.UnmarshalXMLAttr(_cedgf)
			continue
		}
		if _cedgf.Name.Local == "i" {
			_dgbc.IAttr.UnmarshalXMLAttr(_cedgf)
			continue
		}
	}
_acebg:
	for {
		_abbda, _ecgbc := d.Token()
		if _ecgbc != nil {
			return _ecgbc
		}
		switch _bccgeb := _abbda.(type) {
		case _g.StartElement:
			switch _bccgeb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "font"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "font"}:
				_dgbc.Font = NewCT_FontCollection()
				if _bbgabe := d.DecodeElement(_dgbc.Font, &_bccgeb); _bbgabe != nil {
					return _bbgabe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fontRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fontRef"}:
				_dgbc.FontRef = NewCT_FontReference()
				if _addea := d.DecodeElement(_dgbc.FontRef, &_bccgeb); _addea != nil {
					return _addea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_dgbc.ScrgbClr = NewCT_ScRgbColor()
				if _fbega := d.DecodeElement(_dgbc.ScrgbClr, &_bccgeb); _fbega != nil {
					return _fbega
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_dgbc.SrgbClr = NewCT_SRgbColor()
				if _cece := d.DecodeElement(_dgbc.SrgbClr, &_bccgeb); _cece != nil {
					return _cece
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_dgbc.HslClr = NewCT_HslColor()
				if _eabgc := d.DecodeElement(_dgbc.HslClr, &_bccgeb); _eabgc != nil {
					return _eabgc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_dgbc.SysClr = NewCT_SystemColor()
				if _babed := d.DecodeElement(_dgbc.SysClr, &_bccgeb); _babed != nil {
					return _babed
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_dgbc.SchemeClr = NewCT_SchemeColor()
				if _edabcc := d.DecodeElement(_dgbc.SchemeClr, &_bccgeb); _edabcc != nil {
					return _edabcc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_dgbc.PrstClr = NewCT_PresetColor()
				if _eegaf := d.DecodeElement(_dgbc.PrstClr, &_bccgeb); _eegaf != nil {
					return _eegaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_dgbc.ExtLst = NewCT_OfficeArtExtensionList()
				if _efgg := d.DecodeElement(_dgbc.ExtLst, &_bccgeb); _efgg != nil {
					return _efgg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TableStyleTextStyle\u0020\u0025v", _bccgeb.Name)
				if _bdfcf := d.Skip(); _bdfcf != nil {
					return _bdfcf
				}
			}
		case _g.EndElement:
			break _acebg
		case _g.CharData:
		}
	}
	return nil
}
func (_baaabc *CT_Table) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_baaabc.TblGrid = NewCT_TableGrid()
_ggdca:
	for {
		_efdf, _ebcgb := d.Token()
		if _ebcgb != nil {
			return _ebcgb
		}
		switch _agdc := _efdf.(type) {
		case _g.StartElement:
			switch _agdc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tblPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tblPr"}:
				_baaabc.TblPr = NewCT_TableProperties()
				if _dgcfe := d.DecodeElement(_baaabc.TblPr, &_agdc); _dgcfe != nil {
					return _dgcfe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tblGrid"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tblGrid"}:
				if _ebdf := d.DecodeElement(_baaabc.TblGrid, &_agdc); _ebdf != nil {
					return _ebdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tr"}:
				_bdgaf := NewCT_TableRow()
				if _gegfd := d.DecodeElement(_bdgaf, &_agdc); _gegfd != nil {
					return _gegfd
				}
				_baaabc.Tr = append(_baaabc.Tr, _bdgaf)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Table\u0020\u0025v", _agdc.Name)
				if _cgac := d.Skip(); _cgac != nil {
					return _cgac
				}
			}
		case _g.EndElement:
			break _ggdca
		case _g.CharData:
		}
	}
	return nil
}

type CT_GvmlConnectorNonVisual struct {
	CNvPr      *CT_NonVisualDrawingProps
	CNvCxnSpPr *CT_NonVisualConnectorProperties
}

// Validate validates the CT_TextBulletTypefaceFollowText and its children
func (_dcgfgc *CT_TextBulletTypefaceFollowText) Validate() error {
	return _dcgfgc.ValidateWithPath("CT_TextBulletTypefaceFollowText")
}

var ST_TextBulletSizePercentPatternRe = _dc.MustCompile(ST_TextBulletSizePercentPattern)

type CT_TextNormalAutofit struct {
	FontScaleAttr      *ST_TextFontScalePercentOrPercentString
	LnSpcReductionAttr *ST_TextSpacingPercentOrPercentString
}

// ValidateWithPath validates the EG_ThemeableFontStyles and its children, prefixing error messages with path
func (_dfbfd *EG_ThemeableFontStyles) ValidateWithPath(path string) error {
	if _dfbfd.Font != nil {
		if _fbecc := _dfbfd.Font.ValidateWithPath(path + "\u002fFont"); _fbecc != nil {
			return _fbecc
		}
	}
	if _dfbfd.FontRef != nil {
		if _bcecg := _dfbfd.FontRef.ValidateWithPath(path + "\u002fFontRef"); _bcecg != nil {
			return _bcecg
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ColorMappingOverride and its children, prefixing error messages with path
func (_agee *CT_ColorMappingOverride) ValidateWithPath(path string) error {
	if _dbac := _agee.Choice.ValidateWithPath(path + "\u002fChoice"); _dbac != nil {
		return _dbac
	}
	return nil
}
func (_dcdda *CT_Vector3D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fbbff := range start.Attr {
		if _fbbff.Name.Local == "dx" {
			_bfbbc, _abcfd := ParseUnionST_Coordinate(_fbbff.Value)
			if _abcfd != nil {
				return _abcfd
			}
			_dcdda.DxAttr = _bfbbc
			continue
		}
		if _fbbff.Name.Local == "dy" {
			_fgbdg, _fegag := ParseUnionST_Coordinate(_fbbff.Value)
			if _fegag != nil {
				return _fegag
			}
			_dcdda.DyAttr = _fgbdg
			continue
		}
		if _fbbff.Name.Local == "dz" {
			_afeca, _edcdg := ParseUnionST_Coordinate(_fbbff.Value)
			if _edcdg != nil {
				return _edcdg
			}
			_dcdda.DzAttr = _afeca
			continue
		}
	}
	for {
		_fggee, _dafac := d.Token()
		if _dafac != nil {
			return _dcf.Errorf("parsing\u0020CT_Vector3D:\u0020\u0025s", _dafac)
		}
		if _eefge, _dfdacd := _fggee.(_g.EndElement); _dfdacd && _eefge.Name == start.Name {
			break
		}
	}
	return nil
}
func (_afed *ST_TileFlipMode) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_afed = 0
	case "none":
		*_afed = 1
	case "x":
		*_afed = 2
	case "y":
		*_afed = 3
	case "xy":
		*_afed = 4
	}
	return nil
}
func NewCT_InverseTransform() *CT_InverseTransform { _gbfb := &CT_InverseTransform{}; return _gbfb }

const (
	ST_ColorSchemeIndexUnset    ST_ColorSchemeIndex = 0
	ST_ColorSchemeIndexDk1      ST_ColorSchemeIndex = 1
	ST_ColorSchemeIndexLt1      ST_ColorSchemeIndex = 2
	ST_ColorSchemeIndexDk2      ST_ColorSchemeIndex = 3
	ST_ColorSchemeIndexLt2      ST_ColorSchemeIndex = 4
	ST_ColorSchemeIndexAccent1  ST_ColorSchemeIndex = 5
	ST_ColorSchemeIndexAccent2  ST_ColorSchemeIndex = 6
	ST_ColorSchemeIndexAccent3  ST_ColorSchemeIndex = 7
	ST_ColorSchemeIndexAccent4  ST_ColorSchemeIndex = 8
	ST_ColorSchemeIndexAccent5  ST_ColorSchemeIndex = 9
	ST_ColorSchemeIndexAccent6  ST_ColorSchemeIndex = 10
	ST_ColorSchemeIndexHlink    ST_ColorSchemeIndex = 11
	ST_ColorSchemeIndexFolHlink ST_ColorSchemeIndex = 12
)

func (_acc *CT_AlphaInverseEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _acc.ScrgbClr != nil {
		_gae := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_acc.ScrgbClr, _gae)
	}
	if _acc.SrgbClr != nil {
		_bgdg := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_acc.SrgbClr, _bgdg)
	}
	if _acc.HslClr != nil {
		_gdg := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_acc.HslClr, _gdg)
	}
	if _acc.SysClr != nil {
		_cae := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_acc.SysClr, _cae)
	}
	if _acc.SchemeClr != nil {
		_bdda := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_acc.SchemeClr, _bdda)
	}
	if _acc.PrstClr != nil {
		_faeb := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_acc.PrstClr, _faeb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_bdec ST_OnOffStyleType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_cfdbc := _g.Attr{}
	_cfdbc.Name = name
	switch _bdec {
	case ST_OnOffStyleTypeUnset:
		_cfdbc.Value = ""
	case ST_OnOffStyleTypeOn:
		_cfdbc.Value = "on"
	case ST_OnOffStyleTypeOff:
		_cfdbc.Value = "off"
	case ST_OnOffStyleTypeDef:
		_cfdbc.Value = "def"
	}
	return _cfdbc, nil
}
func (_fbbfd ST_SchemeColorVal) Validate() error { return _fbbfd.ValidateWithPath("") }

// ValidateWithPath validates the CT_GradientStop and its children, prefixing error messages with path
func (_gbdd *CT_GradientStop) ValidateWithPath(path string) error {
	if _cdfa := _gbdd.PosAttr.ValidateWithPath(path + "\u002fPosAttr"); _cdfa != nil {
		return _cdfa
	}
	if _gbdd.ScrgbClr != nil {
		if _edeca := _gbdd.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _edeca != nil {
			return _edeca
		}
	}
	if _gbdd.SrgbClr != nil {
		if _gbcbd := _gbdd.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _gbcbd != nil {
			return _gbcbd
		}
	}
	if _gbdd.HslClr != nil {
		if _agefb := _gbdd.HslClr.ValidateWithPath(path + "\u002fHslClr"); _agefb != nil {
			return _agefb
		}
	}
	if _gbdd.SysClr != nil {
		if _bgeb := _gbdd.SysClr.ValidateWithPath(path + "\u002fSysClr"); _bgeb != nil {
			return _bgeb
		}
	}
	if _gbdd.SchemeClr != nil {
		if _bcae := _gbdd.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _bcae != nil {
			return _bcae
		}
	}
	if _gbdd.PrstClr != nil {
		if _egcae := _gbdd.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _egcae != nil {
			return _egcae
		}
	}
	return nil
}
func (_cagga *CT_FontCollection) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cagga.Latin = NewCT_TextFont()
	_cagga.Ea = NewCT_TextFont()
	_cagga.Cs = NewCT_TextFont()
_gddge:
	for {
		_bacb, _gegae := d.Token()
		if _gegae != nil {
			return _gegae
		}
		switch _dfba := _bacb.(type) {
		case _g.StartElement:
			switch _dfba.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "latin"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "latin"}:
				if _cffb := d.DecodeElement(_cagga.Latin, &_dfba); _cffb != nil {
					return _cffb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ea"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ea"}:
				if _eadgae := d.DecodeElement(_cagga.Ea, &_dfba); _eadgae != nil {
					return _eadgae
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cs"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cs"}:
				if _bfee := d.DecodeElement(_cagga.Cs, &_dfba); _bfee != nil {
					return _bfee
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "font"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "font"}:
				_bgcb := NewCT_SupplementalFont()
				if _fdcag := d.DecodeElement(_bgcb, &_dfba); _fdcag != nil {
					return _fdcag
				}
				_cagga.Font = append(_cagga.Font, _bgcb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_cagga.ExtLst = NewCT_OfficeArtExtensionList()
				if _ffaaf := d.DecodeElement(_cagga.ExtLst, &_dfba); _ffaaf != nil {
					return _ffaaf
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_FontCollection\u0020\u0025v", _dfba.Name)
				if _beaf := d.Skip(); _beaf != nil {
					return _beaf
				}
			}
		case _g.EndElement:
			break _gddge
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_ShapeLocking and its children
func (_bfcd *CT_ShapeLocking) Validate() error { return _bfcd.ValidateWithPath("CT_ShapeLocking") }

// ValidateWithPath validates the EG_TextUnderlineFill and its children, prefixing error messages with path
func (_fbgdg *EG_TextUnderlineFill) ValidateWithPath(path string) error {
	if _fbgdg.UFillTx != nil {
		if _effdb := _fbgdg.UFillTx.ValidateWithPath(path + "\u002fUFillTx"); _effdb != nil {
			return _effdb
		}
	}
	if _fbgdg.UFill != nil {
		if _fdfae := _fbgdg.UFill.ValidateWithPath(path + "\u002fUFill"); _fdfae != nil {
			return _fdfae
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TextNoBullet and its children, prefixing error messages with path
func (_geeea *CT_TextNoBullet) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_PositiveSize2D and its children
func (_bddb *CT_PositiveSize2D) Validate() error   { return _bddb.ValidateWithPath("CT_PositiveSize2D") }
func (_gfgcd ST_TextVerticalType) Validate() error { return _gfgcd.ValidateWithPath("") }
func (_aegbeg ST_LineEndLength) ValidateWithPath(path string) error {
	switch _aegbeg {
	case 0, 1, 2, 3:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aegbeg))
	}
	return nil
}

// Validate validates the CT_Angle and its children
func (_dge *CT_Angle) Validate() error { return _dge.ValidateWithPath("CT_Angle") }

// Validate validates the CT_Vector3D and its children
func (_eafad *CT_Vector3D) Validate() error { return _eafad.ValidateWithPath("CT_Vector3D") }

// Validate validates the CT_XYAdjustHandle and its children
func (_eccdf *CT_XYAdjustHandle) Validate() error {
	return _eccdf.ValidateWithPath("CT_XYAdjustHandle")
}

type CT_Headers struct{ Header []string }

func (_dbdbb ST_PenAlignment) ValidateWithPath(path string) error {
	switch _dbdbb {
	case 0, 1, 2:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dbdbb))
	}
	return nil
}
func (_gaaeg ST_OnOffStyleType) Validate() error { return _gaaeg.ValidateWithPath("") }
func NewCT_AnimationChartBuildProperties() *CT_AnimationChartBuildProperties {
	_egbb := &CT_AnimationChartBuildProperties{}
	return _egbb
}
func (_afaad *CT_TextShapeAutofit) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_Path2DLineTo() *CT_Path2DLineTo {
	_febge := &CT_Path2DLineTo{}
	_febge.Pt = NewCT_AdjPoint2D()
	return _febge
}
func (_ddcda ST_RectAlignment) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ddcda.String(), start)
}
func NewCT_ReflectionEffect() *CT_ReflectionEffect { _gcgfe := &CT_ReflectionEffect{}; return _gcgfe }
func (_egccbg *ST_TextCapsType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_egccbg = 0
	case "none":
		*_egccbg = 1
	case "small":
		*_egccbg = 2
	case "all":
		*_egccbg = 3
	}
	return nil
}

// ValidateWithPath validates the CT_EffectReference and its children, prefixing error messages with path
func (_bddc *CT_EffectReference) ValidateWithPath(path string) error { return nil }
func (_dbgga *ST_AnimationChartOnlyBuildType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_acfdg, _geead := d.Token()
	if _geead != nil {
		return _geead
	}
	if _ddaabf, _gaaa := _acfdg.(_g.EndElement); _gaaa && _ddaabf.Name == start.Name {
		*_dbgga = 1
		return nil
	}
	if _acafb, _acfdf := _acfdg.(_g.CharData); !_acfdf {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _acfdg)
	} else {
		switch string(_acafb) {
		case "":
			*_dbgga = 0
		case "series":
			*_dbgga = 1
		case "category":
			*_dbgga = 2
		case "seriesEl":
			*_dbgga = 3
		case "categoryEl":
			*_dbgga = 4
		}
	}
	_acfdg, _geead = d.Token()
	if _geead != nil {
		return _geead
	}
	if _cgced, _dgedce := _acfdg.(_g.EndElement); _dgedce && _cgced.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _acfdg)
}

// Validate validates the CT_BlurEffect and its children
func (_ege *CT_BlurEffect) Validate() error { return _ege.ValidateWithPath("CT_BlurEffect") }
func (_bgbeg *CT_OuterShadowEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _dfgg := range start.Attr {
		if _dfgg.Name.Local == "algn" {
			_bgbeg.AlgnAttr.UnmarshalXMLAttr(_dfgg)
			continue
		}
		if _dfgg.Name.Local == "rotWithShape" {
			_fggc, _geefb := _e.ParseBool(_dfgg.Value)
			if _geefb != nil {
				return _geefb
			}
			_bgbeg.RotWithShapeAttr = &_fggc
			continue
		}
		if _dfgg.Name.Local == "dist" {
			_gdefa, _febb := _e.ParseInt(_dfgg.Value, 10, 64)
			if _febb != nil {
				return _febb
			}
			_bgbeg.DistAttr = &_gdefa
			continue
		}
		if _dfgg.Name.Local == "sx" {
			_dgcf, _bdcbb := ParseUnionST_Percentage(_dfgg.Value)
			if _bdcbb != nil {
				return _bdcbb
			}
			_bgbeg.SxAttr = &_dgcf
			continue
		}
		if _dfgg.Name.Local == "sy" {
			_dfag, _gecgf := ParseUnionST_Percentage(_dfgg.Value)
			if _gecgf != nil {
				return _gecgf
			}
			_bgbeg.SyAttr = &_dfag
			continue
		}
		if _dfgg.Name.Local == "kx" {
			_gdcbf, _fadeg := _e.ParseInt(_dfgg.Value, 10, 32)
			if _fadeg != nil {
				return _fadeg
			}
			_egdeg := int32(_gdcbf)
			_bgbeg.KxAttr = &_egdeg
			continue
		}
		if _dfgg.Name.Local == "ky" {
			_gdfab, _acfa := _e.ParseInt(_dfgg.Value, 10, 32)
			if _acfa != nil {
				return _acfa
			}
			_caafg := int32(_gdfab)
			_bgbeg.KyAttr = &_caafg
			continue
		}
		if _dfgg.Name.Local == "blurRad" {
			_abdbb, _dbbdf := _e.ParseInt(_dfgg.Value, 10, 64)
			if _dbbdf != nil {
				return _dbbdf
			}
			_bgbeg.BlurRadAttr = &_abdbb
			continue
		}
		if _dfgg.Name.Local == "dir" {
			_abdc, _acdag := _e.ParseInt(_dfgg.Value, 10, 32)
			if _acdag != nil {
				return _acdag
			}
			_eecac := int32(_abdc)
			_bgbeg.DirAttr = &_eecac
			continue
		}
	}
_aeeb:
	for {
		_bdedc, _adadd := d.Token()
		if _adadd != nil {
			return _adadd
		}
		switch _bdeb := _bdedc.(type) {
		case _g.StartElement:
			switch _bdeb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_bgbeg.ScrgbClr = NewCT_ScRgbColor()
				if _bageg := d.DecodeElement(_bgbeg.ScrgbClr, &_bdeb); _bageg != nil {
					return _bageg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_bgbeg.SrgbClr = NewCT_SRgbColor()
				if _efgea := d.DecodeElement(_bgbeg.SrgbClr, &_bdeb); _efgea != nil {
					return _efgea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_bgbeg.HslClr = NewCT_HslColor()
				if _edge := d.DecodeElement(_bgbeg.HslClr, &_bdeb); _edge != nil {
					return _edge
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_bgbeg.SysClr = NewCT_SystemColor()
				if _fcff := d.DecodeElement(_bgbeg.SysClr, &_bdeb); _fcff != nil {
					return _fcff
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_bgbeg.SchemeClr = NewCT_SchemeColor()
				if _bbaab := d.DecodeElement(_bgbeg.SchemeClr, &_bdeb); _bbaab != nil {
					return _bbaab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_bgbeg.PrstClr = NewCT_PresetColor()
				if _defab := d.DecodeElement(_bgbeg.PrstClr, &_bdeb); _defab != nil {
					return _defab
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_OuterShadowEffect\u0020\u0025v", _bdeb.Name)
				if _bafe := d.Skip(); _bafe != nil {
					return _bafe
				}
			}
		case _g.EndElement:
			break _aeeb
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_NoFillProperties() *CT_NoFillProperties { _fade := &CT_NoFillProperties{}; return _fade }

type CT_GroupTransform2D struct {
	RotAttr   *int32
	FlipHAttr *bool
	FlipVAttr *bool
	Off       *CT_Point2D
	Ext       *CT_PositiveSize2D
	ChOff     *CT_Point2D
	ChExt     *CT_PositiveSize2D
}

func NewCT_EffectStyleItem() *CT_EffectStyleItem { _ecbe := &CT_EffectStyleItem{}; return _ecbe }
func (_dafed ST_DgmBuildStep) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_dafed.String(), start)
}
func (_cfa *CT_ClipboardStyleSheet) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cfa.ThemeElements = NewCT_BaseStyles()
	_cfa.ClrMap = NewCT_ColorMapping()
_bed:
	for {
		_ageg, _efgca := d.Token()
		if _efgca != nil {
			return _efgca
		}
		switch _geeef := _ageg.(type) {
		case _g.StartElement:
			switch _geeef.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "themeElements"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "themeElements"}:
				if _dccbg := d.DecodeElement(_cfa.ThemeElements, &_geeef); _dccbg != nil {
					return _dccbg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrMap"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrMap"}:
				if _ceaf := d.DecodeElement(_cfa.ClrMap, &_geeef); _ceaf != nil {
					return _ceaf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ClipboardStyleSheet\u0020\u0025v", _geeef.Name)
				if _bgee := d.Skip(); _bgee != nil {
					return _bgee
				}
			}
		case _g.EndElement:
			break _bed
		case _g.CharData:
		}
	}
	return nil
}
func (_egdab *CT_RelativeRect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _egdab.LAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "l"}, Value: _dcf.Sprintf("\u0025v", *_egdab.LAttr)})
	}
	if _egdab.TAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "t"}, Value: _dcf.Sprintf("\u0025v", *_egdab.TAttr)})
	}
	if _egdab.RAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r"}, Value: _dcf.Sprintf("\u0025v", *_egdab.RAttr)})
	}
	if _egdab.BAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "b"}, Value: _dcf.Sprintf("\u0025v", *_egdab.BAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_bcecc *EG_Text3D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_edegb:
	for {
		_acbeed, _agbeb := d.Token()
		if _agbeb != nil {
			return _agbeb
		}
		switch _fcgbg := _acbeed.(type) {
		case _g.StartElement:
			switch _fcgbg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sp3d"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sp3d"}:
				_bcecc.Sp3d = NewCT_Shape3D()
				if _cgcdg := d.DecodeElement(_bcecc.Sp3d, &_fcgbg); _cgcdg != nil {
					return _cgcdg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "flatTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "flatTx"}:
				_bcecc.FlatTx = NewCT_FlatText()
				if _bdgde := d.DecodeElement(_bcecc.FlatTx, &_fcgbg); _bdgde != nil {
					return _bdgde
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on EG_Text3D \u0025v", _fcgbg.Name)
				if _dgbfb := d.Skip(); _dgbfb != nil {
					return _dgbfb
				}
			}
		case _g.EndElement:
			break _edegb
		case _g.CharData:
		}
	}
	return nil
}

const (
	ST_TextShapeTypeUnset                     ST_TextShapeType = 0
	ST_TextShapeTypeTextNoShape               ST_TextShapeType = 1
	ST_TextShapeTypeTextPlain                 ST_TextShapeType = 2
	ST_TextShapeTypeTextStop                  ST_TextShapeType = 3
	ST_TextShapeTypeTextTriangle              ST_TextShapeType = 4
	ST_TextShapeTypeTextTriangleInverted      ST_TextShapeType = 5
	ST_TextShapeTypeTextChevron               ST_TextShapeType = 6
	ST_TextShapeTypeTextChevronInverted       ST_TextShapeType = 7
	ST_TextShapeTypeTextRingInside            ST_TextShapeType = 8
	ST_TextShapeTypeTextRingOutside           ST_TextShapeType = 9
	ST_TextShapeTypeTextArchUp                ST_TextShapeType = 10
	ST_TextShapeTypeTextArchDown              ST_TextShapeType = 11
	ST_TextShapeTypeTextCircle                ST_TextShapeType = 12
	ST_TextShapeTypeTextButton                ST_TextShapeType = 13
	ST_TextShapeTypeTextArchUpPour            ST_TextShapeType = 14
	ST_TextShapeTypeTextArchDownPour          ST_TextShapeType = 15
	ST_TextShapeTypeTextCirclePour            ST_TextShapeType = 16
	ST_TextShapeTypeTextButtonPour            ST_TextShapeType = 17
	ST_TextShapeTypeTextCurveUp               ST_TextShapeType = 18
	ST_TextShapeTypeTextCurveDown             ST_TextShapeType = 19
	ST_TextShapeTypeTextCanUp                 ST_TextShapeType = 20
	ST_TextShapeTypeTextCanDown               ST_TextShapeType = 21
	ST_TextShapeTypeTextWave1                 ST_TextShapeType = 22
	ST_TextShapeTypeTextWave2                 ST_TextShapeType = 23
	ST_TextShapeTypeTextDoubleWave1           ST_TextShapeType = 24
	ST_TextShapeTypeTextWave4                 ST_TextShapeType = 25
	ST_TextShapeTypeTextInflate               ST_TextShapeType = 26
	ST_TextShapeTypeTextDeflate               ST_TextShapeType = 27
	ST_TextShapeTypeTextInflateBottom         ST_TextShapeType = 28
	ST_TextShapeTypeTextDeflateBottom         ST_TextShapeType = 29
	ST_TextShapeTypeTextInflateTop            ST_TextShapeType = 30
	ST_TextShapeTypeTextDeflateTop            ST_TextShapeType = 31
	ST_TextShapeTypeTextDeflateInflate        ST_TextShapeType = 32
	ST_TextShapeTypeTextDeflateInflateDeflate ST_TextShapeType = 33
	ST_TextShapeTypeTextFadeRight             ST_TextShapeType = 34
	ST_TextShapeTypeTextFadeLeft              ST_TextShapeType = 35
	ST_TextShapeTypeTextFadeUp                ST_TextShapeType = 36
	ST_TextShapeTypeTextFadeDown              ST_TextShapeType = 37
	ST_TextShapeTypeTextSlantUp               ST_TextShapeType = 38
	ST_TextShapeTypeTextSlantDown             ST_TextShapeType = 39
	ST_TextShapeTypeTextCascadeUp             ST_TextShapeType = 40
	ST_TextShapeTypeTextCascadeDown           ST_TextShapeType = 41
)

// ValidateWithPath validates the CT_Percentage and its children, prefixing error messages with path
func (_acbd *CT_Percentage) ValidateWithPath(path string) error {
	if _abdbc := _acbd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _abdbc != nil {
		return _abdbc
	}
	return nil
}
func (_aecf *CT_NoFillProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_agaff *EG_Media) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _agaff.AudioCd != nil {
		_bbddb := _g.StartElement{Name: _g.Name{Local: "a:audioCd"}}
		e.EncodeElement(_agaff.AudioCd, _bbddb)
	}
	if _agaff.WavAudioFile != nil {
		_fedcg := _g.StartElement{Name: _g.Name{Local: "a:wavAudioFile"}}
		e.EncodeElement(_agaff.WavAudioFile, _fedcg)
	}
	if _agaff.AudioFile != nil {
		_gbfgdb := _g.StartElement{Name: _g.Name{Local: "a:audioFile"}}
		e.EncodeElement(_agaff.AudioFile, _gbfgdb)
	}
	if _agaff.VideoFile != nil {
		_gaaed := _g.StartElement{Name: _g.Name{Local: "a:videoFile"}}
		e.EncodeElement(_agaff.VideoFile, _gaaed)
	}
	if _agaff.QuickTimeFile != nil {
		_cgeea := _g.StartElement{Name: _g.Name{Local: "a:quickTimeFile"}}
		e.EncodeElement(_agaff.QuickTimeFile, _cgeea)
	}
	return nil
}

const (
	ST_TextHorzOverflowTypeUnset    ST_TextHorzOverflowType = 0
	ST_TextHorzOverflowTypeOverflow ST_TextHorzOverflowType = 1
	ST_TextHorzOverflowTypeClip     ST_TextHorzOverflowType = 2
)

func (_abgbeb ST_TextVerticalType) ValidateWithPath(path string) error {
	switch _abgbeb {
	case 0, 1, 2, 3, 4, 5, 6, 7:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_abgbeb))
	}
	return nil
}
func (_fegfa *EG_ShadeProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_acfae:
	for {
		_aefdfc, _abafd := d.Token()
		if _abafd != nil {
			return _abafd
		}
		switch _adabd := _aefdfc.(type) {
		case _g.StartElement:
			switch _adabd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lin"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lin"}:
				_fegfa.Lin = NewCT_LinearShadeProperties()
				if _cfgbeg := d.DecodeElement(_fegfa.Lin, &_adabd); _cfgbeg != nil {
					return _cfgbeg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "path"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "path"}:
				_fegfa.Path = NewCT_PathShadeProperties()
				if _aecbb := d.DecodeElement(_fegfa.Path, &_adabd); _aecbb != nil {
					return _aecbb
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020EG_ShadeProperties\u0020\u0025v", _adabd.Name)
				if _febff := d.Skip(); _febff != nil {
					return _febff
				}
			}
		case _g.EndElement:
			break _acfae
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_EffectProperties and its children
func (_fcdb *CT_EffectProperties) Validate() error {
	return _fcdb.ValidateWithPath("CT_EffectProperties")
}
func (_aeag *CT_DashStopList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_deca:
	for {
		_fegbc, _cagc := d.Token()
		if _cagc != nil {
			return _cagc
		}
		switch _beaa := _fegbc.(type) {
		case _g.StartElement:
			switch _beaa.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ds"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ds"}:
				_aaef := NewCT_DashStop()
				if _baca := d.DecodeElement(_aaef, &_beaa); _baca != nil {
					return _baca
				}
				_aeag.Ds = append(_aeag.Ds, _aaef)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DashStopList\u0020\u0025v", _beaa.Name)
				if _dbeg := d.Skip(); _dbeg != nil {
					return _dbeg
				}
			}
		case _g.EndElement:
			break _deca
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the EG_TextAutofit and its children
func (_acffaa *EG_TextAutofit) Validate() error { return _acffaa.ValidateWithPath("EG_TextAutofit") }
func (_dgea *CT_TextCharBullet) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "char"}, Value: _dcf.Sprintf("\u0025v", _dgea.CharAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_NonVisualGraphicFrameProperties and its children
func (_acbee *CT_NonVisualGraphicFrameProperties) Validate() error {
	return _acbee.ValidateWithPath("CT_NonVisualGraphicFrameProperties")
}
func (_fffe *CT_ColorChangeEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fffe.UseAAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "useA"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fffe.UseAAttr))})
	}
	e.EncodeToken(start)
	_gagd := _g.StartElement{Name: _g.Name{Local: "a:clrFrom"}}
	e.EncodeElement(_fffe.ClrFrom, _gagd)
	_fbg := _g.StartElement{Name: _g.Name{Local: "a:clrTo"}}
	e.EncodeElement(_fffe.ClrTo, _fbg)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_BiLevelEffect and its children
func (_gdgb *CT_BiLevelEffect) Validate() error { return _gdgb.ValidateWithPath("CT_BiLevelEffect") }
func (_abfb *CT_ShapeStyle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_abfb.LnRef = NewCT_StyleMatrixReference()
	_abfb.FillRef = NewCT_StyleMatrixReference()
	_abfb.EffectRef = NewCT_StyleMatrixReference()
	_abfb.FontRef = NewCT_FontReference()
_edcfg:
	for {
		_bacdd, _fccea := d.Token()
		if _fccea != nil {
			return _fccea
		}
		switch _beffc := _bacdd.(type) {
		case _g.StartElement:
			switch _beffc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnRef"}:
				if _aedeb := d.DecodeElement(_abfb.LnRef, &_beffc); _aedeb != nil {
					return _aedeb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillRef"}:
				if _bagdda := d.DecodeElement(_abfb.FillRef, &_beffc); _bagdda != nil {
					return _bagdda
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectRef"}:
				if _febeb := d.DecodeElement(_abfb.EffectRef, &_beffc); _febeb != nil {
					return _febeb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fontRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fontRef"}:
				if _gdcba := d.DecodeElement(_abfb.FontRef, &_beffc); _gdcba != nil {
					return _gdcba
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_ShapeStyle \u0025v", _beffc.Name)
				if _fdgcf := d.Skip(); _fdgcf != nil {
					return _fdgcf
				}
			}
		case _g.EndElement:
			break _edcfg
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_LightRig and its children, prefixing error messages with path
func (_gbdbde *CT_LightRig) ValidateWithPath(path string) error {
	if _gbdbde.RigAttr == ST_LightRigTypeUnset {
		return _dcf.Errorf("\u0025s\u002fRigAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bbfgb := _gbdbde.RigAttr.ValidateWithPath(path + "\u002fRigAttr"); _bbfgb != nil {
		return _bbfgb
	}
	if _gbdbde.DirAttr == ST_LightRigDirectionUnset {
		return _dcf.Errorf("\u0025s\u002fDirAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bdaeg := _gbdbde.DirAttr.ValidateWithPath(path + "\u002fDirAttr"); _bdaeg != nil {
		return _bdaeg
	}
	if _gbdbde.Rot != nil {
		if _fdee := _gbdbde.Rot.ValidateWithPath(path + "\u002fRot"); _fdee != nil {
			return _fdee
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ClipboardStyleSheet and its children, prefixing error messages with path
func (_abge *CT_ClipboardStyleSheet) ValidateWithPath(path string) error {
	if _bcdc := _abge.ThemeElements.ValidateWithPath(path + "\u002fThemeElements"); _bcdc != nil {
		return _bcdc
	}
	if _gggg := _abge.ClrMap.ValidateWithPath(path + "\u002fClrMap"); _gggg != nil {
		return _gggg
	}
	return nil
}

// Validate validates the CT_NoFillProperties and its children
func (_ccefg *CT_NoFillProperties) Validate() error {
	return _ccefg.ValidateWithPath("CT_NoFillProperties")
}
func (_aaeeg *CT_Path2DArcTo) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "wR"}, Value: _dcf.Sprintf("\u0025v", _aaeeg.WRAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "hR"}, Value: _dcf.Sprintf("\u0025v", _aaeeg.HRAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "stAng"}, Value: _dcf.Sprintf("\u0025v", _aaeeg.StAngAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "swAng"}, Value: _dcf.Sprintf("\u0025v", _aaeeg.SwAngAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_aggfe ST_AnimationDgmOnlyBuildType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_gcfab := _g.Attr{}
	_gcfab.Name = name
	switch _aggfe {
	case ST_AnimationDgmOnlyBuildTypeUnset:
		_gcfab.Value = ""
	case ST_AnimationDgmOnlyBuildTypeOne:
		_gcfab.Value = "one"
	case ST_AnimationDgmOnlyBuildTypeLvlOne:
		_gcfab.Value = "lvlOne"
	case ST_AnimationDgmOnlyBuildTypeLvlAtOnce:
		_gcfab.Value = "lvlAtOnce"
	}
	return _gcfab, nil
}
func (_fgfb *CT_TableProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fgfb.RtlAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rtl"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fgfb.RtlAttr))})
	}
	if _fgfb.FirstRowAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "firstRow"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fgfb.FirstRowAttr))})
	}
	if _fgfb.FirstColAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "firstCol"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fgfb.FirstColAttr))})
	}
	if _fgfb.LastRowAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lastRow"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fgfb.LastRowAttr))})
	}
	if _fgfb.LastColAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lastCol"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fgfb.LastColAttr))})
	}
	if _fgfb.BandRowAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "bandRow"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fgfb.BandRowAttr))})
	}
	if _fgfb.BandColAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "bandCol"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fgfb.BandColAttr))})
	}
	e.EncodeToken(start)
	if _fgfb.NoFill != nil {
		_ddegd := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_fgfb.NoFill, _ddegd)
	}
	if _fgfb.SolidFill != nil {
		_ecbagf := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_fgfb.SolidFill, _ecbagf)
	}
	if _fgfb.GradFill != nil {
		_ecfeb := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_fgfb.GradFill, _ecfeb)
	}
	if _fgfb.BlipFill != nil {
		_eccac := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
		e.EncodeElement(_fgfb.BlipFill, _eccac)
	}
	if _fgfb.PattFill != nil {
		_eegag := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_fgfb.PattFill, _eegag)
	}
	if _fgfb.GrpFill != nil {
		_dbcgc := _g.StartElement{Name: _g.Name{Local: "a:grpFill"}}
		e.EncodeElement(_fgfb.GrpFill, _dbcgc)
	}
	if _fgfb.EffectLst != nil {
		_efcbd := _g.StartElement{Name: _g.Name{Local: "a:effectLst"}}
		e.EncodeElement(_fgfb.EffectLst, _efcbd)
	}
	if _fgfb.EffectDag != nil {
		_ebbca := _g.StartElement{Name: _g.Name{Local: "a:effectDag"}}
		e.EncodeElement(_fgfb.EffectDag, _ebbca)
	}
	if _fgfb.Choice != nil {
		_fgfb.Choice.MarshalXML(e, _g.StartElement{})
	}
	if _fgfb.ExtLst != nil {
		_fafa := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_fgfb.ExtLst, _fafa)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_FontCollection and its children
func (_ffbge *CT_FontCollection) Validate() error {
	return _ffbge.ValidateWithPath("CT_FontCollection")
}

// Validate validates the CT_TextBulletSizeFollowText and its children
func (_aeadd *CT_TextBulletSizeFollowText) Validate() error {
	return _aeadd.ValidateWithPath("CT_TextBulletSizeFollowText")
}

type CT_TableCellProperties struct {
	MarLAttr         *ST_Coordinate32
	MarRAttr         *ST_Coordinate32
	MarTAttr         *ST_Coordinate32
	MarBAttr         *ST_Coordinate32
	VertAttr         ST_TextVerticalType
	AnchorAttr       ST_TextAnchoringType
	AnchorCtrAttr    *bool
	HorzOverflowAttr ST_TextHorzOverflowType
	LnL              *CT_LineProperties
	LnR              *CT_LineProperties
	LnT              *CT_LineProperties
	LnB              *CT_LineProperties
	LnTlToBr         *CT_LineProperties
	LnBlToTr         *CT_LineProperties
	Cell3D           *CT_Cell3D
	NoFill           *CT_NoFillProperties
	SolidFill        *CT_SolidColorFillProperties
	GradFill         *CT_GradientFillProperties
	BlipFill         *CT_BlipFillProperties
	PattFill         *CT_PatternFillProperties
	GrpFill          *CT_GroupFillProperties
	Headers          *CT_Headers
	ExtLst           *CT_OfficeArtExtensionList
}

func (_aeeec *ST_TextFontScalePercentOrPercentString) ValidateWithPath(path string) error {
	_bbced := []string{}
	if _aeeec.ST_TextFontScalePercent != nil {
		_bbced = append(_bbced, "ST_TextFontScalePercent")
	}
	if _aeeec.ST_Percentage != nil {
		_bbced = append(_bbced, "ST_Percentage")
	}
	if len(_bbced) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _bbced)
	}
	return nil
}
func (_eebea ST_ColorSchemeIndex) ValidateWithPath(path string) error {
	switch _eebea {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eebea))
	}
	return nil
}

type CT_ConnectionSiteList struct{ Cxn []*CT_ConnectionSite }
type CT_ReflectionEffect struct {
	BlurRadAttr      *int64
	StAAttr          *ST_PositiveFixedPercentage
	StPosAttr        *ST_PositiveFixedPercentage
	EndAAttr         *ST_PositiveFixedPercentage
	EndPosAttr       *ST_PositiveFixedPercentage
	DistAttr         *int64
	DirAttr          *int32
	FadeDirAttr      *int32
	SxAttr           *ST_Percentage
	SyAttr           *ST_Percentage
	KxAttr           *int32
	KyAttr           *int32
	AlgnAttr         ST_RectAlignment
	RotWithShapeAttr *bool
}
type CT_AudioFile struct {
	LinkAttr        string
	ContentTypeAttr *string
	ExtLst          *CT_OfficeArtExtensionList
}

func (_cacf *ThemeOverride) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cacf.CT_BaseStylesOverride = *NewCT_BaseStylesOverride()
_fccaa:
	for {
		_ceacc, _dfccd := d.Token()
		if _dfccd != nil {
			return _dfccd
		}
		switch _effef := _ceacc.(type) {
		case _g.StartElement:
			switch _effef.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrScheme"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrScheme"}:
				_cacf.ClrScheme = NewCT_ColorScheme()
				if _dabf := d.DecodeElement(_cacf.ClrScheme, &_effef); _dabf != nil {
					return _dabf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fontScheme"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fontScheme"}:
				_cacf.FontScheme = NewCT_FontScheme()
				if _fdfda := d.DecodeElement(_cacf.FontScheme, &_effef); _fdfda != nil {
					return _fdfda
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fmtScheme"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fmtScheme"}:
				_cacf.FmtScheme = NewCT_StyleMatrix()
				if _adgea := d.DecodeElement(_cacf.FmtScheme, &_effef); _adgea != nil {
					return _adgea
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020ThemeOverride \u0025v", _effef.Name)
				if _fbacc := d.Skip(); _fbacc != nil {
					return _fbacc
				}
			}
		case _g.EndElement:
			break _fccaa
		case _g.CharData:
		}
	}
	return nil
}
func (_befdbd *ST_EffectContainerType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dfdad, _dcbfcfc := d.Token()
	if _dcbfcfc != nil {
		return _dcbfcfc
	}
	if _feccc, _cgfcfd := _dfdad.(_g.EndElement); _cgfcfd && _feccc.Name == start.Name {
		*_befdbd = 1
		return nil
	}
	if _bedd, _cccdf := _dfdad.(_g.CharData); !_cccdf {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dfdad)
	} else {
		switch string(_bedd) {
		case "":
			*_befdbd = 0
		case "sib":
			*_befdbd = 1
		case "tree":
			*_befdbd = 2
		}
	}
	_dfdad, _dcbfcfc = d.Token()
	if _dcbfcfc != nil {
		return _dcbfcfc
	}
	if _dbecb, _gacfd := _dfdad.(_g.EndElement); _gacfd && _dbecb.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dfdad)
}
func (_cb *AG_Locking) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _cb.NoGrpAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noGrp"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_cb.NoGrpAttr))})
	}
	if _cb.NoSelectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noSelect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_cb.NoSelectAttr))})
	}
	if _cb.NoRotAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noRot"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_cb.NoRotAttr))})
	}
	if _cb.NoChangeAspectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeAspect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_cb.NoChangeAspectAttr))})
	}
	if _cb.NoMoveAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noMove"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_cb.NoMoveAttr))})
	}
	if _cb.NoResizeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noResize"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_cb.NoResizeAttr))})
	}
	if _cb.NoEditPointsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noEditPoints"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_cb.NoEditPointsAttr))})
	}
	if _cb.NoAdjustHandlesAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noAdjustHandles"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_cb.NoAdjustHandlesAttr))})
	}
	if _cb.NoChangeArrowheadsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeArrowheads"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_cb.NoChangeArrowheadsAttr))})
	}
	if _cb.NoChangeShapeTypeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeShapeType"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_cb.NoChangeShapeTypeAttr))})
	}
	return nil
}
func (_gfagf ST_TextShapeType) Validate() error { return _gfagf.ValidateWithPath("") }
func (_bfddd *ST_TextPoint) ValidateWithPath(path string) error {
	_efece := []string{}
	if _bfddd.ST_TextPointUnqualified != nil {
		_efece = append(_efece, "ST_TextPointUnqualified")
	}
	if _bfddd.ST_UniversalMeasure != nil {
		_efece = append(_efece, "ST_UniversalMeasure")
	}
	if len(_efece) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _efece)
	}
	return nil
}

// Validate validates the EG_Media and its children
func (_ggdagdb *EG_Media) Validate() error { return _ggdagdb.ValidateWithPath("EG_Media") }
func (_gaedb ST_PathFillMode) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_gaedb.String(), start)
}

// ValidateWithPath validates the CT_FlatText and its children, prefixing error messages with path
func (_bgdgg *CT_FlatText) ValidateWithPath(path string) error {
	if _bgdgg.ZAttr != nil {
		if _fdeda := _bgdgg.ZAttr.ValidateWithPath(path + "\u002fZAttr"); _fdeda != nil {
			return _fdeda
		}
	}
	return nil
}
func NewCT_Connection() *CT_Connection { _ccc := &CT_Connection{}; return _ccc }

// ValidateWithPath validates the CT_PolarAdjustHandle and its children, prefixing error messages with path
func (_fbbag *CT_PolarAdjustHandle) ValidateWithPath(path string) error {
	if _fbbag.MinRAttr != nil {
		if _ggbdbg := _fbbag.MinRAttr.ValidateWithPath(path + "\u002fMinRAttr"); _ggbdbg != nil {
			return _ggbdbg
		}
	}
	if _fbbag.MaxRAttr != nil {
		if _bfgcbb := _fbbag.MaxRAttr.ValidateWithPath(path + "\u002fMaxRAttr"); _bfgcbb != nil {
			return _bfgcbb
		}
	}
	if _fbbag.MinAngAttr != nil {
		if _ageaf := _fbbag.MinAngAttr.ValidateWithPath(path + "/MinAngAttr"); _ageaf != nil {
			return _ageaf
		}
	}
	if _fbbag.MaxAngAttr != nil {
		if _cebfg := _fbbag.MaxAngAttr.ValidateWithPath(path + "/MaxAngAttr"); _cebfg != nil {
			return _cebfg
		}
	}
	if _dece := _fbbag.Pos.ValidateWithPath(path + "\u002fPos"); _dece != nil {
		return _dece
	}
	return nil
}

// ValidateWithPath validates the CT_GeomRect and its children, prefixing error messages with path
func (_daeef *CT_GeomRect) ValidateWithPath(path string) error {
	if _ecfcf := _daeef.LAttr.ValidateWithPath(path + "\u002fLAttr"); _ecfcf != nil {
		return _ecfcf
	}
	if _gcbaa := _daeef.TAttr.ValidateWithPath(path + "\u002fTAttr"); _gcbaa != nil {
		return _gcbaa
	}
	if _gccaf := _daeef.RAttr.ValidateWithPath(path + "\u002fRAttr"); _gccaf != nil {
		return _gccaf
	}
	if _agea := _daeef.BAttr.ValidateWithPath(path + "\u002fBAttr"); _agea != nil {
		return _agea
	}
	return nil
}

// ValidateWithPath validates the CT_GradientStopList and its children, prefixing error messages with path
func (_gaee *CT_GradientStopList) ValidateWithPath(path string) error {
	for _fbbf, _gbef := range _gaee.Gs {
		if _acde := _gbef.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fGs\u005b\u0025d]", path, _fbbf)); _acde != nil {
			return _acde
		}
	}
	return nil
}

type CT_TextUnderlineLineFollowText struct{}

func (_aaaeb ST_TextVertOverflowType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dcgdee := _g.Attr{}
	_dcgdee.Name = name
	switch _aaaeb {
	case ST_TextVertOverflowTypeUnset:
		_dcgdee.Value = ""
	case ST_TextVertOverflowTypeOverflow:
		_dcgdee.Value = "overflow"
	case ST_TextVertOverflowTypeEllipsis:
		_dcgdee.Value = "ellipsis"
	case ST_TextVertOverflowTypeClip:
		_dcgdee.Value = "clip"
	}
	return _dcgdee, nil
}
func (_bbff *CT_FontScheme) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "name"}, Value: _dcf.Sprintf("\u0025v", _bbff.NameAttr)})
	e.EncodeToken(start)
	_cfeg := _g.StartElement{Name: _g.Name{Local: "a:majorFont"}}
	e.EncodeElement(_bbff.MajorFont, _cfeg)
	_ecbfc := _g.StartElement{Name: _g.Name{Local: "a:minorFont"}}
	e.EncodeElement(_bbff.MinorFont, _ecbfc)
	if _bbff.ExtLst != nil {
		_bfagf := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_bbff.ExtLst, _bfagf)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the EG_TextBulletSize and its children
func (_dfffe *EG_TextBulletSize) Validate() error {
	return _dfffe.ValidateWithPath("EG_TextBulletSize")
}

type EG_TextAutofit struct {
	NoAutofit   *CT_TextNoAutofit
	NormAutofit *CT_TextNormalAutofit
	SpAutoFit   *CT_TextShapeAutofit
}

func (_acgg ST_AnimationDgmOnlyBuildType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_acgg.String(), start)
}
func (_c *AG_Blob) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _c.EmbedAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r:embed"}, Value: _dcf.Sprintf("\u0025v", *_c.EmbedAttr)})
	}
	if _c.LinkAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r:link"}, Value: _dcf.Sprintf("\u0025v", *_c.LinkAttr)})
	}
	return nil
}
func (_acdbaec ST_RectAlignment) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dcbe := _g.Attr{}
	_dcbe.Name = name
	switch _acdbaec {
	case ST_RectAlignmentUnset:
		_dcbe.Value = ""
	case ST_RectAlignmentTl:
		_dcbe.Value = "tl"
	case ST_RectAlignmentT:
		_dcbe.Value = "t"
	case ST_RectAlignmentTr:
		_dcbe.Value = "tr"
	case ST_RectAlignmentL:
		_dcbe.Value = "l"
	case ST_RectAlignmentCtr:
		_dcbe.Value = "ctr"
	case ST_RectAlignmentR:
		_dcbe.Value = "r"
	case ST_RectAlignmentBl:
		_dcbe.Value = "bl"
	case ST_RectAlignmentB:
		_dcbe.Value = "b"
	case ST_RectAlignmentBr:
		_dcbe.Value = "br"
	}
	return _dcbe, nil
}

// ValidateWithPath validates the CT_Path2D and its children, prefixing error messages with path
func (_bbae *CT_Path2D) ValidateWithPath(path string) error {
	if _bbae.WAttr != nil {
		if *_bbae.WAttr < 0 {
			return _dcf.Errorf("\u0025s\u002fm\u002eWAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_bbae.WAttr)
		}
		if *_bbae.WAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s/m\u002eWAttr\u0020must\u0020be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_bbae.WAttr)
		}
	}
	if _bbae.HAttr != nil {
		if *_bbae.HAttr < 0 {
			return _dcf.Errorf("\u0025s\u002fm\u002eHAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_bbae.HAttr)
		}
		if *_bbae.HAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s/m\u002eHAttr\u0020must\u0020be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_bbae.HAttr)
		}
	}
	if _efbgb := _bbae.FillAttr.ValidateWithPath(path + "\u002fFillAttr"); _efbgb != nil {
		return _efbgb
	}
	for _dcegf, _feba := range _bbae.Close {
		if _gafc := _feba.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fClose\u005b\u0025d\u005d", path, _dcegf)); _gafc != nil {
			return _gafc
		}
	}
	for _eccge, _dbadb := range _bbae.MoveTo {
		if _gdebb := _dbadb.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fMoveTo\u005b\u0025d\u005d", path, _eccge)); _gdebb != nil {
			return _gdebb
		}
	}
	for _dccbb, _cbcdd := range _bbae.LnTo {
		if _cdcd := _cbcdd.ValidateWithPath(_dcf.Sprintf("%s\u002fLnTo\u005b\u0025d\u005d", path, _dccbb)); _cdcd != nil {
			return _cdcd
		}
	}
	for _eeeaac, _cedd := range _bbae.ArcTo {
		if _bbfd := _cedd.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fArcTo\u005b\u0025d\u005d", path, _eeeaac)); _bbfd != nil {
			return _bbfd
		}
	}
	for _gcfed, _befec := range _bbae.QuadBezTo {
		if _afgac := _befec.ValidateWithPath(_dcf.Sprintf("\u0025s/QuadBezTo\u005b\u0025d\u005d", path, _gcfed)); _afgac != nil {
			return _afgac
		}
	}
	for _aggb, _fcffg := range _bbae.CubicBezTo {
		if _aecag := _fcffg.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fCubicBezTo\u005b\u0025d\u005d", path, _aggb)); _aecag != nil {
			return _aecag
		}
	}
	return nil
}

// ValidateWithPath validates the EG_OfficeArtExtensionList and its children, prefixing error messages with path
func (_cbeeef *EG_OfficeArtExtensionList) ValidateWithPath(path string) error {
	for _aaagg, _cdede := range _cbeeef.Ext {
		if _ggcfg := _cdede.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fExt\u005b\u0025d\u005d", path, _aaagg)); _ggcfg != nil {
			return _ggcfg
		}
	}
	return nil
}
func (_gabb *CT_ColorMapping) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gabb.Bg1Attr = ST_ColorSchemeIndex(1)
	_gabb.Tx1Attr = ST_ColorSchemeIndex(1)
	_gabb.Bg2Attr = ST_ColorSchemeIndex(1)
	_gabb.Tx2Attr = ST_ColorSchemeIndex(1)
	_gabb.Accent1Attr = ST_ColorSchemeIndex(1)
	_gabb.Accent2Attr = ST_ColorSchemeIndex(1)
	_gabb.Accent3Attr = ST_ColorSchemeIndex(1)
	_gabb.Accent4Attr = ST_ColorSchemeIndex(1)
	_gabb.Accent5Attr = ST_ColorSchemeIndex(1)
	_gabb.Accent6Attr = ST_ColorSchemeIndex(1)
	_gabb.HlinkAttr = ST_ColorSchemeIndex(1)
	_gabb.FolHlinkAttr = ST_ColorSchemeIndex(1)
	for _, _ebda := range start.Attr {
		if _ebda.Name.Local == "accent3" {
			_gabb.Accent3Attr.UnmarshalXMLAttr(_ebda)
			continue
		}
		if _ebda.Name.Local == "tx1" {
			_gabb.Tx1Attr.UnmarshalXMLAttr(_ebda)
			continue
		}
		if _ebda.Name.Local == "bg2" {
			_gabb.Bg2Attr.UnmarshalXMLAttr(_ebda)
			continue
		}
		if _ebda.Name.Local == "tx2" {
			_gabb.Tx2Attr.UnmarshalXMLAttr(_ebda)
			continue
		}
		if _ebda.Name.Local == "accent1" {
			_gabb.Accent1Attr.UnmarshalXMLAttr(_ebda)
			continue
		}
		if _ebda.Name.Local == "accent2" {
			_gabb.Accent2Attr.UnmarshalXMLAttr(_ebda)
			continue
		}
		if _ebda.Name.Local == "bg1" {
			_gabb.Bg1Attr.UnmarshalXMLAttr(_ebda)
			continue
		}
		if _ebda.Name.Local == "accent4" {
			_gabb.Accent4Attr.UnmarshalXMLAttr(_ebda)
			continue
		}
		if _ebda.Name.Local == "accent5" {
			_gabb.Accent5Attr.UnmarshalXMLAttr(_ebda)
			continue
		}
		if _ebda.Name.Local == "accent6" {
			_gabb.Accent6Attr.UnmarshalXMLAttr(_ebda)
			continue
		}
		if _ebda.Name.Local == "hlink" {
			_gabb.HlinkAttr.UnmarshalXMLAttr(_ebda)
			continue
		}
		if _ebda.Name.Local == "folHlink" {
			_gabb.FolHlinkAttr.UnmarshalXMLAttr(_ebda)
			continue
		}
	}
_efba:
	for {
		_geed, _ggcb := d.Token()
		if _ggcb != nil {
			return _ggcb
		}
		switch _aecg := _geed.(type) {
		case _g.StartElement:
			switch _aecg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_gabb.ExtLst = NewCT_OfficeArtExtensionList()
				if _aafc := d.DecodeElement(_gabb.ExtLst, &_aecg); _aafc != nil {
					return _aafc
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ColorMapping\u0020\u0025v", _aecg.Name)
				if _cbfg := d.Skip(); _cbfg != nil {
					return _cbfg
				}
			}
		case _g.EndElement:
			break _efba
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Camera and its children
func (_caef *CT_Camera) Validate() error { return _caef.ValidateWithPath("CT_Camera") }

const (
	ST_FontCollectionIndexUnset ST_FontCollectionIndex = 0
	ST_FontCollectionIndexMajor ST_FontCollectionIndex = 1
	ST_FontCollectionIndexMinor ST_FontCollectionIndex = 2
	ST_FontCollectionIndexNone  ST_FontCollectionIndex = 3
)

type CT_BaseStylesOverride struct {
	ClrScheme  *CT_ColorScheme
	FontScheme *CT_FontScheme
	FmtScheme  *CT_StyleMatrix
}

func (_dcacb *ST_AnimationDgmOnlyBuildType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_dcacb = 0
	case "one":
		*_dcacb = 1
	case "lvlOne":
		*_dcacb = 2
	case "lvlAtOnce":
		*_dcacb = 3
	}
	return nil
}
func NewCT_Camera() *CT_Camera {
	_dccg := &CT_Camera{}
	_dccg.PrstAttr = ST_PresetCameraType(1)
	return _dccg
}
func (_aceced *ST_PresetMaterialType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gafgg, _fgcae := d.Token()
	if _fgcae != nil {
		return _fgcae
	}
	if _acbec, _eebfb := _gafgg.(_g.EndElement); _eebfb && _acbec.Name == start.Name {
		*_aceced = 1
		return nil
	}
	if _cbgdgbb, _dedfb := _gafgg.(_g.CharData); !_dedfb {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gafgg)
	} else {
		switch string(_cbgdgbb) {
		case "":
			*_aceced = 0
		case "legacyMatte":
			*_aceced = 1
		case "legacyPlastic":
			*_aceced = 2
		case "legacyMetal":
			*_aceced = 3
		case "legacyWireframe":
			*_aceced = 4
		case "matte":
			*_aceced = 5
		case "plastic":
			*_aceced = 6
		case "metal":
			*_aceced = 7
		case "warmMatte":
			*_aceced = 8
		case "translucentPowder":
			*_aceced = 9
		case "powder":
			*_aceced = 10
		case "dkEdge":
			*_aceced = 11
		case "softEdge":
			*_aceced = 12
		case "clear":
			*_aceced = 13
		case "flat":
			*_aceced = 14
		case "softmetal":
			*_aceced = 15
		}
	}
	_gafgg, _fgcae = d.Token()
	if _fgcae != nil {
		return _fgcae
	}
	if _efaec, _dfcbe := _gafgg.(_g.EndElement); _dfcbe && _efaec.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gafgg)
}

// Validate validates the CT_StyleMatrixReference and its children
func (_cbdaf *CT_StyleMatrixReference) Validate() error {
	return _cbdaf.ValidateWithPath("CT_StyleMatrixReference")
}
func (_ecacb ST_FontCollectionIndex) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ecacb.String(), start)
}

type CT_EffectReference struct{ RefAttr string }

func (_deadb ST_PresetShadowVal) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_badff := _g.Attr{}
	_badff.Name = name
	switch _deadb {
	case ST_PresetShadowValUnset:
		_badff.Value = ""
	case ST_PresetShadowValShdw1:
		_badff.Value = "shdw1"
	case ST_PresetShadowValShdw2:
		_badff.Value = "shdw2"
	case ST_PresetShadowValShdw3:
		_badff.Value = "shdw3"
	case ST_PresetShadowValShdw4:
		_badff.Value = "shdw4"
	case ST_PresetShadowValShdw5:
		_badff.Value = "shdw5"
	case ST_PresetShadowValShdw6:
		_badff.Value = "shdw6"
	case ST_PresetShadowValShdw7:
		_badff.Value = "shdw7"
	case ST_PresetShadowValShdw8:
		_badff.Value = "shdw8"
	case ST_PresetShadowValShdw9:
		_badff.Value = "shdw9"
	case ST_PresetShadowValShdw10:
		_badff.Value = "shdw10"
	case ST_PresetShadowValShdw11:
		_badff.Value = "shdw11"
	case ST_PresetShadowValShdw12:
		_badff.Value = "shdw12"
	case ST_PresetShadowValShdw13:
		_badff.Value = "shdw13"
	case ST_PresetShadowValShdw14:
		_badff.Value = "shdw14"
	case ST_PresetShadowValShdw15:
		_badff.Value = "shdw15"
	case ST_PresetShadowValShdw16:
		_badff.Value = "shdw16"
	case ST_PresetShadowValShdw17:
		_badff.Value = "shdw17"
	case ST_PresetShadowValShdw18:
		_badff.Value = "shdw18"
	case ST_PresetShadowValShdw19:
		_badff.Value = "shdw19"
	case ST_PresetShadowValShdw20:
		_badff.Value = "shdw20"
	}
	return _badff, nil
}
func (_aedbc *ST_PitchFamily) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gddgfg, _afad := d.Token()
	if _afad != nil {
		return _afad
	}
	if _bbdaa, _geefa := _gddgfg.(_g.EndElement); _geefa && _bbdaa.Name == start.Name {
		*_aedbc = 1
		return nil
	}
	if _fegfg, _feeea := _gddgfg.(_g.CharData); !_feeea {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gddgfg)
	} else {
		switch string(_fegfg) {
		case "":
			*_aedbc = 0
		case "00":
			*_aedbc = 1
		case "01":
			*_aedbc = 2
		case "02":
			*_aedbc = 3
		case "16":
			*_aedbc = 4
		case "17":
			*_aedbc = 5
		case "18":
			*_aedbc = 6
		case "32":
			*_aedbc = 7
		case "33":
			*_aedbc = 8
		case "34":
			*_aedbc = 9
		case "48":
			*_aedbc = 10
		case "49":
			*_aedbc = 11
		case "50":
			*_aedbc = 12
		case "64":
			*_aedbc = 13
		case "65":
			*_aedbc = 14
		case "66":
			*_aedbc = 15
		case "80":
			*_aedbc = 16
		case "81":
			*_aedbc = 17
		case "82":
			*_aedbc = 18
		}
	}
	_gddgfg, _afad = d.Token()
	if _afad != nil {
		return _afad
	}
	if _dgceg, _cdadaf := _gddgfg.(_g.EndElement); _cdadaf && _dgceg.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gddgfg)
}

// ValidateWithPath validates the CT_AnimationDgmElement and its children, prefixing error messages with path
func (_cggg *CT_AnimationDgmElement) ValidateWithPath(path string) error {
	if _cggg.IdAttr != nil {
		if !_f.ST_GuidPatternRe.MatchString(*_cggg.IdAttr) {
			return _dcf.Errorf("\u0025s/m\u002eIdAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _f.ST_GuidPatternRe, *_cggg.IdAttr)
		}
	}
	if _dfc := _cggg.BldStepAttr.ValidateWithPath(path + "\u002fBldStepAttr"); _dfc != nil {
		return _dfc
	}
	return nil
}
func (_abcdf *ST_Coordinate) Validate() error { return _abcdf.ValidateWithPath("") }
func (_fgcgg ST_AdjCoordinate) String() string {
	if _fgcgg.ST_Coordinate != nil {
		return _fgcgg.ST_Coordinate.String()
	}
	if _fgcgg.ST_GeomGuideName != nil {
		return _dcf.Sprintf("\u0025v", *_fgcgg.ST_GeomGuideName)
	}
	return ""
}

// ValidateWithPath validates the CT_NonVisualConnectorProperties and its children, prefixing error messages with path
func (_edade *CT_NonVisualConnectorProperties) ValidateWithPath(path string) error {
	if _edade.CxnSpLocks != nil {
		if _gefbe := _edade.CxnSpLocks.ValidateWithPath(path + "/CxnSpLocks"); _gefbe != nil {
			return _gefbe
		}
	}
	if _edade.StCxn != nil {
		if _bdgc := _edade.StCxn.ValidateWithPath(path + "\u002fStCxn"); _bdgc != nil {
			return _bdgc
		}
	}
	if _edade.EndCxn != nil {
		if _dfbf := _edade.EndCxn.ValidateWithPath(path + "\u002fEndCxn"); _dfbf != nil {
			return _dfbf
		}
	}
	if _edade.ExtLst != nil {
		if _dbgbg := _edade.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dbgbg != nil {
			return _dbgbg
		}
	}
	return nil
}

type CT_ColorChangeEffect struct {
	UseAAttr *bool
	ClrFrom  *CT_Color
	ClrTo    *CT_Color
}

func (_eaef *CT_LineProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ebbdg := range start.Attr {
		if _ebbdg.Name.Local == "w" {
			_ccdgde, _afbd := _e.ParseInt(_ebbdg.Value, 10, 32)
			if _afbd != nil {
				return _afbd
			}
			_fbced := int32(_ccdgde)
			_eaef.WAttr = &_fbced
			continue
		}
		if _ebbdg.Name.Local == "cmpd" {
			_eaef.CmpdAttr.UnmarshalXMLAttr(_ebbdg)
			continue
		}
		if _ebbdg.Name.Local == "cap" {
			_eaef.CapAttr.UnmarshalXMLAttr(_ebbdg)
			continue
		}
		if _ebbdg.Name.Local == "algn" {
			_eaef.AlgnAttr.UnmarshalXMLAttr(_ebbdg)
			continue
		}
	}
_ddbab:
	for {
		_gcdgg, _dbcaf := d.Token()
		if _dbcaf != nil {
			return _dbcaf
		}
		switch _fefcae := _gcdgg.(type) {
		case _g.StartElement:
			switch _fefcae.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_eaef.NoFill = NewCT_NoFillProperties()
				if _cgea := d.DecodeElement(_eaef.NoFill, &_fefcae); _cgea != nil {
					return _cgea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_eaef.SolidFill = NewCT_SolidColorFillProperties()
				if _edfcfc := d.DecodeElement(_eaef.SolidFill, &_fefcae); _edfcfc != nil {
					return _edfcfc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_eaef.GradFill = NewCT_GradientFillProperties()
				if _agba := d.DecodeElement(_eaef.GradFill, &_fefcae); _agba != nil {
					return _agba
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_eaef.PattFill = NewCT_PatternFillProperties()
				if _bgdaf := d.DecodeElement(_eaef.PattFill, &_fefcae); _bgdaf != nil {
					return _bgdaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstDash"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstDash"}:
				_eaef.PrstDash = NewCT_PresetLineDashProperties()
				if _aabgb := d.DecodeElement(_eaef.PrstDash, &_fefcae); _aabgb != nil {
					return _aabgb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "custDash"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "custDash"}:
				_eaef.CustDash = NewCT_DashStopList()
				if _fgbfd := d.DecodeElement(_eaef.CustDash, &_fefcae); _fgbfd != nil {
					return _fgbfd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "round"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "round"}:
				_eaef.Round = NewCT_LineJoinRound()
				if _bfff := d.DecodeElement(_eaef.Round, &_fefcae); _bfff != nil {
					return _bfff
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bevel"}:
				_eaef.Bevel = NewCT_LineJoinBevel()
				if _cggfb := d.DecodeElement(_eaef.Bevel, &_fefcae); _cggfb != nil {
					return _cggfb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "miter"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "miter"}:
				_eaef.Miter = NewCT_LineJoinMiterProperties()
				if _fadcca := d.DecodeElement(_eaef.Miter, &_fefcae); _fadcca != nil {
					return _fadcca
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "headEnd"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "headEnd"}:
				_eaef.HeadEnd = NewCT_LineEndProperties()
				if _dceea := d.DecodeElement(_eaef.HeadEnd, &_fefcae); _dceea != nil {
					return _dceea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tailEnd"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tailEnd"}:
				_eaef.TailEnd = NewCT_LineEndProperties()
				if _eacg := d.DecodeElement(_eaef.TailEnd, &_fefcae); _eacg != nil {
					return _eacg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_eaef.ExtLst = NewCT_OfficeArtExtensionList()
				if _aacb := d.DecodeElement(_eaef.ExtLst, &_fefcae); _aacb != nil {
					return _aacb
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_LineProperties\u0020\u0025v", _fefcae.Name)
				if _acdf := d.Skip(); _acdf != nil {
					return _acdf
				}
			}
		case _g.EndElement:
			break _ddbab
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_AlphaModulateFixedEffect and its children, prefixing error messages with path
func (_cgfe *CT_AlphaModulateFixedEffect) ValidateWithPath(path string) error {
	if _cgfe.AmtAttr != nil {
		if _agcb := _cgfe.AmtAttr.ValidateWithPath(path + "\u002fAmtAttr"); _agcb != nil {
			return _agcb
		}
	}
	return nil
}

// ValidateWithPath validates the CT_AlphaReplaceEffect and its children, prefixing error messages with path
func (_dbca *CT_AlphaReplaceEffect) ValidateWithPath(path string) error {
	if _ccb := _dbca.AAttr.ValidateWithPath(path + "\u002fAAttr"); _ccb != nil {
		return _ccb
	}
	return nil
}

// ValidateWithPath validates the CT_GvmlPictureNonVisual and its children, prefixing error messages with path
func (_gedg *CT_GvmlPictureNonVisual) ValidateWithPath(path string) error {
	if _fecff := _gedg.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _fecff != nil {
		return _fecff
	}
	if _edcd := _gedg.CNvPicPr.ValidateWithPath(path + "\u002fCNvPicPr"); _edcd != nil {
		return _edcd
	}
	return nil
}

// Validate validates the CT_TextCharacterProperties and its children
func (_cada *CT_TextCharacterProperties) Validate() error {
	return _cada.ValidateWithPath("CT_TextCharacterProperties")
}
func (_aabff *CT_GvmlGroupShape) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_aabff.NvGrpSpPr = NewCT_GvmlGroupShapeNonVisual()
	_aabff.GrpSpPr = NewCT_GroupShapeProperties()
_bdca:
	for {
		_aacdg, _fabb := d.Token()
		if _fabb != nil {
			return _fabb
		}
		switch _gaba := _aacdg.(type) {
		case _g.StartElement:
			switch _gaba.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "nvGrpSpPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "nvGrpSpPr"}:
				if _dcdd := d.DecodeElement(_aabff.NvGrpSpPr, &_gaba); _dcdd != nil {
					return _dcdd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpSpPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpSpPr"}:
				if _aacg := d.DecodeElement(_aabff.GrpSpPr, &_gaba); _aacg != nil {
					return _aacg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "txSp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "txSp"}:
				_aabee := NewCT_GvmlGroupShapeChoice()
				if _eega := d.DecodeElement(&_aabee.TxSp, &_gaba); _eega != nil {
					return _eega
				}
				_aabff.Choice = append(_aabff.Choice, _aabee)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sp"}:
				_dcdc := NewCT_GvmlGroupShapeChoice()
				if _ccfb := d.DecodeElement(&_dcdc.Sp, &_gaba); _ccfb != nil {
					return _ccfb
				}
				_aabff.Choice = append(_aabff.Choice, _dcdc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cxnSp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cxnSp"}:
				_cgaeg := NewCT_GvmlGroupShapeChoice()
				if _ddeeg := d.DecodeElement(&_cgaeg.CxnSp, &_gaba); _ddeeg != nil {
					return _ddeeg
				}
				_aabff.Choice = append(_aabff.Choice, _cgaeg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pic"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pic"}:
				_fgab := NewCT_GvmlGroupShapeChoice()
				if _ggbde := d.DecodeElement(&_fgab.Pic, &_gaba); _ggbde != nil {
					return _ggbde
				}
				_aabff.Choice = append(_aabff.Choice, _fgab)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "graphicFrame"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "graphicFrame"}:
				_eedb := NewCT_GvmlGroupShapeChoice()
				if _gabbb := d.DecodeElement(&_eedb.GraphicFrame, &_gaba); _gabbb != nil {
					return _gabbb
				}
				_aabff.Choice = append(_aabff.Choice, _eedb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpSp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpSp"}:
				_gegg := NewCT_GvmlGroupShapeChoice()
				if _cafg := d.DecodeElement(&_gegg.GrpSp, &_gaba); _cafg != nil {
					return _cafg
				}
				_aabff.Choice = append(_aabff.Choice, _gegg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_aabff.ExtLst = NewCT_OfficeArtExtensionList()
				if _baecf := d.DecodeElement(_aabff.ExtLst, &_gaba); _baecf != nil {
					return _baecf
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_GvmlGroupShape\u0020\u0025v", _gaba.Name)
				if _ceeg := d.Skip(); _ceeg != nil {
					return _ceeg
				}
			}
		case _g.EndElement:
			break _bdca
		case _g.CharData:
		}
	}
	return nil
}

type CT_GradientFillProperties struct {
	FlipAttr         ST_TileFlipMode
	RotWithShapeAttr *bool
	GsLst            *CT_GradientStopList
	Lin              *CT_LinearShadeProperties
	Path             *CT_PathShadeProperties
	TileRect         *CT_RelativeRect
}
type CT_GvmlGraphicalObjectFrame struct {
	NvGraphicFramePr *CT_GvmlGraphicFrameNonVisual
	Graphic          *Graphic
	Xfrm             *CT_Transform2D
	ExtLst           *CT_OfficeArtExtensionList
}
type CT_Path2DClose struct{}

func (_dbagde *ST_ShapeType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_dbagde = 0
	case "line":
		*_dbagde = 1
	case "lineInv":
		*_dbagde = 2
	case "triangle":
		*_dbagde = 3
	case "rtTriangle":
		*_dbagde = 4
	case "rect":
		*_dbagde = 5
	case "diamond":
		*_dbagde = 6
	case "parallelogram":
		*_dbagde = 7
	case "trapezoid":
		*_dbagde = 8
	case "nonIsoscelesTrapezoid":
		*_dbagde = 9
	case "pentagon":
		*_dbagde = 10
	case "hexagon":
		*_dbagde = 11
	case "heptagon":
		*_dbagde = 12
	case "octagon":
		*_dbagde = 13
	case "decagon":
		*_dbagde = 14
	case "dodecagon":
		*_dbagde = 15
	case "star4":
		*_dbagde = 16
	case "star5":
		*_dbagde = 17
	case "star6":
		*_dbagde = 18
	case "star7":
		*_dbagde = 19
	case "star8":
		*_dbagde = 20
	case "star10":
		*_dbagde = 21
	case "star12":
		*_dbagde = 22
	case "star16":
		*_dbagde = 23
	case "star24":
		*_dbagde = 24
	case "star32":
		*_dbagde = 25
	case "roundRect":
		*_dbagde = 26
	case "round1Rect":
		*_dbagde = 27
	case "round2SameRect":
		*_dbagde = 28
	case "round2DiagRect":
		*_dbagde = 29
	case "snipRoundRect":
		*_dbagde = 30
	case "snip1Rect":
		*_dbagde = 31
	case "snip2SameRect":
		*_dbagde = 32
	case "snip2DiagRect":
		*_dbagde = 33
	case "plaque":
		*_dbagde = 34
	case "ellipse":
		*_dbagde = 35
	case "teardrop":
		*_dbagde = 36
	case "homePlate":
		*_dbagde = 37
	case "chevron":
		*_dbagde = 38
	case "pieWedge":
		*_dbagde = 39
	case "pie":
		*_dbagde = 40
	case "blockArc":
		*_dbagde = 41
	case "donut":
		*_dbagde = 42
	case "noSmoking":
		*_dbagde = 43
	case "rightArrow":
		*_dbagde = 44
	case "leftArrow":
		*_dbagde = 45
	case "upArrow":
		*_dbagde = 46
	case "downArrow":
		*_dbagde = 47
	case "stripedRightArrow":
		*_dbagde = 48
	case "notchedRightArrow":
		*_dbagde = 49
	case "bentUpArrow":
		*_dbagde = 50
	case "leftRightArrow":
		*_dbagde = 51
	case "upDownArrow":
		*_dbagde = 52
	case "leftUpArrow":
		*_dbagde = 53
	case "leftRightUpArrow":
		*_dbagde = 54
	case "quadArrow":
		*_dbagde = 55
	case "leftArrowCallout":
		*_dbagde = 56
	case "rightArrowCallout":
		*_dbagde = 57
	case "upArrowCallout":
		*_dbagde = 58
	case "downArrowCallout":
		*_dbagde = 59
	case "leftRightArrowCallout":
		*_dbagde = 60
	case "upDownArrowCallout":
		*_dbagde = 61
	case "quadArrowCallout":
		*_dbagde = 62
	case "bentArrow":
		*_dbagde = 63
	case "uturnArrow":
		*_dbagde = 64
	case "circularArrow":
		*_dbagde = 65
	case "leftCircularArrow":
		*_dbagde = 66
	case "leftRightCircularArrow":
		*_dbagde = 67
	case "curvedRightArrow":
		*_dbagde = 68
	case "curvedLeftArrow":
		*_dbagde = 69
	case "curvedUpArrow":
		*_dbagde = 70
	case "curvedDownArrow":
		*_dbagde = 71
	case "swooshArrow":
		*_dbagde = 72
	case "cube":
		*_dbagde = 73
	case "can":
		*_dbagde = 74
	case "lightningBolt":
		*_dbagde = 75
	case "heart":
		*_dbagde = 76
	case "sun":
		*_dbagde = 77
	case "moon":
		*_dbagde = 78
	case "smileyFace":
		*_dbagde = 79
	case "irregularSeal1":
		*_dbagde = 80
	case "irregularSeal2":
		*_dbagde = 81
	case "foldedCorner":
		*_dbagde = 82
	case "bevel":
		*_dbagde = 83
	case "frame":
		*_dbagde = 84
	case "halfFrame":
		*_dbagde = 85
	case "corner":
		*_dbagde = 86
	case "diagStripe":
		*_dbagde = 87
	case "chord":
		*_dbagde = 88
	case "arc":
		*_dbagde = 89
	case "leftBracket":
		*_dbagde = 90
	case "rightBracket":
		*_dbagde = 91
	case "leftBrace":
		*_dbagde = 92
	case "rightBrace":
		*_dbagde = 93
	case "bracketPair":
		*_dbagde = 94
	case "bracePair":
		*_dbagde = 95
	case "straightConnector1":
		*_dbagde = 96
	case "bentConnector2":
		*_dbagde = 97
	case "bentConnector3":
		*_dbagde = 98
	case "bentConnector4":
		*_dbagde = 99
	case "bentConnector5":
		*_dbagde = 100
	case "curvedConnector2":
		*_dbagde = 101
	case "curvedConnector3":
		*_dbagde = 102
	case "curvedConnector4":
		*_dbagde = 103
	case "curvedConnector5":
		*_dbagde = 104
	case "callout1":
		*_dbagde = 105
	case "callout2":
		*_dbagde = 106
	case "callout3":
		*_dbagde = 107
	case "accentCallout1":
		*_dbagde = 108
	case "accentCallout2":
		*_dbagde = 109
	case "accentCallout3":
		*_dbagde = 110
	case "borderCallout1":
		*_dbagde = 111
	case "borderCallout2":
		*_dbagde = 112
	case "borderCallout3":
		*_dbagde = 113
	case "accentBorderCallout1":
		*_dbagde = 114
	case "accentBorderCallout2":
		*_dbagde = 115
	case "accentBorderCallout3":
		*_dbagde = 116
	case "wedgeRectCallout":
		*_dbagde = 117
	case "wedgeRoundRectCallout":
		*_dbagde = 118
	case "wedgeEllipseCallout":
		*_dbagde = 119
	case "cloudCallout":
		*_dbagde = 120
	case "cloud":
		*_dbagde = 121
	case "ribbon":
		*_dbagde = 122
	case "ribbon2":
		*_dbagde = 123
	case "ellipseRibbon":
		*_dbagde = 124
	case "ellipseRibbon2":
		*_dbagde = 125
	case "leftRightRibbon":
		*_dbagde = 126
	case "verticalScroll":
		*_dbagde = 127
	case "horizontalScroll":
		*_dbagde = 128
	case "wave":
		*_dbagde = 129
	case "doubleWave":
		*_dbagde = 130
	case "plus":
		*_dbagde = 131
	case "flowChartProcess":
		*_dbagde = 132
	case "flowChartDecision":
		*_dbagde = 133
	case "flowChartInputOutput":
		*_dbagde = 134
	case "flowChartPredefinedProcess":
		*_dbagde = 135
	case "flowChartInternalStorage":
		*_dbagde = 136
	case "flowChartDocument":
		*_dbagde = 137
	case "flowChartMultidocument":
		*_dbagde = 138
	case "flowChartTerminator":
		*_dbagde = 139
	case "flowChartPreparation":
		*_dbagde = 140
	case "flowChartManualInput":
		*_dbagde = 141
	case "flowChartManualOperation":
		*_dbagde = 142
	case "flowChartConnector":
		*_dbagde = 143
	case "flowChartPunchedCard":
		*_dbagde = 144
	case "flowChartPunchedTape":
		*_dbagde = 145
	case "flowChartSummingJunction":
		*_dbagde = 146
	case "flowChartOr":
		*_dbagde = 147
	case "flowChartCollate":
		*_dbagde = 148
	case "flowChartSort":
		*_dbagde = 149
	case "flowChartExtract":
		*_dbagde = 150
	case "flowChartMerge":
		*_dbagde = 151
	case "flowChartOfflineStorage":
		*_dbagde = 152
	case "flowChartOnlineStorage":
		*_dbagde = 153
	case "flowChartMagneticTape":
		*_dbagde = 154
	case "flowChartMagneticDisk":
		*_dbagde = 155
	case "flowChartMagneticDrum":
		*_dbagde = 156
	case "flowChartDisplay":
		*_dbagde = 157
	case "flowChartDelay":
		*_dbagde = 158
	case "flowChartAlternateProcess":
		*_dbagde = 159
	case "flowChartOffpageConnector":
		*_dbagde = 160
	case "actionButtonBlank":
		*_dbagde = 161
	case "actionButtonHome":
		*_dbagde = 162
	case "actionButtonHelp":
		*_dbagde = 163
	case "actionButtonInformation":
		*_dbagde = 164
	case "actionButtonForwardNext":
		*_dbagde = 165
	case "actionButtonBackPrevious":
		*_dbagde = 166
	case "actionButtonEnd":
		*_dbagde = 167
	case "actionButtonBeginning":
		*_dbagde = 168
	case "actionButtonReturn":
		*_dbagde = 169
	case "actionButtonDocument":
		*_dbagde = 170
	case "actionButtonSound":
		*_dbagde = 171
	case "actionButtonMovie":
		*_dbagde = 172
	case "gear6":
		*_dbagde = 173
	case "gear9":
		*_dbagde = 174
	case "funnel":
		*_dbagde = 175
	case "mathPlus":
		*_dbagde = 176
	case "mathMinus":
		*_dbagde = 177
	case "mathMultiply":
		*_dbagde = 178
	case "mathDivide":
		*_dbagde = 179
	case "mathEqual":
		*_dbagde = 180
	case "mathNotEqual":
		*_dbagde = 181
	case "cornerTabs":
		*_dbagde = 182
	case "squareTabs":
		*_dbagde = 183
	case "plaqueTabs":
		*_dbagde = 184
	case "chartX":
		*_dbagde = 185
	case "chartStar":
		*_dbagde = 186
	case "chartPlus":
		*_dbagde = 187
	}
	return nil
}
func (_dbacc *CT_ConnectionSiteList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_decfc:
	for {
		_ffga, _edcgg := d.Token()
		if _edcgg != nil {
			return _edcgg
		}
		switch _ggff := _ffga.(type) {
		case _g.StartElement:
			switch _ggff.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cxn"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cxn"}:
				_ffef := NewCT_ConnectionSite()
				if _bgce := d.DecodeElement(_ffef, &_ggff); _bgce != nil {
					return _bgce
				}
				_dbacc.Cxn = append(_dbacc.Cxn, _ffef)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_ConnectionSiteList\u0020\u0025v", _ggff.Name)
				if _faeeg := d.Skip(); _faeeg != nil {
					return _faeeg
				}
			}
		case _g.EndElement:
			break _decfc
		case _g.CharData:
		}
	}
	return nil
}

const (
	ST_CompoundLineUnset     ST_CompoundLine = 0
	ST_CompoundLineSng       ST_CompoundLine = 1
	ST_CompoundLineDbl       ST_CompoundLine = 2
	ST_CompoundLineThickThin ST_CompoundLine = 3
	ST_CompoundLineThinThick ST_CompoundLine = 4
	ST_CompoundLineTri       ST_CompoundLine = 5
)

// Validate validates the CT_TintEffect and its children
func (_fdecc *CT_TintEffect) Validate() error { return _fdecc.ValidateWithPath("CT_TintEffect") }
func (_debcb *CT_TableBackgroundStyle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fbaea:
	for {
		_gbggb, _cfedc := d.Token()
		if _cfedc != nil {
			return _cfedc
		}
		switch _eceegf := _gbggb.(type) {
		case _g.StartElement:
			switch _eceegf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fill"}:
				_debcb.Fill = NewCT_FillProperties()
				if _edgec := d.DecodeElement(_debcb.Fill, &_eceegf); _edgec != nil {
					return _edgec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillRef"}:
				_debcb.FillRef = NewCT_StyleMatrixReference()
				if _eggaf := d.DecodeElement(_debcb.FillRef, &_eceegf); _eggaf != nil {
					return _eggaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effect"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effect"}:
				_debcb.Effect = NewCT_EffectProperties()
				if _cfdea := d.DecodeElement(_debcb.Effect, &_eceegf); _cfdea != nil {
					return _cfdea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectRef"}:
				_debcb.EffectRef = NewCT_StyleMatrixReference()
				if _bgcfd := d.DecodeElement(_debcb.EffectRef, &_eceegf); _bgcfd != nil {
					return _bgcfd
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_TableBackgroundStyle \u0025v", _eceegf.Name)
				if _egaeb := d.Skip(); _egaeb != nil {
					return _egaeb
				}
			}
		case _g.EndElement:
			break _fbaea
		case _g.CharData:
		}
	}
	return nil
}
func (_bfgaf ST_LightRigType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_gdcfd := _g.Attr{}
	_gdcfd.Name = name
	switch _bfgaf {
	case ST_LightRigTypeUnset:
		_gdcfd.Value = ""
	case ST_LightRigTypeLegacyFlat1:
		_gdcfd.Value = "legacyFlat1"
	case ST_LightRigTypeLegacyFlat2:
		_gdcfd.Value = "legacyFlat2"
	case ST_LightRigTypeLegacyFlat3:
		_gdcfd.Value = "legacyFlat3"
	case ST_LightRigTypeLegacyFlat4:
		_gdcfd.Value = "legacyFlat4"
	case ST_LightRigTypeLegacyNormal1:
		_gdcfd.Value = "legacyNormal1"
	case ST_LightRigTypeLegacyNormal2:
		_gdcfd.Value = "legacyNormal2"
	case ST_LightRigTypeLegacyNormal3:
		_gdcfd.Value = "legacyNormal3"
	case ST_LightRigTypeLegacyNormal4:
		_gdcfd.Value = "legacyNormal4"
	case ST_LightRigTypeLegacyHarsh1:
		_gdcfd.Value = "legacyHarsh1"
	case ST_LightRigTypeLegacyHarsh2:
		_gdcfd.Value = "legacyHarsh2"
	case ST_LightRigTypeLegacyHarsh3:
		_gdcfd.Value = "legacyHarsh3"
	case ST_LightRigTypeLegacyHarsh4:
		_gdcfd.Value = "legacyHarsh4"
	case ST_LightRigTypeThreePt:
		_gdcfd.Value = "threePt"
	case ST_LightRigTypeBalanced:
		_gdcfd.Value = "balanced"
	case ST_LightRigTypeSoft:
		_gdcfd.Value = "soft"
	case ST_LightRigTypeHarsh:
		_gdcfd.Value = "harsh"
	case ST_LightRigTypeFlood:
		_gdcfd.Value = "flood"
	case ST_LightRigTypeContrasting:
		_gdcfd.Value = "contrasting"
	case ST_LightRigTypeMorning:
		_gdcfd.Value = "morning"
	case ST_LightRigTypeSunrise:
		_gdcfd.Value = "sunrise"
	case ST_LightRigTypeSunset:
		_gdcfd.Value = "sunset"
	case ST_LightRigTypeChilly:
		_gdcfd.Value = "chilly"
	case ST_LightRigTypeFreezing:
		_gdcfd.Value = "freezing"
	case ST_LightRigTypeFlat:
		_gdcfd.Value = "flat"
	case ST_LightRigTypeTwoPt:
		_gdcfd.Value = "twoPt"
	case ST_LightRigTypeGlow:
		_gdcfd.Value = "glow"
	case ST_LightRigTypeBrightRoom:
		_gdcfd.Value = "brightRoom"
	}
	return _gdcfd, nil
}

// ValidateWithPath validates the CT_ColorSchemeAndMapping and its children, prefixing error messages with path
func (_gdbfc *CT_ColorSchemeAndMapping) ValidateWithPath(path string) error {
	if _bccc := _gdbfc.ClrScheme.ValidateWithPath(path + "\u002fClrScheme"); _bccc != nil {
		return _bccc
	}
	if _gdbfc.ClrMap != nil {
		if _cdbc := _gdbfc.ClrMap.ValidateWithPath(path + "\u002fClrMap"); _cdbc != nil {
			return _cdbc
		}
	}
	return nil
}

type CT_GraphicalObjectData struct {
	UriAttr string
	Any     []_ee.Any
}
type ST_TextWrappingType byte

func (_dabde *ST_PositivePercentage) ValidateWithPath(path string) error {
	_edabf := []string{}
	if _dabde.ST_PositivePercentageDecimal != nil {
		_edabf = append(_edabf, "ST_PositivePercentageDecimal")
	}
	if _dabde.ST_PositivePercentage != nil {
		if _cdfbda := _dabde.ST_PositivePercentage.ValidateWithPath(path + "\u002fST_PositivePercentage"); _cdfbda != nil {
			return _cdfbda
		}
		_edabf = append(_edabf, "ST_PositivePercentage")
	}
	if len(_edabf) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _edabf)
	}
	return nil
}
func (_cgdad ST_AnimationChartOnlyBuildType) Validate() error { return _cgdad.ValidateWithPath("") }
func (_ecfagd *ST_AdjCoordinate) Validate() error             { return _ecfagd.ValidateWithPath("") }
func (_cgfa *CT_PresetGeometry2D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_fbeeg, _cggef := _cgfa.PrstAttr.MarshalXMLAttr(_g.Name{Local: "prst"})
	if _cggef != nil {
		return _cggef
	}
	start.Attr = append(start.Attr, _fbeeg)
	e.EncodeToken(start)
	if _cgfa.AvLst != nil {
		_fdgae := _g.StartElement{Name: _g.Name{Local: "a:avLst"}}
		e.EncodeElement(_cgfa.AvLst, _fdgae)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_InverseGammaTransform() *CT_InverseGammaTransform {
	_adcbg := &CT_InverseGammaTransform{}
	return _adcbg
}

type CT_Shape3D struct {
	ZAttr            *ST_Coordinate
	ExtrusionHAttr   *int64
	ContourWAttr     *int64
	PrstMaterialAttr ST_PresetMaterialType
	BevelT           *CT_Bevel
	BevelB           *CT_Bevel
	ExtrusionClr     *CT_Color
	ContourClr       *CT_Color
	ExtLst           *CT_OfficeArtExtensionList
}

func (_eggae *ST_PitchFamily) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_eggae = 0
	case "00":
		*_eggae = 1
	case "01":
		*_eggae = 2
	case "02":
		*_eggae = 3
	case "16":
		*_eggae = 4
	case "17":
		*_eggae = 5
	case "18":
		*_eggae = 6
	case "32":
		*_eggae = 7
	case "33":
		*_eggae = 8
	case "34":
		*_eggae = 9
	case "48":
		*_eggae = 10
	case "49":
		*_eggae = 11
	case "50":
		*_eggae = 12
	case "64":
		*_eggae = 13
	case "65":
		*_eggae = 14
	case "66":
		*_eggae = 15
	case "80":
		*_eggae = 16
	case "81":
		*_eggae = 17
	case "82":
		*_eggae = 18
	}
	return nil
}

// ValidateWithPath validates the CT_Scene3D and its children, prefixing error messages with path
func (_abgagg *CT_Scene3D) ValidateWithPath(path string) error {
	if _gcedd := _abgagg.Camera.ValidateWithPath(path + "\u002fCamera"); _gcedd != nil {
		return _gcedd
	}
	if _aegf := _abgagg.LightRig.ValidateWithPath(path + "\u002fLightRig"); _aegf != nil {
		return _aegf
	}
	if _abgagg.Backdrop != nil {
		if _gaede := _abgagg.Backdrop.ValidateWithPath(path + "\u002fBackdrop"); _gaede != nil {
			return _gaede
		}
	}
	if _abgagg.ExtLst != nil {
		if _edde := _abgagg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _edde != nil {
			return _edde
		}
	}
	return nil
}

// ST_Coordinate is a union type
type ST_Coordinate struct {
	ST_CoordinateUnqualified *int64
	ST_UniversalMeasure      *string
}

func (_gddbd ST_TileFlipMode) String() string {
	switch _gddbd {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "x"
	case 3:
		return "y"
	case 4:
		return "xy"
	}
	return ""
}

// Validate validates the AG_Blob and its children
func (_fda *AG_Blob) Validate() error { return _fda.ValidateWithPath("AG_Blob") }
func (_eecdf ST_AnimationChartBuildType) String() string {
	if _eecdf.ST_AnimationBuildType != ST_AnimationBuildTypeUnset {
		return _eecdf.ST_AnimationBuildType.String()
	}
	if _eecdf.ST_AnimationChartOnlyBuildType != ST_AnimationChartOnlyBuildTypeUnset {
		return _eecdf.ST_AnimationChartOnlyBuildType.String()
	}
	return ""
}
func (_cdabe ST_FontCollectionIndex) Validate() error { return _cdabe.ValidateWithPath("") }

// Validate validates the CT_AnimationGraphicalObjectBuildProperties and its children
func (_fagc *CT_AnimationGraphicalObjectBuildProperties) Validate() error {
	return _fagc.ValidateWithPath("CT_AnimationGraphicalObjectBuildProperties")
}

// Validate validates the CT_Connection and its children
func (_aacc *CT_Connection) Validate() error { return _aacc.ValidateWithPath("CT_Connection") }
func (_dfcdc *CT_GrayscaleEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_aceea, _ffeb := d.Token()
		if _ffeb != nil {
			return _dcf.Errorf("parsing\u0020CT_GrayscaleEffect:\u0020\u0025s", _ffeb)
		}
		if _eaagd, _faage := _aceea.(_g.EndElement); _faage && _eaagd.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_TableStyleCellStyle and its children
func (_bbacb *CT_TableStyleCellStyle) Validate() error {
	return _bbacb.ValidateWithPath("CT_TableStyleCellStyle")
}
func (_ggbdcc ST_PresetMaterialType) Validate() error { return _ggbdcc.ValidateWithPath("") }
func (_cabab *CT_QuickTimeFile) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r:link"}, Value: _dcf.Sprintf("\u0025v", _cabab.LinkAttr)})
	e.EncodeToken(start)
	if _cabab.ExtLst != nil {
		_gabbd := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_cabab.ExtLst, _gabbd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ddaf *CT_Boolean) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bbab := range start.Attr {
		if _bbab.Name.Local == "val" {
			_fdef, _efce := ParseUnionST_OnOff(_bbab.Value)
			if _efce != nil {
				return _efce
			}
			_ddaf.ValAttr = &_fdef
			continue
		}
	}
	for {
		_gbbg, _dbae := d.Token()
		if _dbae != nil {
			return _dcf.Errorf("parsing\u0020CT_Boolean:\u0020%s", _dbae)
		}
		if _adfa, _abe := _gbbg.(_g.EndElement); _abe && _adfa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fdeee *CT_RelativeOffsetEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fdeee.TxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "tx"}, Value: _dcf.Sprintf("\u0025v", *_fdeee.TxAttr)})
	}
	if _fdeee.TyAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "ty"}, Value: _dcf.Sprintf("\u0025v", *_fdeee.TyAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_dg *Blip) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "a:blip"
	return _dg.CT_Blip.MarshalXML(e, start)
}

type CT_TextBulletSizeFollowText struct{}

func (_fffbc ST_TextFontAlignType) Validate() error { return _fffbc.ValidateWithPath("") }

// Validate validates the EG_EffectProperties and its children
func (_dgafc *EG_EffectProperties) Validate() error {
	return _dgafc.ValidateWithPath("EG_EffectProperties")
}

// ValidateWithPath validates the CT_GvmlGroupShapeChoice and its children, prefixing error messages with path
func (_bbdd *CT_GvmlGroupShapeChoice) ValidateWithPath(path string) error {
	for _aabcb, _eaga := range _bbdd.TxSp {
		if _bcdgd := _eaga.ValidateWithPath(_dcf.Sprintf("%s\u002fTxSp\u005b\u0025d\u005d", path, _aabcb)); _bcdgd != nil {
			return _bcdgd
		}
	}
	for _fcgb, _gcdad := range _bbdd.Sp {
		if _fbgeb := _gcdad.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fSp\u005b\u0025d]", path, _fcgb)); _fbgeb != nil {
			return _fbgeb
		}
	}
	for _bbged, _bface := range _bbdd.CxnSp {
		if _acbcg := _bface.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fCxnSp\u005b\u0025d\u005d", path, _bbged)); _acbcg != nil {
			return _acbcg
		}
	}
	for _dfacb, _abgfg := range _bbdd.Pic {
		if _cfaea := _abgfg.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fPic\u005b\u0025d\u005d", path, _dfacb)); _cfaea != nil {
			return _cfaea
		}
	}
	for _ffabd, _gbabe := range _bbdd.GraphicFrame {
		if _acdbf := _gbabe.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fGraphicFrame\u005b\u0025d\u005d", path, _ffabd)); _acdbf != nil {
			return _acdbf
		}
	}
	for _geeee, _dcdea := range _bbdd.GrpSp {
		if _accb := _dcdea.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fGrpSp\u005b\u0025d\u005d", path, _geeee)); _accb != nil {
			return _accb
		}
	}
	return nil
}

type CT_NonVisualGroupDrawingShapeProps struct {
	GrpSpLocks *CT_GroupLocking
	ExtLst     *CT_OfficeArtExtensionList
}

func (_cfcfg ST_TextAutonumberScheme) String() string {
	switch _cfcfg {
	case 0:
		return ""
	case 1:
		return "alphaLcParenBoth"
	case 2:
		return "alphaUcParenBoth"
	case 3:
		return "alphaLcParenR"
	case 4:
		return "alphaUcParenR"
	case 5:
		return "alphaLcPeriod"
	case 6:
		return "alphaUcPeriod"
	case 7:
		return "arabicParenBoth"
	case 8:
		return "arabicParenR"
	case 9:
		return "arabicPeriod"
	case 10:
		return "arabicPlain"
	case 11:
		return "romanLcParenBoth"
	case 12:
		return "romanUcParenBoth"
	case 13:
		return "romanLcParenR"
	case 14:
		return "romanUcParenR"
	case 15:
		return "romanLcPeriod"
	case 16:
		return "romanUcPeriod"
	case 17:
		return "circleNumDbPlain"
	case 18:
		return "circleNumWdBlackPlain"
	case 19:
		return "circleNumWdWhitePlain"
	case 20:
		return "arabicDbPeriod"
	case 21:
		return "arabicDbPlain"
	case 22:
		return "ea1ChsPeriod"
	case 23:
		return "ea1ChsPlain"
	case 24:
		return "ea1ChtPeriod"
	case 25:
		return "ea1ChtPlain"
	case 26:
		return "ea1JpnChsDbPeriod"
	case 27:
		return "ea1JpnKorPlain"
	case 28:
		return "ea1JpnKorPeriod"
	case 29:
		return "arabic1Minus"
	case 30:
		return "arabic2Minus"
	case 31:
		return "hebrew2Minus"
	case 32:
		return "thaiAlphaPeriod"
	case 33:
		return "thaiAlphaParenR"
	case 34:
		return "thaiAlphaParenBoth"
	case 35:
		return "thaiNumPeriod"
	case 36:
		return "thaiNumParenR"
	case 37:
		return "thaiNumParenBoth"
	case 38:
		return "hindiAlphaPeriod"
	case 39:
		return "hindiNumPeriod"
	case 40:
		return "hindiNumParenR"
	case 41:
		return "hindiAlpha1Period"
	}
	return ""
}

// ValidateWithPath validates the CT_GvmlTextShapeChoice and its children, prefixing error messages with path
func (_bdfee *CT_GvmlTextShapeChoice) ValidateWithPath(path string) error {
	if _bdfee.UseSpRect != nil {
		if _fefca := _bdfee.UseSpRect.ValidateWithPath(path + "\u002fUseSpRect"); _fefca != nil {
			return _fefca
		}
	}
	if _bdfee.Xfrm != nil {
		if _adfg := _bdfee.Xfrm.ValidateWithPath(path + "\u002fXfrm"); _adfg != nil {
			return _adfg
		}
	}
	return nil
}
func (_bfffgc ST_DgmBuildStep) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_fggae := _g.Attr{}
	_fggae.Name = name
	switch _bfffgc {
	case ST_DgmBuildStepUnset:
		_fggae.Value = ""
	case ST_DgmBuildStepSp:
		_fggae.Value = "sp"
	case ST_DgmBuildStepBg:
		_fggae.Value = "bg"
	}
	return _fggae, nil
}
func (_cfge *CT_Hyperlink) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _aaebe := range start.Attr {
		if _aaebe.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _aaebe.Name.Local == "id" || _aaebe.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _aaebe.Name.Local == "id" {
			_fgccb, _fdgfa := _aaebe.Value, error(nil)
			if _fdgfa != nil {
				return _fdgfa
			}
			_cfge.IdAttr = &_fgccb
			continue
		}
		if _aaebe.Name.Local == "invalidUrl" {
			_edcea, _egbc := _aaebe.Value, error(nil)
			if _egbc != nil {
				return _egbc
			}
			_cfge.InvalidUrlAttr = &_edcea
			continue
		}
		if _aaebe.Name.Local == "action" {
			_egfdf, _adddb := _aaebe.Value, error(nil)
			if _adddb != nil {
				return _adddb
			}
			_cfge.ActionAttr = &_egfdf
			continue
		}
		if _aaebe.Name.Local == "tgtFrame" {
			_baefb, _dccc := _aaebe.Value, error(nil)
			if _dccc != nil {
				return _dccc
			}
			_cfge.TgtFrameAttr = &_baefb
			continue
		}
		if _aaebe.Name.Local == "tooltip" {
			_cefed, _edbc := _aaebe.Value, error(nil)
			if _edbc != nil {
				return _edbc
			}
			_cfge.TooltipAttr = &_cefed
			continue
		}
		if _aaebe.Name.Local == "history" {
			_eeff, _afgfde := _e.ParseBool(_aaebe.Value)
			if _afgfde != nil {
				return _afgfde
			}
			_cfge.HistoryAttr = &_eeff
			continue
		}
		if _aaebe.Name.Local == "highlightClick" {
			_fcgc, _dbeba := _e.ParseBool(_aaebe.Value)
			if _dbeba != nil {
				return _dbeba
			}
			_cfge.HighlightClickAttr = &_fcgc
			continue
		}
		if _aaebe.Name.Local == "endSnd" {
			_adba, _fbefc := _e.ParseBool(_aaebe.Value)
			if _fbefc != nil {
				return _fbefc
			}
			_cfge.EndSndAttr = &_adba
			continue
		}
	}
_bdafa:
	for {
		_ccgad, _cccfc := d.Token()
		if _cccfc != nil {
			return _cccfc
		}
		switch _fgaf := _ccgad.(type) {
		case _g.StartElement:
			switch _fgaf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "snd"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "snd"}:
				_cfge.Snd = NewCT_EmbeddedWAVAudioFile()
				if _agbca := d.DecodeElement(_cfge.Snd, &_fgaf); _agbca != nil {
					return _agbca
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_cfge.ExtLst = NewCT_OfficeArtExtensionList()
				if _faad := d.DecodeElement(_cfge.ExtLst, &_fgaf); _faad != nil {
					return _faad
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Hyperlink\u0020\u0025v", _fgaf.Name)
				if _fbgfd := d.Skip(); _fbgfd != nil {
					return _fbgfd
				}
			}
		case _g.EndElement:
			break _bdafa
		case _g.CharData:
		}
	}
	return nil
}

const (
	ST_TextStrikeTypeUnset     ST_TextStrikeType = 0
	ST_TextStrikeTypeNoStrike  ST_TextStrikeType = 1
	ST_TextStrikeTypeSngStrike ST_TextStrikeType = 2
	ST_TextStrikeTypeDblStrike ST_TextStrikeType = 3
)

func (_edbef *CT_TextNoAutofit) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_cdfef *CT_TablePartStyle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _cdfef.TcTxStyle != nil {
		_fcdee := _g.StartElement{Name: _g.Name{Local: "a:tcTxStyle"}}
		e.EncodeElement(_cdfef.TcTxStyle, _fcdee)
	}
	if _cdfef.TcStyle != nil {
		_cefga := _g.StartElement{Name: _g.Name{Local: "a:tcStyle"}}
		e.EncodeElement(_cdfef.TcStyle, _cefga)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_faadfb ST_LineEndType) ValidateWithPath(path string) error {
	switch _faadfb {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_faadfb))
	}
	return nil
}
func (_abacfb *ST_PresetPatternVal) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ddbdb, _beggef := d.Token()
	if _beggef != nil {
		return _beggef
	}
	if _bbaef, _fbfcf := _ddbdb.(_g.EndElement); _fbfcf && _bbaef.Name == start.Name {
		*_abacfb = 1
		return nil
	}
	if _bfdgg, _cebfgg := _ddbdb.(_g.CharData); !_cebfgg {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ddbdb)
	} else {
		switch string(_bfdgg) {
		case "":
			*_abacfb = 0
		case "pct5":
			*_abacfb = 1
		case "pct10":
			*_abacfb = 2
		case "pct20":
			*_abacfb = 3
		case "pct25":
			*_abacfb = 4
		case "pct30":
			*_abacfb = 5
		case "pct40":
			*_abacfb = 6
		case "pct50":
			*_abacfb = 7
		case "pct60":
			*_abacfb = 8
		case "pct70":
			*_abacfb = 9
		case "pct75":
			*_abacfb = 10
		case "pct80":
			*_abacfb = 11
		case "pct90":
			*_abacfb = 12
		case "horz":
			*_abacfb = 13
		case "vert":
			*_abacfb = 14
		case "ltHorz":
			*_abacfb = 15
		case "ltVert":
			*_abacfb = 16
		case "dkHorz":
			*_abacfb = 17
		case "dkVert":
			*_abacfb = 18
		case "narHorz":
			*_abacfb = 19
		case "narVert":
			*_abacfb = 20
		case "dashHorz":
			*_abacfb = 21
		case "dashVert":
			*_abacfb = 22
		case "cross":
			*_abacfb = 23
		case "dnDiag":
			*_abacfb = 24
		case "upDiag":
			*_abacfb = 25
		case "ltDnDiag":
			*_abacfb = 26
		case "ltUpDiag":
			*_abacfb = 27
		case "dkDnDiag":
			*_abacfb = 28
		case "dkUpDiag":
			*_abacfb = 29
		case "wdDnDiag":
			*_abacfb = 30
		case "wdUpDiag":
			*_abacfb = 31
		case "dashDnDiag":
			*_abacfb = 32
		case "dashUpDiag":
			*_abacfb = 33
		case "diagCross":
			*_abacfb = 34
		case "smCheck":
			*_abacfb = 35
		case "lgCheck":
			*_abacfb = 36
		case "smGrid":
			*_abacfb = 37
		case "lgGrid":
			*_abacfb = 38
		case "dotGrid":
			*_abacfb = 39
		case "smConfetti":
			*_abacfb = 40
		case "lgConfetti":
			*_abacfb = 41
		case "horzBrick":
			*_abacfb = 42
		case "diagBrick":
			*_abacfb = 43
		case "solidDmnd":
			*_abacfb = 44
		case "openDmnd":
			*_abacfb = 45
		case "dotDmnd":
			*_abacfb = 46
		case "plaid":
			*_abacfb = 47
		case "sphere":
			*_abacfb = 48
		case "weave":
			*_abacfb = 49
		case "divot":
			*_abacfb = 50
		case "shingle":
			*_abacfb = 51
		case "wave":
			*_abacfb = 52
		case "trellis":
			*_abacfb = 53
		case "zigZag":
			*_abacfb = 54
		}
	}
	_ddbdb, _beggef = d.Token()
	if _beggef != nil {
		return _beggef
	}
	if _dcdaf, _aafbgg := _ddbdb.(_g.EndElement); _aafbgg && _dcdaf.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ddbdb)
}
func (_fdadf *EG_LineDashProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_ebbddd:
	for {
		_eagae, _aege := d.Token()
		if _aege != nil {
			return _aege
		}
		switch _baecd := _eagae.(type) {
		case _g.StartElement:
			switch _baecd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstDash"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstDash"}:
				_fdadf.PrstDash = NewCT_PresetLineDashProperties()
				if _bdfba := d.DecodeElement(_fdadf.PrstDash, &_baecd); _bdfba != nil {
					return _bdfba
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "custDash"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "custDash"}:
				_fdadf.CustDash = NewCT_DashStopList()
				if _fafgf := d.DecodeElement(_fdadf.CustDash, &_baecd); _fafgf != nil {
					return _fafgf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on EG_LineDashProperties\u0020\u0025v", _baecd.Name)
				if _afbee := d.Skip(); _afbee != nil {
					return _afbee
				}
			}
		case _g.EndElement:
			break _ebbddd
		case _g.CharData:
		}
	}
	return nil
}
func (_gacdgg *CT_PathShadeProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _deba := range start.Attr {
		if _deba.Name.Local == "path" {
			_gacdgg.PathAttr.UnmarshalXMLAttr(_deba)
			continue
		}
	}
_dggba:
	for {
		_decbd, _defac := d.Token()
		if _defac != nil {
			return _defac
		}
		switch _dgdfg := _decbd.(type) {
		case _g.StartElement:
			switch _dgdfg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillToRect"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillToRect"}:
				_gacdgg.FillToRect = NewCT_RelativeRect()
				if _dcega := d.DecodeElement(_gacdgg.FillToRect, &_dgdfg); _dcega != nil {
					return _dcega
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PathShadeProperties\u0020\u0025v", _dgdfg.Name)
				if _eeba := d.Skip(); _eeba != nil {
					return _eeba
				}
			}
		case _g.EndElement:
			break _dggba
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_NonVisualContentPartProperties and its children, prefixing error messages with path
func (_cgcb *CT_NonVisualContentPartProperties) ValidateWithPath(path string) error {
	if _cgcb.CpLocks != nil {
		if _cbead := _cgcb.CpLocks.ValidateWithPath(path + "\u002fCpLocks"); _cbead != nil {
			return _cbead
		}
	}
	if _cgcb.ExtLst != nil {
		if _dbbf := _cgcb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dbbf != nil {
			return _dbbf
		}
	}
	return nil
}
func NewCT_TextBulletTypefaceFollowText() *CT_TextBulletTypefaceFollowText {
	_bbdee := &CT_TextBulletTypefaceFollowText{}
	return _bbdee
}
func (_gfdcg *CT_NonVisualContentPartProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ccbgc := range start.Attr {
		if _ccbgc.Name.Local == "isComment" {
			_gcgge, _efeag := _e.ParseBool(_ccbgc.Value)
			if _efeag != nil {
				return _efeag
			}
			_gfdcg.IsCommentAttr = &_gcgge
			continue
		}
	}
_ccgge:
	for {
		_gffc, _gaafe := d.Token()
		if _gaafe != nil {
			return _gaafe
		}
		switch _eece := _gffc.(type) {
		case _g.StartElement:
			switch _eece.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cpLocks"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cpLocks"}:
				_gfdcg.CpLocks = NewCT_ContentPartLocking()
				if _fdad := d.DecodeElement(_gfdcg.CpLocks, &_eece); _fdad != nil {
					return _fdad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_gfdcg.ExtLst = NewCT_OfficeArtExtensionList()
				if _gaeb := d.DecodeElement(_gfdcg.ExtLst, &_eece); _gaeb != nil {
					return _gaeb
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_NonVisualContentPartProperties\u0020\u0025v", _eece.Name)
				if _cfgb := d.Skip(); _cfgb != nil {
					return _cfgb
				}
			}
		case _g.EndElement:
			break _ccgge
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TextShapeAutofit and its children, prefixing error messages with path
func (_agdfg *CT_TextShapeAutofit) ValidateWithPath(path string) error { return nil }
func (_bfgf *CT_FillStyleList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	for _, _aeffb := range _bfgf.EG_FillProperties {
		_aeffb.MarshalXML(e, _g.StartElement{})
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_TextTabStopList struct{ Tab []*CT_TextTabStop }

func (_dbagf *CT_GvmlGraphicalObjectFrame) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dbagf.NvGraphicFramePr = NewCT_GvmlGraphicFrameNonVisual()
	_dbagf.Graphic = NewGraphic()
	_dbagf.Xfrm = NewCT_Transform2D()
_ffbd:
	for {
		_gbdb, _efge := d.Token()
		if _efge != nil {
			return _efge
		}
		switch _bdfff := _gbdb.(type) {
		case _g.StartElement:
			switch _bdfff.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "nvGraphicFramePr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "nvGraphicFramePr"}:
				if _ecfb := d.DecodeElement(_dbagf.NvGraphicFramePr, &_bdfff); _ecfb != nil {
					return _ecfb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "graphic"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "graphic"}:
				if _cdfaa := d.DecodeElement(_dbagf.Graphic, &_bdfff); _cdfaa != nil {
					return _cdfaa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "xfrm"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "xfrm"}:
				if _abddc := d.DecodeElement(_dbagf.Xfrm, &_bdfff); _abddc != nil {
					return _abddc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_dbagf.ExtLst = NewCT_OfficeArtExtensionList()
				if _dbcgd := d.DecodeElement(_dbagf.ExtLst, &_bdfff); _dbcgd != nil {
					return _dbcgd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GvmlGraphicalObjectFrame\u0020\u0025v", _bdfff.Name)
				if _geadd := d.Skip(); _geadd != nil {
					return _geadd
				}
			}
		case _g.EndElement:
			break _ffbd
		case _g.CharData:
		}
	}
	return nil
}

type ST_PresetMaterialType byte

func (_aeagf *CT_GlowEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _gabg := range start.Attr {
		if _gabg.Name.Local == "rad" {
			_ecfcdc, _gbbd := _e.ParseInt(_gabg.Value, 10, 64)
			if _gbbd != nil {
				return _gbbd
			}
			_aeagf.RadAttr = &_ecfcdc
			continue
		}
	}
_acbc:
	for {
		_ecdc, _bbbfc := d.Token()
		if _bbbfc != nil {
			return _bbbfc
		}
		switch _ceed := _ecdc.(type) {
		case _g.StartElement:
			switch _ceed.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_aeagf.ScrgbClr = NewCT_ScRgbColor()
				if _fafg := d.DecodeElement(_aeagf.ScrgbClr, &_ceed); _fafg != nil {
					return _fafg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_aeagf.SrgbClr = NewCT_SRgbColor()
				if _eaab := d.DecodeElement(_aeagf.SrgbClr, &_ceed); _eaab != nil {
					return _eaab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_aeagf.HslClr = NewCT_HslColor()
				if _edfd := d.DecodeElement(_aeagf.HslClr, &_ceed); _edfd != nil {
					return _edfd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_aeagf.SysClr = NewCT_SystemColor()
				if _dafdba := d.DecodeElement(_aeagf.SysClr, &_ceed); _dafdba != nil {
					return _dafdba
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_aeagf.SchemeClr = NewCT_SchemeColor()
				if _eaagf := d.DecodeElement(_aeagf.SchemeClr, &_ceed); _eaagf != nil {
					return _eaagf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_aeagf.PrstClr = NewCT_PresetColor()
				if _gecg := d.DecodeElement(_aeagf.PrstClr, &_ceed); _gecg != nil {
					return _gecg
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_GlowEffect \u0025v", _ceed.Name)
				if _bfea := d.Skip(); _bfea != nil {
					return _bfea
				}
			}
		case _g.EndElement:
			break _acbc
		case _g.CharData:
		}
	}
	return nil
}
func (_dafafg *EG_Text3D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dafafg.Sp3d != nil {
		_afeeg := _g.StartElement{Name: _g.Name{Local: "a:sp3d"}}
		e.EncodeElement(_dafafg.Sp3d, _afeeg)
	}
	if _dafafg.FlatTx != nil {
		_bgcbd := _g.StartElement{Name: _g.Name{Local: "a:flatTx"}}
		e.EncodeElement(_dafafg.FlatTx, _bgcbd)
	}
	return nil
}

// Validate validates the EG_FillProperties and its children
func (_bdagg *EG_FillProperties) Validate() error {
	return _bdagg.ValidateWithPath("EG_FillProperties")
}
func NewCT_BackgroundFormatting() *CT_BackgroundFormatting {
	_gfeb := &CT_BackgroundFormatting{}
	return _gfeb
}

type CT_InnerShadowEffect struct {
	BlurRadAttr *int64
	DistAttr    *int64
	DirAttr     *int32
	ScrgbClr    *CT_ScRgbColor
	SrgbClr     *CT_SRgbColor
	HslClr      *CT_HslColor
	SysClr      *CT_SystemColor
	SchemeClr   *CT_SchemeColor
	PrstClr     *CT_PresetColor
}

// ValidateWithPath validates the CT_Path2DMoveTo and its children, prefixing error messages with path
func (_cddbg *CT_Path2DMoveTo) ValidateWithPath(path string) error {
	if _dbdcd := _cddbg.Pt.ValidateWithPath(path + "\u002fPt"); _dbdcd != nil {
		return _dbdcd
	}
	return nil
}
func (_ffeba *CT_GroupTransform2D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _ffeba.RotAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rot"}, Value: _dcf.Sprintf("\u0025v", *_ffeba.RotAttr)})
	}
	if _ffeba.FlipHAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "flipH"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ffeba.FlipHAttr))})
	}
	if _ffeba.FlipVAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "flipV"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_ffeba.FlipVAttr))})
	}
	e.EncodeToken(start)
	if _ffeba.Off != nil {
		_dccfb := _g.StartElement{Name: _g.Name{Local: "a:off"}}
		e.EncodeElement(_ffeba.Off, _dccfb)
	}
	if _ffeba.Ext != nil {
		_cbafe := _g.StartElement{Name: _g.Name{Local: "a:ext"}}
		e.EncodeElement(_ffeba.Ext, _cbafe)
	}
	if _ffeba.ChOff != nil {
		_cdab := _g.StartElement{Name: _g.Name{Local: "a:chOff"}}
		e.EncodeElement(_ffeba.ChOff, _cdab)
	}
	if _ffeba.ChExt != nil {
		_ggcg := _g.StartElement{Name: _g.Name{Local: "a:chExt"}}
		e.EncodeElement(_ffeba.ChExt, _ggcg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_GvmlGroupShapeChoice struct {
	TxSp         []*CT_GvmlTextShape
	Sp           []*CT_GvmlShape
	CxnSp        []*CT_GvmlConnector
	Pic          []*CT_GvmlPicture
	GraphicFrame []*CT_GvmlGraphicalObjectFrame
	GrpSp        []*CT_GvmlGroupShape
}
type CT_EffectList struct {
	Blur        *CT_BlurEffect
	FillOverlay *CT_FillOverlayEffect
	Glow        *CT_GlowEffect
	InnerShdw   *CT_InnerShadowEffect
	OuterShdw   *CT_OuterShadowEffect
	PrstShdw    *CT_PresetShadowEffect
	Reflection  *CT_ReflectionEffect
	SoftEdge    *CT_SoftEdgesEffect
}
type CT_FlatText struct{ ZAttr *ST_Coordinate }

const (
	ST_PathFillModeUnset       ST_PathFillMode = 0
	ST_PathFillModeNone        ST_PathFillMode = 1
	ST_PathFillModeNorm        ST_PathFillMode = 2
	ST_PathFillModeLighten     ST_PathFillMode = 3
	ST_PathFillModeLightenLess ST_PathFillMode = 4
	ST_PathFillModeDarken      ST_PathFillMode = 5
	ST_PathFillModeDarkenLess  ST_PathFillMode = 6
)

func (_ebbcf *CT_Table) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _ebbcf.TblPr != nil {
		_facec := _g.StartElement{Name: _g.Name{Local: "a:tblPr"}}
		e.EncodeElement(_ebbcf.TblPr, _facec)
	}
	_edga := _g.StartElement{Name: _g.Name{Local: "a:tblGrid"}}
	e.EncodeElement(_ebbcf.TblGrid, _edga)
	if _ebbcf.Tr != nil {
		_dfbdc := _g.StartElement{Name: _g.Name{Local: "a:tr"}}
		for _, _efddf := range _ebbcf.Tr {
			e.EncodeElement(_efddf, _dfbdc)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

const (
	ST_TextUnderlineTypeUnset           ST_TextUnderlineType = 0
	ST_TextUnderlineTypeNone            ST_TextUnderlineType = 1
	ST_TextUnderlineTypeWords           ST_TextUnderlineType = 2
	ST_TextUnderlineTypeSng             ST_TextUnderlineType = 3
	ST_TextUnderlineTypeDbl             ST_TextUnderlineType = 4
	ST_TextUnderlineTypeHeavy           ST_TextUnderlineType = 5
	ST_TextUnderlineTypeDotted          ST_TextUnderlineType = 6
	ST_TextUnderlineTypeDottedHeavy     ST_TextUnderlineType = 7
	ST_TextUnderlineTypeDash            ST_TextUnderlineType = 8
	ST_TextUnderlineTypeDashHeavy       ST_TextUnderlineType = 9
	ST_TextUnderlineTypeDashLong        ST_TextUnderlineType = 10
	ST_TextUnderlineTypeDashLongHeavy   ST_TextUnderlineType = 11
	ST_TextUnderlineTypeDotDash         ST_TextUnderlineType = 12
	ST_TextUnderlineTypeDotDashHeavy    ST_TextUnderlineType = 13
	ST_TextUnderlineTypeDotDotDash      ST_TextUnderlineType = 14
	ST_TextUnderlineTypeDotDotDashHeavy ST_TextUnderlineType = 15
	ST_TextUnderlineTypeWavy            ST_TextUnderlineType = 16
	ST_TextUnderlineTypeWavyHeavy       ST_TextUnderlineType = 17
	ST_TextUnderlineTypeWavyDbl         ST_TextUnderlineType = 18
)

type CT_SchemeColor struct {
	ValAttr           ST_SchemeColorVal
	EG_ColorTransform []*EG_ColorTransform
}

func (_gdfcb *ST_LineCap) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bcgfab, _ceabfb := d.Token()
	if _ceabfb != nil {
		return _ceabfb
	}
	if _dgbcf, _bfcdfg := _bcgfab.(_g.EndElement); _bfcdfg && _dgbcf.Name == start.Name {
		*_gdfcb = 1
		return nil
	}
	if _cgaag, _fbcgd := _bcgfab.(_g.CharData); !_fbcgd {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bcgfab)
	} else {
		switch string(_cgaag) {
		case "":
			*_gdfcb = 0
		case "rnd":
			*_gdfcb = 1
		case "sq":
			*_gdfcb = 2
		case "flat":
			*_gdfcb = 3
		}
	}
	_bcgfab, _ceabfb = d.Token()
	if _ceabfb != nil {
		return _ceabfb
	}
	if _dcaffd, _eedge := _bcgfab.(_g.EndElement); _eedge && _dcaffd.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bcgfab)
}
func (_cbbcag *CT_FillEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _cbbcag.NoFill != nil {
		_dgccf := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_cbbcag.NoFill, _dgccf)
	}
	if _cbbcag.SolidFill != nil {
		_agaf := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_cbbcag.SolidFill, _agaf)
	}
	if _cbbcag.GradFill != nil {
		_bgaf := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_cbbcag.GradFill, _bgaf)
	}
	if _cbbcag.BlipFill != nil {
		_gfagg := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
		e.EncodeElement(_cbbcag.BlipFill, _gfagg)
	}
	if _cbbcag.PattFill != nil {
		_ddfbf := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_cbbcag.PattFill, _ddfbf)
	}
	if _cbbcag.GrpFill != nil {
		_acfdd := _g.StartElement{Name: _g.Name{Local: "a:grpFill"}}
		e.EncodeElement(_cbbcag.GrpFill, _acfdd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_XYAdjustHandle and its children, prefixing error messages with path
func (_aaggee *CT_XYAdjustHandle) ValidateWithPath(path string) error {
	if _aaggee.MinXAttr != nil {
		if _cabcb := _aaggee.MinXAttr.ValidateWithPath(path + "\u002fMinXAttr"); _cabcb != nil {
			return _cabcb
		}
	}
	if _aaggee.MaxXAttr != nil {
		if _dddda := _aaggee.MaxXAttr.ValidateWithPath(path + "\u002fMaxXAttr"); _dddda != nil {
			return _dddda
		}
	}
	if _aaggee.MinYAttr != nil {
		if _aegcf := _aaggee.MinYAttr.ValidateWithPath(path + "\u002fMinYAttr"); _aegcf != nil {
			return _aegcf
		}
	}
	if _aaggee.MaxYAttr != nil {
		if _gcfag := _aaggee.MaxYAttr.ValidateWithPath(path + "\u002fMaxYAttr"); _gcfag != nil {
			return _gcfag
		}
	}
	if _edcdgb := _aaggee.Pos.ValidateWithPath(path + "\u002fPos"); _edcdgb != nil {
		return _edcdgb
	}
	return nil
}

// Validate validates the EG_LineJoinProperties and its children
func (_afecag *EG_LineJoinProperties) Validate() error {
	return _afecag.ValidateWithPath("EG_LineJoinProperties")
}
func NewCT_TextCharBullet() *CT_TextCharBullet { _afaaf := &CT_TextCharBullet{}; return _afaaf }

// Validate validates the CT_Ratio and its children
func (_cbefd *CT_Ratio) Validate() error { return _cbefd.ValidateWithPath("CT_Ratio") }
func (_cgfc *CT_AnimationChartBuildProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fbdf := range start.Attr {
		if _fbdf.Name.Local == "bld" {
			_aac, _ada := ParseUnionST_AnimationChartBuildType(_fbdf.Value)
			if _ada != nil {
				return _ada
			}
			_cgfc.BldAttr = &_aac
			continue
		}
		if _fbdf.Name.Local == "animBg" {
			_gdgg, _dgga := _e.ParseBool(_fbdf.Value)
			if _dgga != nil {
				return _dgga
			}
			_cgfc.AnimBgAttr = &_gdgg
			continue
		}
	}
	for {
		_gcba, _bddg := d.Token()
		if _bddg != nil {
			return _dcf.Errorf("parsing\u0020CT_AnimationChartBuildProperties: \u0025s", _bddg)
		}
		if _dage, _ecc := _gcba.(_g.EndElement); _ecc && _dage.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ceag *CT_ColorSchemeAndMapping) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ceag.ClrScheme = NewCT_ColorScheme()
_eaebg:
	for {
		_aacfe, _cbca := d.Token()
		if _cbca != nil {
			return _cbca
		}
		switch _beab := _aacfe.(type) {
		case _g.StartElement:
			switch _beab.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrScheme"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrScheme"}:
				if _ddgf := d.DecodeElement(_ceag.ClrScheme, &_beab); _ddgf != nil {
					return _ddgf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrMap"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrMap"}:
				_ceag.ClrMap = NewCT_ColorMapping()
				if _decce := d.DecodeElement(_ceag.ClrMap, &_beab); _decce != nil {
					return _decce
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_ColorSchemeAndMapping\u0020%v", _beab.Name)
				if _gcgb := d.Skip(); _gcgb != nil {
					return _gcgb
				}
			}
		case _g.EndElement:
			break _eaebg
		case _g.CharData:
		}
	}
	return nil
}
func (_cagab *ST_BlipCompression) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_cagab = 0
	case "email":
		*_cagab = 1
	case "screen":
		*_cagab = 2
	case "print":
		*_cagab = 3
	case "hqprint":
		*_cagab = 4
	case "none":
		*_cagab = 5
	}
	return nil
}
func (_gcgeb *CT_TextNoBullet) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_ddbgb, _bbfeaf := d.Token()
		if _bbfeaf != nil {
			return _dcf.Errorf("parsing CT_TextNoBullet:\u0020\u0025s", _bbfeaf)
		}
		if _afdbb, _agbdeb := _ddbgb.(_g.EndElement); _agbdeb && _afdbb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cbbfg *CT_GroupTransform2D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ggcgg := range start.Attr {
		if _ggcgg.Name.Local == "rot" {
			_abbd, _fecfe := _e.ParseInt(_ggcgg.Value, 10, 32)
			if _fecfe != nil {
				return _fecfe
			}
			_acged := int32(_abbd)
			_cbbfg.RotAttr = &_acged
			continue
		}
		if _ggcgg.Name.Local == "flipH" {
			_dfcg, _bagc := _e.ParseBool(_ggcgg.Value)
			if _bagc != nil {
				return _bagc
			}
			_cbbfg.FlipHAttr = &_dfcg
			continue
		}
		if _ggcgg.Name.Local == "flipV" {
			_bbcdf, _ffca := _e.ParseBool(_ggcgg.Value)
			if _ffca != nil {
				return _ffca
			}
			_cbbfg.FlipVAttr = &_bbcdf
			continue
		}
	}
_adgc:
	for {
		_fedaa, _fgaa := d.Token()
		if _fgaa != nil {
			return _fgaa
		}
		switch _bccga := _fedaa.(type) {
		case _g.StartElement:
			switch _bccga.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "off"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "off"}:
				_cbbfg.Off = NewCT_Point2D()
				if _ccdge := d.DecodeElement(_cbbfg.Off, &_bccga); _ccdge != nil {
					return _ccdge
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ext"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ext"}:
				_cbbfg.Ext = NewCT_PositiveSize2D()
				if _dccfa := d.DecodeElement(_cbbfg.Ext, &_bccga); _dccfa != nil {
					return _dccfa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "chOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "chOff"}:
				_cbbfg.ChOff = NewCT_Point2D()
				if _ebcg := d.DecodeElement(_cbbfg.ChOff, &_bccga); _ebcg != nil {
					return _ebcg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "chExt"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "chExt"}:
				_cbbfg.ChExt = NewCT_PositiveSize2D()
				if _ebfd := d.DecodeElement(_cbbfg.ChExt, &_bccga); _ebfd != nil {
					return _ebfd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GroupTransform2D\u0020\u0025v", _bccga.Name)
				if _fcegc := d.Skip(); _fcegc != nil {
					return _fcegc
				}
			}
		case _g.EndElement:
			break _adgc
		case _g.CharData:
		}
	}
	return nil
}

type ST_TextCapsType byte

func (_bbf *CT_AnimationGraphicalObjectBuildProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _bbf.BldDgm != nil {
		_cga := _g.StartElement{Name: _g.Name{Local: "a:bldDgm"}}
		e.EncodeElement(_bbf.BldDgm, _cga)
	}
	if _bbf.BldChart != nil {
		_decc := _g.StartElement{Name: _g.Name{Local: "a:bldChart"}}
		e.EncodeElement(_bbf.BldChart, _decc)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_gfebbe ST_PresetColorVal) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_gfebbe.String(), start)
}
func (_abgfba *ST_TextVerticalType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cddbc, _bafgf := d.Token()
	if _bafgf != nil {
		return _bafgf
	}
	if _aggefa, _cagfb := _cddbc.(_g.EndElement); _cagfb && _aggefa.Name == start.Name {
		*_abgfba = 1
		return nil
	}
	if _bdabd, _gaebc := _cddbc.(_g.CharData); !_gaebc {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cddbc)
	} else {
		switch string(_bdabd) {
		case "":
			*_abgfba = 0
		case "horz":
			*_abgfba = 1
		case "vert":
			*_abgfba = 2
		case "vert270":
			*_abgfba = 3
		case "wordArtVert":
			*_abgfba = 4
		case "eaVert":
			*_abgfba = 5
		case "mongolianVert":
			*_abgfba = 6
		case "wordArtVertRtl":
			*_abgfba = 7
		}
	}
	_cddbc, _bafgf = d.Token()
	if _bafgf != nil {
		return _bafgf
	}
	if _decca, _bcaeff := _cddbc.(_g.EndElement); _bcaeff && _decca.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cddbc)
}
func (_gdcg *CT_FontScheme) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gdcg.MajorFont = NewCT_FontCollection()
	_gdcg.MinorFont = NewCT_FontCollection()
	for _, _afgbc := range start.Attr {
		if _afgbc.Name.Local == "name" {
			_eccde, _fagaf := _afgbc.Value, error(nil)
			if _fagaf != nil {
				return _fagaf
			}
			_gdcg.NameAttr = _eccde
			continue
		}
	}
_bccaa:
	for {
		_dfbde, _ffag := d.Token()
		if _ffag != nil {
			return _ffag
		}
		switch _gbdab := _dfbde.(type) {
		case _g.StartElement:
			switch _gbdab.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "majorFont"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "majorFont"}:
				if _bdcb := d.DecodeElement(_gdcg.MajorFont, &_gbdab); _bdcb != nil {
					return _bdcb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "minorFont"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "minorFont"}:
				if _ebaaf := d.DecodeElement(_gdcg.MinorFont, &_gbdab); _ebaaf != nil {
					return _ebaaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_gdcg.ExtLst = NewCT_OfficeArtExtensionList()
				if _facg := d.DecodeElement(_gdcg.ExtLst, &_gbdab); _facg != nil {
					return _facg
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_FontScheme \u0025v", _gbdab.Name)
				if _caab := d.Skip(); _caab != nil {
					return _caab
				}
			}
		case _g.EndElement:
			break _bccaa
		case _g.CharData:
		}
	}
	return nil
}
func (_dbagg ST_PresetPatternVal) Validate() error { return _dbagg.ValidateWithPath("") }

// Validate validates the CT_EmptyElement and its children
func (_fdaba *CT_EmptyElement) Validate() error { return _fdaba.ValidateWithPath("CT_EmptyElement") }
func (_eafdb ST_TileFlipMode) Validate() error  { return _eafdb.ValidateWithPath("") }

// Validate validates the CT_LineEndProperties and its children
func (_gbgce *CT_LineEndProperties) Validate() error {
	return _gbgce.ValidateWithPath("CT_LineEndProperties")
}

// Validate validates the CT_Boolean and its children
func (_fdca *CT_Boolean) Validate() error { return _fdca.ValidateWithPath("CT_Boolean") }
func NewTheme() *Theme {
	_bbgfa := &Theme{}
	_bbgfa.CT_OfficeStyleSheet = *NewCT_OfficeStyleSheet()
	return _bbgfa
}
func NewCT_SupplementalFont() *CT_SupplementalFont { _fdffg := &CT_SupplementalFont{}; return _fdffg }
func (_gcge *CT_GvmlConnector) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gcge.NvCxnSpPr = NewCT_GvmlConnectorNonVisual()
	_gcge.SpPr = NewCT_ShapeProperties()
_agbfe:
	for {
		_bdcca, _agbfef := d.Token()
		if _agbfef != nil {
			return _agbfef
		}
		switch _dgfe := _bdcca.(type) {
		case _g.StartElement:
			switch _dgfe.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "nvCxnSpPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "nvCxnSpPr"}:
				if _fgdbf := d.DecodeElement(_gcge.NvCxnSpPr, &_dgfe); _fgdbf != nil {
					return _fgdbf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spPr"}:
				if _bcge := d.DecodeElement(_gcge.SpPr, &_dgfe); _bcge != nil {
					return _bcge
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "style"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "style"}:
				_gcge.Style = NewCT_ShapeStyle()
				if _cebga := d.DecodeElement(_gcge.Style, &_dgfe); _cebga != nil {
					return _cebga
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_gcge.ExtLst = NewCT_OfficeArtExtensionList()
				if _debec := d.DecodeElement(_gcge.ExtLst, &_dgfe); _debec != nil {
					return _debec
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GvmlConnector\u0020\u0025v", _dgfe.Name)
				if _abag := d.Skip(); _abag != nil {
					return _abag
				}
			}
		case _g.EndElement:
			break _agbfe
		case _g.CharData:
		}
	}
	return nil
}
func (_fddad *ST_SchemeColorVal) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fddad = 0
	case "bg1":
		*_fddad = 1
	case "tx1":
		*_fddad = 2
	case "bg2":
		*_fddad = 3
	case "tx2":
		*_fddad = 4
	case "accent1":
		*_fddad = 5
	case "accent2":
		*_fddad = 6
	case "accent3":
		*_fddad = 7
	case "accent4":
		*_fddad = 8
	case "accent5":
		*_fddad = 9
	case "accent6":
		*_fddad = 10
	case "hlink":
		*_fddad = 11
	case "folHlink":
		*_fddad = 12
	case "phClr":
		*_fddad = 13
	case "dk1":
		*_fddad = 14
	case "lt1":
		*_fddad = 15
	case "dk2":
		*_fddad = 16
	case "lt2":
		*_fddad = 17
	}
	return nil
}

// ValidateWithPath validates the CT_GroupLocking and its children, prefixing error messages with path
func (_dafdaf *CT_GroupLocking) ValidateWithPath(path string) error {
	if _dafdaf.ExtLst != nil {
		if _abacc := _dafdaf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _abacc != nil {
			return _abacc
		}
	}
	return nil
}
func (_dbecg *Tbl) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "a:tbl"
	return _dbecg.CT_Table.MarshalXML(e, start)
}
func NewCT_AlphaOutsetEffect() *CT_AlphaOutsetEffect { _dbe := &CT_AlphaOutsetEffect{}; return _dbe }

type ST_BlendMode byte

// Validate validates the CT_TextSpacingPoint and its children
func (_eedfe *CT_TextSpacingPoint) Validate() error {
	return _eedfe.ValidateWithPath("CT_TextSpacingPoint")
}
func (_cfbec ST_TextAnchoringType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cfbec.String(), start)
}
func (_fedeg *CT_TextParagraphProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fedeg.MarLAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "marL"}, Value: _dcf.Sprintf("\u0025v", *_fedeg.MarLAttr)})
	}
	if _fedeg.MarRAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "marR"}, Value: _dcf.Sprintf("\u0025v", *_fedeg.MarRAttr)})
	}
	if _fedeg.LvlAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lvl"}, Value: _dcf.Sprintf("\u0025v", *_fedeg.LvlAttr)})
	}
	if _fedeg.IndentAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "indent"}, Value: _dcf.Sprintf("\u0025v", *_fedeg.IndentAttr)})
	}
	if _fedeg.AlgnAttr != ST_TextAlignTypeUnset {
		_bccac, _bccfe := _fedeg.AlgnAttr.MarshalXMLAttr(_g.Name{Local: "algn"})
		if _bccfe != nil {
			return _bccfe
		}
		start.Attr = append(start.Attr, _bccac)
	}
	if _fedeg.DefTabSzAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "defTabSz"}, Value: _dcf.Sprintf("\u0025v", *_fedeg.DefTabSzAttr)})
	}
	if _fedeg.RtlAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rtl"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fedeg.RtlAttr))})
	}
	if _fedeg.EaLnBrkAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "eaLnBrk"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fedeg.EaLnBrkAttr))})
	}
	if _fedeg.FontAlgnAttr != ST_TextFontAlignTypeUnset {
		_acddcc, _edeabf := _fedeg.FontAlgnAttr.MarshalXMLAttr(_g.Name{Local: "fontAlgn"})
		if _edeabf != nil {
			return _edeabf
		}
		start.Attr = append(start.Attr, _acddcc)
	}
	if _fedeg.LatinLnBrkAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "latinLnBrk"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fedeg.LatinLnBrkAttr))})
	}
	if _fedeg.HangingPunctAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "hangingPunct"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fedeg.HangingPunctAttr))})
	}
	e.EncodeToken(start)
	if _fedeg.LnSpc != nil {
		_eadab := _g.StartElement{Name: _g.Name{Local: "a:lnSpc"}}
		e.EncodeElement(_fedeg.LnSpc, _eadab)
	}
	if _fedeg.SpcBef != nil {
		_eeadc := _g.StartElement{Name: _g.Name{Local: "a:spcBef"}}
		e.EncodeElement(_fedeg.SpcBef, _eeadc)
	}
	if _fedeg.SpcAft != nil {
		_fbbc := _g.StartElement{Name: _g.Name{Local: "a:spcAft"}}
		e.EncodeElement(_fedeg.SpcAft, _fbbc)
	}
	if _fedeg.BuClrTx != nil {
		_ccdef := _g.StartElement{Name: _g.Name{Local: "a:buClrTx"}}
		e.EncodeElement(_fedeg.BuClrTx, _ccdef)
	}
	if _fedeg.BuClr != nil {
		_agcedf := _g.StartElement{Name: _g.Name{Local: "a:buClr"}}
		e.EncodeElement(_fedeg.BuClr, _agcedf)
	}
	if _fedeg.BuSzTx != nil {
		_eafcb := _g.StartElement{Name: _g.Name{Local: "a:buSzTx"}}
		e.EncodeElement(_fedeg.BuSzTx, _eafcb)
	}
	if _fedeg.BuSzPct != nil {
		_egeff := _g.StartElement{Name: _g.Name{Local: "a:buSzPct"}}
		e.EncodeElement(_fedeg.BuSzPct, _egeff)
	}
	if _fedeg.BuSzPts != nil {
		_cgfd := _g.StartElement{Name: _g.Name{Local: "a:buSzPts"}}
		e.EncodeElement(_fedeg.BuSzPts, _cgfd)
	}
	if _fedeg.BuFontTx != nil {
		_dega := _g.StartElement{Name: _g.Name{Local: "a:buFontTx"}}
		e.EncodeElement(_fedeg.BuFontTx, _dega)
	}
	if _fedeg.BuFont != nil {
		_fcbda := _g.StartElement{Name: _g.Name{Local: "a:buFont"}}
		e.EncodeElement(_fedeg.BuFont, _fcbda)
	}
	if _fedeg.BuNone != nil {
		_gcbe := _g.StartElement{Name: _g.Name{Local: "a:buNone"}}
		e.EncodeElement(_fedeg.BuNone, _gcbe)
	}
	if _fedeg.BuAutoNum != nil {
		_bccgc := _g.StartElement{Name: _g.Name{Local: "a:buAutoNum"}}
		e.EncodeElement(_fedeg.BuAutoNum, _bccgc)
	}
	if _fedeg.BuChar != nil {
		_cgabb := _g.StartElement{Name: _g.Name{Local: "a:buChar"}}
		e.EncodeElement(_fedeg.BuChar, _cgabb)
	}
	if _fedeg.BuBlip != nil {
		_afaga := _g.StartElement{Name: _g.Name{Local: "a:buBlip"}}
		e.EncodeElement(_fedeg.BuBlip, _afaga)
	}
	if _fedeg.TabLst != nil {
		_ffdae := _g.StartElement{Name: _g.Name{Local: "a:tabLst"}}
		e.EncodeElement(_fedeg.TabLst, _ffdae)
	}
	if _fedeg.DefRPr != nil {
		_faedf := _g.StartElement{Name: _g.Name{Local: "a:defRPr"}}
		e.EncodeElement(_fedeg.DefRPr, _faedf)
	}
	if _fedeg.ExtLst != nil {
		_afabed := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_fedeg.ExtLst, _afabed)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_Color struct {
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
}

func NewCT_SolidColorFillProperties() *CT_SolidColorFillProperties {
	_cdgbgf := &CT_SolidColorFillProperties{}
	return _cdgbgf
}
func NewCT_FixedPercentage() *CT_FixedPercentage { _dgeg := &CT_FixedPercentage{}; return _dgeg }

// ST_TextSpacingPercentOrPercentString is a union type
type ST_TextSpacingPercentOrPercentString struct {
	ST_TextSpacingPercent *int32
	ST_Percentage         *string
}

// ValidateWithPath validates the CT_TextBulletSizePercent and its children, prefixing error messages with path
func (_dadfg *CT_TextBulletSizePercent) ValidateWithPath(path string) error {
	if !ST_TextBulletSizePercentPatternRe.MatchString(_dadfg.ValAttr) {
		return _dcf.Errorf("\u0025s\u002fm\u002eValAttr\u0020must\u0020match\u0020'\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, ST_TextBulletSizePercentPatternRe, _dadfg.ValAttr)
	}
	return nil
}

// Validate validates the CT_GroupTransform2D and its children
func (_agbe *CT_GroupTransform2D) Validate() error {
	return _agbe.ValidateWithPath("CT_GroupTransform2D")
}

const (
	ST_LightRigDirectionUnset ST_LightRigDirection = 0
	ST_LightRigDirectionTl    ST_LightRigDirection = 1
	ST_LightRigDirectionT     ST_LightRigDirection = 2
	ST_LightRigDirectionTr    ST_LightRigDirection = 3
	ST_LightRigDirectionL     ST_LightRigDirection = 4
	ST_LightRigDirectionR     ST_LightRigDirection = 5
	ST_LightRigDirectionBl    ST_LightRigDirection = 6
	ST_LightRigDirectionB     ST_LightRigDirection = 7
	ST_LightRigDirectionBr    ST_LightRigDirection = 8
)

func (_bcadf ST_TextFontScalePercentOrPercentString) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _bcadf.ST_TextFontScalePercent != nil {
		e.EncodeToken(_g.CharData(_dcf.Sprintf("\u0025d", *_bcadf.ST_TextFontScalePercent)))
	}
	if _bcadf.ST_Percentage != nil {
		e.EncodeToken(_g.CharData(*_bcadf.ST_Percentage))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

// ValidateWithPath validates the EG_ThemeableEffectStyle and its children, prefixing error messages with path
func (_dacb *EG_ThemeableEffectStyle) ValidateWithPath(path string) error {
	if _dacb.Effect != nil {
		if _ceacf := _dacb.Effect.ValidateWithPath(path + "\u002fEffect"); _ceacf != nil {
			return _ceacf
		}
	}
	if _dacb.EffectRef != nil {
		if _gfbbda := _dacb.EffectRef.ValidateWithPath(path + "\u002fEffectRef"); _gfbbda != nil {
			return _gfbbda
		}
	}
	return nil
}
func NewCT_GvmlPictureNonVisual() *CT_GvmlPictureNonVisual {
	_fegd := &CT_GvmlPictureNonVisual{}
	_fegd.CNvPr = NewCT_NonVisualDrawingProps()
	_fegd.CNvPicPr = NewCT_NonVisualPictureProperties()
	return _fegd
}
func (_cgec *CT_GroupLocking) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _dabeg := range start.Attr {
		if _dabeg.Name.Local == "noGrp" {
			_fbff, _ddafc := _e.ParseBool(_dabeg.Value)
			if _ddafc != nil {
				return _ddafc
			}
			_cgec.NoGrpAttr = &_fbff
			continue
		}
		if _dabeg.Name.Local == "noUngrp" {
			_cdbf, _fabed := _e.ParseBool(_dabeg.Value)
			if _fabed != nil {
				return _fabed
			}
			_cgec.NoUngrpAttr = &_cdbf
			continue
		}
		if _dabeg.Name.Local == "noSelect" {
			_dgdd, _fddd := _e.ParseBool(_dabeg.Value)
			if _fddd != nil {
				return _fddd
			}
			_cgec.NoSelectAttr = &_dgdd
			continue
		}
		if _dabeg.Name.Local == "noRot" {
			_daeed, _geabg := _e.ParseBool(_dabeg.Value)
			if _geabg != nil {
				return _geabg
			}
			_cgec.NoRotAttr = &_daeed
			continue
		}
		if _dabeg.Name.Local == "noChangeAspect" {
			_ddbd, _aaabc := _e.ParseBool(_dabeg.Value)
			if _aaabc != nil {
				return _aaabc
			}
			_cgec.NoChangeAspectAttr = &_ddbd
			continue
		}
		if _dabeg.Name.Local == "noMove" {
			_agfg, _dacfg := _e.ParseBool(_dabeg.Value)
			if _dacfg != nil {
				return _dacfg
			}
			_cgec.NoMoveAttr = &_agfg
			continue
		}
		if _dabeg.Name.Local == "noResize" {
			_cccge, _afdc := _e.ParseBool(_dabeg.Value)
			if _afdc != nil {
				return _afdc
			}
			_cgec.NoResizeAttr = &_cccge
			continue
		}
	}
_dagg:
	for {
		_edda, _ageb := d.Token()
		if _ageb != nil {
			return _ageb
		}
		switch _dgffa := _edda.(type) {
		case _g.StartElement:
			switch _dgffa.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_cgec.ExtLst = NewCT_OfficeArtExtensionList()
				if _gffa := d.DecodeElement(_cgec.ExtLst, &_dgffa); _gffa != nil {
					return _gffa
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GroupLocking\u0020\u0025v", _dgffa.Name)
				if _cadef := d.Skip(); _cadef != nil {
					return _cadef
				}
			}
		case _g.EndElement:
			break _dagg
		case _g.CharData:
		}
	}
	return nil
}

type CT_SRgbColor struct {
	ValAttr           string
	EG_ColorTransform []*EG_ColorTransform
}

func (_cfegcg *CT_TextShapeAutofit) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_cbdef, _fagge := d.Token()
		if _fagge != nil {
			return _dcf.Errorf("parsing\u0020CT_TextShapeAutofit:\u0020\u0025s", _fagge)
		}
		if _ebgcd, _gfabd := _cbdef.(_g.EndElement); _gfabd && _ebgcd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dcgcg *ST_TextCapsType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cccdb, _cagba := d.Token()
	if _cagba != nil {
		return _cagba
	}
	if _cgcdc, _gadea := _cccdb.(_g.EndElement); _gadea && _cgcdc.Name == start.Name {
		*_dcgcg = 1
		return nil
	}
	if _dfgbg, _fefee := _cccdb.(_g.CharData); !_fefee {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cccdb)
	} else {
		switch string(_dfgbg) {
		case "":
			*_dcgcg = 0
		case "none":
			*_dcgcg = 1
		case "small":
			*_dcgcg = 2
		case "all":
			*_dcgcg = 3
		}
	}
	_cccdb, _cagba = d.Token()
	if _cagba != nil {
		return _cagba
	}
	if _bfcef, _ccgd := _cccdb.(_g.EndElement); _ccgd && _bfcef.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cccdb)
}

// ValidateWithPath validates the CT_TextTabStop and its children, prefixing error messages with path
func (_fadgg *CT_TextTabStop) ValidateWithPath(path string) error {
	if _fadgg.PosAttr != nil {
		if _ccdc := _fadgg.PosAttr.ValidateWithPath(path + "\u002fPosAttr"); _ccdc != nil {
			return _ccdc
		}
	}
	if _beadc := _fadgg.AlgnAttr.ValidateWithPath(path + "\u002fAlgnAttr"); _beadc != nil {
		return _beadc
	}
	return nil
}
func (_cbdac *CT_GvmlPictureNonVisual) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_gedb := _g.StartElement{Name: _g.Name{Local: "a:cNvPr"}}
	e.EncodeElement(_cbdac.CNvPr, _gedb)
	_eecgc := _g.StartElement{Name: _g.Name{Local: "a:cNvPicPr"}}
	e.EncodeElement(_cbdac.CNvPicPr, _eecgc)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_AnimationChartElement() *CT_AnimationChartElement {
	_caaa := &CT_AnimationChartElement{}
	_caaa.BldStepAttr = ST_ChartBuildStep(1)
	return _caaa
}

// Validate validates the CT_GvmlGraphicalObjectFrame and its children
func (_aeefg *CT_GvmlGraphicalObjectFrame) Validate() error {
	return _aeefg.ValidateWithPath("CT_GvmlGraphicalObjectFrame")
}
func (_gcbd *CT_FillOverlayEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gcbd.BlendAttr = ST_BlendMode(1)
	for _, _egee := range start.Attr {
		if _egee.Name.Local == "blend" {
			_gcbd.BlendAttr.UnmarshalXMLAttr(_egee)
			continue
		}
	}
_fefa:
	for {
		_cabg, _gcdgb := d.Token()
		if _gcdgb != nil {
			return _gcdgb
		}
		switch _adddc := _cabg.(type) {
		case _g.StartElement:
			switch _adddc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_gcbd.NoFill = NewCT_NoFillProperties()
				if _fcbc := d.DecodeElement(_gcbd.NoFill, &_adddc); _fcbc != nil {
					return _fcbc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_gcbd.SolidFill = NewCT_SolidColorFillProperties()
				if _fdgc := d.DecodeElement(_gcbd.SolidFill, &_adddc); _fdgc != nil {
					return _fdgc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_gcbd.GradFill = NewCT_GradientFillProperties()
				if _fggg := d.DecodeElement(_gcbd.GradFill, &_adddc); _fggg != nil {
					return _fggg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_gcbd.BlipFill = NewCT_BlipFillProperties()
				if _dcgda := d.DecodeElement(_gcbd.BlipFill, &_adddc); _dcgda != nil {
					return _dcgda
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_gcbd.PattFill = NewCT_PatternFillProperties()
				if _gfcbe := d.DecodeElement(_gcbd.PattFill, &_adddc); _gfcbe != nil {
					return _gfcbe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_gcbd.GrpFill = NewCT_GroupFillProperties()
				if _dggad := d.DecodeElement(_gcbd.GrpFill, &_adddc); _dggad != nil {
					return _dggad
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_FillOverlayEffect\u0020\u0025v", _adddc.Name)
				if _ebaa := d.Skip(); _ebaa != nil {
					return _ebaa
				}
			}
		case _g.EndElement:
			break _fefa
		case _g.CharData:
		}
	}
	return nil
}
func (_dcddf *CT_GvmlGroupShapeNonVisual) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dcddf.CNvPr = NewCT_NonVisualDrawingProps()
	_dcddf.CNvGrpSpPr = NewCT_NonVisualGroupDrawingShapeProps()
_fada:
	for {
		_gcbfg, _egebd := d.Token()
		if _egebd != nil {
			return _egebd
		}
		switch _ggeaf := _gcbfg.(type) {
		case _g.StartElement:
			switch _ggeaf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cNvPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cNvPr"}:
				if _afafg := d.DecodeElement(_dcddf.CNvPr, &_ggeaf); _afafg != nil {
					return _afafg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cNvGrpSpPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cNvGrpSpPr"}:
				if _gdgbb := d.DecodeElement(_dcddf.CNvGrpSpPr, &_ggeaf); _gdgbb != nil {
					return _gdgbb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GvmlGroupShapeNonVisual\u0020\u0025v", _ggeaf.Name)
				if _fccdb := d.Skip(); _fccdb != nil {
					return _fccdb
				}
			}
		case _g.EndElement:
			break _fada
		case _g.CharData:
		}
	}
	return nil
}

type ST_OnOffStyleType byte

// Validate validates the CT_GraphicalObjectFrameLocking and its children
func (_fbbae *CT_GraphicalObjectFrameLocking) Validate() error {
	return _fbbae.ValidateWithPath("CT_GraphicalObjectFrameLocking")
}

type CT_PositivePercentage struct{ ValAttr ST_PositivePercentage }

func (_cfgef *CT_XYAdjustHandle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cfgef.Pos = NewCT_AdjPoint2D()
	for _, _cbgfa := range start.Attr {
		if _cbgfa.Name.Local == "gdRefX" {
			_cbffb, _fadbd := _cbgfa.Value, error(nil)
			if _fadbd != nil {
				return _fadbd
			}
			_cfgef.GdRefXAttr = &_cbffb
			continue
		}
		if _cbgfa.Name.Local == "minX" {
			_ggfbe, _eefde := ParseUnionST_AdjCoordinate(_cbgfa.Value)
			if _eefde != nil {
				return _eefde
			}
			_cfgef.MinXAttr = &_ggfbe
			continue
		}
		if _cbgfa.Name.Local == "maxX" {
			_deeaf, _dffbb := ParseUnionST_AdjCoordinate(_cbgfa.Value)
			if _dffbb != nil {
				return _dffbb
			}
			_cfgef.MaxXAttr = &_deeaf
			continue
		}
		if _cbgfa.Name.Local == "gdRefY" {
			_aegda, _cgfadc := _cbgfa.Value, error(nil)
			if _cgfadc != nil {
				return _cgfadc
			}
			_cfgef.GdRefYAttr = &_aegda
			continue
		}
		if _cbgfa.Name.Local == "minY" {
			_bfcdf, _degc := ParseUnionST_AdjCoordinate(_cbgfa.Value)
			if _degc != nil {
				return _degc
			}
			_cfgef.MinYAttr = &_bfcdf
			continue
		}
		if _cbgfa.Name.Local == "maxY" {
			_bgfeg, _efade := ParseUnionST_AdjCoordinate(_cbgfa.Value)
			if _efade != nil {
				return _efade
			}
			_cfgef.MaxYAttr = &_bgfeg
			continue
		}
	}
_bdbee:
	for {
		_ccdbg, _bcbbc := d.Token()
		if _bcbbc != nil {
			return _bcbbc
		}
		switch _bddadc := _ccdbg.(type) {
		case _g.StartElement:
			switch _bddadc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pos"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pos"}:
				if _ecbbgg := d.DecodeElement(_cfgef.Pos, &_bddadc); _ecbbgg != nil {
					return _ecbbgg
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_XYAdjustHandle\u0020\u0025v", _bddadc.Name)
				if _gegcg := d.Skip(); _gegcg != nil {
					return _gegcg
				}
			}
		case _g.EndElement:
			break _bdbee
		case _g.CharData:
		}
	}
	return nil
}
func (_acg *CT_AlphaCeilingEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the EG_TextBulletTypeface and its children
func (_deaabf *EG_TextBulletTypeface) Validate() error {
	return _deaabf.ValidateWithPath("EG_TextBulletTypeface")
}

// Validate validates the CT_EffectReference and its children
func (_fbbe *CT_EffectReference) Validate() error {
	return _fbbe.ValidateWithPath("CT_EffectReference")
}

type CT_SoftEdgesEffect struct{ RadAttr int64 }

// ValidateWithPath validates the CT_InnerShadowEffect and its children, prefixing error messages with path
func (_fgff *CT_InnerShadowEffect) ValidateWithPath(path string) error {
	if _fgff.BlurRadAttr != nil {
		if *_fgff.BlurRadAttr < 0 {
			return _dcf.Errorf("\u0025s\u002fm\u002eBlurRadAttr\u0020must\u0020be\u0020\u003e\u003d\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_fgff.BlurRadAttr)
		}
		if *_fgff.BlurRadAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s/m\u002eBlurRadAttr\u0020must\u0020be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_fgff.BlurRadAttr)
		}
	}
	if _fgff.DistAttr != nil {
		if *_fgff.DistAttr < 0 {
			return _dcf.Errorf("\u0025s/m\u002eDistAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_fgff.DistAttr)
		}
		if *_fgff.DistAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s\u002fm\u002eDistAttr\u0020must\u0020be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_fgff.DistAttr)
		}
	}
	if _fgff.DirAttr != nil {
		if *_fgff.DirAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eDirAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_fgff.DirAttr)
		}
		if *_fgff.DirAttr >= 21600000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eDirAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, *_fgff.DirAttr)
		}
	}
	if _fgff.ScrgbClr != nil {
		if _gfbca := _fgff.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _gfbca != nil {
			return _gfbca
		}
	}
	if _fgff.SrgbClr != nil {
		if _fgbf := _fgff.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _fgbf != nil {
			return _fgbf
		}
	}
	if _fgff.HslClr != nil {
		if _baaf := _fgff.HslClr.ValidateWithPath(path + "\u002fHslClr"); _baaf != nil {
			return _baaf
		}
	}
	if _fgff.SysClr != nil {
		if _eceb := _fgff.SysClr.ValidateWithPath(path + "\u002fSysClr"); _eceb != nil {
			return _eceb
		}
	}
	if _fgff.SchemeClr != nil {
		if _acefg := _fgff.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _acefg != nil {
			return _acefg
		}
	}
	if _fgff.PrstClr != nil {
		if _adbge := _fgff.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _adbge != nil {
			return _adbge
		}
	}
	return nil
}
func (_eagaf *ST_TextAutonumberScheme) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_eagaf = 0
	case "alphaLcParenBoth":
		*_eagaf = 1
	case "alphaUcParenBoth":
		*_eagaf = 2
	case "alphaLcParenR":
		*_eagaf = 3
	case "alphaUcParenR":
		*_eagaf = 4
	case "alphaLcPeriod":
		*_eagaf = 5
	case "alphaUcPeriod":
		*_eagaf = 6
	case "arabicParenBoth":
		*_eagaf = 7
	case "arabicParenR":
		*_eagaf = 8
	case "arabicPeriod":
		*_eagaf = 9
	case "arabicPlain":
		*_eagaf = 10
	case "romanLcParenBoth":
		*_eagaf = 11
	case "romanUcParenBoth":
		*_eagaf = 12
	case "romanLcParenR":
		*_eagaf = 13
	case "romanUcParenR":
		*_eagaf = 14
	case "romanLcPeriod":
		*_eagaf = 15
	case "romanUcPeriod":
		*_eagaf = 16
	case "circleNumDbPlain":
		*_eagaf = 17
	case "circleNumWdBlackPlain":
		*_eagaf = 18
	case "circleNumWdWhitePlain":
		*_eagaf = 19
	case "arabicDbPeriod":
		*_eagaf = 20
	case "arabicDbPlain":
		*_eagaf = 21
	case "ea1ChsPeriod":
		*_eagaf = 22
	case "ea1ChsPlain":
		*_eagaf = 23
	case "ea1ChtPeriod":
		*_eagaf = 24
	case "ea1ChtPlain":
		*_eagaf = 25
	case "ea1JpnChsDbPeriod":
		*_eagaf = 26
	case "ea1JpnKorPlain":
		*_eagaf = 27
	case "ea1JpnKorPeriod":
		*_eagaf = 28
	case "arabic1Minus":
		*_eagaf = 29
	case "arabic2Minus":
		*_eagaf = 30
	case "hebrew2Minus":
		*_eagaf = 31
	case "thaiAlphaPeriod":
		*_eagaf = 32
	case "thaiAlphaParenR":
		*_eagaf = 33
	case "thaiAlphaParenBoth":
		*_eagaf = 34
	case "thaiNumPeriod":
		*_eagaf = 35
	case "thaiNumParenR":
		*_eagaf = 36
	case "thaiNumParenBoth":
		*_eagaf = 37
	case "hindiAlphaPeriod":
		*_eagaf = 38
	case "hindiNumPeriod":
		*_eagaf = 39
	case "hindiNumParenR":
		*_eagaf = 40
	case "hindiAlpha1Period":
		*_eagaf = 41
	}
	return nil
}

// ValidateWithPath validates the CT_FontScheme and its children, prefixing error messages with path
func (_dfeb *CT_FontScheme) ValidateWithPath(path string) error {
	if _eccg := _dfeb.MajorFont.ValidateWithPath(path + "\u002fMajorFont"); _eccg != nil {
		return _eccg
	}
	if _affe := _dfeb.MinorFont.ValidateWithPath(path + "\u002fMinorFont"); _affe != nil {
		return _affe
	}
	if _dfeb.ExtLst != nil {
		if _dgag := _dfeb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dgag != nil {
			return _dgag
		}
	}
	return nil
}
func NewCT_TextFont() *CT_TextFont { _accd := &CT_TextFont{}; return _accd }

// ValidateWithPath validates the EG_LineDashProperties and its children, prefixing error messages with path
func (_dbbcgc *EG_LineDashProperties) ValidateWithPath(path string) error {
	if _dbbcgc.PrstDash != nil {
		if _bbace := _dbbcgc.PrstDash.ValidateWithPath(path + "\u002fPrstDash"); _bbace != nil {
			return _bbace
		}
	}
	if _dbbcgc.CustDash != nil {
		if _ecacg := _dbbcgc.CustDash.ValidateWithPath(path + "\u002fCustDash"); _ecacg != nil {
			return _ecacg
		}
	}
	return nil
}
func (_aaadd ST_OnOffStyleType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_aaadd.String(), start)
}
func NewCT_LinearShadeProperties() *CT_LinearShadeProperties {
	_cdced := &CT_LinearShadeProperties{}
	return _cdced
}
func (_eaedf *CT_FillStyleList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gabbc:
	for {
		_ebce, _bcdeg := d.Token()
		if _bcdeg != nil {
			return _bcdeg
		}
		switch _debfa := _ebce.(type) {
		case _g.StartElement:
			switch _debfa.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_gddg := NewEG_FillProperties()
				_gddg.NoFill = NewCT_NoFillProperties()
				if _gcfde := d.DecodeElement(_gddg.NoFill, &_debfa); _gcfde != nil {
					return _gcfde
				}
				_eaedf.EG_FillProperties = append(_eaedf.EG_FillProperties, _gddg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_fded := NewEG_FillProperties()
				_fded.SolidFill = NewCT_SolidColorFillProperties()
				if _cbaa := d.DecodeElement(_fded.SolidFill, &_debfa); _cbaa != nil {
					return _cbaa
				}
				_eaedf.EG_FillProperties = append(_eaedf.EG_FillProperties, _fded)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_cbdab := NewEG_FillProperties()
				_cbdab.GradFill = NewCT_GradientFillProperties()
				if _cacd := d.DecodeElement(_cbdab.GradFill, &_debfa); _cacd != nil {
					return _cacd
				}
				_eaedf.EG_FillProperties = append(_eaedf.EG_FillProperties, _cbdab)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_bagb := NewEG_FillProperties()
				_bagb.BlipFill = NewCT_BlipFillProperties()
				if _cgbea := d.DecodeElement(_bagb.BlipFill, &_debfa); _cgbea != nil {
					return _cgbea
				}
				_eaedf.EG_FillProperties = append(_eaedf.EG_FillProperties, _bagb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_cdad := NewEG_FillProperties()
				_cdad.PattFill = NewCT_PatternFillProperties()
				if _cbedg := d.DecodeElement(_cdad.PattFill, &_debfa); _cbedg != nil {
					return _cbedg
				}
				_eaedf.EG_FillProperties = append(_eaedf.EG_FillProperties, _cdad)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_gdgd := NewEG_FillProperties()
				_gdgd.GrpFill = NewCT_GroupFillProperties()
				if _acda := d.DecodeElement(_gdgd.GrpFill, &_debfa); _acda != nil {
					return _acda
				}
				_eaedf.EG_FillProperties = append(_eaedf.EG_FillProperties, _gdgd)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_FillStyleList\u0020\u0025v", _debfa.Name)
				if _baac := d.Skip(); _baac != nil {
					return _baac
				}
			}
		case _g.EndElement:
			break _gabbc
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TableStyleTextStyle and its children, prefixing error messages with path
func (_gggae *CT_TableStyleTextStyle) ValidateWithPath(path string) error {
	if _gaecd := _gggae.BAttr.ValidateWithPath(path + "\u002fBAttr"); _gaecd != nil {
		return _gaecd
	}
	if _acfdc := _gggae.IAttr.ValidateWithPath(path + "\u002fIAttr"); _acfdc != nil {
		return _acfdc
	}
	if _gggae.Font != nil {
		if _ecfbe := _gggae.Font.ValidateWithPath(path + "\u002fFont"); _ecfbe != nil {
			return _ecfbe
		}
	}
	if _gggae.FontRef != nil {
		if _acfac := _gggae.FontRef.ValidateWithPath(path + "\u002fFontRef"); _acfac != nil {
			return _acfac
		}
	}
	if _gggae.ScrgbClr != nil {
		if _dfdeg := _gggae.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _dfdeg != nil {
			return _dfdeg
		}
	}
	if _gggae.SrgbClr != nil {
		if _fffeba := _gggae.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _fffeba != nil {
			return _fffeba
		}
	}
	if _gggae.HslClr != nil {
		if _gadbg := _gggae.HslClr.ValidateWithPath(path + "\u002fHslClr"); _gadbg != nil {
			return _gadbg
		}
	}
	if _gggae.SysClr != nil {
		if _edegff := _gggae.SysClr.ValidateWithPath(path + "\u002fSysClr"); _edegff != nil {
			return _edegff
		}
	}
	if _gggae.SchemeClr != nil {
		if _ebae := _gggae.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _ebae != nil {
			return _ebae
		}
	}
	if _gggae.PrstClr != nil {
		if _acgac := _gggae.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _acgac != nil {
			return _acgac
		}
	}
	if _gggae.ExtLst != nil {
		if _geafc := _gggae.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _geafc != nil {
			return _geafc
		}
	}
	return nil
}
func (_dbdcb *CT_InnerShadowEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _dbfdb := range start.Attr {
		if _dbfdb.Name.Local == "blurRad" {
			_gfaf, _eggad := _e.ParseInt(_dbfdb.Value, 10, 64)
			if _eggad != nil {
				return _eggad
			}
			_dbdcb.BlurRadAttr = &_gfaf
			continue
		}
		if _dbfdb.Name.Local == "dist" {
			_gddca, _edfb := _e.ParseInt(_dbfdb.Value, 10, 64)
			if _edfb != nil {
				return _edfb
			}
			_dbdcb.DistAttr = &_gddca
			continue
		}
		if _dbfdb.Name.Local == "dir" {
			_edcdd, _ddbgf := _e.ParseInt(_dbfdb.Value, 10, 32)
			if _ddbgf != nil {
				return _ddbgf
			}
			_edba := int32(_edcdd)
			_dbdcb.DirAttr = &_edba
			continue
		}
	}
_bbag:
	for {
		_fdfc, _cebcc := d.Token()
		if _cebcc != nil {
			return _cebcc
		}
		switch _fbbbd := _fdfc.(type) {
		case _g.StartElement:
			switch _fbbbd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_dbdcb.ScrgbClr = NewCT_ScRgbColor()
				if _fgaaf := d.DecodeElement(_dbdcb.ScrgbClr, &_fbbbd); _fgaaf != nil {
					return _fgaaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_dbdcb.SrgbClr = NewCT_SRgbColor()
				if _daea := d.DecodeElement(_dbdcb.SrgbClr, &_fbbbd); _daea != nil {
					return _daea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_dbdcb.HslClr = NewCT_HslColor()
				if _fdbdg := d.DecodeElement(_dbdcb.HslClr, &_fbbbd); _fdbdg != nil {
					return _fdbdg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_dbdcb.SysClr = NewCT_SystemColor()
				if _baaab := d.DecodeElement(_dbdcb.SysClr, &_fbbbd); _baaab != nil {
					return _baaab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_dbdcb.SchemeClr = NewCT_SchemeColor()
				if _gedad := d.DecodeElement(_dbdcb.SchemeClr, &_fbbbd); _gedad != nil {
					return _gedad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_dbdcb.PrstClr = NewCT_PresetColor()
				if _acbca := d.DecodeElement(_dbdcb.PrstClr, &_fbbbd); _acbca != nil {
					return _acbca
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_InnerShadowEffect\u0020\u0025v", _fbbbd.Name)
				if _deag := d.Skip(); _deag != nil {
					return _deag
				}
			}
		case _g.EndElement:
			break _bbag
		case _g.CharData:
		}
	}
	return nil
}
func (_bacab ST_LineEndType) Validate() error { return _bacab.ValidateWithPath("") }

type CT_WholeE2oFormatting struct {
	Ln        *CT_LineProperties
	EffectLst *CT_EffectList
	EffectDag *CT_EffectContainer
}

// ValidateWithPath validates the EG_ThemeableFillStyle and its children, prefixing error messages with path
func (_bbgae *EG_ThemeableFillStyle) ValidateWithPath(path string) error {
	if _bbgae.Fill != nil {
		if _adbae := _bbgae.Fill.ValidateWithPath(path + "\u002fFill"); _adbae != nil {
			return _adbae
		}
	}
	if _bbgae.FillRef != nil {
		if _gdfdff := _bbgae.FillRef.ValidateWithPath(path + "\u002fFillRef"); _gdfdff != nil {
			return _gdfdff
		}
	}
	return nil
}
func (_ceacff ST_OnOffStyleType) String() string {
	switch _ceacff {
	case 0:
		return ""
	case 1:
		return "on"
	case 2:
		return "off"
	case 3:
		return "def"
	}
	return ""
}

// ValidateWithPath validates the CT_TextSpacingPercent and its children, prefixing error messages with path
func (_aaaa *CT_TextSpacingPercent) ValidateWithPath(path string) error {
	if _adbef := _aaaa.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _adbef != nil {
		return _adbef
	}
	return nil
}
func (_gcgbg *EG_TextBulletSize) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gcfagg:
	for {
		_gafba, _gecde := d.Token()
		if _gecde != nil {
			return _gecde
		}
		switch _gggee := _gafba.(type) {
		case _g.StartElement:
			switch _gggee.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buSzTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buSzTx"}:
				_gcgbg.BuSzTx = NewCT_TextBulletSizeFollowText()
				if _gadae := d.DecodeElement(_gcgbg.BuSzTx, &_gggee); _gadae != nil {
					return _gadae
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buSzPct"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buSzPct"}:
				_gcgbg.BuSzPct = NewCT_TextBulletSizePercent()
				if _gfcgf := d.DecodeElement(_gcgbg.BuSzPct, &_gggee); _gfcgf != nil {
					return _gfcgf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buSzPts"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buSzPts"}:
				_gcgbg.BuSzPts = NewCT_TextBulletSizePoint()
				if _edcag := d.DecodeElement(_gcgbg.BuSzPts, &_gggee); _edcag != nil {
					return _edcag
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020EG_TextBulletSize\u0020\u0025v", _gggee.Name)
				if _ccbge := d.Skip(); _ccbge != nil {
					return _ccbge
				}
			}
		case _g.EndElement:
			break _gcfagg
		case _g.CharData:
		}
	}
	return nil
}
func (_cgfga ST_TextUnderlineType) String() string {
	switch _cgfga {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "words"
	case 3:
		return "sng"
	case 4:
		return "dbl"
	case 5:
		return "heavy"
	case 6:
		return "dotted"
	case 7:
		return "dottedHeavy"
	case 8:
		return "dash"
	case 9:
		return "dashHeavy"
	case 10:
		return "dashLong"
	case 11:
		return "dashLongHeavy"
	case 12:
		return "dotDash"
	case 13:
		return "dotDashHeavy"
	case 14:
		return "dotDotDash"
	case 15:
		return "dotDotDashHeavy"
	case 16:
		return "wavy"
	case 17:
		return "wavyHeavy"
	case 18:
		return "wavyDbl"
	}
	return ""
}

// Validate validates the CT_FillOverlayEffect and its children
func (_ccdgd *CT_FillOverlayEffect) Validate() error {
	return _ccdgd.ValidateWithPath("CT_FillOverlayEffect")
}

// Validate validates the CT_Transform2D and its children
func (_cdgeg *CT_Transform2D) Validate() error { return _cdgeg.ValidateWithPath("CT_Transform2D") }
func NewEG_FillProperties() *EG_FillProperties { _fbcbc := &EG_FillProperties{}; return _fbcbc }

// Validate validates the CT_DashStop and its children
func (_fgee *CT_DashStop) Validate() error { return _fgee.ValidateWithPath("CT_DashStop") }
func (_egegd *ST_FontCollectionIndex) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gfdagd, _gbabb := d.Token()
	if _gbabb != nil {
		return _gbabb
	}
	if _ebbgcg, _efadef := _gfdagd.(_g.EndElement); _efadef && _ebbgcg.Name == start.Name {
		*_egegd = 1
		return nil
	}
	if _cafgg, _efafe := _gfdagd.(_g.CharData); !_efafe {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gfdagd)
	} else {
		switch string(_cafgg) {
		case "":
			*_egegd = 0
		case "major":
			*_egegd = 1
		case "minor":
			*_egegd = 2
		case "none":
			*_egegd = 3
		}
	}
	_gfdagd, _gbabb = d.Token()
	if _gbabb != nil {
		return _gbabb
	}
	if _dcbbe, _ebaae := _gfdagd.(_g.EndElement); _ebaae && _dcbbe.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gfdagd)
}
func (_bgdag ST_CompoundLine) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_bgdag.String(), start)
}
func NewCT_TextBulletSizePoint() *CT_TextBulletSizePoint {
	_abgeb := &CT_TextBulletSizePoint{}
	_abgeb.ValAttr = 100
	return _abgeb
}
func (_cagege ST_TextBulletSize) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _cagege.ST_TextBulletSizePercent != nil {
		e.EncodeToken(_g.CharData(*_cagege.ST_TextBulletSizePercent))
	}
	if _cagege.ST_TextBulletSizeDecimal != nil {
		e.EncodeToken(_g.CharData(_dcf.Sprintf("\u0025d", *_cagege.ST_TextBulletSizeDecimal)))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}
func NewCT_BaseStylesOverride() *CT_BaseStylesOverride { _bbe := &CT_BaseStylesOverride{}; return _bbe }

// ValidateWithPath validates the CT_PositiveFixedAngle and its children, prefixing error messages with path
func (_dgeb *CT_PositiveFixedAngle) ValidateWithPath(path string) error {
	if _dgeb.ValAttr < 0 {
		return _dcf.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _dgeb.ValAttr)
	}
	if _dgeb.ValAttr >= 21600000 {
		return _dcf.Errorf("\u0025s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, _dgeb.ValAttr)
	}
	return nil
}
func (_caed *ST_PresetPatternVal) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_caed = 0
	case "pct5":
		*_caed = 1
	case "pct10":
		*_caed = 2
	case "pct20":
		*_caed = 3
	case "pct25":
		*_caed = 4
	case "pct30":
		*_caed = 5
	case "pct40":
		*_caed = 6
	case "pct50":
		*_caed = 7
	case "pct60":
		*_caed = 8
	case "pct70":
		*_caed = 9
	case "pct75":
		*_caed = 10
	case "pct80":
		*_caed = 11
	case "pct90":
		*_caed = 12
	case "horz":
		*_caed = 13
	case "vert":
		*_caed = 14
	case "ltHorz":
		*_caed = 15
	case "ltVert":
		*_caed = 16
	case "dkHorz":
		*_caed = 17
	case "dkVert":
		*_caed = 18
	case "narHorz":
		*_caed = 19
	case "narVert":
		*_caed = 20
	case "dashHorz":
		*_caed = 21
	case "dashVert":
		*_caed = 22
	case "cross":
		*_caed = 23
	case "dnDiag":
		*_caed = 24
	case "upDiag":
		*_caed = 25
	case "ltDnDiag":
		*_caed = 26
	case "ltUpDiag":
		*_caed = 27
	case "dkDnDiag":
		*_caed = 28
	case "dkUpDiag":
		*_caed = 29
	case "wdDnDiag":
		*_caed = 30
	case "wdUpDiag":
		*_caed = 31
	case "dashDnDiag":
		*_caed = 32
	case "dashUpDiag":
		*_caed = 33
	case "diagCross":
		*_caed = 34
	case "smCheck":
		*_caed = 35
	case "lgCheck":
		*_caed = 36
	case "smGrid":
		*_caed = 37
	case "lgGrid":
		*_caed = 38
	case "dotGrid":
		*_caed = 39
	case "smConfetti":
		*_caed = 40
	case "lgConfetti":
		*_caed = 41
	case "horzBrick":
		*_caed = 42
	case "diagBrick":
		*_caed = 43
	case "solidDmnd":
		*_caed = 44
	case "openDmnd":
		*_caed = 45
	case "dotDmnd":
		*_caed = 46
	case "plaid":
		*_caed = 47
	case "sphere":
		*_caed = 48
	case "weave":
		*_caed = 49
	case "divot":
		*_caed = 50
	case "shingle":
		*_caed = 51
	case "wave":
		*_caed = 52
	case "trellis":
		*_caed = 53
	case "zigZag":
		*_caed = 54
	}
	return nil
}
func (_gfedg *ST_PresetCameraType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gabgc, _bdedd := d.Token()
	if _bdedd != nil {
		return _bdedd
	}
	if _gdbad, _ffgdec := _gabgc.(_g.EndElement); _ffgdec && _gdbad.Name == start.Name {
		*_gfedg = 1
		return nil
	}
	if _adeea, _fcabf := _gabgc.(_g.CharData); !_fcabf {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gabgc)
	} else {
		switch string(_adeea) {
		case "":
			*_gfedg = 0
		case "legacyObliqueTopLeft":
			*_gfedg = 1
		case "legacyObliqueTop":
			*_gfedg = 2
		case "legacyObliqueTopRight":
			*_gfedg = 3
		case "legacyObliqueLeft":
			*_gfedg = 4
		case "legacyObliqueFront":
			*_gfedg = 5
		case "legacyObliqueRight":
			*_gfedg = 6
		case "legacyObliqueBottomLeft":
			*_gfedg = 7
		case "legacyObliqueBottom":
			*_gfedg = 8
		case "legacyObliqueBottomRight":
			*_gfedg = 9
		case "legacyPerspectiveTopLeft":
			*_gfedg = 10
		case "legacyPerspectiveTop":
			*_gfedg = 11
		case "legacyPerspectiveTopRight":
			*_gfedg = 12
		case "legacyPerspectiveLeft":
			*_gfedg = 13
		case "legacyPerspectiveFront":
			*_gfedg = 14
		case "legacyPerspectiveRight":
			*_gfedg = 15
		case "legacyPerspectiveBottomLeft":
			*_gfedg = 16
		case "legacyPerspectiveBottom":
			*_gfedg = 17
		case "legacyPerspectiveBottomRight":
			*_gfedg = 18
		case "orthographicFront":
			*_gfedg = 19
		case "isometricTopUp":
			*_gfedg = 20
		case "isometricTopDown":
			*_gfedg = 21
		case "isometricBottomUp":
			*_gfedg = 22
		case "isometricBottomDown":
			*_gfedg = 23
		case "isometricLeftUp":
			*_gfedg = 24
		case "isometricLeftDown":
			*_gfedg = 25
		case "isometricRightUp":
			*_gfedg = 26
		case "isometricRightDown":
			*_gfedg = 27
		case "isometricOffAxis1Left":
			*_gfedg = 28
		case "isometricOffAxis1Right":
			*_gfedg = 29
		case "isometricOffAxis1Top":
			*_gfedg = 30
		case "isometricOffAxis2Left":
			*_gfedg = 31
		case "isometricOffAxis2Right":
			*_gfedg = 32
		case "isometricOffAxis2Top":
			*_gfedg = 33
		case "isometricOffAxis3Left":
			*_gfedg = 34
		case "isometricOffAxis3Right":
			*_gfedg = 35
		case "isometricOffAxis3Bottom":
			*_gfedg = 36
		case "isometricOffAxis4Left":
			*_gfedg = 37
		case "isometricOffAxis4Right":
			*_gfedg = 38
		case "isometricOffAxis4Bottom":
			*_gfedg = 39
		case "obliqueTopLeft":
			*_gfedg = 40
		case "obliqueTop":
			*_gfedg = 41
		case "obliqueTopRight":
			*_gfedg = 42
		case "obliqueLeft":
			*_gfedg = 43
		case "obliqueRight":
			*_gfedg = 44
		case "obliqueBottomLeft":
			*_gfedg = 45
		case "obliqueBottom":
			*_gfedg = 46
		case "obliqueBottomRight":
			*_gfedg = 47
		case "perspectiveFront":
			*_gfedg = 48
		case "perspectiveLeft":
			*_gfedg = 49
		case "perspectiveRight":
			*_gfedg = 50
		case "perspectiveAbove":
			*_gfedg = 51
		case "perspectiveBelow":
			*_gfedg = 52
		case "perspectiveAboveLeftFacing":
			*_gfedg = 53
		case "perspectiveAboveRightFacing":
			*_gfedg = 54
		case "perspectiveContrastingLeftFacing":
			*_gfedg = 55
		case "perspectiveContrastingRightFacing":
			*_gfedg = 56
		case "perspectiveHeroicLeftFacing":
			*_gfedg = 57
		case "perspectiveHeroicRightFacing":
			*_gfedg = 58
		case "perspectiveHeroicExtremeLeftFacing":
			*_gfedg = 59
		case "perspectiveHeroicExtremeRightFacing":
			*_gfedg = 60
		case "perspectiveRelaxed":
			*_gfedg = 61
		case "perspectiveRelaxedModerately":
			*_gfedg = 62
		}
	}
	_gabgc, _bdedd = d.Token()
	if _bdedd != nil {
		return _bdedd
	}
	if _efcde, _faff := _gabgc.(_g.EndElement); _faff && _efcde.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gabgc)
}

// Validate validates the ThemeOverride and its children
func (_daadbf *ThemeOverride) Validate() error { return _daadbf.ValidateWithPath("ThemeOverride") }
func (_dbdaa *CT_QuickTimeFile) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _aeedc := range start.Attr {
		if _aeedc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _aeedc.Name.Local == "link" || _aeedc.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _aeedc.Name.Local == "link" {
			_dfegg, _gbgbaa := _aeedc.Value, error(nil)
			if _gbgbaa != nil {
				return _gbgbaa
			}
			_dbdaa.LinkAttr = _dfegg
			continue
		}
	}
_bageb:
	for {
		_bbegf, _cggfg := d.Token()
		if _cggfg != nil {
			return _cggfg
		}
		switch _faed := _bbegf.(type) {
		case _g.StartElement:
			switch _faed.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_dbdaa.ExtLst = NewCT_OfficeArtExtensionList()
				if _abaa := d.DecodeElement(_dbdaa.ExtLst, &_faed); _abaa != nil {
					return _abaa
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_QuickTimeFile\u0020\u0025v", _faed.Name)
				if _abcbe := d.Skip(); _abcbe != nil {
					return _abcbe
				}
			}
		case _g.EndElement:
			break _bageb
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_AlphaReplaceEffect and its children
func (_dgad *CT_AlphaReplaceEffect) Validate() error {
	return _dgad.ValidateWithPath("CT_AlphaReplaceEffect")
}

// Validate validates the CT_PatternFillProperties and its children
func (_fbafc *CT_PatternFillProperties) Validate() error {
	return _fbafc.ValidateWithPath("CT_PatternFillProperties")
}

// Validate validates the CT_VideoFile and its children
func (_gfbff *CT_VideoFile) Validate() error { return _gfbff.ValidateWithPath("CT_VideoFile") }

// ValidateWithPath validates the CT_EmptyElement and its children, prefixing error messages with path
func (_badb *CT_EmptyElement) ValidateWithPath(path string) error { return nil }
func NewCT_AlphaFloorEffect() *CT_AlphaFloorEffect                { _edf := &CT_AlphaFloorEffect{}; return _edf }

const (
	ST_LineCapUnset ST_LineCap = 0
	ST_LineCapRnd   ST_LineCap = 1
	ST_LineCapSq    ST_LineCap = 2
	ST_LineCapFlat  ST_LineCap = 3
)

func NewCT_LineProperties() *CT_LineProperties { _dcaa := &CT_LineProperties{}; return _dcaa }

type CT_NonVisualConnectorProperties struct {
	CxnSpLocks *CT_ConnectorLocking
	StCxn      *CT_Connection
	EndCxn     *CT_Connection
	ExtLst     *CT_OfficeArtExtensionList
}

// Validate validates the CT_TablePartStyle and its children
func (_cgeee *CT_TablePartStyle) Validate() error {
	return _cgeee.ValidateWithPath("CT_TablePartStyle")
}
func (_fdadd *CT_TextTabStop) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fdadd.PosAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "pos"}, Value: _dcf.Sprintf("\u0025v", *_fdadd.PosAttr)})
	}
	if _fdadd.AlgnAttr != ST_TextTabAlignTypeUnset {
		_bcfafa, _bcfdb := _fdadd.AlgnAttr.MarshalXMLAttr(_g.Name{Local: "algn"})
		if _bcfdb != nil {
			return _bcfdb
		}
		start.Attr = append(start.Attr, _bcfafa)
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

const (
	ST_TileFlipModeUnset ST_TileFlipMode = 0
	ST_TileFlipModeNone  ST_TileFlipMode = 1
	ST_TileFlipModeX     ST_TileFlipMode = 2
	ST_TileFlipModeY     ST_TileFlipMode = 3
	ST_TileFlipModeXy    ST_TileFlipMode = 4
)

func (_dadfd ST_BlackWhiteMode) ValidateWithPath(path string) error {
	switch _dadfd {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dadfd))
	}
	return nil
}
func NewCT_FlatText() *CT_FlatText { _fbed := &CT_FlatText{}; return _fbed }
func (_agfgb ST_TextTabAlignType) ValidateWithPath(path string) error {
	switch _agfgb {
	case 0, 1, 2, 3, 4:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_agfgb))
	}
	return nil
}

// ValidateWithPath validates the CT_FillStyleList and its children, prefixing error messages with path
func (_adgfb *CT_FillStyleList) ValidateWithPath(path string) error {
	for _gdbc, _fcbgc := range _adgfb.EG_FillProperties {
		if _eafb := _fcbgc.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fEG_FillProperties\u005b\u0025d\u005d", path, _gdbc)); _eafb != nil {
			return _eafb
		}
	}
	return nil
}

type CT_TileInfoProperties struct {
	TxAttr   *ST_Coordinate
	TyAttr   *ST_Coordinate
	SxAttr   *ST_Percentage
	SyAttr   *ST_Percentage
	FlipAttr ST_TileFlipMode
	AlgnAttr ST_RectAlignment
}

// Validate validates the CT_GeomRect and its children
func (_cbgdg *CT_GeomRect) Validate() error { return _cbgdg.ValidateWithPath("CT_GeomRect") }
func (_fafc *CT_BackgroundFillStyleList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	for _, _cdd := range _fafc.EG_FillProperties {
		_cdd.MarshalXML(e, _g.StartElement{})
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_Transform2D struct {
	RotAttr   *int32
	FlipHAttr *bool
	FlipVAttr *bool
	Off       *CT_Point2D
	Ext       *CT_PositiveSize2D
}

// ValidateWithPath validates the CT_Color and its children, prefixing error messages with path
func (_ddaef *CT_Color) ValidateWithPath(path string) error {
	if _ddaef.ScrgbClr != nil {
		if _cade := _ddaef.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _cade != nil {
			return _cade
		}
	}
	if _ddaef.SrgbClr != nil {
		if _eggf := _ddaef.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _eggf != nil {
			return _eggf
		}
	}
	if _ddaef.HslClr != nil {
		if _ddca := _ddaef.HslClr.ValidateWithPath(path + "\u002fHslClr"); _ddca != nil {
			return _ddca
		}
	}
	if _ddaef.SysClr != nil {
		if _bafg := _ddaef.SysClr.ValidateWithPath(path + "\u002fSysClr"); _bafg != nil {
			return _bafg
		}
	}
	if _ddaef.SchemeClr != nil {
		if _fcbb := _ddaef.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _fcbb != nil {
			return _fcbb
		}
	}
	if _ddaef.PrstClr != nil {
		if _gace := _ddaef.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _gace != nil {
			return _gace
		}
	}
	return nil
}

// Validate validates the CT_NonVisualDrawingProps and its children
func (_adga *CT_NonVisualDrawingProps) Validate() error {
	return _adga.ValidateWithPath("CT_NonVisualDrawingProps")
}

const (
	ST_PresetCameraTypeUnset                               ST_PresetCameraType = 0
	ST_PresetCameraTypeLegacyObliqueTopLeft                ST_PresetCameraType = 1
	ST_PresetCameraTypeLegacyObliqueTop                    ST_PresetCameraType = 2
	ST_PresetCameraTypeLegacyObliqueTopRight               ST_PresetCameraType = 3
	ST_PresetCameraTypeLegacyObliqueLeft                   ST_PresetCameraType = 4
	ST_PresetCameraTypeLegacyObliqueFront                  ST_PresetCameraType = 5
	ST_PresetCameraTypeLegacyObliqueRight                  ST_PresetCameraType = 6
	ST_PresetCameraTypeLegacyObliqueBottomLeft             ST_PresetCameraType = 7
	ST_PresetCameraTypeLegacyObliqueBottom                 ST_PresetCameraType = 8
	ST_PresetCameraTypeLegacyObliqueBottomRight            ST_PresetCameraType = 9
	ST_PresetCameraTypeLegacyPerspectiveTopLeft            ST_PresetCameraType = 10
	ST_PresetCameraTypeLegacyPerspectiveTop                ST_PresetCameraType = 11
	ST_PresetCameraTypeLegacyPerspectiveTopRight           ST_PresetCameraType = 12
	ST_PresetCameraTypeLegacyPerspectiveLeft               ST_PresetCameraType = 13
	ST_PresetCameraTypeLegacyPerspectiveFront              ST_PresetCameraType = 14
	ST_PresetCameraTypeLegacyPerspectiveRight              ST_PresetCameraType = 15
	ST_PresetCameraTypeLegacyPerspectiveBottomLeft         ST_PresetCameraType = 16
	ST_PresetCameraTypeLegacyPerspectiveBottom             ST_PresetCameraType = 17
	ST_PresetCameraTypeLegacyPerspectiveBottomRight        ST_PresetCameraType = 18
	ST_PresetCameraTypeOrthographicFront                   ST_PresetCameraType = 19
	ST_PresetCameraTypeIsometricTopUp                      ST_PresetCameraType = 20
	ST_PresetCameraTypeIsometricTopDown                    ST_PresetCameraType = 21
	ST_PresetCameraTypeIsometricBottomUp                   ST_PresetCameraType = 22
	ST_PresetCameraTypeIsometricBottomDown                 ST_PresetCameraType = 23
	ST_PresetCameraTypeIsometricLeftUp                     ST_PresetCameraType = 24
	ST_PresetCameraTypeIsometricLeftDown                   ST_PresetCameraType = 25
	ST_PresetCameraTypeIsometricRightUp                    ST_PresetCameraType = 26
	ST_PresetCameraTypeIsometricRightDown                  ST_PresetCameraType = 27
	ST_PresetCameraTypeIsometricOffAxis1Left               ST_PresetCameraType = 28
	ST_PresetCameraTypeIsometricOffAxis1Right              ST_PresetCameraType = 29
	ST_PresetCameraTypeIsometricOffAxis1Top                ST_PresetCameraType = 30
	ST_PresetCameraTypeIsometricOffAxis2Left               ST_PresetCameraType = 31
	ST_PresetCameraTypeIsometricOffAxis2Right              ST_PresetCameraType = 32
	ST_PresetCameraTypeIsometricOffAxis2Top                ST_PresetCameraType = 33
	ST_PresetCameraTypeIsometricOffAxis3Left               ST_PresetCameraType = 34
	ST_PresetCameraTypeIsometricOffAxis3Right              ST_PresetCameraType = 35
	ST_PresetCameraTypeIsometricOffAxis3Bottom             ST_PresetCameraType = 36
	ST_PresetCameraTypeIsometricOffAxis4Left               ST_PresetCameraType = 37
	ST_PresetCameraTypeIsometricOffAxis4Right              ST_PresetCameraType = 38
	ST_PresetCameraTypeIsometricOffAxis4Bottom             ST_PresetCameraType = 39
	ST_PresetCameraTypeObliqueTopLeft                      ST_PresetCameraType = 40
	ST_PresetCameraTypeObliqueTop                          ST_PresetCameraType = 41
	ST_PresetCameraTypeObliqueTopRight                     ST_PresetCameraType = 42
	ST_PresetCameraTypeObliqueLeft                         ST_PresetCameraType = 43
	ST_PresetCameraTypeObliqueRight                        ST_PresetCameraType = 44
	ST_PresetCameraTypeObliqueBottomLeft                   ST_PresetCameraType = 45
	ST_PresetCameraTypeObliqueBottom                       ST_PresetCameraType = 46
	ST_PresetCameraTypeObliqueBottomRight                  ST_PresetCameraType = 47
	ST_PresetCameraTypePerspectiveFront                    ST_PresetCameraType = 48
	ST_PresetCameraTypePerspectiveLeft                     ST_PresetCameraType = 49
	ST_PresetCameraTypePerspectiveRight                    ST_PresetCameraType = 50
	ST_PresetCameraTypePerspectiveAbove                    ST_PresetCameraType = 51
	ST_PresetCameraTypePerspectiveBelow                    ST_PresetCameraType = 52
	ST_PresetCameraTypePerspectiveAboveLeftFacing          ST_PresetCameraType = 53
	ST_PresetCameraTypePerspectiveAboveRightFacing         ST_PresetCameraType = 54
	ST_PresetCameraTypePerspectiveContrastingLeftFacing    ST_PresetCameraType = 55
	ST_PresetCameraTypePerspectiveContrastingRightFacing   ST_PresetCameraType = 56
	ST_PresetCameraTypePerspectiveHeroicLeftFacing         ST_PresetCameraType = 57
	ST_PresetCameraTypePerspectiveHeroicRightFacing        ST_PresetCameraType = 58
	ST_PresetCameraTypePerspectiveHeroicExtremeLeftFacing  ST_PresetCameraType = 59
	ST_PresetCameraTypePerspectiveHeroicExtremeRightFacing ST_PresetCameraType = 60
	ST_PresetCameraTypePerspectiveRelaxed                  ST_PresetCameraType = 61
	ST_PresetCameraTypePerspectiveRelaxedModerately        ST_PresetCameraType = 62
)

func (_gddaa *CT_GeomGuideList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fbf:
	for {
		_fdcd, _fcbcg := d.Token()
		if _fcbcg != nil {
			return _fcbcg
		}
		switch _gbdad := _fdcd.(type) {
		case _g.StartElement:
			switch _gbdad.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gd"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gd"}:
				_dgaa := NewCT_GeomGuide()
				if _fbgec := d.DecodeElement(_dgaa, &_gbdad); _fbgec != nil {
					return _fbgec
				}
				_gddaa.Gd = append(_gddaa.Gd, _dgaa)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GeomGuideList\u0020\u0025v", _gbdad.Name)
				if _eafe := d.Skip(); _eafe != nil {
					return _eafe
				}
			}
		case _g.EndElement:
			break _fbf
		case _g.CharData:
		}
	}
	return nil
}
func (_fgbg *CT_ColorMRU) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _fgbg.EG_ColorChoice != nil {
		for _, _dafb := range _fgbg.EG_ColorChoice {
			_dafb.MarshalXML(e, _g.StartElement{})
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_Scale2D struct {
	Sx *CT_Ratio
	Sy *CT_Ratio
}

// ValidateWithPath validates the CT_TextField and its children, prefixing error messages with path
func (_cabcfa *CT_TextField) ValidateWithPath(path string) error {
	if !_f.ST_GuidPatternRe.MatchString(_cabcfa.IdAttr) {
		return _dcf.Errorf("\u0025s/m\u002eIdAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _f.ST_GuidPatternRe, _cabcfa.IdAttr)
	}
	if _cabcfa.RPr != nil {
		if _dcade := _cabcfa.RPr.ValidateWithPath(path + "\u002fRPr"); _dcade != nil {
			return _dcade
		}
	}
	if _cabcfa.PPr != nil {
		if _cgbce := _cabcfa.PPr.ValidateWithPath(path + "\u002fPPr"); _cgbce != nil {
			return _cgbce
		}
	}
	return nil
}
func (_ecggfd ST_PresetColorVal) ValidateWithPath(path string) error {
	switch _ecggfd {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ecggfd))
	}
	return nil
}
func (_fab *Blip) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fab.CT_Blip = *NewCT_Blip()
	for _, _gbd := range start.Attr {
		if _gbd.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _gbd.Name.Local == "embed" {
			_de, _ed := _gbd.Value, error(nil)
			if _ed != nil {
				return _ed
			}
			_fab.EmbedAttr = &_de
			continue
		}
		if _gbd.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _gbd.Name.Local == "link" {
			_af, _aaf := _gbd.Value, error(nil)
			if _aaf != nil {
				return _aaf
			}
			_fab.LinkAttr = &_af
			continue
		}
		if _gbd.Name.Local == "cstate" {
			_fab.CstateAttr.UnmarshalXMLAttr(_gbd)
			continue
		}
	}
_cca:
	for {
		_gba, _cba := d.Token()
		if _cba != nil {
			return _cba
		}
		switch _bae := _gba.(type) {
		case _g.StartElement:
			switch _bae.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaBiLevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaBiLevel"}:
				_dde := NewCT_BlipChoice()
				if _dcg := d.DecodeElement(&_dde.AlphaBiLevel, &_bae); _dcg != nil {
					return _dcg
				}
				_fab.Choice = append(_fab.Choice, _dde)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaCeiling"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaCeiling"}:
				_aeb := NewCT_BlipChoice()
				if _cgg := d.DecodeElement(&_aeb.AlphaCeiling, &_bae); _cgg != nil {
					return _cgg
				}
				_fab.Choice = append(_fab.Choice, _aeb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaFloor"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaFloor"}:
				_bcg := NewCT_BlipChoice()
				if _bfa := d.DecodeElement(&_bcg.AlphaFloor, &_bae); _bfa != nil {
					return _bfa
				}
				_fab.Choice = append(_fab.Choice, _bcg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaInv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaInv"}:
				_ddb := NewCT_BlipChoice()
				if _ddbg := d.DecodeElement(&_ddb.AlphaInv, &_bae); _ddbg != nil {
					return _ddbg
				}
				_fab.Choice = append(_fab.Choice, _ddb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_cgb := NewCT_BlipChoice()
				if _edd := d.DecodeElement(&_cgb.AlphaMod, &_bae); _edd != nil {
					return _edd
				}
				_fab.Choice = append(_fab.Choice, _cgb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaModFix"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaModFix"}:
				_bcgc := NewCT_BlipChoice()
				if _gbdg := d.DecodeElement(&_bcgc.AlphaModFix, &_bae); _gbdg != nil {
					return _gbdg
				}
				_fab.Choice = append(_fab.Choice, _bcgc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaRepl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaRepl"}:
				_bcd := NewCT_BlipChoice()
				if _cce := d.DecodeElement(&_bcd.AlphaRepl, &_bae); _cce != nil {
					return _cce
				}
				_fab.Choice = append(_fab.Choice, _bcd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "biLevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "biLevel"}:
				_afe := NewCT_BlipChoice()
				if _aeg := d.DecodeElement(&_afe.BiLevel, &_bae); _aeg != nil {
					return _aeg
				}
				_fab.Choice = append(_fab.Choice, _afe)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blur"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blur"}:
				_egd := NewCT_BlipChoice()
				if _ccf := d.DecodeElement(&_egd.Blur, &_bae); _ccf != nil {
					return _ccf
				}
				_fab.Choice = append(_fab.Choice, _egd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrChange"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrChange"}:
				_dab := NewCT_BlipChoice()
				if _cbc := d.DecodeElement(&_dab.ClrChange, &_bae); _cbc != nil {
					return _cbc
				}
				_fab.Choice = append(_fab.Choice, _dab)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrRepl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrRepl"}:
				_gee := NewCT_BlipChoice()
				if _bd := d.DecodeElement(&_gee.ClrRepl, &_bae); _bd != nil {
					return _bd
				}
				_fab.Choice = append(_fab.Choice, _gee)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "duotone"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "duotone"}:
				_ec := NewCT_BlipChoice()
				if _egb := d.DecodeElement(&_ec.Duotone, &_bae); _egb != nil {
					return _egb
				}
				_fab.Choice = append(_fab.Choice, _ec)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillOverlay"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillOverlay"}:
				_dec := NewCT_BlipChoice()
				if _ebe := d.DecodeElement(&_dec.FillOverlay, &_bae); _ebe != nil {
					return _ebe
				}
				_fab.Choice = append(_fab.Choice, _dec)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grayscl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grayscl"}:
				_ag := NewCT_BlipChoice()
				if _ga := d.DecodeElement(&_ag.Grayscl, &_bae); _ga != nil {
					return _ga
				}
				_fab.Choice = append(_fab.Choice, _ag)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hsl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hsl"}:
				_bgd := NewCT_BlipChoice()
				if _fabc := d.DecodeElement(&_bgd.Hsl, &_bae); _fabc != nil {
					return _fabc
				}
				_fab.Choice = append(_fab.Choice, _bgd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_feg := NewCT_BlipChoice()
				if _gcb := d.DecodeElement(&_feg.Lum, &_bae); _gcb != nil {
					return _gcb
				}
				_fab.Choice = append(_fab.Choice, _feg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_cgf := NewCT_BlipChoice()
				if _gbc := d.DecodeElement(&_cgf.Tint, &_bae); _gbc != nil {
					return _gbc
				}
				_fab.Choice = append(_fab.Choice, _cgf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_fab.ExtLst = NewCT_OfficeArtExtensionList()
				if _abc := d.DecodeElement(_fab.ExtLst, &_bae); _abc != nil {
					return _abc
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020Blip\u0020\u0025v", _bae.Name)
				if _dbb := d.Skip(); _dbb != nil {
					return _dbb
				}
			}
		case _g.EndElement:
			break _cca
		case _g.CharData:
		}
	}
	return nil
}
func (_ecgca ST_BlackWhiteMode) String() string {
	switch _ecgca {
	case 0:
		return ""
	case 1:
		return "clr"
	case 2:
		return "auto"
	case 3:
		return "gray"
	case 4:
		return "ltGray"
	case 5:
		return "invGray"
	case 6:
		return "grayWhite"
	case 7:
		return "blackGray"
	case 8:
		return "blackWhite"
	case 9:
		return "black"
	case 10:
		return "white"
	case 11:
		return "hidden"
	}
	return ""
}

// Validate validates the EG_TextUnderlineFill and its children
func (_cdbg *EG_TextUnderlineFill) Validate() error {
	return _cdbg.ValidateWithPath("EG_TextUnderlineFill")
}
func (_acfacd ST_TextAutonumberScheme) ValidateWithPath(path string) error {
	switch _acfacd {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_acfacd))
	}
	return nil
}

type EG_EffectProperties struct {
	EffectLst *CT_EffectList
	EffectDag *CT_EffectContainer
}

// ValidateWithPath validates the CT_ColorMapping and its children, prefixing error messages with path
func (_feeg *CT_ColorMapping) ValidateWithPath(path string) error {
	if _feeg.Bg1Attr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("\u0025s\u002fBg1Attr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _ebfb := _feeg.Bg1Attr.ValidateWithPath(path + "\u002fBg1Attr"); _ebfb != nil {
		return _ebfb
	}
	if _feeg.Tx1Attr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("\u0025s\u002fTx1Attr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _beag := _feeg.Tx1Attr.ValidateWithPath(path + "\u002fTx1Attr"); _beag != nil {
		return _beag
	}
	if _feeg.Bg2Attr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("\u0025s\u002fBg2Attr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bfgc := _feeg.Bg2Attr.ValidateWithPath(path + "\u002fBg2Attr"); _bfgc != nil {
		return _bfgc
	}
	if _feeg.Tx2Attr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("\u0025s\u002fTx2Attr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _dfge := _feeg.Tx2Attr.ValidateWithPath(path + "\u002fTx2Attr"); _dfge != nil {
		return _dfge
	}
	if _feeg.Accent1Attr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("%s\u002fAccent1Attr is\u0020a\u0020mandatory\u0020field", path)
	}
	if _abbf := _feeg.Accent1Attr.ValidateWithPath(path + "\u002fAccent1Attr"); _abbf != nil {
		return _abbf
	}
	if _feeg.Accent2Attr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("%s\u002fAccent2Attr is\u0020a\u0020mandatory\u0020field", path)
	}
	if _fgg := _feeg.Accent2Attr.ValidateWithPath(path + "\u002fAccent2Attr"); _fgg != nil {
		return _fgg
	}
	if _feeg.Accent3Attr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("%s\u002fAccent3Attr is\u0020a\u0020mandatory\u0020field", path)
	}
	if _ffab := _feeg.Accent3Attr.ValidateWithPath(path + "\u002fAccent3Attr"); _ffab != nil {
		return _ffab
	}
	if _feeg.Accent4Attr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("%s\u002fAccent4Attr is\u0020a\u0020mandatory\u0020field", path)
	}
	if _gdff := _feeg.Accent4Attr.ValidateWithPath(path + "\u002fAccent4Attr"); _gdff != nil {
		return _gdff
	}
	if _feeg.Accent5Attr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("%s\u002fAccent5Attr is\u0020a\u0020mandatory\u0020field", path)
	}
	if _fffg := _feeg.Accent5Attr.ValidateWithPath(path + "\u002fAccent5Attr"); _fffg != nil {
		return _fffg
	}
	if _feeg.Accent6Attr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("%s\u002fAccent6Attr is\u0020a\u0020mandatory\u0020field", path)
	}
	if _baa := _feeg.Accent6Attr.ValidateWithPath(path + "\u002fAccent6Attr"); _baa != nil {
		return _baa
	}
	if _feeg.HlinkAttr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("\u0025s\u002fHlinkAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _caga := _feeg.HlinkAttr.ValidateWithPath(path + "\u002fHlinkAttr"); _caga != nil {
		return _caga
	}
	if _feeg.FolHlinkAttr == ST_ColorSchemeIndexUnset {
		return _dcf.Errorf("\u0025s/FolHlinkAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _aafb := _feeg.FolHlinkAttr.ValidateWithPath(path + "\u002fFolHlinkAttr"); _aafb != nil {
		return _aafb
	}
	if _feeg.ExtLst != nil {
		if _fcba := _feeg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fcba != nil {
			return _fcba
		}
	}
	return nil
}
func (_dacgb *EG_TextBullet) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_cdbce:
	for {
		_cbfdc, _egfdae := d.Token()
		if _egfdae != nil {
			return _egfdae
		}
		switch _bbdac := _cbfdc.(type) {
		case _g.StartElement:
			switch _bbdac.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buNone"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buNone"}:
				_dacgb.BuNone = NewCT_TextNoBullet()
				if _ffcf := d.DecodeElement(_dacgb.BuNone, &_bbdac); _ffcf != nil {
					return _ffcf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buAutoNum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buAutoNum"}:
				_dacgb.BuAutoNum = NewCT_TextAutonumberBullet()
				if _geacfd := d.DecodeElement(_dacgb.BuAutoNum, &_bbdac); _geacfd != nil {
					return _geacfd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buChar"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buChar"}:
				_dacgb.BuChar = NewCT_TextCharBullet()
				if _dggfec := d.DecodeElement(_dacgb.BuChar, &_bbdac); _dggfec != nil {
					return _dggfec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "buBlip"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "buBlip"}:
				_dacgb.BuBlip = NewCT_TextBlipBullet()
				if _gfcbgg := d.DecodeElement(_dacgb.BuBlip, &_bbdac); _gfcbgg != nil {
					return _gfcbgg
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020EG_TextBullet \u0025v", _bbdac.Name)
				if _aaedcf := d.Skip(); _aaedcf != nil {
					return _aaedcf
				}
			}
		case _g.EndElement:
			break _cdbce
		case _g.CharData:
		}
	}
	return nil
}

type CT_SupplementalFont struct {
	ScriptAttr   string
	TypefaceAttr string
}

func (_dbcc *CT_ColorMappingOverride) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_dbcc.Choice.MarshalXML(e, _g.StartElement{})
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_fegfc ST_Coordinate32) String() string {
	if _fegfc.ST_Coordinate32Unqualified != nil {
		return _dcf.Sprintf("\u0025v", *_fegfc.ST_Coordinate32Unqualified)
	}
	if _fegfc.ST_UniversalMeasure != nil {
		return _dcf.Sprintf("\u0025v", *_fegfc.ST_UniversalMeasure)
	}
	return ""
}
func (_dcgd *CT_AlphaReplaceEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "a"}, Value: _dcf.Sprintf("\u0025v", _dcgd.AAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_EffectList and its children
func (_gcgg *CT_EffectList) Validate() error { return _gcgg.ValidateWithPath("CT_EffectList") }
func (_cceae *EG_TextAutofit) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fbgeag:
	for {
		_ccfae, _dbdfd := d.Token()
		if _dbdfd != nil {
			return _dbdfd
		}
		switch _gbgcdf := _ccfae.(type) {
		case _g.StartElement:
			switch _gbgcdf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noAutofit"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noAutofit"}:
				_cceae.NoAutofit = NewCT_TextNoAutofit()
				if _gbgee := d.DecodeElement(_cceae.NoAutofit, &_gbgcdf); _gbgee != nil {
					return _gbgee
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "normAutofit"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "normAutofit"}:
				_cceae.NormAutofit = NewCT_TextNormalAutofit()
				if _efbeb := d.DecodeElement(_cceae.NormAutofit, &_gbgcdf); _efbeb != nil {
					return _efbeb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spAutoFit"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spAutoFit"}:
				_cceae.SpAutoFit = NewCT_TextShapeAutofit()
				if _edcac := d.DecodeElement(_cceae.SpAutoFit, &_gbgcdf); _edcac != nil {
					return _edcac
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_TextAutofit\u0020\u0025v", _gbgcdf.Name)
				if _ffgfg := d.Skip(); _ffgfg != nil {
					return _ffgfg
				}
			}
		case _g.EndElement:
			break _fbgeag
		case _g.CharData:
		}
	}
	return nil
}
func (_adbb *CT_EffectContainer) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _adbb.TypeAttr != ST_EffectContainerTypeUnset {
		_afafd, _dfacf := _adbb.TypeAttr.MarshalXMLAttr(_g.Name{Local: "type"})
		if _dfacf != nil {
			return _dfacf
		}
		start.Attr = append(start.Attr, _afafd)
	}
	if _adbb.NameAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "name"}, Value: _dcf.Sprintf("\u0025v", *_adbb.NameAttr)})
	}
	e.EncodeToken(start)
	if _adbb.Cont != nil {
		_eeadf := _g.StartElement{Name: _g.Name{Local: "a:cont"}}
		e.EncodeElement(_adbb.Cont, _eeadf)
	}
	if _adbb.Effect != nil {
		_acef := _g.StartElement{Name: _g.Name{Local: "a:effect"}}
		e.EncodeElement(_adbb.Effect, _acef)
	}
	if _adbb.AlphaBiLevel != nil {
		_gefb := _g.StartElement{Name: _g.Name{Local: "a:alphaBiLevel"}}
		e.EncodeElement(_adbb.AlphaBiLevel, _gefb)
	}
	if _adbb.AlphaCeiling != nil {
		_efbce := _g.StartElement{Name: _g.Name{Local: "a:alphaCeiling"}}
		e.EncodeElement(_adbb.AlphaCeiling, _efbce)
	}
	if _adbb.AlphaFloor != nil {
		_dcag := _g.StartElement{Name: _g.Name{Local: "a:alphaFloor"}}
		e.EncodeElement(_adbb.AlphaFloor, _dcag)
	}
	if _adbb.AlphaInv != nil {
		_badfc := _g.StartElement{Name: _g.Name{Local: "a:alphaInv"}}
		e.EncodeElement(_adbb.AlphaInv, _badfc)
	}
	if _adbb.AlphaMod != nil {
		_fbge := _g.StartElement{Name: _g.Name{Local: "a:alphaMod"}}
		e.EncodeElement(_adbb.AlphaMod, _fbge)
	}
	if _adbb.AlphaModFix != nil {
		_bbcc := _g.StartElement{Name: _g.Name{Local: "a:alphaModFix"}}
		e.EncodeElement(_adbb.AlphaModFix, _bbcc)
	}
	if _adbb.AlphaOutset != nil {
		_ecgb := _g.StartElement{Name: _g.Name{Local: "a:alphaOutset"}}
		e.EncodeElement(_adbb.AlphaOutset, _ecgb)
	}
	if _adbb.AlphaRepl != nil {
		_efgae := _g.StartElement{Name: _g.Name{Local: "a:alphaRepl"}}
		e.EncodeElement(_adbb.AlphaRepl, _efgae)
	}
	if _adbb.BiLevel != nil {
		_cbgg := _g.StartElement{Name: _g.Name{Local: "a:biLevel"}}
		e.EncodeElement(_adbb.BiLevel, _cbgg)
	}
	if _adbb.Blend != nil {
		_bfef := _g.StartElement{Name: _g.Name{Local: "a:blend"}}
		e.EncodeElement(_adbb.Blend, _bfef)
	}
	if _adbb.Blur != nil {
		_abecc := _g.StartElement{Name: _g.Name{Local: "a:blur"}}
		e.EncodeElement(_adbb.Blur, _abecc)
	}
	if _adbb.ClrChange != nil {
		_egef := _g.StartElement{Name: _g.Name{Local: "a:clrChange"}}
		e.EncodeElement(_adbb.ClrChange, _egef)
	}
	if _adbb.ClrRepl != nil {
		_acfd := _g.StartElement{Name: _g.Name{Local: "a:clrRepl"}}
		e.EncodeElement(_adbb.ClrRepl, _acfd)
	}
	if _adbb.Duotone != nil {
		_edcec := _g.StartElement{Name: _g.Name{Local: "a:duotone"}}
		e.EncodeElement(_adbb.Duotone, _edcec)
	}
	if _adbb.Fill != nil {
		_edff := _g.StartElement{Name: _g.Name{Local: "a:fill"}}
		e.EncodeElement(_adbb.Fill, _edff)
	}
	if _adbb.FillOverlay != nil {
		_cfbd := _g.StartElement{Name: _g.Name{Local: "a:fillOverlay"}}
		e.EncodeElement(_adbb.FillOverlay, _cfbd)
	}
	if _adbb.Glow != nil {
		_acgae := _g.StartElement{Name: _g.Name{Local: "a:glow"}}
		e.EncodeElement(_adbb.Glow, _acgae)
	}
	if _adbb.Grayscl != nil {
		_feaf := _g.StartElement{Name: _g.Name{Local: "a:grayscl"}}
		e.EncodeElement(_adbb.Grayscl, _feaf)
	}
	if _adbb.Hsl != nil {
		_gbedgb := _g.StartElement{Name: _g.Name{Local: "a:hsl"}}
		e.EncodeElement(_adbb.Hsl, _gbedgb)
	}
	if _adbb.InnerShdw != nil {
		_dfgf := _g.StartElement{Name: _g.Name{Local: "a:innerShdw"}}
		e.EncodeElement(_adbb.InnerShdw, _dfgf)
	}
	if _adbb.Lum != nil {
		_aaedb := _g.StartElement{Name: _g.Name{Local: "a:lum"}}
		e.EncodeElement(_adbb.Lum, _aaedb)
	}
	if _adbb.OuterShdw != nil {
		_gcdag := _g.StartElement{Name: _g.Name{Local: "a:outerShdw"}}
		e.EncodeElement(_adbb.OuterShdw, _gcdag)
	}
	if _adbb.PrstShdw != nil {
		_gfag := _g.StartElement{Name: _g.Name{Local: "a:prstShdw"}}
		e.EncodeElement(_adbb.PrstShdw, _gfag)
	}
	if _adbb.Reflection != nil {
		_efcg := _g.StartElement{Name: _g.Name{Local: "a:reflection"}}
		e.EncodeElement(_adbb.Reflection, _efcg)
	}
	if _adbb.RelOff != nil {
		_gfggf := _g.StartElement{Name: _g.Name{Local: "a:relOff"}}
		e.EncodeElement(_adbb.RelOff, _gfggf)
	}
	if _adbb.SoftEdge != nil {
		_cbag := _g.StartElement{Name: _g.Name{Local: "a:softEdge"}}
		e.EncodeElement(_adbb.SoftEdge, _cbag)
	}
	if _adbb.Tint != nil {
		_gefgf := _g.StartElement{Name: _g.Name{Local: "a:tint"}}
		e.EncodeElement(_adbb.Tint, _gefgf)
	}
	if _adbb.Xfrm != nil {
		_egdgd := _g.StartElement{Name: _g.Name{Local: "a:xfrm"}}
		e.EncodeElement(_adbb.Xfrm, _egdgd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_fbcccd *ST_TextWrappingType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_facceb, _fagbgf := d.Token()
	if _fagbgf != nil {
		return _fagbgf
	}
	if _aeabdd, _fcfbf := _facceb.(_g.EndElement); _fcfbf && _aeabdd.Name == start.Name {
		*_fbcccd = 1
		return nil
	}
	if _dabdb, _ecaac := _facceb.(_g.CharData); !_ecaac {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _facceb)
	} else {
		switch string(_dabdb) {
		case "":
			*_fbcccd = 0
		case "none":
			*_fbcccd = 1
		case "square":
			*_fbcccd = 2
		}
	}
	_facceb, _fagbgf = d.Token()
	if _fagbgf != nil {
		return _fagbgf
	}
	if _edagfe, _geceaa := _facceb.(_g.EndElement); _geceaa && _edagfe.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _facceb)
}
func NewCT_GeomRect() *CT_GeomRect               { _bddef := &CT_GeomRect{}; return _bddef }
func NewEG_ShadeProperties() *EG_ShadeProperties { _ddfee := &EG_ShadeProperties{}; return _ddfee }

type CT_TextTabStop struct {
	PosAttr  *ST_Coordinate32
	AlgnAttr ST_TextTabAlignType
}
type CT_Blip struct {
	CstateAttr ST_BlipCompression
	Choice     []*CT_BlipChoice
	ExtLst     *CT_OfficeArtExtensionList
	EmbedAttr  *string
	LinkAttr   *string
}

func (_dddff *CT_PictureLocking) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dddff.NoCropAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noCrop"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dddff.NoCropAttr))})
	}
	if _dddff.NoGrpAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noGrp"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dddff.NoGrpAttr))})
	}
	if _dddff.NoSelectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noSelect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dddff.NoSelectAttr))})
	}
	if _dddff.NoRotAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noRot"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dddff.NoRotAttr))})
	}
	if _dddff.NoChangeAspectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeAspect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dddff.NoChangeAspectAttr))})
	}
	if _dddff.NoMoveAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noMove"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dddff.NoMoveAttr))})
	}
	if _dddff.NoResizeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noResize"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dddff.NoResizeAttr))})
	}
	if _dddff.NoEditPointsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noEditPoints"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dddff.NoEditPointsAttr))})
	}
	if _dddff.NoAdjustHandlesAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noAdjustHandles"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dddff.NoAdjustHandlesAttr))})
	}
	if _dddff.NoChangeArrowheadsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeArrowheads"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dddff.NoChangeArrowheadsAttr))})
	}
	if _dddff.NoChangeShapeTypeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeShapeType"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dddff.NoChangeShapeTypeAttr))})
	}
	e.EncodeToken(start)
	if _dddff.ExtLst != nil {
		_dbgec := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dddff.ExtLst, _dbgec)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func ParseUnionST_AdjAngle(s string) (ST_AdjAngle, error) {
	_eeeg := ST_AdjAngle{}
	_dgggda, _gafdc := _e.ParseInt(s, 10, 64)
	if _gafdc != nil {
		_eeeg.ST_GeomGuideName = &s
	} else {
		_geffe := int32(_dgggda)
		_eeeg.ST_Angle = &_geffe
	}
	return _eeeg, nil
}
func (_gdcbc *Graphic) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gdcbc.CT_GraphicalObject = *NewCT_GraphicalObject()
_bfdee:
	for {
		_caegf, _eaecg := d.Token()
		if _eaecg != nil {
			return _eaecg
		}
		switch _fbgbd := _caegf.(type) {
		case _g.StartElement:
			switch _fbgbd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "graphicData"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "graphicData"}:
				if _dcgfba := d.DecodeElement(_gdcbc.GraphicData, &_fbgbd); _dcgfba != nil {
					return _dcgfba
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Graphic\u0020\u0025v", _fbgbd.Name)
				if _eefbge := d.Skip(); _eefbge != nil {
					return _eefbge
				}
			}
		case _g.EndElement:
			break _bfdee
		case _g.CharData:
		}
	}
	return nil
}
func (_fdfd *CT_Cell3D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fdfd.Bevel = NewCT_Bevel()
	for _, _feb := range start.Attr {
		if _feb.Name.Local == "prstMaterial" {
			_fdfd.PrstMaterialAttr.UnmarshalXMLAttr(_feb)
			continue
		}
	}
_debf:
	for {
		_efbb, _gcbc := d.Token()
		if _gcbc != nil {
			return _gcbc
		}
		switch _cac := _efbb.(type) {
		case _g.StartElement:
			switch _cac.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bevel"}:
				if _gdfa := d.DecodeElement(_fdfd.Bevel, &_cac); _gdfa != nil {
					return _gdfa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lightRig"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lightRig"}:
				_fdfd.LightRig = NewCT_LightRig()
				if _gfcg := d.DecodeElement(_fdfd.LightRig, &_cac); _gfcg != nil {
					return _gfcg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_fdfd.ExtLst = NewCT_OfficeArtExtensionList()
				if _fcfg := d.DecodeElement(_fdfd.ExtLst, &_cac); _fcfg != nil {
					return _fcfg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on CT_Cell3D \u0025v", _cac.Name)
				if _geaf := d.Skip(); _geaf != nil {
					return _geaf
				}
			}
		case _g.EndElement:
			break _debf
		case _g.CharData:
		}
	}
	return nil
}
func (_bfaa *CT_Path2DLineTo) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_geeff := _g.StartElement{Name: _g.Name{Local: "a:pt"}}
	e.EncodeElement(_bfaa.Pt, _geeff)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_AlphaOutsetEffect and its children, prefixing error messages with path
func (_fg *CT_AlphaOutsetEffect) ValidateWithPath(path string) error {
	if _fg.RadAttr != nil {
		if _dfg := _fg.RadAttr.ValidateWithPath(path + "\u002fRadAttr"); _dfg != nil {
			return _dfg
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TextUnderlineFillFollowText and its children, prefixing error messages with path
func (_acccg *CT_TextUnderlineFillFollowText) ValidateWithPath(path string) error { return nil }

type CT_LineProperties struct {
	WAttr     *int32
	CapAttr   ST_LineCap
	CmpdAttr  ST_CompoundLine
	AlgnAttr  ST_PenAlignment
	NoFill    *CT_NoFillProperties
	SolidFill *CT_SolidColorFillProperties
	GradFill  *CT_GradientFillProperties
	PattFill  *CT_PatternFillProperties
	PrstDash  *CT_PresetLineDashProperties
	CustDash  *CT_DashStopList
	Round     *CT_LineJoinRound
	Bevel     *CT_LineJoinBevel
	Miter     *CT_LineJoinMiterProperties
	HeadEnd   *CT_LineEndProperties
	TailEnd   *CT_LineEndProperties
	ExtLst    *CT_OfficeArtExtensionList
}

func (_dabbe *CT_LinearShadeProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bdaad := range start.Attr {
		if _bdaad.Name.Local == "ang" {
			_ddfbc, _dbgda := _e.ParseInt(_bdaad.Value, 10, 32)
			if _dbgda != nil {
				return _dbgda
			}
			_fgcf := int32(_ddfbc)
			_dabbe.AngAttr = &_fgcf
			continue
		}
		if _bdaad.Name.Local == "scaled" {
			_ggagb, _cfgaf := _e.ParseBool(_bdaad.Value)
			if _cfgaf != nil {
				return _cfgaf
			}
			_dabbe.ScaledAttr = &_ggagb
			continue
		}
	}
	for {
		_gagff, _fcca := d.Token()
		if _fcca != nil {
			return _dcf.Errorf("parsing CT_LinearShadeProperties:\u0020%s", _fcca)
		}
		if _afbba, _adbbb := _gagff.(_g.EndElement); _adbbb && _afbba.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_WholeE2oFormatting and its children, prefixing error messages with path
func (_dfafe *CT_WholeE2oFormatting) ValidateWithPath(path string) error {
	if _dfafe.Ln != nil {
		if _ddbede := _dfafe.Ln.ValidateWithPath(path + "\u002fLn"); _ddbede != nil {
			return _ddbede
		}
	}
	if _dfafe.EffectLst != nil {
		if _deeda := _dfafe.EffectLst.ValidateWithPath(path + "\u002fEffectLst"); _deeda != nil {
			return _deeda
		}
	}
	if _dfafe.EffectDag != nil {
		if _ddebf := _dfafe.EffectDag.ValidateWithPath(path + "\u002fEffectDag"); _ddebf != nil {
			return _ddebf
		}
	}
	return nil
}

const (
	ST_SchemeColorValUnset    ST_SchemeColorVal = 0
	ST_SchemeColorValBg1      ST_SchemeColorVal = 1
	ST_SchemeColorValTx1      ST_SchemeColorVal = 2
	ST_SchemeColorValBg2      ST_SchemeColorVal = 3
	ST_SchemeColorValTx2      ST_SchemeColorVal = 4
	ST_SchemeColorValAccent1  ST_SchemeColorVal = 5
	ST_SchemeColorValAccent2  ST_SchemeColorVal = 6
	ST_SchemeColorValAccent3  ST_SchemeColorVal = 7
	ST_SchemeColorValAccent4  ST_SchemeColorVal = 8
	ST_SchemeColorValAccent5  ST_SchemeColorVal = 9
	ST_SchemeColorValAccent6  ST_SchemeColorVal = 10
	ST_SchemeColorValHlink    ST_SchemeColorVal = 11
	ST_SchemeColorValFolHlink ST_SchemeColorVal = 12
	ST_SchemeColorValPhClr    ST_SchemeColorVal = 13
	ST_SchemeColorValDk1      ST_SchemeColorVal = 14
	ST_SchemeColorValLt1      ST_SchemeColorVal = 15
	ST_SchemeColorValDk2      ST_SchemeColorVal = 16
	ST_SchemeColorValLt2      ST_SchemeColorVal = 17
)

func (_abggd *CT_Ratio) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "n"}, Value: _dcf.Sprintf("\u0025v", _abggd.NAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "d"}, Value: _dcf.Sprintf("\u0025v", _abggd.DAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_PresetGeometry2D struct {
	PrstAttr ST_ShapeType
	AvLst    *CT_GeomGuideList
}

// Validate validates the CT_Scale2D and its children
func (_bcfed *CT_Scale2D) Validate() error { return _bcfed.ValidateWithPath("CT_Scale2D") }
func NewCT_TableBackgroundStyle() *CT_TableBackgroundStyle {
	_abadc := &CT_TableBackgroundStyle{}
	return _abadc
}
func NewCT_LineStyleList() *CT_LineStyleList { _gedd := &CT_LineStyleList{}; return _gedd }
func (_ffa *CT_AlphaFloorEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_bfbd, _ebf := d.Token()
		if _ebf != nil {
			return _dcf.Errorf("parsing\u0020CT_AlphaFloorEffect:\u0020\u0025s", _ebf)
		}
		if _efg, _dba := _bfbd.(_g.EndElement); _dba && _efg.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_LinearShadeProperties and its children, prefixing error messages with path
func (_badfb *CT_LinearShadeProperties) ValidateWithPath(path string) error {
	if _badfb.AngAttr != nil {
		if *_badfb.AngAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eAngAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_badfb.AngAttr)
		}
		if *_badfb.AngAttr >= 21600000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eAngAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, *_badfb.AngAttr)
		}
	}
	return nil
}
func (_dedff ST_TextHorzOverflowType) String() string {
	switch _dedff {
	case 0:
		return ""
	case 1:
		return "overflow"
	case 2:
		return "clip"
	}
	return ""
}

type ST_TextAutonumberScheme byte

func (_gadbc *ST_AnimationChartBuildType) ValidateWithPath(path string) error {
	_egcbg := []string{}
	if _gadbc.ST_AnimationBuildType != ST_AnimationBuildTypeUnset {
		_egcbg = append(_egcbg, "ST_AnimationBuildType")
	}
	if _gadbc.ST_AnimationChartOnlyBuildType != ST_AnimationChartOnlyBuildTypeUnset {
		_egcbg = append(_egcbg, "ST_AnimationChartOnlyBuildType")
	}
	if len(_egcbg) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _egcbg)
	}
	return nil
}
func (_gecb ST_ChartBuildStep) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_adabc := _g.Attr{}
	_adabc.Name = name
	switch _gecb {
	case ST_ChartBuildStepUnset:
		_adabc.Value = ""
	case ST_ChartBuildStepCategory:
		_adabc.Value = "category"
	case ST_ChartBuildStepPtInCategory:
		_adabc.Value = "ptInCategory"
	case ST_ChartBuildStepSeries:
		_adabc.Value = "series"
	case ST_ChartBuildStepPtInSeries:
		_adabc.Value = "ptInSeries"
	case ST_ChartBuildStepAllPts:
		_adabc.Value = "allPts"
	case ST_ChartBuildStepGridLegend:
		_adabc.Value = "gridLegend"
	}
	return _adabc, nil
}
func (_dbcfa *CT_ContentPartLocking) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _gcgd := range start.Attr {
		if _gcgd.Name.Local == "noGrp" {
			_befb, _ecdf := _e.ParseBool(_gcgd.Value)
			if _ecdf != nil {
				return _ecdf
			}
			_dbcfa.NoGrpAttr = &_befb
			continue
		}
		if _gcgd.Name.Local == "noSelect" {
			_cbedc, _becf := _e.ParseBool(_gcgd.Value)
			if _becf != nil {
				return _becf
			}
			_dbcfa.NoSelectAttr = &_cbedc
			continue
		}
		if _gcgd.Name.Local == "noRot" {
			_decfb, _daee := _e.ParseBool(_gcgd.Value)
			if _daee != nil {
				return _daee
			}
			_dbcfa.NoRotAttr = &_decfb
			continue
		}
		if _gcgd.Name.Local == "noChangeAspect" {
			_fgcd, _ccffg := _e.ParseBool(_gcgd.Value)
			if _ccffg != nil {
				return _ccffg
			}
			_dbcfa.NoChangeAspectAttr = &_fgcd
			continue
		}
		if _gcgd.Name.Local == "noMove" {
			_gacea, _fbee := _e.ParseBool(_gcgd.Value)
			if _fbee != nil {
				return _fbee
			}
			_dbcfa.NoMoveAttr = &_gacea
			continue
		}
		if _gcgd.Name.Local == "noResize" {
			_fbeb, _fdeb := _e.ParseBool(_gcgd.Value)
			if _fdeb != nil {
				return _fdeb
			}
			_dbcfa.NoResizeAttr = &_fbeb
			continue
		}
		if _gcgd.Name.Local == "noEditPoints" {
			_ddaa, _ecba := _e.ParseBool(_gcgd.Value)
			if _ecba != nil {
				return _ecba
			}
			_dbcfa.NoEditPointsAttr = &_ddaa
			continue
		}
		if _gcgd.Name.Local == "noAdjustHandles" {
			_ebcd, _ebbb := _e.ParseBool(_gcgd.Value)
			if _ebbb != nil {
				return _ebbb
			}
			_dbcfa.NoAdjustHandlesAttr = &_ebcd
			continue
		}
		if _gcgd.Name.Local == "noChangeArrowheads" {
			_effca, _fceb := _e.ParseBool(_gcgd.Value)
			if _fceb != nil {
				return _fceb
			}
			_dbcfa.NoChangeArrowheadsAttr = &_effca
			continue
		}
		if _gcgd.Name.Local == "noChangeShapeType" {
			_dgfdc, _fcbab := _e.ParseBool(_gcgd.Value)
			if _fcbab != nil {
				return _fcbab
			}
			_dbcfa.NoChangeShapeTypeAttr = &_dgfdc
			continue
		}
	}
_gdbb:
	for {
		_dbee, _ccgbd := d.Token()
		if _ccgbd != nil {
			return _ccgbd
		}
		switch _deed := _dbee.(type) {
		case _g.StartElement:
			switch _deed.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_dbcfa.ExtLst = NewCT_OfficeArtExtensionList()
				if _bcad := d.DecodeElement(_dbcfa.ExtLst, &_deed); _bcad != nil {
					return _bcad
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_ContentPartLocking\u0020\u0025v", _deed.Name)
				if _gdddg := d.Skip(); _gdddg != nil {
					return _gdddg
				}
			}
		case _g.EndElement:
			break _gdbb
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_AlphaModulateFixedEffect and its children
func (_bgg *CT_AlphaModulateFixedEffect) Validate() error {
	return _bgg.ValidateWithPath("CT_AlphaModulateFixedEffect")
}
func (_fdea *CT_Path2DClose) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewEG_FillModeProperties() *EG_FillModeProperties {
	_bfcab := &EG_FillModeProperties{}
	return _bfcab
}
func (_cdcc *CT_ColorReplaceEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _cdcc.ScrgbClr != nil {
		_cebg := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_cdcc.ScrgbClr, _cebg)
	}
	if _cdcc.SrgbClr != nil {
		_eaeb := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_cdcc.SrgbClr, _eaeb)
	}
	if _cdcc.HslClr != nil {
		_gcef := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_cdcc.HslClr, _gcef)
	}
	if _cdcc.SysClr != nil {
		_cecf := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_cdcc.SysClr, _cecf)
	}
	if _cdcc.SchemeClr != nil {
		_gcddb := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_cdcc.SchemeClr, _gcddb)
	}
	if _cdcc.PrstClr != nil {
		_cbac := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_cdcc.PrstClr, _cbac)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TextSpacing and its children, prefixing error messages with path
func (_fbfdc *CT_TextSpacing) ValidateWithPath(path string) error {
	if _fbfdc.SpcPct != nil {
		if _aecfdb := _fbfdc.SpcPct.ValidateWithPath(path + "\u002fSpcPct"); _aecfdb != nil {
			return _aecfdb
		}
	}
	if _fbfdc.SpcPts != nil {
		if _eeabe := _fbfdc.SpcPts.ValidateWithPath(path + "\u002fSpcPts"); _eeabe != nil {
			return _eeabe
		}
	}
	return nil
}
func (_ccfa *CT_Point2D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ebcaf := range start.Attr {
		if _ebcaf.Name.Local == "x" {
			_cfcea, _baggg := ParseUnionST_Coordinate(_ebcaf.Value)
			if _baggg != nil {
				return _baggg
			}
			_ccfa.XAttr = _cfcea
			continue
		}
		if _ebcaf.Name.Local == "y" {
			_ggcde, _afgbg := ParseUnionST_Coordinate(_ebcaf.Value)
			if _afgbg != nil {
				return _afgbg
			}
			_ccfa.YAttr = _ggcde
			continue
		}
	}
	for {
		_cbeb, _aefg := d.Token()
		if _aefg != nil {
			return _dcf.Errorf("parsing\u0020CT_Point2D:\u0020%s", _aefg)
		}
		if _dccce, _gacge := _cbeb.(_g.EndElement); _gacge && _dccce.Name == start.Name {
			break
		}
	}
	return nil
}

type EG_TextGeometry struct {
	CustGeom   *CT_CustomGeometry2D
	PrstTxWarp *CT_PresetTextShape
}
type AG_Blob struct {
	EmbedAttr *string
	LinkAttr  *string
}

func (_dgba *CT_ConnectorLocking) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dgba.NoGrpAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noGrp"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dgba.NoGrpAttr))})
	}
	if _dgba.NoSelectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noSelect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dgba.NoSelectAttr))})
	}
	if _dgba.NoRotAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noRot"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dgba.NoRotAttr))})
	}
	if _dgba.NoChangeAspectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeAspect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dgba.NoChangeAspectAttr))})
	}
	if _dgba.NoMoveAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noMove"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dgba.NoMoveAttr))})
	}
	if _dgba.NoResizeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noResize"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dgba.NoResizeAttr))})
	}
	if _dgba.NoEditPointsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noEditPoints"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dgba.NoEditPointsAttr))})
	}
	if _dgba.NoAdjustHandlesAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noAdjustHandles"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dgba.NoAdjustHandlesAttr))})
	}
	if _dgba.NoChangeArrowheadsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeArrowheads"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dgba.NoChangeArrowheadsAttr))})
	}
	if _dgba.NoChangeShapeTypeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeShapeType"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dgba.NoChangeShapeTypeAttr))})
	}
	e.EncodeToken(start)
	if _dgba.ExtLst != nil {
		_eadb := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dgba.ExtLst, _eadb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_InverseGammaTransform struct{}
type CT_OfficeArtExtensionList struct{ Ext []*CT_OfficeArtExtension }
type ST_SystemColorVal byte

func (_gfcd *CT_TextField) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gfcd.IdAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	for _, _gggad := range start.Attr {
		if _gggad.Name.Local == "id" {
			_cfbccg, _cadeca := _gggad.Value, error(nil)
			if _cadeca != nil {
				return _cadeca
			}
			_gfcd.IdAttr = _cfbccg
			continue
		}
		if _gggad.Name.Local == "type" {
			_adfgf, _ffdbc := _gggad.Value, error(nil)
			if _ffdbc != nil {
				return _ffdbc
			}
			_gfcd.TypeAttr = &_adfgf
			continue
		}
	}
_gbbbb:
	for {
		_cbffd, _daebe := d.Token()
		if _daebe != nil {
			return _daebe
		}
		switch _bfcea := _cbffd.(type) {
		case _g.StartElement:
			switch _bfcea.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "rPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "rPr"}:
				_gfcd.RPr = NewCT_TextCharacterProperties()
				if _fdagd := d.DecodeElement(_gfcd.RPr, &_bfcea); _fdagd != nil {
					return _fdagd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pPr"}:
				_gfcd.PPr = NewCT_TextParagraphProperties()
				if _aebd := d.DecodeElement(_gfcd.PPr, &_bfcea); _aebd != nil {
					return _aebd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "t"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "t"}:
				_gfcd.T = new(string)
				if _gecd := d.DecodeElement(_gfcd.T, &_bfcea); _gecd != nil {
					return _gecd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TextField\u0020\u0025v", _bfcea.Name)
				if _aecba := d.Skip(); _aecba != nil {
					return _aecba
				}
			}
		case _g.EndElement:
			break _gbbbb
		case _g.CharData:
		}
	}
	return nil
}

type EG_TextUnderlineLine struct {
	ULnTx *CT_TextUnderlineLineFollowText
	ULn   *CT_LineProperties
}
type CT_ObjectStyleDefaults struct {
	SpDef  *CT_DefaultShapeDefinition
	LnDef  *CT_DefaultShapeDefinition
	TxDef  *CT_DefaultShapeDefinition
	ExtLst *CT_OfficeArtExtensionList
}

// ValidateWithPath validates the CT_AnimationElementChoice and its children, prefixing error messages with path
func (_fbca *CT_AnimationElementChoice) ValidateWithPath(path string) error {
	if _fbca.Dgm != nil {
		if _ggb := _fbca.Dgm.ValidateWithPath(path + "\u002fDgm"); _ggb != nil {
			return _ggb
		}
	}
	if _fbca.Chart != nil {
		if _fegea := _fbca.Chart.ValidateWithPath(path + "\u002fChart"); _fegea != nil {
			return _fegea
		}
	}
	return nil
}
func (_cdaec *ST_LightRigDirection) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dbgba, _gfggfd := d.Token()
	if _gfggfd != nil {
		return _gfggfd
	}
	if _aceabc, _ffafg := _dbgba.(_g.EndElement); _ffafg && _aceabc.Name == start.Name {
		*_cdaec = 1
		return nil
	}
	if _cdcac, _ffdgf := _dbgba.(_g.CharData); !_ffdgf {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dbgba)
	} else {
		switch string(_cdcac) {
		case "":
			*_cdaec = 0
		case "tl":
			*_cdaec = 1
		case "t":
			*_cdaec = 2
		case "tr":
			*_cdaec = 3
		case "l":
			*_cdaec = 4
		case "r":
			*_cdaec = 5
		case "bl":
			*_cdaec = 6
		case "b":
			*_cdaec = 7
		case "br":
			*_cdaec = 8
		}
	}
	_dbgba, _gfggfd = d.Token()
	if _gfggfd != nil {
		return _gfggfd
	}
	if _ageebfe, _gdadf := _dbgba.(_g.EndElement); _gdadf && _ageebfe.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dbgba)
}
func (_dgbad *CT_TextBulletSizePercent) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dgbad.ValAttr = "100\u0025"
	for _, _cfbfb := range start.Attr {
		if _cfbfb.Name.Local == "val" {
			_gadad, _ededc := _cfbfb.Value, error(nil)
			if _ededc != nil {
				return _ededc
			}
			_dgbad.ValAttr = _gadad
			continue
		}
	}
	for {
		_dfbcf, _acae := d.Token()
		if _acae != nil {
			return _dcf.Errorf("parsing CT_TextBulletSizePercent:\u0020%s", _acae)
		}
		if _egggfe, _ccbff := _dfbcf.(_g.EndElement); _ccbff && _egggfe.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_AlphaModulateFixedEffect struct{ AmtAttr *ST_PositivePercentage }

// Validate validates the CT_LightRig and its children
func (_cffba *CT_LightRig) Validate() error { return _cffba.ValidateWithPath("CT_LightRig") }
func NewEG_TextAutofit() *EG_TextAutofit    { _fabfe := &EG_TextAutofit{}; return _fabfe }

type CT_AlphaReplaceEffect struct{ AAttr ST_PositiveFixedPercentage }
type CT_GvmlShape struct {
	NvSpPr *CT_GvmlShapeNonVisual
	SpPr   *CT_ShapeProperties
	TxSp   *CT_GvmlTextShape
	Style  *CT_ShapeStyle
	ExtLst *CT_OfficeArtExtensionList
}

func (_edfbd ST_TextCapsType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_cbefff := _g.Attr{}
	_cbefff.Name = name
	switch _edfbd {
	case ST_TextCapsTypeUnset:
		_cbefff.Value = ""
	case ST_TextCapsTypeNone:
		_cbefff.Value = "none"
	case ST_TextCapsTypeSmall:
		_cbefff.Value = "small"
	case ST_TextCapsTypeAll:
		_cbefff.Value = "all"
	}
	return _cbefff, nil
}
func (_gagdd *CT_TintEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ebccc := range start.Attr {
		if _ebccc.Name.Local == "hue" {
			_ecbec, _faaag := _e.ParseInt(_ebccc.Value, 10, 32)
			if _faaag != nil {
				return _faaag
			}
			_facgac := int32(_ecbec)
			_gagdd.HueAttr = &_facgac
			continue
		}
		if _ebccc.Name.Local == "amt" {
			_fgcacc, _dgcb := ParseUnionST_FixedPercentage(_ebccc.Value)
			if _dgcb != nil {
				return _dgcb
			}
			_gagdd.AmtAttr = &_fgcacc
			continue
		}
	}
	for {
		_cadae, _aebcg := d.Token()
		if _aebcg != nil {
			return _dcf.Errorf("parsing\u0020CT_TintEffect:\u0020\u0025s", _aebcg)
		}
		if _cecfa, _ffcbaa := _cadae.(_g.EndElement); _ffcbaa && _cecfa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cafcfb *CT_TextBody) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cafcfb.BodyPr = NewCT_TextBodyProperties()
_gafd:
	for {
		_gefbec, _gfgfb := d.Token()
		if _gfgfb != nil {
			return _gfgfb
		}
		switch _gabaf := _gefbec.(type) {
		case _g.StartElement:
			switch _gabaf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bodyPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bodyPr"}:
				if _ddecd := d.DecodeElement(_cafcfb.BodyPr, &_gabaf); _ddecd != nil {
					return _ddecd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lstStyle"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lstStyle"}:
				_cafcfb.LstStyle = NewCT_TextListStyle()
				if _abebbf := d.DecodeElement(_cafcfb.LstStyle, &_gabaf); _abebbf != nil {
					return _abebbf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "p"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "p"}:
				_ageebe := NewCT_TextParagraph()
				if _eaggd := d.DecodeElement(_ageebe, &_gabaf); _eaggd != nil {
					return _eaggd
				}
				_cafcfb.P = append(_cafcfb.P, _ageebe)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TextBody\u0020\u0025v", _gabaf.Name)
				if _cedgg := d.Skip(); _cedgg != nil {
					return _cedgg
				}
			}
		case _g.EndElement:
			break _gafd
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_TextSpacingPercent and its children
func (_eacbc *CT_TextSpacingPercent) Validate() error {
	return _eacbc.ValidateWithPath("CT_TextSpacingPercent")
}
func (_bccec ST_PresetPatternVal) String() string {
	switch _bccec {
	case 0:
		return ""
	case 1:
		return "pct5"
	case 2:
		return "pct10"
	case 3:
		return "pct20"
	case 4:
		return "pct25"
	case 5:
		return "pct30"
	case 6:
		return "pct40"
	case 7:
		return "pct50"
	case 8:
		return "pct60"
	case 9:
		return "pct70"
	case 10:
		return "pct75"
	case 11:
		return "pct80"
	case 12:
		return "pct90"
	case 13:
		return "horz"
	case 14:
		return "vert"
	case 15:
		return "ltHorz"
	case 16:
		return "ltVert"
	case 17:
		return "dkHorz"
	case 18:
		return "dkVert"
	case 19:
		return "narHorz"
	case 20:
		return "narVert"
	case 21:
		return "dashHorz"
	case 22:
		return "dashVert"
	case 23:
		return "cross"
	case 24:
		return "dnDiag"
	case 25:
		return "upDiag"
	case 26:
		return "ltDnDiag"
	case 27:
		return "ltUpDiag"
	case 28:
		return "dkDnDiag"
	case 29:
		return "dkUpDiag"
	case 30:
		return "wdDnDiag"
	case 31:
		return "wdUpDiag"
	case 32:
		return "dashDnDiag"
	case 33:
		return "dashUpDiag"
	case 34:
		return "diagCross"
	case 35:
		return "smCheck"
	case 36:
		return "lgCheck"
	case 37:
		return "smGrid"
	case 38:
		return "lgGrid"
	case 39:
		return "dotGrid"
	case 40:
		return "smConfetti"
	case 41:
		return "lgConfetti"
	case 42:
		return "horzBrick"
	case 43:
		return "diagBrick"
	case 44:
		return "solidDmnd"
	case 45:
		return "openDmnd"
	case 46:
		return "dotDmnd"
	case 47:
		return "plaid"
	case 48:
		return "sphere"
	case 49:
		return "weave"
	case 50:
		return "divot"
	case 51:
		return "shingle"
	case 52:
		return "wave"
	case 53:
		return "trellis"
	case 54:
		return "zigZag"
	}
	return ""
}
func (_gaef *CT_Connection) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "id"}, Value: _dcf.Sprintf("\u0025v", _gaef.IdAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "idx"}, Value: _dcf.Sprintf("\u0025v", _gaef.IdxAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_ObjectStyleDefaults() *CT_ObjectStyleDefaults {
	_agab := &CT_ObjectStyleDefaults{}
	return _agab
}

// ValidateWithPath validates the CT_Scale2D and its children, prefixing error messages with path
func (_agged *CT_Scale2D) ValidateWithPath(path string) error {
	if _gdcf := _agged.Sx.ValidateWithPath(path + "\u002fSx"); _gdcf != nil {
		return _gdcf
	}
	if _bacbc := _agged.Sy.ValidateWithPath(path + "\u002fSy"); _bacbc != nil {
		return _bacbc
	}
	return nil
}
func (_cgdbb *CT_SphereCoords) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cgdbb.LatAttr = 0
	_cgdbb.LonAttr = 0
	_cgdbb.RevAttr = 0
	for _, _bdaba := range start.Attr {
		if _bdaba.Name.Local == "lat" {
			_bdfcc, _dgfcf := _e.ParseInt(_bdaba.Value, 10, 32)
			if _dgfcf != nil {
				return _dgfcf
			}
			_cgdbb.LatAttr = int32(_bdfcc)
			continue
		}
		if _bdaba.Name.Local == "lon" {
			_caecf, _edbgb := _e.ParseInt(_bdaba.Value, 10, 32)
			if _edbgb != nil {
				return _edbgb
			}
			_cgdbb.LonAttr = int32(_caecf)
			continue
		}
		if _bdaba.Name.Local == "rev" {
			_agcfg, _gdbed := _e.ParseInt(_bdaba.Value, 10, 32)
			if _gdbed != nil {
				return _gdbed
			}
			_cgdbb.RevAttr = int32(_agcfg)
			continue
		}
	}
	for {
		_bdbab, _cfeaa := d.Token()
		if _cfeaa != nil {
			return _dcf.Errorf("parsing CT_SphereCoords:\u0020\u0025s", _cfeaa)
		}
		if _bbdbd, _ecdbe := _bdbab.(_g.EndElement); _ecdbe && _bbdbd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cdfede ST_Coordinate) String() string {
	if _cdfede.ST_CoordinateUnqualified != nil {
		return _dcf.Sprintf("\u0025v", *_cdfede.ST_CoordinateUnqualified)
	}
	if _cdfede.ST_UniversalMeasure != nil {
		return _dcf.Sprintf("\u0025v", *_cdfede.ST_UniversalMeasure)
	}
	return ""
}
func (_dbggcc *EG_LineJoinProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_efbge:
	for {
		_bfegac, _becec := d.Token()
		if _becec != nil {
			return _becec
		}
		switch _cegfe := _bfegac.(type) {
		case _g.StartElement:
			switch _cegfe.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "round"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "round"}:
				_dbggcc.Round = NewCT_LineJoinRound()
				if _fccgg := d.DecodeElement(_dbggcc.Round, &_cegfe); _fccgg != nil {
					return _fccgg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "bevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "bevel"}:
				_dbggcc.Bevel = NewCT_LineJoinBevel()
				if _aacca := d.DecodeElement(_dbggcc.Bevel, &_cegfe); _aacca != nil {
					return _aacca
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "miter"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "miter"}:
				_dbggcc.Miter = NewCT_LineJoinMiterProperties()
				if _bgfgg := d.DecodeElement(_dbggcc.Miter, &_cegfe); _bgfgg != nil {
					return _bgfgg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on EG_LineJoinProperties\u0020\u0025v", _cegfe.Name)
				if _cbdc := d.Skip(); _cbdc != nil {
					return _cbdc
				}
			}
		case _g.EndElement:
			break _efbge
		case _g.CharData:
		}
	}
	return nil
}

const (
	ST_ChartBuildStepUnset        ST_ChartBuildStep = 0
	ST_ChartBuildStepCategory     ST_ChartBuildStep = 1
	ST_ChartBuildStepPtInCategory ST_ChartBuildStep = 2
	ST_ChartBuildStepSeries       ST_ChartBuildStep = 3
	ST_ChartBuildStepPtInSeries   ST_ChartBuildStep = 4
	ST_ChartBuildStepAllPts       ST_ChartBuildStep = 5
	ST_ChartBuildStepGridLegend   ST_ChartBuildStep = 6
)

func (_cbbff *ST_LineEndType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_cbbff = 0
	case "none":
		*_cbbff = 1
	case "triangle":
		*_cbbff = 2
	case "stealth":
		*_cbbff = 3
	case "diamond":
		*_cbbff = 4
	case "oval":
		*_cbbff = 5
	case "arrow":
		*_cbbff = 6
	}
	return nil
}

// ValidateWithPath validates the CT_TableCellBorderStyle and its children, prefixing error messages with path
func (_gagb *CT_TableCellBorderStyle) ValidateWithPath(path string) error {
	if _gagb.Left != nil {
		if _ebfbg := _gagb.Left.ValidateWithPath(path + "\u002fLeft"); _ebfbg != nil {
			return _ebfbg
		}
	}
	if _gagb.Right != nil {
		if _ebceff := _gagb.Right.ValidateWithPath(path + "\u002fRight"); _ebceff != nil {
			return _ebceff
		}
	}
	if _gagb.Top != nil {
		if _aegaf := _gagb.Top.ValidateWithPath(path + "\u002fTop"); _aegaf != nil {
			return _aegaf
		}
	}
	if _gagb.Bottom != nil {
		if _gfbea := _gagb.Bottom.ValidateWithPath(path + "\u002fBottom"); _gfbea != nil {
			return _gfbea
		}
	}
	if _gagb.InsideH != nil {
		if _dfff := _gagb.InsideH.ValidateWithPath(path + "\u002fInsideH"); _dfff != nil {
			return _dfff
		}
	}
	if _gagb.InsideV != nil {
		if _becfc := _gagb.InsideV.ValidateWithPath(path + "\u002fInsideV"); _becfc != nil {
			return _becfc
		}
	}
	if _gagb.Tl2br != nil {
		if _ebcabb := _gagb.Tl2br.ValidateWithPath(path + "\u002fTl2br"); _ebcabb != nil {
			return _ebcabb
		}
	}
	if _gagb.Tr2bl != nil {
		if _bacaf := _gagb.Tr2bl.ValidateWithPath(path + "\u002fTr2bl"); _bacaf != nil {
			return _bacaf
		}
	}
	if _gagb.ExtLst != nil {
		if _beeef := _gagb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _beeef != nil {
			return _beeef
		}
	}
	return nil
}
func (_fccfb ST_ShapeType) Validate() error { return _fccfb.ValidateWithPath("") }
func (_febbf *CT_TextListStyle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _febbf.DefPPr != nil {
		_cbadaa := _g.StartElement{Name: _g.Name{Local: "a:defPPr"}}
		e.EncodeElement(_febbf.DefPPr, _cbadaa)
	}
	if _febbf.Lvl1pPr != nil {
		_cccfae := _g.StartElement{Name: _g.Name{Local: "a:lvl1pPr"}}
		e.EncodeElement(_febbf.Lvl1pPr, _cccfae)
	}
	if _febbf.Lvl2pPr != nil {
		_cdadd := _g.StartElement{Name: _g.Name{Local: "a:lvl2pPr"}}
		e.EncodeElement(_febbf.Lvl2pPr, _cdadd)
	}
	if _febbf.Lvl3pPr != nil {
		_dfabd := _g.StartElement{Name: _g.Name{Local: "a:lvl3pPr"}}
		e.EncodeElement(_febbf.Lvl3pPr, _dfabd)
	}
	if _febbf.Lvl4pPr != nil {
		_cdgda := _g.StartElement{Name: _g.Name{Local: "a:lvl4pPr"}}
		e.EncodeElement(_febbf.Lvl4pPr, _cdgda)
	}
	if _febbf.Lvl5pPr != nil {
		_gaegca := _g.StartElement{Name: _g.Name{Local: "a:lvl5pPr"}}
		e.EncodeElement(_febbf.Lvl5pPr, _gaegca)
	}
	if _febbf.Lvl6pPr != nil {
		_egegaa := _g.StartElement{Name: _g.Name{Local: "a:lvl6pPr"}}
		e.EncodeElement(_febbf.Lvl6pPr, _egegaa)
	}
	if _febbf.Lvl7pPr != nil {
		_afbegg := _g.StartElement{Name: _g.Name{Local: "a:lvl7pPr"}}
		e.EncodeElement(_febbf.Lvl7pPr, _afbegg)
	}
	if _febbf.Lvl8pPr != nil {
		_adgffe := _g.StartElement{Name: _g.Name{Local: "a:lvl8pPr"}}
		e.EncodeElement(_febbf.Lvl8pPr, _adgffe)
	}
	if _febbf.Lvl9pPr != nil {
		_bfffg := _g.StartElement{Name: _g.Name{Local: "a:lvl9pPr"}}
		e.EncodeElement(_febbf.Lvl9pPr, _bfffg)
	}
	if _febbf.ExtLst != nil {
		_bggga := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_febbf.ExtLst, _bggga)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_PresetGeometry2D and its children
func (_cgfcf *CT_PresetGeometry2D) Validate() error {
	return _cgfcf.ValidateWithPath("CT_PresetGeometry2D")
}
func (_eggbe *ST_FixedPercentage) ValidateWithPath(path string) error {
	_cfgde := []string{}
	if _eggbe.ST_FixedPercentageDecimal != nil {
		_cfgde = append(_cfgde, "ST_FixedPercentageDecimal")
	}
	if _eggbe.ST_FixedPercentage != nil {
		if _acbce := _eggbe.ST_FixedPercentage.ValidateWithPath(path + "\u002fST_FixedPercentage"); _acbce != nil {
			return _acbce
		}
		_cfgde = append(_cfgde, "ST_FixedPercentage")
	}
	if len(_cfgde) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _cfgde)
	}
	return nil
}
func (_ccefa *ST_TextTabAlignType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fcfccb, _dcacd := d.Token()
	if _dcacd != nil {
		return _dcacd
	}
	if _cfabd, _fdaef := _fcfccb.(_g.EndElement); _fdaef && _cfabd.Name == start.Name {
		*_ccefa = 1
		return nil
	}
	if _fbgca, _ebaca := _fcfccb.(_g.CharData); !_ebaca {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fcfccb)
	} else {
		switch string(_fbgca) {
		case "":
			*_ccefa = 0
		case "l":
			*_ccefa = 1
		case "ctr":
			*_ccefa = 2
		case "r":
			*_ccefa = 3
		case "dec":
			*_ccefa = 4
		}
	}
	_fcfccb, _dcacd = d.Token()
	if _dcacd != nil {
		return _dcacd
	}
	if _bgdgdb, _cefca := _fcfccb.(_g.EndElement); _cefca && _bgdgdb.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fcfccb)
}
func NewBlip() *Blip { _bf := &Blip{}; _bf.CT_Blip = *NewCT_Blip(); return _bf }

// ST_PositiveFixedPercentage is a union type
type ST_PositiveFixedPercentage struct {
	ST_PositiveFixedPercentageDecimal *int32
	ST_PositiveFixedPercentage        *ST_Percentage
}

func (_aaaef *EG_FillProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _aaaef.NoFill != nil {
		_aacac := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_aaaef.NoFill, _aacac)
	}
	if _aaaef.SolidFill != nil {
		_fecga := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_aaaef.SolidFill, _fecga)
	}
	if _aaaef.GradFill != nil {
		_bcdef := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_aaaef.GradFill, _bcdef)
	}
	if _aaaef.BlipFill != nil {
		_cadd := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
		e.EncodeElement(_aaaef.BlipFill, _cadd)
	}
	if _aaaef.PattFill != nil {
		_fffff := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_aaaef.PattFill, _fffff)
	}
	if _aaaef.GrpFill != nil {
		_cegdg := _g.StartElement{Name: _g.Name{Local: "a:grpFill"}}
		e.EncodeElement(_aaaef.GrpFill, _cegdg)
	}
	return nil
}
func NewCT_PresetTextShape() *CT_PresetTextShape {
	_dcbcb := &CT_PresetTextShape{}
	_dcbcb.PrstAttr = ST_TextShapeType(1)
	return _dcbcb
}
func (_befcb ST_AnimationChartOnlyBuildType) String() string {
	switch _befcb {
	case 0:
		return ""
	case 1:
		return "series"
	case 2:
		return "category"
	case 3:
		return "seriesEl"
	case 4:
		return "categoryEl"
	}
	return ""
}
func NewCT_GlowEffect() *CT_GlowEffect { _cbcg := &CT_GlowEffect{}; return _cbcg }
func (_fbde *CT_TextTabStop) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _dcdbe := range start.Attr {
		if _dcdbe.Name.Local == "pos" {
			_gcgdaa, _aaaac := ParseUnionST_Coordinate32(_dcdbe.Value)
			if _aaaac != nil {
				return _aaaac
			}
			_fbde.PosAttr = &_gcgdaa
			continue
		}
		if _dcdbe.Name.Local == "algn" {
			_fbde.AlgnAttr.UnmarshalXMLAttr(_dcdbe)
			continue
		}
	}
	for {
		_eefaa, _cgecb := d.Token()
		if _cgecb != nil {
			return _dcf.Errorf("parsing\u0020CT_TextTabStop:\u0020\u0025s", _cgecb)
		}
		if _ffbfe, _dbgeg := _eefaa.(_g.EndElement); _dbgeg && _ffbfe.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cgbga ST_LineEndType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cgbga.String(), start)
}
func (_fdefae *ST_TextUnderlineType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fdefae = 0
	case "none":
		*_fdefae = 1
	case "words":
		*_fdefae = 2
	case "sng":
		*_fdefae = 3
	case "dbl":
		*_fdefae = 4
	case "heavy":
		*_fdefae = 5
	case "dotted":
		*_fdefae = 6
	case "dottedHeavy":
		*_fdefae = 7
	case "dash":
		*_fdefae = 8
	case "dashHeavy":
		*_fdefae = 9
	case "dashLong":
		*_fdefae = 10
	case "dashLongHeavy":
		*_fdefae = 11
	case "dotDash":
		*_fdefae = 12
	case "dotDashHeavy":
		*_fdefae = 13
	case "dotDotDash":
		*_fdefae = 14
	case "dotDotDashHeavy":
		*_fdefae = 15
	case "wavy":
		*_fdefae = 16
	case "wavyHeavy":
		*_fdefae = 17
	case "wavyDbl":
		*_fdefae = 18
	}
	return nil
}
func (_cdgdc ST_AnimationChartOnlyBuildType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cdgdc.String(), start)
}
func (_agafde *CT_TableBackgroundStyle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _agafde.Fill != nil {
		_gegd := _g.StartElement{Name: _g.Name{Local: "a:fill"}}
		e.EncodeElement(_agafde.Fill, _gegd)
	}
	if _agafde.FillRef != nil {
		_ffaab := _g.StartElement{Name: _g.Name{Local: "a:fillRef"}}
		e.EncodeElement(_agafde.FillRef, _ffaab)
	}
	if _agafde.Effect != nil {
		_dabag := _g.StartElement{Name: _g.Name{Local: "a:effect"}}
		e.EncodeElement(_agafde.Effect, _dabag)
	}
	if _agafde.EffectRef != nil {
		_dagga := _g.StartElement{Name: _g.Name{Local: "a:effectRef"}}
		e.EncodeElement(_agafde.EffectRef, _dagga)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_PatternFillProperties and its children, prefixing error messages with path
func (_dcae *CT_PatternFillProperties) ValidateWithPath(path string) error {
	if _bdfg := _dcae.PrstAttr.ValidateWithPath(path + "\u002fPrstAttr"); _bdfg != nil {
		return _bdfg
	}
	if _dcae.FgClr != nil {
		if _babgf := _dcae.FgClr.ValidateWithPath(path + "\u002fFgClr"); _babgf != nil {
			return _babgf
		}
	}
	if _dcae.BgClr != nil {
		if _eeddf := _dcae.BgClr.ValidateWithPath(path + "\u002fBgClr"); _eeddf != nil {
			return _eeddf
		}
	}
	return nil
}
func NewCT_ColorChangeEffect() *CT_ColorChangeEffect {
	_bafa := &CT_ColorChangeEffect{}
	_bafa.ClrFrom = NewCT_Color()
	_bafa.ClrTo = NewCT_Color()
	return _bafa
}
func (_bbbgb ST_BlendMode) Validate() error { return _bbbgb.ValidateWithPath("") }

type EG_ThemeableEffectStyle struct {
	Effect    *CT_EffectProperties
	EffectRef *CT_StyleMatrixReference
}

func (_cbfbe *CT_ObjectStyleDefaults) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gdcgg:
	for {
		_dbaab, _aaea := d.Token()
		if _aaea != nil {
			return _aaea
		}
		switch _fefda := _dbaab.(type) {
		case _g.StartElement:
			switch _fefda.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spDef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spDef"}:
				_cbfbe.SpDef = NewCT_DefaultShapeDefinition()
				if _edcc := d.DecodeElement(_cbfbe.SpDef, &_fefda); _edcc != nil {
					return _edcc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnDef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnDef"}:
				_cbfbe.LnDef = NewCT_DefaultShapeDefinition()
				if _cbaage := d.DecodeElement(_cbfbe.LnDef, &_fefda); _cbaage != nil {
					return _cbaage
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "txDef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "txDef"}:
				_cbfbe.TxDef = NewCT_DefaultShapeDefinition()
				if _dadb := d.DecodeElement(_cbfbe.TxDef, &_fefda); _dadb != nil {
					return _dadb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_cbfbe.ExtLst = NewCT_OfficeArtExtensionList()
				if _gcdc := d.DecodeElement(_cbfbe.ExtLst, &_fefda); _gcdc != nil {
					return _gcdc
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ObjectStyleDefaults\u0020\u0025v", _fefda.Name)
				if _edfgd := d.Skip(); _edfgd != nil {
					return _edfgd
				}
			}
		case _g.EndElement:
			break _gdcgg
		case _g.CharData:
		}
	}
	return nil
}
func (_gddga *CT_Path2DCubicBezierTo) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fcffd:
	for {
		_fdde, _cabe := d.Token()
		if _cabe != nil {
			return _cabe
		}
		switch _ggeff := _fdde.(type) {
		case _g.StartElement:
			switch _ggeff.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pt"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pt"}:
				_gbfdeg := NewCT_AdjPoint2D()
				if _fcfce := d.DecodeElement(_gbfdeg, &_ggeff); _fcfce != nil {
					return _fcfce
				}
				_gddga.Pt = append(_gddga.Pt, _gbfdeg)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Path2DCubicBezierTo\u0020\u0025v", _ggeff.Name)
				if _ebfa := d.Skip(); _ebfa != nil {
					return _ebfa
				}
			}
		case _g.EndElement:
			break _fcffd
		case _g.CharData:
		}
	}
	return nil
}
func (_faeef *CT_TablePropertiesChoice) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_bdgdd:
	for {
		_abfdb, _eafaa := d.Token()
		if _eafaa != nil {
			return _eafaa
		}
		switch _fdefbg := _abfdb.(type) {
		case _g.StartElement:
			switch _fdefbg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tableStyle"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tableStyle"}:
				_faeef.TableStyle = NewCT_TableStyle()
				if _eagdb := d.DecodeElement(_faeef.TableStyle, &_fdefbg); _eagdb != nil {
					return _eagdb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tableStyleId"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tableStyleId"}:
				_faeef.TableStyleId = new(string)
				if _eggce := d.DecodeElement(_faeef.TableStyleId, &_fdefbg); _eggce != nil {
					return _eggce
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_TablePropertiesChoice\u0020%v", _fdefbg.Name)
				if _gfdcgb := d.Skip(); _gfdcgb != nil {
					return _gfdcgb
				}
			}
		case _g.EndElement:
			break _bdgdd
		case _g.CharData:
		}
	}
	return nil
}
func (_faac ST_PenAlignment) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_faac.String(), start)
}

// ValidateWithPath validates the CT_BaseStyles and its children, prefixing error messages with path
func (_ecgf *CT_BaseStyles) ValidateWithPath(path string) error {
	if _fabf := _ecgf.ClrScheme.ValidateWithPath(path + "\u002fClrScheme"); _fabf != nil {
		return _fabf
	}
	if _dggfd := _ecgf.FontScheme.ValidateWithPath(path + "/FontScheme"); _dggfd != nil {
		return _dggfd
	}
	if _fagf := _ecgf.FmtScheme.ValidateWithPath(path + "\u002fFmtScheme"); _fagf != nil {
		return _fagf
	}
	if _ecgf.ExtLst != nil {
		if _cbab := _ecgf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cbab != nil {
			return _cbab
		}
	}
	return nil
}

// ValidateWithPath validates the CT_FillEffect and its children, prefixing error messages with path
func (_gbegg *CT_FillEffect) ValidateWithPath(path string) error {
	if _gbegg.NoFill != nil {
		if _ggagf := _gbegg.NoFill.ValidateWithPath(path + "\u002fNoFill"); _ggagf != nil {
			return _ggagf
		}
	}
	if _gbegg.SolidFill != nil {
		if _ggdb := _gbegg.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _ggdb != nil {
			return _ggdb
		}
	}
	if _gbegg.GradFill != nil {
		if _dbgb := _gbegg.GradFill.ValidateWithPath(path + "\u002fGradFill"); _dbgb != nil {
			return _dbgb
		}
	}
	if _gbegg.BlipFill != nil {
		if _gdfbe := _gbegg.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _gdfbe != nil {
			return _gdfbe
		}
	}
	if _gbegg.PattFill != nil {
		if _ecgfb := _gbegg.PattFill.ValidateWithPath(path + "\u002fPattFill"); _ecgfb != nil {
			return _ecgfb
		}
	}
	if _gbegg.GrpFill != nil {
		if _eggeb := _gbegg.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _eggeb != nil {
			return _eggeb
		}
	}
	return nil
}

type CT_BaseStyles struct {
	ClrScheme  *CT_ColorScheme
	FontScheme *CT_FontScheme
	FmtScheme  *CT_StyleMatrix
	ExtLst     *CT_OfficeArtExtensionList
}

func NewCT_TextShapeAutofit() *CT_TextShapeAutofit { _fdcgd := &CT_TextShapeAutofit{}; return _fdcgd }
func NewCT_OfficeArtExtension() *CT_OfficeArtExtension {
	_ecegg := &CT_OfficeArtExtension{}
	return _ecegg
}
func NewEG_OfficeArtExtensionList() *EG_OfficeArtExtensionList {
	_cebab := &EG_OfficeArtExtensionList{}
	return _cebab
}

type CT_TableCol struct {
	WAttr  ST_Coordinate
	ExtLst *CT_OfficeArtExtensionList
}
type CT_PresetColor struct {
	ValAttr           ST_PresetColorVal
	EG_ColorTransform []*EG_ColorTransform
}

func (_fegdg *CT_SystemColor) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fegdg.ValAttr = ST_SystemColorVal(1)
	for _, _bccbb := range start.Attr {
		if _bccbb.Name.Local == "val" {
			_fegdg.ValAttr.UnmarshalXMLAttr(_bccbb)
			continue
		}
		if _bccbb.Name.Local == "lastClr" {
			_facb, _defae := _bccbb.Value, error(nil)
			if _defae != nil {
				return _defae
			}
			_fegdg.LastClrAttr = &_facb
			continue
		}
	}
_decad:
	for {
		_aecef, _baeb := d.Token()
		if _baeb != nil {
			return _baeb
		}
		switch _cfdf := _aecef.(type) {
		case _g.StartElement:
			switch _cfdf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_dgdgb := NewEG_ColorTransform()
				_dgdgb.Tint = NewCT_PositiveFixedPercentage()
				if _gaddaf := d.DecodeElement(_dgdgb.Tint, &_cfdf); _gaddaf != nil {
					return _gaddaf
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _dgdgb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "shade"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "shade"}:
				_aged := NewEG_ColorTransform()
				_aged.Shade = NewCT_PositiveFixedPercentage()
				if _feafg := d.DecodeElement(_aged.Shade, &_cfdf); _feafg != nil {
					return _feafg
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _aged)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "comp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "comp"}:
				_bddbc := NewEG_ColorTransform()
				_bddbc.Comp = NewCT_ComplementTransform()
				if _dgae := d.DecodeElement(_bddbc.Comp, &_cfdf); _dgae != nil {
					return _dgae
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _bddbc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "inv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "inv"}:
				_bbfa := NewEG_ColorTransform()
				_bbfa.Inv = NewCT_InverseTransform()
				if _acfda := d.DecodeElement(_bbfa.Inv, &_cfdf); _acfda != nil {
					return _acfda
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _bbfa)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gray"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gray"}:
				_edcddc := NewEG_ColorTransform()
				_edcddc.Gray = NewCT_GrayscaleTransform()
				if _afeac := d.DecodeElement(_edcddc.Gray, &_cfdf); _afeac != nil {
					return _afeac
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _edcddc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alpha"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alpha"}:
				_ffeea := NewEG_ColorTransform()
				_ffeea.Alpha = NewCT_PositiveFixedPercentage()
				if _fgbff := d.DecodeElement(_ffeea.Alpha, &_cfdf); _fgbff != nil {
					return _fgbff
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _ffeea)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaOff"}:
				_gcceae := NewEG_ColorTransform()
				_gcceae.AlphaOff = NewCT_FixedPercentage()
				if _afacc := d.DecodeElement(_gcceae.AlphaOff, &_cfdf); _afacc != nil {
					return _afacc
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _gcceae)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_cagec := NewEG_ColorTransform()
				_cagec.AlphaMod = NewCT_PositivePercentage()
				if _abdff := d.DecodeElement(_cagec.AlphaMod, &_cfdf); _abdff != nil {
					return _abdff
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _cagec)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hue"}:
				_gfafd := NewEG_ColorTransform()
				_gfafd.Hue = NewCT_PositiveFixedAngle()
				if _adaa := d.DecodeElement(_gfafd.Hue, &_cfdf); _adaa != nil {
					return _adaa
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _gfafd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueOff"}:
				_bgecf := NewEG_ColorTransform()
				_bgecf.HueOff = NewCT_Angle()
				if _ddggc := d.DecodeElement(_bgecf.HueOff, &_cfdf); _ddggc != nil {
					return _ddggc
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _bgecf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueMod"}:
				_gdfad := NewEG_ColorTransform()
				_gdfad.HueMod = NewCT_PositivePercentage()
				if _bgdab := d.DecodeElement(_gdfad.HueMod, &_cfdf); _bgdab != nil {
					return _bgdab
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _gdfad)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sat"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sat"}:
				_ggdd := NewEG_ColorTransform()
				_ggdd.Sat = NewCT_Percentage()
				if _eaggg := d.DecodeElement(_ggdd.Sat, &_cfdf); _eaggg != nil {
					return _eaggg
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _ggdd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satOff"}:
				_agbac := NewEG_ColorTransform()
				_agbac.SatOff = NewCT_Percentage()
				if _aafa := d.DecodeElement(_agbac.SatOff, &_cfdf); _aafa != nil {
					return _aafa
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _agbac)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satMod"}:
				_caaad := NewEG_ColorTransform()
				_caaad.SatMod = NewCT_Percentage()
				if _cdfdf := d.DecodeElement(_caaad.SatMod, &_cfdf); _cdfdf != nil {
					return _cdfdf
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _caaad)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_begcf := NewEG_ColorTransform()
				_begcf.Lum = NewCT_Percentage()
				if _daeab := d.DecodeElement(_begcf.Lum, &_cfdf); _daeab != nil {
					return _daeab
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _begcf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumOff"}:
				_dfbfb := NewEG_ColorTransform()
				_dfbfb.LumOff = NewCT_Percentage()
				if _ebea := d.DecodeElement(_dfbfb.LumOff, &_cfdf); _ebea != nil {
					return _ebea
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _dfbfb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumMod"}:
				_addeg := NewEG_ColorTransform()
				_addeg.LumMod = NewCT_Percentage()
				if _bcdbg := d.DecodeElement(_addeg.LumMod, &_cfdf); _bcdbg != nil {
					return _bcdbg
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _addeg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "red"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "red"}:
				_cbdba := NewEG_ColorTransform()
				_cbdba.Red = NewCT_Percentage()
				if _fdfa := d.DecodeElement(_cbdba.Red, &_cfdf); _fdfa != nil {
					return _fdfa
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _cbdba)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redOff"}:
				_fbcca := NewEG_ColorTransform()
				_fbcca.RedOff = NewCT_Percentage()
				if _baggc := d.DecodeElement(_fbcca.RedOff, &_cfdf); _baggc != nil {
					return _baggc
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _fbcca)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redMod"}:
				_fcege := NewEG_ColorTransform()
				_fcege.RedMod = NewCT_Percentage()
				if _gbbcc := d.DecodeElement(_fcege.RedMod, &_cfdf); _gbbcc != nil {
					return _gbbcc
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _fcege)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "green"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "green"}:
				_agcbb := NewEG_ColorTransform()
				_agcbb.Green = NewCT_Percentage()
				if _fdggd := d.DecodeElement(_agcbb.Green, &_cfdf); _fdggd != nil {
					return _fdggd
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _agcbb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenOff"}:
				_fcgee := NewEG_ColorTransform()
				_fcgee.GreenOff = NewCT_Percentage()
				if _ffbgg := d.DecodeElement(_fcgee.GreenOff, &_cfdf); _ffbgg != nil {
					return _ffbgg
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _fcgee)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenMod"}:
				_ffcge := NewEG_ColorTransform()
				_ffcge.GreenMod = NewCT_Percentage()
				if _bgafd := d.DecodeElement(_ffcge.GreenMod, &_cfdf); _bgafd != nil {
					return _bgafd
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _ffcge)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blue"}:
				_cddgfd := NewEG_ColorTransform()
				_cddgfd.Blue = NewCT_Percentage()
				if _afabf := d.DecodeElement(_cddgfd.Blue, &_cfdf); _afabf != nil {
					return _afabf
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _cddgfd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueOff"}:
				_fggge := NewEG_ColorTransform()
				_fggge.BlueOff = NewCT_Percentage()
				if _dgafe := d.DecodeElement(_fggge.BlueOff, &_cfdf); _dgafe != nil {
					return _dgafe
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _fggge)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueMod"}:
				_egbbb := NewEG_ColorTransform()
				_egbbb.BlueMod = NewCT_Percentage()
				if _bedeg := d.DecodeElement(_egbbb.BlueMod, &_cfdf); _bedeg != nil {
					return _bedeg
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _egbbb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gamma"}:
				_eebca := NewEG_ColorTransform()
				_eebca.Gamma = NewCT_GammaTransform()
				if _afbbag := d.DecodeElement(_eebca.Gamma, &_cfdf); _afbbag != nil {
					return _afbbag
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _eebca)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "invGamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "invGamma"}:
				_fbcdc := NewEG_ColorTransform()
				_fbcdc.InvGamma = NewCT_InverseGammaTransform()
				if _eggbc := d.DecodeElement(_fbcdc.InvGamma, &_cfdf); _eggbc != nil {
					return _eggbc
				}
				_fegdg.EG_ColorTransform = append(_fegdg.EG_ColorTransform, _fbcdc)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SystemColor\u0020\u0025v", _cfdf.Name)
				if _bcfgb := d.Skip(); _bcfgb != nil {
					return _bcfgb
				}
			}
		case _g.EndElement:
			break _decad
		case _g.CharData:
		}
	}
	return nil
}

type ST_BlipCompression byte

func NewCT_TablePropertiesChoice() *CT_TablePropertiesChoice {
	_dbccg := &CT_TablePropertiesChoice{}
	return _dbccg
}
func NewCT_NonVisualConnectorProperties() *CT_NonVisualConnectorProperties {
	_daadc := &CT_NonVisualConnectorProperties{}
	return _daadc
}

// ValidateWithPath validates the EG_Effect and its children, prefixing error messages with path
func (_cgdegf *EG_Effect) ValidateWithPath(path string) error {
	if _cgdegf.Cont != nil {
		if _edfca := _cgdegf.Cont.ValidateWithPath(path + "\u002fCont"); _edfca != nil {
			return _edfca
		}
	}
	if _cgdegf.Effect != nil {
		if _edbec := _cgdegf.Effect.ValidateWithPath(path + "\u002fEffect"); _edbec != nil {
			return _edbec
		}
	}
	if _cgdegf.AlphaBiLevel != nil {
		if _addc := _cgdegf.AlphaBiLevel.ValidateWithPath(path + "\u002fAlphaBiLevel"); _addc != nil {
			return _addc
		}
	}
	if _cgdegf.AlphaCeiling != nil {
		if _eebba := _cgdegf.AlphaCeiling.ValidateWithPath(path + "\u002fAlphaCeiling"); _eebba != nil {
			return _eebba
		}
	}
	if _cgdegf.AlphaFloor != nil {
		if _cagfe := _cgdegf.AlphaFloor.ValidateWithPath(path + "/AlphaFloor"); _cagfe != nil {
			return _cagfe
		}
	}
	if _cgdegf.AlphaInv != nil {
		if _bfagcd := _cgdegf.AlphaInv.ValidateWithPath(path + "\u002fAlphaInv"); _bfagcd != nil {
			return _bfagcd
		}
	}
	if _cgdegf.AlphaMod != nil {
		if _ddcdb := _cgdegf.AlphaMod.ValidateWithPath(path + "\u002fAlphaMod"); _ddcdb != nil {
			return _ddcdb
		}
	}
	if _cgdegf.AlphaModFix != nil {
		if _cedea := _cgdegf.AlphaModFix.ValidateWithPath(path + "\u002fAlphaModFix"); _cedea != nil {
			return _cedea
		}
	}
	if _cgdegf.AlphaOutset != nil {
		if _bfega := _cgdegf.AlphaOutset.ValidateWithPath(path + "\u002fAlphaOutset"); _bfega != nil {
			return _bfega
		}
	}
	if _cgdegf.AlphaRepl != nil {
		if _ddbbd := _cgdegf.AlphaRepl.ValidateWithPath(path + "\u002fAlphaRepl"); _ddbbd != nil {
			return _ddbbd
		}
	}
	if _cgdegf.BiLevel != nil {
		if _eaeg := _cgdegf.BiLevel.ValidateWithPath(path + "\u002fBiLevel"); _eaeg != nil {
			return _eaeg
		}
	}
	if _cgdegf.Blend != nil {
		if _egadd := _cgdegf.Blend.ValidateWithPath(path + "\u002fBlend"); _egadd != nil {
			return _egadd
		}
	}
	if _cgdegf.Blur != nil {
		if _gfcgdf := _cgdegf.Blur.ValidateWithPath(path + "\u002fBlur"); _gfcgdf != nil {
			return _gfcgdf
		}
	}
	if _cgdegf.ClrChange != nil {
		if _effge := _cgdegf.ClrChange.ValidateWithPath(path + "\u002fClrChange"); _effge != nil {
			return _effge
		}
	}
	if _cgdegf.ClrRepl != nil {
		if _efgafd := _cgdegf.ClrRepl.ValidateWithPath(path + "\u002fClrRepl"); _efgafd != nil {
			return _efgafd
		}
	}
	if _cgdegf.Duotone != nil {
		if _bafab := _cgdegf.Duotone.ValidateWithPath(path + "\u002fDuotone"); _bafab != nil {
			return _bafab
		}
	}
	if _cgdegf.Fill != nil {
		if _afdaaf := _cgdegf.Fill.ValidateWithPath(path + "\u002fFill"); _afdaaf != nil {
			return _afdaaf
		}
	}
	if _cgdegf.FillOverlay != nil {
		if _gfebe := _cgdegf.FillOverlay.ValidateWithPath(path + "\u002fFillOverlay"); _gfebe != nil {
			return _gfebe
		}
	}
	if _cgdegf.Glow != nil {
		if _fefdc := _cgdegf.Glow.ValidateWithPath(path + "\u002fGlow"); _fefdc != nil {
			return _fefdc
		}
	}
	if _cgdegf.Grayscl != nil {
		if _afcaec := _cgdegf.Grayscl.ValidateWithPath(path + "\u002fGrayscl"); _afcaec != nil {
			return _afcaec
		}
	}
	if _cgdegf.Hsl != nil {
		if _dggfe := _cgdegf.Hsl.ValidateWithPath(path + "\u002fHsl"); _dggfe != nil {
			return _dggfe
		}
	}
	if _cgdegf.InnerShdw != nil {
		if _baafdb := _cgdegf.InnerShdw.ValidateWithPath(path + "\u002fInnerShdw"); _baafdb != nil {
			return _baafdb
		}
	}
	if _cgdegf.Lum != nil {
		if _befbc := _cgdegf.Lum.ValidateWithPath(path + "\u002fLum"); _befbc != nil {
			return _befbc
		}
	}
	if _cgdegf.OuterShdw != nil {
		if _geafg := _cgdegf.OuterShdw.ValidateWithPath(path + "\u002fOuterShdw"); _geafg != nil {
			return _geafg
		}
	}
	if _cgdegf.PrstShdw != nil {
		if _gdfgf := _cgdegf.PrstShdw.ValidateWithPath(path + "\u002fPrstShdw"); _gdfgf != nil {
			return _gdfgf
		}
	}
	if _cgdegf.Reflection != nil {
		if _gadf := _cgdegf.Reflection.ValidateWithPath(path + "/Reflection"); _gadf != nil {
			return _gadf
		}
	}
	if _cgdegf.RelOff != nil {
		if _bcgbc := _cgdegf.RelOff.ValidateWithPath(path + "\u002fRelOff"); _bcgbc != nil {
			return _bcgbc
		}
	}
	if _cgdegf.SoftEdge != nil {
		if _ebadg := _cgdegf.SoftEdge.ValidateWithPath(path + "\u002fSoftEdge"); _ebadg != nil {
			return _ebadg
		}
	}
	if _cgdegf.Tint != nil {
		if _dbeae := _cgdegf.Tint.ValidateWithPath(path + "\u002fTint"); _dbeae != nil {
			return _dbeae
		}
	}
	if _cgdegf.Xfrm != nil {
		if _bffcd := _cgdegf.Xfrm.ValidateWithPath(path + "\u002fXfrm"); _bffcd != nil {
			return _bffcd
		}
	}
	return nil
}
func (_dcge *CT_GvmlShape) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dcge.NvSpPr = NewCT_GvmlShapeNonVisual()
	_dcge.SpPr = NewCT_ShapeProperties()
_aadcb:
	for {
		_cbee, _dacef := d.Token()
		if _dacef != nil {
			return _dacef
		}
		switch _gfbfg := _cbee.(type) {
		case _g.StartElement:
			switch _gfbfg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "nvSpPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "nvSpPr"}:
				if _cffg := d.DecodeElement(_dcge.NvSpPr, &_gfbfg); _cffg != nil {
					return _cffg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spPr"}:
				if _acgdd := d.DecodeElement(_dcge.SpPr, &_gfbfg); _acgdd != nil {
					return _acgdd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "txSp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "txSp"}:
				_dcge.TxSp = NewCT_GvmlTextShape()
				if _fbgd := d.DecodeElement(_dcge.TxSp, &_gfbfg); _fbgd != nil {
					return _fbgd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "style"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "style"}:
				_dcge.Style = NewCT_ShapeStyle()
				if _cccf := d.DecodeElement(_dcge.Style, &_gfbfg); _cccf != nil {
					return _cccf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_dcge.ExtLst = NewCT_OfficeArtExtensionList()
				if _ddeg := d.DecodeElement(_dcge.ExtLst, &_gfbfg); _ddeg != nil {
					return _ddeg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GvmlShape\u0020\u0025v", _gfbfg.Name)
				if _ddgga := d.Skip(); _ddgga != nil {
					return _ddgga
				}
			}
		case _g.EndElement:
			break _aadcb
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_AnimationElementChoice() *CT_AnimationElementChoice {
	_gef := &CT_AnimationElementChoice{}
	return _gef
}
func NewCT_GvmlTextShapeChoice() *CT_GvmlTextShapeChoice {
	_bbddf := &CT_GvmlTextShapeChoice{}
	return _bbddf
}

// Validate validates the CT_TableProperties and its children
func (_cgcd *CT_TableProperties) Validate() error {
	return _cgcd.ValidateWithPath("CT_TableProperties")
}
func (_bgdae ST_SystemColorVal) ValidateWithPath(path string) error {
	switch _bgdae {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bgdae))
	}
	return nil
}

// Validate validates the CT_AlphaInverseEffect and its children
func (_acd *CT_AlphaInverseEffect) Validate() error {
	return _acd.ValidateWithPath("CT_AlphaInverseEffect")
}

type CT_ShapeLocking struct {
	NoTextEditAttr         *bool
	ExtLst                 *CT_OfficeArtExtensionList
	NoGrpAttr              *bool
	NoSelectAttr           *bool
	NoRotAttr              *bool
	NoChangeAspectAttr     *bool
	NoMoveAttr             *bool
	NoResizeAttr           *bool
	NoEditPointsAttr       *bool
	NoAdjustHandlesAttr    *bool
	NoChangeArrowheadsAttr *bool
	NoChangeShapeTypeAttr  *bool
}

// Validate validates the CT_Blip and its children
func (_dbcab *CT_Blip) Validate() error          { return _dbcab.ValidateWithPath("CT_Blip") }
func NewCT_LuminanceEffect() *CT_LuminanceEffect { _eccc := &CT_LuminanceEffect{}; return _eccc }

type CT_TableBackgroundStyle struct {
	Fill      *CT_FillProperties
	FillRef   *CT_StyleMatrixReference
	Effect    *CT_EffectProperties
	EffectRef *CT_StyleMatrixReference
}
type CT_TextBulletTypefaceFollowText struct{}

func NewCT_BlipFillProperties() *CT_BlipFillProperties {
	_gcfb := &CT_BlipFillProperties{}
	return _gcfb
}
func (_fccbc *ST_AdjAngle) Validate() error      { return _fccbc.ValidateWithPath("") }
func NewCT_EffectReference() *CT_EffectReference { _gefa := &CT_EffectReference{}; return _gefa }
func (_aeebe *ST_PositiveFixedPercentage) ValidateWithPath(path string) error {
	_gaagd := []string{}
	if _aeebe.ST_PositiveFixedPercentageDecimal != nil {
		_gaagd = append(_gaagd, "ST_PositiveFixedPercentageDecimal")
	}
	if _aeebe.ST_PositiveFixedPercentage != nil {
		if _cdefc := _aeebe.ST_PositiveFixedPercentage.ValidateWithPath(path + "/ST_PositiveFixedPercentage"); _cdefc != nil {
			return _cdefc
		}
		_gaagd = append(_gaagd, "ST_PositiveFixedPercentage")
	}
	if len(_gaagd) > 1 {
		return _dcf.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _gaagd)
	}
	return nil
}
func NewCT_Scene3D() *CT_Scene3D {
	_dcbag := &CT_Scene3D{}
	_dcbag.Camera = NewCT_Camera()
	_dcbag.LightRig = NewCT_LightRig()
	return _dcbag
}
func (_ccace *CT_Path2DList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _ccace.Path != nil {
		_efdd := _g.StartElement{Name: _g.Name{Local: "a:path"}}
		for _, _fffa := range _ccace.Path {
			e.EncodeElement(_fffa, _efdd)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ggbbdf *ST_AnimationBuildType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_eeecd, _cbgfaf := d.Token()
	if _cbgfaf != nil {
		return _cbgfaf
	}
	if _gefgg, _dgdbd := _eeecd.(_g.EndElement); _dgdbd && _gefgg.Name == start.Name {
		*_ggbbdf = 1
		return nil
	}
	if _acbeb, _eedda := _eeecd.(_g.CharData); !_eedda {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eeecd)
	} else {
		switch string(_acbeb) {
		case "":
			*_ggbbdf = 0
		case "allAtOnce":
			*_ggbbdf = 1
		}
	}
	_eeecd, _cbgfaf = d.Token()
	if _cbgfaf != nil {
		return _cbgfaf
	}
	if _ddbcc, _ddbbe := _eeecd.(_g.EndElement); _ddbbe && _ddbcc.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eeecd)
}
func (_bggf *CT_BaseStylesOverride) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _bggf.ClrScheme != nil {
		_fbb := _g.StartElement{Name: _g.Name{Local: "a:clrScheme"}}
		e.EncodeElement(_bggf.ClrScheme, _fbb)
	}
	if _bggf.FontScheme != nil {
		_ggef := _g.StartElement{Name: _g.Name{Local: "a:fontScheme"}}
		e.EncodeElement(_bggf.FontScheme, _ggef)
	}
	if _bggf.FmtScheme != nil {
		_cefc := _g.StartElement{Name: _g.Name{Local: "a:fmtScheme"}}
		e.EncodeElement(_bggf.FmtScheme, _cefc)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_ColorReplaceEffect struct {
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
}

// ValidateWithPath validates the CT_ShapeProperties and its children, prefixing error messages with path
func (_gbcgc *CT_ShapeProperties) ValidateWithPath(path string) error {
	if _ffed := _gbcgc.BwModeAttr.ValidateWithPath(path + "/BwModeAttr"); _ffed != nil {
		return _ffed
	}
	if _gbcgc.Xfrm != nil {
		if _gfab := _gbcgc.Xfrm.ValidateWithPath(path + "\u002fXfrm"); _gfab != nil {
			return _gfab
		}
	}
	if _gbcgc.CustGeom != nil {
		if _bcecd := _gbcgc.CustGeom.ValidateWithPath(path + "\u002fCustGeom"); _bcecd != nil {
			return _bcecd
		}
	}
	if _gbcgc.PrstGeom != nil {
		if _afbgb := _gbcgc.PrstGeom.ValidateWithPath(path + "\u002fPrstGeom"); _afbgb != nil {
			return _afbgb
		}
	}
	if _gbcgc.NoFill != nil {
		if _cfcaf := _gbcgc.NoFill.ValidateWithPath(path + "\u002fNoFill"); _cfcaf != nil {
			return _cfcaf
		}
	}
	if _gbcgc.SolidFill != nil {
		if _cgbca := _gbcgc.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _cgbca != nil {
			return _cgbca
		}
	}
	if _gbcgc.GradFill != nil {
		if _addfd := _gbcgc.GradFill.ValidateWithPath(path + "\u002fGradFill"); _addfd != nil {
			return _addfd
		}
	}
	if _gbcgc.BlipFill != nil {
		if _facff := _gbcgc.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _facff != nil {
			return _facff
		}
	}
	if _gbcgc.PattFill != nil {
		if _fbac := _gbcgc.PattFill.ValidateWithPath(path + "\u002fPattFill"); _fbac != nil {
			return _fbac
		}
	}
	if _gbcgc.GrpFill != nil {
		if _aceag := _gbcgc.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _aceag != nil {
			return _aceag
		}
	}
	if _gbcgc.Ln != nil {
		if _ggece := _gbcgc.Ln.ValidateWithPath(path + "\u002fLn"); _ggece != nil {
			return _ggece
		}
	}
	if _gbcgc.EffectLst != nil {
		if _fbffd := _gbcgc.EffectLst.ValidateWithPath(path + "\u002fEffectLst"); _fbffd != nil {
			return _fbffd
		}
	}
	if _gbcgc.EffectDag != nil {
		if _efada := _gbcgc.EffectDag.ValidateWithPath(path + "\u002fEffectDag"); _efada != nil {
			return _efada
		}
	}
	if _gbcgc.Scene3d != nil {
		if _aadcc := _gbcgc.Scene3d.ValidateWithPath(path + "\u002fScene3d"); _aadcc != nil {
			return _aadcc
		}
	}
	if _gbcgc.Sp3d != nil {
		if _babab := _gbcgc.Sp3d.ValidateWithPath(path + "\u002fSp3d"); _babab != nil {
			return _babab
		}
	}
	if _gbcgc.ExtLst != nil {
		if _gedff := _gbcgc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gedff != nil {
			return _gedff
		}
	}
	return nil
}
func ParseUnionST_AnimationDgmBuildType(s string) (ST_AnimationDgmBuildType, error) {
	_ddfbfg := ST_AnimationDgmBuildType{}
	switch s {
	case "allAtOnce":
		_ddfbfg.ST_AnimationBuildType = ST_AnimationBuildTypeAllAtOnce
	case "one":
		_ddfbfg.ST_AnimationDgmOnlyBuildType = ST_AnimationDgmOnlyBuildTypeOne
	case "lvlOne":
		_ddfbfg.ST_AnimationDgmOnlyBuildType = ST_AnimationDgmOnlyBuildTypeLvlOne
	case "lvlAtOnce":
		_ddfbfg.ST_AnimationDgmOnlyBuildType = ST_AnimationDgmOnlyBuildTypeLvlAtOnce
	}
	return _ddfbfg, nil
}

// ValidateWithPath validates the EG_LineJoinProperties and its children, prefixing error messages with path
func (_cbceb *EG_LineJoinProperties) ValidateWithPath(path string) error {
	if _cbceb.Round != nil {
		if _bfdgd := _cbceb.Round.ValidateWithPath(path + "\u002fRound"); _bfdgd != nil {
			return _bfdgd
		}
	}
	if _cbceb.Bevel != nil {
		if _ggeda := _cbceb.Bevel.ValidateWithPath(path + "\u002fBevel"); _ggeda != nil {
			return _ggeda
		}
	}
	if _cbceb.Miter != nil {
		if _fbcgc := _cbceb.Miter.ValidateWithPath(path + "\u002fMiter"); _fbcgc != nil {
			return _fbcgc
		}
	}
	return nil
}
func (_ffdd *CT_PresetShadowEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_bdgcg, _dacgc := _ffdd.PrstAttr.MarshalXMLAttr(_g.Name{Local: "prst"})
	if _dacgc != nil {
		return _dacgc
	}
	start.Attr = append(start.Attr, _bdgcg)
	if _ffdd.DistAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dist"}, Value: _dcf.Sprintf("\u0025v", *_ffdd.DistAttr)})
	}
	if _ffdd.DirAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dir"}, Value: _dcf.Sprintf("\u0025v", *_ffdd.DirAttr)})
	}
	e.EncodeToken(start)
	if _ffdd.ScrgbClr != nil {
		_cccgg := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_ffdd.ScrgbClr, _cccgg)
	}
	if _ffdd.SrgbClr != nil {
		_fcdcab := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_ffdd.SrgbClr, _fcdcab)
	}
	if _ffdd.HslClr != nil {
		_dgcaf := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_ffdd.HslClr, _dgcaf)
	}
	if _ffdd.SysClr != nil {
		_cccb := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_ffdd.SysClr, _cccb)
	}
	if _ffdd.SchemeClr != nil {
		_dccecf := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_ffdd.SchemeClr, _dccecf)
	}
	if _ffdd.PrstClr != nil {
		_dbfgb := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_ffdd.PrstClr, _dbfgb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_TextSpacingPoint struct{ ValAttr int32 }
type CT_GvmlUseShapeRectangle struct{}

func (_dccdc *CT_Path2D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dccdc.WAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "w"}, Value: _dcf.Sprintf("\u0025v", *_dccdc.WAttr)})
	}
	if _dccdc.HAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "h"}, Value: _dcf.Sprintf("\u0025v", *_dccdc.HAttr)})
	}
	if _dccdc.FillAttr != ST_PathFillModeUnset {
		_efgf, _dcabf := _dccdc.FillAttr.MarshalXMLAttr(_g.Name{Local: "fill"})
		if _dcabf != nil {
			return _dcabf
		}
		start.Attr = append(start.Attr, _efgf)
	}
	if _dccdc.StrokeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "stroke"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dccdc.StrokeAttr))})
	}
	if _dccdc.ExtrusionOkAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "extrusionOk"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dccdc.ExtrusionOkAttr))})
	}
	e.EncodeToken(start)
	if _dccdc.Close != nil {
		_dcfef := _g.StartElement{Name: _g.Name{Local: "a:close"}}
		for _, _bfcec := range _dccdc.Close {
			e.EncodeElement(_bfcec, _dcfef)
		}
	}
	if _dccdc.MoveTo != nil {
		_beee := _g.StartElement{Name: _g.Name{Local: "a:moveTo"}}
		for _, _edgd := range _dccdc.MoveTo {
			e.EncodeElement(_edgd, _beee)
		}
	}
	if _dccdc.LnTo != nil {
		_egbf := _g.StartElement{Name: _g.Name{Local: "a:lnTo"}}
		for _, _abda := range _dccdc.LnTo {
			e.EncodeElement(_abda, _egbf)
		}
	}
	if _dccdc.ArcTo != nil {
		_bbgab := _g.StartElement{Name: _g.Name{Local: "a:arcTo"}}
		for _, _cbdabe := range _dccdc.ArcTo {
			e.EncodeElement(_cbdabe, _bbgab)
		}
	}
	if _dccdc.QuadBezTo != nil {
		_ccggc := _g.StartElement{Name: _g.Name{Local: "a:quadBezTo"}}
		for _, _aagff := range _dccdc.QuadBezTo {
			e.EncodeElement(_aagff, _ccggc)
		}
	}
	if _dccdc.CubicBezTo != nil {
		_fdgaa := _g.StartElement{Name: _g.Name{Local: "a:cubicBezTo"}}
		for _, _ggefb := range _dccdc.CubicBezTo {
			e.EncodeElement(_ggefb, _fdgaa)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type EG_LineFillProperties struct {
	NoFill    *CT_NoFillProperties
	SolidFill *CT_SolidColorFillProperties
	GradFill  *CT_GradientFillProperties
	PattFill  *CT_PatternFillProperties
}

func (_bgfgb *ST_PresetColorVal) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gdbde, _fdege := d.Token()
	if _fdege != nil {
		return _fdege
	}
	if _fcgfg, _febfg := _gdbde.(_g.EndElement); _febfg && _fcgfg.Name == start.Name {
		*_bgfgb = 1
		return nil
	}
	if _dcbdd, _eaaa := _gdbde.(_g.CharData); !_eaaa {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gdbde)
	} else {
		switch string(_dcbdd) {
		case "":
			*_bgfgb = 0
		case "aliceBlue":
			*_bgfgb = 1
		case "antiqueWhite":
			*_bgfgb = 2
		case "aqua":
			*_bgfgb = 3
		case "aquamarine":
			*_bgfgb = 4
		case "azure":
			*_bgfgb = 5
		case "beige":
			*_bgfgb = 6
		case "bisque":
			*_bgfgb = 7
		case "black":
			*_bgfgb = 8
		case "blanchedAlmond":
			*_bgfgb = 9
		case "blue":
			*_bgfgb = 10
		case "blueViolet":
			*_bgfgb = 11
		case "brown":
			*_bgfgb = 12
		case "burlyWood":
			*_bgfgb = 13
		case "cadetBlue":
			*_bgfgb = 14
		case "chartreuse":
			*_bgfgb = 15
		case "chocolate":
			*_bgfgb = 16
		case "coral":
			*_bgfgb = 17
		case "cornflowerBlue":
			*_bgfgb = 18
		case "cornsilk":
			*_bgfgb = 19
		case "crimson":
			*_bgfgb = 20
		case "cyan":
			*_bgfgb = 21
		case "darkBlue":
			*_bgfgb = 22
		case "darkCyan":
			*_bgfgb = 23
		case "darkGoldenrod":
			*_bgfgb = 24
		case "darkGray":
			*_bgfgb = 25
		case "darkGrey":
			*_bgfgb = 26
		case "darkGreen":
			*_bgfgb = 27
		case "darkKhaki":
			*_bgfgb = 28
		case "darkMagenta":
			*_bgfgb = 29
		case "darkOliveGreen":
			*_bgfgb = 30
		case "darkOrange":
			*_bgfgb = 31
		case "darkOrchid":
			*_bgfgb = 32
		case "darkRed":
			*_bgfgb = 33
		case "darkSalmon":
			*_bgfgb = 34
		case "darkSeaGreen":
			*_bgfgb = 35
		case "darkSlateBlue":
			*_bgfgb = 36
		case "darkSlateGray":
			*_bgfgb = 37
		case "darkSlateGrey":
			*_bgfgb = 38
		case "darkTurquoise":
			*_bgfgb = 39
		case "darkViolet":
			*_bgfgb = 40
		case "dkBlue":
			*_bgfgb = 41
		case "dkCyan":
			*_bgfgb = 42
		case "dkGoldenrod":
			*_bgfgb = 43
		case "dkGray":
			*_bgfgb = 44
		case "dkGrey":
			*_bgfgb = 45
		case "dkGreen":
			*_bgfgb = 46
		case "dkKhaki":
			*_bgfgb = 47
		case "dkMagenta":
			*_bgfgb = 48
		case "dkOliveGreen":
			*_bgfgb = 49
		case "dkOrange":
			*_bgfgb = 50
		case "dkOrchid":
			*_bgfgb = 51
		case "dkRed":
			*_bgfgb = 52
		case "dkSalmon":
			*_bgfgb = 53
		case "dkSeaGreen":
			*_bgfgb = 54
		case "dkSlateBlue":
			*_bgfgb = 55
		case "dkSlateGray":
			*_bgfgb = 56
		case "dkSlateGrey":
			*_bgfgb = 57
		case "dkTurquoise":
			*_bgfgb = 58
		case "dkViolet":
			*_bgfgb = 59
		case "deepPink":
			*_bgfgb = 60
		case "deepSkyBlue":
			*_bgfgb = 61
		case "dimGray":
			*_bgfgb = 62
		case "dimGrey":
			*_bgfgb = 63
		case "dodgerBlue":
			*_bgfgb = 64
		case "firebrick":
			*_bgfgb = 65
		case "floralWhite":
			*_bgfgb = 66
		case "forestGreen":
			*_bgfgb = 67
		case "fuchsia":
			*_bgfgb = 68
		case "gainsboro":
			*_bgfgb = 69
		case "ghostWhite":
			*_bgfgb = 70
		case "gold":
			*_bgfgb = 71
		case "goldenrod":
			*_bgfgb = 72
		case "gray":
			*_bgfgb = 73
		case "grey":
			*_bgfgb = 74
		case "green":
			*_bgfgb = 75
		case "greenYellow":
			*_bgfgb = 76
		case "honeydew":
			*_bgfgb = 77
		case "hotPink":
			*_bgfgb = 78
		case "indianRed":
			*_bgfgb = 79
		case "indigo":
			*_bgfgb = 80
		case "ivory":
			*_bgfgb = 81
		case "khaki":
			*_bgfgb = 82
		case "lavender":
			*_bgfgb = 83
		case "lavenderBlush":
			*_bgfgb = 84
		case "lawnGreen":
			*_bgfgb = 85
		case "lemonChiffon":
			*_bgfgb = 86
		case "lightBlue":
			*_bgfgb = 87
		case "lightCoral":
			*_bgfgb = 88
		case "lightCyan":
			*_bgfgb = 89
		case "lightGoldenrodYellow":
			*_bgfgb = 90
		case "lightGray":
			*_bgfgb = 91
		case "lightGrey":
			*_bgfgb = 92
		case "lightGreen":
			*_bgfgb = 93
		case "lightPink":
			*_bgfgb = 94
		case "lightSalmon":
			*_bgfgb = 95
		case "lightSeaGreen":
			*_bgfgb = 96
		case "lightSkyBlue":
			*_bgfgb = 97
		case "lightSlateGray":
			*_bgfgb = 98
		case "lightSlateGrey":
			*_bgfgb = 99
		case "lightSteelBlue":
			*_bgfgb = 100
		case "lightYellow":
			*_bgfgb = 101
		case "ltBlue":
			*_bgfgb = 102
		case "ltCoral":
			*_bgfgb = 103
		case "ltCyan":
			*_bgfgb = 104
		case "ltGoldenrodYellow":
			*_bgfgb = 105
		case "ltGray":
			*_bgfgb = 106
		case "ltGrey":
			*_bgfgb = 107
		case "ltGreen":
			*_bgfgb = 108
		case "ltPink":
			*_bgfgb = 109
		case "ltSalmon":
			*_bgfgb = 110
		case "ltSeaGreen":
			*_bgfgb = 111
		case "ltSkyBlue":
			*_bgfgb = 112
		case "ltSlateGray":
			*_bgfgb = 113
		case "ltSlateGrey":
			*_bgfgb = 114
		case "ltSteelBlue":
			*_bgfgb = 115
		case "ltYellow":
			*_bgfgb = 116
		case "lime":
			*_bgfgb = 117
		case "limeGreen":
			*_bgfgb = 118
		case "linen":
			*_bgfgb = 119
		case "magenta":
			*_bgfgb = 120
		case "maroon":
			*_bgfgb = 121
		case "medAquamarine":
			*_bgfgb = 122
		case "medBlue":
			*_bgfgb = 123
		case "medOrchid":
			*_bgfgb = 124
		case "medPurple":
			*_bgfgb = 125
		case "medSeaGreen":
			*_bgfgb = 126
		case "medSlateBlue":
			*_bgfgb = 127
		case "medSpringGreen":
			*_bgfgb = 128
		case "medTurquoise":
			*_bgfgb = 129
		case "medVioletRed":
			*_bgfgb = 130
		case "mediumAquamarine":
			*_bgfgb = 131
		case "mediumBlue":
			*_bgfgb = 132
		case "mediumOrchid":
			*_bgfgb = 133
		case "mediumPurple":
			*_bgfgb = 134
		case "mediumSeaGreen":
			*_bgfgb = 135
		case "mediumSlateBlue":
			*_bgfgb = 136
		case "mediumSpringGreen":
			*_bgfgb = 137
		case "mediumTurquoise":
			*_bgfgb = 138
		case "mediumVioletRed":
			*_bgfgb = 139
		case "midnightBlue":
			*_bgfgb = 140
		case "mintCream":
			*_bgfgb = 141
		case "mistyRose":
			*_bgfgb = 142
		case "moccasin":
			*_bgfgb = 143
		case "navajoWhite":
			*_bgfgb = 144
		case "navy":
			*_bgfgb = 145
		case "oldLace":
			*_bgfgb = 146
		case "olive":
			*_bgfgb = 147
		case "oliveDrab":
			*_bgfgb = 148
		case "orange":
			*_bgfgb = 149
		case "orangeRed":
			*_bgfgb = 150
		case "orchid":
			*_bgfgb = 151
		case "paleGoldenrod":
			*_bgfgb = 152
		case "paleGreen":
			*_bgfgb = 153
		case "paleTurquoise":
			*_bgfgb = 154
		case "paleVioletRed":
			*_bgfgb = 155
		case "papayaWhip":
			*_bgfgb = 156
		case "peachPuff":
			*_bgfgb = 157
		case "peru":
			*_bgfgb = 158
		case "pink":
			*_bgfgb = 159
		case "plum":
			*_bgfgb = 160
		case "powderBlue":
			*_bgfgb = 161
		case "purple":
			*_bgfgb = 162
		case "red":
			*_bgfgb = 163
		case "rosyBrown":
			*_bgfgb = 164
		case "royalBlue":
			*_bgfgb = 165
		case "saddleBrown":
			*_bgfgb = 166
		case "salmon":
			*_bgfgb = 167
		case "sandyBrown":
			*_bgfgb = 168
		case "seaGreen":
			*_bgfgb = 169
		case "seaShell":
			*_bgfgb = 170
		case "sienna":
			*_bgfgb = 171
		case "silver":
			*_bgfgb = 172
		case "skyBlue":
			*_bgfgb = 173
		case "slateBlue":
			*_bgfgb = 174
		case "slateGray":
			*_bgfgb = 175
		case "slateGrey":
			*_bgfgb = 176
		case "snow":
			*_bgfgb = 177
		case "springGreen":
			*_bgfgb = 178
		case "steelBlue":
			*_bgfgb = 179
		case "tan":
			*_bgfgb = 180
		case "teal":
			*_bgfgb = 181
		case "thistle":
			*_bgfgb = 182
		case "tomato":
			*_bgfgb = 183
		case "turquoise":
			*_bgfgb = 184
		case "violet":
			*_bgfgb = 185
		case "wheat":
			*_bgfgb = 186
		case "white":
			*_bgfgb = 187
		case "whiteSmoke":
			*_bgfgb = 188
		case "yellow":
			*_bgfgb = 189
		case "yellowGreen":
			*_bgfgb = 190
		}
	}
	_gdbde, _fdege = d.Token()
	if _fdege != nil {
		return _fdege
	}
	if _cagegf, _afacfd := _gdbde.(_g.EndElement); _afacfd && _cagegf.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gdbde)
}
func (_daagee *ST_FontCollectionIndex) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_daagee = 0
	case "major":
		*_daagee = 1
	case "minor":
		*_daagee = 2
	case "none":
		*_daagee = 3
	}
	return nil
}
func NewCT_Cell3D() *CT_Cell3D { _dffd := &CT_Cell3D{}; _dffd.Bevel = NewCT_Bevel(); return _dffd }
func _bfead(_abcde bool) uint8 {
	if _abcde {
		return 1
	}
	return 0
}

// ValidateWithPath validates the CT_OfficeStyleSheet and its children, prefixing error messages with path
func (_ebgad *CT_OfficeStyleSheet) ValidateWithPath(path string) error {
	if _fbadbc := _ebgad.ThemeElements.ValidateWithPath(path + "\u002fThemeElements"); _fbadbc != nil {
		return _fbadbc
	}
	if _ebgad.ObjectDefaults != nil {
		if _bgef := _ebgad.ObjectDefaults.ValidateWithPath(path + "\u002fObjectDefaults"); _bgef != nil {
			return _bgef
		}
	}
	if _ebgad.ExtraClrSchemeLst != nil {
		if _bcggg := _ebgad.ExtraClrSchemeLst.ValidateWithPath(path + "\u002fExtraClrSchemeLst"); _bcggg != nil {
			return _bcggg
		}
	}
	if _ebgad.CustClrLst != nil {
		if _abba := _ebgad.CustClrLst.ValidateWithPath(path + "/CustClrLst"); _abba != nil {
			return _abba
		}
	}
	if _ebgad.ExtLst != nil {
		if _gbfea := _ebgad.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gbfea != nil {
			return _gbfea
		}
	}
	return nil
}
func (_caacg ST_BevelPresetType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_aagfe := _g.Attr{}
	_aagfe.Name = name
	switch _caacg {
	case ST_BevelPresetTypeUnset:
		_aagfe.Value = ""
	case ST_BevelPresetTypeRelaxedInset:
		_aagfe.Value = "relaxedInset"
	case ST_BevelPresetTypeCircle:
		_aagfe.Value = "circle"
	case ST_BevelPresetTypeSlope:
		_aagfe.Value = "slope"
	case ST_BevelPresetTypeCross:
		_aagfe.Value = "cross"
	case ST_BevelPresetTypeAngle:
		_aagfe.Value = "angle"
	case ST_BevelPresetTypeSoftRound:
		_aagfe.Value = "softRound"
	case ST_BevelPresetTypeConvex:
		_aagfe.Value = "convex"
	case ST_BevelPresetTypeCoolSlant:
		_aagfe.Value = "coolSlant"
	case ST_BevelPresetTypeDivot:
		_aagfe.Value = "divot"
	case ST_BevelPresetTypeRiblet:
		_aagfe.Value = "riblet"
	case ST_BevelPresetTypeHardEdge:
		_aagfe.Value = "hardEdge"
	case ST_BevelPresetTypeArtDeco:
		_aagfe.Value = "artDeco"
	}
	return _aagfe, nil
}
func NewCT_TextSpacing() *CT_TextSpacing   { _dedcg := &CT_TextSpacing{}; return _dedcg }
func NewCT_ShapeLocking() *CT_ShapeLocking { _gdaefb := &CT_ShapeLocking{}; return _gdaefb }
func (_dff *CT_Backdrop) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dff.Anchor = NewCT_Point3D()
	_dff.Norm = NewCT_Vector3D()
	_dff.Up = NewCT_Vector3D()
_ffb:
	for {
		_gac, _gaca := d.Token()
		if _gaca != nil {
			return _gaca
		}
		switch _cdec := _gac.(type) {
		case _g.StartElement:
			switch _cdec.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "anchor"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "anchor"}:
				if _ede := d.DecodeElement(_dff.Anchor, &_cdec); _ede != nil {
					return _ede
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "norm"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "norm"}:
				if _cced := d.DecodeElement(_dff.Norm, &_cdec); _cced != nil {
					return _cced
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "up"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "up"}:
				if _dedg := d.DecodeElement(_dff.Up, &_cdec); _dedg != nil {
					return _dedg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_dff.ExtLst = NewCT_OfficeArtExtensionList()
				if _afb := d.DecodeElement(_dff.ExtLst, &_cdec); _afb != nil {
					return _afb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Backdrop\u0020\u0025v", _cdec.Name)
				if _bfec := d.Skip(); _bfec != nil {
					return _bfec
				}
			}
		case _g.EndElement:
			break _ffb
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_AlphaInverseEffect() *CT_AlphaInverseEffect { _gfd := &CT_AlphaInverseEffect{}; return _gfd }
func (_bebcbe ST_TextShapeType) ValidateWithPath(path string) error {
	switch _bebcbe {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bebcbe))
	}
	return nil
}
func (_dggbdb *ST_TextHorzOverflowType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dacde, _cddfc := d.Token()
	if _cddfc != nil {
		return _cddfc
	}
	if _affaa, _fbdeb := _dacde.(_g.EndElement); _fbdeb && _affaa.Name == start.Name {
		*_dggbdb = 1
		return nil
	}
	if _fdaafc, _cdaegd := _dacde.(_g.CharData); !_cdaegd {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dacde)
	} else {
		switch string(_fdaafc) {
		case "":
			*_dggbdb = 0
		case "overflow":
			*_dggbdb = 1
		case "clip":
			*_dggbdb = 2
		}
	}
	_dacde, _cddfc = d.Token()
	if _cddfc != nil {
		return _cddfc
	}
	if _ccbcg, _affec := _dacde.(_g.EndElement); _affec && _ccbcg.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dacde)
}
func (_acgcbf *CT_TransformEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _aegde := range start.Attr {
		if _aegde.Name.Local == "sx" {
			_ddgff, _beeag := ParseUnionST_Percentage(_aegde.Value)
			if _beeag != nil {
				return _beeag
			}
			_acgcbf.SxAttr = &_ddgff
			continue
		}
		if _aegde.Name.Local == "sy" {
			_acfg, _deced := ParseUnionST_Percentage(_aegde.Value)
			if _deced != nil {
				return _deced
			}
			_acgcbf.SyAttr = &_acfg
			continue
		}
		if _aegde.Name.Local == "kx" {
			_effba, _adeef := _e.ParseInt(_aegde.Value, 10, 32)
			if _adeef != nil {
				return _adeef
			}
			_beccc := int32(_effba)
			_acgcbf.KxAttr = &_beccc
			continue
		}
		if _aegde.Name.Local == "ky" {
			_edgc, _badafe := _e.ParseInt(_aegde.Value, 10, 32)
			if _badafe != nil {
				return _badafe
			}
			_eabca := int32(_edgc)
			_acgcbf.KyAttr = &_eabca
			continue
		}
		if _aegde.Name.Local == "tx" {
			_ggbgf, _cegcf := ParseUnionST_Coordinate(_aegde.Value)
			if _cegcf != nil {
				return _cegcf
			}
			_acgcbf.TxAttr = &_ggbgf
			continue
		}
		if _aegde.Name.Local == "ty" {
			_gafad, _ffccc := ParseUnionST_Coordinate(_aegde.Value)
			if _ffccc != nil {
				return _ffccc
			}
			_acgcbf.TyAttr = &_gafad
			continue
		}
	}
	for {
		_cfded, _aabfd := d.Token()
		if _aabfd != nil {
			return _dcf.Errorf("parsing\u0020CT_TransformEffect:\u0020\u0025s", _aabfd)
		}
		if _ddfdfa, _gabdc := _cfded.(_g.EndElement); _gabdc && _ddfdfa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cffcd *CT_EmptyElement) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_bcfda, _ggbdf := d.Token()
		if _ggbdf != nil {
			return _dcf.Errorf("parsing CT_EmptyElement:\u0020\u0025s", _ggbdf)
		}
		if _egcaf, _geeec := _bcfda.(_g.EndElement); _geeec && _egcaf.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_TableGrid and its children
func (_gbcca *CT_TableGrid) Validate() error { return _gbcca.ValidateWithPath("CT_TableGrid") }

type CT_NonVisualDrawingShapeProps struct {
	TxBoxAttr *bool
	SpLocks   *CT_ShapeLocking
	ExtLst    *CT_OfficeArtExtensionList
}

// ValidateWithPath validates the CT_TextCharBullet and its children, prefixing error messages with path
func (_dbbdb *CT_TextCharBullet) ValidateWithPath(path string) error { return nil }
func (_aegaa *CT_RelativeRect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _aedf := range start.Attr {
		if _aedf.Name.Local == "l" {
			_edadg, _fadfd := ParseUnionST_Percentage(_aedf.Value)
			if _fadfd != nil {
				return _fadfd
			}
			_aegaa.LAttr = &_edadg
			continue
		}
		if _aedf.Name.Local == "t" {
			_fffcc, _fcafcc := ParseUnionST_Percentage(_aedf.Value)
			if _fcafcc != nil {
				return _fcafcc
			}
			_aegaa.TAttr = &_fffcc
			continue
		}
		if _aedf.Name.Local == "r" {
			_gddfa, _afaec := ParseUnionST_Percentage(_aedf.Value)
			if _afaec != nil {
				return _afaec
			}
			_aegaa.RAttr = &_gddfa
			continue
		}
		if _aedf.Name.Local == "b" {
			_dacgf, _gdgfa := ParseUnionST_Percentage(_aedf.Value)
			if _gdgfa != nil {
				return _gdgfa
			}
			_aegaa.BAttr = &_dacgf
			continue
		}
	}
	for {
		_agbfc, _eacf := d.Token()
		if _eacf != nil {
			return _dcf.Errorf("parsing CT_RelativeRect:\u0020\u0025s", _eacf)
		}
		if _badgg, _ceaaa := _agbfc.(_g.EndElement); _ceaaa && _badgg.Name == start.Name {
			break
		}
	}
	return nil
}

// ST_AdjCoordinate is a union type
type ST_AdjCoordinate struct {
	ST_Coordinate    *ST_Coordinate
	ST_GeomGuideName *string
}

func (_acdb *CT_CustomGeometry2D) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_acdb.PathLst = NewCT_Path2DList()
_fdbd:
	for {
		_decgb, _fccf := d.Token()
		if _fccf != nil {
			return _fccf
		}
		switch _eadfb := _decgb.(type) {
		case _g.StartElement:
			switch _eadfb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "avLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "avLst"}:
				_acdb.AvLst = NewCT_GeomGuideList()
				if _dddef := d.DecodeElement(_acdb.AvLst, &_eadfb); _dddef != nil {
					return _dddef
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gdLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gdLst"}:
				_acdb.GdLst = NewCT_GeomGuideList()
				if _baaa := d.DecodeElement(_acdb.GdLst, &_eadfb); _baaa != nil {
					return _baaa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ahLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ahLst"}:
				_acdb.AhLst = NewCT_AdjustHandleList()
				if _bagfa := d.DecodeElement(_acdb.AhLst, &_eadfb); _bagfa != nil {
					return _bagfa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cxnLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cxnLst"}:
				_acdb.CxnLst = NewCT_ConnectionSiteList()
				if _bgfc := d.DecodeElement(_acdb.CxnLst, &_eadfb); _bgfc != nil {
					return _bgfc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "rect"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "rect"}:
				_acdb.Rect = NewCT_GeomRect()
				if _ggge := d.DecodeElement(_acdb.Rect, &_eadfb); _ggge != nil {
					return _ggge
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pathLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pathLst"}:
				if _bbfb := d.DecodeElement(_acdb.PathLst, &_eadfb); _bbfb != nil {
					return _bbfb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CustomGeometry2D\u0020\u0025v", _eadfb.Name)
				if _gagf := d.Skip(); _gagf != nil {
					return _gagf
				}
			}
		case _g.EndElement:
			break _fdbd
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_ColorSchemeAndMapping() *CT_ColorSchemeAndMapping {
	_egcb := &CT_ColorSchemeAndMapping{}
	_egcb.ClrScheme = NewCT_ColorScheme()
	return _egcb
}
func (_dadad *CT_NonVisualGraphicFrameProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _dadad.GraphicFrameLocks != nil {
		_geba := _g.StartElement{Name: _g.Name{Local: "a:graphicFrameLocks"}}
		e.EncodeElement(_dadad.GraphicFrameLocks, _geba)
	}
	if _dadad.ExtLst != nil {
		_fdcb := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dadad.ExtLst, _fdcb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_Path2DClose() *CT_Path2DClose { _dgbdf := &CT_Path2DClose{}; return _dgbdf }

const (
	ST_PenAlignmentUnset ST_PenAlignment = 0
	ST_PenAlignmentCtr   ST_PenAlignment = 1
	ST_PenAlignmentIn    ST_PenAlignment = 2
)

func NewCT_AdjPoint2D() *CT_AdjPoint2D { _ddd := &CT_AdjPoint2D{}; return _ddd }

// Validate validates the CT_RelativeRect and its children
func (_ccacb *CT_RelativeRect) Validate() error { return _ccacb.ValidateWithPath("CT_RelativeRect") }
func (_dccdb *CT_TextBlipBullet) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dccdb.Blip = NewCT_Blip()
_ddged:
	for {
		_eadce, _caff := d.Token()
		if _caff != nil {
			return _caff
		}
		switch _caefb := _eadce.(type) {
		case _g.StartElement:
			switch _caefb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blip"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blip"}:
				if _bebbe := d.DecodeElement(_dccdb.Blip, &_caefb); _bebbe != nil {
					return _bebbe
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_TextBlipBullet\u0020\u0025v", _caefb.Name)
				if _gccda := d.Skip(); _gccda != nil {
					return _gccda
				}
			}
		case _g.EndElement:
			break _ddged
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_ColorMappingOverride and its children
func (_gegb *CT_ColorMappingOverride) Validate() error {
	return _gegb.ValidateWithPath("CT_ColorMappingOverride")
}

type CT_CustomGeometry2D struct {
	AvLst   *CT_GeomGuideList
	GdLst   *CT_GeomGuideList
	AhLst   *CT_AdjustHandleList
	CxnLst  *CT_ConnectionSiteList
	Rect    *CT_GeomRect
	PathLst *CT_Path2DList
}

// ValidateWithPath validates the CT_AudioCDTime and its children, prefixing error messages with path
func (_daf *CT_AudioCDTime) ValidateWithPath(path string) error { return nil }

type EG_ColorTransform struct {
	Tint     *CT_PositiveFixedPercentage
	Shade    *CT_PositiveFixedPercentage
	Comp     *CT_ComplementTransform
	Inv      *CT_InverseTransform
	Gray     *CT_GrayscaleTransform
	Alpha    *CT_PositiveFixedPercentage
	AlphaOff *CT_FixedPercentage
	AlphaMod *CT_PositivePercentage
	Hue      *CT_PositiveFixedAngle
	HueOff   *CT_Angle
	HueMod   *CT_PositivePercentage
	Sat      *CT_Percentage
	SatOff   *CT_Percentage
	SatMod   *CT_Percentage
	Lum      *CT_Percentage
	LumOff   *CT_Percentage
	LumMod   *CT_Percentage
	Red      *CT_Percentage
	RedOff   *CT_Percentage
	RedMod   *CT_Percentage
	Green    *CT_Percentage
	GreenOff *CT_Percentage
	GreenMod *CT_Percentage
	Blue     *CT_Percentage
	BlueOff  *CT_Percentage
	BlueMod  *CT_Percentage
	Gamma    *CT_GammaTransform
	InvGamma *CT_InverseGammaTransform
}

func (_bcbbg *ST_CompoundLine) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_bcbbg = 0
	case "sng":
		*_bcbbg = 1
	case "dbl":
		*_bcbbg = 2
	case "thickThin":
		*_bcbbg = 3
	case "thinThick":
		*_bcbbg = 4
	case "tri":
		*_bcbbg = 5
	}
	return nil
}
func NewCT_AlphaModulateFixedEffect() *CT_AlphaModulateFixedEffect {
	_fcbe := &CT_AlphaModulateFixedEffect{}
	return _fcbe
}

// Validate validates the Theme and its children
func (_dcdff *Theme) Validate() error { return _dcdff.ValidateWithPath("Theme") }

// Validate validates the CT_BackgroundFormatting and its children
func (_cff *CT_BackgroundFormatting) Validate() error {
	return _cff.ValidateWithPath("CT_BackgroundFormatting")
}

// Validate validates the EG_Effect and its children
func (_faagga *EG_Effect) Validate() error { return _faagga.ValidateWithPath("EG_Effect") }
func (_becfd *EG_ShadeProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _becfd.Lin != nil {
		_dcecg := _g.StartElement{Name: _g.Name{Local: "a:lin"}}
		e.EncodeElement(_becfd.Lin, _dcecg)
	}
	if _becfd.Path != nil {
		_ggeecb := _g.StartElement{Name: _g.Name{Local: "a:path"}}
		e.EncodeElement(_becfd.Path, _ggeecb)
	}
	return nil
}
func NewCT_ColorMRU() *CT_ColorMRU { _fcad := &CT_ColorMRU{}; return _fcad }

// ValidateWithPath validates the CT_LineJoinBevel and its children, prefixing error messages with path
func (_gcdb *CT_LineJoinBevel) ValidateWithPath(path string) error { return nil }

type Any interface {
	MarshalXML(_ggac *_g.Encoder, _ecaaa _g.StartElement) error
	UnmarshalXML(_dcaed *_g.Decoder, _ggdffa _g.StartElement) error
}

// ValidateWithPath validates the CT_GlowEffect and its children, prefixing error messages with path
func (_ffefb *CT_GlowEffect) ValidateWithPath(path string) error {
	if _ffefb.RadAttr != nil {
		if *_ffefb.RadAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eRadAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_ffefb.RadAttr)
		}
		if *_ffefb.RadAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s\u002fm\u002eRadAttr must\u0020be \u003c\u003d\u002027273042316900\u0020\u0028have\u0020%v\u0029", path, *_ffefb.RadAttr)
		}
	}
	if _ffefb.ScrgbClr != nil {
		if _fddg := _ffefb.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _fddg != nil {
			return _fddg
		}
	}
	if _ffefb.SrgbClr != nil {
		if _afdeb := _ffefb.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _afdeb != nil {
			return _afdeb
		}
	}
	if _ffefb.HslClr != nil {
		if _bgbb := _ffefb.HslClr.ValidateWithPath(path + "\u002fHslClr"); _bgbb != nil {
			return _bgbb
		}
	}
	if _ffefb.SysClr != nil {
		if _egfdc := _ffefb.SysClr.ValidateWithPath(path + "\u002fSysClr"); _egfdc != nil {
			return _egfdc
		}
	}
	if _ffefb.SchemeClr != nil {
		if _gffef := _ffefb.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _gffef != nil {
			return _gffef
		}
	}
	if _ffefb.PrstClr != nil {
		if _fdaf := _ffefb.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _fdaf != nil {
			return _fdaf
		}
	}
	return nil
}

// ValidateWithPath validates the CT_AnimationGraphicalObjectBuildProperties and its children, prefixing error messages with path
func (_bdc *CT_AnimationGraphicalObjectBuildProperties) ValidateWithPath(path string) error {
	if _bdc.BldDgm != nil {
		if _aecc := _bdc.BldDgm.ValidateWithPath(path + "\u002fBldDgm"); _aecc != nil {
			return _aecc
		}
	}
	if _bdc.BldChart != nil {
		if _geagb := _bdc.BldChart.ValidateWithPath(path + "\u002fBldChart"); _geagb != nil {
			return _geagb
		}
	}
	return nil
}
func (_eegee *ST_AnimationChartOnlyBuildType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_eegee = 0
	case "series":
		*_eegee = 1
	case "category":
		*_eegee = 2
	case "seriesEl":
		*_eegee = 3
	case "categoryEl":
		*_eegee = 4
	}
	return nil
}

// Validate validates the CT_PresetShadowEffect and its children
func (_fgabg *CT_PresetShadowEffect) Validate() error {
	return _fgabg.ValidateWithPath("CT_PresetShadowEffect")
}
func (_ggbc *CT_Camera) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ggbc.PrstAttr = ST_PresetCameraType(1)
	for _, _afec := range start.Attr {
		if _afec.Name.Local == "prst" {
			_ggbc.PrstAttr.UnmarshalXMLAttr(_afec)
			continue
		}
		if _afec.Name.Local == "fov" {
			_eadg, _bddad := _e.ParseInt(_afec.Value, 10, 32)
			if _bddad != nil {
				return _bddad
			}
			_dbf := int32(_eadg)
			_ggbc.FovAttr = &_dbf
			continue
		}
		if _afec.Name.Local == "zoom" {
			_bgcg, _abg := ParseUnionST_PositivePercentage(_afec.Value)
			if _abg != nil {
				return _abg
			}
			_ggbc.ZoomAttr = &_bgcg
			continue
		}
	}
_efeg:
	for {
		_efeb, _ecfcd := d.Token()
		if _ecfcd != nil {
			return _ecfcd
		}
		switch _bcgca := _efeb.(type) {
		case _g.StartElement:
			switch _bcgca.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "rot"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "rot"}:
				_ggbc.Rot = NewCT_SphereCoords()
				if _bbfce := d.DecodeElement(_ggbc.Rot, &_bcgca); _bbfce != nil {
					return _bbfce
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on CT_Camera \u0025v", _bcgca.Name)
				if _adaf := d.Skip(); _adaf != nil {
					return _adaf
				}
			}
		case _g.EndElement:
			break _efeg
		case _g.CharData:
		}
	}
	return nil
}
func (_gdca *CT_ColorMappingOverrideChoice) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_ggab:
	for {
		_ccfc, _bgfb := d.Token()
		if _bgfb != nil {
			return _bgfb
		}
		switch _gadd := _ccfc.(type) {
		case _g.StartElement:
			switch _gadd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "masterClrMapping"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "masterClrMapping"}:
				_gdca.MasterClrMapping = NewCT_EmptyElement()
				if _bdg := d.DecodeElement(_gdca.MasterClrMapping, &_gadd); _bdg != nil {
					return _bdg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "overrideClrMapping"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "overrideClrMapping"}:
				_gdca.OverrideClrMapping = NewCT_ColorMapping()
				if _afeg := d.DecodeElement(_gdca.OverrideClrMapping, &_gadd); _afeg != nil {
					return _afeg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_ColorMappingOverrideChoice\u0020%v", _gadd.Name)
				if _cfdb := d.Skip(); _cfdb != nil {
					return _cfdb
				}
			}
		case _g.EndElement:
			break _ggab
		case _g.CharData:
		}
	}
	return nil
}

type CT_DashStopList struct{ Ds []*CT_DashStop }

// ValidateWithPath validates the CT_Camera and its children, prefixing error messages with path
func (_dcfe *CT_Camera) ValidateWithPath(path string) error {
	if _dcfe.PrstAttr == ST_PresetCameraTypeUnset {
		return _dcf.Errorf("\u0025s\u002fPrstAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _egdg := _dcfe.PrstAttr.ValidateWithPath(path + "\u002fPrstAttr"); _egdg != nil {
		return _egdg
	}
	if _dcfe.FovAttr != nil {
		if *_dcfe.FovAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eFovAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_dcfe.FovAttr)
		}
		if *_dcfe.FovAttr > 10800000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eFovAttr\u0020must\u0020be\u0020\u003c\u003d\u002010800000\u0020(have\u0020\u0025v\u0029", path, *_dcfe.FovAttr)
		}
	}
	if _dcfe.ZoomAttr != nil {
		if _gecf := _dcfe.ZoomAttr.ValidateWithPath(path + "\u002fZoomAttr"); _gecf != nil {
			return _gecf
		}
	}
	if _dcfe.Rot != nil {
		if _cfgf := _dcfe.Rot.ValidateWithPath(path + "\u002fRot"); _cfgf != nil {
			return _cfgf
		}
	}
	return nil
}

// ST_TextPoint is a union type
type ST_TextPoint struct {
	ST_TextPointUnqualified *int32
	ST_UniversalMeasure     *string
}
type CT_ScRgbColor struct {
	RAttr             ST_Percentage
	GAttr             ST_Percentage
	BAttr             ST_Percentage
	EG_ColorTransform []*EG_ColorTransform
}

func (_ffbf *CT_GeomGuide) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "name"}, Value: _dcf.Sprintf("\u0025v", _ffbf.NameAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "fmla"}, Value: _dcf.Sprintf("\u0025v", _ffbf.FmlaAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_cagd *CT_Point3D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "x"}, Value: _dcf.Sprintf("\u0025v", _cagd.XAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "y"}, Value: _dcf.Sprintf("\u0025v", _cagd.YAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "z"}, Value: _dcf.Sprintf("\u0025v", _cagd.ZAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_dfgcf ST_TextUnderlineType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_dfgcf.String(), start)
}
func (_becb *CT_GroupShapeProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _becb.BwModeAttr != ST_BlackWhiteModeUnset {
		_ecega, _cfed := _becb.BwModeAttr.MarshalXMLAttr(_g.Name{Local: "bwMode"})
		if _cfed != nil {
			return _cfed
		}
		start.Attr = append(start.Attr, _ecega)
	}
	e.EncodeToken(start)
	if _becb.Xfrm != nil {
		_eebde := _g.StartElement{Name: _g.Name{Local: "a:xfrm"}}
		e.EncodeElement(_becb.Xfrm, _eebde)
	}
	if _becb.NoFill != nil {
		_ffefd := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_becb.NoFill, _ffefd)
	}
	if _becb.SolidFill != nil {
		_bgcgg := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_becb.SolidFill, _bgcgg)
	}
	if _becb.GradFill != nil {
		_gaeeg := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_becb.GradFill, _gaeeg)
	}
	if _becb.BlipFill != nil {
		_bfad := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
		e.EncodeElement(_becb.BlipFill, _bfad)
	}
	if _becb.PattFill != nil {
		_bddee := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_becb.PattFill, _bddee)
	}
	if _becb.GrpFill != nil {
		_badga := _g.StartElement{Name: _g.Name{Local: "a:grpFill"}}
		e.EncodeElement(_becb.GrpFill, _badga)
	}
	if _becb.EffectLst != nil {
		_gebg := _g.StartElement{Name: _g.Name{Local: "a:effectLst"}}
		e.EncodeElement(_becb.EffectLst, _gebg)
	}
	if _becb.EffectDag != nil {
		_abgfb := _g.StartElement{Name: _g.Name{Local: "a:effectDag"}}
		e.EncodeElement(_becb.EffectDag, _abgfb)
	}
	if _becb.Scene3d != nil {
		_ccfecf := _g.StartElement{Name: _g.Name{Local: "a:scene3d"}}
		e.EncodeElement(_becb.Scene3d, _ccfecf)
	}
	if _becb.ExtLst != nil {
		_caba := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_becb.ExtLst, _caba)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_cefeg *CT_TextAutonumberBullet) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cefeg.TypeAttr = ST_TextAutonumberScheme(1)
	for _, _eaabf := range start.Attr {
		if _eaabf.Name.Local == "type" {
			_cefeg.TypeAttr.UnmarshalXMLAttr(_eaabf)
			continue
		}
		if _eaabf.Name.Local == "startAt" {
			_cffgf, _bgdbf := _e.ParseInt(_eaabf.Value, 10, 32)
			if _bgdbf != nil {
				return _bgdbf
			}
			_ddfag := int32(_cffgf)
			_cefeg.StartAtAttr = &_ddfag
			continue
		}
	}
	for {
		_fdbfg, _ebaac := d.Token()
		if _ebaac != nil {
			return _dcf.Errorf("parsing CT_TextAutonumberBullet:\u0020%s", _ebaac)
		}
		if _cdada, _acece := _fdbfg.(_g.EndElement); _acece && _cdada.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ObjectStyleDefaults and its children, prefixing error messages with path
func (_aggc *CT_ObjectStyleDefaults) ValidateWithPath(path string) error {
	if _aggc.SpDef != nil {
		if _cecfe := _aggc.SpDef.ValidateWithPath(path + "\u002fSpDef"); _cecfe != nil {
			return _cecfe
		}
	}
	if _aggc.LnDef != nil {
		if _adgb := _aggc.LnDef.ValidateWithPath(path + "\u002fLnDef"); _adgb != nil {
			return _adgb
		}
	}
	if _aggc.TxDef != nil {
		if _cfgagc := _aggc.TxDef.ValidateWithPath(path + "\u002fTxDef"); _cfgagc != nil {
			return _cfgagc
		}
	}
	if _aggc.ExtLst != nil {
		if _bgfbg := _aggc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bgfbg != nil {
			return _bgfbg
		}
	}
	return nil
}

type EG_TextUnderlineFill struct {
	UFillTx *CT_TextUnderlineFillFollowText
	UFill   *CT_TextUnderlineFillGroupWrapper
}

// ValidateWithPath validates the CT_GvmlGraphicFrameNonVisual and its children, prefixing error messages with path
func (_bccdc *CT_GvmlGraphicFrameNonVisual) ValidateWithPath(path string) error {
	if _caaac := _bccdc.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _caaac != nil {
		return _caaac
	}
	if _efcc := _bccdc.CNvGraphicFramePr.ValidateWithPath(path + "\u002fCNvGraphicFramePr"); _efcc != nil {
		return _efcc
	}
	return nil
}
func (_dfefe *CT_LineProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dfefe.WAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "w"}, Value: _dcf.Sprintf("\u0025v", *_dfefe.WAttr)})
	}
	if _dfefe.CapAttr != ST_LineCapUnset {
		_fbbab, _ebgcg := _dfefe.CapAttr.MarshalXMLAttr(_g.Name{Local: "cap"})
		if _ebgcg != nil {
			return _ebgcg
		}
		start.Attr = append(start.Attr, _fbbab)
	}
	if _dfefe.CmpdAttr != ST_CompoundLineUnset {
		_fgcdf, _dcceg := _dfefe.CmpdAttr.MarshalXMLAttr(_g.Name{Local: "cmpd"})
		if _dcceg != nil {
			return _dcceg
		}
		start.Attr = append(start.Attr, _fgcdf)
	}
	if _dfefe.AlgnAttr != ST_PenAlignmentUnset {
		_cfgeb, _gbedd := _dfefe.AlgnAttr.MarshalXMLAttr(_g.Name{Local: "algn"})
		if _gbedd != nil {
			return _gbedd
		}
		start.Attr = append(start.Attr, _cfgeb)
	}
	e.EncodeToken(start)
	if _dfefe.NoFill != nil {
		_gedbe := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_dfefe.NoFill, _gedbe)
	}
	if _dfefe.SolidFill != nil {
		_dacfc := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_dfefe.SolidFill, _dacfc)
	}
	if _dfefe.GradFill != nil {
		_cdaf := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_dfefe.GradFill, _cdaf)
	}
	if _dfefe.PattFill != nil {
		_ecfa := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_dfefe.PattFill, _ecfa)
	}
	if _dfefe.PrstDash != nil {
		_dced := _g.StartElement{Name: _g.Name{Local: "a:prstDash"}}
		e.EncodeElement(_dfefe.PrstDash, _dced)
	}
	if _dfefe.CustDash != nil {
		_gcacd := _g.StartElement{Name: _g.Name{Local: "a:custDash"}}
		e.EncodeElement(_dfefe.CustDash, _gcacd)
	}
	if _dfefe.Round != nil {
		_agcff := _g.StartElement{Name: _g.Name{Local: "a:round"}}
		e.EncodeElement(_dfefe.Round, _agcff)
	}
	if _dfefe.Bevel != nil {
		_cbdf := _g.StartElement{Name: _g.Name{Local: "a:bevel"}}
		e.EncodeElement(_dfefe.Bevel, _cbdf)
	}
	if _dfefe.Miter != nil {
		_ecebe := _g.StartElement{Name: _g.Name{Local: "a:miter"}}
		e.EncodeElement(_dfefe.Miter, _ecebe)
	}
	if _dfefe.HeadEnd != nil {
		_cfbff := _g.StartElement{Name: _g.Name{Local: "a:headEnd"}}
		e.EncodeElement(_dfefe.HeadEnd, _cfbff)
	}
	if _dfefe.TailEnd != nil {
		_gacda := _g.StartElement{Name: _g.Name{Local: "a:tailEnd"}}
		e.EncodeElement(_dfefe.TailEnd, _gacda)
	}
	if _dfefe.ExtLst != nil {
		_caaf := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dfefe.ExtLst, _caaf)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_NonVisualGraphicFrameProperties struct {
	GraphicFrameLocks *CT_GraphicalObjectFrameLocking
	ExtLst            *CT_OfficeArtExtensionList
}

// ValidateWithPath validates the CT_Table and its children, prefixing error messages with path
func (_dcegd *CT_Table) ValidateWithPath(path string) error {
	if _dcegd.TblPr != nil {
		if _gdcgd := _dcegd.TblPr.ValidateWithPath(path + "\u002fTblPr"); _gdcgd != nil {
			return _gdcgd
		}
	}
	if _gaeg := _dcegd.TblGrid.ValidateWithPath(path + "\u002fTblGrid"); _gaeg != nil {
		return _gaeg
	}
	for _fgda, _eabdg := range _dcegd.Tr {
		if _bbaeg := _eabdg.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fTr\u005b\u0025d]", path, _fgda)); _bbaeg != nil {
			return _bbaeg
		}
	}
	return nil
}

// Validate validates the CT_EmbeddedWAVAudioFile and its children
func (_gbcf *CT_EmbeddedWAVAudioFile) Validate() error {
	return _gbcf.ValidateWithPath("CT_EmbeddedWAVAudioFile")
}
func (_fabfcg *EG_TextUnderlineLine) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_eeedb:
	for {
		_ggfaac, _ffeca := d.Token()
		if _ffeca != nil {
			return _ffeca
		}
		switch _dcegaf := _ggfaac.(type) {
		case _g.StartElement:
			switch _dcegaf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "uLnTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "uLnTx"}:
				_fabfcg.ULnTx = NewCT_TextUnderlineLineFollowText()
				if _egcgd := d.DecodeElement(_fabfcg.ULnTx, &_dcegaf); _egcgd != nil {
					return _egcgd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "uLn"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "uLn"}:
				_fabfcg.ULn = NewCT_LineProperties()
				if _edbbb := d.DecodeElement(_fabfcg.ULn, &_dcegaf); _edbbb != nil {
					return _edbbb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020EG_TextUnderlineLine\u0020\u0025v", _dcegaf.Name)
				if _dcccg := d.Skip(); _dcccg != nil {
					return _dcccg
				}
			}
		case _g.EndElement:
			break _eeedb
		case _g.CharData:
		}
	}
	return nil
}
func NewEG_LineJoinProperties() *EG_LineJoinProperties {
	_cdafe := &EG_LineJoinProperties{}
	return _cdafe
}
func NewCT_FillEffect() *CT_FillEffect { _agbc := &CT_FillEffect{}; return _agbc }

type CT_TextSpacing struct {
	SpcPct *CT_TextSpacingPercent
	SpcPts *CT_TextSpacingPoint
}

// ValidateWithPath validates the CT_Headers and its children, prefixing error messages with path
func (_cdffa *CT_Headers) ValidateWithPath(path string) error { return nil }
func (_cggba ST_LightRigType) ValidateWithPath(path string) error {
	switch _cggba {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cggba))
	}
	return nil
}

// ValidateWithPath validates the EG_TextUnderlineLine and its children, prefixing error messages with path
func (_cddab *EG_TextUnderlineLine) ValidateWithPath(path string) error {
	if _cddab.ULnTx != nil {
		if _afdfgg := _cddab.ULnTx.ValidateWithPath(path + "\u002fULnTx"); _afdfgg != nil {
			return _afdfgg
		}
	}
	if _cddab.ULn != nil {
		if _dedbg := _cddab.ULn.ValidateWithPath(path + "\u002fULn"); _dedbg != nil {
			return _dedbg
		}
	}
	return nil
}

// Validate validates the CT_GradientStop and its children
func (_aacdc *CT_GradientStop) Validate() error { return _aacdc.ValidateWithPath("CT_GradientStop") }
func (_gbeafa *CT_TableCol) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _edbb := range start.Attr {
		if _edbb.Name.Local == "w" {
			_babdb, _aecaga := ParseUnionST_Coordinate(_edbb.Value)
			if _aecaga != nil {
				return _aecaga
			}
			_gbeafa.WAttr = _babdb
			continue
		}
	}
_eaca:
	for {
		_gafb, _ggadc := d.Token()
		if _ggadc != nil {
			return _ggadc
		}
		switch _cddgfc := _gafb.(type) {
		case _g.StartElement:
			switch _cddgfc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_gbeafa.ExtLst = NewCT_OfficeArtExtensionList()
				if _dfade := d.DecodeElement(_gbeafa.ExtLst, &_cddgfc); _dfade != nil {
					return _dfade
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TableCol\u0020\u0025v", _cddgfc.Name)
				if _dbce := d.Skip(); _dbce != nil {
					return _dbce
				}
			}
		case _g.EndElement:
			break _eaca
		case _g.CharData:
		}
	}
	return nil
}

type CT_TablePartStyle struct {
	TcTxStyle *CT_TableStyleTextStyle
	TcStyle   *CT_TableStyleCellStyle
}

// ValidateWithPath validates the CT_AnimationDgmBuildProperties and its children, prefixing error messages with path
func (_bffb *CT_AnimationDgmBuildProperties) ValidateWithPath(path string) error {
	if _bffb.BldAttr != nil {
		if _caag := _bffb.BldAttr.ValidateWithPath(path + "\u002fBldAttr"); _caag != nil {
			return _caag
		}
	}
	return nil
}
func NewCT_GvmlShapeNonVisual() *CT_GvmlShapeNonVisual {
	_fggd := &CT_GvmlShapeNonVisual{}
	_fggd.CNvPr = NewCT_NonVisualDrawingProps()
	_fggd.CNvSpPr = NewCT_NonVisualDrawingShapeProps()
	return _fggd
}
func NewCT_PresetShadowEffect() *CT_PresetShadowEffect {
	_dabd := &CT_PresetShadowEffect{}
	_dabd.PrstAttr = ST_PresetShadowVal(1)
	return _dabd
}

// ValidateWithPath validates the CT_Transform2D and its children, prefixing error messages with path
func (_abddg *CT_Transform2D) ValidateWithPath(path string) error {
	if _abddg.Off != nil {
		if _bgfbgb := _abddg.Off.ValidateWithPath(path + "\u002fOff"); _bgfbgb != nil {
			return _bgfbgb
		}
	}
	if _abddg.Ext != nil {
		if _gcfa := _abddg.Ext.ValidateWithPath(path + "\u002fExt"); _gcfa != nil {
			return _gcfa
		}
	}
	return nil
}
func (_bfdgca *EG_ThemeableEffectStyle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_edceca:
	for {
		_gdfba, _dbade := d.Token()
		if _dbade != nil {
			return _dbade
		}
		switch _fagbf := _gdfba.(type) {
		case _g.StartElement:
			switch _fagbf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effect"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effect"}:
				_bfdgca.Effect = NewCT_EffectProperties()
				if _eebae := d.DecodeElement(_bfdgca.Effect, &_fagbf); _eebae != nil {
					return _eebae
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectRef"}:
				_bfdgca.EffectRef = NewCT_StyleMatrixReference()
				if _cbfcb := d.DecodeElement(_bfdgca.EffectRef, &_fagbf); _cbfcb != nil {
					return _cbfcb
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020EG_ThemeableEffectStyle \u0025v", _fagbf.Name)
				if _bcaf := d.Skip(); _bcaf != nil {
					return _bcaf
				}
			}
		case _g.EndElement:
			break _edceca
		case _g.CharData:
		}
	}
	return nil
}
func (_becfgb ST_RectAlignment) ValidateWithPath(path string) error {
	switch _becfgb {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_becfgb))
	}
	return nil
}
func (_ffaffc *ST_Coordinate32) Validate() error { return _ffaffc.ValidateWithPath("") }
func NewCT_TableGrid() *CT_TableGrid             { _ccgee := &CT_TableGrid{}; return _ccgee }
func (_edcad *ST_OnOffStyleType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gbggg, _facfff := d.Token()
	if _facfff != nil {
		return _facfff
	}
	if _fbgcg, _gecdee := _gbggg.(_g.EndElement); _gecdee && _fbgcg.Name == start.Name {
		*_edcad = 1
		return nil
	}
	if _cfddc, _ffbbf := _gbggg.(_g.CharData); !_ffbbf {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gbggg)
	} else {
		switch string(_cfddc) {
		case "":
			*_edcad = 0
		case "on":
			*_edcad = 1
		case "off":
			*_edcad = 2
		case "def":
			*_edcad = 3
		}
	}
	_gbggg, _facfff = d.Token()
	if _facfff != nil {
		return _facfff
	}
	if _bacbcc, _abfdce := _gbggg.(_g.EndElement); _abfdce && _bacbcc.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gbggg)
}

// Validate validates the CT_BlipFillProperties and its children
func (_agca *CT_BlipFillProperties) Validate() error {
	return _agca.ValidateWithPath("CT_BlipFillProperties")
}
func (_bgaag *CT_ScRgbColor) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fcfb := range start.Attr {
		if _fcfb.Name.Local == "r" {
			_aefdbc, _gebe := ParseUnionST_Percentage(_fcfb.Value)
			if _gebe != nil {
				return _gebe
			}
			_bgaag.RAttr = _aefdbc
			continue
		}
		if _fcfb.Name.Local == "g" {
			_dccba, _fcbfe := ParseUnionST_Percentage(_fcfb.Value)
			if _fcbfe != nil {
				return _fcbfe
			}
			_bgaag.GAttr = _dccba
			continue
		}
		if _fcfb.Name.Local == "b" {
			_ffad, _bagbg := ParseUnionST_Percentage(_fcfb.Value)
			if _bagbg != nil {
				return _bagbg
			}
			_bgaag.BAttr = _ffad
			continue
		}
	}
_degeb:
	for {
		_ddag, _cbedb := d.Token()
		if _cbedb != nil {
			return _cbedb
		}
		switch _cfcf := _ddag.(type) {
		case _g.StartElement:
			switch _cfcf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_gacgc := NewEG_ColorTransform()
				_gacgc.Tint = NewCT_PositiveFixedPercentage()
				if _dbdg := d.DecodeElement(_gacgc.Tint, &_cfcf); _dbdg != nil {
					return _dbdg
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _gacgc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "shade"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "shade"}:
				_dfdac := NewEG_ColorTransform()
				_dfdac.Shade = NewCT_PositiveFixedPercentage()
				if _faegc := d.DecodeElement(_dfdac.Shade, &_cfcf); _faegc != nil {
					return _faegc
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _dfdac)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "comp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "comp"}:
				_bedgc := NewEG_ColorTransform()
				_bedgc.Comp = NewCT_ComplementTransform()
				if _fdfgf := d.DecodeElement(_bedgc.Comp, &_cfcf); _fdfgf != nil {
					return _fdfgf
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _bedgc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "inv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "inv"}:
				_cfba := NewEG_ColorTransform()
				_cfba.Inv = NewCT_InverseTransform()
				if _abeb := d.DecodeElement(_cfba.Inv, &_cfcf); _abeb != nil {
					return _abeb
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _cfba)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gray"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gray"}:
				_bgcc := NewEG_ColorTransform()
				_bgcc.Gray = NewCT_GrayscaleTransform()
				if _cfbef := d.DecodeElement(_bgcc.Gray, &_cfcf); _cfbef != nil {
					return _cfbef
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _bgcc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alpha"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alpha"}:
				_aceec := NewEG_ColorTransform()
				_aceec.Alpha = NewCT_PositiveFixedPercentage()
				if _dbecd := d.DecodeElement(_aceec.Alpha, &_cfcf); _dbecd != nil {
					return _dbecd
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _aceec)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaOff"}:
				_ggeee := NewEG_ColorTransform()
				_ggeee.AlphaOff = NewCT_FixedPercentage()
				if _eabcb := d.DecodeElement(_ggeee.AlphaOff, &_cfcf); _eabcb != nil {
					return _eabcb
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _ggeee)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_adcca := NewEG_ColorTransform()
				_adcca.AlphaMod = NewCT_PositivePercentage()
				if _cbbgd := d.DecodeElement(_adcca.AlphaMod, &_cfcf); _cbbgd != nil {
					return _cbbgd
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _adcca)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hue"}:
				_fdae := NewEG_ColorTransform()
				_fdae.Hue = NewCT_PositiveFixedAngle()
				if _bbebb := d.DecodeElement(_fdae.Hue, &_cfcf); _bbebb != nil {
					return _bbebb
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _fdae)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueOff"}:
				_ebgdc := NewEG_ColorTransform()
				_ebgdc.HueOff = NewCT_Angle()
				if _becbf := d.DecodeElement(_ebgdc.HueOff, &_cfcf); _becbf != nil {
					return _becbf
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _ebgdc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueMod"}:
				_gbcg := NewEG_ColorTransform()
				_gbcg.HueMod = NewCT_PositivePercentage()
				if _cgfaa := d.DecodeElement(_gbcg.HueMod, &_cfcf); _cgfaa != nil {
					return _cgfaa
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _gbcg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sat"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sat"}:
				_fccgb := NewEG_ColorTransform()
				_fccgb.Sat = NewCT_Percentage()
				if _aadce := d.DecodeElement(_fccgb.Sat, &_cfcf); _aadce != nil {
					return _aadce
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _fccgb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satOff"}:
				_ebcagb := NewEG_ColorTransform()
				_ebcagb.SatOff = NewCT_Percentage()
				if _ffgg := d.DecodeElement(_ebcagb.SatOff, &_cfcf); _ffgg != nil {
					return _ffgg
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _ebcagb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satMod"}:
				_cfbcc := NewEG_ColorTransform()
				_cfbcc.SatMod = NewCT_Percentage()
				if _edaf := d.DecodeElement(_cfbcc.SatMod, &_cfcf); _edaf != nil {
					return _edaf
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _cfbcc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_bbee := NewEG_ColorTransform()
				_bbee.Lum = NewCT_Percentage()
				if _deec := d.DecodeElement(_bbee.Lum, &_cfcf); _deec != nil {
					return _deec
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _bbee)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumOff"}:
				_bcefc := NewEG_ColorTransform()
				_bcefc.LumOff = NewCT_Percentage()
				if _fecfd := d.DecodeElement(_bcefc.LumOff, &_cfcf); _fecfd != nil {
					return _fecfd
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _bcefc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumMod"}:
				_abebe := NewEG_ColorTransform()
				_abebe.LumMod = NewCT_Percentage()
				if _gbbb := d.DecodeElement(_abebe.LumMod, &_cfcf); _gbbb != nil {
					return _gbbb
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _abebe)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "red"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "red"}:
				_babf := NewEG_ColorTransform()
				_babf.Red = NewCT_Percentage()
				if _agcdd := d.DecodeElement(_babf.Red, &_cfcf); _agcdd != nil {
					return _agcdd
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _babf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redOff"}:
				_dbedd := NewEG_ColorTransform()
				_dbedd.RedOff = NewCT_Percentage()
				if _ddaab := d.DecodeElement(_dbedd.RedOff, &_cfcf); _ddaab != nil {
					return _ddaab
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _dbedd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redMod"}:
				_beafe := NewEG_ColorTransform()
				_beafe.RedMod = NewCT_Percentage()
				if _adada := d.DecodeElement(_beafe.RedMod, &_cfcf); _adada != nil {
					return _adada
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _beafe)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "green"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "green"}:
				_aefa := NewEG_ColorTransform()
				_aefa.Green = NewCT_Percentage()
				if _dged := d.DecodeElement(_aefa.Green, &_cfcf); _dged != nil {
					return _dged
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _aefa)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenOff"}:
				_cabadg := NewEG_ColorTransform()
				_cabadg.GreenOff = NewCT_Percentage()
				if _cbfbg := d.DecodeElement(_cabadg.GreenOff, &_cfcf); _cbfbg != nil {
					return _cbfbg
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _cabadg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenMod"}:
				_efccg := NewEG_ColorTransform()
				_efccg.GreenMod = NewCT_Percentage()
				if _abdfd := d.DecodeElement(_efccg.GreenMod, &_cfcf); _abdfd != nil {
					return _abdfd
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _efccg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blue"}:
				_bfeaf := NewEG_ColorTransform()
				_bfeaf.Blue = NewCT_Percentage()
				if _bcecb := d.DecodeElement(_bfeaf.Blue, &_cfcf); _bcecb != nil {
					return _bcecb
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _bfeaf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueOff"}:
				_afbeg := NewEG_ColorTransform()
				_afbeg.BlueOff = NewCT_Percentage()
				if _ffbga := d.DecodeElement(_afbeg.BlueOff, &_cfcf); _ffbga != nil {
					return _ffbga
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _afbeg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueMod"}:
				_fgggba := NewEG_ColorTransform()
				_fgggba.BlueMod = NewCT_Percentage()
				if _dbdgf := d.DecodeElement(_fgggba.BlueMod, &_cfcf); _dbdgf != nil {
					return _dbdgf
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _fgggba)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gamma"}:
				_adeed := NewEG_ColorTransform()
				_adeed.Gamma = NewCT_GammaTransform()
				if _edegf := d.DecodeElement(_adeed.Gamma, &_cfcf); _edegf != nil {
					return _edegf
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _adeed)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "invGamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "invGamma"}:
				_cdgc := NewEG_ColorTransform()
				_cdgc.InvGamma = NewCT_InverseGammaTransform()
				if _adaeg := d.DecodeElement(_cdgc.InvGamma, &_cfcf); _adaeg != nil {
					return _adaeg
				}
				_bgaag.EG_ColorTransform = append(_bgaag.EG_ColorTransform, _cdgc)
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_ScRgbColor \u0025v", _cfcf.Name)
				if _bfeec := d.Skip(); _bfeec != nil {
					return _bfeec
				}
			}
		case _g.EndElement:
			break _degeb
		case _g.CharData:
		}
	}
	return nil
}
func (_dgdfb *CT_TableStyle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "styleId"}, Value: _dcf.Sprintf("\u0025v", _dgdfb.StyleIdAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "styleName"}, Value: _dcf.Sprintf("\u0025v", _dgdfb.StyleNameAttr)})
	e.EncodeToken(start)
	if _dgdfb.TblBg != nil {
		_eacgd := _g.StartElement{Name: _g.Name{Local: "a:tblBg"}}
		e.EncodeElement(_dgdfb.TblBg, _eacgd)
	}
	if _dgdfb.WholeTbl != nil {
		_acbgf := _g.StartElement{Name: _g.Name{Local: "a:wholeTbl"}}
		e.EncodeElement(_dgdfb.WholeTbl, _acbgf)
	}
	if _dgdfb.Band1H != nil {
		_cagedb := _g.StartElement{Name: _g.Name{Local: "a:band1H"}}
		e.EncodeElement(_dgdfb.Band1H, _cagedb)
	}
	if _dgdfb.Band2H != nil {
		_cageg := _g.StartElement{Name: _g.Name{Local: "a:band2H"}}
		e.EncodeElement(_dgdfb.Band2H, _cageg)
	}
	if _dgdfb.Band1V != nil {
		_acbga := _g.StartElement{Name: _g.Name{Local: "a:band1V"}}
		e.EncodeElement(_dgdfb.Band1V, _acbga)
	}
	if _dgdfb.Band2V != nil {
		_acbgfa := _g.StartElement{Name: _g.Name{Local: "a:band2V"}}
		e.EncodeElement(_dgdfb.Band2V, _acbgfa)
	}
	if _dgdfb.LastCol != nil {
		_dfce := _g.StartElement{Name: _g.Name{Local: "a:lastCol"}}
		e.EncodeElement(_dgdfb.LastCol, _dfce)
	}
	if _dgdfb.FirstCol != nil {
		_cbdfd := _g.StartElement{Name: _g.Name{Local: "a:firstCol"}}
		e.EncodeElement(_dgdfb.FirstCol, _cbdfd)
	}
	if _dgdfb.LastRow != nil {
		_cgcbf := _g.StartElement{Name: _g.Name{Local: "a:lastRow"}}
		e.EncodeElement(_dgdfb.LastRow, _cgcbf)
	}
	if _dgdfb.SeCell != nil {
		_fbedd := _g.StartElement{Name: _g.Name{Local: "a:seCell"}}
		e.EncodeElement(_dgdfb.SeCell, _fbedd)
	}
	if _dgdfb.SwCell != nil {
		_daggd := _g.StartElement{Name: _g.Name{Local: "a:swCell"}}
		e.EncodeElement(_dgdfb.SwCell, _daggd)
	}
	if _dgdfb.FirstRow != nil {
		_addga := _g.StartElement{Name: _g.Name{Local: "a:firstRow"}}
		e.EncodeElement(_dgdfb.FirstRow, _addga)
	}
	if _dgdfb.NeCell != nil {
		_acfab := _g.StartElement{Name: _g.Name{Local: "a:neCell"}}
		e.EncodeElement(_dgdfb.NeCell, _acfab)
	}
	if _dgdfb.NwCell != nil {
		_ccfcb := _g.StartElement{Name: _g.Name{Local: "a:nwCell"}}
		e.EncodeElement(_dgdfb.NwCell, _ccfcb)
	}
	if _dgdfb.ExtLst != nil {
		_cfgcf := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dgdfb.ExtLst, _cfgcf)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the EG_TextRun and its children
func (_fabgd *EG_TextRun) Validate() error { return _fabgd.ValidateWithPath("EG_TextRun") }

// ValidateWithPath validates the Tbl and its children, prefixing error messages with path
func (_beggf *Tbl) ValidateWithPath(path string) error {
	if _addbb := _beggf.CT_Table.ValidateWithPath(path); _addbb != nil {
		return _addbb
	}
	return nil
}

type CT_CustomColor struct {
	NameAttr  *string
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
}

func (_eabbb ST_PresetLineDashVal) Validate() error { return _eabbb.ValidateWithPath("") }
func NewCT_PositiveFixedAngle() *CT_PositiveFixedAngle {
	_caae := &CT_PositiveFixedAngle{}
	_caae.ValAttr = 0
	return _caae
}

// ValidateWithPath validates the CT_AdjPoint2D and its children, prefixing error messages with path
func (_ef *CT_AdjPoint2D) ValidateWithPath(path string) error {
	if _agc := _ef.XAttr.ValidateWithPath(path + "\u002fXAttr"); _agc != nil {
		return _agc
	}
	if _ded := _ef.YAttr.ValidateWithPath(path + "\u002fYAttr"); _ded != nil {
		return _ded
	}
	return nil
}
func (_cffdg ST_SchemeColorVal) String() string {
	switch _cffdg {
	case 0:
		return ""
	case 1:
		return "bg1"
	case 2:
		return "tx1"
	case 3:
		return "bg2"
	case 4:
		return "tx2"
	case 5:
		return "accent1"
	case 6:
		return "accent2"
	case 7:
		return "accent3"
	case 8:
		return "accent4"
	case 9:
		return "accent5"
	case 10:
		return "accent6"
	case 11:
		return "hlink"
	case 12:
		return "folHlink"
	case 13:
		return "phClr"
	case 14:
		return "dk1"
	case 15:
		return "lt1"
	case 16:
		return "dk2"
	case 17:
		return "lt2"
	}
	return ""
}
func (_acaca *CT_PathShadeProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _acaca.PathAttr != ST_PathShadeTypeUnset {
		_bdaag, _cfbb := _acaca.PathAttr.MarshalXMLAttr(_g.Name{Local: "path"})
		if _cfbb != nil {
			return _cfbb
		}
		start.Attr = append(start.Attr, _bdaag)
	}
	e.EncodeToken(start)
	if _acaca.FillToRect != nil {
		_fddee := _g.StartElement{Name: _g.Name{Local: "a:fillToRect"}}
		e.EncodeElement(_acaca.FillToRect, _fddee)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_OfficeArtExtension struct {
	UriAttr string
	Any     []_ee.Any
}

// ValidateWithPath validates the CT_TextNoAutofit and its children, prefixing error messages with path
func (_edagd *CT_TextNoAutofit) ValidateWithPath(path string) error { return nil }

type CT_RelativeOffsetEffect struct {
	TxAttr *ST_Percentage
	TyAttr *ST_Percentage
}

func (_gbbagf ST_LightRigDirection) String() string {
	switch _gbbagf {
	case 0:
		return ""
	case 1:
		return "tl"
	case 2:
		return "t"
	case 3:
		return "tr"
	case 4:
		return "l"
	case 5:
		return "r"
	case 6:
		return "bl"
	case 7:
		return "b"
	case 8:
		return "br"
	}
	return ""
}
func (_dbeed ST_BevelPresetType) Validate() error { return _dbeed.ValidateWithPath("") }

// Validate validates the CT_BackgroundFillStyleList and its children
func (_ebde *CT_BackgroundFillStyleList) Validate() error {
	return _ebde.ValidateWithPath("CT_BackgroundFillStyleList")
}
func (_deff *CT_Transform2D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _deff.RotAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rot"}, Value: _dcf.Sprintf("\u0025v", *_deff.RotAttr)})
	}
	if _deff.FlipHAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "flipH"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_deff.FlipHAttr))})
	}
	if _deff.FlipVAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "flipV"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_deff.FlipVAttr))})
	}
	e.EncodeToken(start)
	if _deff.Off != nil {
		_abece := _g.StartElement{Name: _g.Name{Local: "a:off"}}
		e.EncodeElement(_deff.Off, _abece)
	}
	if _deff.Ext != nil {
		_cbcefg := _g.StartElement{Name: _g.Name{Local: "a:ext"}}
		e.EncodeElement(_deff.Ext, _cbcefg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_fbgdf *CT_TextTabStopList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _fbgdf.Tab != nil {
		_bbccc := _g.StartElement{Name: _g.Name{Local: "a:tab"}}
		for _, _agegb := range _fbgdf.Tab {
			e.EncodeElement(_agegb, _bbccc)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the EG_ShadeProperties and its children
func (_dbaba *EG_ShadeProperties) Validate() error {
	return _dbaba.ValidateWithPath("EG_ShadeProperties")
}
func (_dgfg *CT_TextBodyProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bagggd := range start.Attr {
		if _bagggd.Name.Local == "fromWordArt" {
			_ceedd, _cegg := _e.ParseBool(_bagggd.Value)
			if _cegg != nil {
				return _cegg
			}
			_dgfg.FromWordArtAttr = &_ceedd
			continue
		}
		if _bagggd.Name.Local == "anchor" {
			_dgfg.AnchorAttr.UnmarshalXMLAttr(_bagggd)
			continue
		}
		if _bagggd.Name.Local == "spcFirstLastPara" {
			_caeff, _efggd := _e.ParseBool(_bagggd.Value)
			if _efggd != nil {
				return _efggd
			}
			_dgfg.SpcFirstLastParaAttr = &_caeff
			continue
		}
		if _bagggd.Name.Local == "anchorCtr" {
			_dcgfb, _feebb := _e.ParseBool(_bagggd.Value)
			if _feebb != nil {
				return _feebb
			}
			_dgfg.AnchorCtrAttr = &_dcgfb
			continue
		}
		if _bagggd.Name.Local == "horzOverflow" {
			_dgfg.HorzOverflowAttr.UnmarshalXMLAttr(_bagggd)
			continue
		}
		if _bagggd.Name.Local == "forceAA" {
			_bcdfe, _fdfb := _e.ParseBool(_bagggd.Value)
			if _fdfb != nil {
				return _fdfb
			}
			_dgfg.ForceAAAttr = &_bcdfe
			continue
		}
		if _bagggd.Name.Local == "wrap" {
			_dgfg.WrapAttr.UnmarshalXMLAttr(_bagggd)
			continue
		}
		if _bagggd.Name.Local == "upright" {
			_afcgab, _ffgfa := _e.ParseBool(_bagggd.Value)
			if _ffgfa != nil {
				return _ffgfa
			}
			_dgfg.UprightAttr = &_afcgab
			continue
		}
		if _bagggd.Name.Local == "tIns" {
			_dfgfc, _fdfebd := ParseUnionST_Coordinate32(_bagggd.Value)
			if _fdfebd != nil {
				return _fdfebd
			}
			_dgfg.TInsAttr = &_dfgfc
			continue
		}
		if _bagggd.Name.Local == "compatLnSpc" {
			_ecgcf, _gfaege := _e.ParseBool(_bagggd.Value)
			if _gfaege != nil {
				return _gfaege
			}
			_dgfg.CompatLnSpcAttr = &_ecgcf
			continue
		}
		if _bagggd.Name.Local == "bIns" {
			_gcaa, _dcfa := ParseUnionST_Coordinate32(_bagggd.Value)
			if _dcfa != nil {
				return _dcfa
			}
			_dgfg.BInsAttr = &_gcaa
			continue
		}
		if _bagggd.Name.Local == "vertOverflow" {
			_dgfg.VertOverflowAttr.UnmarshalXMLAttr(_bagggd)
			continue
		}
		if _bagggd.Name.Local == "rot" {
			_fadca, _ffbgaf := _e.ParseInt(_bagggd.Value, 10, 32)
			if _ffbgaf != nil {
				return _ffbgaf
			}
			_bbef := int32(_fadca)
			_dgfg.RotAttr = &_bbef
			continue
		}
		if _bagggd.Name.Local == "spcCol" {
			_ggedg, _aeefe := _e.ParseInt(_bagggd.Value, 10, 32)
			if _aeefe != nil {
				return _aeefe
			}
			_fgbed := int32(_ggedg)
			_dgfg.SpcColAttr = &_fgbed
			continue
		}
		if _bagggd.Name.Local == "vert" {
			_dgfg.VertAttr.UnmarshalXMLAttr(_bagggd)
			continue
		}
		if _bagggd.Name.Local == "rIns" {
			_acddc, _befdb := ParseUnionST_Coordinate32(_bagggd.Value)
			if _befdb != nil {
				return _befdb
			}
			_dgfg.RInsAttr = &_acddc
			continue
		}
		if _bagggd.Name.Local == "numCol" {
			_ggcggd, _cbaca := _e.ParseInt(_bagggd.Value, 10, 32)
			if _cbaca != nil {
				return _cbaca
			}
			_begf := int32(_ggcggd)
			_dgfg.NumColAttr = &_begf
			continue
		}
		if _bagggd.Name.Local == "rtlCol" {
			_cfag, _abfda := _e.ParseBool(_bagggd.Value)
			if _abfda != nil {
				return _abfda
			}
			_dgfg.RtlColAttr = &_cfag
			continue
		}
		if _bagggd.Name.Local == "lIns" {
			_ddfcf, _cdgbe := ParseUnionST_Coordinate32(_bagggd.Value)
			if _cdgbe != nil {
				return _cdgbe
			}
			_dgfg.LInsAttr = &_ddfcf
			continue
		}
	}
_bbfcc:
	for {
		_daefab, _egded := d.Token()
		if _egded != nil {
			return _egded
		}
		switch _cafce := _daefab.(type) {
		case _g.StartElement:
			switch _cafce.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstTxWarp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstTxWarp"}:
				_dgfg.PrstTxWarp = NewCT_PresetTextShape()
				if _acfec := d.DecodeElement(_dgfg.PrstTxWarp, &_cafce); _acfec != nil {
					return _acfec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noAutofit"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noAutofit"}:
				_dgfg.NoAutofit = NewCT_TextNoAutofit()
				if _gcdfc := d.DecodeElement(_dgfg.NoAutofit, &_cafce); _gcdfc != nil {
					return _gcdfc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "normAutofit"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "normAutofit"}:
				_dgfg.NormAutofit = NewCT_TextNormalAutofit()
				if _eadgab := d.DecodeElement(_dgfg.NormAutofit, &_cafce); _eadgab != nil {
					return _eadgab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "spAutoFit"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "spAutoFit"}:
				_dgfg.SpAutoFit = NewCT_TextShapeAutofit()
				if _cdbbg := d.DecodeElement(_dgfg.SpAutoFit, &_cafce); _cdbbg != nil {
					return _cdbbg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scene3d"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scene3d"}:
				_dgfg.Scene3d = NewCT_Scene3D()
				if _cgacf := d.DecodeElement(_dgfg.Scene3d, &_cafce); _cgacf != nil {
					return _cgacf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sp3d"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sp3d"}:
				_dgfg.Sp3d = NewCT_Shape3D()
				if _gfgbg := d.DecodeElement(_dgfg.Sp3d, &_cafce); _gfgbg != nil {
					return _gfgbg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "flatTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "flatTx"}:
				_dgfg.FlatTx = NewCT_FlatText()
				if _bddf := d.DecodeElement(_dgfg.FlatTx, &_cafce); _bddf != nil {
					return _bddf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_dgfg.ExtLst = NewCT_OfficeArtExtensionList()
				if _acada := d.DecodeElement(_dgfg.ExtLst, &_cafce); _acada != nil {
					return _acada
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_TextBodyProperties\u0020\u0025v", _cafce.Name)
				if _afabb := d.Skip(); _afabb != nil {
					return _afabb
				}
			}
		case _g.EndElement:
			break _bbfcc
		case _g.CharData:
		}
	}
	return nil
}
func (_afdac ST_TextSpacingPercentOrPercentString) String() string {
	if _afdac.ST_TextSpacingPercent != nil {
		return _dcf.Sprintf("\u0025v", *_afdac.ST_TextSpacingPercent)
	}
	if _afdac.ST_Percentage != nil {
		return _dcf.Sprintf("\u0025v", *_afdac.ST_Percentage)
	}
	return ""
}

// ST_TextFontScalePercentOrPercentString is a union type
type ST_TextFontScalePercentOrPercentString struct {
	ST_TextFontScalePercent *int32
	ST_Percentage           *string
}

// Validate validates the CT_LuminanceEffect and its children
func (_faeed *CT_LuminanceEffect) Validate() error {
	return _faeed.ValidateWithPath("CT_LuminanceEffect")
}
func (_cdacb ST_TextFontAlignType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_gabbe := _g.Attr{}
	_gabbe.Name = name
	switch _cdacb {
	case ST_TextFontAlignTypeUnset:
		_gabbe.Value = ""
	case ST_TextFontAlignTypeAuto:
		_gabbe.Value = "auto"
	case ST_TextFontAlignTypeT:
		_gabbe.Value = "t"
	case ST_TextFontAlignTypeCtr:
		_gabbe.Value = "ctr"
	case ST_TextFontAlignTypeBase:
		_gabbe.Value = "base"
	case ST_TextFontAlignTypeB:
		_gabbe.Value = "b"
	}
	return _gabbe, nil
}

// Validate validates the CT_TableBackgroundStyle and its children
func (_cebgg *CT_TableBackgroundStyle) Validate() error {
	return _cebgg.ValidateWithPath("CT_TableBackgroundStyle")
}
func (_febcf ST_LightRigDirection) Validate() error { return _febcf.ValidateWithPath("") }

const (
	ST_EffectContainerTypeUnset ST_EffectContainerType = 0
	ST_EffectContainerTypeSib   ST_EffectContainerType = 1
	ST_EffectContainerTypeTree  ST_EffectContainerType = 2
)

func NewCT_RelativeRect() *CT_RelativeRect { _cdbac := &CT_RelativeRect{}; return _cdbac }

// Validate validates the CT_CustomColor and its children
func (_agef *CT_CustomColor) Validate() error { return _agef.ValidateWithPath("CT_CustomColor") }
func (_bdf *CT_AlphaOutsetEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fbd := range start.Attr {
		if _fbd.Name.Local == "rad" {
			_dcd, _gfc := ParseUnionST_Coordinate(_fbd.Value)
			if _gfc != nil {
				return _gfc
			}
			_bdf.RadAttr = &_dcd
			continue
		}
	}
	for {
		_ebb, _fege := d.Token()
		if _fege != nil {
			return _dcf.Errorf("parsing\u0020CT_AlphaOutsetEffect:\u0020\u0025s", _fege)
		}
		if _facc, _bcc := _ebb.(_g.EndElement); _bcc && _facc.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_GvmlTextShape and its children
func (_cccd *CT_GvmlTextShape) Validate() error { return _cccd.ValidateWithPath("CT_GvmlTextShape") }
func NewCT_SystemColor() *CT_SystemColor {
	_cbdfc := &CT_SystemColor{}
	_cbdfc.ValAttr = ST_SystemColorVal(1)
	return _cbdfc
}
func (_cdcdb ST_PresetCameraType) ValidateWithPath(path string) error {
	switch _cdcdb {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cdcdb))
	}
	return nil
}

type ST_PresetLineDashVal byte

func (_fbceb ST_TextVertOverflowType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_fbceb.String(), start)
}

// Validate validates the CT_GeomGuide and its children
func (_efgaeg *CT_GeomGuide) Validate() error { return _efgaeg.ValidateWithPath("CT_GeomGuide") }

// Validate validates the CT_TextFont and its children
func (_efgada *CT_TextFont) Validate() error { return _efgada.ValidateWithPath("CT_TextFont") }
func (_dgcge *ST_DgmBuildStep) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_dgcge = 0
	case "sp":
		*_dgcge = 1
	case "bg":
		*_dgcge = 2
	}
	return nil
}

type CT_LineJoinBevel struct{}

func (_adcgf ST_AnimationBuildType) String() string {
	switch _adcgf {
	case 0:
		return ""
	case 1:
		return "allAtOnce"
	}
	return ""
}
func NewEG_ThemeableEffectStyle() *EG_ThemeableEffectStyle {
	_gccgd := &EG_ThemeableEffectStyle{}
	return _gccgd
}
func (_efgaf *CT_CustomColorList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _efgaf.CustClr != nil {
		_beba := _g.StartElement{Name: _g.Name{Local: "a:custClr"}}
		for _, _bdfa := range _efgaf.CustClr {
			e.EncodeElement(_bdfa, _beba)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_TextBulletColorFollowText struct{}

func (_ffdaa ST_SystemColorVal) String() string {
	switch _ffdaa {
	case 0:
		return ""
	case 1:
		return "scrollBar"
	case 2:
		return "background"
	case 3:
		return "activeCaption"
	case 4:
		return "inactiveCaption"
	case 5:
		return "menu"
	case 6:
		return "window"
	case 7:
		return "windowFrame"
	case 8:
		return "menuText"
	case 9:
		return "windowText"
	case 10:
		return "captionText"
	case 11:
		return "activeBorder"
	case 12:
		return "inactiveBorder"
	case 13:
		return "appWorkspace"
	case 14:
		return "highlight"
	case 15:
		return "highlightText"
	case 16:
		return "btnFace"
	case 17:
		return "btnShadow"
	case 18:
		return "grayText"
	case 19:
		return "btnText"
	case 20:
		return "inactiveCaptionText"
	case 21:
		return "btnHighlight"
	case 22:
		return "3dDkShadow"
	case 23:
		return "3dLight"
	case 24:
		return "infoText"
	case 25:
		return "infoBk"
	case 26:
		return "hotLight"
	case 27:
		return "gradientActiveCaption"
	case 28:
		return "gradientInactiveCaption"
	case 29:
		return "menuHighlight"
	case 30:
		return "menuBar"
	}
	return ""
}
func (_bafga *CT_StyleMatrixReference) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _abfeg := range start.Attr {
		if _abfeg.Name.Local == "idx" {
			_dbfcf, _cdgd := _e.ParseUint(_abfeg.Value, 10, 32)
			if _cdgd != nil {
				return _cdgd
			}
			_bafga.IdxAttr = uint32(_dbfcf)
			continue
		}
	}
_ebbe:
	for {
		_gdbgd, _gbffd := d.Token()
		if _gbffd != nil {
			return _gbffd
		}
		switch _baffc := _gdbgd.(type) {
		case _g.StartElement:
			switch _baffc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_bafga.ScrgbClr = NewCT_ScRgbColor()
				if _ccbgb := d.DecodeElement(_bafga.ScrgbClr, &_baffc); _ccbgb != nil {
					return _ccbgb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_bafga.SrgbClr = NewCT_SRgbColor()
				if _affcd := d.DecodeElement(_bafga.SrgbClr, &_baffc); _affcd != nil {
					return _affcd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_bafga.HslClr = NewCT_HslColor()
				if _acbbc := d.DecodeElement(_bafga.HslClr, &_baffc); _acbbc != nil {
					return _acbbc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_bafga.SysClr = NewCT_SystemColor()
				if _dgfdf := d.DecodeElement(_bafga.SysClr, &_baffc); _dgfdf != nil {
					return _dgfdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_bafga.SchemeClr = NewCT_SchemeColor()
				if _daeg := d.DecodeElement(_bafga.SchemeClr, &_baffc); _daeg != nil {
					return _daeg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_bafga.PrstClr = NewCT_PresetColor()
				if _egfde := d.DecodeElement(_bafga.PrstClr, &_baffc); _egfde != nil {
					return _egfde
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_StyleMatrixReference \u0025v", _baffc.Name)
				if _febde := d.Skip(); _febde != nil {
					return _febde
				}
			}
		case _g.EndElement:
			break _ebbe
		case _g.CharData:
		}
	}
	return nil
}

const (
	ST_LineEndTypeUnset    ST_LineEndType = 0
	ST_LineEndTypeNone     ST_LineEndType = 1
	ST_LineEndTypeTriangle ST_LineEndType = 2
	ST_LineEndTypeStealth  ST_LineEndType = 3
	ST_LineEndTypeDiamond  ST_LineEndType = 4
	ST_LineEndTypeOval     ST_LineEndType = 5
	ST_LineEndTypeArrow    ST_LineEndType = 6
)

// ValidateWithPath validates the CT_AlphaCeilingEffect and its children, prefixing error messages with path
func (_fdg *CT_AlphaCeilingEffect) ValidateWithPath(path string) error { return nil }
func NewCT_AlphaReplaceEffect() *CT_AlphaReplaceEffect                 { _gag := &CT_AlphaReplaceEffect{}; return _gag }

type CT_TableProperties struct {
	RtlAttr      *bool
	FirstRowAttr *bool
	FirstColAttr *bool
	LastRowAttr  *bool
	LastColAttr  *bool
	BandRowAttr  *bool
	BandColAttr  *bool
	NoFill       *CT_NoFillProperties
	SolidFill    *CT_SolidColorFillProperties
	GradFill     *CT_GradientFillProperties
	BlipFill     *CT_BlipFillProperties
	PattFill     *CT_PatternFillProperties
	GrpFill      *CT_GroupFillProperties
	EffectLst    *CT_EffectList
	EffectDag    *CT_EffectContainer
	Choice       *CT_TablePropertiesChoice
	ExtLst       *CT_OfficeArtExtensionList
}

const (
	ST_LineEndWidthUnset ST_LineEndWidth = 0
	ST_LineEndWidthSm    ST_LineEndWidth = 1
	ST_LineEndWidthMed   ST_LineEndWidth = 2
	ST_LineEndWidthLg    ST_LineEndWidth = 3
)

type CT_BlurEffect struct {
	RadAttr  *int64
	GrowAttr *bool
}

func (_ffdga *EG_EffectProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fadbg:
	for {
		_gbcef, _gdecg := d.Token()
		if _gdecg != nil {
			return _gdecg
		}
		switch _agcga := _gbcef.(type) {
		case _g.StartElement:
			switch _agcga.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectLst"}:
				_ffdga.EffectLst = NewCT_EffectList()
				if _aedb := d.DecodeElement(_ffdga.EffectLst, &_agcga); _aedb != nil {
					return _aedb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectDag"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectDag"}:
				_ffdga.EffectDag = NewCT_EffectContainer()
				if _agcad := d.DecodeElement(_ffdga.EffectDag, &_agcga); _agcad != nil {
					return _agcad
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_EffectProperties\u0020\u0025v", _agcga.Name)
				if _abcba := d.Skip(); _abcba != nil {
					return _abcba
				}
			}
		case _g.EndElement:
			break _fadbg
		case _g.CharData:
		}
	}
	return nil
}
func (_cafb *CT_GvmlTextShapeChoice) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fageg:
	for {
		_bdcd, _cacbd := d.Token()
		if _cacbd != nil {
			return _cacbd
		}
		switch _faaa := _bdcd.(type) {
		case _g.StartElement:
			switch _faaa.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "useSpRect"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "useSpRect"}:
				_cafb.UseSpRect = NewCT_GvmlUseShapeRectangle()
				if _cedage := d.DecodeElement(_cafb.UseSpRect, &_faaa); _cedage != nil {
					return _cedage
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "xfrm"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "xfrm"}:
				_cafb.Xfrm = NewCT_Transform2D()
				if _gbaac := d.DecodeElement(_cafb.Xfrm, &_faaa); _gbaac != nil {
					return _gbaac
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GvmlTextShapeChoice\u0020\u0025v", _faaa.Name)
				if _cdfed := d.Skip(); _cdfed != nil {
					return _cdfed
				}
			}
		case _g.EndElement:
			break _fageg
		case _g.CharData:
		}
	}
	return nil
}
func (_cgeff ST_LineEndWidth) ValidateWithPath(path string) error {
	switch _cgeff {
	case 0, 1, 2, 3:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cgeff))
	}
	return nil
}
func (_cfbcg ST_LineEndType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dabfd := _g.Attr{}
	_dabfd.Name = name
	switch _cfbcg {
	case ST_LineEndTypeUnset:
		_dabfd.Value = ""
	case ST_LineEndTypeNone:
		_dabfd.Value = "none"
	case ST_LineEndTypeTriangle:
		_dabfd.Value = "triangle"
	case ST_LineEndTypeStealth:
		_dabfd.Value = "stealth"
	case ST_LineEndTypeDiamond:
		_dabfd.Value = "diamond"
	case ST_LineEndTypeOval:
		_dabfd.Value = "oval"
	case ST_LineEndTypeArrow:
		_dabfd.Value = "arrow"
	}
	return _dabfd, nil
}

// Validate validates the CT_SystemColor and its children
func (_abadf *CT_SystemColor) Validate() error { return _abadf.ValidateWithPath("CT_SystemColor") }
func (_gfacf *EG_ColorTransform) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_bagdf:
	for {
		_ccbcf, _fcebfb := d.Token()
		if _fcebfb != nil {
			return _fcebfb
		}
		switch _dcegac := _ccbcf.(type) {
		case _g.StartElement:
			switch _dcegac.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_gfacf.Tint = NewCT_PositiveFixedPercentage()
				if _eddgec := d.DecodeElement(_gfacf.Tint, &_dcegac); _eddgec != nil {
					return _eddgec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "shade"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "shade"}:
				_gfacf.Shade = NewCT_PositiveFixedPercentage()
				if _cbdede := d.DecodeElement(_gfacf.Shade, &_dcegac); _cbdede != nil {
					return _cbdede
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "comp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "comp"}:
				_gfacf.Comp = NewCT_ComplementTransform()
				if _ceage := d.DecodeElement(_gfacf.Comp, &_dcegac); _ceage != nil {
					return _ceage
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "inv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "inv"}:
				_gfacf.Inv = NewCT_InverseTransform()
				if _badgd := d.DecodeElement(_gfacf.Inv, &_dcegac); _badgd != nil {
					return _badgd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gray"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gray"}:
				_gfacf.Gray = NewCT_GrayscaleTransform()
				if _bfffc := d.DecodeElement(_gfacf.Gray, &_dcegac); _bfffc != nil {
					return _bfffc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alpha"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alpha"}:
				_gfacf.Alpha = NewCT_PositiveFixedPercentage()
				if _ggefad := d.DecodeElement(_gfacf.Alpha, &_dcegac); _ggefad != nil {
					return _ggefad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaOff"}:
				_gfacf.AlphaOff = NewCT_FixedPercentage()
				if _bdgbc := d.DecodeElement(_gfacf.AlphaOff, &_dcegac); _bdgbc != nil {
					return _bdgbc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_gfacf.AlphaMod = NewCT_PositivePercentage()
				if _adaad := d.DecodeElement(_gfacf.AlphaMod, &_dcegac); _adaad != nil {
					return _adaad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hue"}:
				_gfacf.Hue = NewCT_PositiveFixedAngle()
				if _bgfdg := d.DecodeElement(_gfacf.Hue, &_dcegac); _bgfdg != nil {
					return _bgfdg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueOff"}:
				_gfacf.HueOff = NewCT_Angle()
				if _egdec := d.DecodeElement(_gfacf.HueOff, &_dcegac); _egdec != nil {
					return _egdec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueMod"}:
				_gfacf.HueMod = NewCT_PositivePercentage()
				if _bbbccd := d.DecodeElement(_gfacf.HueMod, &_dcegac); _bbbccd != nil {
					return _bbbccd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sat"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sat"}:
				_gfacf.Sat = NewCT_Percentage()
				if _cdeeg := d.DecodeElement(_gfacf.Sat, &_dcegac); _cdeeg != nil {
					return _cdeeg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satOff"}:
				_gfacf.SatOff = NewCT_Percentage()
				if _bgdfc := d.DecodeElement(_gfacf.SatOff, &_dcegac); _bgdfc != nil {
					return _bgdfc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satMod"}:
				_gfacf.SatMod = NewCT_Percentage()
				if _cfecb := d.DecodeElement(_gfacf.SatMod, &_dcegac); _cfecb != nil {
					return _cfecb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_gfacf.Lum = NewCT_Percentage()
				if _baea := d.DecodeElement(_gfacf.Lum, &_dcegac); _baea != nil {
					return _baea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumOff"}:
				_gfacf.LumOff = NewCT_Percentage()
				if _fcaff := d.DecodeElement(_gfacf.LumOff, &_dcegac); _fcaff != nil {
					return _fcaff
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumMod"}:
				_gfacf.LumMod = NewCT_Percentage()
				if _aabeea := d.DecodeElement(_gfacf.LumMod, &_dcegac); _aabeea != nil {
					return _aabeea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "red"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "red"}:
				_gfacf.Red = NewCT_Percentage()
				if _gfcab := d.DecodeElement(_gfacf.Red, &_dcegac); _gfcab != nil {
					return _gfcab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redOff"}:
				_gfacf.RedOff = NewCT_Percentage()
				if _badgb := d.DecodeElement(_gfacf.RedOff, &_dcegac); _badgb != nil {
					return _badgb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redMod"}:
				_gfacf.RedMod = NewCT_Percentage()
				if _ggebb := d.DecodeElement(_gfacf.RedMod, &_dcegac); _ggebb != nil {
					return _ggebb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "green"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "green"}:
				_gfacf.Green = NewCT_Percentage()
				if _gadec := d.DecodeElement(_gfacf.Green, &_dcegac); _gadec != nil {
					return _gadec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenOff"}:
				_gfacf.GreenOff = NewCT_Percentage()
				if _dfbgf := d.DecodeElement(_gfacf.GreenOff, &_dcegac); _dfbgf != nil {
					return _dfbgf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenMod"}:
				_gfacf.GreenMod = NewCT_Percentage()
				if _ddfdg := d.DecodeElement(_gfacf.GreenMod, &_dcegac); _ddfdg != nil {
					return _ddfdg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blue"}:
				_gfacf.Blue = NewCT_Percentage()
				if _addag := d.DecodeElement(_gfacf.Blue, &_dcegac); _addag != nil {
					return _addag
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueOff"}:
				_gfacf.BlueOff = NewCT_Percentage()
				if _ccaab := d.DecodeElement(_gfacf.BlueOff, &_dcegac); _ccaab != nil {
					return _ccaab
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueMod"}:
				_gfacf.BlueMod = NewCT_Percentage()
				if _eaefag := d.DecodeElement(_gfacf.BlueMod, &_dcegac); _eaefag != nil {
					return _eaefag
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gamma"}:
				_gfacf.Gamma = NewCT_GammaTransform()
				if _edfec := d.DecodeElement(_gfacf.Gamma, &_dcegac); _edfec != nil {
					return _edfec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "invGamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "invGamma"}:
				_gfacf.InvGamma = NewCT_InverseGammaTransform()
				if _bfegd := d.DecodeElement(_gfacf.InvGamma, &_dcegac); _bfegd != nil {
					return _bfegd
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020EG_ColorTransform\u0020\u0025v", _dcegac.Name)
				if _abeed := d.Skip(); _abeed != nil {
					return _abeed
				}
			}
		case _g.EndElement:
			break _bagdf
		case _g.CharData:
		}
	}
	return nil
}

type CT_NoFillProperties struct{}

func (_bddab *ST_AnimationDgmOnlyBuildType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_egggg, _fedgb := d.Token()
	if _fedgb != nil {
		return _fedgb
	}
	if _ddede, _gbega := _egggg.(_g.EndElement); _gbega && _ddede.Name == start.Name {
		*_bddab = 1
		return nil
	}
	if _adbefe, _bebef := _egggg.(_g.CharData); !_bebef {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _egggg)
	} else {
		switch string(_adbefe) {
		case "":
			*_bddab = 0
		case "one":
			*_bddab = 1
		case "lvlOne":
			*_bddab = 2
		case "lvlAtOnce":
			*_bddab = 3
		}
	}
	_egggg, _fedgb = d.Token()
	if _fedgb != nil {
		return _fedgb
	}
	if _bcaef, _aeecd := _egggg.(_g.EndElement); _aeecd && _bcaef.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _egggg)
}
func (_fbdcd *ST_TextVertOverflowType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fbdcd = 0
	case "overflow":
		*_fbdcd = 1
	case "ellipsis":
		*_fbdcd = 2
	case "clip":
		*_fbdcd = 3
	}
	return nil
}
func (_afegga ST_ColorSchemeIndex) String() string {
	switch _afegga {
	case 0:
		return ""
	case 1:
		return "dk1"
	case 2:
		return "lt1"
	case 3:
		return "dk2"
	case 4:
		return "lt2"
	case 5:
		return "accent1"
	case 6:
		return "accent2"
	case 7:
		return "accent3"
	case 8:
		return "accent4"
	case 9:
		return "accent5"
	case 10:
		return "accent6"
	case 11:
		return "hlink"
	case 12:
		return "folHlink"
	}
	return ""
}
func NewTbl() *Tbl { _degfb := &Tbl{}; _degfb.CT_Table = *NewCT_Table(); return _degfb }
func (_dbdgb *ST_LightRigType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ccdafb, _baaca := d.Token()
	if _baaca != nil {
		return _baaca
	}
	if _efaed, _fbgegc := _ccdafb.(_g.EndElement); _fbgegc && _efaed.Name == start.Name {
		*_dbdgb = 1
		return nil
	}
	if _fgeae, _eabcf := _ccdafb.(_g.CharData); !_eabcf {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ccdafb)
	} else {
		switch string(_fgeae) {
		case "":
			*_dbdgb = 0
		case "legacyFlat1":
			*_dbdgb = 1
		case "legacyFlat2":
			*_dbdgb = 2
		case "legacyFlat3":
			*_dbdgb = 3
		case "legacyFlat4":
			*_dbdgb = 4
		case "legacyNormal1":
			*_dbdgb = 5
		case "legacyNormal2":
			*_dbdgb = 6
		case "legacyNormal3":
			*_dbdgb = 7
		case "legacyNormal4":
			*_dbdgb = 8
		case "legacyHarsh1":
			*_dbdgb = 9
		case "legacyHarsh2":
			*_dbdgb = 10
		case "legacyHarsh3":
			*_dbdgb = 11
		case "legacyHarsh4":
			*_dbdgb = 12
		case "threePt":
			*_dbdgb = 13
		case "balanced":
			*_dbdgb = 14
		case "soft":
			*_dbdgb = 15
		case "harsh":
			*_dbdgb = 16
		case "flood":
			*_dbdgb = 17
		case "contrasting":
			*_dbdgb = 18
		case "morning":
			*_dbdgb = 19
		case "sunrise":
			*_dbdgb = 20
		case "sunset":
			*_dbdgb = 21
		case "chilly":
			*_dbdgb = 22
		case "freezing":
			*_dbdgb = 23
		case "flat":
			*_dbdgb = 24
		case "twoPt":
			*_dbdgb = 25
		case "glow":
			*_dbdgb = 26
		case "brightRoom":
			*_dbdgb = 27
		}
	}
	_ccdafb, _baaca = d.Token()
	if _baaca != nil {
		return _baaca
	}
	if _dcbbd, _daaga := _ccdafb.(_g.EndElement); _daaga && _dcbbd.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ccdafb)
}

// ValidateWithPath validates the CT_Point3D and its children, prefixing error messages with path
func (_febae *CT_Point3D) ValidateWithPath(path string) error {
	if _egegg := _febae.XAttr.ValidateWithPath(path + "\u002fXAttr"); _egegg != nil {
		return _egegg
	}
	if _dffgd := _febae.YAttr.ValidateWithPath(path + "\u002fYAttr"); _dffgd != nil {
		return _dffgd
	}
	if _cbeff := _febae.ZAttr.ValidateWithPath(path + "\u002fZAttr"); _cbeff != nil {
		return _cbeff
	}
	return nil
}

type ST_CompoundLine byte

func NewCT_ContentPartLocking() *CT_ContentPartLocking {
	_gcaf := &CT_ContentPartLocking{}
	return _gcaf
}

// Validate validates the CT_ComplementTransform and its children
func (_edecb *CT_ComplementTransform) Validate() error {
	return _edecb.ValidateWithPath("CT_ComplementTransform")
}
func (_fgbb *CT_XYAdjustHandle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fgbb.GdRefXAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "gdRefX"}, Value: _dcf.Sprintf("\u0025v", *_fgbb.GdRefXAttr)})
	}
	if _fgbb.MinXAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "minX"}, Value: _dcf.Sprintf("\u0025v", *_fgbb.MinXAttr)})
	}
	if _fgbb.MaxXAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "maxX"}, Value: _dcf.Sprintf("\u0025v", *_fgbb.MaxXAttr)})
	}
	if _fgbb.GdRefYAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "gdRefY"}, Value: _dcf.Sprintf("\u0025v", *_fgbb.GdRefYAttr)})
	}
	if _fgbb.MinYAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "minY"}, Value: _dcf.Sprintf("\u0025v", *_fgbb.MinYAttr)})
	}
	if _fgbb.MaxYAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "maxY"}, Value: _dcf.Sprintf("\u0025v", *_fgbb.MaxYAttr)})
	}
	e.EncodeToken(start)
	_gagfb := _g.StartElement{Name: _g.Name{Local: "a:pos"}}
	e.EncodeElement(_fgbb.Pos, _gagfb)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_fddafg *ST_LightRigDirection) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fddafg = 0
	case "tl":
		*_fddafg = 1
	case "t":
		*_fddafg = 2
	case "tr":
		*_fddafg = 3
	case "l":
		*_fddafg = 4
	case "r":
		*_fddafg = 5
	case "bl":
		*_fddafg = 6
	case "b":
		*_fddafg = 7
	case "br":
		*_fddafg = 8
	}
	return nil
}

type CT_GroupShapeProperties struct {
	BwModeAttr ST_BlackWhiteMode
	Xfrm       *CT_GroupTransform2D
	NoFill     *CT_NoFillProperties
	SolidFill  *CT_SolidColorFillProperties
	GradFill   *CT_GradientFillProperties
	BlipFill   *CT_BlipFillProperties
	PattFill   *CT_PatternFillProperties
	GrpFill    *CT_GroupFillProperties
	EffectLst  *CT_EffectList
	EffectDag  *CT_EffectContainer
	Scene3d    *CT_Scene3D
	ExtLst     *CT_OfficeArtExtensionList
}

func (_gaebe *ST_TextPoint) Validate() error { return _gaebe.ValidateWithPath("") }

type EG_Media struct {
	AudioCd       *CT_AudioCD
	WavAudioFile  *CT_EmbeddedWAVAudioFile
	AudioFile     *CT_AudioFile
	VideoFile     *CT_VideoFile
	QuickTimeFile *CT_QuickTimeFile
}

// ValidateWithPath validates the CT_AlphaFloorEffect and its children, prefixing error messages with path
func (_cd *CT_AlphaFloorEffect) ValidateWithPath(path string) error { return nil }
func (_edcg *CT_AudioFile) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _gcda := range start.Attr {
		if _gcda.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _gcda.Name.Local == "link" || _gcda.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _gcda.Name.Local == "link" {
			_dddf, _afgf := _gcda.Value, error(nil)
			if _afgf != nil {
				return _afgf
			}
			_edcg.LinkAttr = _dddf
			continue
		}
		if _gcda.Name.Local == "contentType" {
			_ebfcb, _ebgg := _gcda.Value, error(nil)
			if _ebgg != nil {
				return _ebgg
			}
			_edcg.ContentTypeAttr = &_ebfcb
			continue
		}
	}
_bef:
	for {
		_acee, _fegb := d.Token()
		if _fegb != nil {
			return _fegb
		}
		switch _dgac := _acee.(type) {
		case _g.StartElement:
			switch _dgac.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_edcg.ExtLst = NewCT_OfficeArtExtensionList()
				if _gcdd := d.DecodeElement(_edcg.ExtLst, &_dgac); _gcdd != nil {
					return _gcdd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_AudioFile\u0020\u0025v", _dgac.Name)
				if _dfgd := d.Skip(); _dfgd != nil {
					return _dfgd
				}
			}
		case _g.EndElement:
			break _bef
		case _g.CharData:
		}
	}
	return nil
}
func ParseUnionST_TextSpacingPercentOrPercentString(s string) (ST_TextSpacingPercentOrPercentString, error) {
	_eccb := ST_TextSpacingPercentOrPercentString{}
	if _f.ST_PercentagePatternRe.MatchString(s) {
		_eccb.ST_Percentage = &s
	} else {
		_acebf, _begfb := _e.ParseInt(s, 10, 64)
		if _begfb != nil {
			return _eccb, _dcf.Errorf("parsing\u0020\u0025s\u0020as\u0020int", _begfb)
		}
		_aagab := int32(_acebf)
		_eccb.ST_TextSpacingPercent = &_aagab
	}
	return _eccb, nil
}
func (_geea *CT_TextSpacingPercent) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", _geea.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_DuotoneEffect struct{ EG_ColorChoice []*EG_ColorChoice }

func (_gbefa ST_ColorSchemeIndex) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_aebge := _g.Attr{}
	_aebge.Name = name
	switch _gbefa {
	case ST_ColorSchemeIndexUnset:
		_aebge.Value = ""
	case ST_ColorSchemeIndexDk1:
		_aebge.Value = "dk1"
	case ST_ColorSchemeIndexLt1:
		_aebge.Value = "lt1"
	case ST_ColorSchemeIndexDk2:
		_aebge.Value = "dk2"
	case ST_ColorSchemeIndexLt2:
		_aebge.Value = "lt2"
	case ST_ColorSchemeIndexAccent1:
		_aebge.Value = "accent1"
	case ST_ColorSchemeIndexAccent2:
		_aebge.Value = "accent2"
	case ST_ColorSchemeIndexAccent3:
		_aebge.Value = "accent3"
	case ST_ColorSchemeIndexAccent4:
		_aebge.Value = "accent4"
	case ST_ColorSchemeIndexAccent5:
		_aebge.Value = "accent5"
	case ST_ColorSchemeIndexAccent6:
		_aebge.Value = "accent6"
	case ST_ColorSchemeIndexHlink:
		_aebge.Value = "hlink"
	case ST_ColorSchemeIndexFolHlink:
		_aebge.Value = "folHlink"
	}
	return _aebge, nil
}

// Validate validates the CT_TableStyleList and its children
func (_fffef *CT_TableStyleList) Validate() error {
	return _fffef.ValidateWithPath("CT_TableStyleList")
}
func (_dcagaf *CT_TextParagraph) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_efcdb:
	for {
		_fbgeg, _dbfag := d.Token()
		if _dbfag != nil {
			return _dbfag
		}
		switch _gfcdf := _fbgeg.(type) {
		case _g.StartElement:
			switch _gfcdf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pPr"}:
				_dcagaf.PPr = NewCT_TextParagraphProperties()
				if _adefg := d.DecodeElement(_dcagaf.PPr, &_gfcdf); _adefg != nil {
					return _adefg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "r"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "r"}:
				_beacg := NewEG_TextRun()
				_beacg.R = NewCT_RegularTextRun()
				if _baeeb := d.DecodeElement(_beacg.R, &_gfcdf); _baeeb != nil {
					return _baeeb
				}
				_dcagaf.EG_TextRun = append(_dcagaf.EG_TextRun, _beacg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "br"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "br"}:
				_bgbfdb := NewEG_TextRun()
				_bgbfdb.Br = NewCT_TextLineBreak()
				if _bddefa := d.DecodeElement(_bgbfdb.Br, &_gfcdf); _bddefa != nil {
					return _bddefa
				}
				_dcagaf.EG_TextRun = append(_dcagaf.EG_TextRun, _bgbfdb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fld"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fld"}:
				_adaffg := NewEG_TextRun()
				_adaffg.Fld = NewCT_TextField()
				if _dadfgd := d.DecodeElement(_adaffg.Fld, &_gfcdf); _dadfgd != nil {
					return _dadfgd
				}
				_dcagaf.EG_TextRun = append(_dcagaf.EG_TextRun, _adaffg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "endParaRPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "endParaRPr"}:
				_dcagaf.EndParaRPr = NewCT_TextCharacterProperties()
				if _ceef := d.DecodeElement(_dcagaf.EndParaRPr, &_gfcdf); _ceef != nil {
					return _ceef
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TextParagraph\u0020\u0025v", _gfcdf.Name)
				if _aaad := d.Skip(); _aaad != nil {
					return _aaad
				}
			}
		case _g.EndElement:
			break _efcdb
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_NoFillProperties and its children, prefixing error messages with path
func (_eegc *CT_NoFillProperties) ValidateWithPath(path string) error { return nil }
func (_edbefa ST_BlackWhiteMode) Validate() error                     { return _edbefa.ValidateWithPath("") }

type CT_AnimationDgmElement struct {
	IdAttr      *string
	BldStepAttr ST_DgmBuildStep
}
type ST_TextVerticalType byte

func NewCT_EffectStyleList() *CT_EffectStyleList { _fdfg := &CT_EffectStyleList{}; return _fdfg }

// Validate validates the CT_Hyperlink and its children
func (_geac *CT_Hyperlink) Validate() error { return _geac.ValidateWithPath("CT_Hyperlink") }
func (_eadbf *CT_EffectProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _eadbf.EffectLst != nil {
		_dfbd := _g.StartElement{Name: _g.Name{Local: "a:effectLst"}}
		e.EncodeElement(_eadbf.EffectLst, _dfbd)
	}
	if _eadbf.EffectDag != nil {
		_ecbbg := _g.StartElement{Name: _g.Name{Local: "a:effectDag"}}
		e.EncodeElement(_eadbf.EffectDag, _ecbbg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_afeaf *CT_StyleMatrixReference) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "idx"}, Value: _dcf.Sprintf("\u0025v", _afeaf.IdxAttr)})
	e.EncodeToken(start)
	if _afeaf.ScrgbClr != nil {
		_bbcfef := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_afeaf.ScrgbClr, _bbcfef)
	}
	if _afeaf.SrgbClr != nil {
		_bfgeee := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_afeaf.SrgbClr, _bfgeee)
	}
	if _afeaf.HslClr != nil {
		_aaege := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_afeaf.HslClr, _aaege)
	}
	if _afeaf.SysClr != nil {
		_dcbgb := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_afeaf.SysClr, _dcbgb)
	}
	if _afeaf.SchemeClr != nil {
		_fbbec := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_afeaf.SchemeClr, _fbbec)
	}
	if _afeaf.PrstClr != nil {
		_degfg := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_afeaf.PrstClr, _degfg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_cgfcb *CT_TextUnderlineFillFollowText) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_GroupFillProperties() *CT_GroupFillProperties {
	_caebc := &CT_GroupFillProperties{}
	return _caebc
}

type CT_GraphicalObjectFrameLocking struct {
	NoGrpAttr          *bool
	NoDrilldownAttr    *bool
	NoSelectAttr       *bool
	NoChangeAspectAttr *bool
	NoMoveAttr         *bool
	NoResizeAttr       *bool
	ExtLst             *CT_OfficeArtExtensionList
}

// Validate validates the CT_TextBulletColorFollowText and its children
func (_bgaab *CT_TextBulletColorFollowText) Validate() error {
	return _bgaab.ValidateWithPath("CT_TextBulletColorFollowText")
}
func (_cadb *CT_GvmlTextShapeChoice) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _cadb.UseSpRect != nil {
		_ecaee := _g.StartElement{Name: _g.Name{Local: "a:useSpRect"}}
		e.EncodeElement(_cadb.UseSpRect, _ecaee)
	}
	if _cadb.Xfrm != nil {
		_baeee := _g.StartElement{Name: _g.Name{Local: "a:xfrm"}}
		e.EncodeElement(_cadb.Xfrm, _baeee)
	}
	return nil
}
func (_dbdeg ST_SchemeColorVal) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ebbaa := _g.Attr{}
	_ebbaa.Name = name
	switch _dbdeg {
	case ST_SchemeColorValUnset:
		_ebbaa.Value = ""
	case ST_SchemeColorValBg1:
		_ebbaa.Value = "bg1"
	case ST_SchemeColorValTx1:
		_ebbaa.Value = "tx1"
	case ST_SchemeColorValBg2:
		_ebbaa.Value = "bg2"
	case ST_SchemeColorValTx2:
		_ebbaa.Value = "tx2"
	case ST_SchemeColorValAccent1:
		_ebbaa.Value = "accent1"
	case ST_SchemeColorValAccent2:
		_ebbaa.Value = "accent2"
	case ST_SchemeColorValAccent3:
		_ebbaa.Value = "accent3"
	case ST_SchemeColorValAccent4:
		_ebbaa.Value = "accent4"
	case ST_SchemeColorValAccent5:
		_ebbaa.Value = "accent5"
	case ST_SchemeColorValAccent6:
		_ebbaa.Value = "accent6"
	case ST_SchemeColorValHlink:
		_ebbaa.Value = "hlink"
	case ST_SchemeColorValFolHlink:
		_ebbaa.Value = "folHlink"
	case ST_SchemeColorValPhClr:
		_ebbaa.Value = "phClr"
	case ST_SchemeColorValDk1:
		_ebbaa.Value = "dk1"
	case ST_SchemeColorValLt1:
		_ebbaa.Value = "lt1"
	case ST_SchemeColorValDk2:
		_ebbaa.Value = "dk2"
	case ST_SchemeColorValLt2:
		_ebbaa.Value = "lt2"
	}
	return _ebbaa, nil
}

// ST_Coordinate32 is a union type
type ST_Coordinate32 struct {
	ST_Coordinate32Unqualified *int32
	ST_UniversalMeasure        *string
}

func (_afdgd *ST_SchemeColorVal) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_feefg, _faddb := d.Token()
	if _faddb != nil {
		return _faddb
	}
	if _bdbedf, _dcgaa := _feefg.(_g.EndElement); _dcgaa && _bdbedf.Name == start.Name {
		*_afdgd = 1
		return nil
	}
	if _fgbae, _fbedfd := _feefg.(_g.CharData); !_fbedfd {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _feefg)
	} else {
		switch string(_fgbae) {
		case "":
			*_afdgd = 0
		case "bg1":
			*_afdgd = 1
		case "tx1":
			*_afdgd = 2
		case "bg2":
			*_afdgd = 3
		case "tx2":
			*_afdgd = 4
		case "accent1":
			*_afdgd = 5
		case "accent2":
			*_afdgd = 6
		case "accent3":
			*_afdgd = 7
		case "accent4":
			*_afdgd = 8
		case "accent5":
			*_afdgd = 9
		case "accent6":
			*_afdgd = 10
		case "hlink":
			*_afdgd = 11
		case "folHlink":
			*_afdgd = 12
		case "phClr":
			*_afdgd = 13
		case "dk1":
			*_afdgd = 14
		case "lt1":
			*_afdgd = 15
		case "dk2":
			*_afdgd = 16
		case "lt2":
			*_afdgd = 17
		}
	}
	_feefg, _faddb = d.Token()
	if _faddb != nil {
		return _faddb
	}
	if _cgbeac, _cdbgg := _feefg.(_g.EndElement); _cdbgg && _cgbeac.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _feefg)
}
func NewCT_Angle() *CT_Angle { _ddebe := &CT_Angle{}; return _ddebe }
func (_gege *CT_EffectStyleList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_acgef := _g.StartElement{Name: _g.Name{Local: "a:effectStyle"}}
	for _, _dcde := range _gege.EffectStyle {
		e.EncodeElement(_dcde, _acgef)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ggefa *CT_FixedPercentage) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _dfeec := range start.Attr {
		if _dfeec.Name.Local == "val" {
			_bcded, _dbfbb := ParseUnionST_FixedPercentage(_dfeec.Value)
			if _dbfbb != nil {
				return _dbfbb
			}
			_ggefa.ValAttr = _bcded
			continue
		}
	}
	for {
		_aeaab, _fbea := d.Token()
		if _fbea != nil {
			return _dcf.Errorf("parsing\u0020CT_FixedPercentage:\u0020\u0025s", _fbea)
		}
		if _gbdf, _cbabe := _aeaab.(_g.EndElement); _cbabe && _gbdf.Name == start.Name {
			break
		}
	}
	return nil
}

type ST_TextFontAlignType byte

// Validate validates the CT_AlphaOutsetEffect and its children
func (_dbgd *CT_AlphaOutsetEffect) Validate() error {
	return _dbgd.ValidateWithPath("CT_AlphaOutsetEffect")
}
func (_dagc *CT_AlphaModulateEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dagc.Cont = NewCT_EffectContainer()
_gfe:
	for {
		_ebfc, _bdde := d.Token()
		if _bdde != nil {
			return _bdde
		}
		switch _ddde := _ebfc.(type) {
		case _g.StartElement:
			switch _ddde.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cont"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cont"}:
				if _bff := d.DecodeElement(_dagc.Cont, &_ddde); _bff != nil {
					return _bff
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_AlphaModulateEffect\u0020\u0025v", _ddde.Name)
				if _dcb := d.Skip(); _dcb != nil {
					return _dcb
				}
			}
		case _g.EndElement:
			break _gfe
		case _g.CharData:
		}
	}
	return nil
}
func (_bgdcf *CT_PositiveSize2D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "cx"}, Value: _dcf.Sprintf("\u0025v", _bgdcf.CxAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "cy"}, Value: _dcf.Sprintf("\u0025v", _bgdcf.CyAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_NonVisualGraphicFrameProperties and its children, prefixing error messages with path
func (_babca *CT_NonVisualGraphicFrameProperties) ValidateWithPath(path string) error {
	if _babca.GraphicFrameLocks != nil {
		if _bbda := _babca.GraphicFrameLocks.ValidateWithPath(path + "\u002fGraphicFrameLocks"); _bbda != nil {
			return _bbda
		}
	}
	if _babca.ExtLst != nil {
		if _gebc := _babca.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gebc != nil {
			return _gebc
		}
	}
	return nil
}

const (
	ST_PresetPatternValUnset      ST_PresetPatternVal = 0
	ST_PresetPatternValPct5       ST_PresetPatternVal = 1
	ST_PresetPatternValPct10      ST_PresetPatternVal = 2
	ST_PresetPatternValPct20      ST_PresetPatternVal = 3
	ST_PresetPatternValPct25      ST_PresetPatternVal = 4
	ST_PresetPatternValPct30      ST_PresetPatternVal = 5
	ST_PresetPatternValPct40      ST_PresetPatternVal = 6
	ST_PresetPatternValPct50      ST_PresetPatternVal = 7
	ST_PresetPatternValPct60      ST_PresetPatternVal = 8
	ST_PresetPatternValPct70      ST_PresetPatternVal = 9
	ST_PresetPatternValPct75      ST_PresetPatternVal = 10
	ST_PresetPatternValPct80      ST_PresetPatternVal = 11
	ST_PresetPatternValPct90      ST_PresetPatternVal = 12
	ST_PresetPatternValHorz       ST_PresetPatternVal = 13
	ST_PresetPatternValVert       ST_PresetPatternVal = 14
	ST_PresetPatternValLtHorz     ST_PresetPatternVal = 15
	ST_PresetPatternValLtVert     ST_PresetPatternVal = 16
	ST_PresetPatternValDkHorz     ST_PresetPatternVal = 17
	ST_PresetPatternValDkVert     ST_PresetPatternVal = 18
	ST_PresetPatternValNarHorz    ST_PresetPatternVal = 19
	ST_PresetPatternValNarVert    ST_PresetPatternVal = 20
	ST_PresetPatternValDashHorz   ST_PresetPatternVal = 21
	ST_PresetPatternValDashVert   ST_PresetPatternVal = 22
	ST_PresetPatternValCross      ST_PresetPatternVal = 23
	ST_PresetPatternValDnDiag     ST_PresetPatternVal = 24
	ST_PresetPatternValUpDiag     ST_PresetPatternVal = 25
	ST_PresetPatternValLtDnDiag   ST_PresetPatternVal = 26
	ST_PresetPatternValLtUpDiag   ST_PresetPatternVal = 27
	ST_PresetPatternValDkDnDiag   ST_PresetPatternVal = 28
	ST_PresetPatternValDkUpDiag   ST_PresetPatternVal = 29
	ST_PresetPatternValWdDnDiag   ST_PresetPatternVal = 30
	ST_PresetPatternValWdUpDiag   ST_PresetPatternVal = 31
	ST_PresetPatternValDashDnDiag ST_PresetPatternVal = 32
	ST_PresetPatternValDashUpDiag ST_PresetPatternVal = 33
	ST_PresetPatternValDiagCross  ST_PresetPatternVal = 34
	ST_PresetPatternValSmCheck    ST_PresetPatternVal = 35
	ST_PresetPatternValLgCheck    ST_PresetPatternVal = 36
	ST_PresetPatternValSmGrid     ST_PresetPatternVal = 37
	ST_PresetPatternValLgGrid     ST_PresetPatternVal = 38
	ST_PresetPatternValDotGrid    ST_PresetPatternVal = 39
	ST_PresetPatternValSmConfetti ST_PresetPatternVal = 40
	ST_PresetPatternValLgConfetti ST_PresetPatternVal = 41
	ST_PresetPatternValHorzBrick  ST_PresetPatternVal = 42
	ST_PresetPatternValDiagBrick  ST_PresetPatternVal = 43
	ST_PresetPatternValSolidDmnd  ST_PresetPatternVal = 44
	ST_PresetPatternValOpenDmnd   ST_PresetPatternVal = 45
	ST_PresetPatternValDotDmnd    ST_PresetPatternVal = 46
	ST_PresetPatternValPlaid      ST_PresetPatternVal = 47
	ST_PresetPatternValSphere     ST_PresetPatternVal = 48
	ST_PresetPatternValWeave      ST_PresetPatternVal = 49
	ST_PresetPatternValDivot      ST_PresetPatternVal = 50
	ST_PresetPatternValShingle    ST_PresetPatternVal = 51
	ST_PresetPatternValWave       ST_PresetPatternVal = 52
	ST_PresetPatternValTrellis    ST_PresetPatternVal = 53
	ST_PresetPatternValZigZag     ST_PresetPatternVal = 54
)

// Validate validates the CT_LineProperties and its children
func (_ecaf *CT_LineProperties) Validate() error { return _ecaf.ValidateWithPath("CT_LineProperties") }
func (_aaabe *EG_ThemeableFillStyle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gbdee:
	for {
		_gabag, _dcaff := d.Token()
		if _dcaff != nil {
			return _dcaff
		}
		switch _ggdbe := _gabag.(type) {
		case _g.StartElement:
			switch _ggdbe.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fill"}:
				_aaabe.Fill = NewCT_FillProperties()
				if _gfbbf := d.DecodeElement(_aaabe.Fill, &_ggdbe); _gfbbf != nil {
					return _gfbbf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillRef"}:
				_aaabe.FillRef = NewCT_StyleMatrixReference()
				if _daddag := d.DecodeElement(_aaabe.FillRef, &_ggdbe); _daddag != nil {
					return _daddag
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on EG_ThemeableFillStyle\u0020\u0025v", _ggdbe.Name)
				if _bcada := d.Skip(); _bcada != nil {
					return _bcada
				}
			}
		case _g.EndElement:
			break _gbdee
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_GvmlPicture and its children, prefixing error messages with path
func (_gddfe *CT_GvmlPicture) ValidateWithPath(path string) error {
	if _afdaa := _gddfe.NvPicPr.ValidateWithPath(path + "\u002fNvPicPr"); _afdaa != nil {
		return _afdaa
	}
	if _ecaeb := _gddfe.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _ecaeb != nil {
		return _ecaeb
	}
	if _ggcca := _gddfe.SpPr.ValidateWithPath(path + "\u002fSpPr"); _ggcca != nil {
		return _ggcca
	}
	if _gddfe.Style != nil {
		if _gegf := _gddfe.Style.ValidateWithPath(path + "\u002fStyle"); _gegf != nil {
			return _gegf
		}
	}
	if _gddfe.ExtLst != nil {
		if _ceaab := _gddfe.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ceaab != nil {
			return _ceaab
		}
	}
	return nil
}

type CT_TextNoAutofit struct{}

// ValidateWithPath validates the CT_OuterShadowEffect and its children, prefixing error messages with path
func (_gacc *CT_OuterShadowEffect) ValidateWithPath(path string) error {
	if _gacc.BlurRadAttr != nil {
		if *_gacc.BlurRadAttr < 0 {
			return _dcf.Errorf("\u0025s\u002fm\u002eBlurRadAttr\u0020must\u0020be\u0020\u003e\u003d\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_gacc.BlurRadAttr)
		}
		if *_gacc.BlurRadAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s/m\u002eBlurRadAttr\u0020must\u0020be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_gacc.BlurRadAttr)
		}
	}
	if _gacc.DistAttr != nil {
		if *_gacc.DistAttr < 0 {
			return _dcf.Errorf("\u0025s/m\u002eDistAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_gacc.DistAttr)
		}
		if *_gacc.DistAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s\u002fm\u002eDistAttr\u0020must\u0020be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_gacc.DistAttr)
		}
	}
	if _gacc.DirAttr != nil {
		if *_gacc.DirAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eDirAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_gacc.DirAttr)
		}
		if *_gacc.DirAttr >= 21600000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eDirAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, *_gacc.DirAttr)
		}
	}
	if _gacc.SxAttr != nil {
		if _dedgb := _gacc.SxAttr.ValidateWithPath(path + "\u002fSxAttr"); _dedgb != nil {
			return _dedgb
		}
	}
	if _gacc.SyAttr != nil {
		if _gfdad := _gacc.SyAttr.ValidateWithPath(path + "\u002fSyAttr"); _gfdad != nil {
			return _gfdad
		}
	}
	if _gacc.KxAttr != nil {
		if *_gacc.KxAttr <= -5400000 {
			return _dcf.Errorf("%s\u002fm\u002eKxAttr\u0020must\u0020be \u003e\u0020\u002d5400000 (have\u0020%v\u0029", path, *_gacc.KxAttr)
		}
		if *_gacc.KxAttr >= 5400000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eKxAttr\u0020must\u0020be\u0020<\u00205400000\u0020\u0028have\u0020\u0025v\u0029", path, *_gacc.KxAttr)
		}
	}
	if _gacc.KyAttr != nil {
		if *_gacc.KyAttr <= -5400000 {
			return _dcf.Errorf("%s\u002fm\u002eKyAttr\u0020must\u0020be \u003e\u0020\u002d5400000 (have\u0020%v\u0029", path, *_gacc.KyAttr)
		}
		if *_gacc.KyAttr >= 5400000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eKyAttr\u0020must\u0020be\u0020<\u00205400000\u0020\u0028have\u0020\u0025v\u0029", path, *_gacc.KyAttr)
		}
	}
	if _eedgb := _gacc.AlgnAttr.ValidateWithPath(path + "\u002fAlgnAttr"); _eedgb != nil {
		return _eedgb
	}
	if _gacc.ScrgbClr != nil {
		if _gdga := _gacc.ScrgbClr.ValidateWithPath(path + "\u002fScrgbClr"); _gdga != nil {
			return _gdga
		}
	}
	if _gacc.SrgbClr != nil {
		if _babce := _gacc.SrgbClr.ValidateWithPath(path + "\u002fSrgbClr"); _babce != nil {
			return _babce
		}
	}
	if _gacc.HslClr != nil {
		if _egegab := _gacc.HslClr.ValidateWithPath(path + "\u002fHslClr"); _egegab != nil {
			return _egegab
		}
	}
	if _gacc.SysClr != nil {
		if _abcag := _gacc.SysClr.ValidateWithPath(path + "\u002fSysClr"); _abcag != nil {
			return _abcag
		}
	}
	if _gacc.SchemeClr != nil {
		if _bcff := _gacc.SchemeClr.ValidateWithPath(path + "\u002fSchemeClr"); _bcff != nil {
			return _bcff
		}
	}
	if _gacc.PrstClr != nil {
		if _dadg := _gacc.PrstClr.ValidateWithPath(path + "\u002fPrstClr"); _dadg != nil {
			return _dadg
		}
	}
	return nil
}

type CT_Cell3D struct {
	PrstMaterialAttr ST_PresetMaterialType
	Bevel            *CT_Bevel
	LightRig         *CT_LightRig
	ExtLst           *CT_OfficeArtExtensionList
}

// Validate validates the CT_AudioCDTime and its children
func (_ecgea *CT_AudioCDTime) Validate() error { return _ecgea.ValidateWithPath("CT_AudioCDTime") }

// ValidateWithPath validates the CT_TextBodyProperties and its children, prefixing error messages with path
func (_edegg *CT_TextBodyProperties) ValidateWithPath(path string) error {
	if _dcdab := _edegg.VertOverflowAttr.ValidateWithPath(path + "\u002fVertOverflowAttr"); _dcdab != nil {
		return _dcdab
	}
	if _abdabg := _edegg.HorzOverflowAttr.ValidateWithPath(path + "\u002fHorzOverflowAttr"); _abdabg != nil {
		return _abdabg
	}
	if _gdfag := _edegg.VertAttr.ValidateWithPath(path + "\u002fVertAttr"); _gdfag != nil {
		return _gdfag
	}
	if _aeggb := _edegg.WrapAttr.ValidateWithPath(path + "\u002fWrapAttr"); _aeggb != nil {
		return _aeggb
	}
	if _edegg.LInsAttr != nil {
		if _egfec := _edegg.LInsAttr.ValidateWithPath(path + "\u002fLInsAttr"); _egfec != nil {
			return _egfec
		}
	}
	if _edegg.TInsAttr != nil {
		if _eafg := _edegg.TInsAttr.ValidateWithPath(path + "\u002fTInsAttr"); _eafg != nil {
			return _eafg
		}
	}
	if _edegg.RInsAttr != nil {
		if _eefa := _edegg.RInsAttr.ValidateWithPath(path + "\u002fRInsAttr"); _eefa != nil {
			return _eefa
		}
	}
	if _edegg.BInsAttr != nil {
		if _gfee := _edegg.BInsAttr.ValidateWithPath(path + "\u002fBInsAttr"); _gfee != nil {
			return _gfee
		}
	}
	if _edegg.NumColAttr != nil {
		if *_edegg.NumColAttr < 1 {
			return _dcf.Errorf("\u0025s\u002fm\u002eNumColAttr\u0020must\u0020be\u0020>\u003d\u00201\u0020\u0028have\u0020\u0025v\u0029", path, *_edegg.NumColAttr)
		}
		if *_edegg.NumColAttr > 16 {
			return _dcf.Errorf("\u0025s\u002fm\u002eNumColAttr\u0020must be\u0020\u003c\u003d\u002016\u0020\u0028have\u0020\u0025v\u0029", path, *_edegg.NumColAttr)
		}
	}
	if _edegg.SpcColAttr != nil {
		if *_edegg.SpcColAttr < 0 {
			return _dcf.Errorf("\u0025s\u002fm\u002eSpcColAttr\u0020must\u0020be\u0020>\u003d\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_edegg.SpcColAttr)
		}
	}
	if _eddge := _edegg.AnchorAttr.ValidateWithPath(path + "/AnchorAttr"); _eddge != nil {
		return _eddge
	}
	if _edegg.PrstTxWarp != nil {
		if _bdfbd := _edegg.PrstTxWarp.ValidateWithPath(path + "/PrstTxWarp"); _bdfbd != nil {
			return _bdfbd
		}
	}
	if _edegg.NoAutofit != nil {
		if _aecfc := _edegg.NoAutofit.ValidateWithPath(path + "\u002fNoAutofit"); _aecfc != nil {
			return _aecfc
		}
	}
	if _edegg.NormAutofit != nil {
		if _dbdadd := _edegg.NormAutofit.ValidateWithPath(path + "\u002fNormAutofit"); _dbdadd != nil {
			return _dbdadd
		}
	}
	if _edegg.SpAutoFit != nil {
		if _bcbaa := _edegg.SpAutoFit.ValidateWithPath(path + "\u002fSpAutoFit"); _bcbaa != nil {
			return _bcbaa
		}
	}
	if _edegg.Scene3d != nil {
		if _gadga := _edegg.Scene3d.ValidateWithPath(path + "\u002fScene3d"); _gadga != nil {
			return _gadga
		}
	}
	if _edegg.Sp3d != nil {
		if _eagge := _edegg.Sp3d.ValidateWithPath(path + "\u002fSp3d"); _eagge != nil {
			return _eagge
		}
	}
	if _edegg.FlatTx != nil {
		if _bdcda := _edegg.FlatTx.ValidateWithPath(path + "\u002fFlatTx"); _bdcda != nil {
			return _bdcda
		}
	}
	if _edegg.ExtLst != nil {
		if _gdbgdf := _edegg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gdbgdf != nil {
			return _gdbgdf
		}
	}
	return nil
}
func (_gfdd *CT_TextUnderlineFillGroupWrapper) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _gfdd.NoFill != nil {
		_gebfe := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_gfdd.NoFill, _gebfe)
	}
	if _gfdd.SolidFill != nil {
		_efagf := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_gfdd.SolidFill, _efagf)
	}
	if _gfdd.GradFill != nil {
		_bcaga := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_gfdd.GradFill, _bcaga)
	}
	if _gfdd.BlipFill != nil {
		_egcde := _g.StartElement{Name: _g.Name{Local: "a:blipFill"}}
		e.EncodeElement(_gfdd.BlipFill, _egcde)
	}
	if _gfdd.PattFill != nil {
		_defde := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_gfdd.PattFill, _defde)
	}
	if _gfdd.GrpFill != nil {
		_ddda := _g.StartElement{Name: _g.Name{Local: "a:grpFill"}}
		e.EncodeElement(_gfdd.GrpFill, _ddda)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TileInfoProperties and its children
func (_fdabc *CT_TileInfoProperties) Validate() error {
	return _fdabc.ValidateWithPath("CT_TileInfoProperties")
}

type CT_TextParagraphProperties struct {
	MarLAttr         *int32
	MarRAttr         *int32
	LvlAttr          *int32
	IndentAttr       *int32
	AlgnAttr         ST_TextAlignType
	DefTabSzAttr     *ST_Coordinate32
	RtlAttr          *bool
	EaLnBrkAttr      *bool
	FontAlgnAttr     ST_TextFontAlignType
	LatinLnBrkAttr   *bool
	HangingPunctAttr *bool
	LnSpc            *CT_TextSpacing
	SpcBef           *CT_TextSpacing
	SpcAft           *CT_TextSpacing
	BuClrTx          *CT_TextBulletColorFollowText
	BuClr            *CT_Color
	BuSzTx           *CT_TextBulletSizeFollowText
	BuSzPct          *CT_TextBulletSizePercent
	BuSzPts          *CT_TextBulletSizePoint
	BuFontTx         *CT_TextBulletTypefaceFollowText
	BuFont           *CT_TextFont
	BuNone           *CT_TextNoBullet
	BuAutoNum        *CT_TextAutonumberBullet
	BuChar           *CT_TextCharBullet
	BuBlip           *CT_TextBlipBullet
	TabLst           *CT_TextTabStopList
	DefRPr           *CT_TextCharacterProperties
	ExtLst           *CT_OfficeArtExtensionList
}
type CT_Hyperlink struct {
	IdAttr             *string
	InvalidUrlAttr     *string
	ActionAttr         *string
	TgtFrameAttr       *string
	TooltipAttr        *string
	HistoryAttr        *bool
	HighlightClickAttr *bool
	EndSndAttr         *bool
	Snd                *CT_EmbeddedWAVAudioFile
	ExtLst             *CT_OfficeArtExtensionList
}

// Validate validates the CT_FillProperties and its children
func (_gdba *CT_FillProperties) Validate() error { return _gdba.ValidateWithPath("CT_FillProperties") }

type CT_BlipFillProperties struct {
	DpiAttr          *uint32
	RotWithShapeAttr *bool
	Blip             *CT_Blip
	SrcRect          *CT_RelativeRect
	Tile             *CT_TileInfoProperties
	Stretch          *CT_StretchInfoProperties
}
type CT_AlphaInverseEffect struct {
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
}

func (_gcfgd *CT_NonVisualConnectorProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _gcfgd.CxnSpLocks != nil {
		_ddaaab := _g.StartElement{Name: _g.Name{Local: "a:cxnSpLocks"}}
		e.EncodeElement(_gcfgd.CxnSpLocks, _ddaaab)
	}
	if _gcfgd.StCxn != nil {
		_aeaaf := _g.StartElement{Name: _g.Name{Local: "a:stCxn"}}
		e.EncodeElement(_gcfgd.StCxn, _aeaaf)
	}
	if _gcfgd.EndCxn != nil {
		_bbed := _g.StartElement{Name: _g.Name{Local: "a:endCxn"}}
		e.EncodeElement(_gcfgd.EndCxn, _bbed)
	}
	if _gcfgd.ExtLst != nil {
		_cccae := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_gcfgd.ExtLst, _cccae)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_BlipChoice struct {
	AlphaBiLevel []*CT_AlphaBiLevelEffect
	AlphaCeiling []*CT_AlphaCeilingEffect
	AlphaFloor   []*CT_AlphaFloorEffect
	AlphaInv     []*CT_AlphaInverseEffect
	AlphaMod     []*CT_AlphaModulateEffect
	AlphaModFix  []*CT_AlphaModulateFixedEffect
	AlphaRepl    []*CT_AlphaReplaceEffect
	BiLevel      []*CT_BiLevelEffect
	Blur         []*CT_BlurEffect
	ClrChange    []*CT_ColorChangeEffect
	ClrRepl      []*CT_ColorReplaceEffect
	Duotone      []*CT_DuotoneEffect
	FillOverlay  []*CT_FillOverlayEffect
	Grayscl      []*CT_GrayscaleEffect
	Hsl          []*CT_HSLEffect
	Lum          []*CT_LuminanceEffect
	Tint         []*CT_TintEffect
}

// Validate validates the CT_TextBlipBullet and its children
func (_dbbg *CT_TextBlipBullet) Validate() error { return _dbbg.ValidateWithPath("CT_TextBlipBullet") }

// ValidateWithPath validates the CT_FontCollection and its children, prefixing error messages with path
func (_bcfgc *CT_FontCollection) ValidateWithPath(path string) error {
	if _bbfea := _bcfgc.Latin.ValidateWithPath(path + "\u002fLatin"); _bbfea != nil {
		return _bbfea
	}
	if _agfd := _bcfgc.Ea.ValidateWithPath(path + "\u002fEa"); _agfd != nil {
		return _agfd
	}
	if _beed := _bcfgc.Cs.ValidateWithPath(path + "\u002fCs"); _beed != nil {
		return _beed
	}
	for _cabb, _dfcb := range _bcfgc.Font {
		if _bdfec := _dfcb.ValidateWithPath(_dcf.Sprintf("%s\u002fFont\u005b\u0025d\u005d", path, _cabb)); _bdfec != nil {
			return _bdfec
		}
	}
	if _bcfgc.ExtLst != nil {
		if _cggca := _bcfgc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cggca != nil {
			return _cggca
		}
	}
	return nil
}

// ST_FixedPercentage is a union type
type ST_FixedPercentage struct {
	ST_FixedPercentageDecimal *int32
	ST_FixedPercentage        *ST_Percentage
}

func (_cgfgf *ST_TextFontAlignType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_cgfgf = 0
	case "auto":
		*_cgfgf = 1
	case "t":
		*_cgfgf = 2
	case "ctr":
		*_cgfgf = 3
	case "base":
		*_cgfgf = 4
	case "b":
		*_cgfgf = 5
	}
	return nil
}
func (_bcfcg ST_BlendMode) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_bceff := _g.Attr{}
	_bceff.Name = name
	switch _bcfcg {
	case ST_BlendModeUnset:
		_bceff.Value = ""
	case ST_BlendModeOver:
		_bceff.Value = "over"
	case ST_BlendModeMult:
		_bceff.Value = "mult"
	case ST_BlendModeScreen:
		_bceff.Value = "screen"
	case ST_BlendModeDarken:
		_bceff.Value = "darken"
	case ST_BlendModeLighten:
		_bceff.Value = "lighten"
	}
	return _bceff, nil
}
func (_cgbfg *CT_InverseTransform) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_faca, _bcbd := d.Token()
		if _bcbd != nil {
			return _dcf.Errorf("parsing\u0020CT_InverseTransform:\u0020\u0025s", _bcbd)
		}
		if _bcgeb, _geeda := _faca.(_g.EndElement); _geeda && _bcgeb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ffcde *Tbl) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ffcde.CT_Table = *NewCT_Table()
_egbdfc:
	for {
		_dacdd, _fefgf := d.Token()
		if _fefgf != nil {
			return _fefgf
		}
		switch _ffdgba := _dacdd.(type) {
		case _g.StartElement:
			switch _ffdgba.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tblPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tblPr"}:
				_ffcde.TblPr = NewCT_TableProperties()
				if _ecfgcf := d.DecodeElement(_ffcde.TblPr, &_ffdgba); _ecfgcf != nil {
					return _ecfgcf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tblGrid"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tblGrid"}:
				if _cgdefb := d.DecodeElement(_ffcde.TblGrid, &_ffdgba); _cgdefb != nil {
					return _cgdefb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tr"}:
				_fbcbcb := NewCT_TableRow()
				if _abgfe := d.DecodeElement(_fbcbcb, &_ffdgba); _abgfe != nil {
					return _abgfe
				}
				_ffcde.Tr = append(_ffcde.Tr, _fbcbcb)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Tbl\u0020\u0025v", _ffdgba.Name)
				if _adbec := d.Skip(); _adbec != nil {
					return _adbec
				}
			}
		case _g.EndElement:
			break _egbdfc
		case _g.CharData:
		}
	}
	return nil
}
func (_cgef ST_PathShadeType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cgef.String(), start)
}

type CT_TextNoBullet struct{}

func (_bfcbe ST_PenAlignment) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_abeced := _g.Attr{}
	_abeced.Name = name
	switch _bfcbe {
	case ST_PenAlignmentUnset:
		_abeced.Value = ""
	case ST_PenAlignmentCtr:
		_abeced.Value = "ctr"
	case ST_PenAlignmentIn:
		_abeced.Value = "in"
	}
	return _abeced, nil
}
func (_afc *CT_AlphaFloorEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_Shape3D() *CT_Shape3D { _degg := &CT_Shape3D{}; return _degg }

// Validate validates the CT_PositiveFixedPercentage and its children
func (_caaeb *CT_PositiveFixedPercentage) Validate() error {
	return _caaeb.ValidateWithPath("CT_PositiveFixedPercentage")
}
func (_afecc *CT_Path2DQuadBezierTo) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_adcefa:
	for {
		_dadgg, _aeae := d.Token()
		if _aeae != nil {
			return _aeae
		}
		switch _gada := _dadgg.(type) {
		case _g.StartElement:
			switch _gada.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pt"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pt"}:
				_ccbca := NewCT_AdjPoint2D()
				if _eagb := d.DecodeElement(_ccbca, &_gada); _eagb != nil {
					return _eagb
				}
				_afecc.Pt = append(_afecc.Pt, _ccbca)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_Path2DQuadBezierTo\u0020\u0025v", _gada.Name)
				if _ggdfd := d.Skip(); _ggdfd != nil {
					return _ggdfd
				}
			}
		case _g.EndElement:
			break _adcefa
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_ConnectionSite() *CT_ConnectionSite {
	_agec := &CT_ConnectionSite{}
	_agec.Pos = NewCT_AdjPoint2D()
	return _agec
}

type Blip struct{ CT_Blip }

func (_acdba *CT_GeomGuideList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _acdba.Gd != nil {
		_gcca := _g.StartElement{Name: _g.Name{Local: "a:gd"}}
		for _, _aceg := range _acdba.Gd {
			e.EncodeElement(_aceg, _gcca)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_HSLEffect and its children, prefixing error messages with path
func (_fccc *CT_HSLEffect) ValidateWithPath(path string) error {
	if _fccc.HueAttr != nil {
		if *_fccc.HueAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eHueAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_fccc.HueAttr)
		}
		if *_fccc.HueAttr >= 21600000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eHueAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, *_fccc.HueAttr)
		}
	}
	if _fccc.SatAttr != nil {
		if _daaca := _fccc.SatAttr.ValidateWithPath(path + "\u002fSatAttr"); _daaca != nil {
			return _daaca
		}
	}
	if _fccc.LumAttr != nil {
		if _befcd := _fccc.LumAttr.ValidateWithPath(path + "\u002fLumAttr"); _befcd != nil {
			return _befcd
		}
	}
	return nil
}
func (_dedbdb ST_TextVertOverflowType) Validate() error { return _dedbdb.ValidateWithPath("") }
func (_baeag *ST_FixedPercentage) Validate() error      { return _baeag.ValidateWithPath("") }
func (_gbbdf *CT_GroupFillProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_becbd ST_PathShadeType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ebabbc := _g.Attr{}
	_ebabbc.Name = name
	switch _becbd {
	case ST_PathShadeTypeUnset:
		_ebabbc.Value = ""
	case ST_PathShadeTypeShape:
		_ebabbc.Value = "shape"
	case ST_PathShadeTypeCircle:
		_ebabbc.Value = "circle"
	case ST_PathShadeTypeRect:
		_ebabbc.Value = "rect"
	}
	return _ebabbc, nil
}
func (_cfdg *CT_ObjectStyleDefaults) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _cfdg.SpDef != nil {
		_gbbeg := _g.StartElement{Name: _g.Name{Local: "a:spDef"}}
		e.EncodeElement(_cfdg.SpDef, _gbbeg)
	}
	if _cfdg.LnDef != nil {
		_agbec := _g.StartElement{Name: _g.Name{Local: "a:lnDef"}}
		e.EncodeElement(_cfdg.LnDef, _agbec)
	}
	if _cfdg.TxDef != nil {
		_feccb := _g.StartElement{Name: _g.Name{Local: "a:txDef"}}
		e.EncodeElement(_cfdg.TxDef, _feccb)
	}
	if _cfdg.ExtLst != nil {
		_abea := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_cfdg.ExtLst, _abea)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_Backdrop struct {
	Anchor *CT_Point3D
	Norm   *CT_Vector3D
	Up     *CT_Vector3D
	ExtLst *CT_OfficeArtExtensionList
}

func NewEG_ColorChoice() *EG_ColorChoice { _dbbgg := &EG_ColorChoice{}; return _dbbgg }
func NewCT_GraphicalObject() *CT_GraphicalObject {
	_ggaab := &CT_GraphicalObject{}
	_ggaab.GraphicData = NewCT_GraphicalObjectData()
	return _ggaab
}

// ValidateWithPath validates the CT_FillProperties and its children, prefixing error messages with path
func (_dbfg *CT_FillProperties) ValidateWithPath(path string) error {
	if _dbfg.NoFill != nil {
		if _ddbed := _dbfg.NoFill.ValidateWithPath(path + "\u002fNoFill"); _ddbed != nil {
			return _ddbed
		}
	}
	if _dbfg.SolidFill != nil {
		if _addg := _dbfg.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _addg != nil {
			return _addg
		}
	}
	if _dbfg.GradFill != nil {
		if _afgfd := _dbfg.GradFill.ValidateWithPath(path + "\u002fGradFill"); _afgfd != nil {
			return _afgfd
		}
	}
	if _dbfg.BlipFill != nil {
		if _ageeb := _dbfg.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _ageeb != nil {
			return _ageeb
		}
	}
	if _dbfg.PattFill != nil {
		if _afab := _dbfg.PattFill.ValidateWithPath(path + "\u002fPattFill"); _afab != nil {
			return _afab
		}
	}
	if _dbfg.GrpFill != nil {
		if _fbgb := _dbfg.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _fbgb != nil {
			return _fbgb
		}
	}
	return nil
}

type EG_Effect struct {
	Cont         *CT_EffectContainer
	Effect       *CT_EffectReference
	AlphaBiLevel *CT_AlphaBiLevelEffect
	AlphaCeiling *CT_AlphaCeilingEffect
	AlphaFloor   *CT_AlphaFloorEffect
	AlphaInv     *CT_AlphaInverseEffect
	AlphaMod     *CT_AlphaModulateEffect
	AlphaModFix  *CT_AlphaModulateFixedEffect
	AlphaOutset  *CT_AlphaOutsetEffect
	AlphaRepl    *CT_AlphaReplaceEffect
	BiLevel      *CT_BiLevelEffect
	Blend        *CT_BlendEffect
	Blur         *CT_BlurEffect
	ClrChange    *CT_ColorChangeEffect
	ClrRepl      *CT_ColorReplaceEffect
	Duotone      *CT_DuotoneEffect
	Fill         *CT_FillEffect
	FillOverlay  *CT_FillOverlayEffect
	Glow         *CT_GlowEffect
	Grayscl      *CT_GrayscaleEffect
	Hsl          *CT_HSLEffect
	InnerShdw    *CT_InnerShadowEffect
	Lum          *CT_LuminanceEffect
	OuterShdw    *CT_OuterShadowEffect
	PrstShdw     *CT_PresetShadowEffect
	Reflection   *CT_ReflectionEffect
	RelOff       *CT_RelativeOffsetEffect
	SoftEdge     *CT_SoftEdgesEffect
	Tint         *CT_TintEffect
	Xfrm         *CT_TransformEffect
}
type CT_LineEndProperties struct {
	TypeAttr ST_LineEndType
	WAttr    ST_LineEndWidth
	LenAttr  ST_LineEndLength
}

func (_fgabc ST_BlendMode) ValidateWithPath(path string) error {
	switch _fgabc {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fgabc))
	}
	return nil
}
func NewCT_LightRig() *CT_LightRig {
	_cafcb := &CT_LightRig{}
	_cafcb.RigAttr = ST_LightRigType(1)
	_cafcb.DirAttr = ST_LightRigDirection(1)
	return _cafcb
}
func (_ceebd *ST_TextAlignType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_aaegd, _babedb := d.Token()
	if _babedb != nil {
		return _babedb
	}
	if _gedagc, _ebfee := _aaegd.(_g.EndElement); _ebfee && _gedagc.Name == start.Name {
		*_ceebd = 1
		return nil
	}
	if _effcb, _ceec := _aaegd.(_g.CharData); !_ceec {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aaegd)
	} else {
		switch string(_effcb) {
		case "":
			*_ceebd = 0
		case "l":
			*_ceebd = 1
		case "ctr":
			*_ceebd = 2
		case "r":
			*_ceebd = 3
		case "just":
			*_ceebd = 4
		case "justLow":
			*_ceebd = 5
		case "dist":
			*_ceebd = 6
		case "thaiDist":
			*_ceebd = 7
		}
	}
	_aaegd, _babedb = d.Token()
	if _babedb != nil {
		return _babedb
	}
	if _adgbc, _ebadf := _aaegd.(_g.EndElement); _ebadf && _adgbc.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aaegd)
}

type CT_TextBulletSizePercent struct{ ValAttr string }

func (_cfdcc *ThemeOverride) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "a:themeOverride"
	return _cfdcc.CT_BaseStylesOverride.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_BiLevelEffect and its children, prefixing error messages with path
func (_bcf *CT_BiLevelEffect) ValidateWithPath(path string) error {
	if _fbdb := _bcf.ThreshAttr.ValidateWithPath(path + "/ThreshAttr"); _fbdb != nil {
		return _fbdb
	}
	return nil
}
func (_eagce ST_RectAlignment) String() string {
	switch _eagce {
	case 0:
		return ""
	case 1:
		return "tl"
	case 2:
		return "t"
	case 3:
		return "tr"
	case 4:
		return "l"
	case 5:
		return "ctr"
	case 6:
		return "r"
	case 7:
		return "bl"
	case 8:
		return "b"
	case 9:
		return "br"
	}
	return ""
}
func (_dbacb ST_TextFontAlignType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_dbacb.String(), start)
}
func (_gccca *ST_PathFillMode) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ebbgd, _addegb := d.Token()
	if _addegb != nil {
		return _addegb
	}
	if _cgbbd, _bfcgb := _ebbgd.(_g.EndElement); _bfcgb && _cgbbd.Name == start.Name {
		*_gccca = 1
		return nil
	}
	if _acbab, _dcdffc := _ebbgd.(_g.CharData); !_dcdffc {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ebbgd)
	} else {
		switch string(_acbab) {
		case "":
			*_gccca = 0
		case "none":
			*_gccca = 1
		case "norm":
			*_gccca = 2
		case "lighten":
			*_gccca = 3
		case "lightenLess":
			*_gccca = 4
		case "darken":
			*_gccca = 5
		case "darkenLess":
			*_gccca = 6
		}
	}
	_ebbgd, _addegb = d.Token()
	if _addegb != nil {
		return _addegb
	}
	if _dbadeg, _acadaa := _ebbgd.(_g.EndElement); _acadaa && _dbadeg.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ebbgd)
}

type CT_TableStyleList struct {
	DefAttr  string
	TblStyle []*CT_TableStyle
}
type CT_FontReference struct {
	IdxAttr   ST_FontCollectionIndex
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
}

func (_bacf *CT_Bevel) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _dffb := range start.Attr {
		if _dffb.Name.Local == "w" {
			_gcac, _egbg := _e.ParseInt(_dffb.Value, 10, 64)
			if _egbg != nil {
				return _egbg
			}
			_bacf.WAttr = &_gcac
			continue
		}
		if _dffb.Name.Local == "h" {
			_fcbg, _abd := _e.ParseInt(_dffb.Value, 10, 64)
			if _abd != nil {
				return _abd
			}
			_bacf.HAttr = &_fcbg
			continue
		}
		if _dffb.Name.Local == "prst" {
			_bacf.PrstAttr.UnmarshalXMLAttr(_dffb)
			continue
		}
	}
	for {
		_abfd, _efa := d.Token()
		if _efa != nil {
			return _dcf.Errorf("parsing\u0020CT_Bevel: \u0025s", _efa)
		}
		if _ddae, _bcda := _abfd.(_g.EndElement); _bcda && _ddae.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_GlowEffect struct {
	RadAttr   *int64
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
}

func (_ebeff ST_TextAnchoringType) ValidateWithPath(path string) error {
	switch _ebeff {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ebeff))
	}
	return nil
}
func NewCT_DashStopList() *CT_DashStopList { _aafcg := &CT_DashStopList{}; return _aafcg }
func NewCT_GvmlShape() *CT_GvmlShape {
	_fgea := &CT_GvmlShape{}
	_fgea.NvSpPr = NewCT_GvmlShapeNonVisual()
	_fgea.SpPr = NewCT_ShapeProperties()
	return _fgea
}
func (_ececd ST_ChartBuildStep) ValidateWithPath(path string) error {
	switch _ececd {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ececd))
	}
	return nil
}

// Validate validates the CT_AnimationDgmElement and its children
func (_edbd *CT_AnimationDgmElement) Validate() error {
	return _edbd.ValidateWithPath("CT_AnimationDgmElement")
}

// ValidateWithPath validates the CT_ReflectionEffect and its children, prefixing error messages with path
func (_bddga *CT_ReflectionEffect) ValidateWithPath(path string) error {
	if _bddga.BlurRadAttr != nil {
		if *_bddga.BlurRadAttr < 0 {
			return _dcf.Errorf("\u0025s\u002fm\u002eBlurRadAttr\u0020must\u0020be\u0020\u003e\u003d\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_bddga.BlurRadAttr)
		}
		if *_bddga.BlurRadAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s/m\u002eBlurRadAttr\u0020must\u0020be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_bddga.BlurRadAttr)
		}
	}
	if _bddga.StAAttr != nil {
		if _dacfa := _bddga.StAAttr.ValidateWithPath(path + "\u002fStAAttr"); _dacfa != nil {
			return _dacfa
		}
	}
	if _bddga.StPosAttr != nil {
		if _cabfa := _bddga.StPosAttr.ValidateWithPath(path + "\u002fStPosAttr"); _cabfa != nil {
			return _cabfa
		}
	}
	if _bddga.EndAAttr != nil {
		if _cafcf := _bddga.EndAAttr.ValidateWithPath(path + "\u002fEndAAttr"); _cafcf != nil {
			return _cafcf
		}
	}
	if _bddga.EndPosAttr != nil {
		if _gbgae := _bddga.EndPosAttr.ValidateWithPath(path + "/EndPosAttr"); _gbgae != nil {
			return _gbgae
		}
	}
	if _bddga.DistAttr != nil {
		if *_bddga.DistAttr < 0 {
			return _dcf.Errorf("\u0025s/m\u002eDistAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_bddga.DistAttr)
		}
		if *_bddga.DistAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s\u002fm\u002eDistAttr\u0020must\u0020be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_bddga.DistAttr)
		}
	}
	if _bddga.DirAttr != nil {
		if *_bddga.DirAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eDirAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_bddga.DirAttr)
		}
		if *_bddga.DirAttr >= 21600000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eDirAttr\u0020must\u0020be\u0020\u003c\u002021600000\u0020\u0028have\u0020\u0025v\u0029", path, *_bddga.DirAttr)
		}
	}
	if _bddga.FadeDirAttr != nil {
		if *_bddga.FadeDirAttr < 0 {
			return _dcf.Errorf("\u0025s\u002fm\u002eFadeDirAttr\u0020must\u0020be\u0020\u003e\u003d\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_bddga.FadeDirAttr)
		}
		if *_bddga.FadeDirAttr >= 21600000 {
			return _dcf.Errorf("\u0025s\u002fm.FadeDirAttr must\u0020be\u0020\u003c\u002021600000 \u0028have\u0020\u0025v\u0029", path, *_bddga.FadeDirAttr)
		}
	}
	if _bddga.SxAttr != nil {
		if _dagac := _bddga.SxAttr.ValidateWithPath(path + "\u002fSxAttr"); _dagac != nil {
			return _dagac
		}
	}
	if _bddga.SyAttr != nil {
		if _ddedf := _bddga.SyAttr.ValidateWithPath(path + "\u002fSyAttr"); _ddedf != nil {
			return _ddedf
		}
	}
	if _bddga.KxAttr != nil {
		if *_bddga.KxAttr <= -5400000 {
			return _dcf.Errorf("%s\u002fm\u002eKxAttr\u0020must\u0020be \u003e\u0020\u002d5400000 (have\u0020%v\u0029", path, *_bddga.KxAttr)
		}
		if *_bddga.KxAttr >= 5400000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eKxAttr\u0020must\u0020be\u0020<\u00205400000\u0020\u0028have\u0020\u0025v\u0029", path, *_bddga.KxAttr)
		}
	}
	if _bddga.KyAttr != nil {
		if *_bddga.KyAttr <= -5400000 {
			return _dcf.Errorf("%s\u002fm\u002eKyAttr\u0020must\u0020be \u003e\u0020\u002d5400000 (have\u0020%v\u0029", path, *_bddga.KyAttr)
		}
		if *_bddga.KyAttr >= 5400000 {
			return _dcf.Errorf("\u0025s\u002fm\u002eKyAttr\u0020must\u0020be\u0020<\u00205400000\u0020\u0028have\u0020\u0025v\u0029", path, *_bddga.KyAttr)
		}
	}
	if _aafgc := _bddga.AlgnAttr.ValidateWithPath(path + "\u002fAlgnAttr"); _aafgc != nil {
		return _aafgc
	}
	return nil
}
func (_gebbc *ST_BlendMode) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_aeacd, _fadebg := d.Token()
	if _fadebg != nil {
		return _fadebg
	}
	if _eccfd, _bgcef := _aeacd.(_g.EndElement); _bgcef && _eccfd.Name == start.Name {
		*_gebbc = 1
		return nil
	}
	if _fcdcae, _acbgag := _aeacd.(_g.CharData); !_acbgag {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aeacd)
	} else {
		switch string(_fcdcae) {
		case "":
			*_gebbc = 0
		case "over":
			*_gebbc = 1
		case "mult":
			*_gebbc = 2
		case "screen":
			*_gebbc = 3
		case "darken":
			*_gebbc = 4
		case "lighten":
			*_gebbc = 5
		}
	}
	_aeacd, _fadebg = d.Token()
	if _fadebg != nil {
		return _fadebg
	}
	if _fgebe, _fcdda := _aeacd.(_g.EndElement); _fcdda && _fgebe.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aeacd)
}
func NewCT_LineEndProperties() *CT_LineEndProperties {
	_gacdg := &CT_LineEndProperties{}
	return _gacdg
}
func (_bfdad *ST_PresetMaterialType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_bfdad = 0
	case "legacyMatte":
		*_bfdad = 1
	case "legacyPlastic":
		*_bfdad = 2
	case "legacyMetal":
		*_bfdad = 3
	case "legacyWireframe":
		*_bfdad = 4
	case "matte":
		*_bfdad = 5
	case "plastic":
		*_bfdad = 6
	case "metal":
		*_bfdad = 7
	case "warmMatte":
		*_bfdad = 8
	case "translucentPowder":
		*_bfdad = 9
	case "powder":
		*_bfdad = 10
	case "dkEdge":
		*_bfdad = 11
	case "softEdge":
		*_bfdad = 12
	case "clear":
		*_bfdad = 13
	case "flat":
		*_bfdad = 14
	case "softmetal":
		*_bfdad = 15
	}
	return nil
}
func (_cgdcd *CT_NonVisualPictureProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _cfefe := range start.Attr {
		if _cfefe.Name.Local == "preferRelativeResize" {
			_dccfc, _ccge := _e.ParseBool(_cfefe.Value)
			if _ccge != nil {
				return _ccge
			}
			_cgdcd.PreferRelativeResizeAttr = &_dccfc
			continue
		}
	}
_ggegc:
	for {
		_gdge, _deaab := d.Token()
		if _deaab != nil {
			return _deaab
		}
		switch _dcac := _gdge.(type) {
		case _g.StartElement:
			switch _dcac.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "picLocks"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "picLocks"}:
				_cgdcd.PicLocks = NewCT_PictureLocking()
				if _dccec := d.DecodeElement(_cgdcd.PicLocks, &_dcac); _dccec != nil {
					return _dccec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_cgdcd.ExtLst = NewCT_OfficeArtExtensionList()
				if _eabb := d.DecodeElement(_cgdcd.ExtLst, &_dcac); _eabb != nil {
					return _eabb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_NonVisualPictureProperties\u0020%v", _dcac.Name)
				if _ecfde := d.Skip(); _ecfde != nil {
					return _ecfde
				}
			}
		case _g.EndElement:
			break _ggegc
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_AlphaModulateEffect() *CT_AlphaModulateEffect {
	_gec := &CT_AlphaModulateEffect{}
	_gec.Cont = NewCT_EffectContainer()
	return _gec
}

// Validate validates the CT_BaseStyles and its children
func (_cda *CT_BaseStyles) Validate() error { return _cda.ValidateWithPath("CT_BaseStyles") }
func (_fgged *ST_DgmBuildStep) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_agfff, _fbdgf := d.Token()
	if _fbdgf != nil {
		return _fbdgf
	}
	if _egacbe, _fcaffe := _agfff.(_g.EndElement); _fcaffe && _egacbe.Name == start.Name {
		*_fgged = 1
		return nil
	}
	if _eadgb, _bfcb := _agfff.(_g.CharData); !_bfcb {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _agfff)
	} else {
		switch string(_eadgb) {
		case "":
			*_fgged = 0
		case "sp":
			*_fgged = 1
		case "bg":
			*_fgged = 2
		}
	}
	_agfff, _fbdgf = d.Token()
	if _fbdgf != nil {
		return _fbdgf
	}
	if _dfadb, _gcbfe := _agfff.(_g.EndElement); _gcbfe && _dfadb.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _agfff)
}
func (_afega *CT_TextCharBullet) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _aacbe := range start.Attr {
		if _aacbe.Name.Local == "char" {
			_acgfe, _dgeff := _aacbe.Value, error(nil)
			if _dgeff != nil {
				return _dgeff
			}
			_afega.CharAttr = _acgfe
			continue
		}
	}
	for {
		_bbcg, _daeca := d.Token()
		if _daeca != nil {
			return _dcf.Errorf("parsing\u0020CT_TextCharBullet: \u0025s", _daeca)
		}
		if _gdffa, _ecgd := _bbcg.(_g.EndElement); _ecgd && _gdffa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bgfag *ST_LineCap) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_bgfag = 0
	case "rnd":
		*_bgfag = 1
	case "sq":
		*_bgfag = 2
	case "flat":
		*_bgfag = 3
	}
	return nil
}

type CT_AnimationGraphicalObjectBuildProperties struct {
	BldDgm   *CT_AnimationDgmBuildProperties
	BldChart *CT_AnimationChartBuildProperties
}

// ValidateWithPath validates the CT_PositiveFixedPercentage and its children, prefixing error messages with path
func (_gcgfg *CT_PositiveFixedPercentage) ValidateWithPath(path string) error {
	if _cfgdd := _gcgfg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _cfgdd != nil {
		return _cfgdd
	}
	return nil
}

// ValidateWithPath validates the CT_StretchInfoProperties and its children, prefixing error messages with path
func (_bgcfa *CT_StretchInfoProperties) ValidateWithPath(path string) error {
	if _bgcfa.FillRect != nil {
		if _gcddbb := _bgcfa.FillRect.ValidateWithPath(path + "\u002fFillRect"); _gcddbb != nil {
			return _gcddbb
		}
	}
	return nil
}
func (_aaabb ST_AnimationBuildType) Validate() error { return _aaabb.ValidateWithPath("") }

// Validate validates the CT_TextBulletSizePoint and its children
func (_egdfg *CT_TextBulletSizePoint) Validate() error {
	return _egdfg.ValidateWithPath("CT_TextBulletSizePoint")
}
func (_dedcd *CT_SolidColorFillProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _dedcd.ScrgbClr != nil {
		_bafbgg := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_dedcd.ScrgbClr, _bafbgg)
	}
	if _dedcd.SrgbClr != nil {
		_aded := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_dedcd.SrgbClr, _aded)
	}
	if _dedcd.HslClr != nil {
		_cdge := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_dedcd.HslClr, _cdge)
	}
	if _dedcd.SysClr != nil {
		_gcde := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_dedcd.SysClr, _gcde)
	}
	if _dedcd.SchemeClr != nil {
		_ecad := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_dedcd.SchemeClr, _ecad)
	}
	if _dedcd.PrstClr != nil {
		_ecbbf := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_dedcd.PrstClr, _ecbbf)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_bgbd *CT_GrayscaleTransform) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_abbbc ST_PresetColorVal) Validate() error { return _abbbc.ValidateWithPath("") }

// Validate validates the CT_FillEffect and its children
func (_fbdbd *CT_FillEffect) Validate() error    { return _fbdbd.ValidateWithPath("CT_FillEffect") }
func NewEG_TextBulletColor() *EG_TextBulletColor { _dcbfcb := &EG_TextBulletColor{}; return _dcbfcb }

// Validate validates the Blip and its children
func (_gbe *Blip) Validate() error { return _gbe.ValidateWithPath("Blip") }
func (_dagag *CT_Percentage) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", _dagag.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_EffectStyleList and its children, prefixing error messages with path
func (_gcdfg *CT_EffectStyleList) ValidateWithPath(path string) error {
	for _ebfcbg, _cbdb := range _gcdfg.EffectStyle {
		if _cgee := _cbdb.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fEffectStyle\u005b\u0025d\u005d", path, _ebfcbg)); _cgee != nil {
			return _cgee
		}
	}
	return nil
}

type CT_SolidColorFillProperties struct {
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
}

func (_agada ST_ChartBuildStep) String() string {
	switch _agada {
	case 0:
		return ""
	case 1:
		return "category"
	case 2:
		return "ptInCategory"
	case 3:
		return "series"
	case 4:
		return "ptInSeries"
	case 5:
		return "allPts"
	case 6:
		return "gridLegend"
	}
	return ""
}

type CT_AnimationElementChoice struct {
	Dgm   *CT_AnimationDgmElement
	Chart *CT_AnimationChartElement
}

func (_adaab ST_AnimationBuildType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_adaab.String(), start)
}
func (_ffda *CT_PositiveFixedAngle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", _ffda.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_OfficeArtExtensionList and its children, prefixing error messages with path
func (_fcfe *CT_OfficeArtExtensionList) ValidateWithPath(path string) error {
	for _egaa, _bacbb := range _fcfe.Ext {
		if _aeeg := _bacbb.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fExt\u005b\u0025d\u005d", path, _egaa)); _aeeg != nil {
			return _aeeg
		}
	}
	return nil
}

const (
	ST_TextAlignTypeUnset    ST_TextAlignType = 0
	ST_TextAlignTypeL        ST_TextAlignType = 1
	ST_TextAlignTypeCtr      ST_TextAlignType = 2
	ST_TextAlignTypeR        ST_TextAlignType = 3
	ST_TextAlignTypeJust     ST_TextAlignType = 4
	ST_TextAlignTypeJustLow  ST_TextAlignType = 5
	ST_TextAlignTypeDist     ST_TextAlignType = 6
	ST_TextAlignTypeThaiDist ST_TextAlignType = 7
)

func NewCT_GvmlGraphicalObjectFrame() *CT_GvmlGraphicalObjectFrame {
	_ccfcg := &CT_GvmlGraphicalObjectFrame{}
	_ccfcg.NvGraphicFramePr = NewCT_GvmlGraphicFrameNonVisual()
	_ccfcg.Graphic = NewGraphic()
	_ccfcg.Xfrm = NewCT_Transform2D()
	return _ccfcg
}
func (_ecadd *ST_PresetLineDashVal) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_ecadd = 0
	case "solid":
		*_ecadd = 1
	case "dot":
		*_ecadd = 2
	case "dash":
		*_ecadd = 3
	case "lgDash":
		*_ecadd = 4
	case "dashDot":
		*_ecadd = 5
	case "lgDashDot":
		*_ecadd = 6
	case "lgDashDotDot":
		*_ecadd = 7
	case "sysDash":
		*_ecadd = 8
	case "sysDot":
		*_ecadd = 9
	case "sysDashDot":
		*_ecadd = 10
	case "sysDashDotDot":
		*_ecadd = 11
	}
	return nil
}
func (_fbfcb *CT_HslColor) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "hue"}, Value: _dcf.Sprintf("\u0025v", _fbfcb.HueAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sat"}, Value: _dcf.Sprintf("\u0025v", _fbfcb.SatAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lum"}, Value: _dcf.Sprintf("\u0025v", _fbfcb.LumAttr)})
	e.EncodeToken(start)
	if _fbfcb.EG_ColorTransform != nil {
		for _, _cdbfd := range _fbfcb.EG_ColorTransform {
			_cdbfd.MarshalXML(e, _g.StartElement{})
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_bfbb *CT_PresetLineDashProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bbagf := range start.Attr {
		if _bbagf.Name.Local == "val" {
			_bfbb.ValAttr.UnmarshalXMLAttr(_bbagf)
			continue
		}
	}
	for {
		_gcdac, _dfeeca := d.Token()
		if _dfeeca != nil {
			return _dcf.Errorf("parsing\u0020CT_PresetLineDashProperties:\u0020\u0025s", _dfeeca)
		}
		if _acdfa, _ebcfa := _gcdac.(_g.EndElement); _ebcfa && _acdfa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_feagg *CT_ReflectionEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _fgaab := range start.Attr {
		if _fgaab.Name.Local == "fadeDir" {
			_aace, _gfebb := _e.ParseInt(_fgaab.Value, 10, 32)
			if _gfebb != nil {
				return _gfebb
			}
			_cdefe := int32(_aace)
			_feagg.FadeDirAttr = &_cdefe
			continue
		}
		if _fgaab.Name.Local == "blurRad" {
			_gefeg, _eggc := _e.ParseInt(_fgaab.Value, 10, 64)
			if _eggc != nil {
				return _eggc
			}
			_feagg.BlurRadAttr = &_gefeg
			continue
		}
		if _fgaab.Name.Local == "stPos" {
			_cdcb, _baccd := ParseUnionST_PositiveFixedPercentage(_fgaab.Value)
			if _baccd != nil {
				return _baccd
			}
			_feagg.StPosAttr = &_cdcb
			continue
		}
		if _fgaab.Name.Local == "endA" {
			_gfac, _gggde := ParseUnionST_PositiveFixedPercentage(_fgaab.Value)
			if _gggde != nil {
				return _gggde
			}
			_feagg.EndAAttr = &_gfac
			continue
		}
		if _fgaab.Name.Local == "endPos" {
			_ccfeg, _fcbfb := ParseUnionST_PositiveFixedPercentage(_fgaab.Value)
			if _fcbfb != nil {
				return _fcbfb
			}
			_feagg.EndPosAttr = &_ccfeg
			continue
		}
		if _fgaab.Name.Local == "dist" {
			_fged, _cafbe := _e.ParseInt(_fgaab.Value, 10, 64)
			if _cafbe != nil {
				return _cafbe
			}
			_feagg.DistAttr = &_fged
			continue
		}
		if _fgaab.Name.Local == "dir" {
			_bfebdb, _efcbg := _e.ParseInt(_fgaab.Value, 10, 32)
			if _efcbg != nil {
				return _efcbg
			}
			_baaga := int32(_bfebdb)
			_feagg.DirAttr = &_baaga
			continue
		}
		if _fgaab.Name.Local == "stA" {
			_efcfc, _faade := ParseUnionST_PositiveFixedPercentage(_fgaab.Value)
			if _faade != nil {
				return _faade
			}
			_feagg.StAAttr = &_efcfc
			continue
		}
		if _fgaab.Name.Local == "sx" {
			_dfada, _ggcgf := ParseUnionST_Percentage(_fgaab.Value)
			if _ggcgf != nil {
				return _ggcgf
			}
			_feagg.SxAttr = &_dfada
			continue
		}
		if _fgaab.Name.Local == "sy" {
			_bcbb, _cfeaf := ParseUnionST_Percentage(_fgaab.Value)
			if _cfeaf != nil {
				return _cfeaf
			}
			_feagg.SyAttr = &_bcbb
			continue
		}
		if _fgaab.Name.Local == "kx" {
			_afcaa, _cbbeg := _e.ParseInt(_fgaab.Value, 10, 32)
			if _cbbeg != nil {
				return _cbbeg
			}
			_aacea := int32(_afcaa)
			_feagg.KxAttr = &_aacea
			continue
		}
		if _fgaab.Name.Local == "ky" {
			_ggada, _cgba := _e.ParseInt(_fgaab.Value, 10, 32)
			if _cgba != nil {
				return _cgba
			}
			_cdbag := int32(_ggada)
			_feagg.KyAttr = &_cdbag
			continue
		}
		if _fgaab.Name.Local == "algn" {
			_feagg.AlgnAttr.UnmarshalXMLAttr(_fgaab)
			continue
		}
		if _fgaab.Name.Local == "rotWithShape" {
			_cbefb, _gbgf := _e.ParseBool(_fgaab.Value)
			if _gbgf != nil {
				return _gbgf
			}
			_feagg.RotWithShapeAttr = &_cbefb
			continue
		}
	}
	for {
		_cdda, _daeefa := d.Token()
		if _daeefa != nil {
			return _dcf.Errorf("parsing\u0020CT_ReflectionEffect:\u0020\u0025s", _daeefa)
		}
		if _cfbfa, _ecfged := _cdda.(_g.EndElement); _ecfged && _cfbfa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gfcgc ST_PitchFamily) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_bgdcaa := _g.Attr{}
	_bgdcaa.Name = name
	switch _gfcgc {
	case ST_PitchFamilyUnset:
		_bgdcaa.Value = ""
	case ST_PitchFamily00:
		_bgdcaa.Value = "00"
	case ST_PitchFamily01:
		_bgdcaa.Value = "01"
	case ST_PitchFamily02:
		_bgdcaa.Value = "02"
	case ST_PitchFamily16:
		_bgdcaa.Value = "16"
	case ST_PitchFamily17:
		_bgdcaa.Value = "17"
	case ST_PitchFamily18:
		_bgdcaa.Value = "18"
	case ST_PitchFamily32:
		_bgdcaa.Value = "32"
	case ST_PitchFamily33:
		_bgdcaa.Value = "33"
	case ST_PitchFamily34:
		_bgdcaa.Value = "34"
	case ST_PitchFamily48:
		_bgdcaa.Value = "48"
	case ST_PitchFamily49:
		_bgdcaa.Value = "49"
	case ST_PitchFamily50:
		_bgdcaa.Value = "50"
	case ST_PitchFamily64:
		_bgdcaa.Value = "64"
	case ST_PitchFamily65:
		_bgdcaa.Value = "65"
	case ST_PitchFamily66:
		_bgdcaa.Value = "66"
	case ST_PitchFamily80:
		_bgdcaa.Value = "80"
	case ST_PitchFamily81:
		_bgdcaa.Value = "81"
	case ST_PitchFamily82:
		_bgdcaa.Value = "82"
	}
	return _bgdcaa, nil
}
func NewCT_BiLevelEffect() *CT_BiLevelEffect { _ccbf := &CT_BiLevelEffect{}; return _ccbf }

// Validate validates the EG_ColorTransform and its children
func (_dafgb *EG_ColorTransform) Validate() error {
	return _dafgb.ValidateWithPath("EG_ColorTransform")
}

// ValidateWithPath validates the CT_TextBulletSizePoint and its children, prefixing error messages with path
func (_gfcfc *CT_TextBulletSizePoint) ValidateWithPath(path string) error {
	if _gfcfc.ValAttr < 100 {
		return _dcf.Errorf("\u0025s/m\u002eValAttr\u0020must\u0020be\u0020\u003e\u003d\u0020100\u0020\u0028have\u0020\u0025v\u0029", path, _gfcfc.ValAttr)
	}
	if _gfcfc.ValAttr > 400000 {
		return _dcf.Errorf("%s\u002fm\u002eValAttr\u0020must\u0020be\u0020\u003c\u003d\u0020400000 (have\u0020%v\u0029", path, _gfcfc.ValAttr)
	}
	return nil
}

// ValidateWithPath validates the CT_LineJoinMiterProperties and its children, prefixing error messages with path
func (_cdea *CT_LineJoinMiterProperties) ValidateWithPath(path string) error {
	if _cdea.LimAttr != nil {
		if _fcdfb := _cdea.LimAttr.ValidateWithPath(path + "\u002fLimAttr"); _fcdfb != nil {
			return _fcdfb
		}
	}
	return nil
}

type ST_TextHorzOverflowType byte

func (_agaag *CT_GvmlGroupShapeChoice) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_cdfbd:
	for {
		_beafd, _begd := d.Token()
		if _begd != nil {
			return _begd
		}
		switch _adbfc := _beafd.(type) {
		case _g.StartElement:
			switch _adbfc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "txSp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "txSp"}:
				_fbgg := NewCT_GvmlTextShape()
				if _cgbbf := d.DecodeElement(_fbgg, &_adbfc); _cgbbf != nil {
					return _cgbbf
				}
				_agaag.TxSp = append(_agaag.TxSp, _fbgg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sp"}:
				_cafca := NewCT_GvmlShape()
				if _dbega := d.DecodeElement(_cafca, &_adbfc); _dbega != nil {
					return _dbega
				}
				_agaag.Sp = append(_agaag.Sp, _cafca)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cxnSp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cxnSp"}:
				_acfeb := NewCT_GvmlConnector()
				if _gfaa := d.DecodeElement(_acfeb, &_adbfc); _gfaa != nil {
					return _gfaa
				}
				_agaag.CxnSp = append(_agaag.CxnSp, _acfeb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pic"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pic"}:
				_acdaa := NewCT_GvmlPicture()
				if _dfcad := d.DecodeElement(_acdaa, &_adbfc); _dfcad != nil {
					return _dfcad
				}
				_agaag.Pic = append(_agaag.Pic, _acdaa)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "graphicFrame"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "graphicFrame"}:
				_daggb := NewCT_GvmlGraphicalObjectFrame()
				if _cebae := d.DecodeElement(_daggb, &_adbfc); _cebae != nil {
					return _cebae
				}
				_agaag.GraphicFrame = append(_agaag.GraphicFrame, _daggb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpSp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpSp"}:
				_cabgc := NewCT_GvmlGroupShape()
				if _dbfe := d.DecodeElement(_cabgc, &_adbfc); _dbfe != nil {
					return _dbfe
				}
				_agaag.GrpSp = append(_agaag.GrpSp, _cabgc)
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_GvmlGroupShapeChoice \u0025v", _adbfc.Name)
				if _bdfb := d.Skip(); _bdfb != nil {
					return _bdfb
				}
			}
		case _g.EndElement:
			break _cdfbd
		case _g.CharData:
		}
	}
	return nil
}
func (_bcdbd ST_TextTabAlignType) String() string {
	switch _bcdbd {
	case 0:
		return ""
	case 1:
		return "l"
	case 2:
		return "ctr"
	case 3:
		return "r"
	case 4:
		return "dec"
	}
	return ""
}
func (_abcfb ST_TextVerticalType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_edfcge := _g.Attr{}
	_edfcge.Name = name
	switch _abcfb {
	case ST_TextVerticalTypeUnset:
		_edfcge.Value = ""
	case ST_TextVerticalTypeHorz:
		_edfcge.Value = "horz"
	case ST_TextVerticalTypeVert:
		_edfcge.Value = "vert"
	case ST_TextVerticalTypeVert270:
		_edfcge.Value = "vert270"
	case ST_TextVerticalTypeWordArtVert:
		_edfcge.Value = "wordArtVert"
	case ST_TextVerticalTypeEaVert:
		_edfcge.Value = "eaVert"
	case ST_TextVerticalTypeMongolianVert:
		_edfcge.Value = "mongolianVert"
	case ST_TextVerticalTypeWordArtVertRtl:
		_edfcge.Value = "wordArtVertRtl"
	}
	return _edfcge, nil
}

const (
	ST_PathShadeTypeUnset  ST_PathShadeType = 0
	ST_PathShadeTypeShape  ST_PathShadeType = 1
	ST_PathShadeTypeCircle ST_PathShadeType = 2
	ST_PathShadeTypeRect   ST_PathShadeType = 3
)

// Validate validates the CT_StyleMatrix and its children
func (_dgce *CT_StyleMatrix) Validate() error { return _dgce.ValidateWithPath("CT_StyleMatrix") }
func (_abbggc ST_TextTabAlignType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_abbggc.String(), start)
}
func (_cfbe *CT_GradientStop) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _efab := range start.Attr {
		if _efab.Name.Local == "pos" {
			_ffcc, _daaa := ParseUnionST_PositiveFixedPercentage(_efab.Value)
			if _daaa != nil {
				return _daaa
			}
			_cfbe.PosAttr = _ffcc
			continue
		}
	}
_defg:
	for {
		_bgabg, _acgfg := d.Token()
		if _acgfg != nil {
			return _acgfg
		}
		switch _cfga := _bgabg.(type) {
		case _g.StartElement:
			switch _cfga.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_cfbe.ScrgbClr = NewCT_ScRgbColor()
				if _cdade := d.DecodeElement(_cfbe.ScrgbClr, &_cfga); _cdade != nil {
					return _cdade
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_cfbe.SrgbClr = NewCT_SRgbColor()
				if _bbcfe := d.DecodeElement(_cfbe.SrgbClr, &_cfga); _bbcfe != nil {
					return _bbcfe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_cfbe.HslClr = NewCT_HslColor()
				if _adcc := d.DecodeElement(_cfbe.HslClr, &_cfga); _adcc != nil {
					return _adcc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_cfbe.SysClr = NewCT_SystemColor()
				if _eggb := d.DecodeElement(_cfbe.SysClr, &_cfga); _eggb != nil {
					return _eggb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_cfbe.SchemeClr = NewCT_SchemeColor()
				if _bggg := d.DecodeElement(_cfbe.SchemeClr, &_cfga); _bggg != nil {
					return _bggg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_cfbe.PrstClr = NewCT_PresetColor()
				if _fcbd := d.DecodeElement(_cfbe.PrstClr, &_cfga); _fcbd != nil {
					return _fcbd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GradientStop\u0020\u0025v", _cfga.Name)
				if _adfea := d.Skip(); _adfea != nil {
					return _adfea
				}
			}
		case _g.EndElement:
			break _defg
		case _g.CharData:
		}
	}
	return nil
}

type CT_ConnectionSite struct {
	AngAttr ST_AdjAngle
	Pos     *CT_AdjPoint2D
}

func NewCT_Table() *CT_Table {
	_cgabc := &CT_Table{}
	_cgabc.TblGrid = NewCT_TableGrid()
	return _cgabc
}

type CT_PositiveSize2D struct {
	CxAttr int64
	CyAttr int64
}

func NewCT_OfficeArtExtensionList() *CT_OfficeArtExtensionList {
	_bafdb := &CT_OfficeArtExtensionList{}
	return _bafdb
}

type Theme struct{ CT_OfficeStyleSheet }

func NewCT_BlendEffect() *CT_BlendEffect {
	_cec := &CT_BlendEffect{}
	_cec.BlendAttr = ST_BlendMode(1)
	_cec.Cont = NewCT_EffectContainer()
	return _cec
}
func (_fgce *CT_LineJoinBevel) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_afcgae *ST_BevelPresetType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_faadc, _fccff := d.Token()
	if _fccff != nil {
		return _fccff
	}
	if _ageef, _cdbe := _faadc.(_g.EndElement); _cdbe && _ageef.Name == start.Name {
		*_afcgae = 1
		return nil
	}
	if _gdecd, _baafdd := _faadc.(_g.CharData); !_baafdd {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _faadc)
	} else {
		switch string(_gdecd) {
		case "":
			*_afcgae = 0
		case "relaxedInset":
			*_afcgae = 1
		case "circle":
			*_afcgae = 2
		case "slope":
			*_afcgae = 3
		case "cross":
			*_afcgae = 4
		case "angle":
			*_afcgae = 5
		case "softRound":
			*_afcgae = 6
		case "convex":
			*_afcgae = 7
		case "coolSlant":
			*_afcgae = 8
		case "divot":
			*_afcgae = 9
		case "riblet":
			*_afcgae = 10
		case "hardEdge":
			*_afcgae = 11
		case "artDeco":
			*_afcgae = 12
		}
	}
	_faadc, _fccff = d.Token()
	if _fccff != nil {
		return _fccff
	}
	if _dbfff, _ccfgb := _faadc.(_g.EndElement); _ccfgb && _dbfff.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _faadc)
}
func (_gbaca *EG_ThemeableEffectStyle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _gbaca.Effect != nil {
		_gbbcfc := _g.StartElement{Name: _g.Name{Local: "a:effect"}}
		e.EncodeElement(_gbaca.Effect, _gbbcfc)
	}
	if _gbaca.EffectRef != nil {
		_fbcef := _g.StartElement{Name: _g.Name{Local: "a:effectRef"}}
		e.EncodeElement(_gbaca.EffectRef, _fbcef)
	}
	return nil
}
func (_ecfcda ST_TextBulletSize) String() string {
	if _ecfcda.ST_TextBulletSizePercent != nil {
		return _dcf.Sprintf("\u0025v", *_ecfcda.ST_TextBulletSizePercent)
	}
	if _ecfcda.ST_TextBulletSizeDecimal != nil {
		return _dcf.Sprintf("\u0025v", *_ecfcda.ST_TextBulletSizeDecimal)
	}
	return ""
}

type CT_Bevel struct {
	WAttr    *int64
	HAttr    *int64
	PrstAttr ST_BevelPresetType
}

// Validate validates the CT_Path2DQuadBezierTo and its children
func (_gdag *CT_Path2DQuadBezierTo) Validate() error {
	return _gdag.ValidateWithPath("CT_Path2DQuadBezierTo")
}
func (_dcadff *CT_HSLEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _deeg := range start.Attr {
		if _deeg.Name.Local == "hue" {
			_ceegc, _dcbcd := _e.ParseInt(_deeg.Value, 10, 32)
			if _dcbcd != nil {
				return _dcbcd
			}
			_egbae := int32(_ceegc)
			_dcadff.HueAttr = &_egbae
			continue
		}
		if _deeg.Name.Local == "sat" {
			_gbdbd, _cdadec := ParseUnionST_FixedPercentage(_deeg.Value)
			if _cdadec != nil {
				return _cdadec
			}
			_dcadff.SatAttr = &_gbdbd
			continue
		}
		if _deeg.Name.Local == "lum" {
			_gfgga, _agfb := ParseUnionST_FixedPercentage(_deeg.Value)
			if _agfb != nil {
				return _agfb
			}
			_dcadff.LumAttr = &_gfgga
			continue
		}
	}
	for {
		_ecda, _gdac := d.Token()
		if _gdac != nil {
			return _dcf.Errorf("parsing\u0020CT_HSLEffect:\u0020\u0025s", _gdac)
		}
		if _bfebd, _efcf := _ecda.(_g.EndElement); _efcf && _bfebd.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TableGrid and its children, prefixing error messages with path
func (_egaeab *CT_TableGrid) ValidateWithPath(path string) error {
	for _fcffdf, _dddbd := range _egaeab.GridCol {
		if _edffb := _dddbd.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fGridCol\u005b\u0025d\u005d", path, _fcffdf)); _edffb != nil {
			return _edffb
		}
	}
	return nil
}

// Validate validates the CT_TableCol and its children
func (_febaeb *CT_TableCol) Validate() error    { return _febaeb.ValidateWithPath("CT_TableCol") }
func (_bcbba ST_RectAlignment) Validate() error { return _bcbba.ValidateWithPath("") }
func (_ceff *CT_TextSpacingPercent) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _dcafd := range start.Attr {
		if _dcafd.Name.Local == "val" {
			_fcddc, _faeefb := ParseUnionST_TextSpacingPercentOrPercentString(_dcafd.Value)
			if _faeefb != nil {
				return _faeefb
			}
			_ceff.ValAttr = _fcddc
			continue
		}
	}
	for {
		_edbde, _aadee := d.Token()
		if _aadee != nil {
			return _dcf.Errorf("parsing\u0020CT_TextSpacingPercent:\u0020\u0025s", _aadee)
		}
		if _gcded, _fcbbg := _edbde.(_g.EndElement); _fcbbg && _gcded.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_BlipChoice() *CT_BlipChoice { _cab := &CT_BlipChoice{}; return _cab }
func (_eaff *CT_GroupFillProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_cegfa, _bgbdb := d.Token()
		if _bgbdb != nil {
			return _dcf.Errorf("parsing\u0020CT_GroupFillProperties:\u0020\u0025s", _bgbdb)
		}
		if _ccebd, _egbgf := _cegfa.(_g.EndElement); _egbgf && _ccebd.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_StyleMatrix struct {
	NameAttr       *string
	FillStyleLst   *CT_FillStyleList
	LnStyleLst     *CT_LineStyleList
	EffectStyleLst *CT_EffectStyleList
	BgFillStyleLst *CT_BackgroundFillStyleList
}

// ValidateWithPath validates the CT_GraphicalObject and its children, prefixing error messages with path
func (_bdbff *CT_GraphicalObject) ValidateWithPath(path string) error {
	if _cgbb := _bdbff.GraphicData.ValidateWithPath(path + "\u002fGraphicData"); _cgbb != nil {
		return _cgbb
	}
	return nil
}

// Validate validates the CT_TextAutonumberBullet and its children
func (_eeafa *CT_TextAutonumberBullet) Validate() error {
	return _eeafa.ValidateWithPath("CT_TextAutonumberBullet")
}
func (_bada *CT_ComplementTransform) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ecgff *CT_RelativeOffsetEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _efebb := range start.Attr {
		if _efebb.Name.Local == "tx" {
			_begc, _fbbeb := ParseUnionST_Percentage(_efebb.Value)
			if _fbbeb != nil {
				return _fbbeb
			}
			_ecgff.TxAttr = &_begc
			continue
		}
		if _efebb.Name.Local == "ty" {
			_gcafb, _fgccg := ParseUnionST_Percentage(_efebb.Value)
			if _fgccg != nil {
				return _fgccg
			}
			_ecgff.TyAttr = &_gcafb
			continue
		}
	}
	for {
		_edfce, _eeaf := d.Token()
		if _eeaf != nil {
			return _dcf.Errorf("parsing CT_RelativeOffsetEffect:\u0020%s", _eeaf)
		}
		if _bfedc, _ccbfd := _edfce.(_g.EndElement); _ccbfd && _bfedc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fefg *CT_CustomGeometry2D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _fefg.AvLst != nil {
		_acgc := _g.StartElement{Name: _g.Name{Local: "a:avLst"}}
		e.EncodeElement(_fefg.AvLst, _acgc)
	}
	if _fefg.GdLst != nil {
		_cefda := _g.StartElement{Name: _g.Name{Local: "a:gdLst"}}
		e.EncodeElement(_fefg.GdLst, _cefda)
	}
	if _fefg.AhLst != nil {
		_dgab := _g.StartElement{Name: _g.Name{Local: "a:ahLst"}}
		e.EncodeElement(_fefg.AhLst, _dgab)
	}
	if _fefg.CxnLst != nil {
		_ebeg := _g.StartElement{Name: _g.Name{Local: "a:cxnLst"}}
		e.EncodeElement(_fefg.CxnLst, _ebeg)
	}
	if _fefg.Rect != nil {
		_dadf := _g.StartElement{Name: _g.Name{Local: "a:rect"}}
		e.EncodeElement(_fefg.Rect, _dadf)
	}
	_bafbg := _g.StartElement{Name: _g.Name{Local: "a:pathLst"}}
	e.EncodeElement(_fefg.PathLst, _bafbg)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the EG_Media and its children, prefixing error messages with path
func (_ccbada *EG_Media) ValidateWithPath(path string) error {
	if _ccbada.AudioCd != nil {
		if _efebd := _ccbada.AudioCd.ValidateWithPath(path + "\u002fAudioCd"); _efebd != nil {
			return _efebd
		}
	}
	if _ccbada.WavAudioFile != nil {
		if _begce := _ccbada.WavAudioFile.ValidateWithPath(path + "\u002fWavAudioFile"); _begce != nil {
			return _begce
		}
	}
	if _ccbada.AudioFile != nil {
		if _gcccb := _ccbada.AudioFile.ValidateWithPath(path + "\u002fAudioFile"); _gcccb != nil {
			return _gcccb
		}
	}
	if _ccbada.VideoFile != nil {
		if _adff := _ccbada.VideoFile.ValidateWithPath(path + "\u002fVideoFile"); _adff != nil {
			return _adff
		}
	}
	if _ccbada.QuickTimeFile != nil {
		if _gdddca := _ccbada.QuickTimeFile.ValidateWithPath(path + "\u002fQuickTimeFile"); _gdddca != nil {
			return _gdddca
		}
	}
	return nil
}
func (_cdgbc *CT_GrayscaleEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_Point3D struct {
	XAttr ST_Coordinate
	YAttr ST_Coordinate
	ZAttr ST_Coordinate
}
type CT_GrayscaleTransform struct{}
type CT_HslColor struct {
	HueAttr           int32
	SatAttr           ST_Percentage
	LumAttr           ST_Percentage
	EG_ColorTransform []*EG_ColorTransform
}

func (_dagde *CT_PositivePercentage) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", _dagde.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_PresetLineDashProperties struct{ ValAttr ST_PresetLineDashVal }

func (_egebbe ST_CompoundLine) String() string {
	switch _egebbe {
	case 0:
		return ""
	case 1:
		return "sng"
	case 2:
		return "dbl"
	case 3:
		return "thickThin"
	case 4:
		return "thinThick"
	case 5:
		return "tri"
	}
	return ""
}
func (_eadbd *CT_FillEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gedf:
	for {
		_ccca, _gggd := d.Token()
		if _gggd != nil {
			return _gggd
		}
		switch _ccgg := _ccca.(type) {
		case _g.StartElement:
			switch _ccgg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_eadbd.NoFill = NewCT_NoFillProperties()
				if _degb := d.DecodeElement(_eadbd.NoFill, &_ccgg); _degb != nil {
					return _degb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_eadbd.SolidFill = NewCT_SolidColorFillProperties()
				if _ccacd := d.DecodeElement(_eadbd.SolidFill, &_ccgg); _ccacd != nil {
					return _ccacd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_eadbd.GradFill = NewCT_GradientFillProperties()
				if _egfb := d.DecodeElement(_eadbd.GradFill, &_ccgg); _egfb != nil {
					return _egfb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_eadbd.BlipFill = NewCT_BlipFillProperties()
				if _fadfg := d.DecodeElement(_eadbd.BlipFill, &_ccgg); _fadfg != nil {
					return _fadfg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_eadbd.PattFill = NewCT_PatternFillProperties()
				if _baec := d.DecodeElement(_eadbd.PattFill, &_ccgg); _baec != nil {
					return _baec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_eadbd.GrpFill = NewCT_GroupFillProperties()
				if _dbfb := d.DecodeElement(_eadbd.GrpFill, &_ccgg); _dbfb != nil {
					return _dbfb
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_FillEffect \u0025v", _ccgg.Name)
				if _ecgbg := d.Skip(); _ecgbg != nil {
					return _ecgbg
				}
			}
		case _g.EndElement:
			break _gedf
		case _g.CharData:
		}
	}
	return nil
}

type ST_PenAlignment byte

func (_agbfa *CT_LineJoinMiterProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _agbfa.LimAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lim"}, Value: _dcf.Sprintf("\u0025v", *_agbfa.LimAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_aadg *EG_FillProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fefde:
	for {
		_gfcge, _gcbgg := d.Token()
		if _gcbgg != nil {
			return _gcbgg
		}
		switch _dfagce := _gfcge.(type) {
		case _g.StartElement:
			switch _dfagce.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_aadg.NoFill = NewCT_NoFillProperties()
				if _ebaec := d.DecodeElement(_aadg.NoFill, &_dfagce); _ebaec != nil {
					return _ebaec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_aadg.SolidFill = NewCT_SolidColorFillProperties()
				if _bafge := d.DecodeElement(_aadg.SolidFill, &_dfagce); _bafge != nil {
					return _bafge
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_aadg.GradFill = NewCT_GradientFillProperties()
				if _afefc := d.DecodeElement(_aadg.GradFill, &_dfagce); _afefc != nil {
					return _afefc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_aadg.BlipFill = NewCT_BlipFillProperties()
				if _acagg := d.DecodeElement(_aadg.BlipFill, &_dfagce); _acagg != nil {
					return _acagg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_aadg.PattFill = NewCT_PatternFillProperties()
				if _bdgbe := d.DecodeElement(_aadg.PattFill, &_dfagce); _bdgbe != nil {
					return _bdgbe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_aadg.GrpFill = NewCT_GroupFillProperties()
				if _cgcae := d.DecodeElement(_aadg.GrpFill, &_dfagce); _cgcae != nil {
					return _cgcae
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020EG_FillProperties\u0020\u0025v", _dfagce.Name)
				if _dgabf := d.Skip(); _dgabf != nil {
					return _dgabf
				}
			}
		case _g.EndElement:
			break _fefde
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_NonVisualDrawingProps() *CT_NonVisualDrawingProps {
	_bafbf := &CT_NonVisualDrawingProps{}
	return _bafbf
}
func (_fdabb *CT_EmbeddedWAVAudioFile) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "r:embed"}, Value: _dcf.Sprintf("\u0025v", _fdabb.EmbedAttr)})
	if _fdabb.NameAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "name"}, Value: _dcf.Sprintf("\u0025v", *_fdabb.NameAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ccgff ST_TextAlignType) ValidateWithPath(path string) error {
	switch _ccgff {
	case 0, 1, 2, 3, 4, 5, 6, 7:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ccgff))
	}
	return nil
}
func (_dgbga *CT_NonVisualPictureProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dgbga.PreferRelativeResizeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "preferRelativeResize"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dgbga.PreferRelativeResizeAttr))})
	}
	e.EncodeToken(start)
	if _dgbga.PicLocks != nil {
		_egega := _g.StartElement{Name: _g.Name{Local: "a:picLocks"}}
		e.EncodeElement(_dgbga.PicLocks, _egega)
	}
	if _dgbga.ExtLst != nil {
		_bceg := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dgbga.ExtLst, _bceg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewEG_ThemeableFillStyle() *EG_ThemeableFillStyle {
	_ecfgac := &EG_ThemeableFillStyle{}
	return _ecfgac
}
func (_cgabf *CT_LuminanceEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _cgabf.BrightAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "bright"}, Value: _dcf.Sprintf("\u0025v", *_cgabf.BrightAttr)})
	}
	if _cgabf.ContrastAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "contrast"}, Value: _dcf.Sprintf("\u0025v", *_cgabf.ContrastAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TextBulletSizeFollowText and its children, prefixing error messages with path
func (_bcgfa *CT_TextBulletSizeFollowText) ValidateWithPath(path string) error { return nil }
func (_cbffbb *EG_TextBulletTypeface) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _cbffbb.BuFontTx != nil {
		_adaege := _g.StartElement{Name: _g.Name{Local: "a:buFontTx"}}
		e.EncodeElement(_cbffbb.BuFontTx, _adaege)
	}
	if _cbffbb.BuFont != nil {
		_ggefg := _g.StartElement{Name: _g.Name{Local: "a:buFont"}}
		e.EncodeElement(_cbffbb.BuFont, _ggefg)
	}
	return nil
}

// Validate validates the CT_ColorMappingOverrideChoice and its children
func (_gbfg *CT_ColorMappingOverrideChoice) Validate() error {
	return _gbfg.ValidateWithPath("CT_ColorMappingOverrideChoice")
}
func (_ecdad ST_TextHorzOverflowType) Validate() error { return _ecdad.ValidateWithPath("") }

// Validate validates the CT_TextBody and its children
func (_acefab *CT_TextBody) Validate() error { return _acefab.ValidateWithPath("CT_TextBody") }
func (_gccg *CT_BaseStyles) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gccg.ClrScheme = NewCT_ColorScheme()
	_gccg.FontScheme = NewCT_FontScheme()
	_gccg.FmtScheme = NewCT_StyleMatrix()
_caea:
	for {
		_dggf, _dda := d.Token()
		if _dda != nil {
			return _dda
		}
		switch _aeead := _dggf.(type) {
		case _g.StartElement:
			switch _aeead.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrScheme"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrScheme"}:
				if _ggaa := d.DecodeElement(_gccg.ClrScheme, &_aeead); _ggaa != nil {
					return _ggaa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fontScheme"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fontScheme"}:
				if _acbbd := d.DecodeElement(_gccg.FontScheme, &_aeead); _acbbd != nil {
					return _acbbd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fmtScheme"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fmtScheme"}:
				if _dea := d.DecodeElement(_gccg.FmtScheme, &_aeead); _dea != nil {
					return _dea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_gccg.ExtLst = NewCT_OfficeArtExtensionList()
				if _faafb := d.DecodeElement(_gccg.ExtLst, &_aeead); _faafb != nil {
					return _faafb
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_BaseStyles \u0025v", _aeead.Name)
				if _cag := d.Skip(); _cag != nil {
					return _cag
				}
			}
		case _g.EndElement:
			break _caea
		case _g.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_PresetGeometry2D and its children, prefixing error messages with path
func (_debca *CT_PresetGeometry2D) ValidateWithPath(path string) error {
	if _debca.PrstAttr == ST_ShapeTypeUnset {
		return _dcf.Errorf("\u0025s\u002fPrstAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _gfcc := _debca.PrstAttr.ValidateWithPath(path + "\u002fPrstAttr"); _gfcc != nil {
		return _gfcc
	}
	if _debca.AvLst != nil {
		if _gffga := _debca.AvLst.ValidateWithPath(path + "\u002fAvLst"); _gffga != nil {
			return _gffga
		}
	}
	return nil
}
func (_cgcgb *Theme) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cgcgb.CT_OfficeStyleSheet = *NewCT_OfficeStyleSheet()
	for _, _fbafg := range start.Attr {
		if _fbafg.Name.Local == "name" {
			_gfaec, _cbafb := _fbafg.Value, error(nil)
			if _cbafb != nil {
				return _cbafb
			}
			_cgcgb.NameAttr = &_gfaec
			continue
		}
	}
_cdgdaa:
	for {
		_abdbce, _dfdacb := d.Token()
		if _dfdacb != nil {
			return _dfdacb
		}
		switch _gbaag := _abdbce.(type) {
		case _g.StartElement:
			switch _gbaag.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "themeElements"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "themeElements"}:
				if _ffdfd := d.DecodeElement(_cgcgb.ThemeElements, &_gbaag); _ffdfd != nil {
					return _ffdfd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "objectDefaults"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "objectDefaults"}:
				_cgcgb.ObjectDefaults = NewCT_ObjectStyleDefaults()
				if _cbbgc := d.DecodeElement(_cgcgb.ObjectDefaults, &_gbaag); _cbbgc != nil {
					return _cbbgc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extraClrSchemeLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extraClrSchemeLst"}:
				_cgcgb.ExtraClrSchemeLst = NewCT_ColorSchemeList()
				if _beggd := d.DecodeElement(_cgcgb.ExtraClrSchemeLst, &_gbaag); _beggd != nil {
					return _beggd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "custClrLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "custClrLst"}:
				_cgcgb.CustClrLst = NewCT_CustomColorList()
				if _ccfbfb := d.DecodeElement(_cgcgb.CustClrLst, &_gbaag); _ccfbfb != nil {
					return _ccfbfb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_cgcgb.ExtLst = NewCT_OfficeArtExtensionList()
				if _cabdf := d.DecodeElement(_cgcgb.ExtLst, &_gbaag); _cabdf != nil {
					return _cabdf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on Theme \u0025v", _gbaag.Name)
				if _feabf := d.Skip(); _feabf != nil {
					return _feabf
				}
			}
		case _g.EndElement:
			break _cdgdaa
		case _g.CharData:
		}
	}
	return nil
}
func (_eebd *CT_EffectList) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _eebd.Blur != nil {
		_bbabc := _g.StartElement{Name: _g.Name{Local: "a:blur"}}
		e.EncodeElement(_eebd.Blur, _bbabc)
	}
	if _eebd.FillOverlay != nil {
		_ebgf := _g.StartElement{Name: _g.Name{Local: "a:fillOverlay"}}
		e.EncodeElement(_eebd.FillOverlay, _ebgf)
	}
	if _eebd.Glow != nil {
		_faeg := _g.StartElement{Name: _g.Name{Local: "a:glow"}}
		e.EncodeElement(_eebd.Glow, _faeg)
	}
	if _eebd.InnerShdw != nil {
		_addb := _g.StartElement{Name: _g.Name{Local: "a:innerShdw"}}
		e.EncodeElement(_eebd.InnerShdw, _addb)
	}
	if _eebd.OuterShdw != nil {
		_agcfa := _g.StartElement{Name: _g.Name{Local: "a:outerShdw"}}
		e.EncodeElement(_eebd.OuterShdw, _agcfa)
	}
	if _eebd.PrstShdw != nil {
		_fbad := _g.StartElement{Name: _g.Name{Local: "a:prstShdw"}}
		e.EncodeElement(_eebd.PrstShdw, _fbad)
	}
	if _eebd.Reflection != nil {
		_cfff := _g.StartElement{Name: _g.Name{Local: "a:reflection"}}
		e.EncodeElement(_eebd.Reflection, _cfff)
	}
	if _eebd.SoftEdge != nil {
		_beac := _g.StartElement{Name: _g.Name{Local: "a:softEdge"}}
		e.EncodeElement(_eebd.SoftEdge, _beac)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_egeaff *ST_PresetShadowVal) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gaedc, _ebbdgb := d.Token()
	if _ebbdgb != nil {
		return _ebbdgb
	}
	if _aecab, _daabb := _gaedc.(_g.EndElement); _daabb && _aecab.Name == start.Name {
		*_egeaff = 1
		return nil
	}
	if _fdfcb, _afdgb := _gaedc.(_g.CharData); !_afdgb {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gaedc)
	} else {
		switch string(_fdfcb) {
		case "":
			*_egeaff = 0
		case "shdw1":
			*_egeaff = 1
		case "shdw2":
			*_egeaff = 2
		case "shdw3":
			*_egeaff = 3
		case "shdw4":
			*_egeaff = 4
		case "shdw5":
			*_egeaff = 5
		case "shdw6":
			*_egeaff = 6
		case "shdw7":
			*_egeaff = 7
		case "shdw8":
			*_egeaff = 8
		case "shdw9":
			*_egeaff = 9
		case "shdw10":
			*_egeaff = 10
		case "shdw11":
			*_egeaff = 11
		case "shdw12":
			*_egeaff = 12
		case "shdw13":
			*_egeaff = 13
		case "shdw14":
			*_egeaff = 14
		case "shdw15":
			*_egeaff = 15
		case "shdw16":
			*_egeaff = 16
		case "shdw17":
			*_egeaff = 17
		case "shdw18":
			*_egeaff = 18
		case "shdw19":
			*_egeaff = 19
		case "shdw20":
			*_egeaff = 20
		}
	}
	_gaedc, _ebbdgb = d.Token()
	if _ebbdgb != nil {
		return _ebbdgb
	}
	if _gcfbf, _dbdbea := _gaedc.(_g.EndElement); _dbdbea && _gcfbf.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gaedc)
}
func (_debfbc *CT_TextNoAutofit) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_cgdf, _fede := d.Token()
		if _fede != nil {
			return _dcf.Errorf("parsing\u0020CT_TextNoAutofit: \u0025s", _fede)
		}
		if _efgagg, _ddaefb := _cgdf.(_g.EndElement); _ddaefb && _efgagg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bbgea *CT_InnerShadowEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _bbgea.BlurRadAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "blurRad"}, Value: _dcf.Sprintf("\u0025v", *_bbgea.BlurRadAttr)})
	}
	if _bbgea.DistAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dist"}, Value: _dcf.Sprintf("\u0025v", *_bbgea.DistAttr)})
	}
	if _bbgea.DirAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dir"}, Value: _dcf.Sprintf("\u0025v", *_bbgea.DirAttr)})
	}
	e.EncodeToken(start)
	if _bbgea.ScrgbClr != nil {
		_bcdeb := _g.StartElement{Name: _g.Name{Local: "a:scrgbClr"}}
		e.EncodeElement(_bbgea.ScrgbClr, _bcdeb)
	}
	if _bbgea.SrgbClr != nil {
		_dggb := _g.StartElement{Name: _g.Name{Local: "a:srgbClr"}}
		e.EncodeElement(_bbgea.SrgbClr, _dggb)
	}
	if _bbgea.HslClr != nil {
		_abgcf := _g.StartElement{Name: _g.Name{Local: "a:hslClr"}}
		e.EncodeElement(_bbgea.HslClr, _abgcf)
	}
	if _bbgea.SysClr != nil {
		_ebggc := _g.StartElement{Name: _g.Name{Local: "a:sysClr"}}
		e.EncodeElement(_bbgea.SysClr, _ebggc)
	}
	if _bbgea.SchemeClr != nil {
		_ecef := _g.StartElement{Name: _g.Name{Local: "a:schemeClr"}}
		e.EncodeElement(_bbgea.SchemeClr, _ecef)
	}
	if _bbgea.PrstClr != nil {
		_gbbgb := _g.StartElement{Name: _g.Name{Local: "a:prstClr"}}
		e.EncodeElement(_bbgea.PrstClr, _gbbgb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ConnectionSiteList and its children, prefixing error messages with path
func (_beebe *CT_ConnectionSiteList) ValidateWithPath(path string) error {
	for _cbcbg, _cbeg := range _beebe.Cxn {
		if _ddfg := _cbeg.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fCxn\u005b\u0025d\u005d", path, _cbcbg)); _ddfg != nil {
			return _ddfg
		}
	}
	return nil
}
func (_agbcf ST_TextCapsType) Validate() error { return _agbcf.ValidateWithPath("") }

// ValidateWithPath validates the CT_GrayscaleTransform and its children, prefixing error messages with path
func (_fcea *CT_GrayscaleTransform) ValidateWithPath(path string) error { return nil }
func (_eegdc *ST_TextAutonumberScheme) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ffaee, _gbaagc := d.Token()
	if _gbaagc != nil {
		return _gbaagc
	}
	if _afbcce, _beggdb := _ffaee.(_g.EndElement); _beggdb && _afbcce.Name == start.Name {
		*_eegdc = 1
		return nil
	}
	if _geabfa, _ffdbfd := _ffaee.(_g.CharData); !_ffdbfd {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ffaee)
	} else {
		switch string(_geabfa) {
		case "":
			*_eegdc = 0
		case "alphaLcParenBoth":
			*_eegdc = 1
		case "alphaUcParenBoth":
			*_eegdc = 2
		case "alphaLcParenR":
			*_eegdc = 3
		case "alphaUcParenR":
			*_eegdc = 4
		case "alphaLcPeriod":
			*_eegdc = 5
		case "alphaUcPeriod":
			*_eegdc = 6
		case "arabicParenBoth":
			*_eegdc = 7
		case "arabicParenR":
			*_eegdc = 8
		case "arabicPeriod":
			*_eegdc = 9
		case "arabicPlain":
			*_eegdc = 10
		case "romanLcParenBoth":
			*_eegdc = 11
		case "romanUcParenBoth":
			*_eegdc = 12
		case "romanLcParenR":
			*_eegdc = 13
		case "romanUcParenR":
			*_eegdc = 14
		case "romanLcPeriod":
			*_eegdc = 15
		case "romanUcPeriod":
			*_eegdc = 16
		case "circleNumDbPlain":
			*_eegdc = 17
		case "circleNumWdBlackPlain":
			*_eegdc = 18
		case "circleNumWdWhitePlain":
			*_eegdc = 19
		case "arabicDbPeriod":
			*_eegdc = 20
		case "arabicDbPlain":
			*_eegdc = 21
		case "ea1ChsPeriod":
			*_eegdc = 22
		case "ea1ChsPlain":
			*_eegdc = 23
		case "ea1ChtPeriod":
			*_eegdc = 24
		case "ea1ChtPlain":
			*_eegdc = 25
		case "ea1JpnChsDbPeriod":
			*_eegdc = 26
		case "ea1JpnKorPlain":
			*_eegdc = 27
		case "ea1JpnKorPeriod":
			*_eegdc = 28
		case "arabic1Minus":
			*_eegdc = 29
		case "arabic2Minus":
			*_eegdc = 30
		case "hebrew2Minus":
			*_eegdc = 31
		case "thaiAlphaPeriod":
			*_eegdc = 32
		case "thaiAlphaParenR":
			*_eegdc = 33
		case "thaiAlphaParenBoth":
			*_eegdc = 34
		case "thaiNumPeriod":
			*_eegdc = 35
		case "thaiNumParenR":
			*_eegdc = 36
		case "thaiNumParenBoth":
			*_eegdc = 37
		case "hindiAlphaPeriod":
			*_eegdc = 38
		case "hindiNumPeriod":
			*_eegdc = 39
		case "hindiNumParenR":
			*_eegdc = 40
		case "hindiAlpha1Period":
			*_eegdc = 41
		}
	}
	_ffaee, _gbaagc = d.Token()
	if _gbaagc != nil {
		return _gbaagc
	}
	if _adefe, _bbbbf := _ffaee.(_g.EndElement); _bbbbf && _adefe.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ffaee)
}

// Validate validates the CT_DuotoneEffect and its children
func (_cdcgg *CT_DuotoneEffect) Validate() error { return _cdcgg.ValidateWithPath("CT_DuotoneEffect") }

type CT_TintEffect struct {
	HueAttr *int32
	AmtAttr *ST_FixedPercentage
}

func (_cdccfg *ST_LineEndType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dddg, _fbgfb := d.Token()
	if _fbgfb != nil {
		return _fbgfb
	}
	if _deebg, _cfedfg := _dddg.(_g.EndElement); _cfedfg && _deebg.Name == start.Name {
		*_cdccfg = 1
		return nil
	}
	if _ebgbe, _cagae := _dddg.(_g.CharData); !_cagae {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dddg)
	} else {
		switch string(_ebgbe) {
		case "":
			*_cdccfg = 0
		case "none":
			*_cdccfg = 1
		case "triangle":
			*_cdccfg = 2
		case "stealth":
			*_cdccfg = 3
		case "diamond":
			*_cdccfg = 4
		case "oval":
			*_cdccfg = 5
		case "arrow":
			*_cdccfg = 6
		}
	}
	_dddg, _fbgfb = d.Token()
	if _fbgfb != nil {
		return _fbgfb
	}
	if _dbcbc, _bfcba := _dddg.(_g.EndElement); _bfcba && _dbcbc.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dddg)
}
func NewCT_TableStyleTextStyle() *CT_TableStyleTextStyle {
	_ffebd := &CT_TableStyleTextStyle{}
	return _ffebd
}
func (_ffebb *CT_Point2D) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "x"}, Value: _dcf.Sprintf("\u0025v", _ffebb.XAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "y"}, Value: _dcf.Sprintf("\u0025v", _ffebb.YAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_acgedd *EG_TextRun) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_effda:
	for {
		_bbedb, _baebf := d.Token()
		if _baebf != nil {
			return _baebf
		}
		switch _eeafad := _bbedb.(type) {
		case _g.StartElement:
			switch _eeafad.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "r"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "r"}:
				_acgedd.R = NewCT_RegularTextRun()
				if _afdba := d.DecodeElement(_acgedd.R, &_eeafad); _afdba != nil {
					return _afdba
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "br"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "br"}:
				_acgedd.Br = NewCT_TextLineBreak()
				if _dccgg := d.DecodeElement(_acgedd.Br, &_eeafad); _dccgg != nil {
					return _dccgg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fld"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fld"}:
				_acgedd.Fld = NewCT_TextField()
				if _cbbda := d.DecodeElement(_acgedd.Fld, &_eeafad); _cbbda != nil {
					return _cbbda
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020EG_TextRun\u0020\u0025v", _eeafad.Name)
				if _cddbd := d.Skip(); _cddbd != nil {
					return _cddbd
				}
			}
		case _g.EndElement:
			break _effda
		case _g.CharData:
		}
	}
	return nil
}
func (_agfgc *CT_TextFont) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "typeface"}, Value: _dcf.Sprintf("\u0025v", _agfgc.TypefaceAttr)})
	if _agfgc.PanoseAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "panose"}, Value: _dcf.Sprintf("\u0025v", *_agfgc.PanoseAttr)})
	}
	if _agfgc.PitchFamilyAttr != ST_PitchFamilyUnset {
		_bfab, _facaf := _agfgc.PitchFamilyAttr.MarshalXMLAttr(_g.Name{Local: "pitchFamily"})
		if _facaf != nil {
			return _facaf
		}
		start.Attr = append(start.Attr, _bfab)
	}
	if _agfgc.CharsetAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "charset"}, Value: _dcf.Sprintf("\u0025v", *_agfgc.CharsetAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_TextBulletColorFollowText() *CT_TextBulletColorFollowText {
	_dedf := &CT_TextBulletColorFollowText{}
	return _dedf
}

type CT_TransformEffect struct {
	SxAttr *ST_Percentage
	SyAttr *ST_Percentage
	KxAttr *int32
	KyAttr *int32
	TxAttr *ST_Coordinate
	TyAttr *ST_Coordinate
}

func NewCT_PresetColor() *CT_PresetColor {
	_fcgcd := &CT_PresetColor{}
	_fcgcd.ValAttr = ST_PresetColorVal(1)
	return _fcgcd
}
func (_adcd *CT_EffectStyleItem) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_dbba:
	for {
		_aegag, _gdeb := d.Token()
		if _gdeb != nil {
			return _gdeb
		}
		switch _cabcf := _aegag.(type) {
		case _g.StartElement:
			switch _cabcf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectLst"}:
				_adcd.EffectLst = NewCT_EffectList()
				if _cfacf := d.DecodeElement(_adcd.EffectLst, &_cabcf); _cfacf != nil {
					return _cfacf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectDag"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectDag"}:
				_adcd.EffectDag = NewCT_EffectContainer()
				if _bfefa := d.DecodeElement(_adcd.EffectDag, &_cabcf); _bfefa != nil {
					return _bfefa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scene3d"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scene3d"}:
				_adcd.Scene3d = NewCT_Scene3D()
				if _bbbcf := d.DecodeElement(_adcd.Scene3d, &_cabcf); _bbbcf != nil {
					return _bbbcf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sp3d"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sp3d"}:
				_adcd.Sp3d = NewCT_Shape3D()
				if _dceb := d.DecodeElement(_adcd.Sp3d, &_cabcf); _dceb != nil {
					return _dceb
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_EffectStyleItem\u0020\u0025v", _cabcf.Name)
				if _cbbca := d.Skip(); _cbbca != nil {
					return _cbbca
				}
			}
		case _g.EndElement:
			break _dbba
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_GvmlGroupShapeNonVisual() *CT_GvmlGroupShapeNonVisual {
	_afgfdc := &CT_GvmlGroupShapeNonVisual{}
	_afgfdc.CNvPr = NewCT_NonVisualDrawingProps()
	_afgfdc.CNvGrpSpPr = NewCT_NonVisualGroupDrawingShapeProps()
	return _afgfdc
}
func (_cfabg *CT_TextBulletTypefaceFollowText) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_TextParagraphProperties() *CT_TextParagraphProperties {
	_edcdf := &CT_TextParagraphProperties{}
	return _edcdf
}

type ST_TextShapeType byte

// ValidateWithPath validates the CT_Backdrop and its children, prefixing error messages with path
func (_aebe *CT_Backdrop) ValidateWithPath(path string) error {
	if _adbf := _aebe.Anchor.ValidateWithPath(path + "\u002fAnchor"); _adbf != nil {
		return _adbf
	}
	if _faaf := _aebe.Norm.ValidateWithPath(path + "\u002fNorm"); _faaf != nil {
		return _faaf
	}
	if _fgd := _aebe.Up.ValidateWithPath(path + "\u002fUp"); _fgd != nil {
		return _fgd
	}
	if _aebe.ExtLst != nil {
		if _decg := _aebe.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _decg != nil {
			return _decg
		}
	}
	return nil
}
func NewCT_TableProperties() *CT_TableProperties { _badc := &CT_TableProperties{}; return _badc }

type ST_PresetCameraType byte

func (_fefcg *CT_EmbeddedWAVAudioFile) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _efbgc := range start.Attr {
		if _efbgc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _efbgc.Name.Local == "embed" || _efbgc.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _efbgc.Name.Local == "embed" {
			_bbca, _gfeg := _efbgc.Value, error(nil)
			if _gfeg != nil {
				return _gfeg
			}
			_fefcg.EmbedAttr = _bbca
			continue
		}
		if _efbgc.Name.Local == "name" {
			_cbfb, _acfe := _efbgc.Value, error(nil)
			if _acfe != nil {
				return _acfe
			}
			_fefcg.NameAttr = &_cbfb
			continue
		}
	}
	for {
		_ccad, _adge := d.Token()
		if _adge != nil {
			return _dcf.Errorf("parsing CT_EmbeddedWAVAudioFile:\u0020%s", _adge)
		}
		if _acbe, _agffe := _ccad.(_g.EndElement); _agffe && _acbe.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_DashStopList and its children, prefixing error messages with path
func (_gfgg *CT_DashStopList) ValidateWithPath(path string) error {
	for _dadec, _eecbb := range _gfgg.Ds {
		if _ebga := _eecbb.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fDs\u005b\u0025d]", path, _dadec)); _ebga != nil {
			return _ebga
		}
	}
	return nil
}
func NewEG_TextUnderlineLine() *EG_TextUnderlineLine {
	_gafda := &EG_TextUnderlineLine{}
	return _gafda
}

// ValidateWithPath validates the CT_TableRow and its children, prefixing error messages with path
func (_abaf *CT_TableRow) ValidateWithPath(path string) error {
	if _ddgc := _abaf.HAttr.ValidateWithPath(path + "\u002fHAttr"); _ddgc != nil {
		return _ddgc
	}
	for _cdcba, _cfdeaa := range _abaf.Tc {
		if _eafcg := _cfdeaa.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fTc\u005b\u0025d]", path, _cdcba)); _eafcg != nil {
			return _eafcg
		}
	}
	if _abaf.ExtLst != nil {
		if _aaff := _abaf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _aaff != nil {
			return _aaff
		}
	}
	return nil
}
func (_cfdge *CT_TextBulletSizePoint) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cfdge.ValAttr = 100
	for _, _ecbee := range start.Attr {
		if _ecbee.Name.Local == "val" {
			_efcca, _fcagb := _e.ParseInt(_ecbee.Value, 10, 32)
			if _fcagb != nil {
				return _fcagb
			}
			_cfdge.ValAttr = int32(_efcca)
			continue
		}
	}
	for {
		_eddfd, _gbaf := d.Token()
		if _gbaf != nil {
			return _dcf.Errorf("parsing\u0020CT_TextBulletSizePoint:\u0020\u0025s", _gbaf)
		}
		if _ggeec, _bdbfc := _eddfd.(_g.EndElement); _bdbfc && _ggeec.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TableStyleCellStyle and its children, prefixing error messages with path
func (_feaeg *CT_TableStyleCellStyle) ValidateWithPath(path string) error {
	if _feaeg.TcBdr != nil {
		if _bbgaf := _feaeg.TcBdr.ValidateWithPath(path + "\u002fTcBdr"); _bbgaf != nil {
			return _bbgaf
		}
	}
	if _feaeg.Fill != nil {
		if _gdabg := _feaeg.Fill.ValidateWithPath(path + "\u002fFill"); _gdabg != nil {
			return _gdabg
		}
	}
	if _feaeg.FillRef != nil {
		if _ggeac := _feaeg.FillRef.ValidateWithPath(path + "\u002fFillRef"); _ggeac != nil {
			return _ggeac
		}
	}
	if _feaeg.Cell3D != nil {
		if _dbdec := _feaeg.Cell3D.ValidateWithPath(path + "\u002fCell3D"); _dbdec != nil {
			return _dbdec
		}
	}
	return nil
}
func NewCT_TextBulletSizePercent() *CT_TextBulletSizePercent {
	_aagde := &CT_TextBulletSizePercent{}
	_aagde.ValAttr = "100\u0025"
	return _aagde
}

// Validate validates the CT_GvmlGroupShape and its children
func (_deeae *CT_GvmlGroupShape) Validate() error {
	return _deeae.ValidateWithPath("CT_GvmlGroupShape")
}
func NewCT_Bevel() *CT_Bevel { _ddfc := &CT_Bevel{}; return _ddfc }
func NewCT_BackgroundFillStyleList() *CT_BackgroundFillStyleList {
	_egf := &CT_BackgroundFillStyleList{}
	return _egf
}
func (_eggff *CT_GvmlGraphicalObjectFrame) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_cfeda := _g.StartElement{Name: _g.Name{Local: "a:nvGraphicFramePr"}}
	e.EncodeElement(_eggff.NvGraphicFramePr, _cfeda)
	_dddea := _g.StartElement{Name: _g.Name{Local: "a:graphic"}}
	_dddea.Attr = append(_dddea.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	e.EncodeElement(_eggff.Graphic, _dddea)
	_gbeab := _g.StartElement{Name: _g.Name{Local: "a:xfrm"}}
	e.EncodeElement(_eggff.Xfrm, _gbeab)
	if _eggff.ExtLst != nil {
		_adaff := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_eggff.ExtLst, _adaff)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_Point2D() *CT_Point2D { _cagad := &CT_Point2D{}; return _cagad }
func (_efeee ST_PitchFamily) ValidateWithPath(path string) error {
	switch _efeee {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_efeee))
	}
	return nil
}
func (_fbfcba ST_AnimationDgmBuildType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _fbfcba.ST_AnimationBuildType != ST_AnimationBuildTypeUnset {
		e.EncodeToken(_g.CharData(_fbfcba.ST_AnimationBuildType.String()))
	}
	if _fbfcba.ST_AnimationDgmOnlyBuildType != ST_AnimationDgmOnlyBuildTypeUnset {
		e.EncodeToken(_g.CharData(_fbfcba.ST_AnimationDgmOnlyBuildType.String()))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

// Validate validates the CT_ReflectionEffect and its children
func (_aecd *CT_ReflectionEffect) Validate() error {
	return _aecd.ValidateWithPath("CT_ReflectionEffect")
}

// ValidateWithPath validates the CT_AlphaBiLevelEffect and its children, prefixing error messages with path
func (_fag *CT_AlphaBiLevelEffect) ValidateWithPath(path string) error {
	if _acb := _fag.ThreshAttr.ValidateWithPath(path + "/ThreshAttr"); _acb != nil {
		return _acb
	}
	return nil
}

// ST_AdjAngle is a union type
type ST_AdjAngle struct {
	ST_Angle         *int32
	ST_GeomGuideName *string
}

const (
	ST_LineEndLengthUnset ST_LineEndLength = 0
	ST_LineEndLengthSm    ST_LineEndLength = 1
	ST_LineEndLengthMed   ST_LineEndLength = 2
	ST_LineEndLengthLg    ST_LineEndLength = 3
)

func (_bbgfb ST_AnimationChartOnlyBuildType) ValidateWithPath(path string) error {
	switch _bbgfb {
	case 0, 1, 2, 3, 4:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bbgfb))
	}
	return nil
}
func (_fagfb ST_PresetCameraType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_agfegf := _g.Attr{}
	_agfegf.Name = name
	switch _fagfb {
	case ST_PresetCameraTypeUnset:
		_agfegf.Value = ""
	case ST_PresetCameraTypeLegacyObliqueTopLeft:
		_agfegf.Value = "legacyObliqueTopLeft"
	case ST_PresetCameraTypeLegacyObliqueTop:
		_agfegf.Value = "legacyObliqueTop"
	case ST_PresetCameraTypeLegacyObliqueTopRight:
		_agfegf.Value = "legacyObliqueTopRight"
	case ST_PresetCameraTypeLegacyObliqueLeft:
		_agfegf.Value = "legacyObliqueLeft"
	case ST_PresetCameraTypeLegacyObliqueFront:
		_agfegf.Value = "legacyObliqueFront"
	case ST_PresetCameraTypeLegacyObliqueRight:
		_agfegf.Value = "legacyObliqueRight"
	case ST_PresetCameraTypeLegacyObliqueBottomLeft:
		_agfegf.Value = "legacyObliqueBottomLeft"
	case ST_PresetCameraTypeLegacyObliqueBottom:
		_agfegf.Value = "legacyObliqueBottom"
	case ST_PresetCameraTypeLegacyObliqueBottomRight:
		_agfegf.Value = "legacyObliqueBottomRight"
	case ST_PresetCameraTypeLegacyPerspectiveTopLeft:
		_agfegf.Value = "legacyPerspectiveTopLeft"
	case ST_PresetCameraTypeLegacyPerspectiveTop:
		_agfegf.Value = "legacyPerspectiveTop"
	case ST_PresetCameraTypeLegacyPerspectiveTopRight:
		_agfegf.Value = "legacyPerspectiveTopRight"
	case ST_PresetCameraTypeLegacyPerspectiveLeft:
		_agfegf.Value = "legacyPerspectiveLeft"
	case ST_PresetCameraTypeLegacyPerspectiveFront:
		_agfegf.Value = "legacyPerspectiveFront"
	case ST_PresetCameraTypeLegacyPerspectiveRight:
		_agfegf.Value = "legacyPerspectiveRight"
	case ST_PresetCameraTypeLegacyPerspectiveBottomLeft:
		_agfegf.Value = "legacyPerspectiveBottomLeft"
	case ST_PresetCameraTypeLegacyPerspectiveBottom:
		_agfegf.Value = "legacyPerspectiveBottom"
	case ST_PresetCameraTypeLegacyPerspectiveBottomRight:
		_agfegf.Value = "legacyPerspectiveBottomRight"
	case ST_PresetCameraTypeOrthographicFront:
		_agfegf.Value = "orthographicFront"
	case ST_PresetCameraTypeIsometricTopUp:
		_agfegf.Value = "isometricTopUp"
	case ST_PresetCameraTypeIsometricTopDown:
		_agfegf.Value = "isometricTopDown"
	case ST_PresetCameraTypeIsometricBottomUp:
		_agfegf.Value = "isometricBottomUp"
	case ST_PresetCameraTypeIsometricBottomDown:
		_agfegf.Value = "isometricBottomDown"
	case ST_PresetCameraTypeIsometricLeftUp:
		_agfegf.Value = "isometricLeftUp"
	case ST_PresetCameraTypeIsometricLeftDown:
		_agfegf.Value = "isometricLeftDown"
	case ST_PresetCameraTypeIsometricRightUp:
		_agfegf.Value = "isometricRightUp"
	case ST_PresetCameraTypeIsometricRightDown:
		_agfegf.Value = "isometricRightDown"
	case ST_PresetCameraTypeIsometricOffAxis1Left:
		_agfegf.Value = "isometricOffAxis1Left"
	case ST_PresetCameraTypeIsometricOffAxis1Right:
		_agfegf.Value = "isometricOffAxis1Right"
	case ST_PresetCameraTypeIsometricOffAxis1Top:
		_agfegf.Value = "isometricOffAxis1Top"
	case ST_PresetCameraTypeIsometricOffAxis2Left:
		_agfegf.Value = "isometricOffAxis2Left"
	case ST_PresetCameraTypeIsometricOffAxis2Right:
		_agfegf.Value = "isometricOffAxis2Right"
	case ST_PresetCameraTypeIsometricOffAxis2Top:
		_agfegf.Value = "isometricOffAxis2Top"
	case ST_PresetCameraTypeIsometricOffAxis3Left:
		_agfegf.Value = "isometricOffAxis3Left"
	case ST_PresetCameraTypeIsometricOffAxis3Right:
		_agfegf.Value = "isometricOffAxis3Right"
	case ST_PresetCameraTypeIsometricOffAxis3Bottom:
		_agfegf.Value = "isometricOffAxis3Bottom"
	case ST_PresetCameraTypeIsometricOffAxis4Left:
		_agfegf.Value = "isometricOffAxis4Left"
	case ST_PresetCameraTypeIsometricOffAxis4Right:
		_agfegf.Value = "isometricOffAxis4Right"
	case ST_PresetCameraTypeIsometricOffAxis4Bottom:
		_agfegf.Value = "isometricOffAxis4Bottom"
	case ST_PresetCameraTypeObliqueTopLeft:
		_agfegf.Value = "obliqueTopLeft"
	case ST_PresetCameraTypeObliqueTop:
		_agfegf.Value = "obliqueTop"
	case ST_PresetCameraTypeObliqueTopRight:
		_agfegf.Value = "obliqueTopRight"
	case ST_PresetCameraTypeObliqueLeft:
		_agfegf.Value = "obliqueLeft"
	case ST_PresetCameraTypeObliqueRight:
		_agfegf.Value = "obliqueRight"
	case ST_PresetCameraTypeObliqueBottomLeft:
		_agfegf.Value = "obliqueBottomLeft"
	case ST_PresetCameraTypeObliqueBottom:
		_agfegf.Value = "obliqueBottom"
	case ST_PresetCameraTypeObliqueBottomRight:
		_agfegf.Value = "obliqueBottomRight"
	case ST_PresetCameraTypePerspectiveFront:
		_agfegf.Value = "perspectiveFront"
	case ST_PresetCameraTypePerspectiveLeft:
		_agfegf.Value = "perspectiveLeft"
	case ST_PresetCameraTypePerspectiveRight:
		_agfegf.Value = "perspectiveRight"
	case ST_PresetCameraTypePerspectiveAbove:
		_agfegf.Value = "perspectiveAbove"
	case ST_PresetCameraTypePerspectiveBelow:
		_agfegf.Value = "perspectiveBelow"
	case ST_PresetCameraTypePerspectiveAboveLeftFacing:
		_agfegf.Value = "perspectiveAboveLeftFacing"
	case ST_PresetCameraTypePerspectiveAboveRightFacing:
		_agfegf.Value = "perspectiveAboveRightFacing"
	case ST_PresetCameraTypePerspectiveContrastingLeftFacing:
		_agfegf.Value = "perspectiveContrastingLeftFacing"
	case ST_PresetCameraTypePerspectiveContrastingRightFacing:
		_agfegf.Value = "perspectiveContrastingRightFacing"
	case ST_PresetCameraTypePerspectiveHeroicLeftFacing:
		_agfegf.Value = "perspectiveHeroicLeftFacing"
	case ST_PresetCameraTypePerspectiveHeroicRightFacing:
		_agfegf.Value = "perspectiveHeroicRightFacing"
	case ST_PresetCameraTypePerspectiveHeroicExtremeLeftFacing:
		_agfegf.Value = "perspectiveHeroicExtremeLeftFacing"
	case ST_PresetCameraTypePerspectiveHeroicExtremeRightFacing:
		_agfegf.Value = "perspectiveHeroicExtremeRightFacing"
	case ST_PresetCameraTypePerspectiveRelaxed:
		_agfegf.Value = "perspectiveRelaxed"
	case ST_PresetCameraTypePerspectiveRelaxedModerately:
		_agfegf.Value = "perspectiveRelaxedModerately"
	}
	return _agfegf, nil
}

// ValidateWithPath validates the CT_EffectList and its children, prefixing error messages with path
func (_bcbe *CT_EffectList) ValidateWithPath(path string) error {
	if _bcbe.Blur != nil {
		if _dbde := _bcbe.Blur.ValidateWithPath(path + "\u002fBlur"); _dbde != nil {
			return _dbde
		}
	}
	if _bcbe.FillOverlay != nil {
		if _aaab := _bcbe.FillOverlay.ValidateWithPath(path + "\u002fFillOverlay"); _aaab != nil {
			return _aaab
		}
	}
	if _bcbe.Glow != nil {
		if _fcbgd := _bcbe.Glow.ValidateWithPath(path + "\u002fGlow"); _fcbgd != nil {
			return _fcbgd
		}
	}
	if _bcbe.InnerShdw != nil {
		if _ebca := _bcbe.InnerShdw.ValidateWithPath(path + "\u002fInnerShdw"); _ebca != nil {
			return _ebca
		}
	}
	if _bcbe.OuterShdw != nil {
		if _egdeb := _bcbe.OuterShdw.ValidateWithPath(path + "\u002fOuterShdw"); _egdeb != nil {
			return _egdeb
		}
	}
	if _bcbe.PrstShdw != nil {
		if _cacec := _bcbe.PrstShdw.ValidateWithPath(path + "\u002fPrstShdw"); _cacec != nil {
			return _cacec
		}
	}
	if _bcbe.Reflection != nil {
		if _agbb := _bcbe.Reflection.ValidateWithPath(path + "/Reflection"); _agbb != nil {
			return _agbb
		}
	}
	if _bcbe.SoftEdge != nil {
		if _bbebe := _bcbe.SoftEdge.ValidateWithPath(path + "\u002fSoftEdge"); _bbebe != nil {
			return _bbebe
		}
	}
	return nil
}
func NewCT_TableStyleCellStyle() *CT_TableStyleCellStyle {
	_abdab := &CT_TableStyleCellStyle{}
	return _abdab
}
func (_edcfd *CT_TextBulletSizePoint) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "val"}, Value: _dcf.Sprintf("\u0025v", _edcfd.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Path2DCubicBezierTo and its children, prefixing error messages with path
func (_fafge *CT_Path2DCubicBezierTo) ValidateWithPath(path string) error {
	for _gbabeg, _faead := range _fafge.Pt {
		if _aagd := _faead.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fPt\u005b\u0025d]", path, _gbabeg)); _aagd != nil {
			return _aagd
		}
	}
	return nil
}

type CT_NonVisualContentPartProperties struct {
	IsCommentAttr *bool
	CpLocks       *CT_ContentPartLocking
	ExtLst        *CT_OfficeArtExtensionList
}

func (_gdbf *CT_AudioCD) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_dfd := _g.StartElement{Name: _g.Name{Local: "a:st"}}
	e.EncodeElement(_gdbf.St, _dfd)
	_aeac := _g.StartElement{Name: _g.Name{Local: "a:end"}}
	e.EncodeElement(_gdbf.End, _aeac)
	if _gdbf.ExtLst != nil {
		_bab := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_gdbf.ExtLst, _bab)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the EG_Text3D and its children
func (_ffagbg *EG_Text3D) Validate() error { return _ffagbg.ValidateWithPath("EG_Text3D") }
func (_cdeg *CT_Path2DArcTo) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _agbfec := range start.Attr {
		if _agbfec.Name.Local == "wR" {
			_fccg, _bfdga := ParseUnionST_AdjCoordinate(_agbfec.Value)
			if _bfdga != nil {
				return _bfdga
			}
			_cdeg.WRAttr = _fccg
			continue
		}
		if _agbfec.Name.Local == "hR" {
			_cbabc, _bgefb := ParseUnionST_AdjCoordinate(_agbfec.Value)
			if _bgefb != nil {
				return _bgefb
			}
			_cdeg.HRAttr = _cbabc
			continue
		}
		if _agbfec.Name.Local == "stAng" {
			_ffccb, _agebd := ParseUnionST_AdjAngle(_agbfec.Value)
			if _agebd != nil {
				return _agebd
			}
			_cdeg.StAngAttr = _ffccb
			continue
		}
		if _agbfec.Name.Local == "swAng" {
			_fbgaa, _becab := ParseUnionST_AdjAngle(_agbfec.Value)
			if _becab != nil {
				return _becab
			}
			_cdeg.SwAngAttr = _fbgaa
			continue
		}
	}
	for {
		_gbeea, _bcaad := d.Token()
		if _bcaad != nil {
			return _dcf.Errorf("parsing\u0020CT_Path2DArcTo:\u0020\u0025s", _bcaad)
		}
		if _ddadb, _fdefb := _gbeea.(_g.EndElement); _fdefb && _ddadb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cffcf *ST_TextBulletSize) Validate() error { return _cffcf.ValidateWithPath("") }

// Validate validates the CT_GvmlShape and its children
func (_ageebf *CT_GvmlShape) Validate() error { return _ageebf.ValidateWithPath("CT_GvmlShape") }
func (_fcga *CT_AnimationDgmElement) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ggcf := range start.Attr {
		if _ggcf.Name.Local == "id" {
			_dbec, _fgc := _ggcf.Value, error(nil)
			if _fgc != nil {
				return _fgc
			}
			_fcga.IdAttr = &_dbec
			continue
		}
		if _ggcf.Name.Local == "bldStep" {
			_fcga.BldStepAttr.UnmarshalXMLAttr(_ggcf)
			continue
		}
	}
	for {
		_dedc, _acgf := d.Token()
		if _acgf != nil {
			return _dcf.Errorf("parsing\u0020CT_AnimationDgmElement:\u0020\u0025s", _acgf)
		}
		if _abce, _eac := _dedc.(_g.EndElement); _eac && _abce.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bgegd ST_ColorSchemeIndex) Validate() error { return _bgegd.ValidateWithPath("") }

type EG_Geometry struct {
	CustGeom *CT_CustomGeometry2D
	PrstGeom *CT_PresetGeometry2D
}
type CT_FillOverlayEffect struct {
	BlendAttr ST_BlendMode
	NoFill    *CT_NoFillProperties
	SolidFill *CT_SolidColorFillProperties
	GradFill  *CT_GradientFillProperties
	BlipFill  *CT_BlipFillProperties
	PattFill  *CT_PatternFillProperties
	GrpFill   *CT_GroupFillProperties
}

// ValidateWithPath validates the CT_LuminanceEffect and its children, prefixing error messages with path
func (_baag *CT_LuminanceEffect) ValidateWithPath(path string) error {
	if _baag.BrightAttr != nil {
		if _bagea := _baag.BrightAttr.ValidateWithPath(path + "/BrightAttr"); _bagea != nil {
			return _bagea
		}
	}
	if _baag.ContrastAttr != nil {
		if _ggcga := _baag.ContrastAttr.ValidateWithPath(path + "\u002fContrastAttr"); _ggcga != nil {
			return _ggcga
		}
	}
	return nil
}
func (_bececa ST_TextShapeType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_fdgdd := _g.Attr{}
	_fdgdd.Name = name
	switch _bececa {
	case ST_TextShapeTypeUnset:
		_fdgdd.Value = ""
	case ST_TextShapeTypeTextNoShape:
		_fdgdd.Value = "textNoShape"
	case ST_TextShapeTypeTextPlain:
		_fdgdd.Value = "textPlain"
	case ST_TextShapeTypeTextStop:
		_fdgdd.Value = "textStop"
	case ST_TextShapeTypeTextTriangle:
		_fdgdd.Value = "textTriangle"
	case ST_TextShapeTypeTextTriangleInverted:
		_fdgdd.Value = "textTriangleInverted"
	case ST_TextShapeTypeTextChevron:
		_fdgdd.Value = "textChevron"
	case ST_TextShapeTypeTextChevronInverted:
		_fdgdd.Value = "textChevronInverted"
	case ST_TextShapeTypeTextRingInside:
		_fdgdd.Value = "textRingInside"
	case ST_TextShapeTypeTextRingOutside:
		_fdgdd.Value = "textRingOutside"
	case ST_TextShapeTypeTextArchUp:
		_fdgdd.Value = "textArchUp"
	case ST_TextShapeTypeTextArchDown:
		_fdgdd.Value = "textArchDown"
	case ST_TextShapeTypeTextCircle:
		_fdgdd.Value = "textCircle"
	case ST_TextShapeTypeTextButton:
		_fdgdd.Value = "textButton"
	case ST_TextShapeTypeTextArchUpPour:
		_fdgdd.Value = "textArchUpPour"
	case ST_TextShapeTypeTextArchDownPour:
		_fdgdd.Value = "textArchDownPour"
	case ST_TextShapeTypeTextCirclePour:
		_fdgdd.Value = "textCirclePour"
	case ST_TextShapeTypeTextButtonPour:
		_fdgdd.Value = "textButtonPour"
	case ST_TextShapeTypeTextCurveUp:
		_fdgdd.Value = "textCurveUp"
	case ST_TextShapeTypeTextCurveDown:
		_fdgdd.Value = "textCurveDown"
	case ST_TextShapeTypeTextCanUp:
		_fdgdd.Value = "textCanUp"
	case ST_TextShapeTypeTextCanDown:
		_fdgdd.Value = "textCanDown"
	case ST_TextShapeTypeTextWave1:
		_fdgdd.Value = "textWave1"
	case ST_TextShapeTypeTextWave2:
		_fdgdd.Value = "textWave2"
	case ST_TextShapeTypeTextDoubleWave1:
		_fdgdd.Value = "textDoubleWave1"
	case ST_TextShapeTypeTextWave4:
		_fdgdd.Value = "textWave4"
	case ST_TextShapeTypeTextInflate:
		_fdgdd.Value = "textInflate"
	case ST_TextShapeTypeTextDeflate:
		_fdgdd.Value = "textDeflate"
	case ST_TextShapeTypeTextInflateBottom:
		_fdgdd.Value = "textInflateBottom"
	case ST_TextShapeTypeTextDeflateBottom:
		_fdgdd.Value = "textDeflateBottom"
	case ST_TextShapeTypeTextInflateTop:
		_fdgdd.Value = "textInflateTop"
	case ST_TextShapeTypeTextDeflateTop:
		_fdgdd.Value = "textDeflateTop"
	case ST_TextShapeTypeTextDeflateInflate:
		_fdgdd.Value = "textDeflateInflate"
	case ST_TextShapeTypeTextDeflateInflateDeflate:
		_fdgdd.Value = "textDeflateInflateDeflate"
	case ST_TextShapeTypeTextFadeRight:
		_fdgdd.Value = "textFadeRight"
	case ST_TextShapeTypeTextFadeLeft:
		_fdgdd.Value = "textFadeLeft"
	case ST_TextShapeTypeTextFadeUp:
		_fdgdd.Value = "textFadeUp"
	case ST_TextShapeTypeTextFadeDown:
		_fdgdd.Value = "textFadeDown"
	case ST_TextShapeTypeTextSlantUp:
		_fdgdd.Value = "textSlantUp"
	case ST_TextShapeTypeTextSlantDown:
		_fdgdd.Value = "textSlantDown"
	case ST_TextShapeTypeTextCascadeUp:
		_fdgdd.Value = "textCascadeUp"
	case ST_TextShapeTypeTextCascadeDown:
		_fdgdd.Value = "textCascadeDown"
	}
	return _fdgdd, nil
}
func (_ebabd ST_TextAutonumberScheme) Validate() error { return _ebabd.ValidateWithPath("") }
func (_ccbffa ST_TextStrikeType) String() string {
	switch _ccbffa {
	case 0:
		return ""
	case 1:
		return "noStrike"
	case 2:
		return "sngStrike"
	case 3:
		return "dblStrike"
	}
	return ""
}
func (_dbgde *CT_GradientFillProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dbgde.FlipAttr != ST_TileFlipModeUnset {
		_gbec, _fgac := _dbgde.FlipAttr.MarshalXMLAttr(_g.Name{Local: "flip"})
		if _fgac != nil {
			return _fgac
		}
		start.Attr = append(start.Attr, _gbec)
	}
	if _dbgde.RotWithShapeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rotWithShape"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dbgde.RotWithShapeAttr))})
	}
	e.EncodeToken(start)
	if _dbgde.GsLst != nil {
		_dfgc := _g.StartElement{Name: _g.Name{Local: "a:gsLst"}}
		e.EncodeElement(_dbgde.GsLst, _dfgc)
	}
	if _dbgde.Lin != nil {
		_dgfaa := _g.StartElement{Name: _g.Name{Local: "a:lin"}}
		e.EncodeElement(_dbgde.Lin, _dgfaa)
	}
	if _dbgde.Path != nil {
		_ecffa := _g.StartElement{Name: _g.Name{Local: "a:path"}}
		e.EncodeElement(_dbgde.Path, _ecffa)
	}
	if _dbgde.TileRect != nil {
		_bcgge := _g.StartElement{Name: _g.Name{Local: "a:tileRect"}}
		e.EncodeElement(_dbgde.TileRect, _bcgge)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TextUnderlineFillGroupWrapper and its children
func (_cceg *CT_TextUnderlineFillGroupWrapper) Validate() error {
	return _cceg.ValidateWithPath("CT_TextUnderlineFillGroupWrapper")
}
func (_ccd *CT_AnimationDgmElement) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _ccd.IdAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "id"}, Value: _dcf.Sprintf("\u0025v", *_ccd.IdAttr)})
	}
	if _ccd.BldStepAttr != ST_DgmBuildStepUnset {
		_cbcb, _cfb := _ccd.BldStepAttr.MarshalXMLAttr(_g.Name{Local: "bldStep"})
		if _cfb != nil {
			return _cfb
		}
		start.Attr = append(start.Attr, _cbcb)
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TableCell and its children
func (_acag *CT_TableCell) Validate() error { return _acag.ValidateWithPath("CT_TableCell") }

type CT_GeomRect struct {
	LAttr ST_AdjCoordinate
	TAttr ST_AdjCoordinate
	RAttr ST_AdjCoordinate
	BAttr ST_AdjCoordinate
}

func (_fdbac ST_BlipCompression) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_fdbac.String(), start)
}
func (_adaaa ST_TextFontAlignType) String() string {
	switch _adaaa {
	case 0:
		return ""
	case 1:
		return "auto"
	case 2:
		return "t"
	case 3:
		return "ctr"
	case 4:
		return "base"
	case 5:
		return "b"
	}
	return ""
}
func NewCT_GvmlPicture() *CT_GvmlPicture {
	_ggeg := &CT_GvmlPicture{}
	_ggeg.NvPicPr = NewCT_GvmlPictureNonVisual()
	_ggeg.BlipFill = NewCT_BlipFillProperties()
	_ggeg.SpPr = NewCT_ShapeProperties()
	return _ggeg
}

type CT_CustomColorList struct{ CustClr []*CT_CustomColor }

func (_feafe *CT_TextUnderlineFillFollowText) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_ggcaf, _bfaf := d.Token()
		if _bfaf != nil {
			return _dcf.Errorf("parsing\u0020CT_TextUnderlineFillFollowText:\u0020\u0025s", _bfaf)
		}
		if _cgdbf, _edcef := _ggcaf.(_g.EndElement); _edcef && _cgdbf.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_DefaultShapeDefinition and its children
func (_cdbcf *CT_DefaultShapeDefinition) Validate() error {
	return _cdbcf.ValidateWithPath("CT_DefaultShapeDefinition")
}
func (_fadbc *CT_TextNormalAutofit) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _cfacb := range start.Attr {
		if _cfacb.Name.Local == "fontScale" {
			_gfadb, _fdbeb := ParseUnionST_TextFontScalePercentOrPercentString(_cfacb.Value)
			if _fdbeb != nil {
				return _fdbeb
			}
			_fadbc.FontScaleAttr = &_gfadb
			continue
		}
		if _cfacb.Name.Local == "lnSpcReduction" {
			_gfbac, _cagef := ParseUnionST_TextSpacingPercentOrPercentString(_cfacb.Value)
			if _cagef != nil {
				return _cagef
			}
			_fadbc.LnSpcReductionAttr = &_gfbac
			continue
		}
	}
	for {
		_gbadc, _cffeb := d.Token()
		if _cffeb != nil {
			return _dcf.Errorf("parsing\u0020CT_TextNormalAutofit:\u0020\u0025s", _cffeb)
		}
		if _acffa, _cdfacd := _gbadc.(_g.EndElement); _cdfacd && _acffa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bggc *CT_BlipChoice) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_ebcc:
	for {
		_dgfb, _geee := d.Token()
		if _geee != nil {
			return _geee
		}
		switch _gaaf := _dgfb.(type) {
		case _g.StartElement:
			switch _gaaf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaBiLevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaBiLevel"}:
				_dade := NewCT_AlphaBiLevelEffect()
				if _gafg := d.DecodeElement(_dade, &_gaaf); _gafg != nil {
					return _gafg
				}
				_bggc.AlphaBiLevel = append(_bggc.AlphaBiLevel, _dade)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaCeiling"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaCeiling"}:
				_aegc := NewCT_AlphaCeilingEffect()
				if _aagg := d.DecodeElement(_aegc, &_gaaf); _aagg != nil {
					return _aagg
				}
				_bggc.AlphaCeiling = append(_bggc.AlphaCeiling, _aegc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaFloor"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaFloor"}:
				_aaa := NewCT_AlphaFloorEffect()
				if _baeg := d.DecodeElement(_aaa, &_gaaf); _baeg != nil {
					return _baeg
				}
				_bggc.AlphaFloor = append(_bggc.AlphaFloor, _aaa)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaInv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaInv"}:
				_dddfb := NewCT_AlphaInverseEffect()
				if _eead := d.DecodeElement(_dddfb, &_gaaf); _eead != nil {
					return _eead
				}
				_bggc.AlphaInv = append(_bggc.AlphaInv, _dddfb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_ceda := NewCT_AlphaModulateEffect()
				if _fea := d.DecodeElement(_ceda, &_gaaf); _fea != nil {
					return _fea
				}
				_bggc.AlphaMod = append(_bggc.AlphaMod, _ceda)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaModFix"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaModFix"}:
				_fgdd := NewCT_AlphaModulateFixedEffect()
				if _dcfg := d.DecodeElement(_fgdd, &_gaaf); _dcfg != nil {
					return _dcfg
				}
				_bggc.AlphaModFix = append(_bggc.AlphaModFix, _fgdd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaRepl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaRepl"}:
				_edec := NewCT_AlphaReplaceEffect()
				if _gcag := d.DecodeElement(_edec, &_gaaf); _gcag != nil {
					return _gcag
				}
				_bggc.AlphaRepl = append(_bggc.AlphaRepl, _edec)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "biLevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "biLevel"}:
				_cdeda := NewCT_BiLevelEffect()
				if _aagc := d.DecodeElement(_cdeda, &_gaaf); _aagc != nil {
					return _aagc
				}
				_bggc.BiLevel = append(_bggc.BiLevel, _cdeda)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blur"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blur"}:
				_fcfc := NewCT_BlurEffect()
				if _cad := d.DecodeElement(_fcfc, &_gaaf); _cad != nil {
					return _cad
				}
				_bggc.Blur = append(_bggc.Blur, _fcfc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrChange"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrChange"}:
				_afbf := NewCT_ColorChangeEffect()
				if _cgbe := d.DecodeElement(_afbf, &_gaaf); _cgbe != nil {
					return _cgbe
				}
				_bggc.ClrChange = append(_bggc.ClrChange, _afbf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrRepl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrRepl"}:
				_aefde := NewCT_ColorReplaceEffect()
				if _acca := d.DecodeElement(_aefde, &_gaaf); _acca != nil {
					return _acca
				}
				_bggc.ClrRepl = append(_bggc.ClrRepl, _aefde)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "duotone"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "duotone"}:
				_fadb := NewCT_DuotoneEffect()
				if _gcdae := d.DecodeElement(_fadb, &_gaaf); _gcdae != nil {
					return _gcdae
				}
				_bggc.Duotone = append(_bggc.Duotone, _fadb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillOverlay"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillOverlay"}:
				_gece := NewCT_FillOverlayEffect()
				if _aceb := d.DecodeElement(_gece, &_gaaf); _aceb != nil {
					return _aceb
				}
				_bggc.FillOverlay = append(_bggc.FillOverlay, _gece)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grayscl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grayscl"}:
				_bgfg := NewCT_GrayscaleEffect()
				if _gdfd := d.DecodeElement(_bgfg, &_gaaf); _gdfd != nil {
					return _gdfd
				}
				_bggc.Grayscl = append(_bggc.Grayscl, _bgfg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hsl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hsl"}:
				_beae := NewCT_HSLEffect()
				if _aeffgd := d.DecodeElement(_beae, &_gaaf); _aeffgd != nil {
					return _aeffgd
				}
				_bggc.Hsl = append(_bggc.Hsl, _beae)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_dbad := NewCT_LuminanceEffect()
				if _acea := d.DecodeElement(_dbad, &_gaaf); _acea != nil {
					return _acea
				}
				_bggc.Lum = append(_bggc.Lum, _dbad)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_ecce := NewCT_TintEffect()
				if _bfc := d.DecodeElement(_ecce, &_gaaf); _bfc != nil {
					return _bfc
				}
				_bggc.Tint = append(_bggc.Tint, _ecce)
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_BlipChoice \u0025v", _gaaf.Name)
				if _bddaf := d.Skip(); _bddaf != nil {
					return _bddaf
				}
			}
		case _g.EndElement:
			break _ebcc
		case _g.CharData:
		}
	}
	return nil
}
func (_afdef *CT_PositivePercentage) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _dbbff := range start.Attr {
		if _dbbff.Name.Local == "val" {
			_fcceb, _agdaa := ParseUnionST_PositivePercentage(_dbbff.Value)
			if _agdaa != nil {
				return _agdaa
			}
			_afdef.ValAttr = _fcceb
			continue
		}
	}
	for {
		_ffcbg, _agafd := d.Token()
		if _agafd != nil {
			return _dcf.Errorf("parsing\u0020CT_PositivePercentage:\u0020\u0025s", _agafd)
		}
		if _gcebe, _fbdaf := _ffcbg.(_g.EndElement); _fbdaf && _gcebe.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_BlurEffect and its children, prefixing error messages with path
func (_ggbg *CT_BlurEffect) ValidateWithPath(path string) error {
	if _ggbg.RadAttr != nil {
		if *_ggbg.RadAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eRadAttr\u0020must\u0020be\u0020\u003e=\u00200\u0020\u0028have\u0020\u0025v\u0029", path, *_ggbg.RadAttr)
		}
		if *_ggbg.RadAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s\u002fm\u002eRadAttr must\u0020be \u003c\u003d\u002027273042316900\u0020\u0028have\u0020%v\u0029", path, *_ggbg.RadAttr)
		}
	}
	return nil
}
func (_abeee *CT_TableStyle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_abeee.StyleIdAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	for _, _abde := range start.Attr {
		if _abde.Name.Local == "styleName" {
			_bgbeaf, _cdgbfb := _abde.Value, error(nil)
			if _cdgbfb != nil {
				return _cdgbfb
			}
			_abeee.StyleNameAttr = _bgbeaf
			continue
		}
		if _abde.Name.Local == "styleId" {
			_acega, _dbabcf := _abde.Value, error(nil)
			if _dbabcf != nil {
				return _dbabcf
			}
			_abeee.StyleIdAttr = _acega
			continue
		}
	}
_dfdf:
	for {
		_feeae, _gfba := d.Token()
		if _gfba != nil {
			return _gfba
		}
		switch _dfcag := _feeae.(type) {
		case _g.StartElement:
			switch _dfcag.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tblBg"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tblBg"}:
				_abeee.TblBg = NewCT_TableBackgroundStyle()
				if _dcegc := d.DecodeElement(_abeee.TblBg, &_dfcag); _dcegc != nil {
					return _dcegc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "wholeTbl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "wholeTbl"}:
				_abeee.WholeTbl = NewCT_TablePartStyle()
				if _cefac := d.DecodeElement(_abeee.WholeTbl, &_dfcag); _cefac != nil {
					return _cefac
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "band1H"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "band1H"}:
				_abeee.Band1H = NewCT_TablePartStyle()
				if _bgbec := d.DecodeElement(_abeee.Band1H, &_dfcag); _bgbec != nil {
					return _bgbec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "band2H"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "band2H"}:
				_abeee.Band2H = NewCT_TablePartStyle()
				if _gcfea := d.DecodeElement(_abeee.Band2H, &_dfcag); _gcfea != nil {
					return _gcfea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "band1V"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "band1V"}:
				_abeee.Band1V = NewCT_TablePartStyle()
				if _cfdbfc := d.DecodeElement(_abeee.Band1V, &_dfcag); _cfdbfc != nil {
					return _cfdbfc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "band2V"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "band2V"}:
				_abeee.Band2V = NewCT_TablePartStyle()
				if _gdafc := d.DecodeElement(_abeee.Band2V, &_dfcag); _gdafc != nil {
					return _gdafc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lastCol"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lastCol"}:
				_abeee.LastCol = NewCT_TablePartStyle()
				if _faeca := d.DecodeElement(_abeee.LastCol, &_dfcag); _faeca != nil {
					return _faeca
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "firstCol"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "firstCol"}:
				_abeee.FirstCol = NewCT_TablePartStyle()
				if _ffbcb := d.DecodeElement(_abeee.FirstCol, &_dfcag); _ffbcb != nil {
					return _ffbcb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lastRow"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lastRow"}:
				_abeee.LastRow = NewCT_TablePartStyle()
				if _deee := d.DecodeElement(_abeee.LastRow, &_dfcag); _deee != nil {
					return _deee
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "seCell"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "seCell"}:
				_abeee.SeCell = NewCT_TablePartStyle()
				if _fbcgg := d.DecodeElement(_abeee.SeCell, &_dfcag); _fbcgg != nil {
					return _fbcgg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "swCell"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "swCell"}:
				_abeee.SwCell = NewCT_TablePartStyle()
				if _aaddfg := d.DecodeElement(_abeee.SwCell, &_dfcag); _aaddfg != nil {
					return _aaddfg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "firstRow"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "firstRow"}:
				_abeee.FirstRow = NewCT_TablePartStyle()
				if _bcgcb := d.DecodeElement(_abeee.FirstRow, &_dfcag); _bcgcb != nil {
					return _bcgcb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "neCell"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "neCell"}:
				_abeee.NeCell = NewCT_TablePartStyle()
				if _gbefcf := d.DecodeElement(_abeee.NeCell, &_dfcag); _gbefcf != nil {
					return _gbefcf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "nwCell"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "nwCell"}:
				_abeee.NwCell = NewCT_TablePartStyle()
				if _cbcce := d.DecodeElement(_abeee.NwCell, &_dfcag); _cbcce != nil {
					return _cbcce
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_abeee.ExtLst = NewCT_OfficeArtExtensionList()
				if _ebfdb := d.DecodeElement(_abeee.ExtLst, &_dfcag); _ebfdb != nil {
					return _ebfdb
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_TableStyle \u0025v", _dfcag.Name)
				if _cedcc := d.Skip(); _cedcc != nil {
					return _cedcc
				}
			}
		case _g.EndElement:
			break _dfdf
		case _g.CharData:
		}
	}
	return nil
}
func (_ffd *CT_AlphaReplaceEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ffce := range start.Attr {
		if _ffce.Name.Local == "a" {
			_bdb, _fgf := ParseUnionST_PositiveFixedPercentage(_ffce.Value)
			if _fgf != nil {
				return _fgf
			}
			_ffd.AAttr = _bdb
			continue
		}
	}
	for {
		_bfg, _bfge := d.Token()
		if _bfge != nil {
			return _dcf.Errorf("parsing\u0020CT_AlphaReplaceEffect:\u0020\u0025s", _bfge)
		}
		if _gab, _efbg := _bfg.(_g.EndElement); _efbg && _gab.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Path2DList() *CT_Path2DList { _eagg := &CT_Path2DList{}; return _eagg }
func (_dffa ST_PresetPatternVal) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_dffa.String(), start)
}
func (_ccbe *CT_TableCell) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _cabeb := range start.Attr {
		if _cabeb.Name.Local == "rowSpan" {
			_gbbcf, _abee := _e.ParseInt(_cabeb.Value, 10, 32)
			if _abee != nil {
				return _abee
			}
			_gedcg := int32(_gbbcf)
			_ccbe.RowSpanAttr = &_gedcg
			continue
		}
		if _cabeb.Name.Local == "gridSpan" {
			_febbg, _gceaf := _e.ParseInt(_cabeb.Value, 10, 32)
			if _gceaf != nil {
				return _gceaf
			}
			_edcb := int32(_febbg)
			_ccbe.GridSpanAttr = &_edcb
			continue
		}
		if _cabeb.Name.Local == "hMerge" {
			_eddag, _cgdef := _e.ParseBool(_cabeb.Value)
			if _cgdef != nil {
				return _cgdef
			}
			_ccbe.HMergeAttr = &_eddag
			continue
		}
		if _cabeb.Name.Local == "vMerge" {
			_caaebe, _fcbde := _e.ParseBool(_cabeb.Value)
			if _fcbde != nil {
				return _fcbde
			}
			_ccbe.VMergeAttr = &_caaebe
			continue
		}
		if _cabeb.Name.Local == "id" {
			_ccec, _ecfag := _cabeb.Value, error(nil)
			if _ecfag != nil {
				return _ecfag
			}
			_ccbe.IdAttr = &_ccec
			continue
		}
	}
_dffcg:
	for {
		_ffeef, _aeaga := d.Token()
		if _aeaga != nil {
			return _aeaga
		}
		switch _gfgf := _ffeef.(type) {
		case _g.StartElement:
			switch _gfgf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "txBody"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "txBody"}:
				_ccbe.TxBody = NewCT_TextBody()
				if _gbad := d.DecodeElement(_ccbe.TxBody, &_gfgf); _gbad != nil {
					return _gbad
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tcPr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tcPr"}:
				_ccbe.TcPr = NewCT_TableCellProperties()
				if _ddcde := d.DecodeElement(_ccbe.TcPr, &_gfgf); _ddcde != nil {
					return _ddcde
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_ccbe.ExtLst = NewCT_OfficeArtExtensionList()
				if _cgggf := d.DecodeElement(_ccbe.ExtLst, &_gfgf); _cgggf != nil {
					return _cgggf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TableCell\u0020\u0025v", _gfgf.Name)
				if _fecfeg := d.Skip(); _fecfeg != nil {
					return _fecfeg
				}
			}
		case _g.EndElement:
			break _dffcg
		case _g.CharData:
		}
	}
	return nil
}
func (_fdaaf *CT_PresetColor) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fdaaf.ValAttr = ST_PresetColorVal(1)
	for _, _gcgbb := range start.Attr {
		if _gcgbb.Name.Local == "val" {
			_fdaaf.ValAttr.UnmarshalXMLAttr(_gcgbb)
			continue
		}
	}
_fdafb:
	for {
		_dffe, _abdbd := d.Token()
		if _abdbd != nil {
			return _abdbd
		}
		switch _adbc := _dffe.(type) {
		case _g.StartElement:
			switch _adbc.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_aggg := NewEG_ColorTransform()
				_aggg.Tint = NewCT_PositiveFixedPercentage()
				if _befbe := d.DecodeElement(_aggg.Tint, &_adbc); _befbe != nil {
					return _befbe
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _aggg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "shade"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "shade"}:
				_dgfffg := NewEG_ColorTransform()
				_dgfffg.Shade = NewCT_PositiveFixedPercentage()
				if _efbbg := d.DecodeElement(_dgfffg.Shade, &_adbc); _efbbg != nil {
					return _efbbg
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _dgfffg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "comp"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "comp"}:
				_ebff := NewEG_ColorTransform()
				_ebff.Comp = NewCT_ComplementTransform()
				if _fbcd := d.DecodeElement(_ebff.Comp, &_adbc); _fbcd != nil {
					return _fbcd
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _ebff)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "inv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "inv"}:
				_bgae := NewEG_ColorTransform()
				_bgae.Inv = NewCT_InverseTransform()
				if _gcgdf := d.DecodeElement(_bgae.Inv, &_adbc); _gcgdf != nil {
					return _gcgdf
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _bgae)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gray"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gray"}:
				_ccba := NewEG_ColorTransform()
				_ccba.Gray = NewCT_GrayscaleTransform()
				if _cdaab := d.DecodeElement(_ccba.Gray, &_adbc); _cdaab != nil {
					return _cdaab
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _ccba)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alpha"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alpha"}:
				_ddcc := NewEG_ColorTransform()
				_ddcc.Alpha = NewCT_PositiveFixedPercentage()
				if _gbgga := d.DecodeElement(_ddcc.Alpha, &_adbc); _gbgga != nil {
					return _gbgga
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _ddcc)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaOff"}:
				_gffb := NewEG_ColorTransform()
				_gffb.AlphaOff = NewCT_FixedPercentage()
				if _gaeeb := d.DecodeElement(_gffb.AlphaOff, &_adbc); _gaeeb != nil {
					return _gaeeb
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _gffb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_aeegf := NewEG_ColorTransform()
				_aeegf.AlphaMod = NewCT_PositivePercentage()
				if _gcadb := d.DecodeElement(_aeegf.AlphaMod, &_adbc); _gcadb != nil {
					return _gcadb
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _aeegf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hue"}:
				_ffcd := NewEG_ColorTransform()
				_ffcd.Hue = NewCT_PositiveFixedAngle()
				if _ggcea := d.DecodeElement(_ffcd.Hue, &_adbc); _ggcea != nil {
					return _ggcea
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _ffcd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueOff"}:
				_cbcge := NewEG_ColorTransform()
				_cbcge.HueOff = NewCT_Angle()
				if _fgcgb := d.DecodeElement(_cbcge.HueOff, &_adbc); _fgcgb != nil {
					return _fgcgb
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _cbcge)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hueMod"}:
				_ecabb := NewEG_ColorTransform()
				_ecabb.HueMod = NewCT_PositivePercentage()
				if _agffd := d.DecodeElement(_ecabb.HueMod, &_adbc); _agffd != nil {
					return _agffd
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _ecabb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sat"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sat"}:
				_ccfbab := NewEG_ColorTransform()
				_ccfbab.Sat = NewCT_Percentage()
				if _beeab := d.DecodeElement(_ccfbab.Sat, &_adbc); _beeab != nil {
					return _beeab
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _ccfbab)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satOff"}:
				_ebad := NewEG_ColorTransform()
				_ebad.SatOff = NewCT_Percentage()
				if _agdgg := d.DecodeElement(_ebad.SatOff, &_adbc); _agdgg != nil {
					return _agdgg
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _ebad)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "satMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "satMod"}:
				_eagbf := NewEG_ColorTransform()
				_eagbf.SatMod = NewCT_Percentage()
				if _debgd := d.DecodeElement(_eagbf.SatMod, &_adbc); _debgd != nil {
					return _debgd
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _eagbf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_bdbaa := NewEG_ColorTransform()
				_bdbaa.Lum = NewCT_Percentage()
				if _fbdbg := d.DecodeElement(_bdbaa.Lum, &_adbc); _fbdbg != nil {
					return _fbdbg
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _bdbaa)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumOff"}:
				_cefaa := NewEG_ColorTransform()
				_cefaa.LumOff = NewCT_Percentage()
				if _cffd := d.DecodeElement(_cefaa.LumOff, &_adbc); _cffd != nil {
					return _cffd
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _cefaa)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lumMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lumMod"}:
				_adcbb := NewEG_ColorTransform()
				_adcbb.LumMod = NewCT_Percentage()
				if _gacde := d.DecodeElement(_adcbb.LumMod, &_adbc); _gacde != nil {
					return _gacde
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _adcbb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "red"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "red"}:
				_bggd := NewEG_ColorTransform()
				_bggd.Red = NewCT_Percentage()
				if _dggde := d.DecodeElement(_bggd.Red, &_adbc); _dggde != nil {
					return _dggde
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _bggd)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redOff"}:
				_aaec := NewEG_ColorTransform()
				_aaec.RedOff = NewCT_Percentage()
				if _decfcb := d.DecodeElement(_aaec.RedOff, &_adbc); _decfcb != nil {
					return _decfcb
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _aaec)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "redMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "redMod"}:
				_egag := NewEG_ColorTransform()
				_egag.RedMod = NewCT_Percentage()
				if _edfcg := d.DecodeElement(_egag.RedMod, &_adbc); _edfcg != nil {
					return _edfcg
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _egag)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "green"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "green"}:
				_ccdaf := NewEG_ColorTransform()
				_ccdaf.Green = NewCT_Percentage()
				if _bccge := d.DecodeElement(_ccdaf.Green, &_adbc); _bccge != nil {
					return _bccge
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _ccdaf)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenOff"}:
				_cfabb := NewEG_ColorTransform()
				_cfabb.GreenOff = NewCT_Percentage()
				if _fbag := d.DecodeElement(_cfabb.GreenOff, &_adbc); _fbag != nil {
					return _fbag
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _cfabb)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "greenMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "greenMod"}:
				_fgcec := NewEG_ColorTransform()
				_fgcec.GreenMod = NewCT_Percentage()
				if _acegc := d.DecodeElement(_fgcec.GreenMod, &_adbc); _acegc != nil {
					return _acegc
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _fgcec)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blue"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blue"}:
				_aaede := NewEG_ColorTransform()
				_aaede.Blue = NewCT_Percentage()
				if _cfccg := d.DecodeElement(_aaede.Blue, &_adbc); _cfccg != nil {
					return _cfccg
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _aaede)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueOff"}:
				_dccda := NewEG_ColorTransform()
				_dccda.BlueOff = NewCT_Percentage()
				if _egcd := d.DecodeElement(_dccda.BlueOff, &_adbc); _egcd != nil {
					return _egcd
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _dccda)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blueMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blueMod"}:
				_cdcfg := NewEG_ColorTransform()
				_cdcfg.BlueMod = NewCT_Percentage()
				if _gfdga := d.DecodeElement(_cdcfg.BlueMod, &_adbc); _gfdga != nil {
					return _gfdga
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _cdcfg)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gamma"}:
				_gcgda := NewEG_ColorTransform()
				_gcgda.Gamma = NewCT_GammaTransform()
				if _gdcab := d.DecodeElement(_gcgda.Gamma, &_adbc); _gdcab != nil {
					return _gdcab
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _gcgda)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "invGamma"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "invGamma"}:
				_ecde := NewEG_ColorTransform()
				_ecde.InvGamma = NewCT_InverseGammaTransform()
				if _cfdbf := d.DecodeElement(_ecde.InvGamma, &_adbc); _cfdbf != nil {
					return _cfdbf
				}
				_fdaaf.EG_ColorTransform = append(_fdaaf.EG_ColorTransform, _ecde)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PresetColor\u0020\u0025v", _adbc.Name)
				if _bcefg := d.Skip(); _bcefg != nil {
					return _bcefg
				}
			}
		case _g.EndElement:
			break _fdafb
		case _g.CharData:
		}
	}
	return nil
}

const (
	ST_BlendModeUnset   ST_BlendMode = 0
	ST_BlendModeOver    ST_BlendMode = 1
	ST_BlendModeMult    ST_BlendMode = 2
	ST_BlendModeScreen  ST_BlendMode = 3
	ST_BlendModeDarken  ST_BlendMode = 4
	ST_BlendModeLighten ST_BlendMode = 5
)

func (_fafea *ST_PenAlignment) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gaadf, _abfec := d.Token()
	if _abfec != nil {
		return _abfec
	}
	if _bgeee, _eafga := _gaadf.(_g.EndElement); _eafga && _bgeee.Name == start.Name {
		*_fafea = 1
		return nil
	}
	if _daadcb, _dfbef := _gaadf.(_g.CharData); !_dfbef {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gaadf)
	} else {
		switch string(_daadcb) {
		case "":
			*_fafea = 0
		case "ctr":
			*_fafea = 1
		case "in":
			*_fafea = 2
		}
	}
	_gaadf, _abfec = d.Token()
	if _abfec != nil {
		return _abfec
	}
	if _gafcg, _fbfeg := _gaadf.(_g.EndElement); _fbfeg && _gafcg.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gaadf)
}

// Validate validates the CT_ColorMapping and its children
func (_edeg *CT_ColorMapping) Validate() error { return _edeg.ValidateWithPath("CT_ColorMapping") }
func (_adfec ST_PresetLineDashVal) String() string {
	switch _adfec {
	case 0:
		return ""
	case 1:
		return "solid"
	case 2:
		return "dot"
	case 3:
		return "dash"
	case 4:
		return "lgDash"
	case 5:
		return "dashDot"
	case 6:
		return "lgDashDot"
	case 7:
		return "lgDashDotDot"
	case 8:
		return "sysDash"
	case 9:
		return "sysDot"
	case 10:
		return "sysDashDot"
	case 11:
		return "sysDashDotDot"
	}
	return ""
}
func (_dbabc *CT_PositiveFixedPercentage) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _baecfg := range start.Attr {
		if _baecfg.Name.Local == "val" {
			_babgd, _gfbgd := ParseUnionST_PositiveFixedPercentage(_baecfg.Value)
			if _gfbgd != nil {
				return _gfbgd
			}
			_dbabc.ValAttr = _babgd
			continue
		}
	}
	for {
		_agebg, _bagfag := d.Token()
		if _bagfag != nil {
			return _dcf.Errorf("parsing\u0020CT_PositiveFixedPercentage:\u0020\u0025s", _bagfag)
		}
		if _daab, _cbbac := _agebg.(_g.EndElement); _cbbac && _daab.Name == start.Name {
			break
		}
	}
	return nil
}

type ST_LineEndType byte
type CT_ContentPartLocking struct {
	ExtLst                 *CT_OfficeArtExtensionList
	NoGrpAttr              *bool
	NoSelectAttr           *bool
	NoRotAttr              *bool
	NoChangeAspectAttr     *bool
	NoMoveAttr             *bool
	NoResizeAttr           *bool
	NoEditPointsAttr       *bool
	NoAdjustHandlesAttr    *bool
	NoChangeArrowheadsAttr *bool
	NoChangeShapeTypeAttr  *bool
}

func NewEG_LineFillProperties() *EG_LineFillProperties {
	_dbcdf := &EG_LineFillProperties{}
	return _dbcdf
}
func (_fgacf *ST_PenAlignment) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fgacf = 0
	case "ctr":
		*_fgacf = 1
	case "in":
		*_fgacf = 2
	}
	return nil
}
func NewCT_AlphaBiLevelEffect() *CT_AlphaBiLevelEffect { _dgf := &CT_AlphaBiLevelEffect{}; return _dgf }

// Validate validates the CT_AnimationDgmBuildProperties and its children
func (_cfc *CT_AnimationDgmBuildProperties) Validate() error {
	return _cfc.ValidateWithPath("CT_AnimationDgmBuildProperties")
}
func (_cgff *CT_PresetTextShape) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_edbg, _gddcf := _cgff.PrstAttr.MarshalXMLAttr(_g.Name{Local: "prst"})
	if _gddcf != nil {
		return _gddcf
	}
	start.Attr = append(start.Attr, _edbg)
	e.EncodeToken(start)
	if _cgff.AvLst != nil {
		_fagba := _g.StartElement{Name: _g.Name{Local: "a:avLst"}}
		e.EncodeElement(_cgff.AvLst, _fagba)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type ST_PresetColorVal byte

func NewCT_TextUnderlineLineFollowText() *CT_TextUnderlineLineFollowText {
	_deedg := &CT_TextUnderlineLineFollowText{}
	return _deedg
}
func (_eded *CT_PictureLocking) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _acbcc := range start.Attr {
		if _acbcc.Name.Local == "noCrop" {
			_aaefdf, _ffeaa := _e.ParseBool(_acbcc.Value)
			if _ffeaa != nil {
				return _ffeaa
			}
			_eded.NoCropAttr = &_aaefdf
			continue
		}
		if _acbcc.Name.Local == "noGrp" {
			_eddb, _fgae := _e.ParseBool(_acbcc.Value)
			if _fgae != nil {
				return _fgae
			}
			_eded.NoGrpAttr = &_eddb
			continue
		}
		if _acbcc.Name.Local == "noSelect" {
			_dfbc, _bbgge := _e.ParseBool(_acbcc.Value)
			if _bbgge != nil {
				return _bbgge
			}
			_eded.NoSelectAttr = &_dfbc
			continue
		}
		if _acbcc.Name.Local == "noRot" {
			_effb, _bagff := _e.ParseBool(_acbcc.Value)
			if _bagff != nil {
				return _bagff
			}
			_eded.NoRotAttr = &_effb
			continue
		}
		if _acbcc.Name.Local == "noChangeAspect" {
			_afcdf, _fdbef := _e.ParseBool(_acbcc.Value)
			if _fdbef != nil {
				return _fdbef
			}
			_eded.NoChangeAspectAttr = &_afcdf
			continue
		}
		if _acbcc.Name.Local == "noMove" {
			_geaaf, _fedaaa := _e.ParseBool(_acbcc.Value)
			if _fedaaa != nil {
				return _fedaaa
			}
			_eded.NoMoveAttr = &_geaaf
			continue
		}
		if _acbcc.Name.Local == "noResize" {
			_efgdg, _gcceg := _e.ParseBool(_acbcc.Value)
			if _gcceg != nil {
				return _gcceg
			}
			_eded.NoResizeAttr = &_efgdg
			continue
		}
		if _acbcc.Name.Local == "noEditPoints" {
			_fdfec, _dgadc := _e.ParseBool(_acbcc.Value)
			if _dgadc != nil {
				return _dgadc
			}
			_eded.NoEditPointsAttr = &_fdfec
			continue
		}
		if _acbcc.Name.Local == "noAdjustHandles" {
			_fgagg, _gbgg := _e.ParseBool(_acbcc.Value)
			if _gbgg != nil {
				return _gbgg
			}
			_eded.NoAdjustHandlesAttr = &_fgagg
			continue
		}
		if _acbcc.Name.Local == "noChangeArrowheads" {
			_ffcbb, _eccda := _e.ParseBool(_acbcc.Value)
			if _eccda != nil {
				return _eccda
			}
			_eded.NoChangeArrowheadsAttr = &_ffcbb
			continue
		}
		if _acbcc.Name.Local == "noChangeShapeType" {
			_afgfg, _egbda := _e.ParseBool(_acbcc.Value)
			if _egbda != nil {
				return _egbda
			}
			_eded.NoChangeShapeTypeAttr = &_afgfg
			continue
		}
	}
_cgecd:
	for {
		_egdc, _afdfg := d.Token()
		if _afdfg != nil {
			return _afdfg
		}
		switch _cafga := _egdc.(type) {
		case _g.StartElement:
			switch _cafga.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_eded.ExtLst = NewCT_OfficeArtExtensionList()
				if _feea := d.DecodeElement(_eded.ExtLst, &_cafga); _feea != nil {
					return _feea
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_PictureLocking\u0020\u0025v", _cafga.Name)
				if _dgfae := d.Skip(); _dgfae != nil {
					return _dgfae
				}
			}
		case _g.EndElement:
			break _cgecd
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_TextCharacterProperties() *CT_TextCharacterProperties {
	_dacga := &CT_TextCharacterProperties{}
	return _dacga
}
func (_agadb ST_EffectContainerType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dcfbcc := _g.Attr{}
	_dcfbcc.Name = name
	switch _agadb {
	case ST_EffectContainerTypeUnset:
		_dcfbcc.Value = ""
	case ST_EffectContainerTypeSib:
		_dcfbcc.Value = "sib"
	case ST_EffectContainerTypeTree:
		_dcfbcc.Value = "tree"
	}
	return _dcfbcc, nil
}
func (_afgcc *CT_TextAutonumberBullet) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_ddgec, _cbegde := _afgcc.TypeAttr.MarshalXMLAttr(_g.Name{Local: "type"})
	if _cbegde != nil {
		return _cbegde
	}
	start.Attr = append(start.Attr, _ddgec)
	if _afgcc.StartAtAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "startAt"}, Value: _dcf.Sprintf("\u0025v", *_afgcc.StartAtAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_SRgbColor and its children, prefixing error messages with path
func (_dcdad *CT_SRgbColor) ValidateWithPath(path string) error {
	for _cgccf, _eegba := range _dcdad.EG_ColorTransform {
		if _bacd := _eegba.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fEG_ColorTransform\u005b\u0025d\u005d", path, _cgccf)); _bacd != nil {
			return _bacd
		}
	}
	return nil
}

// Validate validates the Graphic and its children
func (_cgcfe *Graphic) Validate() error { return _cgcfe.ValidateWithPath("Graphic") }

type CT_EmbeddedWAVAudioFile struct {
	EmbedAttr string
	NameAttr  *string
}

// ValidateWithPath validates the AG_Blob and its children, prefixing error messages with path
func (_bc *AG_Blob) ValidateWithPath(path string) error { return nil }
func (_egfcea ST_LineCap) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_defe := _g.Attr{}
	_defe.Name = name
	switch _egfcea {
	case ST_LineCapUnset:
		_defe.Value = ""
	case ST_LineCapRnd:
		_defe.Value = "rnd"
	case ST_LineCapSq:
		_defe.Value = "sq"
	case ST_LineCapFlat:
		_defe.Value = "flat"
	}
	return _defe, nil
}

type EG_TextBulletColor struct {
	BuClrTx *CT_TextBulletColorFollowText
	BuClr   *CT_Color
}

func (_edffc *ST_LineEndWidth) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cdeeb, _gdde := d.Token()
	if _gdde != nil {
		return _gdde
	}
	if _dbbdc, _bfdaa := _cdeeb.(_g.EndElement); _bfdaa && _dbbdc.Name == start.Name {
		*_edffc = 1
		return nil
	}
	if _geffgb, _afdcd := _cdeeb.(_g.CharData); !_afdcd {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cdeeb)
	} else {
		switch string(_geffgb) {
		case "":
			*_edffc = 0
		case "sm":
			*_edffc = 1
		case "med":
			*_edffc = 2
		case "lg":
			*_edffc = 3
		}
	}
	_cdeeb, _gdde = d.Token()
	if _gdde != nil {
		return _gdde
	}
	if _gabfae, _fdgdde := _cdeeb.(_g.EndElement); _fdgdde && _gabfae.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cdeeb)
}
func (_dcea *CT_DashStop) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _efeff := range start.Attr {
		if _efeff.Name.Local == "d" {
			_dadd, _caeb := ParseUnionST_PositivePercentage(_efeff.Value)
			if _caeb != nil {
				return _caeb
			}
			_dcea.DAttr = _dadd
			continue
		}
		if _efeff.Name.Local == "sp" {
			_afde, _bfgb := ParseUnionST_PositivePercentage(_efeff.Value)
			if _bfgb != nil {
				return _bfgb
			}
			_dcea.SpAttr = _afde
			continue
		}
	}
	for {
		_egae, _fdge := d.Token()
		if _fdge != nil {
			return _dcf.Errorf("parsing\u0020CT_DashStop:\u0020\u0025s", _fdge)
		}
		if _aefe, _fdfdb := _egae.(_g.EndElement); _fdfdb && _aefe.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gedbd ST_TextVerticalType) String() string {
	switch _gedbd {
	case 0:
		return ""
	case 1:
		return "horz"
	case 2:
		return "vert"
	case 3:
		return "vert270"
	case 4:
		return "wordArtVert"
	case 5:
		return "eaVert"
	case 6:
		return "mongolianVert"
	case 7:
		return "wordArtVertRtl"
	}
	return ""
}

// ValidateWithPath validates the CT_GroupShapeProperties and its children, prefixing error messages with path
func (_dacc *CT_GroupShapeProperties) ValidateWithPath(path string) error {
	if _fgfed := _dacc.BwModeAttr.ValidateWithPath(path + "/BwModeAttr"); _fgfed != nil {
		return _fgfed
	}
	if _dacc.Xfrm != nil {
		if _bbcad := _dacc.Xfrm.ValidateWithPath(path + "\u002fXfrm"); _bbcad != nil {
			return _bbcad
		}
	}
	if _dacc.NoFill != nil {
		if _ccce := _dacc.NoFill.ValidateWithPath(path + "\u002fNoFill"); _ccce != nil {
			return _ccce
		}
	}
	if _dacc.SolidFill != nil {
		if _ddad := _dacc.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _ddad != nil {
			return _ddad
		}
	}
	if _dacc.GradFill != nil {
		if _abdb := _dacc.GradFill.ValidateWithPath(path + "\u002fGradFill"); _abdb != nil {
			return _abdb
		}
	}
	if _dacc.BlipFill != nil {
		if _gegab := _dacc.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _gegab != nil {
			return _gegab
		}
	}
	if _dacc.PattFill != nil {
		if _gbca := _dacc.PattFill.ValidateWithPath(path + "\u002fPattFill"); _gbca != nil {
			return _gbca
		}
	}
	if _dacc.GrpFill != nil {
		if _face := _dacc.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _face != nil {
			return _face
		}
	}
	if _dacc.EffectLst != nil {
		if _edae := _dacc.EffectLst.ValidateWithPath(path + "\u002fEffectLst"); _edae != nil {
			return _edae
		}
	}
	if _dacc.EffectDag != nil {
		if _dgbg := _dacc.EffectDag.ValidateWithPath(path + "\u002fEffectDag"); _dgbg != nil {
			return _dgbg
		}
	}
	if _dacc.Scene3d != nil {
		if _agce := _dacc.Scene3d.ValidateWithPath(path + "\u002fScene3d"); _agce != nil {
			return _agce
		}
	}
	if _dacc.ExtLst != nil {
		if _gadb := _dacc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gadb != nil {
			return _gadb
		}
	}
	return nil
}
func (_beec *CT_SoftEdgesEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_beec.RadAttr = 0
	for _, _ebcef := range start.Attr {
		if _ebcef.Name.Local == "rad" {
			_afcgb, _ccab := _e.ParseInt(_ebcef.Value, 10, 64)
			if _ccab != nil {
				return _ccab
			}
			_beec.RadAttr = _afcgb
			continue
		}
	}
	for {
		_dcbfc, _bbdb := d.Token()
		if _bbdb != nil {
			return _dcf.Errorf("parsing\u0020CT_SoftEdgesEffect:\u0020\u0025s", _bbdb)
		}
		if _caec, _dcdag := _dcbfc.(_g.EndElement); _dcdag && _caec.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_NonVisualGroupDrawingShapeProps and its children, prefixing error messages with path
func (_fddfc *CT_NonVisualGroupDrawingShapeProps) ValidateWithPath(path string) error {
	if _fddfc.GrpSpLocks != nil {
		if _ggfac := _fddfc.GrpSpLocks.ValidateWithPath(path + "/GrpSpLocks"); _ggfac != nil {
			return _ggfac
		}
	}
	if _fddfc.ExtLst != nil {
		if _gggeg := _fddfc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gggeg != nil {
			return _gggeg
		}
	}
	return nil
}
func (_fbfb *CT_GvmlGroupShapeNonVisual) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_cfde := _g.StartElement{Name: _g.Name{Local: "a:cNvPr"}}
	e.EncodeElement(_fbfb.CNvPr, _cfde)
	_bfdf := _g.StartElement{Name: _g.Name{Local: "a:cNvGrpSpPr"}}
	e.EncodeElement(_fbfb.CNvGrpSpPr, _bfdf)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_degbc ST_AdjCoordinate) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _degbc.ST_Coordinate != nil {
		e.Encode(_degbc.ST_Coordinate)
	}
	if _degbc.ST_GeomGuideName != nil {
		e.EncodeToken(_g.CharData(*_degbc.ST_GeomGuideName))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}
func (_acgcb *CT_GvmlShape) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_dggda := _g.StartElement{Name: _g.Name{Local: "a:nvSpPr"}}
	e.EncodeElement(_acgcb.NvSpPr, _dggda)
	_dbagd := _g.StartElement{Name: _g.Name{Local: "a:spPr"}}
	e.EncodeElement(_acgcb.SpPr, _dbagd)
	if _acgcb.TxSp != nil {
		_fbgbg := _g.StartElement{Name: _g.Name{Local: "a:txSp"}}
		e.EncodeElement(_acgcb.TxSp, _fbgbg)
	}
	if _acgcb.Style != nil {
		_eggd := _g.StartElement{Name: _g.Name{Local: "a:style"}}
		e.EncodeElement(_acgcb.Style, _eggd)
	}
	if _acgcb.ExtLst != nil {
		_ddgg := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_acgcb.ExtLst, _ddgg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TextLineBreak and its children, prefixing error messages with path
func (_bcgff *CT_TextLineBreak) ValidateWithPath(path string) error {
	if _bcgff.RPr != nil {
		if _adfcf := _bcgff.RPr.ValidateWithPath(path + "\u002fRPr"); _adfcf != nil {
			return _adfcf
		}
	}
	return nil
}
func (_bfcg ST_BlackWhiteMode) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_bfcg.String(), start)
}
func NewCT_TextAutonumberBullet() *CT_TextAutonumberBullet {
	_bgfbd := &CT_TextAutonumberBullet{}
	_bgfbd.TypeAttr = ST_TextAutonumberScheme(1)
	return _bgfbd
}

// Validate validates the CT_ShapeStyle and its children
func (_geagbd *CT_ShapeStyle) Validate() error { return _geagbd.ValidateWithPath("CT_ShapeStyle") }
func (_efgdb *CT_StyleMatrix) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _efgdb.NameAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "name"}, Value: _dcf.Sprintf("\u0025v", *_efgdb.NameAttr)})
	}
	e.EncodeToken(start)
	_dffbe := _g.StartElement{Name: _g.Name{Local: "a:fillStyleLst"}}
	e.EncodeElement(_efgdb.FillStyleLst, _dffbe)
	_cdgbfg := _g.StartElement{Name: _g.Name{Local: "a:lnStyleLst"}}
	e.EncodeElement(_efgdb.LnStyleLst, _cdgbfg)
	_cagb := _g.StartElement{Name: _g.Name{Local: "a:effectStyleLst"}}
	e.EncodeElement(_efgdb.EffectStyleLst, _cagb)
	_edfe := _g.StartElement{Name: _g.Name{Local: "a:bgFillStyleLst"}}
	e.EncodeElement(_efgdb.BgFillStyleLst, _edfe)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_cdfacb *ST_PathShadeType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_cdfacb = 0
	case "shape":
		*_cdfacb = 1
	case "circle":
		*_cdfacb = 2
	case "rect":
		*_cdfacb = 3
	}
	return nil
}
func (_efbc *CT_AlphaInverseEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_dca:
	for {
		_ddec, _faf := d.Token()
		if _faf != nil {
			return _faf
		}
		switch _fef := _ddec.(type) {
		case _g.StartElement:
			switch _fef.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "scrgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "scrgbClr"}:
				_efbc.ScrgbClr = NewCT_ScRgbColor()
				if _bgb := d.DecodeElement(_efbc.ScrgbClr, &_fef); _bgb != nil {
					return _bgb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "srgbClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "srgbClr"}:
				_efbc.SrgbClr = NewCT_SRgbColor()
				if _cbe := d.DecodeElement(_efbc.SrgbClr, &_fef); _cbe != nil {
					return _cbe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hslClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hslClr"}:
				_efbc.HslClr = NewCT_HslColor()
				if _efd := d.DecodeElement(_efbc.HslClr, &_fef); _efd != nil {
					return _efd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sysClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sysClr"}:
				_efbc.SysClr = NewCT_SystemColor()
				if _dfb := d.DecodeElement(_efbc.SysClr, &_fef); _dfb != nil {
					return _dfb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "schemeClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "schemeClr"}:
				_efbc.SchemeClr = NewCT_SchemeColor()
				if _aca := d.DecodeElement(_efbc.SchemeClr, &_fef); _aca != nil {
					return _aca
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstClr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstClr"}:
				_efbc.PrstClr = NewCT_PresetColor()
				if _daae := d.DecodeElement(_efbc.PrstClr, &_fef); _daae != nil {
					return _daae
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_AlphaInverseEffect\u0020\u0025v", _fef.Name)
				if _faba := d.Skip(); _faba != nil {
					return _faba
				}
			}
		case _g.EndElement:
			break _dca
		case _g.CharData:
		}
	}
	return nil
}

const (
	ST_TextVertOverflowTypeUnset    ST_TextVertOverflowType = 0
	ST_TextVertOverflowTypeOverflow ST_TextVertOverflowType = 1
	ST_TextVertOverflowTypeEllipsis ST_TextVertOverflowType = 2
	ST_TextVertOverflowTypeClip     ST_TextVertOverflowType = 3
)

func (_fbgadc *EG_TextAutofit) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fbgadc.NoAutofit != nil {
		_bcacd := _g.StartElement{Name: _g.Name{Local: "a:noAutofit"}}
		e.EncodeElement(_fbgadc.NoAutofit, _bcacd)
	}
	if _fbgadc.NormAutofit != nil {
		_efdcd := _g.StartElement{Name: _g.Name{Local: "a:normAutofit"}}
		e.EncodeElement(_fbgadc.NormAutofit, _efdcd)
	}
	if _fbgadc.SpAutoFit != nil {
		_agcdff := _g.StartElement{Name: _g.Name{Local: "a:spAutoFit"}}
		e.EncodeElement(_fbgadc.SpAutoFit, _agcdff)
	}
	return nil
}
func NewCT_ComplementTransform() *CT_ComplementTransform {
	_egfe := &CT_ComplementTransform{}
	return _egfe
}

// Validate validates the CT_GvmlPicture and its children
func (_cffef *CT_GvmlPicture) Validate() error { return _cffef.ValidateWithPath("CT_GvmlPicture") }
func (_cffc *CT_EffectContainer) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bcde := range start.Attr {
		if _bcde.Name.Local == "type" {
			_cffc.TypeAttr.UnmarshalXMLAttr(_bcde)
			continue
		}
		if _bcde.Name.Local == "name" {
			_beea, _ebdec := _bcde.Value, error(nil)
			if _ebdec != nil {
				return _ebdec
			}
			_cffc.NameAttr = &_beea
			continue
		}
	}
_ccea:
	for {
		_ddaaa, _geec := d.Token()
		if _geec != nil {
			return _geec
		}
		switch _gaae := _ddaaa.(type) {
		case _g.StartElement:
			switch _gaae.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cont"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cont"}:
				_cffc.Cont = NewCT_EffectContainer()
				if _fcbaf := d.DecodeElement(_cffc.Cont, &_gaae); _fcbaf != nil {
					return _fcbaf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effect"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effect"}:
				_cffc.Effect = NewCT_EffectReference()
				if _beabf := d.DecodeElement(_cffc.Effect, &_gaae); _beabf != nil {
					return _beabf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaBiLevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaBiLevel"}:
				_cffc.AlphaBiLevel = NewCT_AlphaBiLevelEffect()
				if _edea := d.DecodeElement(_cffc.AlphaBiLevel, &_gaae); _edea != nil {
					return _edea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaCeiling"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaCeiling"}:
				_cffc.AlphaCeiling = NewCT_AlphaCeilingEffect()
				if _geagc := d.DecodeElement(_cffc.AlphaCeiling, &_gaae); _geagc != nil {
					return _geagc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaFloor"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaFloor"}:
				_cffc.AlphaFloor = NewCT_AlphaFloorEffect()
				if _fcdf := d.DecodeElement(_cffc.AlphaFloor, &_gaae); _fcdf != nil {
					return _fcdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaInv"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaInv"}:
				_cffc.AlphaInv = NewCT_AlphaInverseEffect()
				if _defd := d.DecodeElement(_cffc.AlphaInv, &_gaae); _defd != nil {
					return _defd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaMod"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaMod"}:
				_cffc.AlphaMod = NewCT_AlphaModulateEffect()
				if _aceba := d.DecodeElement(_cffc.AlphaMod, &_gaae); _aceba != nil {
					return _aceba
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaModFix"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaModFix"}:
				_cffc.AlphaModFix = NewCT_AlphaModulateFixedEffect()
				if _eadbe := d.DecodeElement(_cffc.AlphaModFix, &_gaae); _eadbe != nil {
					return _eadbe
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaOutset"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaOutset"}:
				_cffc.AlphaOutset = NewCT_AlphaOutsetEffect()
				if _fbdaa := d.DecodeElement(_cffc.AlphaOutset, &_gaae); _fbdaa != nil {
					return _fbdaa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "alphaRepl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "alphaRepl"}:
				_cffc.AlphaRepl = NewCT_AlphaReplaceEffect()
				if _agbde := d.DecodeElement(_cffc.AlphaRepl, &_gaae); _agbde != nil {
					return _agbde
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "biLevel"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "biLevel"}:
				_cffc.BiLevel = NewCT_BiLevelEffect()
				if _dcadg := d.DecodeElement(_cffc.BiLevel, &_gaae); _dcadg != nil {
					return _dcadg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blend"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blend"}:
				_cffc.Blend = NewCT_BlendEffect()
				if _gaead := d.DecodeElement(_cffc.Blend, &_gaae); _gaead != nil {
					return _gaead
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blur"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blur"}:
				_cffc.Blur = NewCT_BlurEffect()
				if _gccec := d.DecodeElement(_cffc.Blur, &_gaae); _gccec != nil {
					return _gccec
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrChange"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrChange"}:
				_cffc.ClrChange = NewCT_ColorChangeEffect()
				if _aabf := d.DecodeElement(_cffc.ClrChange, &_gaae); _aabf != nil {
					return _aabf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrRepl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrRepl"}:
				_cffc.ClrRepl = NewCT_ColorReplaceEffect()
				if _bdef := d.DecodeElement(_cffc.ClrRepl, &_gaae); _bdef != nil {
					return _bdef
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "duotone"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "duotone"}:
				_cffc.Duotone = NewCT_DuotoneEffect()
				if _dgadf := d.DecodeElement(_cffc.Duotone, &_gaae); _dgadf != nil {
					return _dgadf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fill"}:
				_cffc.Fill = NewCT_FillEffect()
				if _fcebf := d.DecodeElement(_cffc.Fill, &_gaae); _fcebf != nil {
					return _fcebf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillOverlay"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillOverlay"}:
				_cffc.FillOverlay = NewCT_FillOverlayEffect()
				if _efbba := d.DecodeElement(_cffc.FillOverlay, &_gaae); _efbba != nil {
					return _efbba
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "glow"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "glow"}:
				_cffc.Glow = NewCT_GlowEffect()
				if _ceea := d.DecodeElement(_cffc.Glow, &_gaae); _ceea != nil {
					return _ceea
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grayscl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grayscl"}:
				_cffc.Grayscl = NewCT_GrayscaleEffect()
				if _aeaa := d.DecodeElement(_cffc.Grayscl, &_gaae); _aeaa != nil {
					return _aeaa
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "hsl"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "hsl"}:
				_cffc.Hsl = NewCT_HSLEffect()
				if _dbcg := d.DecodeElement(_cffc.Hsl, &_gaae); _dbcg != nil {
					return _dbcg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "innerShdw"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "innerShdw"}:
				_cffc.InnerShdw = NewCT_InnerShadowEffect()
				if _dbdde := d.DecodeElement(_cffc.InnerShdw, &_gaae); _dbdde != nil {
					return _dbdde
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lum"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lum"}:
				_cffc.Lum = NewCT_LuminanceEffect()
				if _cdeee := d.DecodeElement(_cffc.Lum, &_gaae); _cdeee != nil {
					return _cdeee
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "outerShdw"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "outerShdw"}:
				_cffc.OuterShdw = NewCT_OuterShadowEffect()
				if _efcgd := d.DecodeElement(_cffc.OuterShdw, &_gaae); _efcgd != nil {
					return _efcgd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "prstShdw"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "prstShdw"}:
				_cffc.PrstShdw = NewCT_PresetShadowEffect()
				if _dgdf := d.DecodeElement(_cffc.PrstShdw, &_gaae); _dgdf != nil {
					return _dgdf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "reflection"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "reflection"}:
				_cffc.Reflection = NewCT_ReflectionEffect()
				if _gcbf := d.DecodeElement(_cffc.Reflection, &_gaae); _gcbf != nil {
					return _gcbf
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "relOff"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "relOff"}:
				_cffc.RelOff = NewCT_RelativeOffsetEffect()
				if _cbaba := d.DecodeElement(_cffc.RelOff, &_gaae); _cbaba != nil {
					return _cbaba
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "softEdge"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "softEdge"}:
				_cffc.SoftEdge = NewCT_SoftEdgesEffect()
				if _cebc := d.DecodeElement(_cffc.SoftEdge, &_gaae); _cebc != nil {
					return _cebc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tint"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tint"}:
				_cffc.Tint = NewCT_TintEffect()
				if _decb := d.DecodeElement(_cffc.Tint, &_gaae); _decb != nil {
					return _decb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "xfrm"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "xfrm"}:
				_cffc.Xfrm = NewCT_TransformEffect()
				if _aeca := d.DecodeElement(_cffc.Xfrm, &_gaae); _aeca != nil {
					return _aeca
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_EffectContainer\u0020\u0025v", _gaae.Name)
				if _affd := d.Skip(); _affd != nil {
					return _affd
				}
			}
		case _g.EndElement:
			break _ccea
		case _g.CharData:
		}
	}
	return nil
}
func (_fdbfb ST_AnimationBuildType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ffbcc := _g.Attr{}
	_ffbcc.Name = name
	switch _fdbfb {
	case ST_AnimationBuildTypeUnset:
		_ffbcc.Value = ""
	case ST_AnimationBuildTypeAllAtOnce:
		_ffbcc.Value = "allAtOnce"
	}
	return _ffbcc, nil
}

type CT_AnimationChartBuildProperties struct {
	BldAttr    *ST_AnimationChartBuildType
	AnimBgAttr *bool
}

func NewCT_StyleMatrixReference() *CT_StyleMatrixReference {
	_cfaeae := &CT_StyleMatrixReference{}
	return _cfaeae
}
func (_dcbd *CT_ShapeLocking) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _dcbd.NoTextEditAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noTextEdit"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcbd.NoTextEditAttr))})
	}
	if _dcbd.NoGrpAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noGrp"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcbd.NoGrpAttr))})
	}
	if _dcbd.NoSelectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noSelect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcbd.NoSelectAttr))})
	}
	if _dcbd.NoRotAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noRot"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcbd.NoRotAttr))})
	}
	if _dcbd.NoChangeAspectAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeAspect"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcbd.NoChangeAspectAttr))})
	}
	if _dcbd.NoMoveAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noMove"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcbd.NoMoveAttr))})
	}
	if _dcbd.NoResizeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noResize"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcbd.NoResizeAttr))})
	}
	if _dcbd.NoEditPointsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noEditPoints"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcbd.NoEditPointsAttr))})
	}
	if _dcbd.NoAdjustHandlesAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noAdjustHandles"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcbd.NoAdjustHandlesAttr))})
	}
	if _dcbd.NoChangeArrowheadsAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeArrowheads"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcbd.NoChangeArrowheadsAttr))})
	}
	if _dcbd.NoChangeShapeTypeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "noChangeShapeType"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_dcbd.NoChangeShapeTypeAttr))})
	}
	e.EncodeToken(start)
	if _dcbd.ExtLst != nil {
		_bdcbe := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dcbd.ExtLst, _bdcbe)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_eefga *EG_LineFillProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _eefga.NoFill != nil {
		_acecf := _g.StartElement{Name: _g.Name{Local: "a:noFill"}}
		e.EncodeElement(_eefga.NoFill, _acecf)
	}
	if _eefga.SolidFill != nil {
		_acgdc := _g.StartElement{Name: _g.Name{Local: "a:solidFill"}}
		e.EncodeElement(_eefga.SolidFill, _acgdc)
	}
	if _eefga.GradFill != nil {
		_egeeb := _g.StartElement{Name: _g.Name{Local: "a:gradFill"}}
		e.EncodeElement(_eefga.GradFill, _egeeb)
	}
	if _eefga.PattFill != nil {
		_afbce := _g.StartElement{Name: _g.Name{Local: "a:pattFill"}}
		e.EncodeElement(_eefga.PattFill, _afbce)
	}
	return nil
}

// ValidateWithPath validates the CT_Path2DLineTo and its children, prefixing error messages with path
func (_dbedb *CT_Path2DLineTo) ValidateWithPath(path string) error {
	if _dfadc := _dbedb.Pt.ValidateWithPath(path + "\u002fPt"); _dfadc != nil {
		return _dfadc
	}
	return nil
}

const (
	ST_ShapeTypeUnset                      ST_ShapeType = 0
	ST_ShapeTypeLine                       ST_ShapeType = 1
	ST_ShapeTypeLineInv                    ST_ShapeType = 2
	ST_ShapeTypeTriangle                   ST_ShapeType = 3
	ST_ShapeTypeRtTriangle                 ST_ShapeType = 4
	ST_ShapeTypeRect                       ST_ShapeType = 5
	ST_ShapeTypeDiamond                    ST_ShapeType = 6
	ST_ShapeTypeParallelogram              ST_ShapeType = 7
	ST_ShapeTypeTrapezoid                  ST_ShapeType = 8
	ST_ShapeTypeNonIsoscelesTrapezoid      ST_ShapeType = 9
	ST_ShapeTypePentagon                   ST_ShapeType = 10
	ST_ShapeTypeHexagon                    ST_ShapeType = 11
	ST_ShapeTypeHeptagon                   ST_ShapeType = 12
	ST_ShapeTypeOctagon                    ST_ShapeType = 13
	ST_ShapeTypeDecagon                    ST_ShapeType = 14
	ST_ShapeTypeDodecagon                  ST_ShapeType = 15
	ST_ShapeTypeStar4                      ST_ShapeType = 16
	ST_ShapeTypeStar5                      ST_ShapeType = 17
	ST_ShapeTypeStar6                      ST_ShapeType = 18
	ST_ShapeTypeStar7                      ST_ShapeType = 19
	ST_ShapeTypeStar8                      ST_ShapeType = 20
	ST_ShapeTypeStar10                     ST_ShapeType = 21
	ST_ShapeTypeStar12                     ST_ShapeType = 22
	ST_ShapeTypeStar16                     ST_ShapeType = 23
	ST_ShapeTypeStar24                     ST_ShapeType = 24
	ST_ShapeTypeStar32                     ST_ShapeType = 25
	ST_ShapeTypeRoundRect                  ST_ShapeType = 26
	ST_ShapeTypeRound1Rect                 ST_ShapeType = 27
	ST_ShapeTypeRound2SameRect             ST_ShapeType = 28
	ST_ShapeTypeRound2DiagRect             ST_ShapeType = 29
	ST_ShapeTypeSnipRoundRect              ST_ShapeType = 30
	ST_ShapeTypeSnip1Rect                  ST_ShapeType = 31
	ST_ShapeTypeSnip2SameRect              ST_ShapeType = 32
	ST_ShapeTypeSnip2DiagRect              ST_ShapeType = 33
	ST_ShapeTypePlaque                     ST_ShapeType = 34
	ST_ShapeTypeEllipse                    ST_ShapeType = 35
	ST_ShapeTypeTeardrop                   ST_ShapeType = 36
	ST_ShapeTypeHomePlate                  ST_ShapeType = 37
	ST_ShapeTypeChevron                    ST_ShapeType = 38
	ST_ShapeTypePieWedge                   ST_ShapeType = 39
	ST_ShapeTypePie                        ST_ShapeType = 40
	ST_ShapeTypeBlockArc                   ST_ShapeType = 41
	ST_ShapeTypeDonut                      ST_ShapeType = 42
	ST_ShapeTypeNoSmoking                  ST_ShapeType = 43
	ST_ShapeTypeRightArrow                 ST_ShapeType = 44
	ST_ShapeTypeLeftArrow                  ST_ShapeType = 45
	ST_ShapeTypeUpArrow                    ST_ShapeType = 46
	ST_ShapeTypeDownArrow                  ST_ShapeType = 47
	ST_ShapeTypeStripedRightArrow          ST_ShapeType = 48
	ST_ShapeTypeNotchedRightArrow          ST_ShapeType = 49
	ST_ShapeTypeBentUpArrow                ST_ShapeType = 50
	ST_ShapeTypeLeftRightArrow             ST_ShapeType = 51
	ST_ShapeTypeUpDownArrow                ST_ShapeType = 52
	ST_ShapeTypeLeftUpArrow                ST_ShapeType = 53
	ST_ShapeTypeLeftRightUpArrow           ST_ShapeType = 54
	ST_ShapeTypeQuadArrow                  ST_ShapeType = 55
	ST_ShapeTypeLeftArrowCallout           ST_ShapeType = 56
	ST_ShapeTypeRightArrowCallout          ST_ShapeType = 57
	ST_ShapeTypeUpArrowCallout             ST_ShapeType = 58
	ST_ShapeTypeDownArrowCallout           ST_ShapeType = 59
	ST_ShapeTypeLeftRightArrowCallout      ST_ShapeType = 60
	ST_ShapeTypeUpDownArrowCallout         ST_ShapeType = 61
	ST_ShapeTypeQuadArrowCallout           ST_ShapeType = 62
	ST_ShapeTypeBentArrow                  ST_ShapeType = 63
	ST_ShapeTypeUturnArrow                 ST_ShapeType = 64
	ST_ShapeTypeCircularArrow              ST_ShapeType = 65
	ST_ShapeTypeLeftCircularArrow          ST_ShapeType = 66
	ST_ShapeTypeLeftRightCircularArrow     ST_ShapeType = 67
	ST_ShapeTypeCurvedRightArrow           ST_ShapeType = 68
	ST_ShapeTypeCurvedLeftArrow            ST_ShapeType = 69
	ST_ShapeTypeCurvedUpArrow              ST_ShapeType = 70
	ST_ShapeTypeCurvedDownArrow            ST_ShapeType = 71
	ST_ShapeTypeSwooshArrow                ST_ShapeType = 72
	ST_ShapeTypeCube                       ST_ShapeType = 73
	ST_ShapeTypeCan                        ST_ShapeType = 74
	ST_ShapeTypeLightningBolt              ST_ShapeType = 75
	ST_ShapeTypeHeart                      ST_ShapeType = 76
	ST_ShapeTypeSun                        ST_ShapeType = 77
	ST_ShapeTypeMoon                       ST_ShapeType = 78
	ST_ShapeTypeSmileyFace                 ST_ShapeType = 79
	ST_ShapeTypeIrregularSeal1             ST_ShapeType = 80
	ST_ShapeTypeIrregularSeal2             ST_ShapeType = 81
	ST_ShapeTypeFoldedCorner               ST_ShapeType = 82
	ST_ShapeTypeBevel                      ST_ShapeType = 83
	ST_ShapeTypeFrame                      ST_ShapeType = 84
	ST_ShapeTypeHalfFrame                  ST_ShapeType = 85
	ST_ShapeTypeCorner                     ST_ShapeType = 86
	ST_ShapeTypeDiagStripe                 ST_ShapeType = 87
	ST_ShapeTypeChord                      ST_ShapeType = 88
	ST_ShapeTypeArc                        ST_ShapeType = 89
	ST_ShapeTypeLeftBracket                ST_ShapeType = 90
	ST_ShapeTypeRightBracket               ST_ShapeType = 91
	ST_ShapeTypeLeftBrace                  ST_ShapeType = 92
	ST_ShapeTypeRightBrace                 ST_ShapeType = 93
	ST_ShapeTypeBracketPair                ST_ShapeType = 94
	ST_ShapeTypeBracePair                  ST_ShapeType = 95
	ST_ShapeTypeStraightConnector1         ST_ShapeType = 96
	ST_ShapeTypeBentConnector2             ST_ShapeType = 97
	ST_ShapeTypeBentConnector3             ST_ShapeType = 98
	ST_ShapeTypeBentConnector4             ST_ShapeType = 99
	ST_ShapeTypeBentConnector5             ST_ShapeType = 100
	ST_ShapeTypeCurvedConnector2           ST_ShapeType = 101
	ST_ShapeTypeCurvedConnector3           ST_ShapeType = 102
	ST_ShapeTypeCurvedConnector4           ST_ShapeType = 103
	ST_ShapeTypeCurvedConnector5           ST_ShapeType = 104
	ST_ShapeTypeCallout1                   ST_ShapeType = 105
	ST_ShapeTypeCallout2                   ST_ShapeType = 106
	ST_ShapeTypeCallout3                   ST_ShapeType = 107
	ST_ShapeTypeAccentCallout1             ST_ShapeType = 108
	ST_ShapeTypeAccentCallout2             ST_ShapeType = 109
	ST_ShapeTypeAccentCallout3             ST_ShapeType = 110
	ST_ShapeTypeBorderCallout1             ST_ShapeType = 111
	ST_ShapeTypeBorderCallout2             ST_ShapeType = 112
	ST_ShapeTypeBorderCallout3             ST_ShapeType = 113
	ST_ShapeTypeAccentBorderCallout1       ST_ShapeType = 114
	ST_ShapeTypeAccentBorderCallout2       ST_ShapeType = 115
	ST_ShapeTypeAccentBorderCallout3       ST_ShapeType = 116
	ST_ShapeTypeWedgeRectCallout           ST_ShapeType = 117
	ST_ShapeTypeWedgeRoundRectCallout      ST_ShapeType = 118
	ST_ShapeTypeWedgeEllipseCallout        ST_ShapeType = 119
	ST_ShapeTypeCloudCallout               ST_ShapeType = 120
	ST_ShapeTypeCloud                      ST_ShapeType = 121
	ST_ShapeTypeRibbon                     ST_ShapeType = 122
	ST_ShapeTypeRibbon2                    ST_ShapeType = 123
	ST_ShapeTypeEllipseRibbon              ST_ShapeType = 124
	ST_ShapeTypeEllipseRibbon2             ST_ShapeType = 125
	ST_ShapeTypeLeftRightRibbon            ST_ShapeType = 126
	ST_ShapeTypeVerticalScroll             ST_ShapeType = 127
	ST_ShapeTypeHorizontalScroll           ST_ShapeType = 128
	ST_ShapeTypeWave                       ST_ShapeType = 129
	ST_ShapeTypeDoubleWave                 ST_ShapeType = 130
	ST_ShapeTypePlus                       ST_ShapeType = 131
	ST_ShapeTypeFlowChartProcess           ST_ShapeType = 132
	ST_ShapeTypeFlowChartDecision          ST_ShapeType = 133
	ST_ShapeTypeFlowChartInputOutput       ST_ShapeType = 134
	ST_ShapeTypeFlowChartPredefinedProcess ST_ShapeType = 135
	ST_ShapeTypeFlowChartInternalStorage   ST_ShapeType = 136
	ST_ShapeTypeFlowChartDocument          ST_ShapeType = 137
	ST_ShapeTypeFlowChartMultidocument     ST_ShapeType = 138
	ST_ShapeTypeFlowChartTerminator        ST_ShapeType = 139
	ST_ShapeTypeFlowChartPreparation       ST_ShapeType = 140
	ST_ShapeTypeFlowChartManualInput       ST_ShapeType = 141
	ST_ShapeTypeFlowChartManualOperation   ST_ShapeType = 142
	ST_ShapeTypeFlowChartConnector         ST_ShapeType = 143
	ST_ShapeTypeFlowChartPunchedCard       ST_ShapeType = 144
	ST_ShapeTypeFlowChartPunchedTape       ST_ShapeType = 145
	ST_ShapeTypeFlowChartSummingJunction   ST_ShapeType = 146
	ST_ShapeTypeFlowChartOr                ST_ShapeType = 147
	ST_ShapeTypeFlowChartCollate           ST_ShapeType = 148
	ST_ShapeTypeFlowChartSort              ST_ShapeType = 149
	ST_ShapeTypeFlowChartExtract           ST_ShapeType = 150
	ST_ShapeTypeFlowChartMerge             ST_ShapeType = 151
	ST_ShapeTypeFlowChartOfflineStorage    ST_ShapeType = 152
	ST_ShapeTypeFlowChartOnlineStorage     ST_ShapeType = 153
	ST_ShapeTypeFlowChartMagneticTape      ST_ShapeType = 154
	ST_ShapeTypeFlowChartMagneticDisk      ST_ShapeType = 155
	ST_ShapeTypeFlowChartMagneticDrum      ST_ShapeType = 156
	ST_ShapeTypeFlowChartDisplay           ST_ShapeType = 157
	ST_ShapeTypeFlowChartDelay             ST_ShapeType = 158
	ST_ShapeTypeFlowChartAlternateProcess  ST_ShapeType = 159
	ST_ShapeTypeFlowChartOffpageConnector  ST_ShapeType = 160
	ST_ShapeTypeActionButtonBlank          ST_ShapeType = 161
	ST_ShapeTypeActionButtonHome           ST_ShapeType = 162
	ST_ShapeTypeActionButtonHelp           ST_ShapeType = 163
	ST_ShapeTypeActionButtonInformation    ST_ShapeType = 164
	ST_ShapeTypeActionButtonForwardNext    ST_ShapeType = 165
	ST_ShapeTypeActionButtonBackPrevious   ST_ShapeType = 166
	ST_ShapeTypeActionButtonEnd            ST_ShapeType = 167
	ST_ShapeTypeActionButtonBeginning      ST_ShapeType = 168
	ST_ShapeTypeActionButtonReturn         ST_ShapeType = 169
	ST_ShapeTypeActionButtonDocument       ST_ShapeType = 170
	ST_ShapeTypeActionButtonSound          ST_ShapeType = 171
	ST_ShapeTypeActionButtonMovie          ST_ShapeType = 172
	ST_ShapeTypeGear6                      ST_ShapeType = 173
	ST_ShapeTypeGear9                      ST_ShapeType = 174
	ST_ShapeTypeFunnel                     ST_ShapeType = 175
	ST_ShapeTypeMathPlus                   ST_ShapeType = 176
	ST_ShapeTypeMathMinus                  ST_ShapeType = 177
	ST_ShapeTypeMathMultiply               ST_ShapeType = 178
	ST_ShapeTypeMathDivide                 ST_ShapeType = 179
	ST_ShapeTypeMathEqual                  ST_ShapeType = 180
	ST_ShapeTypeMathNotEqual               ST_ShapeType = 181
	ST_ShapeTypeCornerTabs                 ST_ShapeType = 182
	ST_ShapeTypeSquareTabs                 ST_ShapeType = 183
	ST_ShapeTypePlaqueTabs                 ST_ShapeType = 184
	ST_ShapeTypeChartX                     ST_ShapeType = 185
	ST_ShapeTypeChartStar                  ST_ShapeType = 186
	ST_ShapeTypeChartPlus                  ST_ShapeType = 187
)

// ValidateWithPath validates the CT_Angle and its children, prefixing error messages with path
func (_ecg *CT_Angle) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_PresetLineDashProperties and its children
func (_fcgg *CT_PresetLineDashProperties) Validate() error {
	return _fcgg.ValidateWithPath("CT_PresetLineDashProperties")
}
func NewGraphic() *Graphic {
	_ffagg := &Graphic{}
	_ffagg.CT_GraphicalObject = *NewCT_GraphicalObject()
	return _ffagg
}
func NewCT_ColorMapping() *CT_ColorMapping {
	_agge := &CT_ColorMapping{}
	_agge.Bg1Attr = ST_ColorSchemeIndex(1)
	_agge.Tx1Attr = ST_ColorSchemeIndex(1)
	_agge.Bg2Attr = ST_ColorSchemeIndex(1)
	_agge.Tx2Attr = ST_ColorSchemeIndex(1)
	_agge.Accent1Attr = ST_ColorSchemeIndex(1)
	_agge.Accent2Attr = ST_ColorSchemeIndex(1)
	_agge.Accent3Attr = ST_ColorSchemeIndex(1)
	_agge.Accent4Attr = ST_ColorSchemeIndex(1)
	_agge.Accent5Attr = ST_ColorSchemeIndex(1)
	_agge.Accent6Attr = ST_ColorSchemeIndex(1)
	_agge.HlinkAttr = ST_ColorSchemeIndex(1)
	_agge.FolHlinkAttr = ST_ColorSchemeIndex(1)
	return _agge
}

// Validate validates the CT_GammaTransform and its children
func (_agae *CT_GammaTransform) Validate() error { return _agae.ValidateWithPath("CT_GammaTransform") }
func (_cfgae ST_PitchFamily) Validate() error    { return _cfgae.ValidateWithPath("") }
func (_cadgb *CT_NonVisualConnectorProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_acaf:
	for {
		_ccdad, _aabcf := d.Token()
		if _aabcf != nil {
			return _aabcf
		}
		switch _bgdb := _ccdad.(type) {
		case _g.StartElement:
			switch _bgdb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cxnSpLocks"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cxnSpLocks"}:
				_cadgb.CxnSpLocks = NewCT_ConnectorLocking()
				if _gafgb := d.DecodeElement(_cadgb.CxnSpLocks, &_bgdb); _gafgb != nil {
					return _gafgb
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "stCxn"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "stCxn"}:
				_cadgb.StCxn = NewCT_Connection()
				if _dcedc := d.DecodeElement(_cadgb.StCxn, &_bgdb); _dcedc != nil {
					return _dcedc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "endCxn"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "endCxn"}:
				_cadgb.EndCxn = NewCT_Connection()
				if _ebgcgc := d.DecodeElement(_cadgb.EndCxn, &_bgdb); _ebgcgc != nil {
					return _ebgcgc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_cadgb.ExtLst = NewCT_OfficeArtExtensionList()
				if _ffgf := d.DecodeElement(_cadgb.ExtLst, &_bgdb); _ffgf != nil {
					return _ffgf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_NonVisualConnectorProperties\u0020\u0025v", _bgdb.Name)
				if _ebgaf := d.Skip(); _ebgaf != nil {
					return _ebgaf
				}
			}
		case _g.EndElement:
			break _acaf
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_PresetGeometry2D() *CT_PresetGeometry2D {
	_aegad := &CT_PresetGeometry2D{}
	_aegad.PrstAttr = ST_ShapeType(1)
	return _aegad
}

// ValidateWithPath validates the CT_GvmlShapeNonVisual and its children, prefixing error messages with path
func (_bgdfa *CT_GvmlShapeNonVisual) ValidateWithPath(path string) error {
	if _cedab := _bgdfa.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _cedab != nil {
		return _cedab
	}
	if _ddcabf := _bgdfa.CNvSpPr.ValidateWithPath(path + "\u002fCNvSpPr"); _ddcabf != nil {
		return _ddcabf
	}
	return nil
}

// Validate validates the CT_Path2DMoveTo and its children
func (_cafcbd *CT_Path2DMoveTo) Validate() error { return _cafcbd.ValidateWithPath("CT_Path2DMoveTo") }
func (_eeda *CT_HSLEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _eeda.HueAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "hue"}, Value: _dcf.Sprintf("\u0025v", *_eeda.HueAttr)})
	}
	if _eeda.SatAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sat"}, Value: _dcf.Sprintf("\u0025v", *_eeda.SatAttr)})
	}
	if _eeda.LumAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "lum"}, Value: _dcf.Sprintf("\u0025v", *_eeda.LumAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the EG_TextBulletSize and its children, prefixing error messages with path
func (_bbdcd *EG_TextBulletSize) ValidateWithPath(path string) error {
	if _bbdcd.BuSzTx != nil {
		if _ffgff := _bbdcd.BuSzTx.ValidateWithPath(path + "\u002fBuSzTx"); _ffgff != nil {
			return _ffgff
		}
	}
	if _bbdcd.BuSzPct != nil {
		if _aceeg := _bbdcd.BuSzPct.ValidateWithPath(path + "\u002fBuSzPct"); _aceeg != nil {
			return _aceeg
		}
	}
	if _bbdcd.BuSzPts != nil {
		if _ccfef := _bbdcd.BuSzPts.ValidateWithPath(path + "\u002fBuSzPts"); _ccfef != nil {
			return _ccfef
		}
	}
	return nil
}
func (_ccafd *CT_TextBulletSizeFollowText) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_AnimationElementChoice and its children
func (_geag *CT_AnimationElementChoice) Validate() error {
	return _geag.ValidateWithPath("CT_AnimationElementChoice")
}
func (_baefe *EG_ColorTransform) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _baefe.Tint != nil {
		_abafg := _g.StartElement{Name: _g.Name{Local: "a:tint"}}
		e.EncodeElement(_baefe.Tint, _abafg)
	}
	if _baefe.Shade != nil {
		_bbdba := _g.StartElement{Name: _g.Name{Local: "a:shade"}}
		e.EncodeElement(_baefe.Shade, _bbdba)
	}
	if _baefe.Comp != nil {
		_gfgef := _g.StartElement{Name: _g.Name{Local: "a:comp"}}
		e.EncodeElement(_baefe.Comp, _gfgef)
	}
	if _baefe.Inv != nil {
		_badcd := _g.StartElement{Name: _g.Name{Local: "a:inv"}}
		e.EncodeElement(_baefe.Inv, _badcd)
	}
	if _baefe.Gray != nil {
		_fedab := _g.StartElement{Name: _g.Name{Local: "a:gray"}}
		e.EncodeElement(_baefe.Gray, _fedab)
	}
	if _baefe.Alpha != nil {
		_dedda := _g.StartElement{Name: _g.Name{Local: "a:alpha"}}
		e.EncodeElement(_baefe.Alpha, _dedda)
	}
	if _baefe.AlphaOff != nil {
		_gfeef := _g.StartElement{Name: _g.Name{Local: "a:alphaOff"}}
		e.EncodeElement(_baefe.AlphaOff, _gfeef)
	}
	if _baefe.AlphaMod != nil {
		_cgbg := _g.StartElement{Name: _g.Name{Local: "a:alphaMod"}}
		e.EncodeElement(_baefe.AlphaMod, _cgbg)
	}
	if _baefe.Hue != nil {
		_aecage := _g.StartElement{Name: _g.Name{Local: "a:hue"}}
		e.EncodeElement(_baefe.Hue, _aecage)
	}
	if _baefe.HueOff != nil {
		_cdfcf := _g.StartElement{Name: _g.Name{Local: "a:hueOff"}}
		e.EncodeElement(_baefe.HueOff, _cdfcf)
	}
	if _baefe.HueMod != nil {
		_gaad := _g.StartElement{Name: _g.Name{Local: "a:hueMod"}}
		e.EncodeElement(_baefe.HueMod, _gaad)
	}
	if _baefe.Sat != nil {
		_faccc := _g.StartElement{Name: _g.Name{Local: "a:sat"}}
		e.EncodeElement(_baefe.Sat, _faccc)
	}
	if _baefe.SatOff != nil {
		_eaeeg := _g.StartElement{Name: _g.Name{Local: "a:satOff"}}
		e.EncodeElement(_baefe.SatOff, _eaeeg)
	}
	if _baefe.SatMod != nil {
		_addeac := _g.StartElement{Name: _g.Name{Local: "a:satMod"}}
		e.EncodeElement(_baefe.SatMod, _addeac)
	}
	if _baefe.Lum != nil {
		_fbgef := _g.StartElement{Name: _g.Name{Local: "a:lum"}}
		e.EncodeElement(_baefe.Lum, _fbgef)
	}
	if _baefe.LumOff != nil {
		_eegae := _g.StartElement{Name: _g.Name{Local: "a:lumOff"}}
		e.EncodeElement(_baefe.LumOff, _eegae)
	}
	if _baefe.LumMod != nil {
		_fabda := _g.StartElement{Name: _g.Name{Local: "a:lumMod"}}
		e.EncodeElement(_baefe.LumMod, _fabda)
	}
	if _baefe.Red != nil {
		_gcebd := _g.StartElement{Name: _g.Name{Local: "a:red"}}
		e.EncodeElement(_baefe.Red, _gcebd)
	}
	if _baefe.RedOff != nil {
		_dabadf := _g.StartElement{Name: _g.Name{Local: "a:redOff"}}
		e.EncodeElement(_baefe.RedOff, _dabadf)
	}
	if _baefe.RedMod != nil {
		_abfce := _g.StartElement{Name: _g.Name{Local: "a:redMod"}}
		e.EncodeElement(_baefe.RedMod, _abfce)
	}
	if _baefe.Green != nil {
		_bfcac := _g.StartElement{Name: _g.Name{Local: "a:green"}}
		e.EncodeElement(_baefe.Green, _bfcac)
	}
	if _baefe.GreenOff != nil {
		_ccacf := _g.StartElement{Name: _g.Name{Local: "a:greenOff"}}
		e.EncodeElement(_baefe.GreenOff, _ccacf)
	}
	if _baefe.GreenMod != nil {
		_aeegb := _g.StartElement{Name: _g.Name{Local: "a:greenMod"}}
		e.EncodeElement(_baefe.GreenMod, _aeegb)
	}
	if _baefe.Blue != nil {
		_edaeb := _g.StartElement{Name: _g.Name{Local: "a:blue"}}
		e.EncodeElement(_baefe.Blue, _edaeb)
	}
	if _baefe.BlueOff != nil {
		_dbcee := _g.StartElement{Name: _g.Name{Local: "a:blueOff"}}
		e.EncodeElement(_baefe.BlueOff, _dbcee)
	}
	if _baefe.BlueMod != nil {
		_adfgac := _g.StartElement{Name: _g.Name{Local: "a:blueMod"}}
		e.EncodeElement(_baefe.BlueMod, _adfgac)
	}
	if _baefe.Gamma != nil {
		_egce := _g.StartElement{Name: _g.Name{Local: "a:gamma"}}
		e.EncodeElement(_baefe.Gamma, _egce)
	}
	if _baefe.InvGamma != nil {
		_fbgag := _g.StartElement{Name: _g.Name{Local: "a:invGamma"}}
		e.EncodeElement(_baefe.InvGamma, _fbgag)
	}
	return nil
}

// Validate validates the CT_LineJoinBevel and its children
func (_fdcea *CT_LineJoinBevel) Validate() error { return _fdcea.ValidateWithPath("CT_LineJoinBevel") }
func (_gebge *EG_TextBulletColor) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _gebge.BuClrTx != nil {
		_gbcga := _g.StartElement{Name: _g.Name{Local: "a:buClrTx"}}
		e.EncodeElement(_gebge.BuClrTx, _gbcga)
	}
	if _gebge.BuClr != nil {
		_egccc := _g.StartElement{Name: _g.Name{Local: "a:buClr"}}
		e.EncodeElement(_gebge.BuClr, _egccc)
	}
	return nil
}

type ST_TextUnderlineType byte

func (_gfea ST_AnimationDgmOnlyBuildType) ValidateWithPath(path string) error {
	switch _gfea {
	case 0, 1, 2, 3:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gfea))
	}
	return nil
}

type ST_TileFlipMode byte

func (_fafac *ST_PresetCameraType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fafac = 0
	case "legacyObliqueTopLeft":
		*_fafac = 1
	case "legacyObliqueTop":
		*_fafac = 2
	case "legacyObliqueTopRight":
		*_fafac = 3
	case "legacyObliqueLeft":
		*_fafac = 4
	case "legacyObliqueFront":
		*_fafac = 5
	case "legacyObliqueRight":
		*_fafac = 6
	case "legacyObliqueBottomLeft":
		*_fafac = 7
	case "legacyObliqueBottom":
		*_fafac = 8
	case "legacyObliqueBottomRight":
		*_fafac = 9
	case "legacyPerspectiveTopLeft":
		*_fafac = 10
	case "legacyPerspectiveTop":
		*_fafac = 11
	case "legacyPerspectiveTopRight":
		*_fafac = 12
	case "legacyPerspectiveLeft":
		*_fafac = 13
	case "legacyPerspectiveFront":
		*_fafac = 14
	case "legacyPerspectiveRight":
		*_fafac = 15
	case "legacyPerspectiveBottomLeft":
		*_fafac = 16
	case "legacyPerspectiveBottom":
		*_fafac = 17
	case "legacyPerspectiveBottomRight":
		*_fafac = 18
	case "orthographicFront":
		*_fafac = 19
	case "isometricTopUp":
		*_fafac = 20
	case "isometricTopDown":
		*_fafac = 21
	case "isometricBottomUp":
		*_fafac = 22
	case "isometricBottomDown":
		*_fafac = 23
	case "isometricLeftUp":
		*_fafac = 24
	case "isometricLeftDown":
		*_fafac = 25
	case "isometricRightUp":
		*_fafac = 26
	case "isometricRightDown":
		*_fafac = 27
	case "isometricOffAxis1Left":
		*_fafac = 28
	case "isometricOffAxis1Right":
		*_fafac = 29
	case "isometricOffAxis1Top":
		*_fafac = 30
	case "isometricOffAxis2Left":
		*_fafac = 31
	case "isometricOffAxis2Right":
		*_fafac = 32
	case "isometricOffAxis2Top":
		*_fafac = 33
	case "isometricOffAxis3Left":
		*_fafac = 34
	case "isometricOffAxis3Right":
		*_fafac = 35
	case "isometricOffAxis3Bottom":
		*_fafac = 36
	case "isometricOffAxis4Left":
		*_fafac = 37
	case "isometricOffAxis4Right":
		*_fafac = 38
	case "isometricOffAxis4Bottom":
		*_fafac = 39
	case "obliqueTopLeft":
		*_fafac = 40
	case "obliqueTop":
		*_fafac = 41
	case "obliqueTopRight":
		*_fafac = 42
	case "obliqueLeft":
		*_fafac = 43
	case "obliqueRight":
		*_fafac = 44
	case "obliqueBottomLeft":
		*_fafac = 45
	case "obliqueBottom":
		*_fafac = 46
	case "obliqueBottomRight":
		*_fafac = 47
	case "perspectiveFront":
		*_fafac = 48
	case "perspectiveLeft":
		*_fafac = 49
	case "perspectiveRight":
		*_fafac = 50
	case "perspectiveAbove":
		*_fafac = 51
	case "perspectiveBelow":
		*_fafac = 52
	case "perspectiveAboveLeftFacing":
		*_fafac = 53
	case "perspectiveAboveRightFacing":
		*_fafac = 54
	case "perspectiveContrastingLeftFacing":
		*_fafac = 55
	case "perspectiveContrastingRightFacing":
		*_fafac = 56
	case "perspectiveHeroicLeftFacing":
		*_fafac = 57
	case "perspectiveHeroicRightFacing":
		*_fafac = 58
	case "perspectiveHeroicExtremeLeftFacing":
		*_fafac = 59
	case "perspectiveHeroicExtremeRightFacing":
		*_fafac = 60
	case "perspectiveRelaxed":
		*_fafac = 61
	case "perspectiveRelaxedModerately":
		*_fafac = 62
	}
	return nil
}
func (_cggcd ST_TextAutonumberScheme) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cggcd.String(), start)
}

// Validate validates the CT_GvmlShapeNonVisual and its children
func (_cdff *CT_GvmlShapeNonVisual) Validate() error {
	return _cdff.ValidateWithPath("CT_GvmlShapeNonVisual")
}
func (_adgff *CT_BlendEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_adgff.BlendAttr = ST_BlendMode(1)
	_adgff.Cont = NewCT_EffectContainer()
	for _, _eae := range start.Attr {
		if _eae.Name.Local == "blend" {
			_adgff.BlendAttr.UnmarshalXMLAttr(_eae)
			continue
		}
	}
_afee:
	for {
		_efdg, _gead := d.Token()
		if _gead != nil {
			return _gead
		}
		switch _dcga := _efdg.(type) {
		case _g.StartElement:
			switch _dcga.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cont"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cont"}:
				if _gbgb := d.DecodeElement(_adgff.Cont, &_dcga); _gbgb != nil {
					return _gbgb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BlendEffect\u0020\u0025v", _dcga.Name)
				if _ccg := d.Skip(); _ccg != nil {
					return _ccg
				}
			}
		case _g.EndElement:
			break _afee
		case _g.CharData:
		}
	}
	return nil
}
func (_ccdff ST_TextHorzOverflowType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_bafdf := _g.Attr{}
	_bafdf.Name = name
	switch _ccdff {
	case ST_TextHorzOverflowTypeUnset:
		_bafdf.Value = ""
	case ST_TextHorzOverflowTypeOverflow:
		_bafdf.Value = "overflow"
	case ST_TextHorzOverflowTypeClip:
		_bafdf.Value = "clip"
	}
	return _bafdf, nil
}

type ST_FontCollectionIndex byte
type CT_TableCell struct {
	RowSpanAttr  *int32
	GridSpanAttr *int32
	HMergeAttr   *bool
	VMergeAttr   *bool
	IdAttr       *string
	TxBody       *CT_TextBody
	TcPr         *CT_TableCellProperties
	ExtLst       *CT_OfficeArtExtensionList
}

func (_geafgb ST_PresetShadowVal) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_geafgb.String(), start)
}
func (_bdea *CT_SupplementalFont) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "script"}, Value: _dcf.Sprintf("\u0025v", _bdea.ScriptAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "typeface"}, Value: _dcf.Sprintf("\u0025v", _bdea.TypefaceAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_acce *CT_SchemeColor) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_degbe, _dbddcc := _acce.ValAttr.MarshalXMLAttr(_g.Name{Local: "val"})
	if _dbddcc != nil {
		return _dbddcc
	}
	start.Attr = append(start.Attr, _degbe)
	e.EncodeToken(start)
	if _acce.EG_ColorTransform != nil {
		for _, _aece := range _acce.EG_ColorTransform {
			_aece.MarshalXML(e, _g.StartElement{})
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_PathShadeProperties and its children, prefixing error messages with path
func (_cbcc *CT_PathShadeProperties) ValidateWithPath(path string) error {
	if _cegdf := _cbcc.PathAttr.ValidateWithPath(path + "\u002fPathAttr"); _cegdf != nil {
		return _cegdf
	}
	if _cbcc.FillToRect != nil {
		if _aaebd := _cbcc.FillToRect.ValidateWithPath(path + "/FillToRect"); _aaebd != nil {
			return _aaebd
		}
	}
	return nil
}
func (_bdcbf *CT_TextLineBreak) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _bdcbf.RPr != nil {
		_efbbc := _g.StartElement{Name: _g.Name{Local: "a:rPr"}}
		e.EncodeElement(_bdcbf.RPr, _efbbc)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func NewCT_LineJoinBevel() *CT_LineJoinBevel { _ggfa := &CT_LineJoinBevel{}; return _ggfa }
func (_fcdgb *CT_ReflectionEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _fcdgb.BlurRadAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "blurRad"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.BlurRadAttr)})
	}
	if _fcdgb.StAAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "stA"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.StAAttr)})
	}
	if _fcdgb.StPosAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "stPos"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.StPosAttr)})
	}
	if _fcdgb.EndAAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "endA"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.EndAAttr)})
	}
	if _fcdgb.EndPosAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "endPos"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.EndPosAttr)})
	}
	if _fcdgb.DistAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dist"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.DistAttr)})
	}
	if _fcdgb.DirAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "dir"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.DirAttr)})
	}
	if _fcdgb.FadeDirAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "fadeDir"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.FadeDirAttr)})
	}
	if _fcdgb.SxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sx"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.SxAttr)})
	}
	if _fcdgb.SyAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "sy"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.SyAttr)})
	}
	if _fcdgb.KxAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "kx"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.KxAttr)})
	}
	if _fcdgb.KyAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "ky"}, Value: _dcf.Sprintf("\u0025v", *_fcdgb.KyAttr)})
	}
	if _fcdgb.AlgnAttr != ST_RectAlignmentUnset {
		_efffc, _cfcag := _fcdgb.AlgnAttr.MarshalXMLAttr(_g.Name{Local: "algn"})
		if _cfcag != nil {
			return _cfcag
		}
		start.Attr = append(start.Attr, _efffc)
	}
	if _fcdgb.RotWithShapeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rotWithShape"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_fcdgb.RotWithShapeAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Percentage and its children
func (_bafef *CT_Percentage) Validate() error { return _bafef.ValidateWithPath("CT_Percentage") }
func (_dbaefe ST_PresetPatternVal) ValidateWithPath(path string) error {
	switch _dbaefe {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dbaefe))
	}
	return nil
}

// ValidateWithPath validates the CT_StyleMatrix and its children, prefixing error messages with path
func (_dggc *CT_StyleMatrix) ValidateWithPath(path string) error {
	if _afcdc := _dggc.FillStyleLst.ValidateWithPath(path + "\u002fFillStyleLst"); _afcdc != nil {
		return _afcdc
	}
	if _ccfee := _dggc.LnStyleLst.ValidateWithPath(path + "/LnStyleLst"); _ccfee != nil {
		return _ccfee
	}
	if _bgbaf := _dggc.EffectStyleLst.ValidateWithPath(path + "\u002fEffectStyleLst"); _bgbaf != nil {
		return _bgbaf
	}
	if _dbbdfb := _dggc.BgFillStyleLst.ValidateWithPath(path + "\u002fBgFillStyleLst"); _dbbdfb != nil {
		return _dbbdfb
	}
	return nil
}
func (_edcf *CT_Bevel) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _edcf.WAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "w"}, Value: _dcf.Sprintf("\u0025v", *_edcf.WAttr)})
	}
	if _edcf.HAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "h"}, Value: _dcf.Sprintf("\u0025v", *_edcf.HAttr)})
	}
	if _edcf.PrstAttr != ST_BevelPresetTypeUnset {
		_dafde, _ggdc := _edcf.PrstAttr.MarshalXMLAttr(_g.Name{Local: "prst"})
		if _ggdc != nil {
			return _ggdc
		}
		start.Attr = append(start.Attr, _dafde)
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_TableCellBorderStyle struct {
	Left    *CT_ThemeableLineStyle
	Right   *CT_ThemeableLineStyle
	Top     *CT_ThemeableLineStyle
	Bottom  *CT_ThemeableLineStyle
	InsideH *CT_ThemeableLineStyle
	InsideV *CT_ThemeableLineStyle
	Tl2br   *CT_ThemeableLineStyle
	Tr2bl   *CT_ThemeableLineStyle
	ExtLst  *CT_OfficeArtExtensionList
}

// Validate validates the CT_GrayscaleEffect and its children
func (_fceg *CT_GrayscaleEffect) Validate() error {
	return _fceg.ValidateWithPath("CT_GrayscaleEffect")
}

// ValidateWithPath validates the CT_GroupTransform2D and its children, prefixing error messages with path
func (_cgdgc *CT_GroupTransform2D) ValidateWithPath(path string) error {
	if _cgdgc.Off != nil {
		if _ccedf := _cgdgc.Off.ValidateWithPath(path + "\u002fOff"); _ccedf != nil {
			return _ccedf
		}
	}
	if _cgdgc.Ext != nil {
		if _abca := _cgdgc.Ext.ValidateWithPath(path + "\u002fExt"); _abca != nil {
			return _abca
		}
	}
	if _cgdgc.ChOff != nil {
		if _bcbg := _cgdgc.ChOff.ValidateWithPath(path + "\u002fChOff"); _bcbg != nil {
			return _bcbg
		}
	}
	if _cgdgc.ChExt != nil {
		if _bdegd := _cgdgc.ChExt.ValidateWithPath(path + "\u002fChExt"); _bdegd != nil {
			return _bdegd
		}
	}
	return nil
}
func (_gbbecf ST_TextWrappingType) ValidateWithPath(path string) error {
	switch _gbbecf {
	case 0, 1, 2:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gbbecf))
	}
	return nil
}
func NewCT_GeomGuide() *CT_GeomGuide { _begb := &CT_GeomGuide{}; return _begb }
func (_efb *CT_AdjustHandleList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_ddeb:
	for {
		_ffg, _dcff := d.Token()
		if _dcff != nil {
			return _dcff
		}
		switch _gea := _ffg.(type) {
		case _g.StartElement:
			switch _gea.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ahXY"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ahXY"}:
				_bga := NewCT_XYAdjustHandle()
				if _egbd := d.DecodeElement(_bga, &_gea); _egbd != nil {
					return _egbd
				}
				_efb.AhXY = append(_efb.AhXY, _bga)
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ahPolar"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ahPolar"}:
				_cea := NewCT_PolarAdjustHandle()
				if _ddbc := d.DecodeElement(_cea, &_gea); _ddbc != nil {
					return _ddbc
				}
				_efb.AhPolar = append(_efb.AhPolar, _cea)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_AdjustHandleList\u0020\u0025v", _gea.Name)
				if _aae := d.Skip(); _aae != nil {
					return _aae
				}
			}
		case _g.EndElement:
			break _ddeb
		case _g.CharData:
		}
	}
	return nil
}
func (_ccef *CT_AlphaCeilingEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_cggb, _baef := d.Token()
		if _baef != nil {
			return _dcf.Errorf("parsing\u0020CT_AlphaCeilingEffect:\u0020\u0025s", _baef)
		}
		if _abb, _fcg := _cggb.(_g.EndElement); _fcg && _abb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ebceb *CT_FontCollection) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_cadg := _g.StartElement{Name: _g.Name{Local: "a:latin"}}
	e.EncodeElement(_ebceb.Latin, _cadg)
	_fcbae := _g.StartElement{Name: _g.Name{Local: "a:ea"}}
	e.EncodeElement(_ebceb.Ea, _fcbae)
	_bcagf := _g.StartElement{Name: _g.Name{Local: "a:cs"}}
	e.EncodeElement(_ebceb.Cs, _bcagf)
	if _ebceb.Font != nil {
		_cdccb := _g.StartElement{Name: _g.Name{Local: "a:font"}}
		for _, _ddbb := range _ebceb.Font {
			e.EncodeElement(_ddbb, _cdccb)
		}
	}
	if _ebceb.ExtLst != nil {
		_debb := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_ebceb.ExtLst, _debb)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_gcaea ST_TileFlipMode) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_gcaea.String(), start)
}
func (_gcafg *CT_NonVisualDrawingProps) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "id"}, Value: _dcf.Sprintf("\u0025v", _gcafg.IdAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "name"}, Value: _dcf.Sprintf("\u0025v", _gcafg.NameAttr)})
	if _gcafg.DescrAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "descr"}, Value: _dcf.Sprintf("\u0025v", *_gcafg.DescrAttr)})
	}
	if _gcafg.HiddenAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "hidden"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_gcafg.HiddenAttr))})
	}
	if _gcafg.TitleAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "title"}, Value: _dcf.Sprintf("\u0025v", *_gcafg.TitleAttr)})
	}
	e.EncodeToken(start)
	if _gcafg.HlinkClick != nil {
		_aagfb := _g.StartElement{Name: _g.Name{Local: "a:hlinkClick"}}
		e.EncodeElement(_gcafg.HlinkClick, _aagfb)
	}
	if _gcafg.HlinkHover != nil {
		_debc := _g.StartElement{Name: _g.Name{Local: "a:hlinkHover"}}
		e.EncodeElement(_gcafg.HlinkHover, _debc)
	}
	if _gcafg.ExtLst != nil {
		_aeaca := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_gcafg.ExtLst, _aeaca)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_abdfb *ST_TextFontScalePercentOrPercentString) Validate() error {
	return _abdfb.ValidateWithPath("")
}
func (_ddff *CT_GvmlGroupShape) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_gaggb := _g.StartElement{Name: _g.Name{Local: "a:nvGrpSpPr"}}
	e.EncodeElement(_ddff.NvGrpSpPr, _gaggb)
	_faege := _g.StartElement{Name: _g.Name{Local: "a:grpSpPr"}}
	e.EncodeElement(_ddff.GrpSpPr, _faege)
	if _ddff.Choice != nil {
		for _, _dbgeb := range _ddff.Choice {
			_dbgeb.MarshalXML(e, _g.StartElement{})
		}
	}
	if _ddff.ExtLst != nil {
		_gdfdf := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_ddff.ExtLst, _gdfdf)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_abgcd *EG_TextBulletSize) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _abgcd.BuSzTx != nil {
		_ccgfgd := _g.StartElement{Name: _g.Name{Local: "a:buSzTx"}}
		e.EncodeElement(_abgcd.BuSzTx, _ccgfgd)
	}
	if _abgcd.BuSzPct != nil {
		_egecf := _g.StartElement{Name: _g.Name{Local: "a:buSzPct"}}
		e.EncodeElement(_abgcd.BuSzPct, _egecf)
	}
	if _abgcd.BuSzPts != nil {
		_dbgfe := _g.StartElement{Name: _g.Name{Local: "a:buSzPts"}}
		e.EncodeElement(_abgcd.BuSzPts, _dbgfe)
	}
	return nil
}

type ST_RectAlignment byte

func (_cffgc ST_PathFillMode) ValidateWithPath(path string) error {
	switch _cffgc {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cffgc))
	}
	return nil
}
func (_dcbce *CT_StretchInfoProperties) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_efege:
	for {
		_ggagcb, _fbdfa := d.Token()
		if _fbdfa != nil {
			return _fbdfa
		}
		switch _cgbfd := _ggagcb.(type) {
		case _g.StartElement:
			switch _cgbfd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillRect"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillRect"}:
				_dcbce.FillRect = NewCT_RelativeRect()
				if _bbgf := d.DecodeElement(_dcbce.FillRect, &_cgbfd); _bbgf != nil {
					return _bbgf
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_StretchInfoProperties\u0020%v", _cgbfd.Name)
				if _babaa := d.Skip(); _babaa != nil {
					return _babaa
				}
			}
		case _g.EndElement:
			break _efege
		case _g.CharData:
		}
	}
	return nil
}

type CT_GvmlConnector struct {
	NvCxnSpPr *CT_GvmlConnectorNonVisual
	SpPr      *CT_ShapeProperties
	Style     *CT_ShapeStyle
	ExtLst    *CT_OfficeArtExtensionList
}

// ValidateWithPath validates the CT_GraphicalObjectFrameLocking and its children, prefixing error messages with path
func (_bcdce *CT_GraphicalObjectFrameLocking) ValidateWithPath(path string) error {
	if _bcdce.ExtLst != nil {
		if _aefdb := _bcdce.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _aefdb != nil {
			return _aefdb
		}
	}
	return nil
}
func (_decaf *CT_EmptyElement) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_aefff ST_EffectContainerType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_aefff.String(), start)
}
func NewCT_ColorScheme() *CT_ColorScheme {
	_acbg := &CT_ColorScheme{}
	_acbg.Dk1 = NewCT_Color()
	_acbg.Lt1 = NewCT_Color()
	_acbg.Dk2 = NewCT_Color()
	_acbg.Lt2 = NewCT_Color()
	_acbg.Accent1 = NewCT_Color()
	_acbg.Accent2 = NewCT_Color()
	_acbg.Accent3 = NewCT_Color()
	_acbg.Accent4 = NewCT_Color()
	_acbg.Accent5 = NewCT_Color()
	_acbg.Accent6 = NewCT_Color()
	_acbg.Hlink = NewCT_Color()
	_acbg.FolHlink = NewCT_Color()
	return _acbg
}
func (_agacc *CT_TextBulletTypefaceFollowText) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for {
		_fdgad, _dddc := d.Token()
		if _dddc != nil {
			return _dcf.Errorf("parsing CT_TextBulletTypefaceFollowText:\u0020\u0025s", _dddc)
		}
		if _fgdde, _cecbg := _fdgad.(_g.EndElement); _cecbg && _fgdde.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_Point3D and its children
func (_ecffc *CT_Point3D) Validate() error { return _ecffc.ValidateWithPath("CT_Point3D") }
func (_acfc *CT_ColorSchemeAndMapping) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_gddc := _g.StartElement{Name: _g.Name{Local: "a:clrScheme"}}
	e.EncodeElement(_acfc.ClrScheme, _gddc)
	if _acfc.ClrMap != nil {
		_eccef := _g.StartElement{Name: _g.Name{Local: "a:clrMap"}}
		e.EncodeElement(_acfc.ClrMap, _eccef)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_dead *CT_TableStyleCellStyle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_gedba:
	for {
		_adafe, _abbdb := d.Token()
		if _abbdb != nil {
			return _abbdb
		}
		switch _eadcf := _adafe.(type) {
		case _g.StartElement:
			switch _eadcf.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tcBdr"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tcBdr"}:
				_dead.TcBdr = NewCT_TableCellBorderStyle()
				if _cfaae := d.DecodeElement(_dead.TcBdr, &_eadcf); _cfaae != nil {
					return _cfaae
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fill"}:
				_dead.Fill = NewCT_FillProperties()
				if _cdaeg := d.DecodeElement(_dead.Fill, &_eadcf); _cdaeg != nil {
					return _cdaeg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "fillRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "fillRef"}:
				_dead.FillRef = NewCT_StyleMatrixReference()
				if _ffdadc := d.DecodeElement(_dead.FillRef, &_eadcf); _ffdadc != nil {
					return _ffdadc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "cell3D"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "cell3D"}:
				_dead.Cell3D = NewCT_Cell3D()
				if _gafed := d.DecodeElement(_dead.Cell3D, &_eadcf); _gafed != nil {
					return _gafed
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TableStyleCellStyle\u0020\u0025v", _eadcf.Name)
				if _eccefd := d.Skip(); _eccefd != nil {
					return _eccefd
				}
			}
		case _g.EndElement:
			break _gedba
		case _g.CharData:
		}
	}
	return nil
}
func (_geacca ST_TextStrikeType) Validate() error { return _geacca.ValidateWithPath("") }

// Validate validates the CT_TextTabStopList and its children
func (_dfdegd *CT_TextTabStopList) Validate() error {
	return _dfdegd.ValidateWithPath("CT_TextTabStopList")
}
func (_baccf *ST_TextVerticalType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_baccf = 0
	case "horz":
		*_baccf = 1
	case "vert":
		*_baccf = 2
	case "vert270":
		*_baccf = 3
	case "wordArtVert":
		*_baccf = 4
	case "eaVert":
		*_baccf = 5
	case "mongolianVert":
		*_baccf = 6
	case "wordArtVertRtl":
		*_baccf = 7
	}
	return nil
}

const (
	ST_TextWrappingTypeUnset  ST_TextWrappingType = 0
	ST_TextWrappingTypeNone   ST_TextWrappingType = 1
	ST_TextWrappingTypeSquare ST_TextWrappingType = 2
)

func (_bdad *CT_EffectReference) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "ref"}, Value: _dcf.Sprintf("\u0025v", _bdad.RefAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_cgffd ST_Percentage) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _cgffd.ST_PercentageDecimal != nil {
		e.EncodeToken(_g.CharData(_dcf.Sprintf("\u0025d", *_cgffd.ST_PercentageDecimal)))
	}
	if _cgffd.ST_Percentage != nil {
		e.EncodeToken(_g.CharData(*_cgffd.ST_Percentage))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}
func (_dfege *CT_ColorMappingOverride) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dfege.Choice = NewCT_ColorMappingOverrideChoice()
_bcca:
	for {
		_cabc, _gbff := d.Token()
		if _gbff != nil {
			return _gbff
		}
		switch _eca := _cabc.(type) {
		case _g.StartElement:
			switch _eca.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "masterClrMapping"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "masterClrMapping"}:
				_dfege.Choice = NewCT_ColorMappingOverrideChoice()
				if _fcfcd := d.DecodeElement(&_dfege.Choice.MasterClrMapping, &_eca); _fcfcd != nil {
					return _fcfcd
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "overrideClrMapping"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "overrideClrMapping"}:
				_dfege.Choice = NewCT_ColorMappingOverrideChoice()
				if _gccc := d.DecodeElement(&_dfege.Choice.OverrideClrMapping, &_eca); _gccc != nil {
					return _gccc
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_ColorMappingOverride \u0025v", _eca.Name)
				if _feag := d.Skip(); _feag != nil {
					return _feag
				}
			}
		case _g.EndElement:
			break _bcca
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_AlphaCeilingEffect and its children
func (_baf *CT_AlphaCeilingEffect) Validate() error {
	return _baf.ValidateWithPath("CT_AlphaCeilingEffect")
}
func (_ccfgbc ST_BevelPresetType) String() string {
	switch _ccfgbc {
	case 0:
		return ""
	case 1:
		return "relaxedInset"
	case 2:
		return "circle"
	case 3:
		return "slope"
	case 4:
		return "cross"
	case 5:
		return "angle"
	case 6:
		return "softRound"
	case 7:
		return "convex"
	case 8:
		return "coolSlant"
	case 9:
		return "divot"
	case 10:
		return "riblet"
	case 11:
		return "hardEdge"
	case 12:
		return "artDeco"
	}
	return ""
}
func (_fggde ST_TextCapsType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_fggde.String(), start)
}
func NewCT_InnerShadowEffect() *CT_InnerShadowEffect { _dgbf := &CT_InnerShadowEffect{}; return _dgbf }

type AG_Locking struct {
	NoGrpAttr              *bool
	NoSelectAttr           *bool
	NoRotAttr              *bool
	NoChangeAspectAttr     *bool
	NoMoveAttr             *bool
	NoResizeAttr           *bool
	NoEditPointsAttr       *bool
	NoAdjustHandlesAttr    *bool
	NoChangeArrowheadsAttr *bool
	NoChangeShapeTypeAttr  *bool
}

func (_feegg *CT_TableStyleList) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_feegg.DefAttr = "\u007b00000000\u002d0000\u002d0000\u002d0000-000000000000\u007d"
	for _, _bfaga := range start.Attr {
		if _bfaga.Name.Local == "def" {
			_gdabb, _fcabd := _bfaga.Value, error(nil)
			if _fcabd != nil {
				return _fcabd
			}
			_feegg.DefAttr = _gdabb
			continue
		}
	}
_cacae:
	for {
		_abdffd, _cbgfc := d.Token()
		if _cbgfc != nil {
			return _cbgfc
		}
		switch _ebbeg := _abdffd.(type) {
		case _g.StartElement:
			switch _ebbeg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "tblStyle"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "tblStyle"}:
				_eaceb := NewCT_TableStyle()
				if _dgcff := d.DecodeElement(_eaceb, &_ebbeg); _dgcff != nil {
					return _dgcff
				}
				_feegg.TblStyle = append(_feegg.TblStyle, _eaceb)
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_TableStyleList\u0020\u0025v", _ebbeg.Name)
				if _deecc := d.Skip(); _deecc != nil {
					return _deecc
				}
			}
		case _g.EndElement:
			break _cacae
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_TableRow and its children
func (_bbdcf *CT_TableRow) Validate() error { return _bbdcf.ValidateWithPath("CT_TableRow") }

// ValidateWithPath validates the CT_TextBlipBullet and its children, prefixing error messages with path
func (_gbdde *CT_TextBlipBullet) ValidateWithPath(path string) error {
	if _abfc := _gbdde.Blip.ValidateWithPath(path + "\u002fBlip"); _abfc != nil {
		return _abfc
	}
	return nil
}

type ST_AnimationBuildType byte

func (_cfccb ST_TextCapsType) ValidateWithPath(path string) error {
	switch _cfccb {
	case 0, 1, 2, 3:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cfccb))
	}
	return nil
}
func NewCT_RelativeOffsetEffect() *CT_RelativeOffsetEffect {
	_gbabea := &CT_RelativeOffsetEffect{}
	return _gbabea
}
func (_aaedc *CT_ThemeableLineStyle) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_ecbagb:
	for {
		_cfcd, _gbged := d.Token()
		if _gbged != nil {
			return _gbged
		}
		switch _dgcg := _cfcd.(type) {
		case _g.StartElement:
			switch _dgcg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "ln"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "ln"}:
				_aaedc.Ln = NewCT_LineProperties()
				if _fcgcc := d.DecodeElement(_aaedc.Ln, &_dgcg); _fcgcc != nil {
					return _fcgcc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "lnRef"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "lnRef"}:
				_aaedc.LnRef = NewCT_StyleMatrixReference()
				if _bdeef := d.DecodeElement(_aaedc.LnRef, &_dgcg); _bdeef != nil {
					return _bdeef
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_ThemeableLineStyle\u0020\u0025v", _dgcg.Name)
				if _gccb := d.Skip(); _gccb != nil {
					return _gccb
				}
			}
		case _g.EndElement:
			break _ecbagb
		case _g.CharData:
		}
	}
	return nil
}
func (_bbdef *EG_TextUnderlineFill) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_egcbd:
	for {
		_afcb, _fegba := d.Token()
		if _fegba != nil {
			return _fegba
		}
		switch _bdge := _afcb.(type) {
		case _g.StartElement:
			switch _bdge.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "uFillTx"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "uFillTx"}:
				_bbdef.UFillTx = NewCT_TextUnderlineFillFollowText()
				if _dgbcg := d.DecodeElement(_bbdef.UFillTx, &_bdge); _dgbcg != nil {
					return _dgbcg
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "uFill"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "uFill"}:
				_bbdef.UFill = NewCT_TextUnderlineFillGroupWrapper()
				if _egefd := d.DecodeElement(_bbdef.UFill, &_bdge); _egefd != nil {
					return _egefd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020EG_TextUnderlineFill\u0020\u0025v", _bdge.Name)
				if _cfgagcd := d.Skip(); _cfgagcd != nil {
					return _cfgagcd
				}
			}
		case _g.EndElement:
			break _egcbd
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Path2DList and its children
func (_becd *CT_Path2DList) Validate() error { return _becd.ValidateWithPath("CT_Path2DList") }

// ValidateWithPath validates the CT_Blip and its children, prefixing error messages with path
func (_dcad *CT_Blip) ValidateWithPath(path string) error {
	if _gfcbf := _dcad.CstateAttr.ValidateWithPath(path + "/CstateAttr"); _gfcbf != nil {
		return _gfcbf
	}
	for _dgff, _gcf := range _dcad.Choice {
		if _gafa := _gcf.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fChoice\u005b\u0025d\u005d", path, _dgff)); _gafa != nil {
			return _gafa
		}
	}
	if _dcad.ExtLst != nil {
		if _cdeb := _dcad.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cdeb != nil {
			return _cdeb
		}
	}
	return nil
}

// Validate validates the CT_GvmlConnector and its children
func (_ccbg *CT_GvmlConnector) Validate() error { return _ccbg.ValidateWithPath("CT_GvmlConnector") }

// Validate validates the CT_GeomGuideList and its children
func (_cefa *CT_GeomGuideList) Validate() error { return _cefa.ValidateWithPath("CT_GeomGuideList") }

const (
	ST_TextAnchoringTypeUnset ST_TextAnchoringType = 0
	ST_TextAnchoringTypeT     ST_TextAnchoringType = 1
	ST_TextAnchoringTypeCtr   ST_TextAnchoringType = 2
	ST_TextAnchoringTypeB     ST_TextAnchoringType = 3
	ST_TextAnchoringTypeJust  ST_TextAnchoringType = 4
	ST_TextAnchoringTypeDist  ST_TextAnchoringType = 5
)

func (_gbaa *CT_BiLevelEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _bgdgf := range start.Attr {
		if _bgdgf.Name.Local == "thresh" {
			_aeff, _gacaf := ParseUnionST_PositiveFixedPercentage(_bgdgf.Value)
			if _gacaf != nil {
				return _gacaf
			}
			_gbaa.ThreshAttr = _aeff
			continue
		}
	}
	for {
		_dfcd, _bfdc := d.Token()
		if _bfdc != nil {
			return _dcf.Errorf("parsing\u0020CT_BiLevelEffect: \u0025s", _bfdc)
		}
		if _deea, _decf := _dfcd.(_g.EndElement); _decf && _deea.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_Point2D and its children
func (_dbddcf *CT_Point2D) Validate() error { return _dbddcf.ValidateWithPath("CT_Point2D") }

const (
	ST_OnOffStyleTypeUnset ST_OnOffStyleType = 0
	ST_OnOffStyleTypeOn    ST_OnOffStyleType = 1
	ST_OnOffStyleTypeOff   ST_OnOffStyleType = 2
	ST_OnOffStyleTypeDef   ST_OnOffStyleType = 3
)

// Validate validates the CT_ColorReplaceEffect and its children
func (_aagada *CT_ColorReplaceEffect) Validate() error {
	return _aagada.ValidateWithPath("CT_ColorReplaceEffect")
}
func NewEG_TextRun() *EG_TextRun { _ebcafc := &EG_TextRun{}; return _ebcafc }

type CT_OuterShadowEffect struct {
	BlurRadAttr      *int64
	DistAttr         *int64
	DirAttr          *int32
	SxAttr           *ST_Percentage
	SyAttr           *ST_Percentage
	KxAttr           *int32
	KyAttr           *int32
	AlgnAttr         ST_RectAlignment
	RotWithShapeAttr *bool
	ScrgbClr         *CT_ScRgbColor
	SrgbClr          *CT_SRgbColor
	HslClr           *CT_HslColor
	SysClr           *CT_SystemColor
	SchemeClr        *CT_SchemeColor
	PrstClr          *CT_PresetColor
}

func (_dddbc ST_TextAlignType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_gfefg := _g.Attr{}
	_gfefg.Name = name
	switch _dddbc {
	case ST_TextAlignTypeUnset:
		_gfefg.Value = ""
	case ST_TextAlignTypeL:
		_gfefg.Value = "l"
	case ST_TextAlignTypeCtr:
		_gfefg.Value = "ctr"
	case ST_TextAlignTypeR:
		_gfefg.Value = "r"
	case ST_TextAlignTypeJust:
		_gfefg.Value = "just"
	case ST_TextAlignTypeJustLow:
		_gfefg.Value = "justLow"
	case ST_TextAlignTypeDist:
		_gfefg.Value = "dist"
	case ST_TextAlignTypeThaiDist:
		_gfefg.Value = "thaiDist"
	}
	return _gfefg, nil
}
func (_cedg *CT_AudioCDTime) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _cdf := range start.Attr {
		if _cdf.Name.Local == "track" {
			_baffd, _efde := _e.ParseUint(_cdf.Value, 10, 8)
			if _efde != nil {
				return _efde
			}
			_cedg.TrackAttr = uint8(_baffd)
			continue
		}
		if _cdf.Name.Local == "time" {
			_eeac, _bdbf := _e.ParseUint(_cdf.Value, 10, 32)
			if _bdbf != nil {
				return _bdbf
			}
			_fdff := uint32(_eeac)
			_cedg.TimeAttr = &_fdff
			continue
		}
	}
	for {
		_ffe, _aee := d.Token()
		if _aee != nil {
			return _dcf.Errorf("parsing\u0020CT_AudioCDTime:\u0020\u0025s", _aee)
		}
		if _badg, _cbcd := _ffe.(_g.EndElement); _cbcd && _badg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_accg ST_BevelPresetType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_accg.String(), start)
}
func (_eebff ST_PositivePercentage) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _eebff.ST_PositivePercentageDecimal != nil {
		e.EncodeToken(_g.CharData(_dcf.Sprintf("\u0025d", *_eebff.ST_PositivePercentageDecimal)))
	}
	if _eebff.ST_PositivePercentage != nil {
		e.Encode(_eebff.ST_PositivePercentage)
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

const (
	ST_RectAlignmentUnset ST_RectAlignment = 0
	ST_RectAlignmentTl    ST_RectAlignment = 1
	ST_RectAlignmentT     ST_RectAlignment = 2
	ST_RectAlignmentTr    ST_RectAlignment = 3
	ST_RectAlignmentL     ST_RectAlignment = 4
	ST_RectAlignmentCtr   ST_RectAlignment = 5
	ST_RectAlignmentR     ST_RectAlignment = 6
	ST_RectAlignmentBl    ST_RectAlignment = 7
	ST_RectAlignmentB     ST_RectAlignment = 8
	ST_RectAlignmentBr    ST_RectAlignment = 9
)

func (_adgf *CT_BlendEffect) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_cbaf, _gad := _adgf.BlendAttr.MarshalXMLAttr(_g.Name{Local: "blend"})
	if _gad != nil {
		return _gad
	}
	start.Attr = append(start.Attr, _cbaf)
	e.EncodeToken(start)
	_acdc := _g.StartElement{Name: _g.Name{Local: "a:cont"}}
	e.EncodeElement(_adgf.Cont, _acdc)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_ConnectorLocking struct {
	ExtLst                 *CT_OfficeArtExtensionList
	NoGrpAttr              *bool
	NoSelectAttr           *bool
	NoRotAttr              *bool
	NoChangeAspectAttr     *bool
	NoMoveAttr             *bool
	NoResizeAttr           *bool
	NoEditPointsAttr       *bool
	NoAdjustHandlesAttr    *bool
	NoChangeArrowheadsAttr *bool
	NoChangeShapeTypeAttr  *bool
}

// ValidateWithPath validates the CT_AnimationChartElement and its children, prefixing error messages with path
func (_gdb *CT_AnimationChartElement) ValidateWithPath(path string) error {
	if _gdb.BldStepAttr == ST_ChartBuildStepUnset {
		return _dcf.Errorf("%s\u002fBldStepAttr is\u0020a\u0020mandatory\u0020field", path)
	}
	if _cfe := _gdb.BldStepAttr.ValidateWithPath(path + "\u002fBldStepAttr"); _cfe != nil {
		return _cfe
	}
	return nil
}
func (_bdfd *CT_LightRig) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_ebaag, _bggge := _bdfd.RigAttr.MarshalXMLAttr(_g.Name{Local: "rig"})
	if _bggge != nil {
		return _bggge
	}
	start.Attr = append(start.Attr, _ebaag)
	_ebaag, _bggge = _bdfd.DirAttr.MarshalXMLAttr(_g.Name{Local: "dir"})
	if _bggge != nil {
		return _bggge
	}
	start.Attr = append(start.Attr, _ebaag)
	e.EncodeToken(start)
	if _bdfd.Rot != nil {
		_dbfae := _g.StartElement{Name: _g.Name{Local: "a:rot"}}
		e.EncodeElement(_bdfd.Rot, _dbfae)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_LightRig struct {
	RigAttr ST_LightRigType
	DirAttr ST_LightRigDirection
	Rot     *CT_SphereCoords
}

func (_dbdbd *ST_ColorSchemeIndex) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_dbdbd = 0
	case "dk1":
		*_dbdbd = 1
	case "lt1":
		*_dbdbd = 2
	case "dk2":
		*_dbdbd = 3
	case "lt2":
		*_dbdbd = 4
	case "accent1":
		*_dbdbd = 5
	case "accent2":
		*_dbdbd = 6
	case "accent3":
		*_dbdbd = 7
	case "accent4":
		*_dbdbd = 8
	case "accent5":
		*_dbdbd = 9
	case "accent6":
		*_dbdbd = 10
	case "hlink":
		*_dbdbd = 11
	case "folHlink":
		*_dbdbd = 12
	}
	return nil
}

// Validate validates the CT_Backdrop and its children
func (_eab *CT_Backdrop) Validate() error { return _eab.ValidateWithPath("CT_Backdrop") }
func (_edgad ST_TileFlipMode) ValidateWithPath(path string) error {
	switch _edgad {
	case 0, 1, 2, 3, 4:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_edgad))
	}
	return nil
}
func (_egeggc ST_LightRigDirection) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_egeggc.String(), start)
}
func (_adcg *ST_TextSpacingPercentOrPercentString) Validate() error {
	return _adcg.ValidateWithPath("")
}

// ValidateWithPath validates the CT_RegularTextRun and its children, prefixing error messages with path
func (_gafae *CT_RegularTextRun) ValidateWithPath(path string) error {
	if _gafae.RPr != nil {
		if _bffa := _gafae.RPr.ValidateWithPath(path + "\u002fRPr"); _bffa != nil {
			return _bffa
		}
	}
	return nil
}
func (_fcgf *CT_BaseStyles) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_dffc := _g.StartElement{Name: _g.Name{Local: "a:clrScheme"}}
	e.EncodeElement(_fcgf.ClrScheme, _dffc)
	_aaba := _g.StartElement{Name: _g.Name{Local: "a:fontScheme"}}
	e.EncodeElement(_fcgf.FontScheme, _aaba)
	_fagac := _g.StartElement{Name: _g.Name{Local: "a:fmtScheme"}}
	e.EncodeElement(_fcgf.FmtScheme, _fagac)
	if _fcgf.ExtLst != nil {
		_dafd := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_fcgf.ExtLst, _dafd)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_deeggb *ST_TextFontAlignType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fdfbg, _egcbc := d.Token()
	if _egcbc != nil {
		return _egcbc
	}
	if _adffc, _gfccbc := _fdfbg.(_g.EndElement); _gfccbc && _adffc.Name == start.Name {
		*_deeggb = 1
		return nil
	}
	if _geeefg, _efggf := _fdfbg.(_g.CharData); !_efggf {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fdfbg)
	} else {
		switch string(_geeefg) {
		case "":
			*_deeggb = 0
		case "auto":
			*_deeggb = 1
		case "t":
			*_deeggb = 2
		case "ctr":
			*_deeggb = 3
		case "base":
			*_deeggb = 4
		case "b":
			*_deeggb = 5
		}
	}
	_fdfbg, _egcbc = d.Token()
	if _egcbc != nil {
		return _egcbc
	}
	if _dfaab, _gccaa := _fdfbg.(_g.EndElement); _gccaa && _dfaab.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fdfbg)
}

// ValidateWithPath validates the CT_DuotoneEffect and its children, prefixing error messages with path
func (_fgddb *CT_DuotoneEffect) ValidateWithPath(path string) error {
	for _fcgd, _ffdg := range _fgddb.EG_ColorChoice {
		if _dbfa := _ffdg.ValidateWithPath(_dcf.Sprintf("%s\u002fEG_ColorChoice\u005b\u0025d\u005d", path, _fcgd)); _dbfa != nil {
			return _dbfa
		}
	}
	return nil
}
func NewCT_NonVisualPictureProperties() *CT_NonVisualPictureProperties {
	_egdfe := &CT_NonVisualPictureProperties{}
	return _egdfe
}
func NewCT_EmbeddedWAVAudioFile() *CT_EmbeddedWAVAudioFile {
	_cddbb := &CT_EmbeddedWAVAudioFile{}
	return _cddbb
}

type CT_ComplementTransform struct{}

func (_acac *CT_ColorChangeEffect) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_acac.ClrFrom = NewCT_Color()
	_acac.ClrTo = NewCT_Color()
	for _, _ggbd := range start.Attr {
		if _ggbd.Name.Local == "useA" {
			_afcd, _aabe := _e.ParseBool(_ggbd.Value)
			if _aabe != nil {
				return _aabe
			}
			_acac.UseAAttr = &_afcd
			continue
		}
	}
_ceba:
	for {
		_gdddf, _abgb := d.Token()
		if _abgb != nil {
			return _abgb
		}
		switch _fffd := _gdddf.(type) {
		case _g.StartElement:
			switch _fffd.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrFrom"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrFrom"}:
				if _dcef := d.DecodeElement(_acac.ClrFrom, &_fffd); _dcef != nil {
					return _dcef
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "clrTo"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "clrTo"}:
				if _fgfe := d.DecodeElement(_acac.ClrTo, &_fffd); _fgfe != nil {
					return _fgfe
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_ColorChangeEffect\u0020\u0025v", _fffd.Name)
				if _aaggef := d.Skip(); _aaggef != nil {
					return _aaggef
				}
			}
		case _g.EndElement:
			break _ceba
		case _g.CharData:
		}
	}
	return nil
}

type CT_GroupFillProperties struct{}
type CT_Path2DArcTo struct {
	WRAttr    ST_AdjCoordinate
	HRAttr    ST_AdjCoordinate
	StAngAttr ST_AdjAngle
	SwAngAttr ST_AdjAngle
}

// Validate validates the CT_ConnectorLocking and its children
func (_eddc *CT_ConnectorLocking) Validate() error {
	return _eddc.ValidateWithPath("CT_ConnectorLocking")
}
func (_aacf *CT_AnimationDgmBuildProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _aacf.BldAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "bld"}, Value: _dcf.Sprintf("\u0025v", *_aacf.BldAttr)})
	}
	if _aacf.RevAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "rev"}, Value: _dcf.Sprintf("\u0025d", _bfead(*_aacf.RevAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

type CT_Path2DCubicBezierTo struct{ Pt []*CT_AdjPoint2D }

func (_ceac *CT_ClipboardStyleSheet) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Name.Local = "a:CT_ClipboardStyleSheet"
	e.EncodeToken(start)
	_beeb := _g.StartElement{Name: _g.Name{Local: "a:themeElements"}}
	e.EncodeElement(_ceac.ThemeElements, _beeb)
	_gcbg := _g.StartElement{Name: _g.Name{Local: "a:clrMap"}}
	e.EncodeElement(_ceac.ClrMap, _gcbg)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_decba *EG_EffectProperties) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _decba.EffectLst != nil {
		_bedbb := _g.StartElement{Name: _g.Name{Local: "a:effectLst"}}
		e.EncodeElement(_decba.EffectLst, _bedbb)
	}
	if _decba.EffectDag != nil {
		_eecgce := _g.StartElement{Name: _g.Name{Local: "a:effectDag"}}
		e.EncodeElement(_decba.EffectDag, _eecgce)
	}
	return nil
}
func (_baee *CT_AnimationElementChoice) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_dac:
	for {
		_aag, _dddd := d.Token()
		if _dddd != nil {
			return _dddd
		}
		switch _bgeg := _aag.(type) {
		case _g.StartElement:
			switch _bgeg.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "dgm"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "dgm"}:
				_baee.Dgm = NewCT_AnimationDgmElement()
				if _egc := d.DecodeElement(_baee.Dgm, &_bgeg); _egc != nil {
					return _egc
				}
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "chart"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "chart"}:
				_baee.Chart = NewCT_AnimationChartElement()
				if _cfcc := d.DecodeElement(_baee.Chart, &_bgeg); _cfcc != nil {
					return _cfcc
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_AnimationElementChoice\u0020\u0025v", _bgeg.Name)
				if _gaf := d.Skip(); _gaf != nil {
					return _gaf
				}
			}
		case _g.EndElement:
			break _dac
		case _g.CharData:
		}
	}
	return nil
}

type CT_AlphaOutsetEffect struct{ RadAttr *ST_Coordinate }
type VideoFile struct{ CT_VideoFile }

// ValidateWithPath validates the CT_TextTabStopList and its children, prefixing error messages with path
func (_ddbcb *CT_TextTabStopList) ValidateWithPath(path string) error {
	for _faebd, _geaafc := range _ddbcb.Tab {
		if _fdcfc := _geaafc.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fTab\u005b\u0025d\u005d", path, _faebd)); _fdcfc != nil {
			return _fdcfc
		}
	}
	return nil
}
func (_ecgbgc *CT_TableCellBorderStyle) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _ecgbgc.Left != nil {
		_fbacb := _g.StartElement{Name: _g.Name{Local: "a:left"}}
		e.EncodeElement(_ecgbgc.Left, _fbacb)
	}
	if _ecgbgc.Right != nil {
		_efadf := _g.StartElement{Name: _g.Name{Local: "a:right"}}
		e.EncodeElement(_ecgbgc.Right, _efadf)
	}
	if _ecgbgc.Top != nil {
		_aacge := _g.StartElement{Name: _g.Name{Local: "a:top"}}
		e.EncodeElement(_ecgbgc.Top, _aacge)
	}
	if _ecgbgc.Bottom != nil {
		_aadaa := _g.StartElement{Name: _g.Name{Local: "a:bottom"}}
		e.EncodeElement(_ecgbgc.Bottom, _aadaa)
	}
	if _ecgbgc.InsideH != nil {
		_gbgfd := _g.StartElement{Name: _g.Name{Local: "a:insideH"}}
		e.EncodeElement(_ecgbgc.InsideH, _gbgfd)
	}
	if _ecgbgc.InsideV != nil {
		_gabfa := _g.StartElement{Name: _g.Name{Local: "a:insideV"}}
		e.EncodeElement(_ecgbgc.InsideV, _gabfa)
	}
	if _ecgbgc.Tl2br != nil {
		_bdbac := _g.StartElement{Name: _g.Name{Local: "a:tl2br"}}
		e.EncodeElement(_ecgbgc.Tl2br, _bdbac)
	}
	if _ecgbgc.Tr2bl != nil {
		_daadb := _g.StartElement{Name: _g.Name{Local: "a:tr2bl"}}
		e.EncodeElement(_ecgbgc.Tr2bl, _daadb)
	}
	if _ecgbgc.ExtLst != nil {
		_efgaa := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_ecgbgc.ExtLst, _efgaa)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_ConnectionSiteList and its children
func (_bcb *CT_ConnectionSiteList) Validate() error {
	return _bcb.ValidateWithPath("CT_ConnectionSiteList")
}
func NewEG_Media() *EG_Media { _ddab := &EG_Media{}; return _ddab }

type EG_ColorChoice struct {
	ScrgbClr  *CT_ScRgbColor
	SrgbClr   *CT_SRgbColor
	HslClr    *CT_HslColor
	SysClr    *CT_SystemColor
	SchemeClr *CT_SchemeColor
	PrstClr   *CT_PresetColor
}

func (_gbcgcf *VideoFile) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gbcgcf.CT_VideoFile = *NewCT_VideoFile()
	for _, _aeccg := range start.Attr {
		if _aeccg.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _aeccg.Name.Local == "link" || _aeccg.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _aeccg.Name.Local == "link" {
			_ddedg, _fgedf := _aeccg.Value, error(nil)
			if _fgedf != nil {
				return _fgedf
			}
			_gbcgcf.LinkAttr = _ddedg
			continue
		}
		if _aeccg.Name.Local == "contentType" {
			_ggffd, _ceaba := _aeccg.Value, error(nil)
			if _ceaba != nil {
				return _ceaba
			}
			_gbcgcf.ContentTypeAttr = &_ggffd
			continue
		}
	}
_ecbcg:
	for {
		_fbegg, _eaded := d.Token()
		if _eaded != nil {
			return _eaded
		}
		switch _egefe := _fbegg.(type) {
		case _g.StartElement:
			switch _egefe.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "extLst"}, _g.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "extLst"}:
				_gbcgcf.ExtLst = NewCT_OfficeArtExtensionList()
				if _eegcb := d.DecodeElement(_gbcgcf.ExtLst, &_egefe); _eegcb != nil {
					return _eegcb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on VideoFile \u0025v", _egefe.Name)
				if _afbfg := d.Skip(); _afbfg != nil {
					return _afbfg
				}
			}
		case _g.EndElement:
			break _ecbcg
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_Path2DMoveTo() *CT_Path2DMoveTo {
	_cafed := &CT_Path2DMoveTo{}
	_cafed.Pt = NewCT_AdjPoint2D()
	return _cafed
}
func (_adgg *ST_TextUnderlineType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cbadc, _cdcad := d.Token()
	if _cdcad != nil {
		return _cdcad
	}
	if _fffdc, _bddbe := _cbadc.(_g.EndElement); _bddbe && _fffdc.Name == start.Name {
		*_adgg = 1
		return nil
	}
	if _ecfad, _dfded := _cbadc.(_g.CharData); !_dfded {
		return _dcf.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cbadc)
	} else {
		switch string(_ecfad) {
		case "":
			*_adgg = 0
		case "none":
			*_adgg = 1
		case "words":
			*_adgg = 2
		case "sng":
			*_adgg = 3
		case "dbl":
			*_adgg = 4
		case "heavy":
			*_adgg = 5
		case "dotted":
			*_adgg = 6
		case "dottedHeavy":
			*_adgg = 7
		case "dash":
			*_adgg = 8
		case "dashHeavy":
			*_adgg = 9
		case "dashLong":
			*_adgg = 10
		case "dashLongHeavy":
			*_adgg = 11
		case "dotDash":
			*_adgg = 12
		case "dotDashHeavy":
			*_adgg = 13
		case "dotDotDash":
			*_adgg = 14
		case "dotDotDashHeavy":
			*_adgg = 15
		case "wavy":
			*_adgg = 16
		case "wavyHeavy":
			*_adgg = 17
		case "wavyDbl":
			*_adgg = 18
		}
	}
	_cbadc, _cdcad = d.Token()
	if _cdcad != nil {
		return _cdcad
	}
	if _abedg, _cbgbbe := _cbadc.(_g.EndElement); _cbgbbe && _abedg.Name == start.Name {
		return nil
	}
	return _dcf.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cbadc)
}

type CT_AlphaBiLevelEffect struct{ ThreshAttr ST_PositiveFixedPercentage }

// Validate validates the TblStyleLst and its children
func (_eaebga *TblStyleLst) Validate() error { return _eaebga.ValidateWithPath("TblStyleLst") }

// ValidateWithPath validates the CT_Shape3D and its children, prefixing error messages with path
func (_aaefa *CT_Shape3D) ValidateWithPath(path string) error {
	if _aaefa.ZAttr != nil {
		if _egaad := _aaefa.ZAttr.ValidateWithPath(path + "\u002fZAttr"); _egaad != nil {
			return _egaad
		}
	}
	if _aaefa.ExtrusionHAttr != nil {
		if *_aaefa.ExtrusionHAttr < 0 {
			return _dcf.Errorf("\u0025s\u002fm\u002eExtrusionHAttr\u0020must\u0020be\u0020\u003e\u003d\u00200\u0020(have\u0020\u0025v\u0029", path, *_aaefa.ExtrusionHAttr)
		}
		if *_aaefa.ExtrusionHAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s\u002fm\u002eExtrusionHAttr\u0020must\u0020be <\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_aaefa.ExtrusionHAttr)
		}
	}
	if _aaefa.ContourWAttr != nil {
		if *_aaefa.ContourWAttr < 0 {
			return _dcf.Errorf("%s\u002fm\u002eContourWAttr\u0020must\u0020be\u0020\u003e\u003d\u00200 (have\u0020%v\u0029", path, *_aaefa.ContourWAttr)
		}
		if *_aaefa.ContourWAttr > 27273042316900 {
			return _dcf.Errorf("\u0025s\u002fm\u002eContourWAttr\u0020must be\u0020\u003c\u003d\u002027273042316900\u0020\u0028have\u0020\u0025v\u0029", path, *_aaefa.ContourWAttr)
		}
	}
	if _ecdde := _aaefa.PrstMaterialAttr.ValidateWithPath(path + "\u002fPrstMaterialAttr"); _ecdde != nil {
		return _ecdde
	}
	if _aaefa.BevelT != nil {
		if _cbefba := _aaefa.BevelT.ValidateWithPath(path + "\u002fBevelT"); _cbefba != nil {
			return _cbefba
		}
	}
	if _aaefa.BevelB != nil {
		if _beefbd := _aaefa.BevelB.ValidateWithPath(path + "\u002fBevelB"); _beefbd != nil {
			return _beefbd
		}
	}
	if _aaefa.ExtrusionClr != nil {
		if _bdefc := _aaefa.ExtrusionClr.ValidateWithPath(path + "\u002fExtrusionClr"); _bdefc != nil {
			return _bdefc
		}
	}
	if _aaefa.ContourClr != nil {
		if _ggdagd := _aaefa.ContourClr.ValidateWithPath(path + "/ContourClr"); _ggdagd != nil {
			return _ggdagd
		}
	}
	if _aaefa.ExtLst != nil {
		if _eadcc := _aaefa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eadcc != nil {
			return _eadcc
		}
	}
	return nil
}
func (_dgbd *CT_ColorMapping) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	_cefd, _gfgc := _dgbd.Bg1Attr.MarshalXMLAttr(_g.Name{Local: "bg1"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	_cefd, _gfgc = _dgbd.Tx1Attr.MarshalXMLAttr(_g.Name{Local: "tx1"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	_cefd, _gfgc = _dgbd.Bg2Attr.MarshalXMLAttr(_g.Name{Local: "bg2"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	_cefd, _gfgc = _dgbd.Tx2Attr.MarshalXMLAttr(_g.Name{Local: "tx2"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	_cefd, _gfgc = _dgbd.Accent1Attr.MarshalXMLAttr(_g.Name{Local: "accent1"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	_cefd, _gfgc = _dgbd.Accent2Attr.MarshalXMLAttr(_g.Name{Local: "accent2"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	_cefd, _gfgc = _dgbd.Accent3Attr.MarshalXMLAttr(_g.Name{Local: "accent3"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	_cefd, _gfgc = _dgbd.Accent4Attr.MarshalXMLAttr(_g.Name{Local: "accent4"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	_cefd, _gfgc = _dgbd.Accent5Attr.MarshalXMLAttr(_g.Name{Local: "accent5"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	_cefd, _gfgc = _dgbd.Accent6Attr.MarshalXMLAttr(_g.Name{Local: "accent6"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	_cefd, _gfgc = _dgbd.HlinkAttr.MarshalXMLAttr(_g.Name{Local: "hlink"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	_cefd, _gfgc = _dgbd.FolHlinkAttr.MarshalXMLAttr(_g.Name{Local: "folHlink"})
	if _gfgc != nil {
		return _gfgc
	}
	start.Attr = append(start.Attr, _cefd)
	e.EncodeToken(start)
	if _dgbd.ExtLst != nil {
		_gbfde := _g.StartElement{Name: _g.Name{Local: "a:extLst"}}
		e.EncodeElement(_dgbd.ExtLst, _gbfde)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_GvmlTextShapeChoice and its children
func (_adae *CT_GvmlTextShapeChoice) Validate() error {
	return _adae.ValidateWithPath("CT_GvmlTextShapeChoice")
}

// ValidateWithPath validates the CT_LineStyleList and its children, prefixing error messages with path
func (_efcba *CT_LineStyleList) ValidateWithPath(path string) error {
	for _geagca, _gegc := range _efcba.Ln {
		if _fddae := _gegc.ValidateWithPath(_dcf.Sprintf("\u0025s\u002fLn\u005b\u0025d]", path, _geagca)); _fddae != nil {
			return _fddae
		}
	}
	return nil
}
func (_bdbfga *ST_OnOffStyleType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_bdbfga = 0
	case "on":
		*_bdbfga = 1
	case "off":
		*_bdbfga = 2
	case "def":
		*_bdbfga = 3
	}
	return nil
}
func (_fbbcf ST_TextUnderlineType) ValidateWithPath(path string) error {
	switch _fbbcf {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18:
	default:
		return _dcf.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fbbcf))
	}
	return nil
}
func (_geeb *CT_AudioCDTime) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "track"}, Value: _dcf.Sprintf("\u0025v", _geeb.TrackAttr)})
	if _geeb.TimeAttr != nil {
		start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "time"}, Value: _dcf.Sprintf("\u0025v", *_geeb.TimeAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_ddecb *CT_Headers) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_adddg := _g.StartElement{Name: _g.Name{Local: "a:header"}}
	for _, _gcff := range _ddecb.Header {
		e.EncodeElement(_gcff, _adddg)
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func init() {
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AudioFile", NewCT_AudioFile)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_VideoFile", NewCT_VideoFile)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_QuickTimeFile", NewCT_QuickTimeFile)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AudioCDTime", NewCT_AudioCDTime)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AudioCD", NewCT_AudioCD)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ColorScheme", NewCT_ColorScheme)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_CustomColor", NewCT_CustomColor)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_SupplementalFont", NewCT_SupplementalFont)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_CustomColorList", NewCT_CustomColorList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_FontCollection", NewCT_FontCollection)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_EffectStyleItem", NewCT_EffectStyleItem)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_FontScheme", NewCT_FontScheme)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_FillStyleList", NewCT_FillStyleList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_LineStyleList", NewCT_LineStyleList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_EffectStyleList", NewCT_EffectStyleList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_BackgroundFillStyleList", NewCT_BackgroundFillStyleList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_StyleMatrix", NewCT_StyleMatrix)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_BaseStyles", NewCT_BaseStyles)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_OfficeArtExtension", NewCT_OfficeArtExtension)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Angle", NewCT_Angle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PositiveFixedAngle", NewCT_PositiveFixedAngle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Percentage", NewCT_Percentage)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PositivePercentage", NewCT_PositivePercentage)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_FixedPercentage", NewCT_FixedPercentage)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PositiveFixedPercentage", NewCT_PositiveFixedPercentage)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Ratio", NewCT_Ratio)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Point2D", NewCT_Point2D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PositiveSize2D", NewCT_PositiveSize2D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ComplementTransform", NewCT_ComplementTransform)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_InverseTransform", NewCT_InverseTransform)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GrayscaleTransform", NewCT_GrayscaleTransform)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GammaTransform", NewCT_GammaTransform)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_InverseGammaTransform", NewCT_InverseGammaTransform)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ScRgbColor", NewCT_ScRgbColor)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_SRgbColor", NewCT_SRgbColor)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_HslColor", NewCT_HslColor)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_SystemColor", NewCT_SystemColor)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_SchemeColor", NewCT_SchemeColor)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PresetColor", NewCT_PresetColor)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_OfficeArtExtensionList", NewCT_OfficeArtExtensionList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Scale2D", NewCT_Scale2D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Transform2D", NewCT_Transform2D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GroupTransform2D", NewCT_GroupTransform2D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Point3D", NewCT_Point3D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Vector3D", NewCT_Vector3D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_SphereCoords", NewCT_SphereCoords)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_RelativeRect", NewCT_RelativeRect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Color", NewCT_Color)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ColorMRU", NewCT_ColorMRU)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_EmbeddedWAVAudioFile", NewCT_EmbeddedWAVAudioFile)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Hyperlink", NewCT_Hyperlink)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ConnectorLocking", NewCT_ConnectorLocking)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ShapeLocking", NewCT_ShapeLocking)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PictureLocking", NewCT_PictureLocking)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GroupLocking", NewCT_GroupLocking)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GraphicalObjectFrameLocking", NewCT_GraphicalObjectFrameLocking)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ContentPartLocking", NewCT_ContentPartLocking)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_NonVisualDrawingProps", NewCT_NonVisualDrawingProps)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_NonVisualDrawingShapeProps", NewCT_NonVisualDrawingShapeProps)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_NonVisualConnectorProperties", NewCT_NonVisualConnectorProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_NonVisualPictureProperties", NewCT_NonVisualPictureProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_NonVisualGroupDrawingShapeProps", NewCT_NonVisualGroupDrawingShapeProps)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_NonVisualGraphicFrameProperties", NewCT_NonVisualGraphicFrameProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_NonVisualContentPartProperties", NewCT_NonVisualContentPartProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GraphicalObjectData", NewCT_GraphicalObjectData)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GraphicalObject", NewCT_GraphicalObject)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AnimationDgmElement", NewCT_AnimationDgmElement)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AnimationChartElement", NewCT_AnimationChartElement)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AnimationElementChoice", NewCT_AnimationElementChoice)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AnimationDgmBuildProperties", NewCT_AnimationDgmBuildProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AnimationChartBuildProperties", NewCT_AnimationChartBuildProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AnimationGraphicalObjectBuildProperties", NewCT_AnimationGraphicalObjectBuildProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_BackgroundFormatting", NewCT_BackgroundFormatting)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_WholeE2oFormatting", NewCT_WholeE2oFormatting)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlUseShapeRectangle", NewCT_GvmlUseShapeRectangle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlTextShape", NewCT_GvmlTextShape)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlShapeNonVisual", NewCT_GvmlShapeNonVisual)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlShape", NewCT_GvmlShape)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlConnectorNonVisual", NewCT_GvmlConnectorNonVisual)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlConnector", NewCT_GvmlConnector)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlPictureNonVisual", NewCT_GvmlPictureNonVisual)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlPicture", NewCT_GvmlPicture)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlGraphicFrameNonVisual", NewCT_GvmlGraphicFrameNonVisual)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlGraphicalObjectFrame", NewCT_GvmlGraphicalObjectFrame)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlGroupShapeNonVisual", NewCT_GvmlGroupShapeNonVisual)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GvmlGroupShape", NewCT_GvmlGroupShape)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Camera", NewCT_Camera)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_LightRig", NewCT_LightRig)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Scene3D", NewCT_Scene3D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Backdrop", NewCT_Backdrop)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Bevel", NewCT_Bevel)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Shape3D", NewCT_Shape3D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_FlatText", NewCT_FlatText)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AlphaBiLevelEffect", NewCT_AlphaBiLevelEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AlphaCeilingEffect", NewCT_AlphaCeilingEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AlphaFloorEffect", NewCT_AlphaFloorEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AlphaInverseEffect", NewCT_AlphaInverseEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AlphaModulateFixedEffect", NewCT_AlphaModulateFixedEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AlphaOutsetEffect", NewCT_AlphaOutsetEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AlphaReplaceEffect", NewCT_AlphaReplaceEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_BiLevelEffect", NewCT_BiLevelEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_BlurEffect", NewCT_BlurEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ColorChangeEffect", NewCT_ColorChangeEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ColorReplaceEffect", NewCT_ColorReplaceEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_DuotoneEffect", NewCT_DuotoneEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GlowEffect", NewCT_GlowEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GrayscaleEffect", NewCT_GrayscaleEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_HSLEffect", NewCT_HSLEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_InnerShadowEffect", NewCT_InnerShadowEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_LuminanceEffect", NewCT_LuminanceEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_OuterShadowEffect", NewCT_OuterShadowEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PresetShadowEffect", NewCT_PresetShadowEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ReflectionEffect", NewCT_ReflectionEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_RelativeOffsetEffect", NewCT_RelativeOffsetEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_SoftEdgesEffect", NewCT_SoftEdgesEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TintEffect", NewCT_TintEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TransformEffect", NewCT_TransformEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_NoFillProperties", NewCT_NoFillProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_SolidColorFillProperties", NewCT_SolidColorFillProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_LinearShadeProperties", NewCT_LinearShadeProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PathShadeProperties", NewCT_PathShadeProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GradientStop", NewCT_GradientStop)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GradientStopList", NewCT_GradientStopList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GradientFillProperties", NewCT_GradientFillProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TileInfoProperties", NewCT_TileInfoProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_StretchInfoProperties", NewCT_StretchInfoProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Blip", NewCT_Blip)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_BlipFillProperties", NewCT_BlipFillProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PatternFillProperties", NewCT_PatternFillProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GroupFillProperties", NewCT_GroupFillProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_FillProperties", NewCT_FillProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_FillEffect", NewCT_FillEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_FillOverlayEffect", NewCT_FillOverlayEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_EffectReference", NewCT_EffectReference)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_EffectContainer", NewCT_EffectContainer)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AlphaModulateEffect", NewCT_AlphaModulateEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_BlendEffect", NewCT_BlendEffect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_EffectList", NewCT_EffectList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_EffectProperties", NewCT_EffectProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GeomGuide", NewCT_GeomGuide)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GeomGuideList", NewCT_GeomGuideList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AdjPoint2D", NewCT_AdjPoint2D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GeomRect", NewCT_GeomRect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_XYAdjustHandle", NewCT_XYAdjustHandle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PolarAdjustHandle", NewCT_PolarAdjustHandle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ConnectionSite", NewCT_ConnectionSite)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_AdjustHandleList", NewCT_AdjustHandleList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ConnectionSiteList", NewCT_ConnectionSiteList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Connection", NewCT_Connection)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Path2DMoveTo", NewCT_Path2DMoveTo)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Path2DLineTo", NewCT_Path2DLineTo)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Path2DArcTo", NewCT_Path2DArcTo)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Path2DQuadBezierTo", NewCT_Path2DQuadBezierTo)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Path2DCubicBezierTo", NewCT_Path2DCubicBezierTo)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Path2DClose", NewCT_Path2DClose)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Path2D", NewCT_Path2D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Path2DList", NewCT_Path2DList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PresetGeometry2D", NewCT_PresetGeometry2D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PresetTextShape", NewCT_PresetTextShape)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_CustomGeometry2D", NewCT_CustomGeometry2D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_LineEndProperties", NewCT_LineEndProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_LineJoinBevel", NewCT_LineJoinBevel)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_LineJoinRound", NewCT_LineJoinRound)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_LineJoinMiterProperties", NewCT_LineJoinMiterProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_PresetLineDashProperties", NewCT_PresetLineDashProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_DashStop", NewCT_DashStop)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_DashStopList", NewCT_DashStopList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_LineProperties", NewCT_LineProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ShapeProperties", NewCT_ShapeProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_GroupShapeProperties", NewCT_GroupShapeProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_StyleMatrixReference", NewCT_StyleMatrixReference)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_FontReference", NewCT_FontReference)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ShapeStyle", NewCT_ShapeStyle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_DefaultShapeDefinition", NewCT_DefaultShapeDefinition)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ObjectStyleDefaults", NewCT_ObjectStyleDefaults)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_EmptyElement", NewCT_EmptyElement)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ColorMapping", NewCT_ColorMapping)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ColorMappingOverride", NewCT_ColorMappingOverride)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ColorSchemeAndMapping", NewCT_ColorSchemeAndMapping)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ColorSchemeList", NewCT_ColorSchemeList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_OfficeStyleSheet", NewCT_OfficeStyleSheet)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_BaseStylesOverride", NewCT_BaseStylesOverride)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ClipboardStyleSheet", NewCT_ClipboardStyleSheet)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableCellProperties", NewCT_TableCellProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Headers", NewCT_Headers)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableCol", NewCT_TableCol)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableGrid", NewCT_TableGrid)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableCell", NewCT_TableCell)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableRow", NewCT_TableRow)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableProperties", NewCT_TableProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Table", NewCT_Table)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Cell3D", NewCT_Cell3D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_ThemeableLineStyle", NewCT_ThemeableLineStyle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableStyleTextStyle", NewCT_TableStyleTextStyle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableCellBorderStyle", NewCT_TableCellBorderStyle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableBackgroundStyle", NewCT_TableBackgroundStyle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableStyleCellStyle", NewCT_TableStyleCellStyle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TablePartStyle", NewCT_TablePartStyle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableStyle", NewCT_TableStyle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TableStyleList", NewCT_TableStyleList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextParagraph", NewCT_TextParagraph)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextListStyle", NewCT_TextListStyle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextNormalAutofit", NewCT_TextNormalAutofit)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextShapeAutofit", NewCT_TextShapeAutofit)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextNoAutofit", NewCT_TextNoAutofit)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextBodyProperties", NewCT_TextBodyProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextBody", NewCT_TextBody)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextBulletColorFollowText", NewCT_TextBulletColorFollowText)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextBulletSizeFollowText", NewCT_TextBulletSizeFollowText)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextBulletSizePercent", NewCT_TextBulletSizePercent)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextBulletSizePoint", NewCT_TextBulletSizePoint)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextBulletTypefaceFollowText", NewCT_TextBulletTypefaceFollowText)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextAutonumberBullet", NewCT_TextAutonumberBullet)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextCharBullet", NewCT_TextCharBullet)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextBlipBullet", NewCT_TextBlipBullet)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextNoBullet", NewCT_TextNoBullet)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextFont", NewCT_TextFont)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextUnderlineLineFollowText", NewCT_TextUnderlineLineFollowText)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextUnderlineFillFollowText", NewCT_TextUnderlineFillFollowText)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextUnderlineFillGroupWrapper", NewCT_TextUnderlineFillGroupWrapper)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextCharacterProperties", NewCT_TextCharacterProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_Boolean", NewCT_Boolean)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextSpacingPercent", NewCT_TextSpacingPercent)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextSpacingPoint", NewCT_TextSpacingPoint)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextTabStop", NewCT_TextTabStop)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextTabStopList", NewCT_TextTabStopList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextLineBreak", NewCT_TextLineBreak)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextSpacing", NewCT_TextSpacing)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextParagraphProperties", NewCT_TextParagraphProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_TextField", NewCT_TextField)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "CT_RegularTextRun", NewCT_RegularTextRun)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "videoFile", NewVideoFile)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "graphic", NewGraphic)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "blip", NewBlip)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "theme", NewTheme)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "themeOverride", NewThemeOverride)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "themeManager", NewThemeManager)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "tbl", NewTbl)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "tblStyleLst", NewTblStyleLst)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_Media", NewEG_Media)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_ColorTransform", NewEG_ColorTransform)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_OfficeArtExtensionList", NewEG_OfficeArtExtensionList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_ColorChoice", NewEG_ColorChoice)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_Text3D", NewEG_Text3D)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_ShadeProperties", NewEG_ShadeProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_FillModeProperties", NewEG_FillModeProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_FillProperties", NewEG_FillProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_Effect", NewEG_Effect)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_EffectProperties", NewEG_EffectProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_Geometry", NewEG_Geometry)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_TextGeometry", NewEG_TextGeometry)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_LineFillProperties", NewEG_LineFillProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_LineJoinProperties", NewEG_LineJoinProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_LineDashProperties", NewEG_LineDashProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_ThemeableFillStyle", NewEG_ThemeableFillStyle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_ThemeableEffectStyle", NewEG_ThemeableEffectStyle)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_ThemeableFontStyles", NewEG_ThemeableFontStyles)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_TextAutofit", NewEG_TextAutofit)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_TextBulletColor", NewEG_TextBulletColor)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_TextBulletSize", NewEG_TextBulletSize)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_TextBulletTypeface", NewEG_TextBulletTypeface)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_TextBullet", NewEG_TextBullet)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_TextUnderlineLine", NewEG_TextUnderlineLine)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_TextUnderlineFill", NewEG_TextUnderlineFill)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "EG_TextRun", NewEG_TextRun)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "AG_Blob", NewAG_Blob)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", "AG_Locking", NewAG_Locking)
}
