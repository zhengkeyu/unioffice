//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package diagram

import (
	_b "encoding/xml"
	_a "fmt"
	_ea "gitee.com/greatmusicians/unioffice"
	_f "gitee.com/greatmusicians/unioffice/schema/soo/dml"
	_d "strconv"
)

func (_bcab ST_LinearDirection) ValidateWithPath(path string) error {
	switch _bcab {
	case 0, 1, 2, 3, 4:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bcab))
	}
	return nil
}
func (_ebecb ST_VariableType) String() string {
	switch _ebecb {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "orgChart"
	case 3:
		return "chMax"
	case 4:
		return "chPref"
	case 5:
		return "bulEnabled"
	case 6:
		return "dir"
	case 7:
		return "hierBranch"
	case 8:
		return "animOne"
	case 9:
		return "animLvl"
	case 10:
		return "resizeHandles"
	}
	return ""
}

type CT_CTCategory struct {
	TypeAttr string
	PriAttr  uint32
}

// Validate validates the CT_ElemPropSet and its children
func (_gffd *CT_ElemPropSet) Validate() error { return _gffd.ValidateWithPath("CT_ElemPropSet") }

type ST_AlgorithmType byte

func (_fcc *CT_ColorTransformHeaderLst) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _fcc.ColorsDefHdr != nil {
		_edfa := _b.StartElement{Name: _b.Name{Local: "colorsDefHdr"}}
		for _, _dfcf := range _fcc.ColorsDefHdr {
			e.EncodeElement(_dfcf, _edfa)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_cabfb ST_ModelId) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _cabfb.Int32 != nil {
		e.EncodeToken(_b.CharData(_a.Sprintf("\u0025d", *_cabfb.Int32)))
	}
	if _cabfb.ST_Guid != nil {
		e.EncodeToken(_b.CharData(*_cabfb.ST_Guid))
	}
	return e.EncodeToken(_b.EndElement{Name: start.Name})
}
func (_fb *AG_ConstraintAttributes) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dg := range start.Attr {
		if _dg.Name.Local == "type" {
			_fb.TypeAttr.UnmarshalXMLAttr(_dg)
			continue
		}
		if _dg.Name.Local == "for" {
			_fb.ForAttr.UnmarshalXMLAttr(_dg)
			continue
		}
		if _dg.Name.Local == "forName" {
			_fd, _dgd := _dg.Value, error(nil)
			if _dgd != nil {
				return _dgd
			}
			_fb.ForNameAttr = &_fd
			continue
		}
		if _dg.Name.Local == "ptType" {
			_fb.PtTypeAttr.UnmarshalXMLAttr(_dg)
			continue
		}
	}
	for {
		_ccb, _ccg := d.Token()
		if _ccg != nil {
			return _a.Errorf("parsing AG_ConstraintAttributes:\u0020%s", _ccg)
		}
		if _bg, _gc := _ccb.(_b.EndElement); _gc && _bg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bdad ST_ChildOrderType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bdad.String(), start)
}
func (_bfbd ST_ChildAlignment) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_geac := _b.Attr{}
	_geac.Name = name
	switch _bfbd {
	case ST_ChildAlignmentUnset:
		_geac.Value = ""
	case ST_ChildAlignmentT:
		_geac.Value = "t"
	case ST_ChildAlignmentB:
		_geac.Value = "b"
	case ST_ChildAlignmentL:
		_geac.Value = "l"
	case ST_ChildAlignmentR:
		_geac.Value = "r"
	}
	return _geac, nil
}
func (_gae *CT_CTDescription) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _gae.LangAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "lang"}, Value: _a.Sprintf("\u0025v", *_gae.LangAttr)})
	}
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", _gae.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_CTDescription and its children, prefixing error messages with path
func (_eefc *CT_CTDescription) ValidateWithPath(path string) error { return nil }
func NewCT_Constraints() *CT_Constraints                           { _ddgb := &CT_Constraints{}; return _ddgb }

// Validate validates the StyleDefHdr and its children
func (_efbe *StyleDefHdr) Validate() error { return _efbe.ValidateWithPath("StyleDefHdr") }
func (_gfgeb *CT_TextProps) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_gad:
	for {
		_edfbd, _bbad := d.Token()
		if _bbad != nil {
			return _bbad
		}
		switch _cgge := _edfbd.(type) {
		case _b.StartElement:
			switch _cgge.Name {
			case _b.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "sp3d"}, _b.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "sp3d"}:
				_gfgeb.Sp3d = _f.NewCT_Shape3D()
				if _gcae := d.DecodeElement(_gfgeb.Sp3d, &_cgge); _gcae != nil {
					return _gcae
				}
			case _b.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "flatTx"}, _b.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "flatTx"}:
				_gfgeb.FlatTx = _f.NewCT_FlatText()
				if _bgfe := d.DecodeElement(_gfgeb.FlatTx, &_cgge); _bgfe != nil {
					return _bgfe
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TextProps\u0020\u0025v", _cgge.Name)
				if _cdeag := d.Skip(); _cdeag != nil {
					return _cdeag
				}
			}
		case _b.EndElement:
			break _gad
		case _b.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Constraints and its children
func (_gegb *CT_Constraints) Validate() error { return _gegb.ValidateWithPath("CT_Constraints") }
func (_aegb *LayoutDefHdrLst) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:di"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "layoutDefHdrLst"
	return _aegb.CT_DiagramDefinitionHeaderLst.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_CTStyleLabel and its children, prefixing error messages with path
func (_eegg *CT_CTStyleLabel) ValidateWithPath(path string) error {
	if _eegg.FillClrLst != nil {
		if _cggd := _eegg.FillClrLst.ValidateWithPath(path + "/FillClrLst"); _cggd != nil {
			return _cggd
		}
	}
	if _eegg.LinClrLst != nil {
		if _gdbf := _eegg.LinClrLst.ValidateWithPath(path + "\u002fLinClrLst"); _gdbf != nil {
			return _gdbf
		}
	}
	if _eegg.EffectClrLst != nil {
		if _bdea := _eegg.EffectClrLst.ValidateWithPath(path + "\u002fEffectClrLst"); _bdea != nil {
			return _bdea
		}
	}
	if _eegg.TxLinClrLst != nil {
		if _begd := _eegg.TxLinClrLst.ValidateWithPath(path + "\u002fTxLinClrLst"); _begd != nil {
			return _begd
		}
	}
	if _eegg.TxFillClrLst != nil {
		if _eega := _eegg.TxFillClrLst.ValidateWithPath(path + "\u002fTxFillClrLst"); _eega != nil {
			return _eega
		}
	}
	if _eegg.TxEffectClrLst != nil {
		if _cdea := _eegg.TxEffectClrLst.ValidateWithPath(path + "\u002fTxEffectClrLst"); _cdea != nil {
			return _cdea
		}
	}
	if _eegg.ExtLst != nil {
		if _ece := _eegg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ece != nil {
			return _ece
		}
	}
	return nil
}
func NewCT_Direction() *CT_Direction { _faec := &CT_Direction{}; return _faec }

type ST_ChildAlignment byte

func ParseSliceST_Ints(s string) (ST_Ints, error) { return ST_Ints{}, nil }
func (_gfab *CT_Colors) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _gfab.MethAttr != ST_ClrAppMethodUnset {
		_efg, _cbef := _gfab.MethAttr.MarshalXMLAttr(_b.Name{Local: "meth"})
		if _cbef != nil {
			return _cbef
		}
		start.Attr = append(start.Attr, _efg)
	}
	if _gfab.HueDirAttr != ST_HueDirUnset {
		_bgab, _egga := _gfab.HueDirAttr.MarshalXMLAttr(_b.Name{Local: "hueDir"})
		if _egga != nil {
			return _egga
		}
		start.Attr = append(start.Attr, _bgab)
	}
	e.EncodeToken(start)
	if _gfab.EG_ColorChoice != nil {
		for _, _ecgf := range _gfab.EG_ColorChoice {
			_ecgf.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

const (
	ST_AnimOneStrUnset  ST_AnimOneStr = 0
	ST_AnimOneStrNone   ST_AnimOneStr = 1
	ST_AnimOneStrOne    ST_AnimOneStr = 2
	ST_AnimOneStrBranch ST_AnimOneStr = 3
)

func (_ddaef *CT_ResizeHandles) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ddaef.ValAttr != ST_ResizeHandlesStrUnset {
		_dgbg, _cacc := _ddaef.ValAttr.MarshalXMLAttr(_b.Name{Local: "val"})
		if _cacc != nil {
			return _cacc
		}
		start.Attr = append(start.Attr, _dgbg)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_bcdac ST_StartingElement) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_cedf := _b.Attr{}
	_cedf.Name = name
	switch _bcdac {
	case ST_StartingElementUnset:
		_cedf.Value = ""
	case ST_StartingElementNode:
		_cedf.Value = "node"
	case ST_StartingElementTrans:
		_cedf.Value = "trans"
	}
	return _cedf, nil
}
func (_dadf ST_ChildOrderType) String() string {
	switch _dadf {
	case 0:
		return ""
	case 1:
		return "b"
	case 2:
		return "t"
	}
	return ""
}
func (_ecfdc *StyleDefHdrLst) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:di"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "styleDefHdrLst"
	return _ecfdc.CT_StyleDefinitionHeaderLst.MarshalXML(e, start)
}
func (_eefee ST_RotationPath) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_afbd := _b.Attr{}
	_afbd.Name = name
	switch _eefee {
	case ST_RotationPathUnset:
		_afbd.Value = ""
	case ST_RotationPathNone:
		_afbd.Value = "none"
	case ST_RotationPathAlongPath:
		_afbd.Value = "alongPath"
	}
	return _afbd, nil
}
func NewCT_DiagramDefinitionHeader() *CT_DiagramDefinitionHeader {
	_aceb := &CT_DiagramDefinitionHeader{}
	return _aceb
}

type CT_Otherwise struct {
	NameAttr   *string
	Alg        []*CT_Algorithm
	Shape      []*CT_Shape
	PresOf     []*CT_PresentationOf
	ConstrLst  []*CT_Constraints
	RuleLst    []*CT_Rules
	ForEach    []*CT_ForEach
	LayoutNode []*CT_LayoutNode
	Choose     []*CT_Choose
	ExtLst     []*_f.CT_OfficeArtExtensionList
}

const (
	ST_StartingElementUnset ST_StartingElement = 0
	ST_StartingElementNode  ST_StartingElement = 1
	ST_StartingElementTrans ST_StartingElement = 2
)

type CT_ColorTransformHeader struct {
	UniqueIdAttr string
	MinVerAttr   *string
	ResIdAttr    *int32
	Title        []*CT_CTName
	Desc         []*CT_CTDescription
	CatLst       *CT_CTCategories
	ExtLst       *_f.CT_OfficeArtExtensionList
}

func NewCT_CTCategory() *CT_CTCategory { _cce := &CT_CTCategory{}; return _cce }

// Validate validates the CT_StyleDefinition and its children
func (_dacgb *CT_StyleDefinition) Validate() error {
	return _dacgb.ValidateWithPath("CT_StyleDefinition")
}
func (_aebdf ST_VariableType) Validate() error { return _aebdf.ValidateWithPath("") }

// ValidateWithPath validates the CT_Description and its children, prefixing error messages with path
func (_dbec *CT_Description) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_TextProps and its children
func (_ebcf *CT_TextProps) Validate() error { return _ebcf.ValidateWithPath("CT_TextProps") }

// ValidateWithPath validates the CT_CTName and its children, prefixing error messages with path
func (_gdd *CT_CTName) ValidateWithPath(path string) error { return nil }

const (
	ST_TextAnchorVerticalUnset ST_TextAnchorVertical = 0
	ST_TextAnchorVerticalT     ST_TextAnchorVertical = 1
	ST_TextAnchorVerticalMid   ST_TextAnchorVertical = 2
	ST_TextAnchorVerticalB     ST_TextAnchorVertical = 3
)

func (_afged ST_FunctionValue) String() string {
	if _afged.Int32 != nil {
		return _a.Sprintf("\u0025v", *_afged.Int32)
	}
	if _afged.Bool != nil {
		return _a.Sprintf("\u0025v", *_afged.Bool)
	}
	if _afged.ST_Direction != ST_DirectionUnset {
		return _afged.ST_Direction.String()
	}
	if _afged.ST_HierBranchStyle != ST_HierBranchStyleUnset {
		return _afged.ST_HierBranchStyle.String()
	}
	if _afged.ST_AnimOneStr != ST_AnimOneStrUnset {
		return _afged.ST_AnimOneStr.String()
	}
	if _afged.ST_AnimLvlStr != ST_AnimLvlStrUnset {
		return _afged.ST_AnimLvlStr.String()
	}
	if _afged.ST_ResizeHandlesStr != ST_ResizeHandlesStrUnset {
		return _afged.ST_ResizeHandlesStr.String()
	}
	return ""
}

type ST_VerticalAlignment byte

const (
	ST_ChildAlignmentUnset ST_ChildAlignment = 0
	ST_ChildAlignmentT     ST_ChildAlignment = 1
	ST_ChildAlignmentB     ST_ChildAlignment = 2
	ST_ChildAlignmentL     ST_ChildAlignment = 3
	ST_ChildAlignmentR     ST_ChildAlignment = 4
)

func (_abcf *ST_PyramidAccentPosition) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_acab, _ecad := d.Token()
	if _ecad != nil {
		return _ecad
	}
	if _defac, _bfbda := _acab.(_b.EndElement); _bfbda && _defac.Name == start.Name {
		*_abcf = 1
		return nil
	}
	if _agfdg, _geffb := _acab.(_b.CharData); !_geffb {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _acab)
	} else {
		switch string(_agfdg) {
		case "":
			*_abcf = 0
		case "bef":
			*_abcf = 1
		case "aft":
			*_abcf = 2
		}
	}
	_acab, _ecad = d.Token()
	if _ecad != nil {
		return _ecad
	}
	if _efebd, _fdcgc := _acab.(_b.EndElement); _fdcgc && _efebd.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _acab)
}
func NewCT_StyleLabel() *CT_StyleLabel { _ffbc := &CT_StyleLabel{}; return _ffbc }

// ST_LayoutShapeType is a union type
type ST_LayoutShapeType struct {
	ST_ShapeType       _f.ST_ShapeType
	ST_OutputShapeType ST_OutputShapeType
}

func (_gccf *CT_ColorTransformHeaderLst) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_fcdd:
	for {
		_agf, _eaba := d.Token()
		if _eaba != nil {
			return _eaba
		}
		switch _fggg := _agf.(type) {
		case _b.StartElement:
			switch _fggg.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "colorsDefHdr"}:
				_fccg := NewCT_ColorTransformHeader()
				if _bea := d.DecodeElement(_fccg, &_fggg); _bea != nil {
					return _bea
				}
				_gccf.ColorsDefHdr = append(_gccf.ColorsDefHdr, _fccg)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ColorTransformHeaderLst\u0020\u0025v", _fggg.Name)
				if _cggc := d.Skip(); _cggc != nil {
					return _cggc
				}
			}
		case _b.EndElement:
			break _fcdd
		case _b.CharData:
		}
	}
	return nil
}
func (_gebcb ST_ElementType) String() string {
	switch _gebcb {
	case 0:
		return ""
	case 1:
		return "all"
	case 2:
		return "doc"
	case 3:
		return "node"
	case 4:
		return "norm"
	case 5:
		return "nonNorm"
	case 6:
		return "asst"
	case 7:
		return "nonAsst"
	case 8:
		return "parTrans"
	case 9:
		return "pres"
	case 10:
		return "sibTrans"
	}
	return ""
}
func (_eedf *ST_ChildDirection) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_edda, _eafeb := d.Token()
	if _eafeb != nil {
		return _eafeb
	}
	if _fcdg, _bedgc := _edda.(_b.EndElement); _bedgc && _fcdg.Name == start.Name {
		*_eedf = 1
		return nil
	}
	if _gadbb, _ggga := _edda.(_b.CharData); !_ggga {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _edda)
	} else {
		switch string(_gadbb) {
		case "":
			*_eedf = 0
		case "horz":
			*_eedf = 1
		case "vert":
			*_eedf = 2
		}
	}
	_edda, _eafeb = d.Token()
	if _eafeb != nil {
		return _eafeb
	}
	if _bgeed, _fcaf := _edda.(_b.EndElement); _fcaf && _bgeed.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _edda)
}
func (_faeee ST_FlowDirection) Validate() error { return _faeee.ValidateWithPath("") }

// ST_ParameterVal is a union type
type ST_ParameterVal struct {
	ST_DiagramHorizontalAlignment ST_DiagramHorizontalAlignment
	ST_VerticalAlignment          ST_VerticalAlignment
	ST_ChildDirection             ST_ChildDirection
	ST_ChildAlignment             ST_ChildAlignment
	ST_SecondaryChildAlignment    ST_SecondaryChildAlignment
	ST_LinearDirection            ST_LinearDirection
	ST_SecondaryLinearDirection   ST_SecondaryLinearDirection
	ST_StartingElement            ST_StartingElement
	ST_BendPoint                  ST_BendPoint
	ST_ConnectorRouting           ST_ConnectorRouting
	ST_ArrowheadStyle             ST_ArrowheadStyle
	ST_ConnectorDimension         ST_ConnectorDimension
	ST_RotationPath               ST_RotationPath
	ST_CenterShapeMapping         ST_CenterShapeMapping
	ST_NodeHorizontalAlignment    ST_NodeHorizontalAlignment
	ST_NodeVerticalAlignment      ST_NodeVerticalAlignment
	ST_FallbackDimension          ST_FallbackDimension
	ST_TextDirection              ST_TextDirection
	ST_PyramidAccentPosition      ST_PyramidAccentPosition
	ST_PyramidAccentTextMargin    ST_PyramidAccentTextMargin
	ST_TextBlockDirection         ST_TextBlockDirection
	ST_TextAnchorHorizontal       ST_TextAnchorHorizontal
	ST_TextAnchorVertical         ST_TextAnchorVertical
	ST_DiagramTextAlignment       ST_DiagramTextAlignment
	ST_AutoTextRotation           ST_AutoTextRotation
	ST_GrowDirection              ST_GrowDirection
	ST_FlowDirection              ST_FlowDirection
	ST_ContinueDirection          ST_ContinueDirection
	ST_Breakpoint                 ST_Breakpoint
	ST_Offset                     ST_Offset
	ST_HierarchyAlignment         ST_HierarchyAlignment
	Int32                         *int32
	Float64                       *float64
	Bool                          *bool
	StringVal                     *string
	ST_ConnectorPoint             ST_ConnectorPoint
}

func NewCT_LayoutVariablePropertySet() *CT_LayoutVariablePropertySet {
	_gebd := &CT_LayoutVariablePropertySet{}
	return _gebd
}
func (_dfdbb *StyleDef) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dfdbb.CT_StyleDefinition = *NewCT_StyleDefinition()
	for _, _bbee := range start.Attr {
		if _bbee.Name.Local == "uniqueId" {
			_bdgd, _ecgbc := _bbee.Value, error(nil)
			if _ecgbc != nil {
				return _ecgbc
			}
			_dfdbb.UniqueIdAttr = &_bdgd
			continue
		}
		if _bbee.Name.Local == "minVer" {
			_bgea, _ebce := _bbee.Value, error(nil)
			if _ebce != nil {
				return _ebce
			}
			_dfdbb.MinVerAttr = &_bgea
			continue
		}
	}
_gbgdd:
	for {
		_cead, _gccfd := d.Token()
		if _gccfd != nil {
			return _gccfd
		}
		switch _bedge := _cead.(type) {
		case _b.StartElement:
			switch _bedge.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_ggbfdf := NewCT_SDName()
				if _cffdb := d.DecodeElement(_ggbfdf, &_bedge); _cffdb != nil {
					return _cffdb
				}
				_dfdbb.Title = append(_dfdbb.Title, _ggbfdf)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_dfbf := NewCT_SDDescription()
				if _bggf := d.DecodeElement(_dfbf, &_bedge); _bggf != nil {
					return _bggf
				}
				_dfdbb.Desc = append(_dfdbb.Desc, _dfbf)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_dfdbb.CatLst = NewCT_SDCategories()
				if _dbeg := d.DecodeElement(_dfdbb.CatLst, &_bedge); _dbeg != nil {
					return _dbeg
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "scene3d"}:
				_dfdbb.Scene3d = _f.NewCT_Scene3D()
				if _fbag := d.DecodeElement(_dfdbb.Scene3d, &_bedge); _fbag != nil {
					return _fbag
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "styleLbl"}:
				_bdbef := NewCT_StyleLabel()
				if _ddgf := d.DecodeElement(_bdbef, &_bedge); _ddgf != nil {
					return _ddgf
				}
				_dfdbb.StyleLbl = append(_dfdbb.StyleLbl, _bdbef)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_dfdbb.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _dgdb := d.DecodeElement(_dfdbb.ExtLst, &_bedge); _dgdb != nil {
					return _dgdb
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020StyleDef\u0020\u0025v", _bedge.Name)
				if _fcfga := d.Skip(); _fcfga != nil {
					return _fcfga
				}
			}
		case _b.EndElement:
			break _gbgdd
		case _b.CharData:
		}
	}
	return nil
}
func (_gedgf ST_HierarchyAlignment) String() string {
	switch _gedgf {
	case 0:
		return ""
	case 1:
		return "tL"
	case 2:
		return "tR"
	case 3:
		return "tCtrCh"
	case 4:
		return "tCtrDes"
	case 5:
		return "bL"
	case 6:
		return "bR"
	case 7:
		return "bCtrCh"
	case 8:
		return "bCtrDes"
	case 9:
		return "lT"
	case 10:
		return "lB"
	case 11:
		return "lCtrCh"
	case 12:
		return "lCtrDes"
	case 13:
		return "rT"
	case 14:
		return "rB"
	case 15:
		return "rCtrCh"
	case 16:
		return "rCtrDes"
	}
	return ""
}
func NewDataModel() *DataModel {
	_fcfeg := &DataModel{}
	_fcfeg.CT_DataModel = *NewCT_DataModel()
	return _fcfeg
}
func (_cgfa *ST_CxnType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ccbc, _cggda := d.Token()
	if _cggda != nil {
		return _cggda
	}
	if _gfaf, _bccga := _ccbc.(_b.EndElement); _bccga && _gfaf.Name == start.Name {
		*_cgfa = 1
		return nil
	}
	if _dgba, _febd := _ccbc.(_b.CharData); !_febd {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ccbc)
	} else {
		switch string(_dgba) {
		case "":
			*_cgfa = 0
		case "parOf":
			*_cgfa = 1
		case "presOf":
			*_cgfa = 2
		case "presParOf":
			*_cgfa = 3
		case "unknownRelationship":
			*_cgfa = 4
		}
	}
	_ccbc, _cggda = d.Token()
	if _cggda != nil {
		return _cggda
	}
	if _dcecg, _bcffd := _ccbc.(_b.EndElement); _bcffd && _dcecg.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ccbc)
}
func (_edb *CT_ColorTransformHeader) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "uniqueId"}, Value: _a.Sprintf("\u0025v", _edb.UniqueIdAttr)})
	if _edb.MinVerAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "minVer"}, Value: _a.Sprintf("\u0025v", *_edb.MinVerAttr)})
	}
	if _edb.ResIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "resId"}, Value: _a.Sprintf("\u0025v", *_edb.ResIdAttr)})
	}
	e.EncodeToken(start)
	_acdc := _b.StartElement{Name: _b.Name{Local: "title"}}
	for _, _bfdga := range _edb.Title {
		e.EncodeElement(_bfdga, _acdc)
	}
	_gdbc := _b.StartElement{Name: _b.Name{Local: "desc"}}
	for _, _bagd := range _edb.Desc {
		e.EncodeElement(_bagd, _gdbc)
	}
	if _edb.CatLst != nil {
		_bbe := _b.StartElement{Name: _b.Name{Local: "catLst"}}
		e.EncodeElement(_edb.CatLst, _bbe)
	}
	if _edb.ExtLst != nil {
		_bba := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_edb.ExtLst, _bba)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the ColorsDefHdrLst and its children, prefixing error messages with path
func (_ccgdc *ColorsDefHdrLst) ValidateWithPath(path string) error {
	if _fafa := _ccgdc.CT_ColorTransformHeaderLst.ValidateWithPath(path); _fafa != nil {
		return _fafa
	}
	return nil
}
func (_edgd ST_AutoTextRotation) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_fcfed := _b.Attr{}
	_fcfed.Name = name
	switch _edgd {
	case ST_AutoTextRotationUnset:
		_fcfed.Value = ""
	case ST_AutoTextRotationNone:
		_fcfed.Value = "none"
	case ST_AutoTextRotationUpr:
		_fcfed.Value = "upr"
	case ST_AutoTextRotationGrav:
		_fcfed.Value = "grav"
	}
	return _fcfed, nil
}

// ValidateWithPath validates the CT_Cxn and its children, prefixing error messages with path
func (_fcce *CT_Cxn) ValidateWithPath(path string) error {
	if _fae := _fcce.ModelIdAttr.ValidateWithPath(path + "\u002fModelIdAttr"); _fae != nil {
		return _fae
	}
	if _ffcb := _fcce.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _ffcb != nil {
		return _ffcb
	}
	if _abgc := _fcce.SrcIdAttr.ValidateWithPath(path + "\u002fSrcIdAttr"); _abgc != nil {
		return _abgc
	}
	if _accf := _fcce.DestIdAttr.ValidateWithPath(path + "/DestIdAttr"); _accf != nil {
		return _accf
	}
	if _fcce.ParTransIdAttr != nil {
		if _face := _fcce.ParTransIdAttr.ValidateWithPath(path + "\u002fParTransIdAttr"); _face != nil {
			return _face
		}
	}
	if _fcce.SibTransIdAttr != nil {
		if _caecd := _fcce.SibTransIdAttr.ValidateWithPath(path + "\u002fSibTransIdAttr"); _caecd != nil {
			return _caecd
		}
	}
	if _fcce.ExtLst != nil {
		if _bbec := _fcce.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bbec != nil {
			return _bbec
		}
	}
	return nil
}

type ST_BendPoint byte

func (_acbf *CT_DiagramDefinition) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _acbf.UniqueIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "uniqueId"}, Value: _a.Sprintf("\u0025v", *_acbf.UniqueIdAttr)})
	}
	if _acbf.MinVerAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "minVer"}, Value: _a.Sprintf("\u0025v", *_acbf.MinVerAttr)})
	}
	if _acbf.DefStyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "defStyle"}, Value: _a.Sprintf("\u0025v", *_acbf.DefStyleAttr)})
	}
	e.EncodeToken(start)
	if _acbf.Title != nil {
		_bdgb := _b.StartElement{Name: _b.Name{Local: "title"}}
		for _, _gdda := range _acbf.Title {
			e.EncodeElement(_gdda, _bdgb)
		}
	}
	if _acbf.Desc != nil {
		_cad := _b.StartElement{Name: _b.Name{Local: "desc"}}
		for _, _caf := range _acbf.Desc {
			e.EncodeElement(_caf, _cad)
		}
	}
	if _acbf.CatLst != nil {
		_gbfbg := _b.StartElement{Name: _b.Name{Local: "catLst"}}
		e.EncodeElement(_acbf.CatLst, _gbfbg)
	}
	if _acbf.SampData != nil {
		_bbg := _b.StartElement{Name: _b.Name{Local: "sampData"}}
		e.EncodeElement(_acbf.SampData, _bbg)
	}
	if _acbf.StyleData != nil {
		_gefd := _b.StartElement{Name: _b.Name{Local: "styleData"}}
		e.EncodeElement(_acbf.StyleData, _gefd)
	}
	if _acbf.ClrData != nil {
		_fceb := _b.StartElement{Name: _b.Name{Local: "clrData"}}
		e.EncodeElement(_acbf.ClrData, _fceb)
	}
	_eaf := _b.StartElement{Name: _b.Name{Local: "layoutNode"}}
	e.EncodeElement(_acbf.LayoutNode, _eaf)
	if _acbf.ExtLst != nil {
		_aag := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_acbf.ExtLst, _aag)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_dgdf ST_TextDirection) ValidateWithPath(path string) error {
	switch _dgdf {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dgdf))
	}
	return nil
}

// ValidateWithPath validates the CT_Adj and its children, prefixing error messages with path
func (_ebb *CT_Adj) ValidateWithPath(path string) error {
	if _ebb.IdxAttr < 1 {
		return _a.Errorf("%s\u002fm\u002eIdxAttr\u0020must\u0020be\u0020\u003e=\u00201\u0020\u0028have\u0020\u0025v\u0029", path, _ebb.IdxAttr)
	}
	return nil
}
func (_bcdcb ST_PtType) String() string {
	switch _bcdcb {
	case 0:
		return ""
	case 1:
		return "node"
	case 2:
		return "asst"
	case 3:
		return "doc"
	case 4:
		return "pres"
	case 5:
		return "parTrans"
	case 6:
		return "sibTrans"
	}
	return ""
}

// Validate validates the CT_DiagramDefinition and its children
func (_acgb *CT_DiagramDefinition) Validate() error {
	return _acgb.ValidateWithPath("CT_DiagramDefinition")
}
func (_aaacb ST_ChildDirection) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bbgd := _b.Attr{}
	_bbgd.Name = name
	switch _aaacb {
	case ST_ChildDirectionUnset:
		_bbgd.Value = ""
	case ST_ChildDirectionHorz:
		_bbgd.Value = "horz"
	case ST_ChildDirectionVert:
		_bbgd.Value = "vert"
	}
	return _bbgd, nil
}

// ValidateWithPath validates the CT_StyleDefinition and its children, prefixing error messages with path
func (_gbcd *CT_StyleDefinition) ValidateWithPath(path string) error {
	for _ddbg, _bbeb := range _gbcd.Title {
		if _bdcd := _bbeb.ValidateWithPath(_a.Sprintf("\u0025s\u002fTitle\u005b\u0025d\u005d", path, _ddbg)); _bdcd != nil {
			return _bdcd
		}
	}
	for _afda, _eeef := range _gbcd.Desc {
		if _ggbc := _eeef.ValidateWithPath(_a.Sprintf("%s\u002fDesc\u005b\u0025d\u005d", path, _afda)); _ggbc != nil {
			return _ggbc
		}
	}
	if _gbcd.CatLst != nil {
		if _dddc := _gbcd.CatLst.ValidateWithPath(path + "\u002fCatLst"); _dddc != nil {
			return _dddc
		}
	}
	if _gbcd.Scene3d != nil {
		if _aefga := _gbcd.Scene3d.ValidateWithPath(path + "\u002fScene3d"); _aefga != nil {
			return _aefga
		}
	}
	for _egee, _dcfb := range _gbcd.StyleLbl {
		if _ceaaf := _dcfb.ValidateWithPath(_a.Sprintf("\u0025s\u002fStyleLbl\u005b\u0025d\u005d", path, _egee)); _ceaaf != nil {
			return _ceaaf
		}
	}
	if _gbcd.ExtLst != nil {
		if _gfba := _gbcd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gfba != nil {
			return _gfba
		}
	}
	return nil
}
func (_fgdd *ST_ModelId) ValidateWithPath(path string) error {
	_efga := []string{}
	if _fgdd.Int32 != nil {
		_efga = append(_efga, "Int32")
	}
	if _fgdd.ST_Guid != nil {
		_efga = append(_efga, "ST_Guid")
	}
	if len(_efga) > 1 {
		return _a.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _efga)
	}
	return nil
}
func (_fgdea ST_ConstraintRelationship) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gefa := _b.Attr{}
	_gefa.Name = name
	switch _fgdea {
	case ST_ConstraintRelationshipUnset:
		_gefa.Value = ""
	case ST_ConstraintRelationshipSelf:
		_gefa.Value = "self"
	case ST_ConstraintRelationshipCh:
		_gefa.Value = "ch"
	case ST_ConstraintRelationshipDes:
		_gefa.Value = "des"
	}
	return _gefa, nil
}
func (_ccda ST_AutoTextRotation) ValidateWithPath(path string) error {
	switch _ccda {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ccda))
	}
	return nil
}
func (_afgc ST_BoolOperator) Validate() error { return _afgc.ValidateWithPath("") }

// ValidateWithPath validates the CT_DataModel and its children, prefixing error messages with path
func (_gbfbc *CT_DataModel) ValidateWithPath(path string) error {
	if _dcda := _gbfbc.PtLst.ValidateWithPath(path + "\u002fPtLst"); _dcda != nil {
		return _dcda
	}
	if _gbfbc.CxnLst != nil {
		if _fgeg := _gbfbc.CxnLst.ValidateWithPath(path + "\u002fCxnLst"); _fgeg != nil {
			return _fgeg
		}
	}
	if _gbfbc.Bg != nil {
		if _efaa := _gbfbc.Bg.ValidateWithPath(path + "\u002fBg"); _efaa != nil {
			return _efaa
		}
	}
	if _gbfbc.Whole != nil {
		if _geaa := _gbfbc.Whole.ValidateWithPath(path + "\u002fWhole"); _geaa != nil {
			return _geaa
		}
	}
	if _gbfbc.ExtLst != nil {
		if _gfabf := _gbfbc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gfabf != nil {
			return _gfabf
		}
	}
	return nil
}
func (_gagdf ST_PyramidAccentPosition) String() string {
	switch _gagdf {
	case 0:
		return ""
	case 1:
		return "bef"
	case 2:
		return "aft"
	}
	return ""
}
func (_bbdg ST_ConnectorDimension) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bbdg.String(), start)
}
func (_eddd ST_AnimOneStr) ValidateWithPath(path string) error {
	switch _eddd {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eddd))
	}
	return nil
}
func (_fgae *CT_Otherwise) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _fcff := range start.Attr {
		if _fcff.Name.Local == "name" {
			_cbeed, _ececd := _fcff.Value, error(nil)
			if _ececd != nil {
				return _ececd
			}
			_fgae.NameAttr = &_cbeed
			continue
		}
	}
_ffgc:
	for {
		_bcad, _cdbf := d.Token()
		if _cdbf != nil {
			return _cdbf
		}
		switch _eeee := _bcad.(type) {
		case _b.StartElement:
			switch _eeee.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "alg"}:
				_efcd := NewCT_Algorithm()
				if _bedb := d.DecodeElement(_efcd, &_eeee); _bedb != nil {
					return _bedb
				}
				_fgae.Alg = append(_fgae.Alg, _efcd)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "shape"}:
				_ecfd := NewCT_Shape()
				if _bggd := d.DecodeElement(_ecfd, &_eeee); _bggd != nil {
					return _bggd
				}
				_fgae.Shape = append(_fgae.Shape, _ecfd)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "presOf"}:
				_gcgb := NewCT_PresentationOf()
				if _egbd := d.DecodeElement(_gcgb, &_eeee); _egbd != nil {
					return _egbd
				}
				_fgae.PresOf = append(_fgae.PresOf, _gcgb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "constrLst"}:
				_febf := NewCT_Constraints()
				if _fgba := d.DecodeElement(_febf, &_eeee); _fgba != nil {
					return _fgba
				}
				_fgae.ConstrLst = append(_fgae.ConstrLst, _febf)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "ruleLst"}:
				_faee := NewCT_Rules()
				if _beaa := d.DecodeElement(_faee, &_eeee); _beaa != nil {
					return _beaa
				}
				_fgae.RuleLst = append(_fgae.RuleLst, _faee)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "forEach"}:
				_bdef := NewCT_ForEach()
				if _addf := d.DecodeElement(_bdef, &_eeee); _addf != nil {
					return _addf
				}
				_fgae.ForEach = append(_fgae.ForEach, _bdef)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "layoutNode"}:
				_deeb := NewCT_LayoutNode()
				if _geff := d.DecodeElement(_deeb, &_eeee); _geff != nil {
					return _geff
				}
				_fgae.LayoutNode = append(_fgae.LayoutNode, _deeb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "choose"}:
				_fefd := NewCT_Choose()
				if _adecg := d.DecodeElement(_fefd, &_eeee); _adecg != nil {
					return _adecg
				}
				_fgae.Choose = append(_fgae.Choose, _fefd)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_bge := _f.NewCT_OfficeArtExtensionList()
				if _abef := d.DecodeElement(_bge, &_eeee); _abef != nil {
					return _abef
				}
				_fgae.ExtLst = append(_fgae.ExtLst, _bge)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Otherwise\u0020\u0025v", _eeee.Name)
				if _aaee := d.Skip(); _aaee != nil {
					return _aaee
				}
			}
		case _b.EndElement:
			break _ffgc
		case _b.CharData:
		}
	}
	return nil
}

// Validate validates the CT_LayoutNode and its children
func (_ccdb *CT_LayoutNode) Validate() error { return _ccdb.ValidateWithPath("CT_LayoutNode") }

type ST_ContinueDirection byte

func (_ggda *CT_PresentationOf) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ggda.AxisAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "axis"}, Value: _a.Sprintf("\u0025v", *_ggda.AxisAttr)})
	}
	if _ggda.PtTypeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "ptType"}, Value: _a.Sprintf("\u0025v", *_ggda.PtTypeAttr)})
	}
	if _ggda.HideLastTransAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "hideLastTrans"}, Value: _a.Sprintf("\u0025v", *_ggda.HideLastTransAttr)})
	}
	if _ggda.StAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "st"}, Value: _a.Sprintf("\u0025v", *_ggda.StAttr)})
	}
	if _ggda.CntAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cnt"}, Value: _a.Sprintf("\u0025v", *_ggda.CntAttr)})
	}
	if _ggda.StepAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "step"}, Value: _a.Sprintf("\u0025v", *_ggda.StepAttr)})
	}
	e.EncodeToken(start)
	if _ggda.ExtLst != nil {
		_adcb := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_ggda.ExtLst, _adcb)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_ecd *CT_Choose) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ecd.NameAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "name"}, Value: _a.Sprintf("\u0025v", *_ecd.NameAttr)})
	}
	e.EncodeToken(start)
	_fddd := _b.StartElement{Name: _b.Name{Local: "if"}}
	for _, _agdg := range _ecd.If {
		e.EncodeElement(_agdg, _fddd)
	}
	if _ecd.Else != nil {
		_gefe := _b.StartElement{Name: _b.Name{Local: "else"}}
		e.EncodeElement(_ecd.Else, _gefe)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_gcag ST_NodeHorizontalAlignment) Validate() error { return _gcag.ValidateWithPath("") }

type CT_RelIds struct {
	DmAttr string
	LoAttr string
	QsAttr string
	CsAttr string
}
type ST_DiagramHorizontalAlignment byte

func NewCT_AdjLst() *CT_AdjLst { _ead := &CT_AdjLst{}; return _ead }
func (_affd *CT_ChildPref) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _acf := range start.Attr {
		if _acf.Name.Local == "val" {
			_bcc, _ffbb := _d.ParseInt(_acf.Value, 10, 32)
			if _ffbb != nil {
				return _ffbb
			}
			_daca := int32(_bcc)
			_affd.ValAttr = &_daca
			continue
		}
	}
	for {
		_bbfb, _agde := d.Token()
		if _agde != nil {
			return _a.Errorf("parsing\u0020CT_ChildPref:\u0020\u0025s", _agde)
		}
		if _baea, _eege := _bbfb.(_b.EndElement); _eege && _baea.Name == start.Name {
			break
		}
	}
	return nil
}

type ST_PtType byte
type CT_Rules struct{ Rule []*CT_NumericRule }

func (_cgdcc *ST_HueDir) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_agef, _efbc := d.Token()
	if _efbc != nil {
		return _efbc
	}
	if _bcefc, _adfea := _agef.(_b.EndElement); _adfea && _bcefc.Name == start.Name {
		*_cgdcc = 1
		return nil
	}
	if _gefffd, _bcgf := _agef.(_b.CharData); !_bcgf {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _agef)
	} else {
		switch string(_gefffd) {
		case "":
			*_cgdcc = 0
		case "cw":
			*_cgdcc = 1
		case "ccw":
			*_cgdcc = 2
		}
	}
	_agef, _efbc = d.Token()
	if _efbc != nil {
		return _efbc
	}
	if _afbe, _bcdcg := _agef.(_b.EndElement); _bcdcg && _afbe.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _agef)
}
func NewAG_IteratorAttributes() *AG_IteratorAttributes { _gbd := &AG_IteratorAttributes{}; return _gbd }
func (_eecgg *ST_ConstraintRelationship) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_eecgg = 0
	case "self":
		*_eecgg = 1
	case "ch":
		*_eecgg = 2
	case "des":
		*_eecgg = 3
	}
	return nil
}
func (_dbg *CT_AnimLvl) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _gbea := range start.Attr {
		if _gbea.Name.Local == "val" {
			_dbg.ValAttr.UnmarshalXMLAttr(_gbea)
			continue
		}
	}
	for {
		_fea, _fdcc := d.Token()
		if _fdcc != nil {
			return _a.Errorf("parsing\u0020CT_AnimLvl:\u0020%s", _fdcc)
		}
		if _edg, _gge := _fea.(_b.EndElement); _gge && _edg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cbeeef ST_ConnectorDimension) String() string {
	switch _cbeeef {
	case 0:
		return ""
	case 1:
		return "1D"
	case 2:
		return "2D"
	case 3:
		return "cust"
	}
	return ""
}

// ValidateWithPath validates the CT_BulletEnabled and its children, prefixing error messages with path
func (_ggb *CT_BulletEnabled) ValidateWithPath(path string) error { return nil }

type ST_ParameterId byte

func (_fegbg ST_ArrowheadStyle) String() string {
	switch _fegbg {
	case 0:
		return ""
	case 1:
		return "auto"
	case 2:
		return "arr"
	case 3:
		return "noArr"
	}
	return ""
}
func (_ffb *CT_CTName) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dfbb := range start.Attr {
		if _dfbb.Name.Local == "lang" {
			_cgb, _cabe := _dfbb.Value, error(nil)
			if _cabe != nil {
				return _cabe
			}
			_ffb.LangAttr = &_cgb
			continue
		}
		if _dfbb.Name.Local == "val" {
			_be, _agab := _dfbb.Value, error(nil)
			if _agab != nil {
				return _agab
			}
			_ffb.ValAttr = _be
			continue
		}
	}
	for {
		_fcd, _de := d.Token()
		if _de != nil {
			return _a.Errorf("parsing\u0020CT_CTName:\u0020\u0025s", _de)
		}
		if _abe, _eabd := _fcd.(_b.EndElement); _eabd && _abe.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cag *AG_ConstraintRefAttributes) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bdg := range start.Attr {
		if _bdg.Name.Local == "refType" {
			_cag.RefTypeAttr.UnmarshalXMLAttr(_bdg)
			continue
		}
		if _bdg.Name.Local == "refFor" {
			_cag.RefForAttr.UnmarshalXMLAttr(_bdg)
			continue
		}
		if _bdg.Name.Local == "refForName" {
			_ga, _fg := _bdg.Value, error(nil)
			if _fg != nil {
				return _fg
			}
			_cag.RefForNameAttr = &_ga
			continue
		}
		if _bdg.Name.Local == "refPtType" {
			_cag.RefPtTypeAttr.UnmarshalXMLAttr(_bdg)
			continue
		}
	}
	for {
		_eb, _ebg := d.Token()
		if _ebg != nil {
			return _a.Errorf("parsing\u0020AG_ConstraintRefAttributes:\u0020\u0025s", _ebg)
		}
		if _ebc, _ceb := _eb.(_b.EndElement); _ceb && _ebc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bcea ST_FunctionOperator) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bcea.String(), start)
}
func NewCT_SDCategories() *CT_SDCategories { _cbbca := &CT_SDCategories{}; return _cbbca }
func (_cefd ST_TextBlockDirection) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_cefd.String(), start)
}
func NewCT_ColorTransform() *CT_ColorTransform { _agcd := &CT_ColorTransform{}; return _agcd }

// Validate validates the CT_Pt and its children
func (_geca *CT_Pt) Validate() error { return _geca.ValidateWithPath("CT_Pt") }
func (_babc *CT_ElemPropSet) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ggeg := range start.Attr {
		if _ggeg.Name.Local == "custFlipVert" {
			_gccff, _accbf := _d.ParseBool(_ggeg.Value)
			if _accbf != nil {
				return _accbf
			}
			_babc.CustFlipVertAttr = &_gccff
			continue
		}
		if _ggeg.Name.Local == "presAssocID" {
			_dbdf, _ccfb := ParseUnionST_ModelId(_ggeg.Value)
			if _ccfb != nil {
				return _ccfb
			}
			_babc.PresAssocIDAttr = &_dbdf
			continue
		}
		if _ggeg.Name.Local == "custFlipHor" {
			_adf, _beef := _d.ParseBool(_ggeg.Value)
			if _beef != nil {
				return _beef
			}
			_babc.CustFlipHorAttr = &_adf
			continue
		}
		if _ggeg.Name.Local == "presStyleLbl" {
			_bgbf, _acge := _ggeg.Value, error(nil)
			if _acge != nil {
				return _acge
			}
			_babc.PresStyleLblAttr = &_bgbf
			continue
		}
		if _ggeg.Name.Local == "custSzX" {
			_dbgf, _gcbe := _d.ParseInt(_ggeg.Value, 10, 32)
			if _gcbe != nil {
				return _gcbe
			}
			_bfgcc := int32(_dbgf)
			_babc.CustSzXAttr = &_bfgcc
			continue
		}
		if _ggeg.Name.Local == "presStyleCnt" {
			_cgff, _ccfa := _d.ParseInt(_ggeg.Value, 10, 32)
			if _ccfa != nil {
				return _ccfa
			}
			_bcaa := int32(_cgff)
			_babc.PresStyleCntAttr = &_bcaa
			continue
		}
		if _ggeg.Name.Local == "custSzY" {
			_egbb, _cffe := _d.ParseInt(_ggeg.Value, 10, 32)
			if _cffe != nil {
				return _cffe
			}
			_egbaa := int32(_egbb)
			_babc.CustSzYAttr = &_egbaa
			continue
		}
		if _ggeg.Name.Local == "loCatId" {
			_dcgc, _bcf := _ggeg.Value, error(nil)
			if _bcf != nil {
				return _bcf
			}
			_babc.LoCatIdAttr = &_dcgc
			continue
		}
		if _ggeg.Name.Local == "custScaleX" {
			_degg, _ebdb := ParseUnionST_PrSetCustVal(_ggeg.Value)
			if _ebdb != nil {
				return _ebdb
			}
			_babc.CustScaleXAttr = &_degg
			continue
		}
		if _ggeg.Name.Local == "qsCatId" {
			_dadd, _dgcee := _ggeg.Value, error(nil)
			if _dgcee != nil {
				return _dgcee
			}
			_babc.QsCatIdAttr = &_dadd
			continue
		}
		if _ggeg.Name.Local == "custScaleY" {
			_cgag, _gedg := ParseUnionST_PrSetCustVal(_ggeg.Value)
			if _gedg != nil {
				return _gedg
			}
			_babc.CustScaleYAttr = &_cgag
			continue
		}
		if _ggeg.Name.Local == "custAng" {
			_ceda, _dgfd := _d.ParseInt(_ggeg.Value, 10, 32)
			if _dgfd != nil {
				return _dgfd
			}
			_egda := int32(_ceda)
			_babc.CustAngAttr = &_egda
			continue
		}
		if _ggeg.Name.Local == "custRadScaleRad" {
			_bage, _agfe := ParseUnionST_PrSetCustVal(_ggeg.Value)
			if _agfe != nil {
				return _agfe
			}
			_babc.CustRadScaleRadAttr = &_bage
			continue
		}
		if _ggeg.Name.Local == "custLinFactX" {
			_egdb, _befgc := ParseUnionST_PrSetCustVal(_ggeg.Value)
			if _befgc != nil {
				return _befgc
			}
			_babc.CustLinFactXAttr = &_egdb
			continue
		}
		if _ggeg.Name.Local == "qsTypeId" {
			_eabb, _ffcg := _ggeg.Value, error(nil)
			if _ffcg != nil {
				return _ffcg
			}
			_babc.QsTypeIdAttr = &_eabb
			continue
		}
		if _ggeg.Name.Local == "coherent3DOff" {
			_egcf, _ddb := _d.ParseBool(_ggeg.Value)
			if _ddb != nil {
				return _ddb
			}
			_babc.Coherent3DOffAttr = &_egcf
			continue
		}
		if _ggeg.Name.Local == "custT" {
			_fagc, _dcec := _d.ParseBool(_ggeg.Value)
			if _dcec != nil {
				return _dcec
			}
			_babc.CustTAttr = &_fagc
			continue
		}
		if _ggeg.Name.Local == "presName" {
			_eegaa, _bddba := _ggeg.Value, error(nil)
			if _bddba != nil {
				return _bddba
			}
			_babc.PresNameAttr = &_eegaa
			continue
		}
		if _ggeg.Name.Local == "custLinFactNeighborY" {
			_dbdc, _afeg := ParseUnionST_PrSetCustVal(_ggeg.Value)
			if _afeg != nil {
				return _afeg
			}
			_babc.CustLinFactNeighborYAttr = &_dbdc
			continue
		}
		if _ggeg.Name.Local == "custLinFactY" {
			_eeec, _bdeg := ParseUnionST_PrSetCustVal(_ggeg.Value)
			if _bdeg != nil {
				return _bdeg
			}
			_babc.CustLinFactYAttr = &_eeec
			continue
		}
		if _ggeg.Name.Local == "loTypeId" {
			_acda, _dadb := _ggeg.Value, error(nil)
			if _dadb != nil {
				return _dadb
			}
			_babc.LoTypeIdAttr = &_acda
			continue
		}
		if _ggeg.Name.Local == "custRadScaleInc" {
			_fbebc, _bagea := ParseUnionST_PrSetCustVal(_ggeg.Value)
			if _bagea != nil {
				return _bagea
			}
			_babc.CustRadScaleIncAttr = &_fbebc
			continue
		}
		if _ggeg.Name.Local == "phldr" {
			_edfe, _dagca := _d.ParseBool(_ggeg.Value)
			if _dagca != nil {
				return _dagca
			}
			_babc.PhldrAttr = &_edfe
			continue
		}
		if _ggeg.Name.Local == "csTypeId" {
			_bggcd, _cccg := _ggeg.Value, error(nil)
			if _cccg != nil {
				return _cccg
			}
			_babc.CsTypeIdAttr = &_bggcd
			continue
		}
		if _ggeg.Name.Local == "csCatId" {
			_faac, _age := _ggeg.Value, error(nil)
			if _age != nil {
				return _age
			}
			_babc.CsCatIdAttr = &_faac
			continue
		}
		if _ggeg.Name.Local == "phldrT" {
			_bcaf, _cffeb := _ggeg.Value, error(nil)
			if _cffeb != nil {
				return _cffeb
			}
			_babc.PhldrTAttr = &_bcaf
			continue
		}
		if _ggeg.Name.Local == "presStyleIdx" {
			_bcfa, _acef := _d.ParseInt(_ggeg.Value, 10, 32)
			if _acef != nil {
				return _acef
			}
			_defg := int32(_bcfa)
			_babc.PresStyleIdxAttr = &_defg
			continue
		}
		if _ggeg.Name.Local == "custLinFactNeighborX" {
			_dffb, _eggf := ParseUnionST_PrSetCustVal(_ggeg.Value)
			if _eggf != nil {
				return _eggf
			}
			_babc.CustLinFactNeighborXAttr = &_dffb
			continue
		}
	}
_bdde:
	for {
		_baec, _gbfba := d.Token()
		if _gbfba != nil {
			return _gbfba
		}
		switch _bfac := _baec.(type) {
		case _b.StartElement:
			switch _bfac.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "presLayoutVars"}:
				_babc.PresLayoutVars = NewCT_LayoutVariablePropertySet()
				if _cdbb := d.DecodeElement(_babc.PresLayoutVars, &_bfac); _cdbb != nil {
					return _cdbb
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "style"}:
				_babc.Style = _f.NewCT_ShapeStyle()
				if _efae := d.DecodeElement(_babc.Style, &_bfac); _efae != nil {
					return _efae
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ElemPropSet\u0020\u0025v", _bfac.Name)
				if _fcebe := d.Skip(); _fcebe != nil {
					return _fcebe
				}
			}
		case _b.EndElement:
			break _bdde
		case _b.CharData:
		}
	}
	return nil
}

type ST_StartingElement byte

func (_eeabc *ST_PyramidAccentPosition) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_eeabc = 0
	case "bef":
		*_eeabc = 1
	case "aft":
		*_eeabc = 2
	}
	return nil
}

// Validate validates the CT_StyleDefinitionHeaderLst and its children
func (_cddc *CT_StyleDefinitionHeaderLst) Validate() error {
	return _cddc.ValidateWithPath("CT_StyleDefinitionHeaderLst")
}

type CT_CTName struct {
	LangAttr *string
	ValAttr  string
}

func (_cgbd ST_AnimOneStr) String() string {
	switch _cgbd {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "one"
	case 3:
		return "branch"
	}
	return ""
}
func (_gba *CT_Description) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _gba.LangAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "lang"}, Value: _a.Sprintf("\u0025v", *_gba.LangAttr)})
	}
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", _gba.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_effdf *ST_Direction) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gcgd, _fgec := d.Token()
	if _fgec != nil {
		return _fgec
	}
	if _dfgcf, _fgdaba := _gcgd.(_b.EndElement); _fgdaba && _dfgcf.Name == start.Name {
		*_effdf = 1
		return nil
	}
	if _geded, _edea := _gcgd.(_b.CharData); !_edea {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gcgd)
	} else {
		switch string(_geded) {
		case "":
			*_effdf = 0
		case "norm":
			*_effdf = 1
		case "rev":
			*_effdf = 2
		}
	}
	_gcgd, _fgec = d.Token()
	if _fgec != nil {
		return _fgec
	}
	if _bbfe, _egdfe := _gcgd.(_b.EndElement); _egdfe && _bbfe.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gcgd)
}
func (_abbe *ST_AlgorithmType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_abbe = 0
	case "composite":
		*_abbe = 1
	case "conn":
		*_abbe = 2
	case "cycle":
		*_abbe = 3
	case "hierChild":
		*_abbe = 4
	case "hierRoot":
		*_abbe = 5
	case "pyra":
		*_abbe = 6
	case "lin":
		*_abbe = 7
	case "sp":
		*_abbe = 8
	case "tx":
		*_abbe = 9
	case "snake":
		*_abbe = 10
	}
	return nil
}
func (_ebaf ST_ContinueDirection) ValidateWithPath(path string) error {
	switch _ebaf {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ebaf))
	}
	return nil
}

type CT_LayoutVariablePropertySet struct {
	OrgChart      *CT_OrgChart
	ChMax         *CT_ChildMax
	ChPref        *CT_ChildPref
	BulletEnabled *CT_BulletEnabled
	Dir           *CT_Direction
	HierBranch    *CT_HierBranchStyle
	AnimOne       *CT_AnimOne
	AnimLvl       *CT_AnimLvl
	ResizeHandles *CT_ResizeHandles
}

func (_facc ST_FlowDirection) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_fgaea := _b.Attr{}
	_fgaea.Name = name
	switch _facc {
	case ST_FlowDirectionUnset:
		_fgaea.Value = ""
	case ST_FlowDirectionRow:
		_fgaea.Value = "row"
	case ST_FlowDirectionCol:
		_fgaea.Value = "col"
	}
	return _fgaea, nil
}
func (_ccbb *CT_CTStyleLabel) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _edfb := range start.Attr {
		if _edfb.Name.Local == "name" {
			_fbcc, _ceag := _edfb.Value, error(nil)
			if _ceag != nil {
				return _ceag
			}
			_ccbb.NameAttr = _fbcc
			continue
		}
	}
_efdg:
	for {
		_eff, _ddad := d.Token()
		if _ddad != nil {
			return _ddad
		}
		switch _cdc := _eff.(type) {
		case _b.StartElement:
			switch _cdc.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "fillClrLst"}:
				_ccbb.FillClrLst = NewCT_Colors()
				if _cgd := d.DecodeElement(_ccbb.FillClrLst, &_cdc); _cgd != nil {
					return _cgd
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "linClrLst"}:
				_ccbb.LinClrLst = NewCT_Colors()
				if _fdda := d.DecodeElement(_ccbb.LinClrLst, &_cdc); _fdda != nil {
					return _fdda
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "effectClrLst"}:
				_ccbb.EffectClrLst = NewCT_Colors()
				if _dacf := d.DecodeElement(_ccbb.EffectClrLst, &_cdc); _dacf != nil {
					return _dacf
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "txLinClrLst"}:
				_ccbb.TxLinClrLst = NewCT_Colors()
				if _beg := d.DecodeElement(_ccbb.TxLinClrLst, &_cdc); _beg != nil {
					return _beg
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "txFillClrLst"}:
				_ccbb.TxFillClrLst = NewCT_Colors()
				if _bfgb := d.DecodeElement(_ccbb.TxFillClrLst, &_cdc); _bfgb != nil {
					return _bfgb
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "txEffectClrLst"}:
				_ccbb.TxEffectClrLst = NewCT_Colors()
				if _cga := d.DecodeElement(_ccbb.TxEffectClrLst, &_cdc); _cga != nil {
					return _cga
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_ccbb.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _dagc := d.DecodeElement(_ccbb.ExtLst, &_cdc); _dagc != nil {
					return _dagc
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CTStyleLabel\u0020\u0025v", _cdc.Name)
				if _efdf := d.Skip(); _efdf != nil {
					return _efdf
				}
			}
		case _b.EndElement:
			break _efdg
		case _b.CharData:
		}
	}
	return nil
}
func NewCT_ForEach() *CT_ForEach { _adgc := &CT_ForEach{}; return _adgc }
func (_gfcee ST_SecondaryChildAlignment) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gceb := _b.Attr{}
	_gceb.Name = name
	switch _gfcee {
	case ST_SecondaryChildAlignmentUnset:
		_gceb.Value = ""
	case ST_SecondaryChildAlignmentNone:
		_gceb.Value = "none"
	case ST_SecondaryChildAlignmentT:
		_gceb.Value = "t"
	case ST_SecondaryChildAlignmentB:
		_gceb.Value = "b"
	case ST_SecondaryChildAlignmentL:
		_gceb.Value = "l"
	case ST_SecondaryChildAlignmentR:
		_gceb.Value = "r"
	}
	return _gceb, nil
}
func (_fdfaf ST_SecondaryLinearDirection) Validate() error { return _fdfaf.ValidateWithPath("") }
func (_fffdd *ST_ChildAlignment) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dbgca, _accc := d.Token()
	if _accc != nil {
		return _accc
	}
	if _cdccd, _eacg := _dbgca.(_b.EndElement); _eacg && _cdccd.Name == start.Name {
		*_fffdd = 1
		return nil
	}
	if _dbaa, _bfda := _dbgca.(_b.CharData); !_bfda {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dbgca)
	} else {
		switch string(_dbaa) {
		case "":
			*_fffdd = 0
		case "t":
			*_fffdd = 1
		case "b":
			*_fffdd = 2
		case "l":
			*_fffdd = 3
		case "r":
			*_fffdd = 4
		}
	}
	_dbgca, _accc = d.Token()
	if _accc != nil {
		return _accc
	}
	if _afgdf, _agdeee := _dbgca.(_b.EndElement); _agdeee && _afgdf.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dbgca)
}
func (_gagf *ST_SecondaryChildAlignment) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gbdg, _feaaf := d.Token()
	if _feaaf != nil {
		return _feaaf
	}
	if _aafde, _bcfc := _gbdg.(_b.EndElement); _bcfc && _aafde.Name == start.Name {
		*_gagf = 1
		return nil
	}
	if _fgeef, _bceb := _gbdg.(_b.CharData); !_bceb {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gbdg)
	} else {
		switch string(_fgeef) {
		case "":
			*_gagf = 0
		case "none":
			*_gagf = 1
		case "t":
			*_gagf = 2
		case "b":
			*_gagf = 3
		case "l":
			*_gagf = 4
		case "r":
			*_gagf = 5
		}
	}
	_gbdg, _feaaf = d.Token()
	if _feaaf != nil {
		return _feaaf
	}
	if _fbceaf, _fegbd := _gbdg.(_b.EndElement); _fegbd && _fbceaf.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gbdg)
}
func (_eeacb ST_ParameterId) Validate() error     { return _eeacb.ValidateWithPath("") }
func (_gacc ST_ConnectorRouting) Validate() error { return _gacc.ValidateWithPath("") }

type CT_StyleLabel struct {
	NameAttr string
	Scene3d  *_f.CT_Scene3D
	Sp3d     *_f.CT_Shape3D
	TxPr     *CT_TextProps
	Style    *_f.CT_ShapeStyle
	ExtLst   *_f.CT_OfficeArtExtensionList
}

func (_deab ST_PrSetCustVal) String() string {
	if _deab.ST_Percentage != nil {
		return _a.Sprintf("\u0025v", *_deab.ST_Percentage)
	}
	if _deab.Int32 != nil {
		return _a.Sprintf("\u0025v", *_deab.Int32)
	}
	return ""
}
func (_gbfcb ST_TextBlockDirection) Validate() error { return _gbfcb.ValidateWithPath("") }

type ST_VariableType byte

// ValidateWithPath validates the CT_DiagramDefinition and its children, prefixing error messages with path
func (_gcg *CT_DiagramDefinition) ValidateWithPath(path string) error {
	for _dfab, _adcg := range _gcg.Title {
		if _cbff := _adcg.ValidateWithPath(_a.Sprintf("\u0025s\u002fTitle\u005b\u0025d\u005d", path, _dfab)); _cbff != nil {
			return _cbff
		}
	}
	for _gefb, _daea := range _gcg.Desc {
		if _fcf := _daea.ValidateWithPath(_a.Sprintf("%s\u002fDesc\u005b\u0025d\u005d", path, _gefb)); _fcf != nil {
			return _fcf
		}
	}
	if _gcg.CatLst != nil {
		if _gafc := _gcg.CatLst.ValidateWithPath(path + "\u002fCatLst"); _gafc != nil {
			return _gafc
		}
	}
	if _gcg.SampData != nil {
		if _dbbg := _gcg.SampData.ValidateWithPath(path + "\u002fSampData"); _dbbg != nil {
			return _dbbg
		}
	}
	if _gcg.StyleData != nil {
		if _fee := _gcg.StyleData.ValidateWithPath(path + "\u002fStyleData"); _fee != nil {
			return _fee
		}
	}
	if _gcg.ClrData != nil {
		if _eadd := _gcg.ClrData.ValidateWithPath(path + "\u002fClrData"); _eadd != nil {
			return _eadd
		}
	}
	if _ceeb := _gcg.LayoutNode.ValidateWithPath(path + "/LayoutNode"); _ceeb != nil {
		return _ceeb
	}
	if _gcg.ExtLst != nil {
		if _fbeb := _gcg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fbeb != nil {
			return _fbeb
		}
	}
	return nil
}

// Validate validates the CT_Constraint and its children
func (_cdca *CT_Constraint) Validate() error { return _cdca.ValidateWithPath("CT_Constraint") }
func (_afafb ST_AxisType) ValidateWithPath(path string) error {
	switch _afafb {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_afafb))
	}
	return nil
}

const (
	ST_HierBranchStyleUnset ST_HierBranchStyle = 0
	ST_HierBranchStyleL     ST_HierBranchStyle = 1
	ST_HierBranchStyleR     ST_HierBranchStyle = 2
	ST_HierBranchStyleHang  ST_HierBranchStyle = 3
	ST_HierBranchStyleStd   ST_HierBranchStyle = 4
	ST_HierBranchStyleInit  ST_HierBranchStyle = 5
)

func (_ddee *ST_SecondaryLinearDirection) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_ddee = 0
	case "none":
		*_ddee = 1
	case "fromL":
		*_ddee = 2
	case "fromR":
		*_ddee = 3
	case "fromT":
		*_ddee = 4
	case "fromB":
		*_ddee = 5
	}
	return nil
}
func (_dag *CT_CTCategories) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _dag.Cat != nil {
		_ebgd := _b.StartElement{Name: _b.Name{Local: "cat"}}
		for _, _dgc := range _dag.Cat {
			e.EncodeElement(_dgc, _ebgd)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_cbfd *CT_DataModel) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cbfd.PtLst = NewCT_PtList()
_gga:
	for {
		_cfg, _deg := d.Token()
		if _deg != nil {
			return _deg
		}
		switch _bbfbe := _cfg.(type) {
		case _b.StartElement:
			switch _bbfbe.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "ptLst"}:
				if _cgba := d.DecodeElement(_cbfd.PtLst, &_bbfbe); _cgba != nil {
					return _cgba
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "cxnLst"}:
				_cbfd.CxnLst = NewCT_CxnList()
				if _ccae := d.DecodeElement(_cbfd.CxnLst, &_bbfbe); _ccae != nil {
					return _ccae
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "bg"}:
				_cbfd.Bg = _f.NewCT_BackgroundFormatting()
				if _dgcd := d.DecodeElement(_cbfd.Bg, &_bbfbe); _dgcd != nil {
					return _dgcd
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "whole"}:
				_cbfd.Whole = _f.NewCT_WholeE2oFormatting()
				if _bfbg := d.DecodeElement(_cbfd.Whole, &_bbfbe); _bfbg != nil {
					return _bfbg
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_cbfd.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _bab := d.DecodeElement(_cbfd.ExtLst, &_bbfbe); _bab != nil {
					return _bab
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DataModel\u0020\u0025v", _bbfbe.Name)
				if _decd := d.Skip(); _decd != nil {
					return _decd
				}
			}
		case _b.EndElement:
			break _gga
		case _b.CharData:
		}
	}
	return nil
}

type ST_FunctionOperator byte

func (_febe ST_ConnectorPoint) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_febe.String(), start)
}
func NewCT_ColorTransformHeaderLst() *CT_ColorTransformHeaderLst {
	_fbab := &CT_ColorTransformHeaderLst{}
	return _fbab
}

const (
	ST_ConnectorDimensionUnset ST_ConnectorDimension = 0
	ST_ConnectorDimension1D    ST_ConnectorDimension = 1
	ST_ConnectorDimension2D    ST_ConnectorDimension = 2
	ST_ConnectorDimensionCust  ST_ConnectorDimension = 3
)

func (_aedgf *CT_SDName) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _aedgf.LangAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "lang"}, Value: _a.Sprintf("\u0025v", *_aedgf.LangAttr)})
	}
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", _aedgf.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func ParseSliceST_ElementTypes(s string) (ST_ElementTypes, error) { return ST_ElementTypes{}, nil }

type CT_NumericRule struct {
	ValAttr     *float64
	FactAttr    *float64
	MaxAttr     *float64
	ExtLst      *_f.CT_OfficeArtExtensionList
	TypeAttr    ST_ConstraintType
	ForAttr     ST_ConstraintRelationship
	ForNameAttr *string
	PtTypeAttr  ST_ElementType
}
type CT_Algorithm struct {
	TypeAttr ST_AlgorithmType
	RevAttr  *uint32
	Param    []*CT_Parameter
	ExtLst   *_f.CT_OfficeArtExtensionList
}

func (_gfacc *ST_AutoTextRotation) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dcga, _agbcc := d.Token()
	if _agbcc != nil {
		return _agbcc
	}
	if _cadg, _ggfcc := _dcga.(_b.EndElement); _ggfcc && _cadg.Name == start.Name {
		*_gfacc = 1
		return nil
	}
	if _egcag, _bafab := _dcga.(_b.CharData); !_bafab {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dcga)
	} else {
		switch string(_egcag) {
		case "":
			*_gfacc = 0
		case "none":
			*_gfacc = 1
		case "upr":
			*_gfacc = 2
		case "grav":
			*_gfacc = 3
		}
	}
	_dcga, _agbcc = d.Token()
	if _agbcc != nil {
		return _agbcc
	}
	if _cgcg, _gabcg := _dcga.(_b.EndElement); _gabcg && _cgcg.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dcga)
}

// Validate validates the CT_StyleLabel and its children
func (_dbbe *CT_StyleLabel) Validate() error { return _dbbe.ValidateWithPath("CT_StyleLabel") }
func (_gdcg *ST_Direction) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_gdcg = 0
	case "norm":
		*_gdcg = 1
	case "rev":
		*_gdcg = 2
	}
	return nil
}

type ST_ElementType byte

// ValidateWithPath validates the CT_CxnList and its children, prefixing error messages with path
func (_bfdgf *CT_CxnList) ValidateWithPath(path string) error {
	for _eedc, _cbea := range _bfdgf.Cxn {
		if _dbbf := _cbea.ValidateWithPath(_a.Sprintf("\u0025s\u002fCxn\u005b\u0025d\u005d", path, _eedc)); _dbbf != nil {
			return _dbbf
		}
	}
	return nil
}

const (
	ST_CxnTypeUnset               ST_CxnType = 0
	ST_CxnTypeParOf               ST_CxnType = 1
	ST_CxnTypePresOf              ST_CxnType = 2
	ST_CxnTypePresParOf           ST_CxnType = 3
	ST_CxnTypeUnknownRelationship ST_CxnType = 4
)

func (_ddge ST_LinearDirection) Validate() error { return _ddge.ValidateWithPath("") }

const (
	ST_PyramidAccentTextMarginUnset ST_PyramidAccentTextMargin = 0
	ST_PyramidAccentTextMarginStep  ST_PyramidAccentTextMargin = 1
	ST_PyramidAccentTextMarginStack ST_PyramidAccentTextMargin = 2
)

// ValidateWithPath validates the DataModel and its children, prefixing error messages with path
func (_ebbb *DataModel) ValidateWithPath(path string) error {
	if _bcef := _ebbb.CT_DataModel.ValidateWithPath(path); _bcef != nil {
		return _bcef
	}
	return nil
}

type CT_HierBranchStyle struct{ ValAttr ST_HierBranchStyle }

// ValidateWithPath validates the CT_TextProps and its children, prefixing error messages with path
func (_adba *CT_TextProps) ValidateWithPath(path string) error {
	if _adba.Sp3d != nil {
		if _ffccf := _adba.Sp3d.ValidateWithPath(path + "\u002fSp3d"); _ffccf != nil {
			return _ffccf
		}
	}
	if _adba.FlatTx != nil {
		if _bdfb := _adba.FlatTx.ValidateWithPath(path + "\u002fFlatTx"); _bdfb != nil {
			return _bdfb
		}
	}
	return nil
}

type ST_BoolOperator byte

func (_gbfc ST_NodeHorizontalAlignment) ValidateWithPath(path string) error {
	switch _gbfc {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gbfc))
	}
	return nil
}
func (_cefgb ST_ResizeHandlesStr) Validate() error { return _cefgb.ValidateWithPath("") }

// Validate validates the CT_SampleData and its children
func (_ggcf *CT_SampleData) Validate() error { return _ggcf.ValidateWithPath("CT_SampleData") }

// Validate validates the CT_ColorTransformHeaderLst and its children
func (_aefc *CT_ColorTransformHeaderLst) Validate() error {
	return _aefc.ValidateWithPath("CT_ColorTransformHeaderLst")
}
func NewCT_SampleData() *CT_SampleData            { _eeca := &CT_SampleData{}; return _eeca }
func (_bbfcbe ST_ArrowheadStyle) Validate() error { return _bbfcbe.ValidateWithPath("") }
func NewCT_HierBranchStyle() *CT_HierBranchStyle  { _ggbbf := &CT_HierBranchStyle{}; return _ggbbf }
func (_eface *ST_ConnectorDimension) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_eface = 0
	case "1D":
		*_eface = 1
	case "2D":
		*_eface = 2
	case "cust":
		*_eface = 3
	}
	return nil
}
func (_feaa *CT_Categories) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _feaa.Cat != nil {
		_ged := _b.StartElement{Name: _b.Name{Local: "cat"}}
		for _, _fec := range _feaa.Cat {
			e.EncodeElement(_fec, _ged)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_aade ST_ChildAlignment) ValidateWithPath(path string) error {
	switch _aade {
	case 0, 1, 2, 3, 4:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aade))
	}
	return nil
}
func (_fdbf ST_DiagramHorizontalAlignment) ValidateWithPath(path string) error {
	switch _fdbf {
	case 0, 1, 2, 3, 4:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fdbf))
	}
	return nil
}
func (_abeg *CT_SDCategories) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _abeg.Cat != nil {
		_bgbfg := _b.StartElement{Name: _b.Name{Local: "cat"}}
		for _, _gefdd := range _abeg.Cat {
			e.EncodeElement(_gefdd, _bgbfg)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_aaae ST_ClrAppMethod) ValidateWithPath(path string) error {
	switch _aaae {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aaae))
	}
	return nil
}
func (_cgef ST_FunctionType) ValidateWithPath(path string) error {
	switch _cgef {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cgef))
	}
	return nil
}
func (_gfde *ST_BendPoint) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_gfde = 0
	case "beg":
		*_gfde = 1
	case "def":
		*_gfde = 2
	case "end":
		*_gfde = 3
	}
	return nil
}
func (_dbaf ST_ParameterVal) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _dbaf.ST_DiagramHorizontalAlignment != ST_DiagramHorizontalAlignmentUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_DiagramHorizontalAlignment.String()))
	}
	if _dbaf.ST_VerticalAlignment != ST_VerticalAlignmentUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_VerticalAlignment.String()))
	}
	if _dbaf.ST_ChildDirection != ST_ChildDirectionUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_ChildDirection.String()))
	}
	if _dbaf.ST_ChildAlignment != ST_ChildAlignmentUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_ChildAlignment.String()))
	}
	if _dbaf.ST_SecondaryChildAlignment != ST_SecondaryChildAlignmentUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_SecondaryChildAlignment.String()))
	}
	if _dbaf.ST_LinearDirection != ST_LinearDirectionUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_LinearDirection.String()))
	}
	if _dbaf.ST_SecondaryLinearDirection != ST_SecondaryLinearDirectionUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_SecondaryLinearDirection.String()))
	}
	if _dbaf.ST_StartingElement != ST_StartingElementUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_StartingElement.String()))
	}
	if _dbaf.ST_BendPoint != ST_BendPointUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_BendPoint.String()))
	}
	if _dbaf.ST_ConnectorRouting != ST_ConnectorRoutingUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_ConnectorRouting.String()))
	}
	if _dbaf.ST_ArrowheadStyle != ST_ArrowheadStyleUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_ArrowheadStyle.String()))
	}
	if _dbaf.ST_ConnectorDimension != ST_ConnectorDimensionUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_ConnectorDimension.String()))
	}
	if _dbaf.ST_RotationPath != ST_RotationPathUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_RotationPath.String()))
	}
	if _dbaf.ST_CenterShapeMapping != ST_CenterShapeMappingUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_CenterShapeMapping.String()))
	}
	if _dbaf.ST_NodeHorizontalAlignment != ST_NodeHorizontalAlignmentUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_NodeHorizontalAlignment.String()))
	}
	if _dbaf.ST_NodeVerticalAlignment != ST_NodeVerticalAlignmentUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_NodeVerticalAlignment.String()))
	}
	if _dbaf.ST_FallbackDimension != ST_FallbackDimensionUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_FallbackDimension.String()))
	}
	if _dbaf.ST_TextDirection != ST_TextDirectionUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_TextDirection.String()))
	}
	if _dbaf.ST_PyramidAccentPosition != ST_PyramidAccentPositionUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_PyramidAccentPosition.String()))
	}
	if _dbaf.ST_PyramidAccentTextMargin != ST_PyramidAccentTextMarginUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_PyramidAccentTextMargin.String()))
	}
	if _dbaf.ST_TextBlockDirection != ST_TextBlockDirectionUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_TextBlockDirection.String()))
	}
	if _dbaf.ST_TextAnchorHorizontal != ST_TextAnchorHorizontalUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_TextAnchorHorizontal.String()))
	}
	if _dbaf.ST_TextAnchorVertical != ST_TextAnchorVerticalUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_TextAnchorVertical.String()))
	}
	if _dbaf.ST_DiagramTextAlignment != ST_DiagramTextAlignmentUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_DiagramTextAlignment.String()))
	}
	if _dbaf.ST_AutoTextRotation != ST_AutoTextRotationUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_AutoTextRotation.String()))
	}
	if _dbaf.ST_GrowDirection != ST_GrowDirectionUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_GrowDirection.String()))
	}
	if _dbaf.ST_FlowDirection != ST_FlowDirectionUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_FlowDirection.String()))
	}
	if _dbaf.ST_ContinueDirection != ST_ContinueDirectionUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_ContinueDirection.String()))
	}
	if _dbaf.ST_Breakpoint != ST_BreakpointUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_Breakpoint.String()))
	}
	if _dbaf.ST_Offset != ST_OffsetUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_Offset.String()))
	}
	if _dbaf.ST_HierarchyAlignment != ST_HierarchyAlignmentUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_HierarchyAlignment.String()))
	}
	if _dbaf.Int32 != nil {
		e.EncodeToken(_b.CharData(_a.Sprintf("\u0025d", *_dbaf.Int32)))
	}
	if _dbaf.Float64 != nil {
		e.EncodeToken(_b.CharData(_a.Sprintf("\u0025f", *_dbaf.Float64)))
	}
	if _dbaf.Bool != nil {
		e.EncodeToken(_b.CharData(_a.Sprintf("\u0025d", _eecbc(*_dbaf.Bool))))
	}
	if _dbaf.StringVal != nil {
		e.EncodeToken(_b.CharData(*_dbaf.StringVal))
	}
	if _dbaf.ST_ConnectorPoint != ST_ConnectorPointUnset {
		e.EncodeToken(_b.CharData(_dbaf.ST_ConnectorPoint.String()))
	}
	return e.EncodeToken(_b.EndElement{Name: start.Name})
}
func (_egfgg *ST_ElementType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_egfgg = 0
	case "all":
		*_egfgg = 1
	case "doc":
		*_egfgg = 2
	case "node":
		*_egfgg = 3
	case "norm":
		*_egfgg = 4
	case "nonNorm":
		*_egfgg = 5
	case "asst":
		*_egfgg = 6
	case "nonAsst":
		*_egfgg = 7
	case "parTrans":
		*_egfgg = 8
	case "pres":
		*_egfgg = 9
	case "sibTrans":
		*_egfgg = 10
	}
	return nil
}
func (_cbeeb *StyleDef) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:di"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "styleDef"
	return _cbeeb.CT_StyleDefinition.MarshalXML(e, start)
}
func (_dbcaa *ST_FunctionArgument) ValidateWithPath(path string) error {
	_eebef := []string{}
	if _dbcaa.ST_VariableType != ST_VariableTypeUnset {
		_eebef = append(_eebef, "ST_VariableType")
	}
	if len(_eebef) > 1 {
		return _a.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _eebef)
	}
	return nil
}
func (_cbbb ST_HueDir) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_cbbb.String(), start)
}

type CT_Category struct {
	TypeAttr string
	PriAttr  uint32
}

// ST_PrSetCustVal is a union type
type ST_PrSetCustVal struct {
	ST_Percentage *string
	Int32         *int32
}

func (_gabd *CT_StyleDefinition) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _accbc := range start.Attr {
		if _accbc.Name.Local == "uniqueId" {
			_agff, _gged := _accbc.Value, error(nil)
			if _gged != nil {
				return _gged
			}
			_gabd.UniqueIdAttr = &_agff
			continue
		}
		if _accbc.Name.Local == "minVer" {
			_adcff, _fabb := _accbc.Value, error(nil)
			if _fabb != nil {
				return _fabb
			}
			_gabd.MinVerAttr = &_adcff
			continue
		}
	}
_dcdc:
	for {
		_gecfa, _cbcfa := d.Token()
		if _cbcfa != nil {
			return _cbcfa
		}
		switch _cabaa := _gecfa.(type) {
		case _b.StartElement:
			switch _cabaa.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_bbac := NewCT_SDName()
				if _fffb := d.DecodeElement(_bbac, &_cabaa); _fffb != nil {
					return _fffb
				}
				_gabd.Title = append(_gabd.Title, _bbac)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_bcff := NewCT_SDDescription()
				if _edfce := d.DecodeElement(_bcff, &_cabaa); _edfce != nil {
					return _edfce
				}
				_gabd.Desc = append(_gabd.Desc, _bcff)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_gabd.CatLst = NewCT_SDCategories()
				if _bcde := d.DecodeElement(_gabd.CatLst, &_cabaa); _bcde != nil {
					return _bcde
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "scene3d"}:
				_gabd.Scene3d = _f.NewCT_Scene3D()
				if _gbaff := d.DecodeElement(_gabd.Scene3d, &_cabaa); _gbaff != nil {
					return _gbaff
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "styleLbl"}:
				_geecb := NewCT_StyleLabel()
				if _dbfbe := d.DecodeElement(_geecb, &_cabaa); _dbfbe != nil {
					return _dbfbe
				}
				_gabd.StyleLbl = append(_gabd.StyleLbl, _geecb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_gabd.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _dccf := d.DecodeElement(_gabd.ExtLst, &_cabaa); _dccf != nil {
					return _dccf
				}
			default:
				_ea.Log("skipping\u0020unsupported element\u0020on\u0020CT_StyleDefinition\u0020\u0025v", _cabaa.Name)
				if _edd := d.Skip(); _edd != nil {
					return _edd
				}
			}
		case _b.EndElement:
			break _dcdc
		case _b.CharData:
		}
	}
	return nil
}

type CT_Choose struct {
	NameAttr *string
	If       []*CT_When
	Else     *CT_Otherwise
}
type CT_Parameter struct {
	TypeAttr ST_ParameterId
	ValAttr  ST_ParameterVal
}

const (
	ST_RotationPathUnset     ST_RotationPath = 0
	ST_RotationPathNone      ST_RotationPath = 1
	ST_RotationPathAlongPath ST_RotationPath = 2
)

func (_gfege *ST_PyramidAccentTextMargin) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_gfege = 0
	case "step":
		*_gfege = 1
	case "stack":
		*_gfege = 2
	}
	return nil
}
func (_dega ST_AnimLvlStr) String() string {
	switch _dega {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "lvl"
	case 3:
		return "ctr"
	}
	return ""
}
func (_acdcf ST_TextDirection) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_acdcf.String(), start)
}
func NewCT_DiagramDefinitionHeaderLst() *CT_DiagramDefinitionHeaderLst {
	_dba := &CT_DiagramDefinitionHeaderLst{}
	return _dba
}

type ST_ConnectorDimension byte

func (_fbfae *ST_NodeHorizontalAlignment) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fbfae = 0
	case "l":
		*_fbfae = 1
	case "ctr":
		*_fbfae = 2
	case "r":
		*_fbfae = 3
	}
	return nil
}

const (
	ST_OutputShapeTypeUnset ST_OutputShapeType = 0
	ST_OutputShapeTypeNone  ST_OutputShapeType = 1
	ST_OutputShapeTypeConn  ST_OutputShapeType = 2
)

func (_bbeee ST_RotationPath) Validate() error { return _bbeee.ValidateWithPath("") }

// Validate validates the CT_OrgChart and its children
func (_dfaad *CT_OrgChart) Validate() error { return _dfaad.ValidateWithPath("CT_OrgChart") }

type ST_ConstraintRelationship byte

func (_fcca ST_DiagramTextAlignment) Validate() error { return _fcca.ValidateWithPath("") }
func NewCT_TextProps() *CT_TextProps                  { _ccfba := &CT_TextProps{}; return _ccfba }

const (
	ST_ConstraintRelationshipUnset ST_ConstraintRelationship = 0
	ST_ConstraintRelationshipSelf  ST_ConstraintRelationship = 1
	ST_ConstraintRelationshipCh    ST_ConstraintRelationship = 2
	ST_ConstraintRelationshipDes   ST_ConstraintRelationship = 3
)

func (_eaffg ST_LinearDirection) String() string {
	switch _eaffg {
	case 0:
		return ""
	case 1:
		return "fromL"
	case 2:
		return "fromR"
	case 3:
		return "fromT"
	case 4:
		return "fromB"
	}
	return ""
}

// Validate validates the CT_PtList and its children
func (_deed *CT_PtList) Validate() error { return _deed.ValidateWithPath("CT_PtList") }
func (_bdead ST_NodeHorizontalAlignment) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_fdgcg := _b.Attr{}
	_fdgcg.Name = name
	switch _bdead {
	case ST_NodeHorizontalAlignmentUnset:
		_fdgcg.Value = ""
	case ST_NodeHorizontalAlignmentL:
		_fdgcg.Value = "l"
	case ST_NodeHorizontalAlignmentCtr:
		_fdgcg.Value = "ctr"
	case ST_NodeHorizontalAlignmentR:
		_fdgcg.Value = "r"
	}
	return _fdgcg, nil
}

type ST_Ints []int32

func (_beaec *ST_ChildOrderType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_becge, _cfge := d.Token()
	if _cfge != nil {
		return _cfge
	}
	if _eeaea, _dcdgd := _becge.(_b.EndElement); _dcdgd && _eeaea.Name == start.Name {
		*_beaec = 1
		return nil
	}
	if _gcgbb, _cfaa := _becge.(_b.CharData); !_cfaa {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _becge)
	} else {
		switch string(_gcgbb) {
		case "":
			*_beaec = 0
		case "b":
			*_beaec = 1
		case "t":
			*_beaec = 2
		}
	}
	_becge, _cfge = d.Token()
	if _cfge != nil {
		return _cfge
	}
	if _acdfa, _eccd := _becge.(_b.EndElement); _eccd && _acdfa.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _becge)
}

// ValidateWithPath validates the CT_Shape and its children, prefixing error messages with path
func (_fbgga *CT_Shape) ValidateWithPath(path string) error {
	if _fbgga.TypeAttr != nil {
		if _bcfb := _fbgga.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _bcfb != nil {
			return _bcfb
		}
	}
	if _fbgga.AdjLst != nil {
		if _eecb := _fbgga.AdjLst.ValidateWithPath(path + "\u002fAdjLst"); _eecb != nil {
			return _eecb
		}
	}
	if _fbgga.ExtLst != nil {
		if _aefa := _fbgga.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _aefa != nil {
			return _aefa
		}
	}
	return nil
}
func (_beefg *CT_Parameter) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	_cbbc, _abaf := _beefg.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
	if _abaf != nil {
		return _abaf
	}
	start.Attr = append(start.Attr, _cbbc)
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", _beefg.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewCT_SDDescription() *CT_SDDescription { _afca := &CT_SDDescription{}; return _afca }
func (_faadf *ColorsDefHdr) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:di"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "colorsDefHdr"
	return _faadf.CT_ColorTransformHeader.MarshalXML(e, start)
}

// Validate validates the CT_When and its children
func (_bbga *CT_When) Validate() error { return _bbga.ValidateWithPath("CT_When") }
func (_cafa *CT_Rules) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_abafe:
	for {
		_adcc, _aedga := d.Token()
		if _aedga != nil {
			return _aedga
		}
		switch _cgfb := _adcc.(type) {
		case _b.StartElement:
			switch _cgfb.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "rule"}:
				_bgeg := NewCT_NumericRule()
				if _adfe := d.DecodeElement(_bgeg, &_cgfb); _adfe != nil {
					return _adfe
				}
				_cafa.Rule = append(_cafa.Rule, _bgeg)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Rules\u0020\u0025v", _cgfb.Name)
				if _ecdc := d.Skip(); _ecdc != nil {
					return _ecdc
				}
			}
		case _b.EndElement:
			break _abafe
		case _b.CharData:
		}
	}
	return nil
}
func (_bfdgc *ST_ResizeHandlesStr) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_bfdgc = 0
	case "exact":
		*_bfdgc = 1
	case "rel":
		*_bfdgc = 2
	}
	return nil
}
func (_dfgb *ST_ConnectorDimension) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bfbdd, _acfbf := d.Token()
	if _acfbf != nil {
		return _acfbf
	}
	if _gcbfe, _eecad := _bfbdd.(_b.EndElement); _eecad && _gcbfe.Name == start.Name {
		*_dfgb = 1
		return nil
	}
	if _bcade, _afabg := _bfbdd.(_b.CharData); !_afabg {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bfbdd)
	} else {
		switch string(_bcade) {
		case "":
			*_dfgb = 0
		case "1D":
			*_dfgb = 1
		case "2D":
			*_dfgb = 2
		case "cust":
			*_dfgb = 3
		}
	}
	_bfbdd, _acfbf = d.Token()
	if _acfbf != nil {
		return _acfbf
	}
	if _dfgcg, _dfea := _bfbdd.(_b.EndElement); _dfea && _dfgcg.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bfbdd)
}

const (
	ST_FunctionOperatorUnset ST_FunctionOperator = 0
	ST_FunctionOperatorEqu   ST_FunctionOperator = 1
	ST_FunctionOperatorNeq   ST_FunctionOperator = 2
	ST_FunctionOperatorGt    ST_FunctionOperator = 3
	ST_FunctionOperatorLt    ST_FunctionOperator = 4
	ST_FunctionOperatorGte   ST_FunctionOperator = 5
	ST_FunctionOperatorLte   ST_FunctionOperator = 6
)

func (_egbbe ST_CenterShapeMapping) Validate() error { return _egbbe.ValidateWithPath("") }

type CT_StyleDefinition struct {
	UniqueIdAttr *string
	MinVerAttr   *string
	Title        []*CT_SDName
	Desc         []*CT_SDDescription
	CatLst       *CT_SDCategories
	Scene3d      *_f.CT_Scene3D
	StyleLbl     []*CT_StyleLabel
	ExtLst       *_f.CT_OfficeArtExtensionList
}

func (_dcca ST_VariableType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_cbfdb := _b.Attr{}
	_cbfdb.Name = name
	switch _dcca {
	case ST_VariableTypeUnset:
		_cbfdb.Value = ""
	case ST_VariableTypeNone:
		_cbfdb.Value = "none"
	case ST_VariableTypeOrgChart:
		_cbfdb.Value = "orgChart"
	case ST_VariableTypeChMax:
		_cbfdb.Value = "chMax"
	case ST_VariableTypeChPref:
		_cbfdb.Value = "chPref"
	case ST_VariableTypeBulEnabled:
		_cbfdb.Value = "bulEnabled"
	case ST_VariableTypeDir:
		_cbfdb.Value = "dir"
	case ST_VariableTypeHierBranch:
		_cbfdb.Value = "hierBranch"
	case ST_VariableTypeAnimOne:
		_cbfdb.Value = "animOne"
	case ST_VariableTypeAnimLvl:
		_cbfdb.Value = "animLvl"
	case ST_VariableTypeResizeHandles:
		_cbfdb.Value = "resizeHandles"
	}
	return _cbfdb, nil
}
func (_daaec *ST_DiagramHorizontalAlignment) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_daaec = 0
	case "l":
		*_daaec = 1
	case "ctr":
		*_daaec = 2
	case "r":
		*_daaec = 3
	case "none":
		*_daaec = 4
	}
	return nil
}
func (_ae *AG_ConstraintAttributes) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ae.TypeAttr != ST_ConstraintTypeUnset {
		_c, _ce := _ae.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _ce != nil {
			return _ce
		}
		start.Attr = append(start.Attr, _c)
	}
	if _ae.ForAttr != ST_ConstraintRelationshipUnset {
		_g, _bb := _ae.ForAttr.MarshalXMLAttr(_b.Name{Local: "for"})
		if _bb != nil {
			return _bb
		}
		start.Attr = append(start.Attr, _g)
	}
	if _ae.ForNameAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "forName"}, Value: _a.Sprintf("\u0025v", *_ae.ForNameAttr)})
	}
	if _ae.PtTypeAttr != ST_ElementTypeUnset {
		_cb, _cbd := _ae.PtTypeAttr.MarshalXMLAttr(_b.Name{Local: "ptType"})
		if _cbd != nil {
			return _cbd
		}
		start.Attr = append(start.Attr, _cb)
	}
	return nil
}
func (_bgcb *LayoutDefHdrLst) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bgcb.CT_DiagramDefinitionHeaderLst = *NewCT_DiagramDefinitionHeaderLst()
_bgee:
	for {
		_ecgc, _bega := d.Token()
		if _bega != nil {
			return _bega
		}
		switch _bacdd := _ecgc.(type) {
		case _b.StartElement:
			switch _bacdd.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "layoutDefHdr"}:
				_ccfe := NewCT_DiagramDefinitionHeader()
				if _cecc := d.DecodeElement(_ccfe, &_bacdd); _cecc != nil {
					return _cecc
				}
				_bgcb.LayoutDefHdr = append(_bgcb.LayoutDefHdr, _ccfe)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020LayoutDefHdrLst\u0020\u0025v", _bacdd.Name)
				if _feacf := d.Skip(); _feacf != nil {
					return _feacf
				}
			}
		case _b.EndElement:
			break _bgee
		case _b.CharData:
		}
	}
	return nil
}
func (_bgcf *ST_FallbackDimension) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ffeb, _cffba := d.Token()
	if _cffba != nil {
		return _cffba
	}
	if _gbfbab, _befaf := _ffeb.(_b.EndElement); _befaf && _gbfbab.Name == start.Name {
		*_bgcf = 1
		return nil
	}
	if _ddbgf, _bddg := _ffeb.(_b.CharData); !_bddg {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ffeb)
	} else {
		switch string(_ddbgf) {
		case "":
			*_bgcf = 0
		case "1D":
			*_bgcf = 1
		case "2D":
			*_bgcf = 2
		}
	}
	_ffeb, _cffba = d.Token()
	if _cffba != nil {
		return _cffba
	}
	if _agdgcg, _eade := _ffeb.(_b.EndElement); _eade && _agdgcg.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ffeb)
}

// Validate validates the LayoutDefHdrLst and its children
func (_agbf *LayoutDefHdrLst) Validate() error { return _agbf.ValidateWithPath("LayoutDefHdrLst") }
func (_fdga *CT_HierBranchStyle) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _fdga.ValAttr != ST_HierBranchStyleUnset {
		_bfgg, _efe := _fdga.ValAttr.MarshalXMLAttr(_b.Name{Local: "val"})
		if _efe != nil {
			return _efe
		}
		start.Attr = append(start.Attr, _bfgg)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_bgca *CT_ColorTransformHeader) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ecbb := range start.Attr {
		if _ecbb.Name.Local == "uniqueId" {
			_abb, _fbac := _ecbb.Value, error(nil)
			if _fbac != nil {
				return _fbac
			}
			_bgca.UniqueIdAttr = _abb
			continue
		}
		if _ecbb.Name.Local == "minVer" {
			_ceaa, _bdba := _ecbb.Value, error(nil)
			if _bdba != nil {
				return _bdba
			}
			_bgca.MinVerAttr = &_ceaa
			continue
		}
		if _ecbb.Name.Local == "resId" {
			_gecb, _fde := _d.ParseInt(_ecbb.Value, 10, 32)
			if _fde != nil {
				return _fde
			}
			_gegf := int32(_gecb)
			_bgca.ResIdAttr = &_gegf
			continue
		}
	}
_afg:
	for {
		_gdgc, _dgf := d.Token()
		if _dgf != nil {
			return _dgf
		}
		switch _egdf := _gdgc.(type) {
		case _b.StartElement:
			switch _egdf.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_bced := NewCT_CTName()
				if _efaff := d.DecodeElement(_bced, &_egdf); _efaff != nil {
					return _efaff
				}
				_bgca.Title = append(_bgca.Title, _bced)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_deff := NewCT_CTDescription()
				if _acc := d.DecodeElement(_deff, &_egdf); _acc != nil {
					return _acc
				}
				_bgca.Desc = append(_bgca.Desc, _deff)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_bgca.CatLst = NewCT_CTCategories()
				if _fbcf := d.DecodeElement(_bgca.CatLst, &_egdf); _fbcf != nil {
					return _fbcf
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_bgca.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _bfba := d.DecodeElement(_bgca.ExtLst, &_egdf); _bfba != nil {
					return _bfba
				}
			default:
				_ea.Log("skipping\u0020unsupported element\u0020on\u0020CT_ColorTransformHeader \u0025v", _egdf.Name)
				if _gcc := d.Skip(); _gcc != nil {
					return _gcc
				}
			}
		case _b.EndElement:
			break _afg
		case _b.CharData:
		}
	}
	return nil
}
func (_abgcb ST_ParameterId) String() string {
	switch _abgcb {
	case 0:
		return ""
	case 1:
		return "horzAlign"
	case 2:
		return "vertAlign"
	case 3:
		return "chDir"
	case 4:
		return "chAlign"
	case 5:
		return "secChAlign"
	case 6:
		return "linDir"
	case 7:
		return "secLinDir"
	case 8:
		return "stElem"
	case 9:
		return "bendPt"
	case 10:
		return "connRout"
	case 11:
		return "begSty"
	case 12:
		return "endSty"
	case 13:
		return "dim"
	case 14:
		return "rotPath"
	case 15:
		return "ctrShpMap"
	case 16:
		return "nodeHorzAlign"
	case 17:
		return "nodeVertAlign"
	case 18:
		return "fallback"
	case 19:
		return "txDir"
	case 20:
		return "pyraAcctPos"
	case 21:
		return "pyraAcctTxMar"
	case 22:
		return "txBlDir"
	case 23:
		return "txAnchorHorz"
	case 24:
		return "txAnchorVert"
	case 25:
		return "txAnchorHorzCh"
	case 26:
		return "txAnchorVertCh"
	case 27:
		return "parTxLTRAlign"
	case 28:
		return "parTxRTLAlign"
	case 29:
		return "shpTxLTRAlignCh"
	case 30:
		return "shpTxRTLAlignCh"
	case 31:
		return "autoTxRot"
	case 32:
		return "grDir"
	case 33:
		return "flowDir"
	case 34:
		return "contDir"
	case 35:
		return "bkpt"
	case 36:
		return "off"
	case 37:
		return "hierAlign"
	case 38:
		return "bkPtFixedVal"
	case 39:
		return "stBulletLvl"
	case 40:
		return "stAng"
	case 41:
		return "spanAng"
	case 42:
		return "ar"
	case 43:
		return "lnSpPar"
	case 44:
		return "lnSpAfParP"
	case 45:
		return "lnSpCh"
	case 46:
		return "lnSpAfChP"
	case 47:
		return "rtShortDist"
	case 48:
		return "alignTx"
	case 49:
		return "pyraLvlNode"
	case 50:
		return "pyraAcctBkgdNode"
	case 51:
		return "pyraAcctTxNode"
	case 52:
		return "srcNode"
	case 53:
		return "dstNode"
	case 54:
		return "begPts"
	case 55:
		return "endPts"
	}
	return ""
}
func NewCT_LayoutNode() *CT_LayoutNode { _geaeg := &CT_LayoutNode{}; return _geaeg }

// ValidateWithPath validates the StyleDefHdrLst and its children, prefixing error messages with path
func (_adecb *StyleDefHdrLst) ValidateWithPath(path string) error {
	if _fgge := _adecb.CT_StyleDefinitionHeaderLst.ValidateWithPath(path); _fgge != nil {
		return _fgge
	}
	return nil
}
func (_bceed *CT_StyleLabel) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "name"}, Value: _a.Sprintf("\u0025v", _bceed.NameAttr)})
	e.EncodeToken(start)
	if _bceed.Scene3d != nil {
		_eggca := _b.StartElement{Name: _b.Name{Local: "scene3d"}}
		e.EncodeElement(_bceed.Scene3d, _eggca)
	}
	if _bceed.Sp3d != nil {
		_baff := _b.StartElement{Name: _b.Name{Local: "sp3d"}}
		e.EncodeElement(_bceed.Sp3d, _baff)
	}
	if _bceed.TxPr != nil {
		_gbae := _b.StartElement{Name: _b.Name{Local: "txPr"}}
		e.EncodeElement(_bceed.TxPr, _gbae)
	}
	if _bceed.Style != nil {
		_dbfe := _b.StartElement{Name: _b.Name{Local: "style"}}
		e.EncodeElement(_bceed.Style, _dbfe)
	}
	if _bceed.ExtLst != nil {
		_bafa := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_bceed.ExtLst, _bafa)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_aceg *CT_StyleDefinitionHeader) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "uniqueId"}, Value: _a.Sprintf("\u0025v", _aceg.UniqueIdAttr)})
	if _aceg.MinVerAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "minVer"}, Value: _a.Sprintf("\u0025v", *_aceg.MinVerAttr)})
	}
	if _aceg.ResIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "resId"}, Value: _a.Sprintf("\u0025v", *_aceg.ResIdAttr)})
	}
	e.EncodeToken(start)
	_fgfg := _b.StartElement{Name: _b.Name{Local: "title"}}
	for _, _ffff := range _aceg.Title {
		e.EncodeElement(_ffff, _fgfg)
	}
	_fbacc := _b.StartElement{Name: _b.Name{Local: "desc"}}
	for _, _ddda := range _aceg.Desc {
		e.EncodeElement(_ddda, _fbacc)
	}
	if _aceg.CatLst != nil {
		_cfeff := _b.StartElement{Name: _b.Name{Local: "catLst"}}
		e.EncodeElement(_aceg.CatLst, _cfeff)
	}
	if _aceg.ExtLst != nil {
		_ebdg := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_aceg.ExtLst, _ebdg)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the LayoutDef and its children
func (_aggg *LayoutDef) Validate() error { return _aggg.ValidateWithPath("LayoutDef") }

type ST_HueDir byte

func (_egbbg ST_FlowDirection) String() string {
	switch _egbbg {
	case 0:
		return ""
	case 1:
		return "row"
	case 2:
		return "col"
	}
	return ""
}
func NewCT_Otherwise() *CT_Otherwise { _aebe := &CT_Otherwise{}; return _aebe }

const (
	ST_SecondaryChildAlignmentUnset ST_SecondaryChildAlignment = 0
	ST_SecondaryChildAlignmentNone  ST_SecondaryChildAlignment = 1
	ST_SecondaryChildAlignmentT     ST_SecondaryChildAlignment = 2
	ST_SecondaryChildAlignmentB     ST_SecondaryChildAlignment = 3
	ST_SecondaryChildAlignmentL     ST_SecondaryChildAlignment = 4
	ST_SecondaryChildAlignmentR     ST_SecondaryChildAlignment = 5
)
const (
	ST_LinearDirectionUnset ST_LinearDirection = 0
	ST_LinearDirectionFromL ST_LinearDirection = 1
	ST_LinearDirectionFromR ST_LinearDirection = 2
	ST_LinearDirectionFromT ST_LinearDirection = 3
	ST_LinearDirectionFromB ST_LinearDirection = 4
)

func NewCT_ColorTransformHeader() *CT_ColorTransformHeader {
	_adc := &CT_ColorTransformHeader{}
	return _adc
}
func (_gdaa ST_PyramidAccentTextMargin) Validate() error { return _gdaa.ValidateWithPath("") }

// ValidateWithPath validates the CT_CTCategory and its children, prefixing error messages with path
func (_cdfg *CT_CTCategory) ValidateWithPath(path string) error { return nil }
func (_egfaa ST_BoolOperator) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_egfaa.String(), start)
}
func (_gcec ST_HierarchyAlignment) Validate() error { return _gcec.ValidateWithPath("") }
func (_dgbgc *ST_TextDirection) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_agag, _cadd := d.Token()
	if _cadd != nil {
		return _cadd
	}
	if _cdcg, _ffcca := _agag.(_b.EndElement); _ffcca && _cdcg.Name == start.Name {
		*_dgbgc = 1
		return nil
	}
	if _cebg, _ecfab := _agag.(_b.CharData); !_ecfab {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _agag)
	} else {
		switch string(_cebg) {
		case "":
			*_dgbgc = 0
		case "fromT":
			*_dgbgc = 1
		case "fromB":
			*_dgbgc = 2
		}
	}
	_agag, _cadd = d.Token()
	if _cadd != nil {
		return _cadd
	}
	if _gafbd, _adfbc := _agag.(_b.EndElement); _adfbc && _gafbd.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _agag)
}
func ParseSliceST_AxisTypes(s string) (ST_AxisTypes, error) { return ST_AxisTypes{}, nil }
func (_daee *ST_Offset) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_feab, _bdccc := d.Token()
	if _bdccc != nil {
		return _bdccc
	}
	if _gfbdd, _abgad := _feab.(_b.EndElement); _abgad && _gfbdd.Name == start.Name {
		*_daee = 1
		return nil
	}
	if _acgde, _acagg := _feab.(_b.CharData); !_acagg {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _feab)
	} else {
		switch string(_acgde) {
		case "":
			*_daee = 0
		case "ctr":
			*_daee = 1
		case "off":
			*_daee = 2
		}
	}
	_feab, _bdccc = d.Token()
	if _bdccc != nil {
		return _bdccc
	}
	if _acgbg, _ecade := _feab.(_b.EndElement); _ecade && _acgbg.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _feab)
}
func (_aeag *ColorsDefHdrLst) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:di"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "colorsDefHdrLst"
	return _aeag.CT_ColorTransformHeaderLst.MarshalXML(e, start)
}
func (_fbdda *CT_StyleLabel) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _aaeb := range start.Attr {
		if _aaeb.Name.Local == "name" {
			_abda, _dbcc := _aaeb.Value, error(nil)
			if _dbcc != nil {
				return _dbcc
			}
			_fbdda.NameAttr = _abda
			continue
		}
	}
_dgfag:
	for {
		_gcbf, _bgdd := d.Token()
		if _bgdd != nil {
			return _bgdd
		}
		switch _bdf := _gcbf.(type) {
		case _b.StartElement:
			switch _bdf.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "scene3d"}:
				_fbdda.Scene3d = _f.NewCT_Scene3D()
				if _begde := d.DecodeElement(_fbdda.Scene3d, &_bdf); _begde != nil {
					return _begde
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "sp3d"}:
				_fbdda.Sp3d = _f.NewCT_Shape3D()
				if _egbba := d.DecodeElement(_fbdda.Sp3d, &_bdf); _egbba != nil {
					return _egbba
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "txPr"}:
				_fbdda.TxPr = NewCT_TextProps()
				if _dgage := d.DecodeElement(_fbdda.TxPr, &_bdf); _dgage != nil {
					return _dgage
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "style"}:
				_fbdda.Style = _f.NewCT_ShapeStyle()
				if _ddff := d.DecodeElement(_fbdda.Style, &_bdf); _ddff != nil {
					return _ddff
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_fbdda.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _adcda := d.DecodeElement(_fbdda.ExtLst, &_bdf); _adcda != nil {
					return _adcda
				}
			default:
				_ea.Log("skipping unsupported element\u0020on\u0020CT_StyleLabel \u0025v", _bdf.Name)
				if _ggaa := d.Skip(); _ggaa != nil {
					return _ggaa
				}
			}
		case _b.EndElement:
			break _dgfag
		case _b.CharData:
		}
	}
	return nil
}
func (_bdfd *StyleDefHdr) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:di"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "styleDefHdr"
	return _bdfd.CT_StyleDefinitionHeader.MarshalXML(e, start)
}

// Validate validates the CT_BulletEnabled and its children
func (_eag *CT_BulletEnabled) Validate() error { return _eag.ValidateWithPath("CT_BulletEnabled") }
func (_fgdg ST_HierarchyAlignment) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bfee := _b.Attr{}
	_bfee.Name = name
	switch _fgdg {
	case ST_HierarchyAlignmentUnset:
		_bfee.Value = ""
	case ST_HierarchyAlignmentTL:
		_bfee.Value = "tL"
	case ST_HierarchyAlignmentTR:
		_bfee.Value = "tR"
	case ST_HierarchyAlignmentTCtrCh:
		_bfee.Value = "tCtrCh"
	case ST_HierarchyAlignmentTCtrDes:
		_bfee.Value = "tCtrDes"
	case ST_HierarchyAlignmentBL:
		_bfee.Value = "bL"
	case ST_HierarchyAlignmentBR:
		_bfee.Value = "bR"
	case ST_HierarchyAlignmentBCtrCh:
		_bfee.Value = "bCtrCh"
	case ST_HierarchyAlignmentBCtrDes:
		_bfee.Value = "bCtrDes"
	case ST_HierarchyAlignmentLT:
		_bfee.Value = "lT"
	case ST_HierarchyAlignmentLB:
		_bfee.Value = "lB"
	case ST_HierarchyAlignmentLCtrCh:
		_bfee.Value = "lCtrCh"
	case ST_HierarchyAlignmentLCtrDes:
		_bfee.Value = "lCtrDes"
	case ST_HierarchyAlignmentRT:
		_bfee.Value = "rT"
	case ST_HierarchyAlignmentRB:
		_bfee.Value = "rB"
	case ST_HierarchyAlignmentRCtrCh:
		_bfee.Value = "rCtrCh"
	case ST_HierarchyAlignmentRCtrDes:
		_bfee.Value = "rCtrDes"
	}
	return _bfee, nil
}

const (
	ST_TextBlockDirectionUnset ST_TextBlockDirection = 0
	ST_TextBlockDirectionHorz  ST_TextBlockDirection = 1
	ST_TextBlockDirectionVert  ST_TextBlockDirection = 2
)

func NewCT_SDCategory() *CT_SDCategory { _bbbg := &CT_SDCategory{}; return _bbbg }

const (
	ST_NodeVerticalAlignmentUnset ST_NodeVerticalAlignment = 0
	ST_NodeVerticalAlignmentT     ST_NodeVerticalAlignment = 1
	ST_NodeVerticalAlignmentMid   ST_NodeVerticalAlignment = 2
	ST_NodeVerticalAlignmentB     ST_NodeVerticalAlignment = 3
)

func (_egbf *ST_ConnectorPoint) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_facab, _gddcfc := d.Token()
	if _gddcfc != nil {
		return _gddcfc
	}
	if _fegbc, _agdc := _facab.(_b.EndElement); _agdc && _fegbc.Name == start.Name {
		*_egbf = 1
		return nil
	}
	if _cbccf, _ccbcf := _facab.(_b.CharData); !_ccbcf {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _facab)
	} else {
		switch string(_cbccf) {
		case "":
			*_egbf = 0
		case "auto":
			*_egbf = 1
		case "bCtr":
			*_egbf = 2
		case "ctr":
			*_egbf = 3
		case "midL":
			*_egbf = 4
		case "midR":
			*_egbf = 5
		case "tCtr":
			*_egbf = 6
		case "bL":
			*_egbf = 7
		case "bR":
			*_egbf = 8
		case "tL":
			*_egbf = 9
		case "tR":
			*_egbf = 10
		case "radial":
			*_egbf = 11
		}
	}
	_facab, _gddcfc = d.Token()
	if _gddcfc != nil {
		return _gddcfc
	}
	if _dbbbd, _ddgg := _facab.(_b.EndElement); _ddgg && _dbbbd.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _facab)
}
func (_ffcf ST_ParameterId) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_ffcf.String(), start)
}

const (
	ST_GrowDirectionUnset ST_GrowDirection = 0
	ST_GrowDirectionTL    ST_GrowDirection = 1
	ST_GrowDirectionTR    ST_GrowDirection = 2
	ST_GrowDirectionBL    ST_GrowDirection = 3
	ST_GrowDirectionBR    ST_GrowDirection = 4
)

func (_ccaed ST_CxnType) ValidateWithPath(path string) error {
	switch _ccaed {
	case 0, 1, 2, 3, 4:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ccaed))
	}
	return nil
}
func (_bagfe ST_RotationPath) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bagfe.String(), start)
}

// Validate validates the CT_SDDescription and its children
func (_ceca *CT_SDDescription) Validate() error { return _ceca.ValidateWithPath("CT_SDDescription") }

// Validate validates the CT_SDCategory and its children
func (_dbcea *CT_SDCategory) Validate() error { return _dbcea.ValidateWithPath("CT_SDCategory") }
func (_bfgfe ST_GrowDirection) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gddae := _b.Attr{}
	_gddae.Name = name
	switch _bfgfe {
	case ST_GrowDirectionUnset:
		_gddae.Value = ""
	case ST_GrowDirectionTL:
		_gddae.Value = "tL"
	case ST_GrowDirectionTR:
		_gddae.Value = "tR"
	case ST_GrowDirectionBL:
		_gddae.Value = "bL"
	case ST_GrowDirectionBR:
		_gddae.Value = "bR"
	}
	return _gddae, nil
}
func (_dagf *ST_ConstraintRelationship) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gdegg, _bgce := d.Token()
	if _bgce != nil {
		return _bgce
	}
	if _gdcd, _gfcb := _gdegg.(_b.EndElement); _gfcb && _gdcd.Name == start.Name {
		*_dagf = 1
		return nil
	}
	if _cbdde, _cgeda := _gdegg.(_b.CharData); !_cgeda {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gdegg)
	} else {
		switch string(_cbdde) {
		case "":
			*_dagf = 0
		case "self":
			*_dagf = 1
		case "ch":
			*_dagf = 2
		case "des":
			*_dagf = 3
		}
	}
	_gdegg, _bgce = d.Token()
	if _bgce != nil {
		return _bgce
	}
	if _gafbf, _dcfc := _gdegg.(_b.EndElement); _dcfc && _gafbf.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gdegg)
}

type ST_Offset byte

func (_bbbf ST_ChildDirection) ValidateWithPath(path string) error {
	switch _bbbf {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bbbf))
	}
	return nil
}
func (_fbacf *ST_CenterShapeMapping) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_adaeb, _fccea := d.Token()
	if _fccea != nil {
		return _fccea
	}
	if _abce, _faag := _adaeb.(_b.EndElement); _faag && _abce.Name == start.Name {
		*_fbacf = 1
		return nil
	}
	if _cbce, _bacdf := _adaeb.(_b.CharData); !_bacdf {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _adaeb)
	} else {
		switch string(_cbce) {
		case "":
			*_fbacf = 0
		case "none":
			*_fbacf = 1
		case "fNode":
			*_fbacf = 2
		}
	}
	_adaeb, _fccea = d.Token()
	if _fccea != nil {
		return _fccea
	}
	if _ecbfb, _bdbc := _adaeb.(_b.EndElement); _bdbc && _ecbfb.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _adaeb)
}

type LayoutDefHdr struct{ CT_DiagramDefinitionHeader }

func NewCT_StyleDefinitionHeaderLst() *CT_StyleDefinitionHeaderLst {
	_fgcbg := &CT_StyleDefinitionHeaderLst{}
	return _fgcbg
}

type ST_ResizeHandlesStr byte

func (_cddfad ST_ConnectorPoint) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_afdg := _b.Attr{}
	_afdg.Name = name
	switch _cddfad {
	case ST_ConnectorPointUnset:
		_afdg.Value = ""
	case ST_ConnectorPointAuto:
		_afdg.Value = "auto"
	case ST_ConnectorPointBCtr:
		_afdg.Value = "bCtr"
	case ST_ConnectorPointCtr:
		_afdg.Value = "ctr"
	case ST_ConnectorPointMidL:
		_afdg.Value = "midL"
	case ST_ConnectorPointMidR:
		_afdg.Value = "midR"
	case ST_ConnectorPointTCtr:
		_afdg.Value = "tCtr"
	case ST_ConnectorPointBL:
		_afdg.Value = "bL"
	case ST_ConnectorPointBR:
		_afdg.Value = "bR"
	case ST_ConnectorPointTL:
		_afdg.Value = "tL"
	case ST_ConnectorPointTR:
		_afdg.Value = "tR"
	case ST_ConnectorPointRadial:
		_afdg.Value = "radial"
	}
	return _afdg, nil
}
func (_ecbe ST_StartingElement) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_ecbe.String(), start)
}
func (_cefae ST_ElementType) Validate() error { return _cefae.ValidateWithPath("") }

const (
	ST_ParameterIdUnset            ST_ParameterId = 0
	ST_ParameterIdHorzAlign        ST_ParameterId = 1
	ST_ParameterIdVertAlign        ST_ParameterId = 2
	ST_ParameterIdChDir            ST_ParameterId = 3
	ST_ParameterIdChAlign          ST_ParameterId = 4
	ST_ParameterIdSecChAlign       ST_ParameterId = 5
	ST_ParameterIdLinDir           ST_ParameterId = 6
	ST_ParameterIdSecLinDir        ST_ParameterId = 7
	ST_ParameterIdStElem           ST_ParameterId = 8
	ST_ParameterIdBendPt           ST_ParameterId = 9
	ST_ParameterIdConnRout         ST_ParameterId = 10
	ST_ParameterIdBegSty           ST_ParameterId = 11
	ST_ParameterIdEndSty           ST_ParameterId = 12
	ST_ParameterIdDim              ST_ParameterId = 13
	ST_ParameterIdRotPath          ST_ParameterId = 14
	ST_ParameterIdCtrShpMap        ST_ParameterId = 15
	ST_ParameterIdNodeHorzAlign    ST_ParameterId = 16
	ST_ParameterIdNodeVertAlign    ST_ParameterId = 17
	ST_ParameterIdFallback         ST_ParameterId = 18
	ST_ParameterIdTxDir            ST_ParameterId = 19
	ST_ParameterIdPyraAcctPos      ST_ParameterId = 20
	ST_ParameterIdPyraAcctTxMar    ST_ParameterId = 21
	ST_ParameterIdTxBlDir          ST_ParameterId = 22
	ST_ParameterIdTxAnchorHorz     ST_ParameterId = 23
	ST_ParameterIdTxAnchorVert     ST_ParameterId = 24
	ST_ParameterIdTxAnchorHorzCh   ST_ParameterId = 25
	ST_ParameterIdTxAnchorVertCh   ST_ParameterId = 26
	ST_ParameterIdParTxLTRAlign    ST_ParameterId = 27
	ST_ParameterIdParTxRTLAlign    ST_ParameterId = 28
	ST_ParameterIdShpTxLTRAlignCh  ST_ParameterId = 29
	ST_ParameterIdShpTxRTLAlignCh  ST_ParameterId = 30
	ST_ParameterIdAutoTxRot        ST_ParameterId = 31
	ST_ParameterIdGrDir            ST_ParameterId = 32
	ST_ParameterIdFlowDir          ST_ParameterId = 33
	ST_ParameterIdContDir          ST_ParameterId = 34
	ST_ParameterIdBkpt             ST_ParameterId = 35
	ST_ParameterIdOff              ST_ParameterId = 36
	ST_ParameterIdHierAlign        ST_ParameterId = 37
	ST_ParameterIdBkPtFixedVal     ST_ParameterId = 38
	ST_ParameterIdStBulletLvl      ST_ParameterId = 39
	ST_ParameterIdStAng            ST_ParameterId = 40
	ST_ParameterIdSpanAng          ST_ParameterId = 41
	ST_ParameterIdAr               ST_ParameterId = 42
	ST_ParameterIdLnSpPar          ST_ParameterId = 43
	ST_ParameterIdLnSpAfParP       ST_ParameterId = 44
	ST_ParameterIdLnSpCh           ST_ParameterId = 45
	ST_ParameterIdLnSpAfChP        ST_ParameterId = 46
	ST_ParameterIdRtShortDist      ST_ParameterId = 47
	ST_ParameterIdAlignTx          ST_ParameterId = 48
	ST_ParameterIdPyraLvlNode      ST_ParameterId = 49
	ST_ParameterIdPyraAcctBkgdNode ST_ParameterId = 50
	ST_ParameterIdPyraAcctTxNode   ST_ParameterId = 51
	ST_ParameterIdSrcNode          ST_ParameterId = 52
	ST_ParameterIdDstNode          ST_ParameterId = 53
	ST_ParameterIdBegPts           ST_ParameterId = 54
	ST_ParameterIdEndPts           ST_ParameterId = 55
)

func (_eebg *CT_LayoutNode) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _edba := range start.Attr {
		if _edba.Name.Local == "name" {
			_afdd, _ede := _edba.Value, error(nil)
			if _ede != nil {
				return _ede
			}
			_eebg.NameAttr = &_afdd
			continue
		}
		if _edba.Name.Local == "chOrder" {
			_eebg.ChOrderAttr.UnmarshalXMLAttr(_edba)
			continue
		}
		if _edba.Name.Local == "moveWith" {
			_bbda, _cfcdf := _edba.Value, error(nil)
			if _cfcdf != nil {
				return _cfcdf
			}
			_eebg.MoveWithAttr = &_bbda
			continue
		}
		if _edba.Name.Local == "styleLbl" {
			_bfce, _fdeg := _edba.Value, error(nil)
			if _fdeg != nil {
				return _fdeg
			}
			_eebg.StyleLblAttr = &_bfce
			continue
		}
	}
_fbeba:
	for {
		_fgaf, _bcee := d.Token()
		if _bcee != nil {
			return _bcee
		}
		switch _fafb := _fgaf.(type) {
		case _b.StartElement:
			switch _fafb.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "alg"}:
				_ecff := NewCT_Algorithm()
				if _dfabg := d.DecodeElement(_ecff, &_fafb); _dfabg != nil {
					return _dfabg
				}
				_eebg.Alg = append(_eebg.Alg, _ecff)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "shape"}:
				_bebe := NewCT_Shape()
				if _agcbd := d.DecodeElement(_bebe, &_fafb); _agcbd != nil {
					return _agcbd
				}
				_eebg.Shape = append(_eebg.Shape, _bebe)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "presOf"}:
				_dbde := NewCT_PresentationOf()
				if _bgge := d.DecodeElement(_dbde, &_fafb); _bgge != nil {
					return _bgge
				}
				_eebg.PresOf = append(_eebg.PresOf, _dbde)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "constrLst"}:
				_cegb := NewCT_Constraints()
				if _dfec := d.DecodeElement(_cegb, &_fafb); _dfec != nil {
					return _dfec
				}
				_eebg.ConstrLst = append(_eebg.ConstrLst, _cegb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "ruleLst"}:
				_bfcg := NewCT_Rules()
				if _fgd := d.DecodeElement(_bfcg, &_fafb); _fgd != nil {
					return _fgd
				}
				_eebg.RuleLst = append(_eebg.RuleLst, _bfcg)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "varLst"}:
				_edaa := NewCT_LayoutVariablePropertySet()
				if _cdcac := d.DecodeElement(_edaa, &_fafb); _cdcac != nil {
					return _cdcac
				}
				_eebg.VarLst = append(_eebg.VarLst, _edaa)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "forEach"}:
				_dcbf := NewCT_ForEach()
				if _dfef := d.DecodeElement(_dcbf, &_fafb); _dfef != nil {
					return _dfef
				}
				_eebg.ForEach = append(_eebg.ForEach, _dcbf)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "layoutNode"}:
				_dcgg := NewCT_LayoutNode()
				if _bfgbc := d.DecodeElement(_dcgg, &_fafb); _bfgbc != nil {
					return _bfgbc
				}
				_eebg.LayoutNode = append(_eebg.LayoutNode, _dcgg)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "choose"}:
				_fbad := NewCT_Choose()
				if _cbed := d.DecodeElement(_fbad, &_fafb); _cbed != nil {
					return _cbed
				}
				_eebg.Choose = append(_eebg.Choose, _fbad)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_cecf := _f.NewCT_OfficeArtExtensionList()
				if _afbc := d.DecodeElement(_cecf, &_fafb); _afbc != nil {
					return _afbc
				}
				_eebg.ExtLst = append(_eebg.ExtLst, _cecf)
			default:
				_ea.Log("skipping unsupported element\u0020on\u0020CT_LayoutNode \u0025v", _fafb.Name)
				if _cfa := d.Skip(); _cfa != nil {
					return _cfa
				}
			}
		case _b.EndElement:
			break _fbeba
		case _b.CharData:
		}
	}
	return nil
}
func (_cgdbb ST_BendPoint) ValidateWithPath(path string) error {
	switch _cgdbb {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cgdbb))
	}
	return nil
}

// ValidateWithPath validates the CT_PtList and its children, prefixing error messages with path
func (_bebdb *CT_PtList) ValidateWithPath(path string) error {
	for _bedg, _beae := range _bebdb.Pt {
		if _dafd := _beae.ValidateWithPath(_a.Sprintf("\u0025s\u002fPt\u005b\u0025d]", path, _bedg)); _dafd != nil {
			return _dafd
		}
	}
	return nil
}

// ValidateWithPath validates the CT_StyleDefinitionHeader and its children, prefixing error messages with path
func (_gefbb *CT_StyleDefinitionHeader) ValidateWithPath(path string) error {
	for _fddf, _fbec := range _gefbb.Title {
		if _aagd := _fbec.ValidateWithPath(_a.Sprintf("\u0025s\u002fTitle\u005b\u0025d\u005d", path, _fddf)); _aagd != nil {
			return _aagd
		}
	}
	for _dbgda, _dcgd := range _gefbb.Desc {
		if _efgc := _dcgd.ValidateWithPath(_a.Sprintf("%s\u002fDesc\u005b\u0025d\u005d", path, _dbgda)); _efgc != nil {
			return _efgc
		}
	}
	if _gefbb.CatLst != nil {
		if _adecga := _gefbb.CatLst.ValidateWithPath(path + "\u002fCatLst"); _adecga != nil {
			return _adecga
		}
	}
	if _gefbb.ExtLst != nil {
		if _eefg := _gefbb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eefg != nil {
			return _eefg
		}
	}
	return nil
}
func (_abc *CT_CTStyleLabel) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "name"}, Value: _a.Sprintf("\u0025v", _abc.NameAttr)})
	e.EncodeToken(start)
	if _abc.FillClrLst != nil {
		_aeba := _b.StartElement{Name: _b.Name{Local: "fillClrLst"}}
		e.EncodeElement(_abc.FillClrLst, _aeba)
	}
	if _abc.LinClrLst != nil {
		_gabc := _b.StartElement{Name: _b.Name{Local: "linClrLst"}}
		e.EncodeElement(_abc.LinClrLst, _gabc)
	}
	if _abc.EffectClrLst != nil {
		_bgb := _b.StartElement{Name: _b.Name{Local: "effectClrLst"}}
		e.EncodeElement(_abc.EffectClrLst, _bgb)
	}
	if _abc.TxLinClrLst != nil {
		_eeac := _b.StartElement{Name: _b.Name{Local: "txLinClrLst"}}
		e.EncodeElement(_abc.TxLinClrLst, _eeac)
	}
	if _abc.TxFillClrLst != nil {
		_afa := _b.StartElement{Name: _b.Name{Local: "txFillClrLst"}}
		e.EncodeElement(_abc.TxFillClrLst, _afa)
	}
	if _abc.TxEffectClrLst != nil {
		_fega := _b.StartElement{Name: _b.Name{Local: "txEffectClrLst"}}
		e.EncodeElement(_abc.TxEffectClrLst, _fega)
	}
	if _abc.ExtLst != nil {
		_bbf := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_abc.ExtLst, _bbf)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func ParseUnionST_PrSetCustVal(s string) (ST_PrSetCustVal, error) { return ST_PrSetCustVal{}, nil }
func (_bagag *ST_BoolOperator) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_bagag = 0
	case "none":
		*_bagag = 1
	case "equ":
		*_bagag = 2
	case "gte":
		*_bagag = 3
	case "lte":
		*_bagag = 4
	}
	return nil
}
func NewCT_ChildPref() *CT_ChildPref { _gfda := &CT_ChildPref{}; return _gfda }
func (_cgfe ST_NodeHorizontalAlignment) String() string {
	switch _cgfe {
	case 0:
		return ""
	case 1:
		return "l"
	case 2:
		return "ctr"
	case 3:
		return "r"
	}
	return ""
}
func (_aedf ST_CxnType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_egcbg := _b.Attr{}
	_egcbg.Name = name
	switch _aedf {
	case ST_CxnTypeUnset:
		_egcbg.Value = ""
	case ST_CxnTypeParOf:
		_egcbg.Value = "parOf"
	case ST_CxnTypePresOf:
		_egcbg.Value = "presOf"
	case ST_CxnTypePresParOf:
		_egcbg.Value = "presParOf"
	case ST_CxnTypeUnknownRelationship:
		_egcbg.Value = "unknownRelationship"
	}
	return _egcbg, nil
}

type CT_BulletEnabled struct{ ValAttr *bool }
type ST_Breakpoint byte

func NewCT_Pt() *CT_Pt { _bebd := &CT_Pt{}; return _bebd }
func (_cefb ST_LayoutShapeType) String() string {
	if _cefb.ST_ShapeType != _f.ST_ShapeTypeUnset {
		return _cefb.ST_ShapeType.String()
	}
	if _cefb.ST_OutputShapeType != ST_OutputShapeTypeUnset {
		return _cefb.ST_OutputShapeType.String()
	}
	return ""
}
func (_ecaf ST_CxnType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_ecaf.String(), start)
}

// Validate validates the CT_DiagramDefinitionHeader and its children
func (_cdbce *CT_DiagramDefinitionHeader) Validate() error {
	return _cdbce.ValidateWithPath("CT_DiagramDefinitionHeader")
}
func (_ecbac ST_FunctionType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_eccea := _b.Attr{}
	_eccea.Name = name
	switch _ecbac {
	case ST_FunctionTypeUnset:
		_eccea.Value = ""
	case ST_FunctionTypeCnt:
		_eccea.Value = "cnt"
	case ST_FunctionTypePos:
		_eccea.Value = "pos"
	case ST_FunctionTypeRevPos:
		_eccea.Value = "revPos"
	case ST_FunctionTypePosEven:
		_eccea.Value = "posEven"
	case ST_FunctionTypePosOdd:
		_eccea.Value = "posOdd"
	case ST_FunctionTypeVar:
		_eccea.Value = "var"
	case ST_FunctionTypeDepth:
		_eccea.Value = "depth"
	case ST_FunctionTypeMaxDepth:
		_eccea.Value = "maxDepth"
	}
	return _eccea, nil
}
func (_fffg *CT_TextProps) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _fffg.Sp3d != nil {
		_afddf := _b.StartElement{Name: _b.Name{Local: "sp3d"}}
		e.EncodeElement(_fffg.Sp3d, _afddf)
	}
	if _fffg.FlatTx != nil {
		_adge := _b.StartElement{Name: _b.Name{Local: "flatTx"}}
		e.EncodeElement(_fffg.FlatTx, _adge)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Choose and its children, prefixing error messages with path
func (_dgge *CT_Choose) ValidateWithPath(path string) error {
	for _bdc, _fdca := range _dgge.If {
		if _gce := _fdca.ValidateWithPath(_a.Sprintf("\u0025s\u002fIf\u005b\u0025d]", path, _bdc)); _gce != nil {
			return _gce
		}
	}
	if _dgge.Else != nil {
		if _gfb := _dgge.Else.ValidateWithPath(path + "\u002fElse"); _gfb != nil {
			return _gfb
		}
	}
	return nil
}
func NewCT_When() *CT_When {
	_ebba := &CT_When{}
	_ebba.FuncAttr = ST_FunctionType(1)
	_ebba.OpAttr = ST_FunctionOperator(1)
	return _ebba
}

const (
	ST_SecondaryLinearDirectionUnset ST_SecondaryLinearDirection = 0
	ST_SecondaryLinearDirectionNone  ST_SecondaryLinearDirection = 1
	ST_SecondaryLinearDirectionFromL ST_SecondaryLinearDirection = 2
	ST_SecondaryLinearDirectionFromR ST_SecondaryLinearDirection = 3
	ST_SecondaryLinearDirectionFromT ST_SecondaryLinearDirection = 4
	ST_SecondaryLinearDirectionFromB ST_SecondaryLinearDirection = 5
)

// ValidateWithPath validates the AG_ConstraintRefAttributes and its children, prefixing error messages with path
func (_ec *AG_ConstraintRefAttributes) ValidateWithPath(path string) error {
	if _gb := _ec.RefTypeAttr.ValidateWithPath(path + "\u002fRefTypeAttr"); _gb != nil {
		return _gb
	}
	if _df := _ec.RefForAttr.ValidateWithPath(path + "/RefForAttr"); _df != nil {
		return _df
	}
	if _ed := _ec.RefPtTypeAttr.ValidateWithPath(path + "\u002fRefPtTypeAttr"); _ed != nil {
		return _ed
	}
	return nil
}

// Validate validates the CT_Category and its children
func (_dbd *CT_Category) Validate() error { return _dbd.ValidateWithPath("CT_Category") }

type ST_HierBranchStyle byte

func (_bfdc ST_CenterShapeMapping) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_dfad := _b.Attr{}
	_dfad.Name = name
	switch _bfdc {
	case ST_CenterShapeMappingUnset:
		_dfad.Value = ""
	case ST_CenterShapeMappingNone:
		_dfad.Value = "none"
	case ST_CenterShapeMappingFNode:
		_dfad.Value = "fNode"
	}
	return _dfad, nil
}

type ST_ChildDirection byte

func (_egeeg ST_AxisType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_egeeg.String(), start)
}
func (_cfff *CT_Rules) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _cfff.Rule != nil {
		_abfe := _b.StartElement{Name: _b.Name{Local: "rule"}}
		for _, _caee := range _cfff.Rule {
			e.EncodeElement(_caee, _abfe)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_bdcda *ST_ArrowheadStyle) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_bdcda = 0
	case "auto":
		*_bdcda = 1
	case "arr":
		*_bdcda = 2
	case "noArr":
		*_bdcda = 3
	}
	return nil
}

// Validate validates the CT_StyleDefinitionHeader and its children
func (_cfdb *CT_StyleDefinitionHeader) Validate() error {
	return _cfdb.ValidateWithPath("CT_StyleDefinitionHeader")
}
func (_abbgf ST_ConstraintRelationship) Validate() error { return _abbgf.ValidateWithPath("") }
func (_cfdg ST_AnimLvlStr) Validate() error              { return _cfdg.ValidateWithPath("") }

type CT_Constraints struct{ Constr []*CT_Constraint }

func (_cacg ST_ConstraintType) Validate() error { return _cacg.ValidateWithPath("") }
func (_edeaa *ST_NodeVerticalAlignment) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gbfaa, _abafg := d.Token()
	if _abafg != nil {
		return _abafg
	}
	if _badba, _dfcaa := _gbfaa.(_b.EndElement); _dfcaa && _badba.Name == start.Name {
		*_edeaa = 1
		return nil
	}
	if _bbage, _dbbgg := _gbfaa.(_b.CharData); !_dbbgg {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gbfaa)
	} else {
		switch string(_bbage) {
		case "":
			*_edeaa = 0
		case "t":
			*_edeaa = 1
		case "mid":
			*_edeaa = 2
		case "b":
			*_edeaa = 3
		}
	}
	_gbfaa, _abafg = d.Token()
	if _abafg != nil {
		return _abafg
	}
	if _eabde, _aeccfg := _gbfaa.(_b.EndElement); _aeccfg && _eabde.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gbfaa)
}

type CT_SampleData struct {
	UseDefAttr *bool
	DataModel  *CT_DataModel
}

func (_dagb *ST_LinearDirection) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dagb = 0
	case "fromL":
		*_dagb = 1
	case "fromR":
		*_dagb = 2
	case "fromT":
		*_dagb = 3
	case "fromB":
		*_dagb = 4
	}
	return nil
}
func (_ggbg *ST_StartingElement) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_eage, _cegea := d.Token()
	if _cegea != nil {
		return _cegea
	}
	if _bdbb, _cffgc := _eage.(_b.EndElement); _cffgc && _bdbb.Name == start.Name {
		*_ggbg = 1
		return nil
	}
	if _effg, _agfga := _eage.(_b.CharData); !_agfga {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eage)
	} else {
		switch string(_effg) {
		case "":
			*_ggbg = 0
		case "node":
			*_ggbg = 1
		case "trans":
			*_ggbg = 2
		}
	}
	_eage, _cegea = d.Token()
	if _cegea != nil {
		return _cegea
	}
	if _geeee, _daec := _eage.(_b.EndElement); _daec && _geeee.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eage)
}

// Validate validates the CT_ResizeHandles and its children
func (_bbdcd *CT_ResizeHandles) Validate() error { return _bbdcd.ValidateWithPath("CT_ResizeHandles") }
func (_bcgb ST_GrowDirection) String() string {
	switch _bcgb {
	case 0:
		return ""
	case 1:
		return "tL"
	case 2:
		return "tR"
	case 3:
		return "bL"
	case 4:
		return "bR"
	}
	return ""
}
func (_bafaa ST_HueDir) ValidateWithPath(path string) error {
	switch _bafaa {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bafaa))
	}
	return nil
}
func NewCT_DataModel() *CT_DataModel {
	_ecf := &CT_DataModel{}
	_ecf.PtLst = NewCT_PtList()
	return _ecf
}
func (_fabdb ST_ParameterVal) String() string {
	if _fabdb.ST_DiagramHorizontalAlignment != ST_DiagramHorizontalAlignmentUnset {
		return _fabdb.ST_DiagramHorizontalAlignment.String()
	}
	if _fabdb.ST_VerticalAlignment != ST_VerticalAlignmentUnset {
		return _fabdb.ST_VerticalAlignment.String()
	}
	if _fabdb.ST_ChildDirection != ST_ChildDirectionUnset {
		return _fabdb.ST_ChildDirection.String()
	}
	if _fabdb.ST_ChildAlignment != ST_ChildAlignmentUnset {
		return _fabdb.ST_ChildAlignment.String()
	}
	if _fabdb.ST_SecondaryChildAlignment != ST_SecondaryChildAlignmentUnset {
		return _fabdb.ST_SecondaryChildAlignment.String()
	}
	if _fabdb.ST_LinearDirection != ST_LinearDirectionUnset {
		return _fabdb.ST_LinearDirection.String()
	}
	if _fabdb.ST_SecondaryLinearDirection != ST_SecondaryLinearDirectionUnset {
		return _fabdb.ST_SecondaryLinearDirection.String()
	}
	if _fabdb.ST_StartingElement != ST_StartingElementUnset {
		return _fabdb.ST_StartingElement.String()
	}
	if _fabdb.ST_BendPoint != ST_BendPointUnset {
		return _fabdb.ST_BendPoint.String()
	}
	if _fabdb.ST_ConnectorRouting != ST_ConnectorRoutingUnset {
		return _fabdb.ST_ConnectorRouting.String()
	}
	if _fabdb.ST_ArrowheadStyle != ST_ArrowheadStyleUnset {
		return _fabdb.ST_ArrowheadStyle.String()
	}
	if _fabdb.ST_ConnectorDimension != ST_ConnectorDimensionUnset {
		return _fabdb.ST_ConnectorDimension.String()
	}
	if _fabdb.ST_RotationPath != ST_RotationPathUnset {
		return _fabdb.ST_RotationPath.String()
	}
	if _fabdb.ST_CenterShapeMapping != ST_CenterShapeMappingUnset {
		return _fabdb.ST_CenterShapeMapping.String()
	}
	if _fabdb.ST_NodeHorizontalAlignment != ST_NodeHorizontalAlignmentUnset {
		return _fabdb.ST_NodeHorizontalAlignment.String()
	}
	if _fabdb.ST_NodeVerticalAlignment != ST_NodeVerticalAlignmentUnset {
		return _fabdb.ST_NodeVerticalAlignment.String()
	}
	if _fabdb.ST_FallbackDimension != ST_FallbackDimensionUnset {
		return _fabdb.ST_FallbackDimension.String()
	}
	if _fabdb.ST_TextDirection != ST_TextDirectionUnset {
		return _fabdb.ST_TextDirection.String()
	}
	if _fabdb.ST_PyramidAccentPosition != ST_PyramidAccentPositionUnset {
		return _fabdb.ST_PyramidAccentPosition.String()
	}
	if _fabdb.ST_PyramidAccentTextMargin != ST_PyramidAccentTextMarginUnset {
		return _fabdb.ST_PyramidAccentTextMargin.String()
	}
	if _fabdb.ST_TextBlockDirection != ST_TextBlockDirectionUnset {
		return _fabdb.ST_TextBlockDirection.String()
	}
	if _fabdb.ST_TextAnchorHorizontal != ST_TextAnchorHorizontalUnset {
		return _fabdb.ST_TextAnchorHorizontal.String()
	}
	if _fabdb.ST_TextAnchorVertical != ST_TextAnchorVerticalUnset {
		return _fabdb.ST_TextAnchorVertical.String()
	}
	if _fabdb.ST_DiagramTextAlignment != ST_DiagramTextAlignmentUnset {
		return _fabdb.ST_DiagramTextAlignment.String()
	}
	if _fabdb.ST_AutoTextRotation != ST_AutoTextRotationUnset {
		return _fabdb.ST_AutoTextRotation.String()
	}
	if _fabdb.ST_GrowDirection != ST_GrowDirectionUnset {
		return _fabdb.ST_GrowDirection.String()
	}
	if _fabdb.ST_FlowDirection != ST_FlowDirectionUnset {
		return _fabdb.ST_FlowDirection.String()
	}
	if _fabdb.ST_ContinueDirection != ST_ContinueDirectionUnset {
		return _fabdb.ST_ContinueDirection.String()
	}
	if _fabdb.ST_Breakpoint != ST_BreakpointUnset {
		return _fabdb.ST_Breakpoint.String()
	}
	if _fabdb.ST_Offset != ST_OffsetUnset {
		return _fabdb.ST_Offset.String()
	}
	if _fabdb.ST_HierarchyAlignment != ST_HierarchyAlignmentUnset {
		return _fabdb.ST_HierarchyAlignment.String()
	}
	if _fabdb.Int32 != nil {
		return _a.Sprintf("\u0025v", *_fabdb.Int32)
	}
	if _fabdb.Float64 != nil {
		return _a.Sprintf("\u0025v", *_fabdb.Float64)
	}
	if _fabdb.Bool != nil {
		return _a.Sprintf("\u0025v", *_fabdb.Bool)
	}
	if _fabdb.StringVal != nil {
		return _a.Sprintf("\u0025v", *_fabdb.StringVal)
	}
	if _fabdb.ST_ConnectorPoint != ST_ConnectorPointUnset {
		return _fabdb.ST_ConnectorPoint.String()
	}
	return ""
}
func (_ebbd ST_TextAnchorVertical) String() string {
	switch _ebbd {
	case 0:
		return ""
	case 1:
		return "t"
	case 2:
		return "mid"
	case 3:
		return "b"
	}
	return ""
}
func (_abdcc *CT_SDDescription) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _addfd := range start.Attr {
		if _addfd.Name.Local == "lang" {
			_geccg, _agcgg := _addfd.Value, error(nil)
			if _agcgg != nil {
				return _agcgg
			}
			_abdcc.LangAttr = &_geccg
			continue
		}
		if _addfd.Name.Local == "val" {
			_aeeg, _fegf := _addfd.Value, error(nil)
			if _fegf != nil {
				return _fegf
			}
			_abdcc.ValAttr = _aeeg
			continue
		}
	}
	for {
		_cccdgc, _fgee := d.Token()
		if _fgee != nil {
			return _a.Errorf("parsing\u0020CT_SDDescription: \u0025s", _fgee)
		}
		if _fegg, _badcd := _cccdgc.(_b.EndElement); _badcd && _fegg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fdcb *CT_SDCategory) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _abfcd := range start.Attr {
		if _abfcd.Name.Local == "type" {
			_adfd, _egdd := _abfcd.Value, error(nil)
			if _egdd != nil {
				return _egdd
			}
			_fdcb.TypeAttr = _adfd
			continue
		}
		if _abfcd.Name.Local == "pri" {
			_addfe, _gecce := _d.ParseUint(_abfcd.Value, 10, 32)
			if _gecce != nil {
				return _gecce
			}
			_fdcb.PriAttr = uint32(_addfe)
			continue
		}
	}
	for {
		_gbfaf, _cgffd := d.Token()
		if _cgffd != nil {
			return _a.Errorf("parsing\u0020CT_SDCategory:\u0020\u0025s", _cgffd)
		}
		if _afgeb, _aeed := _gbfaf.(_b.EndElement); _aeed && _afgeb.Name == start.Name {
			break
		}
	}
	return nil
}

type ST_AxisTypes []ST_AxisType

func NewCT_Category() *CT_Category { _gbdd := &CT_Category{}; return _gbdd }

const (
	ST_BendPointUnset ST_BendPoint = 0
	ST_BendPointBeg   ST_BendPoint = 1
	ST_BendPointDef   ST_BendPoint = 2
	ST_BendPointEnd   ST_BendPoint = 3
)

type ST_ConnectorRouting byte

func (_cbade ST_TextBlockDirection) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_dfaea := _b.Attr{}
	_dfaea.Name = name
	switch _cbade {
	case ST_TextBlockDirectionUnset:
		_dfaea.Value = ""
	case ST_TextBlockDirectionHorz:
		_dfaea.Value = "horz"
	case ST_TextBlockDirectionVert:
		_dfaea.Value = "vert"
	}
	return _dfaea, nil
}

type CT_AnimLvl struct{ ValAttr ST_AnimLvlStr }

func (_cdgf *ColorsDef) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:di"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "colorsDef"
	return _cdgf.CT_ColorTransform.MarshalXML(e, start)
}

type AG_IteratorAttributes struct {
	AxisAttr          *ST_AxisTypes
	PtTypeAttr        *ST_ElementTypes
	HideLastTransAttr *ST_Booleans
	StAttr            *ST_Ints
	CntAttr           *ST_UnsignedInts
	StepAttr          *ST_Ints
}

func NewLayoutDefHdrLst() *LayoutDefHdrLst {
	_ccgba := &LayoutDefHdrLst{}
	_ccgba.CT_DiagramDefinitionHeaderLst = *NewCT_DiagramDefinitionHeaderLst()
	return _ccgba
}
func (_fegcf ST_DiagramTextAlignment) ValidateWithPath(path string) error {
	switch _fegcf {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fegcf))
	}
	return nil
}
func ParseUnionST_FunctionArgument(s string) (ST_FunctionArgument, error) {
	return ST_FunctionArgument{}, nil
}
func (_abgea ST_TextDirection) String() string {
	switch _abgea {
	case 0:
		return ""
	case 1:
		return "fromT"
	case 2:
		return "fromB"
	}
	return ""
}
func (_fbb *ST_ChildAlignment) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fbb = 0
	case "t":
		*_fbb = 1
	case "b":
		*_fbb = 2
	case "l":
		*_fbb = 3
	case "r":
		*_fbb = 4
	}
	return nil
}

type ST_NodeVerticalAlignment byte

func (_dagdc ST_TextAnchorVertical) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_afec := _b.Attr{}
	_afec.Name = name
	switch _dagdc {
	case ST_TextAnchorVerticalUnset:
		_afec.Value = ""
	case ST_TextAnchorVerticalT:
		_afec.Value = "t"
	case ST_TextAnchorVerticalMid:
		_afec.Value = "mid"
	case ST_TextAnchorVerticalB:
		_afec.Value = "b"
	}
	return _afec, nil
}

const (
	ST_PyramidAccentPositionUnset ST_PyramidAccentPosition = 0
	ST_PyramidAccentPositionBef   ST_PyramidAccentPosition = 1
	ST_PyramidAccentPositionAft   ST_PyramidAccentPosition = 2
)

func (_bbebd ST_ParameterId) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_beeged := _b.Attr{}
	_beeged.Name = name
	switch _bbebd {
	case ST_ParameterIdUnset:
		_beeged.Value = ""
	case ST_ParameterIdHorzAlign:
		_beeged.Value = "horzAlign"
	case ST_ParameterIdVertAlign:
		_beeged.Value = "vertAlign"
	case ST_ParameterIdChDir:
		_beeged.Value = "chDir"
	case ST_ParameterIdChAlign:
		_beeged.Value = "chAlign"
	case ST_ParameterIdSecChAlign:
		_beeged.Value = "secChAlign"
	case ST_ParameterIdLinDir:
		_beeged.Value = "linDir"
	case ST_ParameterIdSecLinDir:
		_beeged.Value = "secLinDir"
	case ST_ParameterIdStElem:
		_beeged.Value = "stElem"
	case ST_ParameterIdBendPt:
		_beeged.Value = "bendPt"
	case ST_ParameterIdConnRout:
		_beeged.Value = "connRout"
	case ST_ParameterIdBegSty:
		_beeged.Value = "begSty"
	case ST_ParameterIdEndSty:
		_beeged.Value = "endSty"
	case ST_ParameterIdDim:
		_beeged.Value = "dim"
	case ST_ParameterIdRotPath:
		_beeged.Value = "rotPath"
	case ST_ParameterIdCtrShpMap:
		_beeged.Value = "ctrShpMap"
	case ST_ParameterIdNodeHorzAlign:
		_beeged.Value = "nodeHorzAlign"
	case ST_ParameterIdNodeVertAlign:
		_beeged.Value = "nodeVertAlign"
	case ST_ParameterIdFallback:
		_beeged.Value = "fallback"
	case ST_ParameterIdTxDir:
		_beeged.Value = "txDir"
	case ST_ParameterIdPyraAcctPos:
		_beeged.Value = "pyraAcctPos"
	case ST_ParameterIdPyraAcctTxMar:
		_beeged.Value = "pyraAcctTxMar"
	case ST_ParameterIdTxBlDir:
		_beeged.Value = "txBlDir"
	case ST_ParameterIdTxAnchorHorz:
		_beeged.Value = "txAnchorHorz"
	case ST_ParameterIdTxAnchorVert:
		_beeged.Value = "txAnchorVert"
	case ST_ParameterIdTxAnchorHorzCh:
		_beeged.Value = "txAnchorHorzCh"
	case ST_ParameterIdTxAnchorVertCh:
		_beeged.Value = "txAnchorVertCh"
	case ST_ParameterIdParTxLTRAlign:
		_beeged.Value = "parTxLTRAlign"
	case ST_ParameterIdParTxRTLAlign:
		_beeged.Value = "parTxRTLAlign"
	case ST_ParameterIdShpTxLTRAlignCh:
		_beeged.Value = "shpTxLTRAlignCh"
	case ST_ParameterIdShpTxRTLAlignCh:
		_beeged.Value = "shpTxRTLAlignCh"
	case ST_ParameterIdAutoTxRot:
		_beeged.Value = "autoTxRot"
	case ST_ParameterIdGrDir:
		_beeged.Value = "grDir"
	case ST_ParameterIdFlowDir:
		_beeged.Value = "flowDir"
	case ST_ParameterIdContDir:
		_beeged.Value = "contDir"
	case ST_ParameterIdBkpt:
		_beeged.Value = "bkpt"
	case ST_ParameterIdOff:
		_beeged.Value = "off"
	case ST_ParameterIdHierAlign:
		_beeged.Value = "hierAlign"
	case ST_ParameterIdBkPtFixedVal:
		_beeged.Value = "bkPtFixedVal"
	case ST_ParameterIdStBulletLvl:
		_beeged.Value = "stBulletLvl"
	case ST_ParameterIdStAng:
		_beeged.Value = "stAng"
	case ST_ParameterIdSpanAng:
		_beeged.Value = "spanAng"
	case ST_ParameterIdAr:
		_beeged.Value = "ar"
	case ST_ParameterIdLnSpPar:
		_beeged.Value = "lnSpPar"
	case ST_ParameterIdLnSpAfParP:
		_beeged.Value = "lnSpAfParP"
	case ST_ParameterIdLnSpCh:
		_beeged.Value = "lnSpCh"
	case ST_ParameterIdLnSpAfChP:
		_beeged.Value = "lnSpAfChP"
	case ST_ParameterIdRtShortDist:
		_beeged.Value = "rtShortDist"
	case ST_ParameterIdAlignTx:
		_beeged.Value = "alignTx"
	case ST_ParameterIdPyraLvlNode:
		_beeged.Value = "pyraLvlNode"
	case ST_ParameterIdPyraAcctBkgdNode:
		_beeged.Value = "pyraAcctBkgdNode"
	case ST_ParameterIdPyraAcctTxNode:
		_beeged.Value = "pyraAcctTxNode"
	case ST_ParameterIdSrcNode:
		_beeged.Value = "srcNode"
	case ST_ParameterIdDstNode:
		_beeged.Value = "dstNode"
	case ST_ParameterIdBegPts:
		_beeged.Value = "begPts"
	case ST_ParameterIdEndPts:
		_beeged.Value = "endPts"
	}
	return _beeged, nil
}

type CT_ForEach struct {
	NameAttr          *string
	RefAttr           *string
	Alg               []*CT_Algorithm
	Shape             []*CT_Shape
	PresOf            []*CT_PresentationOf
	ConstrLst         []*CT_Constraints
	RuleLst           []*CT_Rules
	ForEach           []*CT_ForEach
	LayoutNode        []*CT_LayoutNode
	Choose            []*CT_Choose
	ExtLst            []*_f.CT_OfficeArtExtensionList
	AxisAttr          *ST_AxisTypes
	PtTypeAttr        *ST_ElementTypes
	HideLastTransAttr *ST_Booleans
	StAttr            *ST_Ints
	CntAttr           *ST_UnsignedInts
	StepAttr          *ST_Ints
}
type ST_DiagramTextAlignment byte

func ParseSliceST_UnsignedInts(s string) (ST_UnsignedInts, error) { return ST_UnsignedInts{}, nil }

const (
	ST_AxisTypeUnset       ST_AxisType = 0
	ST_AxisTypeSelf        ST_AxisType = 1
	ST_AxisTypeCh          ST_AxisType = 2
	ST_AxisTypeDes         ST_AxisType = 3
	ST_AxisTypeDesOrSelf   ST_AxisType = 4
	ST_AxisTypePar         ST_AxisType = 5
	ST_AxisTypeAncst       ST_AxisType = 6
	ST_AxisTypeAncstOrSelf ST_AxisType = 7
	ST_AxisTypeFollowSib   ST_AxisType = 8
	ST_AxisTypePrecedSib   ST_AxisType = 9
	ST_AxisTypeFollow      ST_AxisType = 10
	ST_AxisTypePreced      ST_AxisType = 11
	ST_AxisTypeRoot        ST_AxisType = 12
	ST_AxisTypeNone        ST_AxisType = 13
)

func NewCT_PresentationOf() *CT_PresentationOf { _ebec := &CT_PresentationOf{}; return _ebec }

type CT_ColorTransformHeaderLst struct{ ColorsDefHdr []*CT_ColorTransformHeader }

func NewCT_RelIds() *CT_RelIds { _dgeb := &CT_RelIds{}; return _dgeb }

const (
	ST_FunctionTypeUnset    ST_FunctionType = 0
	ST_FunctionTypeCnt      ST_FunctionType = 1
	ST_FunctionTypePos      ST_FunctionType = 2
	ST_FunctionTypeRevPos   ST_FunctionType = 3
	ST_FunctionTypePosEven  ST_FunctionType = 4
	ST_FunctionTypePosOdd   ST_FunctionType = 5
	ST_FunctionTypeVar      ST_FunctionType = 6
	ST_FunctionTypeDepth    ST_FunctionType = 7
	ST_FunctionTypeMaxDepth ST_FunctionType = 8
)

func (_decc ST_CxnType) String() string {
	switch _decc {
	case 0:
		return ""
	case 1:
		return "parOf"
	case 2:
		return "presOf"
	case 3:
		return "presParOf"
	case 4:
		return "unknownRelationship"
	}
	return ""
}
func NewAG_ConstraintRefAttributes() *AG_ConstraintRefAttributes {
	_eab := &AG_ConstraintRefAttributes{}
	return _eab
}

// Validate validates the CT_ChildPref and its children
func (_cdcf *CT_ChildPref) Validate() error { return _cdcf.ValidateWithPath("CT_ChildPref") }
func (_cdba *CT_CxnList) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_fegc:
	for {
		_cgf, _agg := d.Token()
		if _agg != nil {
			return _agg
		}
		switch _fgfa := _cgf.(type) {
		case _b.StartElement:
			switch _fgfa.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "cxn"}:
				_dgcg := NewCT_Cxn()
				if _ebgde := d.DecodeElement(_dgcg, &_fgfa); _ebgde != nil {
					return _ebgde
				}
				_cdba.Cxn = append(_cdba.Cxn, _dgcg)
			default:
				_ea.Log("skipping unsupported\u0020element\u0020on\u0020CT_CxnList\u0020\u0025v", _fgfa.Name)
				if _fbgf := d.Skip(); _fbgf != nil {
					return _fbgf
				}
			}
		case _b.EndElement:
			break _fegc
		case _b.CharData:
		}
	}
	return nil
}

type CT_PresentationOf struct {
	ExtLst            *_f.CT_OfficeArtExtensionList
	AxisAttr          *ST_AxisTypes
	PtTypeAttr        *ST_ElementTypes
	HideLastTransAttr *ST_Booleans
	StAttr            *ST_Ints
	CntAttr           *ST_UnsignedInts
	StepAttr          *ST_Ints
}

// Validate validates the CT_Direction and its children
func (_fegb *CT_Direction) Validate() error { return _fegb.ValidateWithPath("CT_Direction") }
func (_bbab ST_ResizeHandlesStr) String() string {
	switch _bbab {
	case 0:
		return ""
	case 1:
		return "exact"
	case 2:
		return "rel"
	}
	return ""
}

// Validate validates the CT_CTDescription and its children
func (_dcg *CT_CTDescription) Validate() error { return _dcg.ValidateWithPath("CT_CTDescription") }

// ValidateWithPath validates the CT_AnimOne and its children, prefixing error messages with path
func (_dcd *CT_AnimOne) ValidateWithPath(path string) error {
	if _fga := _dcd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _fga != nil {
		return _fga
	}
	return nil
}
func (_gfbd ST_ConstraintRelationship) String() string {
	switch _gfbd {
	case 0:
		return ""
	case 1:
		return "self"
	case 2:
		return "ch"
	case 3:
		return "des"
	}
	return ""
}
func (_eedd ST_StartingElement) ValidateWithPath(path string) error {
	switch _eedd {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eedd))
	}
	return nil
}
func (_ccgbd *RelIds) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ccgbd.CT_RelIds = *NewCT_RelIds()
	for _, _abgde := range start.Attr {
		if _abgde.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _abgde.Name.Local == "dm" || _abgde.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _abgde.Name.Local == "dm" {
			_efac, _bfaca := _abgde.Value, error(nil)
			if _bfaca != nil {
				return _bfaca
			}
			_ccgbd.DmAttr = _efac
			continue
		}
		if _abgde.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _abgde.Name.Local == "lo" || _abgde.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _abgde.Name.Local == "lo" {
			_ecbd, _edfceg := _abgde.Value, error(nil)
			if _edfceg != nil {
				return _edfceg
			}
			_ccgbd.LoAttr = _ecbd
			continue
		}
		if _abgde.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _abgde.Name.Local == "qs" || _abgde.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _abgde.Name.Local == "qs" {
			_ebde, _fgfcd := _abgde.Value, error(nil)
			if _fgfcd != nil {
				return _fgfcd
			}
			_ccgbd.QsAttr = _ebde
			continue
		}
		if _abgde.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _abgde.Name.Local == "cs" || _abgde.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _abgde.Name.Local == "cs" {
			_fbfb, _fgga := _abgde.Value, error(nil)
			if _fgga != nil {
				return _fgga
			}
			_ccgbd.CsAttr = _fbfb
			continue
		}
	}
	for {
		_ddgd, _bgdcg := d.Token()
		if _bgdcg != nil {
			return _a.Errorf("parsing\u0020RelIds:\u0020\u0025s", _bgdcg)
		}
		if _fbfab, _agcgc := _ddgd.(_b.EndElement); _agcgc && _fbfab.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bgdcb ST_AxisType) Validate() error { return _bgdcb.ValidateWithPath("") }

// ValidateWithPath validates the CT_Category and its children, prefixing error messages with path
func (_bfa *CT_Category) ValidateWithPath(path string) error { return nil }
func (_abed ST_TextBlockDirection) ValidateWithPath(path string) error {
	switch _abed {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_abed))
	}
	return nil
}
func (_addbf ST_BoolOperator) String() string {
	switch _addbf {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "equ"
	case 3:
		return "gte"
	case 4:
		return "lte"
	}
	return ""
}
func (_cafee ST_Direction) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_fgccf := _b.Attr{}
	_fgccf.Name = name
	switch _cafee {
	case ST_DirectionUnset:
		_fgccf.Value = ""
	case ST_DirectionNorm:
		_fgccf.Value = "norm"
	case ST_DirectionRev:
		_fgccf.Value = "rev"
	}
	return _fgccf, nil
}
func (_cbfeb ST_ResizeHandlesStr) ValidateWithPath(path string) error {
	switch _cbfeb {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cbfeb))
	}
	return nil
}
func ParseUnionST_ParameterVal(s string) (ST_ParameterVal, error) { return ST_ParameterVal{}, nil }
func (_egae ST_ResizeHandlesStr) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_fefe := _b.Attr{}
	_fefe.Name = name
	switch _egae {
	case ST_ResizeHandlesStrUnset:
		_fefe.Value = ""
	case ST_ResizeHandlesStrExact:
		_fefe.Value = "exact"
	case ST_ResizeHandlesStrRel:
		_fefe.Value = "rel"
	}
	return _fefe, nil
}

// Validate validates the CT_DataModel and its children
func (_ggea *CT_DataModel) Validate() error { return _ggea.ValidateWithPath("CT_DataModel") }
func (_bcfg ST_ConstraintType) ValidateWithPath(path string) error {
	switch _bcfg {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bcfg))
	}
	return nil
}
func (_bdbg ST_ConnectorRouting) ValidateWithPath(path string) error {
	switch _bdbg {
	case 0, 1, 2, 3, 4:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bdbg))
	}
	return nil
}

type CT_StyleDefinitionHeader struct {
	UniqueIdAttr string
	MinVerAttr   *string
	ResIdAttr    *int32
	Title        []*CT_SDName
	Desc         []*CT_SDDescription
	CatLst       *CT_SDCategories
	ExtLst       *_f.CT_OfficeArtExtensionList
}
type CT_Constraint struct {
	OpAttr         ST_BoolOperator
	ValAttr        *float64
	FactAttr       *float64
	ExtLst         *_f.CT_OfficeArtExtensionList
	TypeAttr       ST_ConstraintType
	ForAttr        ST_ConstraintRelationship
	ForNameAttr    *string
	PtTypeAttr     ST_ElementType
	RefTypeAttr    ST_ConstraintType
	RefForAttr     ST_ConstraintRelationship
	RefForNameAttr *string
	RefPtTypeAttr  ST_ElementType
}

func (_ecgeb *ST_BendPoint) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fffa, _eecaa := d.Token()
	if _eecaa != nil {
		return _eecaa
	}
	if _gedge, _afbdd := _fffa.(_b.EndElement); _afbdd && _gedge.Name == start.Name {
		*_ecgeb = 1
		return nil
	}
	if _ceadd, _bfcea := _fffa.(_b.CharData); !_bfcea {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fffa)
	} else {
		switch string(_ceadd) {
		case "":
			*_ecgeb = 0
		case "beg":
			*_ecgeb = 1
		case "def":
			*_ecgeb = 2
		case "end":
			*_ecgeb = 3
		}
	}
	_fffa, _eecaa = d.Token()
	if _eecaa != nil {
		return _eecaa
	}
	if _cceec, _fggge := _fffa.(_b.EndElement); _fggge && _cceec.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fffa)
}
func (_dbbga *CT_DiagramDefinitionHeaderLst) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _dbbga.LayoutDefHdr != nil {
		_ffef := _b.StartElement{Name: _b.Name{Local: "layoutDefHdr"}}
		for _, _gggb := range _dbbga.LayoutDefHdr {
			e.EncodeElement(_gggb, _ffef)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

const (
	ST_FallbackDimensionUnset ST_FallbackDimension = 0
	ST_FallbackDimension1D    ST_FallbackDimension = 1
	ST_FallbackDimension2D    ST_FallbackDimension = 2
)

func NewCT_ResizeHandles() *CT_ResizeHandles { _gdfg := &CT_ResizeHandles{}; return _gdfg }
func (_gcee *ST_TextAnchorHorizontal) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_gcee = 0
	case "none":
		*_gcee = 1
	case "ctr":
		*_gcee = 2
	}
	return nil
}
func (_gddcf ST_ResizeHandlesStr) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_gddcf.String(), start)
}
func (_cfbb *CT_HierBranchStyle) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _cadf := range start.Attr {
		if _cadf.Name.Local == "val" {
			_cfbb.ValAttr.UnmarshalXMLAttr(_cadf)
			continue
		}
	}
	for {
		_abbf, _bfcb := d.Token()
		if _bfcb != nil {
			return _a.Errorf("parsing\u0020CT_HierBranchStyle:\u0020\u0025s", _bfcb)
		}
		if _bbaa, _daddf := _abbf.(_b.EndElement); _daddf && _bbaa.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_PtTypeUnset    ST_PtType = 0
	ST_PtTypeNode     ST_PtType = 1
	ST_PtTypeAsst     ST_PtType = 2
	ST_PtTypeDoc      ST_PtType = 3
	ST_PtTypePres     ST_PtType = 4
	ST_PtTypeParTrans ST_PtType = 5
	ST_PtTypeSibTrans ST_PtType = 6
)

// Validate validates the AG_IteratorAttributes and its children
func (_dbc *AG_IteratorAttributes) Validate() error {
	return _dbc.ValidateWithPath("AG_IteratorAttributes")
}
func (_cece ST_PyramidAccentPosition) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_cece.String(), start)
}
func (_abbag *ST_AnimLvlStr) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_abbag = 0
	case "none":
		*_abbag = 1
	case "lvl":
		*_abbag = 2
	case "ctr":
		*_abbag = 3
	}
	return nil
}
func (_caecb *ST_ArrowheadStyle) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fcfgf, _gegfd := d.Token()
	if _gegfd != nil {
		return _gegfd
	}
	if _ffbdf, _bgda := _fcfgf.(_b.EndElement); _bgda && _ffbdf.Name == start.Name {
		*_caecb = 1
		return nil
	}
	if _gfabff, _eacb := _fcfgf.(_b.CharData); !_eacb {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fcfgf)
	} else {
		switch string(_gfabff) {
		case "":
			*_caecb = 0
		case "auto":
			*_caecb = 1
		case "arr":
			*_caecb = 2
		case "noArr":
			*_caecb = 3
		}
	}
	_fcfgf, _gegfd = d.Token()
	if _gegfd != nil {
		return _gegfd
	}
	if _cfggf, _bace := _fcfgf.(_b.EndElement); _bace && _cfggf.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fcfgf)
}
func (_cgbbd *ST_PtType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cccc, _acebc := d.Token()
	if _acebc != nil {
		return _acebc
	}
	if _gebb, _dbge := _cccc.(_b.EndElement); _dbge && _gebb.Name == start.Name {
		*_cgbbd = 1
		return nil
	}
	if _adcffd, _efed := _cccc.(_b.CharData); !_efed {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cccc)
	} else {
		switch string(_adcffd) {
		case "":
			*_cgbbd = 0
		case "node":
			*_cgbbd = 1
		case "asst":
			*_cgbbd = 2
		case "doc":
			*_cgbbd = 3
		case "pres":
			*_cgbbd = 4
		case "parTrans":
			*_cgbbd = 5
		case "sibTrans":
			*_cgbbd = 6
		}
	}
	_cccc, _acebc = d.Token()
	if _acebc != nil {
		return _acebc
	}
	if _egfb, _fbcea := _cccc.(_b.EndElement); _fbcea && _egfb.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cccc)
}

const (
	ST_AnimLvlStrUnset ST_AnimLvlStr = 0
	ST_AnimLvlStrNone  ST_AnimLvlStr = 1
	ST_AnimLvlStrLvl   ST_AnimLvlStr = 2
	ST_AnimLvlStrCtr   ST_AnimLvlStr = 3
)

func (_fbff *ST_ConstraintType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fbff = 0
	case "none":
		*_fbff = 1
	case "alignOff":
		*_fbff = 2
	case "begMarg":
		*_fbff = 3
	case "bendDist":
		*_fbff = 4
	case "begPad":
		*_fbff = 5
	case "b":
		*_fbff = 6
	case "bMarg":
		*_fbff = 7
	case "bOff":
		*_fbff = 8
	case "ctrX":
		*_fbff = 9
	case "ctrXOff":
		*_fbff = 10
	case "ctrY":
		*_fbff = 11
	case "ctrYOff":
		*_fbff = 12
	case "connDist":
		*_fbff = 13
	case "diam":
		*_fbff = 14
	case "endMarg":
		*_fbff = 15
	case "endPad":
		*_fbff = 16
	case "h":
		*_fbff = 17
	case "hArH":
		*_fbff = 18
	case "hOff":
		*_fbff = 19
	case "l":
		*_fbff = 20
	case "lMarg":
		*_fbff = 21
	case "lOff":
		*_fbff = 22
	case "r":
		*_fbff = 23
	case "rMarg":
		*_fbff = 24
	case "rOff":
		*_fbff = 25
	case "primFontSz":
		*_fbff = 26
	case "pyraAcctRatio":
		*_fbff = 27
	case "secFontSz":
		*_fbff = 28
	case "sibSp":
		*_fbff = 29
	case "secSibSp":
		*_fbff = 30
	case "sp":
		*_fbff = 31
	case "stemThick":
		*_fbff = 32
	case "t":
		*_fbff = 33
	case "tMarg":
		*_fbff = 34
	case "tOff":
		*_fbff = 35
	case "userA":
		*_fbff = 36
	case "userB":
		*_fbff = 37
	case "userC":
		*_fbff = 38
	case "userD":
		*_fbff = 39
	case "userE":
		*_fbff = 40
	case "userF":
		*_fbff = 41
	case "userG":
		*_fbff = 42
	case "userH":
		*_fbff = 43
	case "userI":
		*_fbff = 44
	case "userJ":
		*_fbff = 45
	case "userK":
		*_fbff = 46
	case "userL":
		*_fbff = 47
	case "userM":
		*_fbff = 48
	case "userN":
		*_fbff = 49
	case "userO":
		*_fbff = 50
	case "userP":
		*_fbff = 51
	case "userQ":
		*_fbff = 52
	case "userR":
		*_fbff = 53
	case "userS":
		*_fbff = 54
	case "userT":
		*_fbff = 55
	case "userU":
		*_fbff = 56
	case "userV":
		*_fbff = 57
	case "userW":
		*_fbff = 58
	case "userX":
		*_fbff = 59
	case "userY":
		*_fbff = 60
	case "userZ":
		*_fbff = 61
	case "w":
		*_fbff = 62
	case "wArH":
		*_fbff = 63
	case "wOff":
		*_fbff = 64
	}
	return nil
}

// Validate validates the RelIds and its children
func (_bgfec *RelIds) Validate() error       { return _bgfec.ValidateWithPath("RelIds") }
func (_eafea ST_AnimOneStr) Validate() error { return _eafea.ValidateWithPath("") }

type ST_FallbackDimension byte

const (
	ST_OffsetUnset ST_Offset = 0
	ST_OffsetCtr   ST_Offset = 1
	ST_OffsetOff   ST_Offset = 2
)

func NewCT_NumericRule() *CT_NumericRule { _eadf := &CT_NumericRule{}; return _eadf }

type ST_TextDirection byte
type ColorsDefHdrLst struct{ CT_ColorTransformHeaderLst }

func NewCT_DiagramDefinition() *CT_DiagramDefinition {
	_cccac := &CT_DiagramDefinition{}
	_cccac.LayoutNode = NewCT_LayoutNode()
	return _cccac
}
func (_efff *CT_Description) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bbecb := range start.Attr {
		if _bbecb.Name.Local == "lang" {
			_aegd, _cdde := _bbecb.Value, error(nil)
			if _cdde != nil {
				return _cdde
			}
			_efff.LangAttr = &_aegd
			continue
		}
		if _bbecb.Name.Local == "val" {
			_ddfb, _gcad := _bbecb.Value, error(nil)
			if _gcad != nil {
				return _gcad
			}
			_efff.ValAttr = _ddfb
			continue
		}
	}
	for {
		_bcbb, _bbdc := d.Token()
		if _bbdc != nil {
			return _a.Errorf("parsing\u0020CT_Description:\u0020\u0025s", _bbdc)
		}
		if _bddc, _aea := _bcbb.(_b.EndElement); _aea && _bddc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_aafdd *CT_DiagramDefinitionHeaderLst) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_dcce:
	for {
		_abfc, _bacd := d.Token()
		if _bacd != nil {
			return _bacd
		}
		switch _abcc := _abfc.(type) {
		case _b.StartElement:
			switch _abcc.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "layoutDefHdr"}:
				_agce := NewCT_DiagramDefinitionHeader()
				if _egaf := d.DecodeElement(_agce, &_abcc); _egaf != nil {
					return _egaf
				}
				_aafdd.LayoutDefHdr = append(_aafdd.LayoutDefHdr, _agce)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element on\u0020CT_DiagramDefinitionHeaderLst\u0020%v", _abcc.Name)
				if _becd := d.Skip(); _becd != nil {
					return _becd
				}
			}
		case _b.EndElement:
			break _dcce
		case _b.CharData:
		}
	}
	return nil
}
func (_bcce ST_VerticalAlignment) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_eebf := _b.Attr{}
	_eebf.Name = name
	switch _bcce {
	case ST_VerticalAlignmentUnset:
		_eebf.Value = ""
	case ST_VerticalAlignmentT:
		_eebf.Value = "t"
	case ST_VerticalAlignmentMid:
		_eebf.Value = "mid"
	case ST_VerticalAlignmentB:
		_eebf.Value = "b"
	case ST_VerticalAlignmentNone:
		_eebf.Value = "none"
	}
	return _eebf, nil
}
func (_gabe ST_ConstraintType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_cbegeb := _b.Attr{}
	_cbegeb.Name = name
	switch _gabe {
	case ST_ConstraintTypeUnset:
		_cbegeb.Value = ""
	case ST_ConstraintTypeNone:
		_cbegeb.Value = "none"
	case ST_ConstraintTypeAlignOff:
		_cbegeb.Value = "alignOff"
	case ST_ConstraintTypeBegMarg:
		_cbegeb.Value = "begMarg"
	case ST_ConstraintTypeBendDist:
		_cbegeb.Value = "bendDist"
	case ST_ConstraintTypeBegPad:
		_cbegeb.Value = "begPad"
	case ST_ConstraintTypeB:
		_cbegeb.Value = "b"
	case ST_ConstraintTypeBMarg:
		_cbegeb.Value = "bMarg"
	case ST_ConstraintTypeBOff:
		_cbegeb.Value = "bOff"
	case ST_ConstraintTypeCtrX:
		_cbegeb.Value = "ctrX"
	case ST_ConstraintTypeCtrXOff:
		_cbegeb.Value = "ctrXOff"
	case ST_ConstraintTypeCtrY:
		_cbegeb.Value = "ctrY"
	case ST_ConstraintTypeCtrYOff:
		_cbegeb.Value = "ctrYOff"
	case ST_ConstraintTypeConnDist:
		_cbegeb.Value = "connDist"
	case ST_ConstraintTypeDiam:
		_cbegeb.Value = "diam"
	case ST_ConstraintTypeEndMarg:
		_cbegeb.Value = "endMarg"
	case ST_ConstraintTypeEndPad:
		_cbegeb.Value = "endPad"
	case ST_ConstraintTypeH:
		_cbegeb.Value = "h"
	case ST_ConstraintTypeHArH:
		_cbegeb.Value = "hArH"
	case ST_ConstraintTypeHOff:
		_cbegeb.Value = "hOff"
	case ST_ConstraintTypeL:
		_cbegeb.Value = "l"
	case ST_ConstraintTypeLMarg:
		_cbegeb.Value = "lMarg"
	case ST_ConstraintTypeLOff:
		_cbegeb.Value = "lOff"
	case ST_ConstraintTypeR:
		_cbegeb.Value = "r"
	case ST_ConstraintTypeRMarg:
		_cbegeb.Value = "rMarg"
	case ST_ConstraintTypeROff:
		_cbegeb.Value = "rOff"
	case ST_ConstraintTypePrimFontSz:
		_cbegeb.Value = "primFontSz"
	case ST_ConstraintTypePyraAcctRatio:
		_cbegeb.Value = "pyraAcctRatio"
	case ST_ConstraintTypeSecFontSz:
		_cbegeb.Value = "secFontSz"
	case ST_ConstraintTypeSibSp:
		_cbegeb.Value = "sibSp"
	case ST_ConstraintTypeSecSibSp:
		_cbegeb.Value = "secSibSp"
	case ST_ConstraintTypeSp:
		_cbegeb.Value = "sp"
	case ST_ConstraintTypeStemThick:
		_cbegeb.Value = "stemThick"
	case ST_ConstraintTypeT:
		_cbegeb.Value = "t"
	case ST_ConstraintTypeTMarg:
		_cbegeb.Value = "tMarg"
	case ST_ConstraintTypeTOff:
		_cbegeb.Value = "tOff"
	case ST_ConstraintTypeUserA:
		_cbegeb.Value = "userA"
	case ST_ConstraintTypeUserB:
		_cbegeb.Value = "userB"
	case ST_ConstraintTypeUserC:
		_cbegeb.Value = "userC"
	case ST_ConstraintTypeUserD:
		_cbegeb.Value = "userD"
	case ST_ConstraintTypeUserE:
		_cbegeb.Value = "userE"
	case ST_ConstraintTypeUserF:
		_cbegeb.Value = "userF"
	case ST_ConstraintTypeUserG:
		_cbegeb.Value = "userG"
	case ST_ConstraintTypeUserH:
		_cbegeb.Value = "userH"
	case ST_ConstraintTypeUserI:
		_cbegeb.Value = "userI"
	case ST_ConstraintTypeUserJ:
		_cbegeb.Value = "userJ"
	case ST_ConstraintTypeUserK:
		_cbegeb.Value = "userK"
	case ST_ConstraintTypeUserL:
		_cbegeb.Value = "userL"
	case ST_ConstraintTypeUserM:
		_cbegeb.Value = "userM"
	case ST_ConstraintTypeUserN:
		_cbegeb.Value = "userN"
	case ST_ConstraintTypeUserO:
		_cbegeb.Value = "userO"
	case ST_ConstraintTypeUserP:
		_cbegeb.Value = "userP"
	case ST_ConstraintTypeUserQ:
		_cbegeb.Value = "userQ"
	case ST_ConstraintTypeUserR:
		_cbegeb.Value = "userR"
	case ST_ConstraintTypeUserS:
		_cbegeb.Value = "userS"
	case ST_ConstraintTypeUserT:
		_cbegeb.Value = "userT"
	case ST_ConstraintTypeUserU:
		_cbegeb.Value = "userU"
	case ST_ConstraintTypeUserV:
		_cbegeb.Value = "userV"
	case ST_ConstraintTypeUserW:
		_cbegeb.Value = "userW"
	case ST_ConstraintTypeUserX:
		_cbegeb.Value = "userX"
	case ST_ConstraintTypeUserY:
		_cbegeb.Value = "userY"
	case ST_ConstraintTypeUserZ:
		_cbegeb.Value = "userZ"
	case ST_ConstraintTypeW:
		_cbegeb.Value = "w"
	case ST_ConstraintTypeWArH:
		_cbegeb.Value = "wArH"
	case ST_ConstraintTypeWOff:
		_cbegeb.Value = "wOff"
	}
	return _cbegeb, nil
}

// ValidateWithPath validates the CT_SDDescription and its children, prefixing error messages with path
func (_cdcfe *CT_SDDescription) ValidateWithPath(path string) error { return nil }
func (_abbbcc ST_FallbackDimension) ValidateWithPath(path string) error {
	switch _abbbcc {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_abbbcc))
	}
	return nil
}
func (_ffgcb ST_DiagramHorizontalAlignment) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_dafe := _b.Attr{}
	_dafe.Name = name
	switch _ffgcb {
	case ST_DiagramHorizontalAlignmentUnset:
		_dafe.Value = ""
	case ST_DiagramHorizontalAlignmentL:
		_dafe.Value = "l"
	case ST_DiagramHorizontalAlignmentCtr:
		_dafe.Value = "ctr"
	case ST_DiagramHorizontalAlignmentR:
		_dafe.Value = "r"
	case ST_DiagramHorizontalAlignmentNone:
		_dafe.Value = "none"
	}
	return _dafe, nil
}
func (_acfd *CT_DiagramDefinitionHeader) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _cec := range start.Attr {
		if _cec.Name.Local == "uniqueId" {
			_fgff, _agdec := _cec.Value, error(nil)
			if _agdec != nil {
				return _agdec
			}
			_acfd.UniqueIdAttr = _fgff
			continue
		}
		if _cec.Name.Local == "minVer" {
			_ffbd, _aae := _cec.Value, error(nil)
			if _aae != nil {
				return _aae
			}
			_acfd.MinVerAttr = &_ffbd
			continue
		}
		if _cec.Name.Local == "defStyle" {
			_fabf, _bbcd := _cec.Value, error(nil)
			if _bbcd != nil {
				return _bbcd
			}
			_acfd.DefStyleAttr = &_fabf
			continue
		}
		if _cec.Name.Local == "resId" {
			_deec, _beeg := _d.ParseInt(_cec.Value, 10, 32)
			if _beeg != nil {
				return _beeg
			}
			_caba := int32(_deec)
			_acfd.ResIdAttr = &_caba
			continue
		}
	}
_fccf:
	for {
		_eccb, _fef := d.Token()
		if _fef != nil {
			return _fef
		}
		switch _eca := _eccb.(type) {
		case _b.StartElement:
			switch _eca.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_gcde := NewCT_Name()
				if _gbc := d.DecodeElement(_gcde, &_eca); _gbc != nil {
					return _gbc
				}
				_acfd.Title = append(_acfd.Title, _gcde)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_geag := NewCT_Description()
				if _befg := d.DecodeElement(_geag, &_eca); _befg != nil {
					return _befg
				}
				_acfd.Desc = append(_acfd.Desc, _geag)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_acfd.CatLst = NewCT_Categories()
				if _aedbb := d.DecodeElement(_acfd.CatLst, &_eca); _aedbb != nil {
					return _aedbb
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_acfd.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _ggee := d.DecodeElement(_acfd.ExtLst, &_eca); _ggee != nil {
					return _ggee
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_DiagramDefinitionHeader\u0020\u0025v", _eca.Name)
				if _ceaca := d.Skip(); _ceaca != nil {
					return _ceaca
				}
			}
		case _b.EndElement:
			break _fccf
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the ColorsDefHdr and its children, prefixing error messages with path
func (_acdd *ColorsDefHdr) ValidateWithPath(path string) error {
	if _ccadb := _acdd.CT_ColorTransformHeader.ValidateWithPath(path); _ccadb != nil {
		return _ccadb
	}
	return nil
}
func NewRelIds() *RelIds { _egfa := &RelIds{}; _egfa.CT_RelIds = *NewCT_RelIds(); return _egfa }
func (_dfagc ST_ArrowheadStyle) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dfagc.String(), start)
}

type CT_ChildMax struct{ ValAttr *int32 }

func NewCT_SDName() *CT_SDName { _efbg := &CT_SDName{}; return _efbg }
func (_adad ST_PtType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_ceed := _b.Attr{}
	_ceed.Name = name
	switch _adad {
	case ST_PtTypeUnset:
		_ceed.Value = ""
	case ST_PtTypeNode:
		_ceed.Value = "node"
	case ST_PtTypeAsst:
		_ceed.Value = "asst"
	case ST_PtTypeDoc:
		_ceed.Value = "doc"
	case ST_PtTypePres:
		_ceed.Value = "pres"
	case ST_PtTypeParTrans:
		_ceed.Value = "parTrans"
	case ST_PtTypeSibTrans:
		_ceed.Value = "sibTrans"
	}
	return _ceed, nil
}
func (_fbcge ST_PtType) ValidateWithPath(path string) error {
	switch _fbcge {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fbcge))
	}
	return nil
}
func (_eebda *ST_ClrAppMethod) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_eebda = 0
	case "span":
		*_eebda = 1
	case "cycle":
		*_eebda = 2
	case "repeat":
		*_eebda = 3
	}
	return nil
}

// Validate validates the CT_Cxn and its children
func (_eefd *CT_Cxn) Validate() error { return _eefd.ValidateWithPath("CT_Cxn") }
func (_ebgg ST_HierarchyAlignment) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_ebgg.String(), start)
}
func (_dfaa *CT_NumericRule) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _dfaa.ValAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", *_dfaa.ValAttr)})
	}
	if _dfaa.FactAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fact"}, Value: _a.Sprintf("\u0025v", *_dfaa.FactAttr)})
	}
	if _dfaa.MaxAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "max"}, Value: _a.Sprintf("\u0025v", *_dfaa.MaxAttr)})
	}
	if _dfaa.TypeAttr != ST_ConstraintTypeUnset {
		_ggbfd, _adae := _dfaa.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _adae != nil {
			return _adae
		}
		start.Attr = append(start.Attr, _ggbfd)
	}
	if _dfaa.ForAttr != ST_ConstraintRelationshipUnset {
		_agdb, _aebg := _dfaa.ForAttr.MarshalXMLAttr(_b.Name{Local: "for"})
		if _aebg != nil {
			return _aebg
		}
		start.Attr = append(start.Attr, _agdb)
	}
	if _dfaa.ForNameAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "forName"}, Value: _a.Sprintf("\u0025v", *_dfaa.ForNameAttr)})
	}
	if _dfaa.PtTypeAttr != ST_ElementTypeUnset {
		_fabc, _gbbcf := _dfaa.PtTypeAttr.MarshalXMLAttr(_b.Name{Local: "ptType"})
		if _gbbcf != nil {
			return _gbbcf
		}
		start.Attr = append(start.Attr, _fabc)
	}
	e.EncodeToken(start)
	if _dfaa.ExtLst != nil {
		_bbeff := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_dfaa.ExtLst, _bbeff)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_AdjLst and its children, prefixing error messages with path
func (_egb *CT_AdjLst) ValidateWithPath(path string) error {
	for _cf, _geg := range _egb.Adj {
		if _gaf := _geg.ValidateWithPath(_a.Sprintf("\u0025s\u002fAdj\u005b\u0025d\u005d", path, _cf)); _gaf != nil {
			return _gaf
		}
	}
	return nil
}

// ValidateWithPath validates the LayoutDefHdrLst and its children, prefixing error messages with path
func (_gbge *LayoutDefHdrLst) ValidateWithPath(path string) error {
	if _adfc := _gbge.CT_DiagramDefinitionHeaderLst.ValidateWithPath(path); _adfc != nil {
		return _adfc
	}
	return nil
}
func (_gdae *CT_Constraint) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _gdae.OpAttr != ST_BoolOperatorUnset {
		_aedge, _gabf := _gdae.OpAttr.MarshalXMLAttr(_b.Name{Local: "op"})
		if _gabf != nil {
			return _gabf
		}
		start.Attr = append(start.Attr, _aedge)
	}
	if _gdae.ValAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", *_gdae.ValAttr)})
	}
	if _gdae.FactAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fact"}, Value: _a.Sprintf("\u0025v", *_gdae.FactAttr)})
	}
	if _gdae.TypeAttr != ST_ConstraintTypeUnset {
		_adcd, _agcb := _gdae.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _agcb != nil {
			return _agcb
		}
		start.Attr = append(start.Attr, _adcd)
	}
	if _gdae.ForAttr != ST_ConstraintRelationshipUnset {
		_fce, _bcac := _gdae.ForAttr.MarshalXMLAttr(_b.Name{Local: "for"})
		if _bcac != nil {
			return _bcac
		}
		start.Attr = append(start.Attr, _fce)
	}
	if _gdae.ForNameAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "forName"}, Value: _a.Sprintf("\u0025v", *_gdae.ForNameAttr)})
	}
	if _gdae.PtTypeAttr != ST_ElementTypeUnset {
		_add, _ecba := _gdae.PtTypeAttr.MarshalXMLAttr(_b.Name{Local: "ptType"})
		if _ecba != nil {
			return _ecba
		}
		start.Attr = append(start.Attr, _add)
	}
	if _gdae.RefTypeAttr != ST_ConstraintTypeUnset {
		_gaab, _dcc := _gdae.RefTypeAttr.MarshalXMLAttr(_b.Name{Local: "refType"})
		if _dcc != nil {
			return _dcc
		}
		start.Attr = append(start.Attr, _gaab)
	}
	if _gdae.RefForAttr != ST_ConstraintRelationshipUnset {
		_gdc, _bbag := _gdae.RefForAttr.MarshalXMLAttr(_b.Name{Local: "refFor"})
		if _bbag != nil {
			return _bbag
		}
		start.Attr = append(start.Attr, _gdc)
	}
	if _gdae.RefForNameAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "refForName"}, Value: _a.Sprintf("\u0025v", *_gdae.RefForNameAttr)})
	}
	if _gdae.RefPtTypeAttr != ST_ElementTypeUnset {
		_cffg, _gdaed := _gdae.RefPtTypeAttr.MarshalXMLAttr(_b.Name{Local: "refPtType"})
		if _gdaed != nil {
			return _gdaed
		}
		start.Attr = append(start.Attr, _cffg)
	}
	e.EncodeToken(start)
	if _gdae.ExtLst != nil {
		_dgfe := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_gdae.ExtLst, _dgfe)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewCT_Categories() *CT_Categories { _ecb := &CT_Categories{}; return _ecb }

// ValidateWithPath validates the AG_IteratorAttributes and its children, prefixing error messages with path
func (_fdg *AG_IteratorAttributes) ValidateWithPath(path string) error { return nil }

// Validate validates the StyleDef and its children
func (_eeaeg *StyleDef) Validate() error { return _eeaeg.ValidateWithPath("StyleDef") }

// ST_ModelId is a union type
type ST_ModelId struct {
	Int32   *int32
	ST_Guid *string
}

func (_dgfebb ST_HierBranchStyle) Validate() error { return _dgfebb.ValidateWithPath("") }
func (_bada ST_LayoutShapeType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _bada.ST_ShapeType != _f.ST_ShapeTypeUnset {
		e.EncodeToken(_b.CharData(_bada.ST_ShapeType.String()))
	}
	if _bada.ST_OutputShapeType != ST_OutputShapeTypeUnset {
		e.EncodeToken(_b.CharData(_bada.ST_OutputShapeType.String()))
	}
	return e.EncodeToken(_b.EndElement{Name: start.Name})
}
func (_agdge ST_DiagramHorizontalAlignment) String() string {
	switch _agdge {
	case 0:
		return ""
	case 1:
		return "l"
	case 2:
		return "ctr"
	case 3:
		return "r"
	case 4:
		return "none"
	}
	return ""
}
func (_dddae ST_AnimOneStr) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dddae.String(), start)
}

const (
	ST_ArrowheadStyleUnset ST_ArrowheadStyle = 0
	ST_ArrowheadStyleAuto  ST_ArrowheadStyle = 1
	ST_ArrowheadStyleArr   ST_ArrowheadStyle = 2
	ST_ArrowheadStyleNoArr ST_ArrowheadStyle = 3
)
const (
	ST_BoolOperatorUnset ST_BoolOperator = 0
	ST_BoolOperatorNone  ST_BoolOperator = 1
	ST_BoolOperatorEqu   ST_BoolOperator = 2
	ST_BoolOperatorGte   ST_BoolOperator = 3
	ST_BoolOperatorLte   ST_BoolOperator = 4
)

type AG_ConstraintRefAttributes struct {
	RefTypeAttr    ST_ConstraintType
	RefForAttr     ST_ConstraintRelationship
	RefForNameAttr *string
	RefPtTypeAttr  ST_ElementType
}

func (_bag *CT_ChildPref) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bag.ValAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", *_bag.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_eacd *ST_AnimOneStr) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_adbf, _cfag := d.Token()
	if _cfag != nil {
		return _cfag
	}
	if _cfbd, _aegc := _adbf.(_b.EndElement); _aegc && _cfbd.Name == start.Name {
		*_eacd = 1
		return nil
	}
	if _gegda, _deebb := _adbf.(_b.CharData); !_deebb {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _adbf)
	} else {
		switch string(_gegda) {
		case "":
			*_eacd = 0
		case "none":
			*_eacd = 1
		case "one":
			*_eacd = 2
		case "branch":
			*_eacd = 3
		}
	}
	_adbf, _cfag = d.Token()
	if _cfag != nil {
		return _cfag
	}
	if _aefaa, _ebcfe := _adbf.(_b.EndElement); _ebcfe && _aefaa.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _adbf)
}

const (
	ST_ConnectorRoutingUnset     ST_ConnectorRouting = 0
	ST_ConnectorRoutingStra      ST_ConnectorRouting = 1
	ST_ConnectorRoutingBend      ST_ConnectorRouting = 2
	ST_ConnectorRoutingCurve     ST_ConnectorRouting = 3
	ST_ConnectorRoutingLongCurve ST_ConnectorRouting = 4
)

// Validate validates the CT_CTName and its children
func (_cdae *CT_CTName) Validate() error { return _cdae.ValidateWithPath("CT_CTName") }
func (_ceff ST_AlgorithmType) ValidateWithPath(path string) error {
	switch _ceff {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ceff))
	}
	return nil
}

// ValidateWithPath validates the ColorsDef and its children, prefixing error messages with path
func (_gddfb *ColorsDef) ValidateWithPath(path string) error {
	if _baef := _gddfb.CT_ColorTransform.ValidateWithPath(path); _baef != nil {
		return _baef
	}
	return nil
}

const (
	ST_NodeHorizontalAlignmentUnset ST_NodeHorizontalAlignment = 0
	ST_NodeHorizontalAlignmentL     ST_NodeHorizontalAlignment = 1
	ST_NodeHorizontalAlignmentCtr   ST_NodeHorizontalAlignment = 2
	ST_NodeHorizontalAlignmentR     ST_NodeHorizontalAlignment = 3
)

func (_cbdce *ST_PyramidAccentTextMargin) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cbaag, _gcdgf := d.Token()
	if _gcdgf != nil {
		return _gcdgf
	}
	if _dgdfd, _edfde := _cbaag.(_b.EndElement); _edfde && _dgdfd.Name == start.Name {
		*_cbdce = 1
		return nil
	}
	if _dcfa, _fagac := _cbaag.(_b.CharData); !_fagac {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cbaag)
	} else {
		switch string(_dcfa) {
		case "":
			*_cbdce = 0
		case "step":
			*_cbdce = 1
		case "stack":
			*_cbdce = 2
		}
	}
	_cbaag, _gcdgf = d.Token()
	if _gcdgf != nil {
		return _gcdgf
	}
	if _cdce, _adece := _cbaag.(_b.EndElement); _adece && _cdce.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cbaag)
}
func ParseUnionST_ModelId(s string) (ST_ModelId, error) { return ST_ModelId{}, nil }

// ValidateWithPath validates the CT_ColorTransformHeaderLst and its children, prefixing error messages with path
func (_cabfa *CT_ColorTransformHeaderLst) ValidateWithPath(path string) error {
	for _afc, _aaac := range _cabfa.ColorsDefHdr {
		if _bccc := _aaac.ValidateWithPath(_a.Sprintf("\u0025s\u002fColorsDefHdr\u005b\u0025d\u005d", path, _afc)); _bccc != nil {
			return _bccc
		}
	}
	return nil
}
func (_gfeg ST_FunctionType) Validate() error { return _gfeg.ValidateWithPath("") }

// Validate validates the CT_Name and its children
func (_ebgc *CT_Name) Validate() error { return _ebgc.ValidateWithPath("CT_Name") }
func (_bfde ST_DiagramHorizontalAlignment) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bfde.String(), start)
}

type CT_ElemPropSet struct {
	PresAssocIDAttr          *ST_ModelId
	PresNameAttr             *string
	PresStyleLblAttr         *string
	PresStyleIdxAttr         *int32
	PresStyleCntAttr         *int32
	LoTypeIdAttr             *string
	LoCatIdAttr              *string
	QsTypeIdAttr             *string
	QsCatIdAttr              *string
	CsTypeIdAttr             *string
	CsCatIdAttr              *string
	Coherent3DOffAttr        *bool
	PhldrTAttr               *string
	PhldrAttr                *bool
	CustAngAttr              *int32
	CustFlipVertAttr         *bool
	CustFlipHorAttr          *bool
	CustSzXAttr              *int32
	CustSzYAttr              *int32
	CustScaleXAttr           *ST_PrSetCustVal
	CustScaleYAttr           *ST_PrSetCustVal
	CustTAttr                *bool
	CustLinFactXAttr         *ST_PrSetCustVal
	CustLinFactYAttr         *ST_PrSetCustVal
	CustLinFactNeighborXAttr *ST_PrSetCustVal
	CustLinFactNeighborYAttr *ST_PrSetCustVal
	CustRadScaleRadAttr      *ST_PrSetCustVal
	CustRadScaleIncAttr      *ST_PrSetCustVal
	PresLayoutVars           *CT_LayoutVariablePropertySet
	Style                    *_f.CT_ShapeStyle
}

const (
	ST_ChildOrderTypeUnset ST_ChildOrderType = 0
	ST_ChildOrderTypeB     ST_ChildOrderType = 1
	ST_ChildOrderTypeT     ST_ChildOrderType = 2
)

// ValidateWithPath validates the CT_Colors and its children, prefixing error messages with path
func (_efc *CT_Colors) ValidateWithPath(path string) error {
	if _ccgf := _efc.MethAttr.ValidateWithPath(path + "\u002fMethAttr"); _ccgf != nil {
		return _ccgf
	}
	if _aacg := _efc.HueDirAttr.ValidateWithPath(path + "/HueDirAttr"); _aacg != nil {
		return _aacg
	}
	for _caec, _dbcb := range _efc.EG_ColorChoice {
		if _bcg := _dbcb.ValidateWithPath(_a.Sprintf("%s\u002fEG_ColorChoice\u005b\u0025d\u005d", path, _caec)); _bcg != nil {
			return _bcg
		}
	}
	return nil
}

const (
	ST_CenterShapeMappingUnset ST_CenterShapeMapping = 0
	ST_CenterShapeMappingNone  ST_CenterShapeMapping = 1
	ST_CenterShapeMappingFNode ST_CenterShapeMapping = 2
)

func (_geee *CT_Pt) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _faaaa := range start.Attr {
		if _faaaa.Name.Local == "modelId" {
			_cedaf, _cdcc := ParseUnionST_ModelId(_faaaa.Value)
			if _cdcc != nil {
				return _cdcc
			}
			_geee.ModelIdAttr = _cedaf
			continue
		}
		if _faaaa.Name.Local == "type" {
			_geee.TypeAttr.UnmarshalXMLAttr(_faaaa)
			continue
		}
		if _faaaa.Name.Local == "cxnId" {
			_acbe, _gacaf := ParseUnionST_ModelId(_faaaa.Value)
			if _gacaf != nil {
				return _gacaf
			}
			_geee.CxnIdAttr = &_acbe
			continue
		}
	}
_bdcc:
	for {
		_dcbd, _dbfb := d.Token()
		if _dbfb != nil {
			return _dbfb
		}
		switch _gfbf := _dcbd.(type) {
		case _b.StartElement:
			switch _gfbf.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "prSet"}:
				_geee.PrSet = NewCT_ElemPropSet()
				if _fdag := d.DecodeElement(_geee.PrSet, &_gfbf); _fdag != nil {
					return _fdag
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "spPr"}:
				_geee.SpPr = _f.NewCT_ShapeProperties()
				if _cdbfa := d.DecodeElement(_geee.SpPr, &_gfbf); _cdbfa != nil {
					return _cdbfa
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "t"}:
				_geee.T = _f.NewCT_TextBody()
				if _agfa := d.DecodeElement(_geee.T, &_gfbf); _agfa != nil {
					return _agfa
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_geee.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _bgae := d.DecodeElement(_geee.ExtLst, &_gfbf); _bgae != nil {
					return _bgae
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on CT_Pt \u0025v", _gfbf.Name)
				if _feee := d.Skip(); _feee != nil {
					return _feee
				}
			}
		case _b.EndElement:
			break _bdcc
		case _b.CharData:
		}
	}
	return nil
}
func (_baeef *CT_OrgChart) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dabbg := range start.Attr {
		if _dabbg.Name.Local == "val" {
			_gdbd, _dccc := _d.ParseBool(_dabbg.Value)
			if _dccc != nil {
				return _dccc
			}
			_baeef.ValAttr = &_gdbd
			continue
		}
	}
	for {
		_egdab, _aadb := d.Token()
		if _aadb != nil {
			return _a.Errorf("parsing\u0020CT_OrgChart:\u0020\u0025s", _aadb)
		}
		if _fdbd, _agdf := _egdab.(_b.EndElement); _agdf && _fdbd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dbdd *ST_TextBlockDirection) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dbdd = 0
	case "horz":
		*_dbdd = 1
	case "vert":
		*_dbdd = 2
	}
	return nil
}

type ST_GrowDirection byte

func (_ddef *CT_PresentationOf) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _eeed := range start.Attr {
		if _eeed.Name.Local == "axis" {
			_bcag, _eadc := ParseSliceST_AxisTypes(_eeed.Value)
			if _eadc != nil {
				return _eadc
			}
			_ddef.AxisAttr = &_bcag
			continue
		}
		if _eeed.Name.Local == "ptType" {
			_edec, _agaf := ParseSliceST_ElementTypes(_eeed.Value)
			if _agaf != nil {
				return _agaf
			}
			_ddef.PtTypeAttr = &_edec
			continue
		}
		if _eeed.Name.Local == "hideLastTrans" {
			_bggbf, _fgef := ParseSliceST_Booleans(_eeed.Value)
			if _fgef != nil {
				return _fgef
			}
			_ddef.HideLastTransAttr = &_bggbf
			continue
		}
		if _eeed.Name.Local == "st" {
			_gafdf, _ggae := ParseSliceST_Ints(_eeed.Value)
			if _ggae != nil {
				return _ggae
			}
			_ddef.StAttr = &_gafdf
			continue
		}
		if _eeed.Name.Local == "cnt" {
			_cgca, _dgfae := ParseSliceST_UnsignedInts(_eeed.Value)
			if _dgfae != nil {
				return _dgfae
			}
			_ddef.CntAttr = &_cgca
			continue
		}
		if _eeed.Name.Local == "step" {
			_ecbaa, _ddag := ParseSliceST_Ints(_eeed.Value)
			if _ddag != nil {
				return _ddag
			}
			_ddef.StepAttr = &_ecbaa
			continue
		}
	}
_dcdac:
	for {
		_ecac, _bbege := d.Token()
		if _bbege != nil {
			return _bbege
		}
		switch _gfgb := _ecac.(type) {
		case _b.StartElement:
			switch _gfgb.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_ddef.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _aebc := d.DecodeElement(_ddef.ExtLst, &_gfgb); _aebc != nil {
					return _aebc
				}
			default:
				_ea.Log("skipping unsupported\u0020element\u0020on\u0020CT_PresentationOf\u0020\u0025v", _gfgb.Name)
				if _dbac := d.Skip(); _dbac != nil {
					return _dbac
				}
			}
		case _b.EndElement:
			break _dcdac
		case _b.CharData:
		}
	}
	return nil
}
func (_fgf *CT_ChildMax) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _abcd := range start.Attr {
		if _abcd.Name.Local == "val" {
			_ebga, _efaf := _d.ParseInt(_abcd.Value, 10, 32)
			if _efaf != nil {
				return _efaf
			}
			_agd := int32(_ebga)
			_fgf.ValAttr = &_agd
			continue
		}
	}
	for {
		_dcf, _ega := d.Token()
		if _ega != nil {
			return _a.Errorf("parsing\u0020CT_ChildMax:\u0020\u0025s", _ega)
		}
		if _ecc, _bbfc := _dcf.(_b.EndElement); _bbfc && _ecc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gbbbe *ST_FunctionValue) Validate() error { return _gbbbe.ValidateWithPath("") }
func (_aeaf *ST_ConnectorRouting) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_aeaf = 0
	case "stra":
		*_aeaf = 1
	case "bend":
		*_aeaf = 2
	case "curve":
		*_aeaf = 3
	case "longCurve":
		*_aeaf = 4
	}
	return nil
}
func (_agge ST_TextAnchorVertical) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_agge.String(), start)
}
func (_dedf ST_ClrAppMethod) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gbdf := _b.Attr{}
	_gbdf.Name = name
	switch _dedf {
	case ST_ClrAppMethodUnset:
		_gbdf.Value = ""
	case ST_ClrAppMethodSpan:
		_gbdf.Value = "span"
	case ST_ClrAppMethodCycle:
		_gbdf.Value = "cycle"
	case ST_ClrAppMethodRepeat:
		_gbdf.Value = "repeat"
	}
	return _gbdf, nil
}

type CT_SDDescription struct {
	LangAttr *string
	ValAttr  string
}
type AG_ConstraintAttributes struct {
	TypeAttr    ST_ConstraintType
	ForAttr     ST_ConstraintRelationship
	ForNameAttr *string
	PtTypeAttr  ST_ElementType
}

func NewCT_ChildMax() *CT_ChildMax { _dec := &CT_ChildMax{}; return _dec }

// Validate validates the CT_Adj and its children
func (_aed *CT_Adj) Validate() error { return _aed.ValidateWithPath("CT_Adj") }
func (_fbebg *ST_ParameterId) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fbebg = 0
	case "horzAlign":
		*_fbebg = 1
	case "vertAlign":
		*_fbebg = 2
	case "chDir":
		*_fbebg = 3
	case "chAlign":
		*_fbebg = 4
	case "secChAlign":
		*_fbebg = 5
	case "linDir":
		*_fbebg = 6
	case "secLinDir":
		*_fbebg = 7
	case "stElem":
		*_fbebg = 8
	case "bendPt":
		*_fbebg = 9
	case "connRout":
		*_fbebg = 10
	case "begSty":
		*_fbebg = 11
	case "endSty":
		*_fbebg = 12
	case "dim":
		*_fbebg = 13
	case "rotPath":
		*_fbebg = 14
	case "ctrShpMap":
		*_fbebg = 15
	case "nodeHorzAlign":
		*_fbebg = 16
	case "nodeVertAlign":
		*_fbebg = 17
	case "fallback":
		*_fbebg = 18
	case "txDir":
		*_fbebg = 19
	case "pyraAcctPos":
		*_fbebg = 20
	case "pyraAcctTxMar":
		*_fbebg = 21
	case "txBlDir":
		*_fbebg = 22
	case "txAnchorHorz":
		*_fbebg = 23
	case "txAnchorVert":
		*_fbebg = 24
	case "txAnchorHorzCh":
		*_fbebg = 25
	case "txAnchorVertCh":
		*_fbebg = 26
	case "parTxLTRAlign":
		*_fbebg = 27
	case "parTxRTLAlign":
		*_fbebg = 28
	case "shpTxLTRAlignCh":
		*_fbebg = 29
	case "shpTxRTLAlignCh":
		*_fbebg = 30
	case "autoTxRot":
		*_fbebg = 31
	case "grDir":
		*_fbebg = 32
	case "flowDir":
		*_fbebg = 33
	case "contDir":
		*_fbebg = 34
	case "bkpt":
		*_fbebg = 35
	case "off":
		*_fbebg = 36
	case "hierAlign":
		*_fbebg = 37
	case "bkPtFixedVal":
		*_fbebg = 38
	case "stBulletLvl":
		*_fbebg = 39
	case "stAng":
		*_fbebg = 40
	case "spanAng":
		*_fbebg = 41
	case "ar":
		*_fbebg = 42
	case "lnSpPar":
		*_fbebg = 43
	case "lnSpAfParP":
		*_fbebg = 44
	case "lnSpCh":
		*_fbebg = 45
	case "lnSpAfChP":
		*_fbebg = 46
	case "rtShortDist":
		*_fbebg = 47
	case "alignTx":
		*_fbebg = 48
	case "pyraLvlNode":
		*_fbebg = 49
	case "pyraAcctBkgdNode":
		*_fbebg = 50
	case "pyraAcctTxNode":
		*_fbebg = 51
	case "srcNode":
		*_fbebg = 52
	case "dstNode":
		*_fbebg = 53
	case "begPts":
		*_fbebg = 54
	case "endPts":
		*_fbebg = 55
	}
	return nil
}
func (_aggb ST_ConnectorRouting) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_aggb.String(), start)
}

// Validate validates the CT_Colors and its children
func (_ecde *CT_Colors) Validate() error { return _ecde.ValidateWithPath("CT_Colors") }
func (_gcgf ST_FunctionArgument) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _gcgf.ST_VariableType != ST_VariableTypeUnset {
		e.EncodeToken(_b.CharData(_gcgf.ST_VariableType.String()))
	}
	return e.EncodeToken(_b.EndElement{Name: start.Name})
}
func (_aaaca *ST_ParameterVal) ValidateWithPath(path string) error {
	_ebbbc := []string{}
	if _aaaca.ST_DiagramHorizontalAlignment != ST_DiagramHorizontalAlignmentUnset {
		_ebbbc = append(_ebbbc, "ST_DiagramHorizontalAlignment")
	}
	if _aaaca.ST_VerticalAlignment != ST_VerticalAlignmentUnset {
		_ebbbc = append(_ebbbc, "ST_VerticalAlignment")
	}
	if _aaaca.ST_ChildDirection != ST_ChildDirectionUnset {
		_ebbbc = append(_ebbbc, "ST_ChildDirection")
	}
	if _aaaca.ST_ChildAlignment != ST_ChildAlignmentUnset {
		_ebbbc = append(_ebbbc, "ST_ChildAlignment")
	}
	if _aaaca.ST_SecondaryChildAlignment != ST_SecondaryChildAlignmentUnset {
		_ebbbc = append(_ebbbc, "ST_SecondaryChildAlignment")
	}
	if _aaaca.ST_LinearDirection != ST_LinearDirectionUnset {
		_ebbbc = append(_ebbbc, "ST_LinearDirection")
	}
	if _aaaca.ST_SecondaryLinearDirection != ST_SecondaryLinearDirectionUnset {
		_ebbbc = append(_ebbbc, "ST_SecondaryLinearDirection")
	}
	if _aaaca.ST_StartingElement != ST_StartingElementUnset {
		_ebbbc = append(_ebbbc, "ST_StartingElement")
	}
	if _aaaca.ST_BendPoint != ST_BendPointUnset {
		_ebbbc = append(_ebbbc, "ST_BendPoint")
	}
	if _aaaca.ST_ConnectorRouting != ST_ConnectorRoutingUnset {
		_ebbbc = append(_ebbbc, "ST_ConnectorRouting")
	}
	if _aaaca.ST_ArrowheadStyle != ST_ArrowheadStyleUnset {
		_ebbbc = append(_ebbbc, "ST_ArrowheadStyle")
	}
	if _aaaca.ST_ConnectorDimension != ST_ConnectorDimensionUnset {
		_ebbbc = append(_ebbbc, "ST_ConnectorDimension")
	}
	if _aaaca.ST_RotationPath != ST_RotationPathUnset {
		_ebbbc = append(_ebbbc, "ST_RotationPath")
	}
	if _aaaca.ST_CenterShapeMapping != ST_CenterShapeMappingUnset {
		_ebbbc = append(_ebbbc, "ST_CenterShapeMapping")
	}
	if _aaaca.ST_NodeHorizontalAlignment != ST_NodeHorizontalAlignmentUnset {
		_ebbbc = append(_ebbbc, "ST_NodeHorizontalAlignment")
	}
	if _aaaca.ST_NodeVerticalAlignment != ST_NodeVerticalAlignmentUnset {
		_ebbbc = append(_ebbbc, "ST_NodeVerticalAlignment")
	}
	if _aaaca.ST_FallbackDimension != ST_FallbackDimensionUnset {
		_ebbbc = append(_ebbbc, "ST_FallbackDimension")
	}
	if _aaaca.ST_TextDirection != ST_TextDirectionUnset {
		_ebbbc = append(_ebbbc, "ST_TextDirection")
	}
	if _aaaca.ST_PyramidAccentPosition != ST_PyramidAccentPositionUnset {
		_ebbbc = append(_ebbbc, "ST_PyramidAccentPosition")
	}
	if _aaaca.ST_PyramidAccentTextMargin != ST_PyramidAccentTextMarginUnset {
		_ebbbc = append(_ebbbc, "ST_PyramidAccentTextMargin")
	}
	if _aaaca.ST_TextBlockDirection != ST_TextBlockDirectionUnset {
		_ebbbc = append(_ebbbc, "ST_TextBlockDirection")
	}
	if _aaaca.ST_TextAnchorHorizontal != ST_TextAnchorHorizontalUnset {
		_ebbbc = append(_ebbbc, "ST_TextAnchorHorizontal")
	}
	if _aaaca.ST_TextAnchorVertical != ST_TextAnchorVerticalUnset {
		_ebbbc = append(_ebbbc, "ST_TextAnchorVertical")
	}
	if _aaaca.ST_DiagramTextAlignment != ST_DiagramTextAlignmentUnset {
		_ebbbc = append(_ebbbc, "ST_DiagramTextAlignment")
	}
	if _aaaca.ST_AutoTextRotation != ST_AutoTextRotationUnset {
		_ebbbc = append(_ebbbc, "ST_AutoTextRotation")
	}
	if _aaaca.ST_GrowDirection != ST_GrowDirectionUnset {
		_ebbbc = append(_ebbbc, "ST_GrowDirection")
	}
	if _aaaca.ST_FlowDirection != ST_FlowDirectionUnset {
		_ebbbc = append(_ebbbc, "ST_FlowDirection")
	}
	if _aaaca.ST_ContinueDirection != ST_ContinueDirectionUnset {
		_ebbbc = append(_ebbbc, "ST_ContinueDirection")
	}
	if _aaaca.ST_Breakpoint != ST_BreakpointUnset {
		_ebbbc = append(_ebbbc, "ST_Breakpoint")
	}
	if _aaaca.ST_Offset != ST_OffsetUnset {
		_ebbbc = append(_ebbbc, "ST_Offset")
	}
	if _aaaca.ST_HierarchyAlignment != ST_HierarchyAlignmentUnset {
		_ebbbc = append(_ebbbc, "ST_HierarchyAlignment")
	}
	if _aaaca.Int32 != nil {
		_ebbbc = append(_ebbbc, "Int32")
	}
	if _aaaca.Float64 != nil {
		_ebbbc = append(_ebbbc, "Float64")
	}
	if _aaaca.Bool != nil {
		_ebbbc = append(_ebbbc, "Bool")
	}
	if _aaaca.StringVal != nil {
		_ebbbc = append(_ebbbc, "StringVal")
	}
	if _aaaca.ST_ConnectorPoint != ST_ConnectorPointUnset {
		_ebbbc = append(_ebbbc, "ST_ConnectorPoint")
	}
	if len(_ebbbc) > 1 {
		return _a.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _ebbbc)
	}
	return nil
}
func (_cegbc ST_NodeVerticalAlignment) String() string {
	switch _cegbc {
	case 0:
		return ""
	case 1:
		return "t"
	case 2:
		return "mid"
	case 3:
		return "b"
	}
	return ""
}
func (_gddcab ST_RotationPath) String() string {
	switch _gddcab {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "alongPath"
	}
	return ""
}
func (_afad *ST_TextAnchorHorizontal) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dfbg, _afee := d.Token()
	if _afee != nil {
		return _afee
	}
	if _cccaa, _eedbd := _dfbg.(_b.EndElement); _eedbd && _cccaa.Name == start.Name {
		*_afad = 1
		return nil
	}
	if _bgcab, _efaffc := _dfbg.(_b.CharData); !_efaffc {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dfbg)
	} else {
		switch string(_bgcab) {
		case "":
			*_afad = 0
		case "none":
			*_afad = 1
		case "ctr":
			*_afad = 2
		}
	}
	_dfbg, _afee = d.Token()
	if _afee != nil {
		return _afee
	}
	if _bagg, _affcc := _dfbg.(_b.EndElement); _affcc && _bagg.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dfbg)
}
func (_gcadc *ST_AnimLvlStr) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bgfef, _dcae := d.Token()
	if _dcae != nil {
		return _dcae
	}
	if _fcdcf, _caggg := _bgfef.(_b.EndElement); _caggg && _fcdcf.Name == start.Name {
		*_gcadc = 1
		return nil
	}
	if _bdcf, _acgc := _bgfef.(_b.CharData); !_acgc {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bgfef)
	} else {
		switch string(_bdcf) {
		case "":
			*_gcadc = 0
		case "none":
			*_gcadc = 1
		case "lvl":
			*_gcadc = 2
		case "ctr":
			*_gcadc = 3
		}
	}
	_bgfef, _dcae = d.Token()
	if _dcae != nil {
		return _dcae
	}
	if _afbf, _cefg := _bgfef.(_b.EndElement); _cefg && _afbf.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bgfef)
}
func (_dbafg ST_HierBranchStyle) ValidateWithPath(path string) error {
	switch _dbafg {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dbafg))
	}
	return nil
}
func (_ggdd ST_NodeVerticalAlignment) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_ggdd.String(), start)
}

type ST_CenterShapeMapping byte

func NewCT_Parameter() *CT_Parameter {
	_eeae := &CT_Parameter{}
	_eeae.TypeAttr = ST_ParameterId(1)
	return _eeae
}
func NewCT_OrgChart() *CT_OrgChart { _bedc := &CT_OrgChart{}; return _bedc }
func (_dfega *ST_ChildOrderType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dfega = 0
	case "b":
		*_dfega = 1
	case "t":
		*_dfega = 2
	}
	return nil
}
func (_aedd *CT_SDDescription) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _aedd.LangAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "lang"}, Value: _a.Sprintf("\u0025v", *_aedd.LangAttr)})
	}
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", _aedd.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type CT_OrgChart struct{ ValAttr *bool }

func (_cbb *CT_Colors) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _baaa := range start.Attr {
		if _baaa.Name.Local == "meth" {
			_cbb.MethAttr.UnmarshalXMLAttr(_baaa)
			continue
		}
		if _baaa.Name.Local == "hueDir" {
			_cbb.HueDirAttr.UnmarshalXMLAttr(_baaa)
			continue
		}
	}
_faga:
	for {
		_ggbf, _ddf := d.Token()
		if _ddf != nil {
			return _ddf
		}
		switch _cbefa := _ggbf.(type) {
		case _b.StartElement:
			switch _cbefa.Name {
			default:
				_ea.Log("skipping\u0020unsupported\u0020element on CT_Colors \u0025v", _cbefa.Name)
				if _gbbc := d.Skip(); _gbbc != nil {
					return _gbbc
				}
			}
		case _b.EndElement:
			break _faga
		case _b.CharData:
		}
	}
	return nil
}

// Validate validates the CT_ColorTransform and its children
func (_cbddd *CT_ColorTransform) Validate() error {
	return _cbddd.ValidateWithPath("CT_ColorTransform")
}
func (_fbd *CT_Algorithm) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	_fad, _fagd := _fbd.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
	if _fagd != nil {
		return _fagd
	}
	start.Attr = append(start.Attr, _fad)
	if _fbd.RevAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "rev"}, Value: _a.Sprintf("\u0025v", *_fbd.RevAttr)})
	}
	e.EncodeToken(start)
	if _fbd.Param != nil {
		_fdcf := _b.StartElement{Name: _b.Name{Local: "param"}}
		for _, _cbdd := range _fbd.Param {
			e.EncodeElement(_cbdd, _fdcf)
		}
	}
	if _fbd.ExtLst != nil {
		_gab := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_fbd.ExtLst, _gab)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_ColorTransformHeader and its children
func (_dbgb *CT_ColorTransformHeader) Validate() error {
	return _dbgb.ValidateWithPath("CT_ColorTransformHeader")
}
func (_agbad *ST_DiagramHorizontalAlignment) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cafag, _afgb := d.Token()
	if _afgb != nil {
		return _afgb
	}
	if _fgfd, _gafbfc := _cafag.(_b.EndElement); _gafbfc && _fgfd.Name == start.Name {
		*_agbad = 1
		return nil
	}
	if _bccgab, _facae := _cafag.(_b.CharData); !_facae {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cafag)
	} else {
		switch string(_bccgab) {
		case "":
			*_agbad = 0
		case "l":
			*_agbad = 1
		case "ctr":
			*_agbad = 2
		case "r":
			*_agbad = 3
		case "none":
			*_agbad = 4
		}
	}
	_cafag, _afgb = d.Token()
	if _afgb != nil {
		return _afgb
	}
	if _agfea, _deac := _cafag.(_b.EndElement); _deac && _agfea.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cafag)
}
func (_gdaf ST_PyramidAccentTextMargin) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_gdaf.String(), start)
}

// ValidateWithPath validates the RelIds and its children, prefixing error messages with path
func (_abfcb *RelIds) ValidateWithPath(path string) error {
	if _aabea := _abfcb.CT_RelIds.ValidateWithPath(path); _aabea != nil {
		return _aabea
	}
	return nil
}
func (_fgg *CT_AnimOne) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dc := range start.Attr {
		if _dc.Name.Local == "val" {
			_fgg.ValAttr.UnmarshalXMLAttr(_dc)
			continue
		}
	}
	for {
		_cdbc, _egbc := d.Token()
		if _egbc != nil {
			return _a.Errorf("parsing\u0020CT_AnimOne:\u0020%s", _egbc)
		}
		if _gf, _eea := _cdbc.(_b.EndElement); _eea && _gf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cabf *CT_CTName) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _cabf.LangAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "lang"}, Value: _a.Sprintf("\u0025v", *_cabf.LangAttr)})
	}
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", _cabf.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_ageg *ST_PtType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_ageg = 0
	case "node":
		*_ageg = 1
	case "asst":
		*_ageg = 2
	case "doc":
		*_ageg = 3
	case "pres":
		*_ageg = 4
	case "parTrans":
		*_ageg = 5
	case "sibTrans":
		*_ageg = 6
	}
	return nil
}
func (_cccde ST_HueDir) Validate() error { return _cccde.ValidateWithPath("") }
func (_gdadc *ColorsDef) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gdadc.CT_ColorTransform = *NewCT_ColorTransform()
	for _, _aeccf := range start.Attr {
		if _aeccf.Name.Local == "uniqueId" {
			_cddf, _befd := _aeccf.Value, error(nil)
			if _befd != nil {
				return _befd
			}
			_gdadc.UniqueIdAttr = &_cddf
			continue
		}
		if _aeccf.Name.Local == "minVer" {
			_aaff, _ecce := _aeccf.Value, error(nil)
			if _ecce != nil {
				return _ecce
			}
			_gdadc.MinVerAttr = &_aaff
			continue
		}
	}
_efea:
	for {
		_gafgg, _afdb := d.Token()
		if _afdb != nil {
			return _afdb
		}
		switch _ddcd := _gafgg.(type) {
		case _b.StartElement:
			switch _ddcd.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_fefce := NewCT_CTName()
				if _afga := d.DecodeElement(_fefce, &_ddcd); _afga != nil {
					return _afga
				}
				_gdadc.Title = append(_gdadc.Title, _fefce)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_faecb := NewCT_CTDescription()
				if _eeggb := d.DecodeElement(_faecb, &_ddcd); _eeggb != nil {
					return _eeggb
				}
				_gdadc.Desc = append(_gdadc.Desc, _faecb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_gdadc.CatLst = NewCT_CTCategories()
				if _bdgad := d.DecodeElement(_gdadc.CatLst, &_ddcd); _bdgad != nil {
					return _bdgad
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "styleLbl"}:
				_fgccc := NewCT_CTStyleLabel()
				if _ecca := d.DecodeElement(_fgccc, &_ddcd); _ecca != nil {
					return _ecca
				}
				_gdadc.StyleLbl = append(_gdadc.StyleLbl, _fgccc)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_gdadc.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _dfbd := d.DecodeElement(_gdadc.ExtLst, &_ddcd); _dfbd != nil {
					return _dfbd
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element on ColorsDef \u0025v", _ddcd.Name)
				if _ecea := d.Skip(); _ecea != nil {
					return _ecea
				}
			}
		case _b.EndElement:
			break _efea
		case _b.CharData:
		}
	}
	return nil
}
func (_cdee ST_ClrAppMethod) String() string {
	switch _cdee {
	case 0:
		return ""
	case 1:
		return "span"
	case 2:
		return "cycle"
	case 3:
		return "repeat"
	}
	return ""
}
func ParseUnionST_LayoutShapeType(s string) (ST_LayoutShapeType, error) {
	return ST_LayoutShapeType{}, nil
}
func (_egcgc ST_AnimLvlStr) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bcgfd := _b.Attr{}
	_bcgfd.Name = name
	switch _egcgc {
	case ST_AnimLvlStrUnset:
		_bcgfd.Value = ""
	case ST_AnimLvlStrNone:
		_bcgfd.Value = "none"
	case ST_AnimLvlStrLvl:
		_bcgfd.Value = "lvl"
	case ST_AnimLvlStrCtr:
		_bcgfd.Value = "ctr"
	}
	return _bcgfd, nil
}
func (_dffe *CT_Algorithm) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dffe.TypeAttr = ST_AlgorithmType(1)
	for _, _cbdc := range start.Attr {
		if _cbdc.Name.Local == "type" {
			_dffe.TypeAttr.UnmarshalXMLAttr(_cbdc)
			continue
		}
		if _cbdc.Name.Local == "rev" {
			_baac, _fc := _d.ParseUint(_cbdc.Value, 10, 32)
			if _fc != nil {
				return _fc
			}
			_bgg := uint32(_baac)
			_dffe.RevAttr = &_bgg
			continue
		}
	}
_cda:
	for {
		_cebd, _edf := d.Token()
		if _edf != nil {
			return _edf
		}
		switch _ege := _cebd.(type) {
		case _b.StartElement:
			switch _ege.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "param"}:
				_gbfb := NewCT_Parameter()
				if _gac := d.DecodeElement(_gbfb, &_ege); _gac != nil {
					return _gac
				}
				_dffe.Param = append(_dffe.Param, _gbfb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_dffe.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _fgc := d.DecodeElement(_dffe.ExtLst, &_ege); _fgc != nil {
					return _fgc
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Algorithm\u0020\u0025v", _ege.Name)
				if _dfc := d.Skip(); _dfc != nil {
					return _dfc
				}
			}
		case _b.EndElement:
			break _cda
		case _b.CharData:
		}
	}
	return nil
}
func (_gcfc ST_SecondaryLinearDirection) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bafe := _b.Attr{}
	_bafe.Name = name
	switch _gcfc {
	case ST_SecondaryLinearDirectionUnset:
		_bafe.Value = ""
	case ST_SecondaryLinearDirectionNone:
		_bafe.Value = "none"
	case ST_SecondaryLinearDirectionFromL:
		_bafe.Value = "fromL"
	case ST_SecondaryLinearDirectionFromR:
		_bafe.Value = "fromR"
	case ST_SecondaryLinearDirectionFromT:
		_bafe.Value = "fromT"
	case ST_SecondaryLinearDirectionFromB:
		_bafe.Value = "fromB"
	}
	return _bafe, nil
}
func (_bgabg ST_ChildAlignment) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bgabg.String(), start)
}
func (_fffff *ST_FallbackDimension) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fffff = 0
	case "1D":
		*_fffff = 1
	case "2D":
		*_fffff = 2
	}
	return nil
}

type ST_NodeHorizontalAlignment byte

func (_dfge ST_FunctionOperator) Validate() error { return _dfge.ValidateWithPath("") }
func (_ddcdg *ST_AlgorithmType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bgbd, _abdce := d.Token()
	if _abdce != nil {
		return _abdce
	}
	if _dgfb, _gaff := _bgbd.(_b.EndElement); _gaff && _dgfb.Name == start.Name {
		*_ddcdg = 1
		return nil
	}
	if _aaaf, _bdbf := _bgbd.(_b.CharData); !_bdbf {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bgbd)
	} else {
		switch string(_aaaf) {
		case "":
			*_ddcdg = 0
		case "composite":
			*_ddcdg = 1
		case "conn":
			*_ddcdg = 2
		case "cycle":
			*_ddcdg = 3
		case "hierChild":
			*_ddcdg = 4
		case "hierRoot":
			*_ddcdg = 5
		case "pyra":
			*_ddcdg = 6
		case "lin":
			*_ddcdg = 7
		case "sp":
			*_ddcdg = 8
		case "tx":
			*_ddcdg = 9
		case "snake":
			*_ddcdg = 10
		}
	}
	_bgbd, _abdce = d.Token()
	if _abdce != nil {
		return _abdce
	}
	if _edcb, _bgag := _bgbd.(_b.EndElement); _bgag && _edcb.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bgbd)
}
func (_gadag *ST_DiagramTextAlignment) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bagb, _fbfe := d.Token()
	if _fbfe != nil {
		return _fbfe
	}
	if _acdb, _befc := _bagb.(_b.EndElement); _befc && _acdb.Name == start.Name {
		*_gadag = 1
		return nil
	}
	if _cfcdg, _ebfa := _bagb.(_b.CharData); !_ebfa {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bagb)
	} else {
		switch string(_cfcdg) {
		case "":
			*_gadag = 0
		case "l":
			*_gadag = 1
		case "ctr":
			*_gadag = 2
		case "r":
			*_gadag = 3
		}
	}
	_bagb, _fbfe = d.Token()
	if _fbfe != nil {
		return _fbfe
	}
	if _gdaea, _ffag := _bagb.(_b.EndElement); _ffag && _gdaea.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bagb)
}

// Validate validates the CT_SDName and its children
func (_dfae *CT_SDName) Validate() error { return _dfae.ValidateWithPath("CT_SDName") }
func (_dabd *CT_Shape) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _dabd.RotAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "rot"}, Value: _a.Sprintf("\u0025v", *_dabd.RotAttr)})
	}
	if _dabd.TypeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "type"}, Value: _a.Sprintf("\u0025v", *_dabd.TypeAttr)})
	}
	if _dabd.BlipAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:blip"}, Value: _a.Sprintf("\u0025v", *_dabd.BlipAttr)})
	}
	if _dabd.ZOrderOffAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "zOrderOff"}, Value: _a.Sprintf("\u0025v", *_dabd.ZOrderOffAttr)})
	}
	if _dabd.HideGeomAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "hideGeom"}, Value: _a.Sprintf("\u0025d", _eecbc(*_dabd.HideGeomAttr))})
	}
	if _dabd.LkTxEntryAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "lkTxEntry"}, Value: _a.Sprintf("\u0025d", _eecbc(*_dabd.LkTxEntryAttr))})
	}
	if _dabd.BlipPhldrAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "blipPhldr"}, Value: _a.Sprintf("\u0025d", _eecbc(*_dabd.BlipPhldrAttr))})
	}
	e.EncodeToken(start)
	if _dabd.AdjLst != nil {
		_dged := _b.StartElement{Name: _b.Name{Local: "adjLst"}}
		e.EncodeElement(_dabd.AdjLst, _dged)
	}
	if _dabd.ExtLst != nil {
		_abdcce := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_dabd.ExtLst, _abdcce)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type ST_ConstraintType byte
type ST_Direction byte

func (_fbabd *ST_TextBlockDirection) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fefgb, _dcbga := d.Token()
	if _dcbga != nil {
		return _dcbga
	}
	if _bgac, _egffa := _fefgb.(_b.EndElement); _egffa && _bgac.Name == start.Name {
		*_fbabd = 1
		return nil
	}
	if _dcdad, _ebaa := _fefgb.(_b.CharData); !_ebaa {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fefgb)
	} else {
		switch string(_dcdad) {
		case "":
			*_fbabd = 0
		case "horz":
			*_fbabd = 1
		case "vert":
			*_fbabd = 2
		}
	}
	_fefgb, _dcbga = d.Token()
	if _dcbga != nil {
		return _dcbga
	}
	if _febec, _eeaf := _fefgb.(_b.EndElement); _eeaf && _febec.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fefgb)
}
func (_egca ST_TextAnchorHorizontal) Validate() error { return _egca.ValidateWithPath("") }
func (_bgbc ST_ElementType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bgbc.String(), start)
}
func (_cdfeg ST_HierarchyAlignment) ValidateWithPath(path string) error {
	switch _cdfeg {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cdfeg))
	}
	return nil
}
func (_ffee ST_TextAnchorHorizontal) String() string {
	switch _ffee {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "ctr"
	}
	return ""
}

type CT_Categories struct{ Cat []*CT_Category }

func (_cbec *ST_ClrAppMethod) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bbaae, _fccgc := d.Token()
	if _fccgc != nil {
		return _fccgc
	}
	if _decad, _edbad := _bbaae.(_b.EndElement); _edbad && _decad.Name == start.Name {
		*_cbec = 1
		return nil
	}
	if _dgga, _gbec := _bbaae.(_b.CharData); !_gbec {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bbaae)
	} else {
		switch string(_dgga) {
		case "":
			*_cbec = 0
		case "span":
			*_cbec = 1
		case "cycle":
			*_cbec = 2
		case "repeat":
			*_cbec = 3
		}
	}
	_bbaae, _fccgc = d.Token()
	if _fccgc != nil {
		return _fccgc
	}
	if _ddegb, _afea := _bbaae.(_b.EndElement); _afea && _ddegb.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bbaae)
}
func (_dcbdd ST_StartingElement) Validate() error { return _dcbdd.ValidateWithPath("") }
func (_ebee ST_ParameterId) ValidateWithPath(path string) error {
	switch _ebee {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ebee))
	}
	return nil
}
func (_acabg *ST_HierarchyAlignment) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_acabg = 0
	case "tL":
		*_acabg = 1
	case "tR":
		*_acabg = 2
	case "tCtrCh":
		*_acabg = 3
	case "tCtrDes":
		*_acabg = 4
	case "bL":
		*_acabg = 5
	case "bR":
		*_acabg = 6
	case "bCtrCh":
		*_acabg = 7
	case "bCtrDes":
		*_acabg = 8
	case "lT":
		*_acabg = 9
	case "lB":
		*_acabg = 10
	case "lCtrCh":
		*_acabg = 11
	case "lCtrDes":
		*_acabg = 12
	case "rT":
		*_acabg = 13
	case "rB":
		*_acabg = 14
	case "rCtrCh":
		*_acabg = 15
	case "rCtrDes":
		*_acabg = 16
	}
	return nil
}
func (_feeec ST_AxisType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gcdg := _b.Attr{}
	_gcdg.Name = name
	switch _feeec {
	case ST_AxisTypeUnset:
		_gcdg.Value = ""
	case ST_AxisTypeSelf:
		_gcdg.Value = "self"
	case ST_AxisTypeCh:
		_gcdg.Value = "ch"
	case ST_AxisTypeDes:
		_gcdg.Value = "des"
	case ST_AxisTypeDesOrSelf:
		_gcdg.Value = "desOrSelf"
	case ST_AxisTypePar:
		_gcdg.Value = "par"
	case ST_AxisTypeAncst:
		_gcdg.Value = "ancst"
	case ST_AxisTypeAncstOrSelf:
		_gcdg.Value = "ancstOrSelf"
	case ST_AxisTypeFollowSib:
		_gcdg.Value = "followSib"
	case ST_AxisTypePrecedSib:
		_gcdg.Value = "precedSib"
	case ST_AxisTypeFollow:
		_gcdg.Value = "follow"
	case ST_AxisTypePreced:
		_gcdg.Value = "preced"
	case ST_AxisTypeRoot:
		_gcdg.Value = "root"
	case ST_AxisTypeNone:
		_gcdg.Value = "none"
	}
	return _gcdg, nil
}
func NewCT_Choose() *CT_Choose { _deb := &CT_Choose{}; return _deb }

// ValidateWithPath validates the CT_StyleDefinitionHeaderLst and its children, prefixing error messages with path
func (_faca *CT_StyleDefinitionHeaderLst) ValidateWithPath(path string) error {
	for _beaeg, _cgdbe := range _faca.StyleDefHdr {
		if _cbba := _cgdbe.ValidateWithPath(_a.Sprintf("\u0025s\u002fStyleDefHdr\u005b\u0025d\u005d", path, _beaeg)); _cbba != nil {
			return _cbba
		}
	}
	return nil
}
func (_gfbb ST_AlgorithmType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_gfbb.String(), start)
}
func (_gfeb ST_OutputShapeType) Validate() error { return _gfeb.ValidateWithPath("") }

const (
	ST_ContinueDirectionUnset   ST_ContinueDirection = 0
	ST_ContinueDirectionRevDir  ST_ContinueDirection = 1
	ST_ContinueDirectionSameDir ST_ContinueDirection = 2
)

func (_ffdcg ST_AlgorithmType) String() string {
	switch _ffdcg {
	case 0:
		return ""
	case 1:
		return "composite"
	case 2:
		return "conn"
	case 3:
		return "cycle"
	case 4:
		return "hierChild"
	case 5:
		return "hierRoot"
	case 6:
		return "pyra"
	case 7:
		return "lin"
	case 8:
		return "sp"
	case 9:
		return "tx"
	case 10:
		return "snake"
	}
	return ""
}
func (_beag *DataModel) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_beag.CT_DataModel = *NewCT_DataModel()
_adbae:
	for {
		_acdcb, _ddedg := d.Token()
		if _ddedg != nil {
			return _ddedg
		}
		switch _fgced := _acdcb.(type) {
		case _b.StartElement:
			switch _fgced.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "ptLst"}:
				if _gacd := d.DecodeElement(_beag.PtLst, &_fgced); _gacd != nil {
					return _gacd
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "cxnLst"}:
				_beag.CxnLst = NewCT_CxnList()
				if _dccba := d.DecodeElement(_beag.CxnLst, &_fgced); _dccba != nil {
					return _dccba
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "bg"}:
				_beag.Bg = _f.NewCT_BackgroundFormatting()
				if _fdce := d.DecodeElement(_beag.Bg, &_fgced); _fdce != nil {
					return _fdce
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "whole"}:
				_beag.Whole = _f.NewCT_WholeE2oFormatting()
				if _agede := d.DecodeElement(_beag.Whole, &_fgced); _agede != nil {
					return _agede
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_beag.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _fedf := d.DecodeElement(_beag.ExtLst, &_fgced); _fedf != nil {
					return _fedf
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element on DataModel \u0025v", _fgced.Name)
				if _ggfd := d.Skip(); _ggfd != nil {
					return _ggfd
				}
			}
		case _b.EndElement:
			break _adbae
		case _b.CharData:
		}
	}
	return nil
}

type StyleDefHdr struct{ CT_StyleDefinitionHeader }

func (_adcbc *ST_GrowDirection) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_adcbc = 0
	case "tL":
		*_adcbc = 1
	case "tR":
		*_adcbc = 2
	case "bL":
		*_adcbc = 3
	case "bR":
		*_adcbc = 4
	}
	return nil
}
func (_eagg *ST_RotationPath) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ccgbdd, _facad := d.Token()
	if _facad != nil {
		return _facad
	}
	if _dcbc, _gaec := _ccgbdd.(_b.EndElement); _gaec && _dcbc.Name == start.Name {
		*_eagg = 1
		return nil
	}
	if _adbb, _gcce := _ccgbdd.(_b.CharData); !_gcce {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ccgbdd)
	} else {
		switch string(_adbb) {
		case "":
			*_eagg = 0
		case "none":
			*_eagg = 1
		case "alongPath":
			*_eagg = 2
		}
	}
	_ccgbdd, _facad = d.Token()
	if _facad != nil {
		return _facad
	}
	if _bged, _abbc := _ccgbdd.(_b.EndElement); _abbc && _bged.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ccgbdd)
}
func (_deef ST_ConstraintRelationship) ValidateWithPath(path string) error {
	switch _deef {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_deef))
	}
	return nil
}

type CT_Shape struct {
	RotAttr       *float64
	TypeAttr      *ST_LayoutShapeType
	BlipAttr      *string
	ZOrderOffAttr *int32
	HideGeomAttr  *bool
	LkTxEntryAttr *bool
	BlipPhldrAttr *bool
	AdjLst        *CT_AdjLst
	ExtLst        *_f.CT_OfficeArtExtensionList
}

// ValidateWithPath validates the CT_SDCategories and its children, prefixing error messages with path
func (_agea *CT_SDCategories) ValidateWithPath(path string) error {
	for _fadf, _aefcf := range _agea.Cat {
		if _abefe := _aefcf.ValidateWithPath(_a.Sprintf("\u0025s\u002fCat\u005b\u0025d\u005d", path, _fadf)); _abefe != nil {
			return _abefe
		}
	}
	return nil
}

const (
	ST_TextDirectionUnset ST_TextDirection = 0
	ST_TextDirectionFromT ST_TextDirection = 1
	ST_TextDirectionFromB ST_TextDirection = 2
)
const (
	ST_AlgorithmTypeUnset     ST_AlgorithmType = 0
	ST_AlgorithmTypeComposite ST_AlgorithmType = 1
	ST_AlgorithmTypeConn      ST_AlgorithmType = 2
	ST_AlgorithmTypeCycle     ST_AlgorithmType = 3
	ST_AlgorithmTypeHierChild ST_AlgorithmType = 4
	ST_AlgorithmTypeHierRoot  ST_AlgorithmType = 5
	ST_AlgorithmTypePyra      ST_AlgorithmType = 6
	ST_AlgorithmTypeLin       ST_AlgorithmType = 7
	ST_AlgorithmTypeSp        ST_AlgorithmType = 8
	ST_AlgorithmTypeTx        ST_AlgorithmType = 9
	ST_AlgorithmTypeSnake     ST_AlgorithmType = 10
)

func (_bfdfd ST_BendPoint) String() string {
	switch _bfdfd {
	case 0:
		return ""
	case 1:
		return "beg"
	case 2:
		return "def"
	case 3:
		return "end"
	}
	return ""
}

// ValidateWithPath validates the CT_ForEach and its children, prefixing error messages with path
func (_beab *CT_ForEach) ValidateWithPath(path string) error {
	for _aee, _fagdg := range _beab.Alg {
		if _abdd := _fagdg.ValidateWithPath(_a.Sprintf("\u0025s\u002fAlg\u005b\u0025d\u005d", path, _aee)); _abdd != nil {
			return _abdd
		}
	}
	for _bfe, _fefc := range _beab.Shape {
		if _gbga := _fefc.ValidateWithPath(_a.Sprintf("\u0025s\u002fShape\u005b\u0025d\u005d", path, _bfe)); _gbga != nil {
			return _gbga
		}
	}
	for _fecg, _bddf := range _beab.PresOf {
		if _abge := _bddf.ValidateWithPath(_a.Sprintf("\u0025s\u002fPresOf\u005b\u0025d\u005d", path, _fecg)); _abge != nil {
			return _abge
		}
	}
	for _cdbe, _bfeg := range _beab.ConstrLst {
		if _fbcg := _bfeg.ValidateWithPath(_a.Sprintf("\u0025s/ConstrLst\u005b\u0025d\u005d", path, _cdbe)); _fbcg != nil {
			return _fbcg
		}
	}
	for _ccee, _bfgcg := range _beab.RuleLst {
		if _ecec := _bfgcg.ValidateWithPath(_a.Sprintf("\u0025s\u002fRuleLst\u005b\u0025d\u005d", path, _ccee)); _ecec != nil {
			return _ecec
		}
	}
	for _acebe, _ecga := range _beab.ForEach {
		if _fecc := _ecga.ValidateWithPath(_a.Sprintf("\u0025s\u002fForEach\u005b\u0025d\u005d", path, _acebe)); _fecc != nil {
			return _fecc
		}
	}
	for _bcge, _dgcec := range _beab.LayoutNode {
		if _bfbb := _dgcec.ValidateWithPath(_a.Sprintf("\u0025s\u002fLayoutNode\u005b\u0025d\u005d", path, _bcge)); _bfbb != nil {
			return _bfbb
		}
	}
	for _cbcf, _gbgg := range _beab.Choose {
		if _cdfe := _gbgg.ValidateWithPath(_a.Sprintf("\u0025s\u002fChoose\u005b\u0025d\u005d", path, _cbcf)); _cdfe != nil {
			return _cdfe
		}
	}
	for _abea, _dbbc := range _beab.ExtLst {
		if _ccgg := _dbbc.ValidateWithPath(_a.Sprintf("\u0025s\u002fExtLst\u005b\u0025d\u005d", path, _abea)); _ccgg != nil {
			return _ccgg
		}
	}
	return nil
}

type RelIds struct{ CT_RelIds }

func (_gfefb *ST_VerticalAlignment) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_gfefb = 0
	case "t":
		*_gfefb = 1
	case "mid":
		*_gfefb = 2
	case "b":
		*_gfefb = 3
	case "none":
		*_gfefb = 4
	}
	return nil
}
func (_geaca ST_ConnectorDimension) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_cggdb := _b.Attr{}
	_cggdb.Name = name
	switch _geaca {
	case ST_ConnectorDimensionUnset:
		_cggdb.Value = ""
	case ST_ConnectorDimension1D:
		_cggdb.Value = "1D"
	case ST_ConnectorDimension2D:
		_cggdb.Value = "2D"
	case ST_ConnectorDimensionCust:
		_cggdb.Value = "cust"
	}
	return _cggdb, nil
}

type CT_DataModel struct {
	PtLst  *CT_PtList
	CxnLst *CT_CxnList
	Bg     *_f.CT_BackgroundFormatting
	Whole  *_f.CT_WholeE2oFormatting
	ExtLst *_f.CT_OfficeArtExtensionList
}

// Validate validates the CT_Categories and its children
func (_fda *CT_Categories) Validate() error { return _fda.ValidateWithPath("CT_Categories") }
func NewLayoutDefHdr() *LayoutDefHdr {
	_ddeda := &LayoutDefHdr{}
	_ddeda.CT_DiagramDefinitionHeader = *NewCT_DiagramDefinitionHeader()
	return _ddeda
}

type ST_TextAnchorVertical byte

func (_cddfa ST_ClrAppMethod) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_cddfa.String(), start)
}

// Validate validates the ColorsDef and its children
func (_fgdab *ColorsDef) Validate() error { return _fgdab.ValidateWithPath("ColorsDef") }
func (_aafd *CT_Cxn) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "modelId"}, Value: _a.Sprintf("\u0025v", _aafd.ModelIdAttr)})
	if _aafd.TypeAttr != ST_CxnTypeUnset {
		_efcb, _fafd := _aafd.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _fafd != nil {
			return _fafd
		}
		start.Attr = append(start.Attr, _efcb)
	}
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "srcId"}, Value: _a.Sprintf("\u0025v", _aafd.SrcIdAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "destId"}, Value: _a.Sprintf("\u0025v", _aafd.DestIdAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "srcOrd"}, Value: _a.Sprintf("\u0025v", _aafd.SrcOrdAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "destOrd"}, Value: _a.Sprintf("\u0025v", _aafd.DestOrdAttr)})
	if _aafd.ParTransIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "parTransId"}, Value: _a.Sprintf("\u0025v", *_aafd.ParTransIdAttr)})
	}
	if _aafd.SibTransIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "sibTransId"}, Value: _a.Sprintf("\u0025v", *_aafd.SibTransIdAttr)})
	}
	if _aafd.PresIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "presId"}, Value: _a.Sprintf("\u0025v", *_aafd.PresIdAttr)})
	}
	e.EncodeToken(start)
	if _aafd.ExtLst != nil {
		_gecc := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_aafd.ExtLst, _gecc)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_cccf ST_NodeVerticalAlignment) ValidateWithPath(path string) error {
	switch _cccf {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cccf))
	}
	return nil
}
func (_bac *CT_BulletEnabled) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _gea := range start.Attr {
		if _gea.Name.Local == "val" {
			_geef, _cdfa := _d.ParseBool(_gea.Value)
			if _cdfa != nil {
				return _cdfa
			}
			_bac.ValAttr = &_geef
			continue
		}
	}
	for {
		_dda, _aff := d.Token()
		if _aff != nil {
			return _a.Errorf("parsing\u0020CT_BulletEnabled: \u0025s", _aff)
		}
		if _dffa, _bff := _dda.(_b.EndElement); _bff && _dffa.Name == start.Name {
			break
		}
	}
	return nil
}
func (_effd *CT_StyleDefinitionHeaderLst) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_adce:
	for {
		_dcde, _ffce := d.Token()
		if _ffce != nil {
			return _ffce
		}
		switch _begb := _dcde.(type) {
		case _b.StartElement:
			switch _begb.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "styleDefHdr"}:
				_bdecd := NewCT_StyleDefinitionHeader()
				if _agcge := d.DecodeElement(_bdecd, &_begb); _agcge != nil {
					return _agcge
				}
				_effd.StyleDefHdr = append(_effd.StyleDefHdr, _bdecd)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_StyleDefinitionHeaderLst\u0020\u0025v", _begb.Name)
				if _acdag := d.Skip(); _acdag != nil {
					return _acdag
				}
			}
		case _b.EndElement:
			break _adce
		case _b.CharData:
		}
	}
	return nil
}
func (_ebdcf *StyleDefHdrLst) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ebdcf.CT_StyleDefinitionHeaderLst = *NewCT_StyleDefinitionHeaderLst()
_cbaeg:
	for {
		_dgea, _fdgfb := d.Token()
		if _fdgfb != nil {
			return _fdgfb
		}
		switch _cgbba := _dgea.(type) {
		case _b.StartElement:
			switch _cgbba.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "styleDefHdr"}:
				_bceeb := NewCT_StyleDefinitionHeader()
				if _debgc := d.DecodeElement(_bceeb, &_cgbba); _debgc != nil {
					return _debgc
				}
				_ebdcf.StyleDefHdr = append(_ebdcf.StyleDefHdr, _bceeb)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020StyleDefHdrLst\u0020\u0025v", _cgbba.Name)
				if _ebcdg := d.Skip(); _ebcdg != nil {
					return _ebcdg
				}
			}
		case _b.EndElement:
			break _cbaeg
		case _b.CharData:
		}
	}
	return nil
}
func (_gdcde ST_AutoTextRotation) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_gdcde.String(), start)
}

// ST_FunctionArgument is a union type
type ST_FunctionArgument struct{ ST_VariableType ST_VariableType }

func (_dcb *CT_Direction) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _dcb.ValAttr != ST_DirectionUnset {
		_adeb, _addc := _dcb.ValAttr.MarshalXMLAttr(_b.Name{Local: "val"})
		if _addc != nil {
			return _addc
		}
		start.Attr = append(start.Attr, _adeb)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_debae *ST_NodeHorizontalAlignment) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gcea, _bdeec := d.Token()
	if _bdeec != nil {
		return _bdeec
	}
	if _geagg, _fdegf := _gcea.(_b.EndElement); _fdegf && _geagg.Name == start.Name {
		*_debae = 1
		return nil
	}
	if _cfcg, _cecge := _gcea.(_b.CharData); !_cecge {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gcea)
	} else {
		switch string(_cfcg) {
		case "":
			*_debae = 0
		case "l":
			*_debae = 1
		case "ctr":
			*_debae = 2
		case "r":
			*_debae = 3
		}
	}
	_gcea, _bdeec = d.Token()
	if _bdeec != nil {
		return _bdeec
	}
	if _ffgeb, _deeda := _gcea.(_b.EndElement); _deeda && _ffgeb.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gcea)
}
func (_caaff ST_ChildDirection) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_caaff.String(), start)
}

// Validate validates the AG_ConstraintRefAttributes and its children
func (_bf *AG_ConstraintRefAttributes) Validate() error {
	return _bf.ValidateWithPath("AG_ConstraintRefAttributes")
}
func (_dfag ST_Direction) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dfag.String(), start)
}
func (_dbgg ST_AnimLvlStr) ValidateWithPath(path string) error {
	switch _dbgg {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dbgg))
	}
	return nil
}
func (_geafd *CT_NumericRule) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bfegc := range start.Attr {
		if _bfegc.Name.Local == "val" {
			_cegaa, _gcdc := _d.ParseFloat(_bfegc.Value, 64)
			if _gcdc != nil {
				return _gcdc
			}
			_geafd.ValAttr = &_cegaa
			continue
		}
		if _bfegc.Name.Local == "fact" {
			_dcdd, _cabg := _d.ParseFloat(_bfegc.Value, 64)
			if _cabg != nil {
				return _cabg
			}
			_geafd.FactAttr = &_dcdd
			continue
		}
		if _bfegc.Name.Local == "max" {
			_cegd, _cfca := _d.ParseFloat(_bfegc.Value, 64)
			if _cfca != nil {
				return _cfca
			}
			_geafd.MaxAttr = &_cegd
			continue
		}
		if _bfegc.Name.Local == "type" {
			_geafd.TypeAttr.UnmarshalXMLAttr(_bfegc)
			continue
		}
		if _bfegc.Name.Local == "for" {
			_geafd.ForAttr.UnmarshalXMLAttr(_bfegc)
			continue
		}
		if _bfegc.Name.Local == "forName" {
			_fccd, _adbc := _bfegc.Value, error(nil)
			if _adbc != nil {
				return _adbc
			}
			_geafd.ForNameAttr = &_fccd
			continue
		}
		if _bfegc.Name.Local == "ptType" {
			_geafd.PtTypeAttr.UnmarshalXMLAttr(_bfegc)
			continue
		}
	}
_bcfe:
	for {
		_fegbb, _ecda := d.Token()
		if _ecda != nil {
			return _ecda
		}
		switch _agfb := _fegbb.(type) {
		case _b.StartElement:
			switch _agfb.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_geafd.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _eegd := d.DecodeElement(_geafd.ExtLst, &_agfb); _eegd != nil {
					return _eegd
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_NumericRule\u0020\u0025v", _agfb.Name)
				if _bfgf := d.Skip(); _bfgf != nil {
					return _bfgf
				}
			}
		case _b.EndElement:
			break _bcfe
		case _b.CharData:
		}
	}
	return nil
}

// Validate validates the CT_LayoutVariablePropertySet and its children
func (_dbcba *CT_LayoutVariablePropertySet) Validate() error {
	return _dbcba.ValidateWithPath("CT_LayoutVariablePropertySet")
}
func (_aebb *CT_DiagramDefinition) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_aebb.LayoutNode = NewCT_LayoutNode()
	for _, _bcec := range start.Attr {
		if _bcec.Name.Local == "uniqueId" {
			_dgbc, _cbeg := _bcec.Value, error(nil)
			if _cbeg != nil {
				return _cbeg
			}
			_aebb.UniqueIdAttr = &_dgbc
			continue
		}
		if _bcec.Name.Local == "minVer" {
			_bdga, _fdee := _bcec.Value, error(nil)
			if _fdee != nil {
				return _fdee
			}
			_aebb.MinVerAttr = &_bdga
			continue
		}
		if _bcec.Name.Local == "defStyle" {
			_fgfaa, _gaba := _bcec.Value, error(nil)
			if _gaba != nil {
				return _gaba
			}
			_aebb.DefStyleAttr = &_fgfaa
			continue
		}
	}
_cdfd:
	for {
		_bgba, _afag := d.Token()
		if _afag != nil {
			return _afag
		}
		switch _degc := _bgba.(type) {
		case _b.StartElement:
			switch _degc.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_dafc := NewCT_Name()
				if _fgac := d.DecodeElement(_dafc, &_degc); _fgac != nil {
					return _fgac
				}
				_aebb.Title = append(_aebb.Title, _dafc)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_ebf := NewCT_Description()
				if _dce := d.DecodeElement(_ebf, &_degc); _dce != nil {
					return _dce
				}
				_aebb.Desc = append(_aebb.Desc, _ebf)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_aebb.CatLst = NewCT_Categories()
				if _eabf := d.DecodeElement(_aebb.CatLst, &_degc); _eabf != nil {
					return _eabf
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "sampData"}:
				_aebb.SampData = NewCT_SampleData()
				if _dea := d.DecodeElement(_aebb.SampData, &_degc); _dea != nil {
					return _dea
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "styleData"}:
				_aebb.StyleData = NewCT_SampleData()
				if _bbff := d.DecodeElement(_aebb.StyleData, &_degc); _bbff != nil {
					return _bbff
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "clrData"}:
				_aebb.ClrData = NewCT_SampleData()
				if _cgcf := d.DecodeElement(_aebb.ClrData, &_degc); _cgcf != nil {
					return _cgcf
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "layoutNode"}:
				if _cbde := d.DecodeElement(_aebb.LayoutNode, &_degc); _cbde != nil {
					return _cbde
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_aebb.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _fgbe := d.DecodeElement(_aebb.ExtLst, &_degc); _fgbe != nil {
					return _fgbe
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element on\u0020CT_DiagramDefinition\u0020\u0025v", _degc.Name)
				if _ggaf := d.Skip(); _ggaf != nil {
					return _ggaf
				}
			}
		case _b.EndElement:
			break _cdfd
		case _b.CharData:
		}
	}
	return nil
}
func (_bcdf *CT_SampleData) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bcdf.UseDefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "useDef"}, Value: _a.Sprintf("\u0025d", _eecbc(*_bcdf.UseDefAttr))})
	}
	e.EncodeToken(start)
	if _bcdf.DataModel != nil {
		_agbca := _b.StartElement{Name: _b.Name{Local: "dataModel"}}
		e.EncodeElement(_bcdf.DataModel, _agbca)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_SDCategory and its children, prefixing error messages with path
func (_fdae *CT_SDCategory) ValidateWithPath(path string) error { return nil }

const (
	ST_HueDirUnset ST_HueDir = 0
	ST_HueDirCw    ST_HueDir = 1
	ST_HueDirCcw   ST_HueDir = 2
)

func NewCT_Algorithm() *CT_Algorithm {
	_cabc := &CT_Algorithm{}
	_cabc.TypeAttr = ST_AlgorithmType(1)
	return _cabc
}
func (_bbcf *CT_SDName) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dfdb := range start.Attr {
		if _dfdb.Name.Local == "lang" {
			_cfce, _cbggf := _dfdb.Value, error(nil)
			if _cbggf != nil {
				return _cbggf
			}
			_bbcf.LangAttr = &_cfce
			continue
		}
		if _dfdb.Name.Local == "val" {
			_gfdd, _bbbc := _dfdb.Value, error(nil)
			if _bbbc != nil {
				return _bbbc
			}
			_bbcf.ValAttr = _gfdd
			continue
		}
	}
	for {
		_bdac, _edfaf := d.Token()
		if _edfaf != nil {
			return _a.Errorf("parsing\u0020CT_SDName:\u0020\u0025s", _edfaf)
		}
		if _cafad, _gefed := _bdac.(_b.EndElement); _gefed && _cafad.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fgab *ST_TextAnchorVertical) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cecgg, _gdaae := d.Token()
	if _gdaae != nil {
		return _gdaae
	}
	if _fbaba, _bgbfa := _cecgg.(_b.EndElement); _bgbfa && _fbaba.Name == start.Name {
		*_fgab = 1
		return nil
	}
	if _bdbga, _fdcbc := _cecgg.(_b.CharData); !_fdcbc {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cecgg)
	} else {
		switch string(_bdbga) {
		case "":
			*_fgab = 0
		case "t":
			*_fgab = 1
		case "mid":
			*_fgab = 2
		case "b":
			*_fgab = 3
		}
	}
	_cecgg, _gdaae = d.Token()
	if _gdaae != nil {
		return _gdaae
	}
	if _bdaf, _ggfea := _cecgg.(_b.EndElement); _ggfea && _bdaf.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cecgg)
}

// ValidateWithPath validates the CT_Rules and its children, prefixing error messages with path
func (_fbce *CT_Rules) ValidateWithPath(path string) error {
	for _cfcag, _cbad := range _fbce.Rule {
		if _bfaa := _cbad.ValidateWithPath(_a.Sprintf("%s\u002fRule\u005b\u0025d\u005d", path, _cfcag)); _bfaa != nil {
			return _bfaa
		}
	}
	return nil
}
func (_daag ST_TextDirection) Validate() error { return _daag.ValidateWithPath("") }

type ST_TextAnchorHorizontal byte

func (_cedb ST_NodeHorizontalAlignment) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_cedb.String(), start)
}
func (_adgg ST_ChildAlignment) Validate() error { return _adgg.ValidateWithPath("") }

type ST_ElementTypes []ST_ElementType

func (_ggbb *CT_CTCategories) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_aef:
	for {
		_cbe, _gdab := d.Token()
		if _gdab != nil {
			return _gdab
		}
		switch _cbf := _cbe.(type) {
		case _b.StartElement:
			switch _cbf.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "cat"}:
				_gcbc := NewCT_CTCategory()
				if _ccba := d.DecodeElement(_gcbc, &_cbf); _ccba != nil {
					return _ccba
				}
				_ggbb.Cat = append(_ggbb.Cat, _gcbc)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CTCategories\u0020\u0025v", _cbf.Name)
				if _dgg := d.Skip(); _dgg != nil {
					return _dgg
				}
			}
		case _b.EndElement:
			break _aef
		case _b.CharData:
		}
	}
	return nil
}
func (_gegc *ST_LayoutShapeType) Validate() error { return _gegc.ValidateWithPath("") }
func (_dgaba ST_ArrowheadStyle) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_egbda := _b.Attr{}
	_egbda.Name = name
	switch _dgaba {
	case ST_ArrowheadStyleUnset:
		_egbda.Value = ""
	case ST_ArrowheadStyleAuto:
		_egbda.Value = "auto"
	case ST_ArrowheadStyleArr:
		_egbda.Value = "arr"
	case ST_ArrowheadStyleNoArr:
		_egbda.Value = "noArr"
	}
	return _egbda, nil
}
func (_ddaa *CT_CxnList) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _ddaa.Cxn != nil {
		_gbfa := _b.StartElement{Name: _b.Name{Local: "cxn"}}
		for _, _ccca := range _ddaa.Cxn {
			e.EncodeElement(_ccca, _gbfa)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_aceed ST_HueDir) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gddaf := _b.Attr{}
	_gddaf.Name = name
	switch _aceed {
	case ST_HueDirUnset:
		_gddaf.Value = ""
	case ST_HueDirCw:
		_gddaf.Value = "cw"
	case ST_HueDirCcw:
		_gddaf.Value = "ccw"
	}
	return _gddaf, nil
}

type ColorsDefHdr struct{ CT_ColorTransformHeader }

func (_daef *ST_FunctionOperator) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_aafdc, _aebd := d.Token()
	if _aebd != nil {
		return _aebd
	}
	if _badg, _bfcf := _aafdc.(_b.EndElement); _bfcf && _badg.Name == start.Name {
		*_daef = 1
		return nil
	}
	if _fgeca, _baad := _aafdc.(_b.CharData); !_baad {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aafdc)
	} else {
		switch string(_fgeca) {
		case "":
			*_daef = 0
		case "equ":
			*_daef = 1
		case "neq":
			*_daef = 2
		case "gt":
			*_daef = 3
		case "lt":
			*_daef = 4
		case "gte":
			*_daef = 5
		case "lte":
			*_daef = 6
		}
	}
	_aafdc, _aebd = d.Token()
	if _aebd != nil {
		return _aebd
	}
	if _debac, _dbgc := _aafdc.(_b.EndElement); _dbgc && _debac.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aafdc)
}

// ValidateWithPath validates the CT_Parameter and its children, prefixing error messages with path
func (_adcf *CT_Parameter) ValidateWithPath(path string) error {
	if _adcf.TypeAttr == ST_ParameterIdUnset {
		return _a.Errorf("\u0025s\u002fTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _dbba := _adcf.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _dbba != nil {
		return _dbba
	}
	if _fgaca := _adcf.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _fgaca != nil {
		return _fgaca
	}
	return nil
}

// Validate validates the CT_Parameter and its children
func (_bdca *CT_Parameter) Validate() error { return _bdca.ValidateWithPath("CT_Parameter") }
func (_cdgd ST_TextAnchorHorizontal) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_adee := _b.Attr{}
	_adee.Name = name
	switch _cdgd {
	case ST_TextAnchorHorizontalUnset:
		_adee.Value = ""
	case ST_TextAnchorHorizontalNone:
		_adee.Value = "none"
	case ST_TextAnchorHorizontalCtr:
		_adee.Value = "ctr"
	}
	return _adee, nil
}
func (_efbf *CT_ChildMax) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _efbf.ValAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", *_efbf.ValAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_debgd ST_VerticalAlignment) ValidateWithPath(path string) error {
	switch _debgd {
	case 0, 1, 2, 3, 4:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_debgd))
	}
	return nil
}

type ST_HierarchyAlignment byte

// ValidateWithPath validates the CT_OrgChart and its children, prefixing error messages with path
func (_ded *CT_OrgChart) ValidateWithPath(path string) error { return nil }
func (_dfga ST_LinearDirection) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_adabd := _b.Attr{}
	_adabd.Name = name
	switch _dfga {
	case ST_LinearDirectionUnset:
		_adabd.Value = ""
	case ST_LinearDirectionFromL:
		_adabd.Value = "fromL"
	case ST_LinearDirectionFromR:
		_adabd.Value = "fromR"
	case ST_LinearDirectionFromT:
		_adabd.Value = "fromT"
	case ST_LinearDirectionFromB:
		_adabd.Value = "fromB"
	}
	return _adabd, nil
}
func NewCT_Constraint() *CT_Constraint { _gafd := &CT_Constraint{}; return _gafd }

const (
	ST_VariableTypeUnset         ST_VariableType = 0
	ST_VariableTypeNone          ST_VariableType = 1
	ST_VariableTypeOrgChart      ST_VariableType = 2
	ST_VariableTypeChMax         ST_VariableType = 3
	ST_VariableTypeChPref        ST_VariableType = 4
	ST_VariableTypeBulEnabled    ST_VariableType = 5
	ST_VariableTypeDir           ST_VariableType = 6
	ST_VariableTypeHierBranch    ST_VariableType = 7
	ST_VariableTypeAnimOne       ST_VariableType = 8
	ST_VariableTypeAnimLvl       ST_VariableType = 9
	ST_VariableTypeResizeHandles ST_VariableType = 10
)

func (_bcagd ST_GrowDirection) Validate() error { return _bcagd.ValidateWithPath("") }
func (_fgcad ST_VariableType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_fgcad.String(), start)
}

type ST_ChildOrderType byte
type CT_AdjLst struct{ Adj []*CT_Adj }

func (_bggca *ColorsDefHdr) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bggca.CT_ColorTransformHeader = *NewCT_ColorTransformHeader()
	for _, _bacc := range start.Attr {
		if _bacc.Name.Local == "uniqueId" {
			_acbbc, _egcfgd := _bacc.Value, error(nil)
			if _egcfgd != nil {
				return _egcfgd
			}
			_bggca.UniqueIdAttr = _acbbc
			continue
		}
		if _bacc.Name.Local == "minVer" {
			_gdge, _egfd := _bacc.Value, error(nil)
			if _egfd != nil {
				return _egfd
			}
			_bggca.MinVerAttr = &_gdge
			continue
		}
		if _bacc.Name.Local == "resId" {
			_agbd, _bbgg := _d.ParseInt(_bacc.Value, 10, 32)
			if _bbgg != nil {
				return _bbgg
			}
			_cbca := int32(_agbd)
			_bggca.ResIdAttr = &_cbca
			continue
		}
	}
_dceg:
	for {
		_cddg, _cdec := d.Token()
		if _cdec != nil {
			return _cdec
		}
		switch _fcfe := _cddg.(type) {
		case _b.StartElement:
			switch _fcfe.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_bbgf := NewCT_CTName()
				if _fgce := d.DecodeElement(_bbgf, &_fcfe); _fgce != nil {
					return _fgce
				}
				_bggca.Title = append(_bggca.Title, _bbgf)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_beege := NewCT_CTDescription()
				if _gcade := d.DecodeElement(_beege, &_fcfe); _gcade != nil {
					return _gcade
				}
				_bggca.Desc = append(_bggca.Desc, _beege)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_bggca.CatLst = NewCT_CTCategories()
				if _daae := d.DecodeElement(_bggca.CatLst, &_fcfe); _daae != nil {
					return _daae
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_bggca.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _deeaa := d.DecodeElement(_bggca.ExtLst, &_fcfe); _deeaa != nil {
					return _deeaa
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020ColorsDefHdr\u0020\u0025v", _fcfe.Name)
				if _gdcc := d.Skip(); _gdcc != nil {
					return _gdcc
				}
			}
		case _b.EndElement:
			break _dceg
		case _b.CharData:
		}
	}
	return nil
}
func (_edbf *CT_Constraints) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_cac:
	for {
		_fdab, _gafdc := d.Token()
		if _gafdc != nil {
			return _gafdc
		}
		switch _dab := _fdab.(type) {
		case _b.StartElement:
			switch _dab.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "constr"}:
				_ccgc := NewCT_Constraint()
				if _cdd := d.DecodeElement(_ccgc, &_dab); _cdd != nil {
					return _cdd
				}
				_edbf.Constr = append(_edbf.Constr, _ccgc)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Constraints\u0020\u0025v", _dab.Name)
				if _gddf := d.Skip(); _gddf != nil {
					return _gddf
				}
			}
		case _b.EndElement:
			break _cac
		case _b.CharData:
		}
	}
	return nil
}

type CT_SDCategories struct{ Cat []*CT_SDCategory }

func (_cadc ST_FallbackDimension) Validate() error { return _cadc.ValidateWithPath("") }
func (_bcafa ST_Breakpoint) ValidateWithPath(path string) error {
	switch _bcafa {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bcafa))
	}
	return nil
}
func (_cea *CT_Adj) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "idx"}, Value: _a.Sprintf("\u0025v", _cea.IdxAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", _cea.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_badga ST_LinearDirection) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_badga.String(), start)
}
func (_bfc *CT_ForEach) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _abbg := range start.Attr {
		if _abbg.Name.Local == "ref" {
			_eegf, _bafd := _abbg.Value, error(nil)
			if _bafd != nil {
				return _bafd
			}
			_bfc.RefAttr = &_eegf
			continue
		}
		if _abbg.Name.Local == "name" {
			_fed, _bfge := _abbg.Value, error(nil)
			if _bfge != nil {
				return _bfge
			}
			_bfc.NameAttr = &_fed
			continue
		}
		if _abbg.Name.Local == "axis" {
			_edcf, _adgce := ParseSliceST_AxisTypes(_abbg.Value)
			if _adgce != nil {
				return _adgce
			}
			_bfc.AxisAttr = &_edcf
			continue
		}
		if _abbg.Name.Local == "ptType" {
			_cgdf, _debf := ParseSliceST_ElementTypes(_abbg.Value)
			if _debf != nil {
				return _debf
			}
			_bfc.PtTypeAttr = &_cgdf
			continue
		}
		if _abbg.Name.Local == "hideLastTrans" {
			_cfbe, _dceb := ParseSliceST_Booleans(_abbg.Value)
			if _dceb != nil {
				return _dceb
			}
			_bfc.HideLastTransAttr = &_cfbe
			continue
		}
		if _abbg.Name.Local == "st" {
			_ccad, _agcdc := ParseSliceST_Ints(_abbg.Value)
			if _agcdc != nil {
				return _agcdc
			}
			_bfc.StAttr = &_ccad
			continue
		}
		if _abbg.Name.Local == "cnt" {
			_aad, _afcg := ParseSliceST_UnsignedInts(_abbg.Value)
			if _afcg != nil {
				return _afcg
			}
			_bfc.CntAttr = &_aad
			continue
		}
		if _abbg.Name.Local == "step" {
			_eeff, _ccgdb := ParseSliceST_Ints(_abbg.Value)
			if _ccgdb != nil {
				return _ccgdb
			}
			_bfc.StepAttr = &_eeff
			continue
		}
	}
_cgeg:
	for {
		_aecd, _gdgdf := d.Token()
		if _gdgdf != nil {
			return _gdgdf
		}
		switch _acfb := _aecd.(type) {
		case _b.StartElement:
			switch _acfb.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "alg"}:
				_dcfg := NewCT_Algorithm()
				if _abag := d.DecodeElement(_dcfg, &_acfb); _abag != nil {
					return _abag
				}
				_bfc.Alg = append(_bfc.Alg, _dcfg)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "shape"}:
				_geed := NewCT_Shape()
				if _gdbb := d.DecodeElement(_geed, &_acfb); _gdbb != nil {
					return _gdbb
				}
				_bfc.Shape = append(_bfc.Shape, _geed)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "presOf"}:
				_cfbec := NewCT_PresentationOf()
				if _beed := d.DecodeElement(_cfbec, &_acfb); _beed != nil {
					return _beed
				}
				_bfc.PresOf = append(_bfc.PresOf, _cfbec)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "constrLst"}:
				_afbg := NewCT_Constraints()
				if _dece := d.DecodeElement(_afbg, &_acfb); _dece != nil {
					return _dece
				}
				_bfc.ConstrLst = append(_bfc.ConstrLst, _afbg)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "ruleLst"}:
				_gbgd := NewCT_Rules()
				if _cfc := d.DecodeElement(_gbgd, &_acfb); _cfc != nil {
					return _cfc
				}
				_bfc.RuleLst = append(_bfc.RuleLst, _gbgd)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "forEach"}:
				_bfbf := NewCT_ForEach()
				if _cdbcg := d.DecodeElement(_bfbf, &_acfb); _cdbcg != nil {
					return _cdbcg
				}
				_bfc.ForEach = append(_bfc.ForEach, _bfbf)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "layoutNode"}:
				_caeg := NewCT_LayoutNode()
				if _geebg := d.DecodeElement(_caeg, &_acfb); _geebg != nil {
					return _geebg
				}
				_bfc.LayoutNode = append(_bfc.LayoutNode, _caeg)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "choose"}:
				_efgf := NewCT_Choose()
				if _gbaf := d.DecodeElement(_efgf, &_acfb); _gbaf != nil {
					return _gbaf
				}
				_bfc.Choose = append(_bfc.Choose, _efgf)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_edfc := _f.NewCT_OfficeArtExtensionList()
				if _eggc := d.DecodeElement(_edfc, &_acfb); _eggc != nil {
					return _eggc
				}
				_bfc.ExtLst = append(_bfc.ExtLst, _edfc)
			default:
				_ea.Log("skipping unsupported\u0020element\u0020on\u0020CT_ForEach\u0020\u0025v", _acfb.Name)
				if _dgbb := d.Skip(); _dgbb != nil {
					return _dgbb
				}
			}
		case _b.EndElement:
			break _cgeg
		case _b.CharData:
		}
	}
	return nil
}
func (_fggb ST_OutputShapeType) String() string {
	switch _fggb {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "conn"
	}
	return ""
}

const (
	ST_HierarchyAlignmentUnset   ST_HierarchyAlignment = 0
	ST_HierarchyAlignmentTL      ST_HierarchyAlignment = 1
	ST_HierarchyAlignmentTR      ST_HierarchyAlignment = 2
	ST_HierarchyAlignmentTCtrCh  ST_HierarchyAlignment = 3
	ST_HierarchyAlignmentTCtrDes ST_HierarchyAlignment = 4
	ST_HierarchyAlignmentBL      ST_HierarchyAlignment = 5
	ST_HierarchyAlignmentBR      ST_HierarchyAlignment = 6
	ST_HierarchyAlignmentBCtrCh  ST_HierarchyAlignment = 7
	ST_HierarchyAlignmentBCtrDes ST_HierarchyAlignment = 8
	ST_HierarchyAlignmentLT      ST_HierarchyAlignment = 9
	ST_HierarchyAlignmentLB      ST_HierarchyAlignment = 10
	ST_HierarchyAlignmentLCtrCh  ST_HierarchyAlignment = 11
	ST_HierarchyAlignmentLCtrDes ST_HierarchyAlignment = 12
	ST_HierarchyAlignmentRT      ST_HierarchyAlignment = 13
	ST_HierarchyAlignmentRB      ST_HierarchyAlignment = 14
	ST_HierarchyAlignmentRCtrCh  ST_HierarchyAlignment = 15
	ST_HierarchyAlignmentRCtrDes ST_HierarchyAlignment = 16
)

func (_aecg ST_Breakpoint) String() string {
	switch _aecg {
	case 0:
		return ""
	case 1:
		return "endCnv"
	case 2:
		return "bal"
	case 3:
		return "fixed"
	}
	return ""
}
func (_ebd *CT_ColorTransform) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ebd.UniqueIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "uniqueId"}, Value: _a.Sprintf("\u0025v", *_ebd.UniqueIdAttr)})
	}
	if _ebd.MinVerAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "minVer"}, Value: _a.Sprintf("\u0025v", *_ebd.MinVerAttr)})
	}
	e.EncodeToken(start)
	if _ebd.Title != nil {
		_bca := _b.StartElement{Name: _b.Name{Local: "title"}}
		for _, _fdf := range _ebd.Title {
			e.EncodeElement(_fdf, _bca)
		}
	}
	if _ebd.Desc != nil {
		_eeb := _b.StartElement{Name: _b.Name{Local: "desc"}}
		for _, _abd := range _ebd.Desc {
			e.EncodeElement(_abd, _eeb)
		}
	}
	if _ebd.CatLst != nil {
		_bfdf := _b.StartElement{Name: _b.Name{Local: "catLst"}}
		e.EncodeElement(_ebd.CatLst, _bfdf)
	}
	if _ebd.StyleLbl != nil {
		_bgc := _b.StartElement{Name: _b.Name{Local: "styleLbl"}}
		for _, _gaca := range _ebd.StyleLbl {
			e.EncodeElement(_gaca, _bgc)
		}
	}
	if _ebd.ExtLst != nil {
		_faf := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_ebd.ExtLst, _faf)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_fdcbf *ST_NodeVerticalAlignment) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fdcbf = 0
	case "t":
		*_fdcbf = 1
	case "mid":
		*_fdcbf = 2
	case "b":
		*_fdcbf = 3
	}
	return nil
}
func (_dbdeb *LayoutDef) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dbdeb.CT_DiagramDefinition = *NewCT_DiagramDefinition()
	for _, _becg := range start.Attr {
		if _becg.Name.Local == "uniqueId" {
			_fbfa, _dfgc := _becg.Value, error(nil)
			if _dfgc != nil {
				return _dfgc
			}
			_dbdeb.UniqueIdAttr = &_fbfa
			continue
		}
		if _becg.Name.Local == "minVer" {
			_cbffe, _eeegb := _becg.Value, error(nil)
			if _eeegb != nil {
				return _eeegb
			}
			_dbdeb.MinVerAttr = &_cbffe
			continue
		}
		if _becg.Name.Local == "defStyle" {
			_baddf, _fbgce := _becg.Value, error(nil)
			if _fbgce != nil {
				return _fbgce
			}
			_dbdeb.DefStyleAttr = &_baddf
			continue
		}
	}
_ffdf:
	for {
		_aadf, _gddca := d.Token()
		if _gddca != nil {
			return _gddca
		}
		switch _fcdc := _aadf.(type) {
		case _b.StartElement:
			switch _fcdc.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_cdfc := NewCT_Name()
				if _affa := d.DecodeElement(_cdfc, &_fcdc); _affa != nil {
					return _affa
				}
				_dbdeb.Title = append(_dbdeb.Title, _cdfc)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_gdbfb := NewCT_Description()
				if _afaf := d.DecodeElement(_gdbfb, &_fcdc); _afaf != nil {
					return _afaf
				}
				_dbdeb.Desc = append(_dbdeb.Desc, _gdbfb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_dbdeb.CatLst = NewCT_Categories()
				if _dade := d.DecodeElement(_dbdeb.CatLst, &_fcdc); _dade != nil {
					return _dade
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "sampData"}:
				_dbdeb.SampData = NewCT_SampleData()
				if _efeg := d.DecodeElement(_dbdeb.SampData, &_fcdc); _efeg != nil {
					return _efeg
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "styleData"}:
				_dbdeb.StyleData = NewCT_SampleData()
				if _fabd := d.DecodeElement(_dbdeb.StyleData, &_fcdc); _fabd != nil {
					return _fabd
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "clrData"}:
				_dbdeb.ClrData = NewCT_SampleData()
				if _bcdaa := d.DecodeElement(_dbdeb.ClrData, &_fcdc); _bcdaa != nil {
					return _bcdaa
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "layoutNode"}:
				if _dffcb := d.DecodeElement(_dbdeb.LayoutNode, &_fcdc); _dffcb != nil {
					return _dffcb
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_dbdeb.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _ecfg := d.DecodeElement(_dbdeb.ExtLst, &_fcdc); _ecfg != nil {
					return _ecfg
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element on LayoutDef \u0025v", _fcdc.Name)
				if _bgec := d.Skip(); _bgec != nil {
					return _bgec
				}
			}
		case _b.EndElement:
			break _ffdf
		case _b.CharData:
		}
	}
	return nil
}

type ST_ClrAppMethod byte

func (_efeab ST_VerticalAlignment) Validate() error { return _efeab.ValidateWithPath("") }

type ST_ConnectorPoint byte
type ColorsDef struct{ CT_ColorTransform }
type StyleDef struct{ CT_StyleDefinition }
type CT_AnimOne struct{ ValAttr ST_AnimOneStr }

// Validate validates the CT_AnimOne and its children
func (_ccc *CT_AnimOne) Validate() error { return _ccc.ValidateWithPath("CT_AnimOne") }
func (_dbdad ST_BendPoint) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dbdad.String(), start)
}

// Validate validates the CT_Otherwise and its children
func (_beeb *CT_Otherwise) Validate() error { return _beeb.ValidateWithPath("CT_Otherwise") }
func NewCT_Colors() *CT_Colors              { _ccgd := &CT_Colors{}; return _ccgd }

type ST_AxisType byte

func NewCT_BulletEnabled() *CT_BulletEnabled       { _egd := &CT_BulletEnabled{}; return _egd }
func (_daece ST_AutoTextRotation) Validate() error { return _daece.ValidateWithPath("") }

// ValidateWithPath validates the LayoutDef and its children, prefixing error messages with path
func (_daed *LayoutDef) ValidateWithPath(path string) error {
	if _ddcg := _daed.CT_DiagramDefinition.ValidateWithPath(path); _ddcg != nil {
		return _ddcg
	}
	return nil
}
func (_gdgg *CT_ForEach) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _gdgg.NameAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "name"}, Value: _a.Sprintf("\u0025v", *_gdgg.NameAttr)})
	}
	if _gdgg.RefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "ref"}, Value: _a.Sprintf("\u0025v", *_gdgg.RefAttr)})
	}
	if _gdgg.AxisAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "axis"}, Value: _a.Sprintf("\u0025v", *_gdgg.AxisAttr)})
	}
	if _gdgg.PtTypeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "ptType"}, Value: _a.Sprintf("\u0025v", *_gdgg.PtTypeAttr)})
	}
	if _gdgg.HideLastTransAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "hideLastTrans"}, Value: _a.Sprintf("\u0025v", *_gdgg.HideLastTransAttr)})
	}
	if _gdgg.StAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "st"}, Value: _a.Sprintf("\u0025v", *_gdgg.StAttr)})
	}
	if _gdgg.CntAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cnt"}, Value: _a.Sprintf("\u0025v", *_gdgg.CntAttr)})
	}
	if _gdgg.StepAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "step"}, Value: _a.Sprintf("\u0025v", *_gdgg.StepAttr)})
	}
	e.EncodeToken(start)
	if _gdgg.Alg != nil {
		_bbdca := _b.StartElement{Name: _b.Name{Local: "alg"}}
		for _, _dcdg := range _gdgg.Alg {
			e.EncodeElement(_dcdg, _bbdca)
		}
	}
	if _gdgg.Shape != nil {
		_dbce := _b.StartElement{Name: _b.Name{Local: "shape"}}
		for _, _ddcc := range _gdgg.Shape {
			e.EncodeElement(_ddcc, _dbce)
		}
	}
	if _gdgg.PresOf != nil {
		_gecbe := _b.StartElement{Name: _b.Name{Local: "presOf"}}
		for _, _gdef := range _gdgg.PresOf {
			e.EncodeElement(_gdef, _gecbe)
		}
	}
	if _gdgg.ConstrLst != nil {
		_aacf := _b.StartElement{Name: _b.Name{Local: "constrLst"}}
		for _, _cbeee := range _gdgg.ConstrLst {
			e.EncodeElement(_cbeee, _aacf)
		}
	}
	if _gdgg.RuleLst != nil {
		_fcfb := _b.StartElement{Name: _b.Name{Local: "ruleLst"}}
		for _, _aeae := range _gdgg.RuleLst {
			e.EncodeElement(_aeae, _fcfb)
		}
	}
	if _gdgg.ForEach != nil {
		_dbgfg := _b.StartElement{Name: _b.Name{Local: "forEach"}}
		for _, _eagf := range _gdgg.ForEach {
			e.EncodeElement(_eagf, _dbgfg)
		}
	}
	if _gdgg.LayoutNode != nil {
		_badc := _b.StartElement{Name: _b.Name{Local: "layoutNode"}}
		for _, _geea := range _gdgg.LayoutNode {
			e.EncodeElement(_geea, _badc)
		}
	}
	if _gdgg.Choose != nil {
		_edag := _b.StartElement{Name: _b.Name{Local: "choose"}}
		for _, _gaeg := range _gdgg.Choose {
			e.EncodeElement(_gaeg, _edag)
		}
	}
	if _gdgg.ExtLst != nil {
		_fbcd := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		for _, _ccdg := range _gdgg.ExtLst {
			e.EncodeElement(_ccdg, _fbcd)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_gfbfc *ST_FlowDirection) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_gfbfc = 0
	case "row":
		*_gfbfc = 1
	case "col":
		*_gfbfc = 2
	}
	return nil
}

type ST_PyramidAccentPosition byte

func (_cgfd ST_FlowDirection) ValidateWithPath(path string) error {
	switch _cgfd {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cgfd))
	}
	return nil
}
func (_dcfec ST_GrowDirection) ValidateWithPath(path string) error {
	switch _dcfec {
	case 0, 1, 2, 3, 4:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dcfec))
	}
	return nil
}
func (_gacg ST_AlgorithmType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bagf := _b.Attr{}
	_bagf.Name = name
	switch _gacg {
	case ST_AlgorithmTypeUnset:
		_bagf.Value = ""
	case ST_AlgorithmTypeComposite:
		_bagf.Value = "composite"
	case ST_AlgorithmTypeConn:
		_bagf.Value = "conn"
	case ST_AlgorithmTypeCycle:
		_bagf.Value = "cycle"
	case ST_AlgorithmTypeHierChild:
		_bagf.Value = "hierChild"
	case ST_AlgorithmTypeHierRoot:
		_bagf.Value = "hierRoot"
	case ST_AlgorithmTypePyra:
		_bagf.Value = "pyra"
	case ST_AlgorithmTypeLin:
		_bagf.Value = "lin"
	case ST_AlgorithmTypeSp:
		_bagf.Value = "sp"
	case ST_AlgorithmTypeTx:
		_bagf.Value = "tx"
	case ST_AlgorithmTypeSnake:
		_bagf.Value = "snake"
	}
	return _bagf, nil
}

type DataModel struct{ CT_DataModel }

// ValidateWithPath validates the CT_Direction and its children, prefixing error messages with path
func (_bbfcb *CT_Direction) ValidateWithPath(path string) error {
	if _dabb := _bbfcb.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _dabb != nil {
		return _dabb
	}
	return nil
}

const (
	ST_ResizeHandlesStrUnset ST_ResizeHandlesStr = 0
	ST_ResizeHandlesStrExact ST_ResizeHandlesStr = 1
	ST_ResizeHandlesStrRel   ST_ResizeHandlesStr = 2
)

func (_febff ST_ConstraintType) String() string {
	switch _febff {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "alignOff"
	case 3:
		return "begMarg"
	case 4:
		return "bendDist"
	case 5:
		return "begPad"
	case 6:
		return "b"
	case 7:
		return "bMarg"
	case 8:
		return "bOff"
	case 9:
		return "ctrX"
	case 10:
		return "ctrXOff"
	case 11:
		return "ctrY"
	case 12:
		return "ctrYOff"
	case 13:
		return "connDist"
	case 14:
		return "diam"
	case 15:
		return "endMarg"
	case 16:
		return "endPad"
	case 17:
		return "h"
	case 18:
		return "hArH"
	case 19:
		return "hOff"
	case 20:
		return "l"
	case 21:
		return "lMarg"
	case 22:
		return "lOff"
	case 23:
		return "r"
	case 24:
		return "rMarg"
	case 25:
		return "rOff"
	case 26:
		return "primFontSz"
	case 27:
		return "pyraAcctRatio"
	case 28:
		return "secFontSz"
	case 29:
		return "sibSp"
	case 30:
		return "secSibSp"
	case 31:
		return "sp"
	case 32:
		return "stemThick"
	case 33:
		return "t"
	case 34:
		return "tMarg"
	case 35:
		return "tOff"
	case 36:
		return "userA"
	case 37:
		return "userB"
	case 38:
		return "userC"
	case 39:
		return "userD"
	case 40:
		return "userE"
	case 41:
		return "userF"
	case 42:
		return "userG"
	case 43:
		return "userH"
	case 44:
		return "userI"
	case 45:
		return "userJ"
	case 46:
		return "userK"
	case 47:
		return "userL"
	case 48:
		return "userM"
	case 49:
		return "userN"
	case 50:
		return "userO"
	case 51:
		return "userP"
	case 52:
		return "userQ"
	case 53:
		return "userR"
	case 54:
		return "userS"
	case 55:
		return "userT"
	case 56:
		return "userU"
	case 57:
		return "userV"
	case 58:
		return "userW"
	case 59:
		return "userX"
	case 60:
		return "userY"
	case 61:
		return "userZ"
	case 62:
		return "w"
	case 63:
		return "wArH"
	case 64:
		return "wOff"
	}
	return ""
}

type CT_Adj struct {
	IdxAttr uint32
	ValAttr float64
}

func (_debad *CT_Name) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _debad.LangAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "lang"}, Value: _a.Sprintf("\u0025v", *_debad.LangAttr)})
	}
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", _debad.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_ecfe *ST_GrowDirection) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bbdgc, _dadg := d.Token()
	if _dadg != nil {
		return _dadg
	}
	if _cfba, _begab := _bbdgc.(_b.EndElement); _begab && _cfba.Name == start.Name {
		*_ecfe = 1
		return nil
	}
	if _cbeefe, _cagf := _bbdgc.(_b.CharData); !_cagf {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bbdgc)
	} else {
		switch string(_cbeefe) {
		case "":
			*_ecfe = 0
		case "tL":
			*_ecfe = 1
		case "tR":
			*_ecfe = 2
		case "bL":
			*_ecfe = 3
		case "bR":
			*_ecfe = 4
		}
	}
	_bbdgc, _dadg = d.Token()
	if _dadg != nil {
		return _dadg
	}
	if _dcbbf, _fdcaf := _bbdgc.(_b.EndElement); _fdcaf && _dcbbf.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bbdgc)
}
func ParseUnionST_FunctionValue(s string) (ST_FunctionValue, error) { return ST_FunctionValue{}, nil }
func (_ceded *ST_SecondaryLinearDirection) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_eaag, _dbed := d.Token()
	if _dbed != nil {
		return _dbed
	}
	if _afbcd, _ggcb := _eaag.(_b.EndElement); _ggcb && _afbcd.Name == start.Name {
		*_ceded = 1
		return nil
	}
	if _egfbf, _cegg := _eaag.(_b.CharData); !_cegg {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eaag)
	} else {
		switch string(_egfbf) {
		case "":
			*_ceded = 0
		case "none":
			*_ceded = 1
		case "fromL":
			*_ceded = 2
		case "fromR":
			*_ceded = 3
		case "fromT":
			*_ceded = 4
		case "fromB":
			*_ceded = 5
		}
	}
	_eaag, _dbed = d.Token()
	if _dbed != nil {
		return _dbed
	}
	if _fcef, _bfec := _eaag.(_b.EndElement); _bfec && _fcef.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eaag)
}

type CT_DiagramDefinition struct {
	UniqueIdAttr *string
	MinVerAttr   *string
	DefStyleAttr *string
	Title        []*CT_Name
	Desc         []*CT_Description
	CatLst       *CT_Categories
	SampData     *CT_SampleData
	StyleData    *CT_SampleData
	ClrData      *CT_SampleData
	LayoutNode   *CT_LayoutNode
	ExtLst       *_f.CT_OfficeArtExtensionList
}
type CT_CTDescription struct {
	LangAttr *string
	ValAttr  string
}

func (_da *AG_IteratorAttributes) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _da.AxisAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "axis"}, Value: _a.Sprintf("\u0025v", *_da.AxisAttr)})
	}
	if _da.PtTypeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "ptType"}, Value: _a.Sprintf("\u0025v", *_da.PtTypeAttr)})
	}
	if _da.HideLastTransAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "hideLastTrans"}, Value: _a.Sprintf("\u0025v", *_da.HideLastTransAttr)})
	}
	if _da.StAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "st"}, Value: _a.Sprintf("\u0025v", *_da.StAttr)})
	}
	if _da.CntAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cnt"}, Value: _a.Sprintf("\u0025v", *_da.CntAttr)})
	}
	if _da.StepAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "step"}, Value: _a.Sprintf("\u0025v", *_da.StepAttr)})
	}
	return nil
}

type CT_SDCategory struct {
	TypeAttr string
	PriAttr  uint32
}

func (_ddbgg ST_VerticalAlignment) String() string {
	switch _ddbgg {
	case 0:
		return ""
	case 1:
		return "t"
	case 2:
		return "mid"
	case 3:
		return "b"
	case 4:
		return "none"
	}
	return ""
}

// ValidateWithPath validates the CT_Algorithm and its children, prefixing error messages with path
func (_gbb *CT_Algorithm) ValidateWithPath(path string) error {
	if _gbb.TypeAttr == ST_AlgorithmTypeUnset {
		return _a.Errorf("\u0025s\u002fTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _ebed := _gbb.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _ebed != nil {
		return _ebed
	}
	for _afd, _gcb := range _gbb.Param {
		if _eef := _gcb.ValidateWithPath(_a.Sprintf("\u0025s\u002fParam\u005b\u0025d\u005d", path, _afd)); _eef != nil {
			return _eef
		}
	}
	if _gbb.ExtLst != nil {
		if _ace := _gbb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ace != nil {
			return _ace
		}
	}
	return nil
}
func NewCT_Name() *CT_Name   { _dgad := &CT_Name{}; return _dgad }
func NewCT_Rules() *CT_Rules { _bgafg := &CT_Rules{}; return _bgafg }
func (_dbbb *CT_Direction) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _fece := range start.Attr {
		if _fece.Name.Local == "val" {
			_dbbb.ValAttr.UnmarshalXMLAttr(_fece)
			continue
		}
	}
	for {
		_caca, _egba := d.Token()
		if _egba != nil {
			return _a.Errorf("parsing\u0020CT_Direction:\u0020\u0025s", _egba)
		}
		if _eee, _caef := _caca.(_b.EndElement); _caef && _eee.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cdeb *CT_ResizeHandles) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _efcg := range start.Attr {
		if _efcg.Name.Local == "val" {
			_cdeb.ValAttr.UnmarshalXMLAttr(_efcg)
			continue
		}
	}
	for {
		_dbgd, _fcgd := d.Token()
		if _fcgd != nil {
			return _a.Errorf("parsing\u0020CT_ResizeHandles: \u0025s", _fcgd)
		}
		if _adff, _gccfc := _dbgd.(_b.EndElement); _gccfc && _adff.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_CxnList() *CT_CxnList { _fdgf := &CT_CxnList{}; return _fdgf }

type LayoutDef struct{ CT_DiagramDefinition }

func NewCT_PtList() *CT_PtList                            { _cbege := &CT_PtList{}; return _cbege }
func (_ddedb ST_SecondaryChildAlignment) Validate() error { return _ddedb.ValidateWithPath("") }

// Validate validates the ColorsDefHdr and its children
func (_gcbea *ColorsDefHdr) Validate() error { return _gcbea.ValidateWithPath("ColorsDefHdr") }

// ValidateWithPath validates the CT_ChildPref and its children, prefixing error messages with path
func (_cff *CT_ChildPref) ValidateWithPath(path string) error {
	if _cff.ValAttr != nil {
		if *_cff.ValAttr < -1 {
			return _a.Errorf("\u0025s/m\u002eValAttr must be\u0020\u003e\u003d\u0020\u002d1 \u0028have\u0020\u0025v\u0029", path, *_cff.ValAttr)
		}
	}
	return nil
}

type StyleDefHdrLst struct{ CT_StyleDefinitionHeaderLst }

// Validate validates the CT_CTCategory and its children
func (_aga *CT_CTCategory) Validate() error { return _aga.ValidateWithPath("CT_CTCategory") }
func (_affbb ST_Direction) String() string {
	switch _affbb {
	case 0:
		return ""
	case 1:
		return "norm"
	case 2:
		return "rev"
	}
	return ""
}
func (_eefdd *ST_AxisType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_eefdd = 0
	case "self":
		*_eefdd = 1
	case "ch":
		*_eefdd = 2
	case "des":
		*_eefdd = 3
	case "desOrSelf":
		*_eefdd = 4
	case "par":
		*_eefdd = 5
	case "ancst":
		*_eefdd = 6
	case "ancstOrSelf":
		*_eefdd = 7
	case "followSib":
		*_eefdd = 8
	case "precedSib":
		*_eefdd = 9
	case "follow":
		*_eefdd = 10
	case "preced":
		*_eefdd = 11
	case "root":
		*_eefdd = 12
	case "none":
		*_eefdd = 13
	}
	return nil
}
func NewCT_CTStyleLabel() *CT_CTStyleLabel { _efd := &CT_CTStyleLabel{}; return _efd }
func NewColorsDefHdrLst() *ColorsDefHdrLst {
	_fafdb := &ColorsDefHdrLst{}
	_fafdb.CT_ColorTransformHeaderLst = *NewCT_ColorTransformHeaderLst()
	return _fafdb
}
func (_dgdcb ST_VariableType) ValidateWithPath(path string) error {
	switch _dgdcb {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dgdcb))
	}
	return nil
}
func (_fdea ST_Direction) Validate() error { return _fdea.ValidateWithPath("") }

type ST_TextBlockDirection byte

func (_cbgff ST_BendPoint) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_eded := _b.Attr{}
	_eded.Name = name
	switch _cbgff {
	case ST_BendPointUnset:
		_eded.Value = ""
	case ST_BendPointBeg:
		_eded.Value = "beg"
	case ST_BendPointDef:
		_eded.Value = "def"
	case ST_BendPointEnd:
		_eded.Value = "end"
	}
	return _eded, nil
}
func (_adeg *ST_ParameterId) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dbgba, _ffca := d.Token()
	if _ffca != nil {
		return _ffca
	}
	if _adaef, _fgbgc := _dbgba.(_b.EndElement); _fgbgc && _adaef.Name == start.Name {
		*_adeg = 1
		return nil
	}
	if _ggcac, _abdb := _dbgba.(_b.CharData); !_abdb {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dbgba)
	} else {
		switch string(_ggcac) {
		case "":
			*_adeg = 0
		case "horzAlign":
			*_adeg = 1
		case "vertAlign":
			*_adeg = 2
		case "chDir":
			*_adeg = 3
		case "chAlign":
			*_adeg = 4
		case "secChAlign":
			*_adeg = 5
		case "linDir":
			*_adeg = 6
		case "secLinDir":
			*_adeg = 7
		case "stElem":
			*_adeg = 8
		case "bendPt":
			*_adeg = 9
		case "connRout":
			*_adeg = 10
		case "begSty":
			*_adeg = 11
		case "endSty":
			*_adeg = 12
		case "dim":
			*_adeg = 13
		case "rotPath":
			*_adeg = 14
		case "ctrShpMap":
			*_adeg = 15
		case "nodeHorzAlign":
			*_adeg = 16
		case "nodeVertAlign":
			*_adeg = 17
		case "fallback":
			*_adeg = 18
		case "txDir":
			*_adeg = 19
		case "pyraAcctPos":
			*_adeg = 20
		case "pyraAcctTxMar":
			*_adeg = 21
		case "txBlDir":
			*_adeg = 22
		case "txAnchorHorz":
			*_adeg = 23
		case "txAnchorVert":
			*_adeg = 24
		case "txAnchorHorzCh":
			*_adeg = 25
		case "txAnchorVertCh":
			*_adeg = 26
		case "parTxLTRAlign":
			*_adeg = 27
		case "parTxRTLAlign":
			*_adeg = 28
		case "shpTxLTRAlignCh":
			*_adeg = 29
		case "shpTxRTLAlignCh":
			*_adeg = 30
		case "autoTxRot":
			*_adeg = 31
		case "grDir":
			*_adeg = 32
		case "flowDir":
			*_adeg = 33
		case "contDir":
			*_adeg = 34
		case "bkpt":
			*_adeg = 35
		case "off":
			*_adeg = 36
		case "hierAlign":
			*_adeg = 37
		case "bkPtFixedVal":
			*_adeg = 38
		case "stBulletLvl":
			*_adeg = 39
		case "stAng":
			*_adeg = 40
		case "spanAng":
			*_adeg = 41
		case "ar":
			*_adeg = 42
		case "lnSpPar":
			*_adeg = 43
		case "lnSpAfParP":
			*_adeg = 44
		case "lnSpCh":
			*_adeg = 45
		case "lnSpAfChP":
			*_adeg = 46
		case "rtShortDist":
			*_adeg = 47
		case "alignTx":
			*_adeg = 48
		case "pyraLvlNode":
			*_adeg = 49
		case "pyraAcctBkgdNode":
			*_adeg = 50
		case "pyraAcctTxNode":
			*_adeg = 51
		case "srcNode":
			*_adeg = 52
		case "dstNode":
			*_adeg = 53
		case "begPts":
			*_adeg = 54
		case "endPts":
			*_adeg = 55
		}
	}
	_dbgba, _ffca = d.Token()
	if _ffca != nil {
		return _ffca
	}
	if _ffbcc, _bccgb := _dbgba.(_b.EndElement); _bccgb && _ffbcc.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dbgba)
}
func (_dddac *ST_ParameterVal) Validate() error { return _dddac.ValidateWithPath("") }
func NewStyleDef() *StyleDef {
	_gebae := &StyleDef{}
	_gebae.CT_StyleDefinition = *NewCT_StyleDefinition()
	return _gebae
}
func NewCT_Cxn() *CT_Cxn { _ced := &CT_Cxn{}; return _ced }

type CT_Colors struct {
	MethAttr       ST_ClrAppMethod
	HueDirAttr     ST_HueDir
	EG_ColorChoice []*_f.EG_ColorChoice
}

func (_dabde ST_FunctionType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dabde.String(), start)
}

type ST_LinearDirection byte

func (_dgfg ST_NodeVerticalAlignment) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_facfc := _b.Attr{}
	_facfc.Name = name
	switch _dgfg {
	case ST_NodeVerticalAlignmentUnset:
		_facfc.Value = ""
	case ST_NodeVerticalAlignmentT:
		_facfc.Value = "t"
	case ST_NodeVerticalAlignmentMid:
		_facfc.Value = "mid"
	case ST_NodeVerticalAlignmentB:
		_facfc.Value = "b"
	}
	return _facfc, nil
}
func (_eaff *CT_OrgChart) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _eaff.ValAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025d", _eecbc(*_eaff.ValAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_ebca ST_BoolOperator) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_efef := _b.Attr{}
	_efef.Name = name
	switch _ebca {
	case ST_BoolOperatorUnset:
		_efef.Value = ""
	case ST_BoolOperatorNone:
		_efef.Value = "none"
	case ST_BoolOperatorEqu:
		_efef.Value = "equ"
	case ST_BoolOperatorGte:
		_efef.Value = "gte"
	case ST_BoolOperatorLte:
		_efef.Value = "lte"
	}
	return _efef, nil
}

// Validate validates the CT_Description and its children
func (_bdbd *CT_Description) Validate() error { return _bdbd.ValidateWithPath("CT_Description") }
func (_bgad *CT_PtList) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_dbca:
	for {
		_dfeg, _ffea := d.Token()
		if _ffea != nil {
			return _ffea
		}
		switch _gdec := _dfeg.(type) {
		case _b.StartElement:
			switch _gdec.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "pt"}:
				_egff := NewCT_Pt()
				if _gcbcb := d.DecodeElement(_egff, &_gdec); _gcbcb != nil {
					return _gcbcb
				}
				_bgad.Pt = append(_bgad.Pt, _egff)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element on CT_PtList \u0025v", _gdec.Name)
				if _ddd := d.Skip(); _ddd != nil {
					return _ddd
				}
			}
		case _b.EndElement:
			break _dbca
		case _b.CharData:
		}
	}
	return nil
}
func (_aecde ST_FlowDirection) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_aecde.String(), start)
}
func (_eeeg *CT_SDCategories) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_ffbde:
	for {
		_cfga, _bgbfd := d.Token()
		if _bgbfd != nil {
			return _bgbfd
		}
		switch _dagg := _cfga.(type) {
		case _b.StartElement:
			switch _dagg.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "cat"}:
				_gdce := NewCT_SDCategory()
				if _gfgg := d.DecodeElement(_gdce, &_dagg); _gfgg != nil {
					return _gfgg
				}
				_eeeg.Cat = append(_eeeg.Cat, _gdce)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SDCategories\u0020\u0025v", _dagg.Name)
				if _gebc := d.Skip(); _gebc != nil {
					return _gebc
				}
			}
		case _b.EndElement:
			break _ffbde
		case _b.CharData:
		}
	}
	return nil
}
func (_cbee *CT_Constraint) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dbda := range start.Attr {
		if _dbda.Name.Local == "op" {
			_cbee.OpAttr.UnmarshalXMLAttr(_dbda)
			continue
		}
		if _dbda.Name.Local == "val" {
			_bbea, _geggg := _d.ParseFloat(_dbda.Value, 64)
			if _geggg != nil {
				return _geggg
			}
			_cbee.ValAttr = &_bbea
			continue
		}
		if _dbda.Name.Local == "fact" {
			_adgd, _cge := _d.ParseFloat(_dbda.Value, 64)
			if _cge != nil {
				return _cge
			}
			_cbee.FactAttr = &_adgd
			continue
		}
		if _dbda.Name.Local == "type" {
			_cbee.TypeAttr.UnmarshalXMLAttr(_dbda)
			continue
		}
		if _dbda.Name.Local == "for" {
			_cbee.ForAttr.UnmarshalXMLAttr(_dbda)
			continue
		}
		if _dbda.Name.Local == "forName" {
			_fgb, _fagf := _dbda.Value, error(nil)
			if _fagf != nil {
				return _fagf
			}
			_cbee.ForNameAttr = &_fgb
			continue
		}
		if _dbda.Name.Local == "ptType" {
			_cbee.PtTypeAttr.UnmarshalXMLAttr(_dbda)
			continue
		}
		if _dbda.Name.Local == "refType" {
			_cbee.RefTypeAttr.UnmarshalXMLAttr(_dbda)
			continue
		}
		if _dbda.Name.Local == "refFor" {
			_cbee.RefForAttr.UnmarshalXMLAttr(_dbda)
			continue
		}
		if _dbda.Name.Local == "refForName" {
			_gebf, _ccgdd := _dbda.Value, error(nil)
			if _ccgdd != nil {
				return _ccgdd
			}
			_cbee.RefForNameAttr = &_gebf
			continue
		}
		if _dbda.Name.Local == "refPtType" {
			_cbee.RefPtTypeAttr.UnmarshalXMLAttr(_dbda)
			continue
		}
	}
_afgd:
	for {
		_egf, _begc := d.Token()
		if _begc != nil {
			return _begc
		}
		switch _ffgd := _egf.(type) {
		case _b.StartElement:
			switch _ffgd.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_cbee.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _gbed := d.DecodeElement(_cbee.ExtLst, &_ffgd); _gbed != nil {
					return _gbed
				}
			default:
				_ea.Log("skipping unsupported element\u0020on\u0020CT_Constraint \u0025v", _ffgd.Name)
				if _dcaf := d.Skip(); _dcaf != nil {
					return _dcaf
				}
			}
		case _b.EndElement:
			break _afgd
		case _b.CharData:
		}
	}
	return nil
}
func (_dffca *ST_CxnType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dffca = 0
	case "parOf":
		*_dffca = 1
	case "presOf":
		*_dffca = 2
	case "presParOf":
		*_dffca = 3
	case "unknownRelationship":
		*_dffca = 4
	}
	return nil
}
func (_cfe *CT_Parameter) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cfe.TypeAttr = ST_ParameterId(1)
	for _, _eba := range start.Attr {
		if _eba.Name.Local == "type" {
			_cfe.TypeAttr.UnmarshalXMLAttr(_eba)
			continue
		}
		if _eba.Name.Local == "val" {
			_bead, _caad := ParseUnionST_ParameterVal(_eba.Value)
			if _caad != nil {
				return _caad
			}
			_cfe.ValAttr = _bead
			continue
		}
	}
	for {
		_ggbac, _eebc := d.Token()
		if _eebc != nil {
			return _a.Errorf("parsing\u0020CT_Parameter:\u0020\u0025s", _eebc)
		}
		if _bbcdf, _eec := _ggbac.(_b.EndElement); _eec && _bbcdf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dgaf *ST_PrSetCustVal) Validate() error { return _dgaf.ValidateWithPath("") }
func NewCT_StyleDefinitionHeader() *CT_StyleDefinitionHeader {
	_caac := &CT_StyleDefinitionHeader{}
	return _caac
}
func (_egcfg *CT_When) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _egcfg.NameAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "name"}, Value: _a.Sprintf("\u0025v", *_egcfg.NameAttr)})
	}
	_gadb, _gecad := _egcfg.FuncAttr.MarshalXMLAttr(_b.Name{Local: "func"})
	if _gecad != nil {
		return _gecad
	}
	start.Attr = append(start.Attr, _gadb)
	if _egcfg.ArgAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "arg"}, Value: _a.Sprintf("\u0025v", *_egcfg.ArgAttr)})
	}
	_gadb, _gecad = _egcfg.OpAttr.MarshalXMLAttr(_b.Name{Local: "op"})
	if _gecad != nil {
		return _gecad
	}
	start.Attr = append(start.Attr, _gadb)
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025v", _egcfg.ValAttr)})
	if _egcfg.AxisAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "axis"}, Value: _a.Sprintf("\u0025v", *_egcfg.AxisAttr)})
	}
	if _egcfg.PtTypeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "ptType"}, Value: _a.Sprintf("\u0025v", *_egcfg.PtTypeAttr)})
	}
	if _egcfg.HideLastTransAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "hideLastTrans"}, Value: _a.Sprintf("\u0025v", *_egcfg.HideLastTransAttr)})
	}
	if _egcfg.StAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "st"}, Value: _a.Sprintf("\u0025v", *_egcfg.StAttr)})
	}
	if _egcfg.CntAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cnt"}, Value: _a.Sprintf("\u0025v", *_egcfg.CntAttr)})
	}
	if _egcfg.StepAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "step"}, Value: _a.Sprintf("\u0025v", *_egcfg.StepAttr)})
	}
	e.EncodeToken(start)
	if _egcfg.Alg != nil {
		_befa := _b.StartElement{Name: _b.Name{Local: "alg"}}
		for _, _abgb := range _egcfg.Alg {
			e.EncodeElement(_abgb, _befa)
		}
	}
	if _egcfg.Shape != nil {
		_gece := _b.StartElement{Name: _b.Name{Local: "shape"}}
		for _, _cecg := range _egcfg.Shape {
			e.EncodeElement(_cecg, _gece)
		}
	}
	if _egcfg.PresOf != nil {
		_cfdee := _b.StartElement{Name: _b.Name{Local: "presOf"}}
		for _, _cgffa := range _egcfg.PresOf {
			e.EncodeElement(_cgffa, _cfdee)
		}
	}
	if _egcfg.ConstrLst != nil {
		_cafg := _b.StartElement{Name: _b.Name{Local: "constrLst"}}
		for _, _ccgb := range _egcfg.ConstrLst {
			e.EncodeElement(_ccgb, _cafg)
		}
	}
	if _egcfg.RuleLst != nil {
		_gdbg := _b.StartElement{Name: _b.Name{Local: "ruleLst"}}
		for _, _eaeea := range _egcfg.RuleLst {
			e.EncodeElement(_eaeea, _gdbg)
		}
	}
	if _egcfg.ForEach != nil {
		_gadc := _b.StartElement{Name: _b.Name{Local: "forEach"}}
		for _, _cbab := range _egcfg.ForEach {
			e.EncodeElement(_cbab, _gadc)
		}
	}
	if _egcfg.LayoutNode != nil {
		_gaed := _b.StartElement{Name: _b.Name{Local: "layoutNode"}}
		for _, _cbcd := range _egcfg.LayoutNode {
			e.EncodeElement(_cbcd, _gaed)
		}
	}
	if _egcfg.Choose != nil {
		_ebcd := _b.StartElement{Name: _b.Name{Local: "choose"}}
		for _, _edgc := range _egcfg.Choose {
			e.EncodeElement(_edgc, _ebcd)
		}
	}
	if _egcfg.ExtLst != nil {
		_dfaaf := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		for _, _aaedf := range _egcfg.ExtLst {
			e.EncodeElement(_aaedf, _dfaaf)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Shape and its children
func (_dgee *CT_Shape) Validate() error { return _dgee.ValidateWithPath("CT_Shape") }

type CT_When struct {
	NameAttr          *string
	FuncAttr          ST_FunctionType
	ArgAttr           *ST_FunctionArgument
	OpAttr            ST_FunctionOperator
	ValAttr           ST_FunctionValue
	Alg               []*CT_Algorithm
	Shape             []*CT_Shape
	PresOf            []*CT_PresentationOf
	ConstrLst         []*CT_Constraints
	RuleLst           []*CT_Rules
	ForEach           []*CT_ForEach
	LayoutNode        []*CT_LayoutNode
	Choose            []*CT_Choose
	ExtLst            []*_f.CT_OfficeArtExtensionList
	AxisAttr          *ST_AxisTypes
	PtTypeAttr        *ST_ElementTypes
	HideLastTransAttr *ST_Booleans
	StAttr            *ST_Ints
	CntAttr           *ST_UnsignedInts
	StepAttr          *ST_Ints
}

func (_eefb ST_SecondaryChildAlignment) String() string {
	switch _eefb {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "t"
	case 3:
		return "b"
	case 4:
		return "l"
	case 5:
		return "r"
	}
	return ""
}
func (_cfad *ST_ElementType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_aecbbd, _efec := d.Token()
	if _efec != nil {
		return _efec
	}
	if _fddee, _bffb := _aecbbd.(_b.EndElement); _bffb && _fddee.Name == start.Name {
		*_cfad = 1
		return nil
	}
	if _daedd, _eaadg := _aecbbd.(_b.CharData); !_eaadg {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aecbbd)
	} else {
		switch string(_daedd) {
		case "":
			*_cfad = 0
		case "all":
			*_cfad = 1
		case "doc":
			*_cfad = 2
		case "node":
			*_cfad = 3
		case "norm":
			*_cfad = 4
		case "nonNorm":
			*_cfad = 5
		case "asst":
			*_cfad = 6
		case "nonAsst":
			*_cfad = 7
		case "parTrans":
			*_cfad = 8
		case "pres":
			*_cfad = 9
		case "sibTrans":
			*_cfad = 10
		}
	}
	_aecbbd, _efec = d.Token()
	if _efec != nil {
		return _efec
	}
	if _babcc, _gdeca := _aecbbd.(_b.EndElement); _gdeca && _babcc.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aecbbd)
}

// Validate validates the CT_AdjLst and its children
func (_gee *CT_AdjLst) Validate() error { return _gee.ValidateWithPath("CT_AdjLst") }
func NewCT_Shape() *CT_Shape            { _dbded := &CT_Shape{}; return _dbded }

type ST_RotationPath byte

// Validate validates the CT_Rules and its children
func (_aecbb *CT_Rules) Validate() error { return _aecbb.ValidateWithPath("CT_Rules") }

// Validate validates the AG_ConstraintAttributes and its children
func (_ab *AG_ConstraintAttributes) Validate() error {
	return _ab.ValidateWithPath("AG_ConstraintAttributes")
}
func (_daeb *ST_FunctionType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ggdfg, _dagd := d.Token()
	if _dagd != nil {
		return _dagd
	}
	if _gaggb, _gdea := _ggdfg.(_b.EndElement); _gdea && _gaggb.Name == start.Name {
		*_daeb = 1
		return nil
	}
	if _bbfec, _gabad := _ggdfg.(_b.CharData); !_gabad {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ggdfg)
	} else {
		switch string(_bbfec) {
		case "":
			*_daeb = 0
		case "cnt":
			*_daeb = 1
		case "pos":
			*_daeb = 2
		case "revPos":
			*_daeb = 3
		case "posEven":
			*_daeb = 4
		case "posOdd":
			*_daeb = 5
		case "var":
			*_daeb = 6
		case "depth":
			*_daeb = 7
		case "maxDepth":
			*_daeb = 8
		}
	}
	_ggdfg, _dagd = d.Token()
	if _dagd != nil {
		return _dagd
	}
	if _cffa, _dcfe := _ggdfg.(_b.EndElement); _dcfe && _cffa.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ggdfg)
}
func (_eefff ST_ChildDirection) Validate() error { return _eefff.ValidateWithPath("") }
func (_dggg *CT_LayoutVariablePropertySet) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_agaef:
	for {
		_ebbf, _aaef := d.Token()
		if _aaef != nil {
			return _aaef
		}
		switch _caga := _ebbf.(type) {
		case _b.StartElement:
			switch _caga.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "orgChart"}:
				_dggg.OrgChart = NewCT_OrgChart()
				if _bcdc := d.DecodeElement(_dggg.OrgChart, &_caga); _bcdc != nil {
					return _bcdc
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "chMax"}:
				_dggg.ChMax = NewCT_ChildMax()
				if _ecbf := d.DecodeElement(_dggg.ChMax, &_caga); _ecbf != nil {
					return _ecbf
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "chPref"}:
				_dggg.ChPref = NewCT_ChildPref()
				if _bcdb := d.DecodeElement(_dggg.ChPref, &_caga); _bcdb != nil {
					return _bcdb
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "bulletEnabled"}:
				_dggg.BulletEnabled = NewCT_BulletEnabled()
				if _geccb := d.DecodeElement(_dggg.BulletEnabled, &_caga); _geccb != nil {
					return _geccb
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "dir"}:
				_dggg.Dir = NewCT_Direction()
				if _bcda := d.DecodeElement(_dggg.Dir, &_caga); _bcda != nil {
					return _bcda
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "hierBranch"}:
				_dggg.HierBranch = NewCT_HierBranchStyle()
				if _geaf := d.DecodeElement(_dggg.HierBranch, &_caga); _geaf != nil {
					return _geaf
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "animOne"}:
				_dggg.AnimOne = NewCT_AnimOne()
				if _cdagd := d.DecodeElement(_dggg.AnimOne, &_caga); _cdagd != nil {
					return _cdagd
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "animLvl"}:
				_dggg.AnimLvl = NewCT_AnimLvl()
				if _fcda := d.DecodeElement(_dggg.AnimLvl, &_caga); _fcda != nil {
					return _fcda
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "resizeHandles"}:
				_dggg.ResizeHandles = NewCT_ResizeHandles()
				if _dfd := d.DecodeElement(_dggg.ResizeHandles, &_caga); _dfd != nil {
					return _dfd
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element on\u0020CT_LayoutVariablePropertySet\u0020\u0025v", _caga.Name)
				if _cged := d.Skip(); _cged != nil {
					return _cged
				}
			}
		case _b.EndElement:
			break _agaef
		case _b.CharData:
		}
	}
	return nil
}
func (_abfg ST_FunctionOperator) ValidateWithPath(path string) error {
	switch _abfg {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_abfg))
	}
	return nil
}
func (_edfd ST_CenterShapeMapping) String() string {
	switch _edfd {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "fNode"
	}
	return ""
}
func (_dedd ST_HierBranchStyle) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dedd.String(), start)
}

const (
	ST_ConstraintTypeUnset         ST_ConstraintType = 0
	ST_ConstraintTypeNone          ST_ConstraintType = 1
	ST_ConstraintTypeAlignOff      ST_ConstraintType = 2
	ST_ConstraintTypeBegMarg       ST_ConstraintType = 3
	ST_ConstraintTypeBendDist      ST_ConstraintType = 4
	ST_ConstraintTypeBegPad        ST_ConstraintType = 5
	ST_ConstraintTypeB             ST_ConstraintType = 6
	ST_ConstraintTypeBMarg         ST_ConstraintType = 7
	ST_ConstraintTypeBOff          ST_ConstraintType = 8
	ST_ConstraintTypeCtrX          ST_ConstraintType = 9
	ST_ConstraintTypeCtrXOff       ST_ConstraintType = 10
	ST_ConstraintTypeCtrY          ST_ConstraintType = 11
	ST_ConstraintTypeCtrYOff       ST_ConstraintType = 12
	ST_ConstraintTypeConnDist      ST_ConstraintType = 13
	ST_ConstraintTypeDiam          ST_ConstraintType = 14
	ST_ConstraintTypeEndMarg       ST_ConstraintType = 15
	ST_ConstraintTypeEndPad        ST_ConstraintType = 16
	ST_ConstraintTypeH             ST_ConstraintType = 17
	ST_ConstraintTypeHArH          ST_ConstraintType = 18
	ST_ConstraintTypeHOff          ST_ConstraintType = 19
	ST_ConstraintTypeL             ST_ConstraintType = 20
	ST_ConstraintTypeLMarg         ST_ConstraintType = 21
	ST_ConstraintTypeLOff          ST_ConstraintType = 22
	ST_ConstraintTypeR             ST_ConstraintType = 23
	ST_ConstraintTypeRMarg         ST_ConstraintType = 24
	ST_ConstraintTypeROff          ST_ConstraintType = 25
	ST_ConstraintTypePrimFontSz    ST_ConstraintType = 26
	ST_ConstraintTypePyraAcctRatio ST_ConstraintType = 27
	ST_ConstraintTypeSecFontSz     ST_ConstraintType = 28
	ST_ConstraintTypeSibSp         ST_ConstraintType = 29
	ST_ConstraintTypeSecSibSp      ST_ConstraintType = 30
	ST_ConstraintTypeSp            ST_ConstraintType = 31
	ST_ConstraintTypeStemThick     ST_ConstraintType = 32
	ST_ConstraintTypeT             ST_ConstraintType = 33
	ST_ConstraintTypeTMarg         ST_ConstraintType = 34
	ST_ConstraintTypeTOff          ST_ConstraintType = 35
	ST_ConstraintTypeUserA         ST_ConstraintType = 36
	ST_ConstraintTypeUserB         ST_ConstraintType = 37
	ST_ConstraintTypeUserC         ST_ConstraintType = 38
	ST_ConstraintTypeUserD         ST_ConstraintType = 39
	ST_ConstraintTypeUserE         ST_ConstraintType = 40
	ST_ConstraintTypeUserF         ST_ConstraintType = 41
	ST_ConstraintTypeUserG         ST_ConstraintType = 42
	ST_ConstraintTypeUserH         ST_ConstraintType = 43
	ST_ConstraintTypeUserI         ST_ConstraintType = 44
	ST_ConstraintTypeUserJ         ST_ConstraintType = 45
	ST_ConstraintTypeUserK         ST_ConstraintType = 46
	ST_ConstraintTypeUserL         ST_ConstraintType = 47
	ST_ConstraintTypeUserM         ST_ConstraintType = 48
	ST_ConstraintTypeUserN         ST_ConstraintType = 49
	ST_ConstraintTypeUserO         ST_ConstraintType = 50
	ST_ConstraintTypeUserP         ST_ConstraintType = 51
	ST_ConstraintTypeUserQ         ST_ConstraintType = 52
	ST_ConstraintTypeUserR         ST_ConstraintType = 53
	ST_ConstraintTypeUserS         ST_ConstraintType = 54
	ST_ConstraintTypeUserT         ST_ConstraintType = 55
	ST_ConstraintTypeUserU         ST_ConstraintType = 56
	ST_ConstraintTypeUserV         ST_ConstraintType = 57
	ST_ConstraintTypeUserW         ST_ConstraintType = 58
	ST_ConstraintTypeUserX         ST_ConstraintType = 59
	ST_ConstraintTypeUserY         ST_ConstraintType = 60
	ST_ConstraintTypeUserZ         ST_ConstraintType = 61
	ST_ConstraintTypeW             ST_ConstraintType = 62
	ST_ConstraintTypeWArH          ST_ConstraintType = 63
	ST_ConstraintTypeWOff          ST_ConstraintType = 64
)

func (_gda *AG_IteratorAttributes) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _daa := range start.Attr {
		if _daa.Name.Local == "axis" {
			_ad, _dac := ParseSliceST_AxisTypes(_daa.Value)
			if _dac != nil {
				return _dac
			}
			_gda.AxisAttr = &_ad
			continue
		}
		if _daa.Name.Local == "ptType" {
			_ba, _cab := ParseSliceST_ElementTypes(_daa.Value)
			if _cab != nil {
				return _cab
			}
			_gda.PtTypeAttr = &_ba
			continue
		}
		if _daa.Name.Local == "hideLastTrans" {
			_cbg, _aeb := ParseSliceST_Booleans(_daa.Value)
			if _aeb != nil {
				return _aeb
			}
			_gda.HideLastTransAttr = &_cbg
			continue
		}
		if _daa.Name.Local == "st" {
			_gdg, _ddg := ParseSliceST_Ints(_daa.Value)
			if _ddg != nil {
				return _ddg
			}
			_gda.StAttr = &_gdg
			continue
		}
		if _daa.Name.Local == "cnt" {
			_fe, _baa := ParseSliceST_UnsignedInts(_daa.Value)
			if _baa != nil {
				return _baa
			}
			_gda.CntAttr = &_fe
			continue
		}
		if _daa.Name.Local == "step" {
			_cd, _ee := ParseSliceST_Ints(_daa.Value)
			if _ee != nil {
				return _ee
			}
			_gda.StepAttr = &_cd
			continue
		}
	}
	for {
		_eae, _fdc := d.Token()
		if _fdc != nil {
			return _a.Errorf("parsing\u0020AG_IteratorAttributes:\u0020\u0025s", _fdc)
		}
		if _ccbg, _cba := _eae.(_b.EndElement); _cba && _ccbg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cffdbd *ST_RotationPath) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_cffdbd = 0
	case "none":
		*_cffdbd = 1
	case "alongPath":
		*_cffdbd = 2
	}
	return nil
}
func (_bdfdf ST_Direction) ValidateWithPath(path string) error {
	switch _bdfdf {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bdfdf))
	}
	return nil
}
func (_ddgaf *ST_VerticalAlignment) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fffd, _cccdga := d.Token()
	if _cccdga != nil {
		return _cccdga
	}
	if _gaeb, _decf := _fffd.(_b.EndElement); _decf && _gaeb.Name == start.Name {
		*_ddgaf = 1
		return nil
	}
	if _bbacb, _afdeg := _fffd.(_b.CharData); !_afdeg {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fffd)
	} else {
		switch string(_bbacb) {
		case "":
			*_ddgaf = 0
		case "t":
			*_ddgaf = 1
		case "mid":
			*_ddgaf = 2
		case "b":
			*_ddgaf = 3
		case "none":
			*_ddgaf = 4
		}
	}
	_fffd, _cccdga = d.Token()
	if _cccdga != nil {
		return _cccdga
	}
	if _agfbf, _afgae := _fffd.(_b.EndElement); _afgae && _agfbf.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fffd)
}
func (_gfce *ST_ConstraintType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ecgeg, _ccdd := d.Token()
	if _ccdd != nil {
		return _ccdd
	}
	if _egacg, _fdgcb := _ecgeg.(_b.EndElement); _fdgcb && _egacg.Name == start.Name {
		*_gfce = 1
		return nil
	}
	if _edbd, _cgbga := _ecgeg.(_b.CharData); !_cgbga {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ecgeg)
	} else {
		switch string(_edbd) {
		case "":
			*_gfce = 0
		case "none":
			*_gfce = 1
		case "alignOff":
			*_gfce = 2
		case "begMarg":
			*_gfce = 3
		case "bendDist":
			*_gfce = 4
		case "begPad":
			*_gfce = 5
		case "b":
			*_gfce = 6
		case "bMarg":
			*_gfce = 7
		case "bOff":
			*_gfce = 8
		case "ctrX":
			*_gfce = 9
		case "ctrXOff":
			*_gfce = 10
		case "ctrY":
			*_gfce = 11
		case "ctrYOff":
			*_gfce = 12
		case "connDist":
			*_gfce = 13
		case "diam":
			*_gfce = 14
		case "endMarg":
			*_gfce = 15
		case "endPad":
			*_gfce = 16
		case "h":
			*_gfce = 17
		case "hArH":
			*_gfce = 18
		case "hOff":
			*_gfce = 19
		case "l":
			*_gfce = 20
		case "lMarg":
			*_gfce = 21
		case "lOff":
			*_gfce = 22
		case "r":
			*_gfce = 23
		case "rMarg":
			*_gfce = 24
		case "rOff":
			*_gfce = 25
		case "primFontSz":
			*_gfce = 26
		case "pyraAcctRatio":
			*_gfce = 27
		case "secFontSz":
			*_gfce = 28
		case "sibSp":
			*_gfce = 29
		case "secSibSp":
			*_gfce = 30
		case "sp":
			*_gfce = 31
		case "stemThick":
			*_gfce = 32
		case "t":
			*_gfce = 33
		case "tMarg":
			*_gfce = 34
		case "tOff":
			*_gfce = 35
		case "userA":
			*_gfce = 36
		case "userB":
			*_gfce = 37
		case "userC":
			*_gfce = 38
		case "userD":
			*_gfce = 39
		case "userE":
			*_gfce = 40
		case "userF":
			*_gfce = 41
		case "userG":
			*_gfce = 42
		case "userH":
			*_gfce = 43
		case "userI":
			*_gfce = 44
		case "userJ":
			*_gfce = 45
		case "userK":
			*_gfce = 46
		case "userL":
			*_gfce = 47
		case "userM":
			*_gfce = 48
		case "userN":
			*_gfce = 49
		case "userO":
			*_gfce = 50
		case "userP":
			*_gfce = 51
		case "userQ":
			*_gfce = 52
		case "userR":
			*_gfce = 53
		case "userS":
			*_gfce = 54
		case "userT":
			*_gfce = 55
		case "userU":
			*_gfce = 56
		case "userV":
			*_gfce = 57
		case "userW":
			*_gfce = 58
		case "userX":
			*_gfce = 59
		case "userY":
			*_gfce = 60
		case "userZ":
			*_gfce = 61
		case "w":
			*_gfce = 62
		case "wArH":
			*_gfce = 63
		case "wOff":
			*_gfce = 64
		}
	}
	_ecgeg, _ccdd = d.Token()
	if _ccdd != nil {
		return _ccdd
	}
	if _bdbee, _abec := _ecgeg.(_b.EndElement); _abec && _bdbee.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ecgeg)
}
func NewCT_ElemPropSet() *CT_ElemPropSet { _fddaa := &CT_ElemPropSet{}; return _fddaa }
func (_cgfba ST_RotationPath) ValidateWithPath(path string) error {
	switch _cgfba {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cgfba))
	}
	return nil
}

const (
	ST_TextAnchorHorizontalUnset ST_TextAnchorHorizontal = 0
	ST_TextAnchorHorizontalNone  ST_TextAnchorHorizontal = 1
	ST_TextAnchorHorizontalCtr   ST_TextAnchorHorizontal = 2
)

func (_cegff ST_TextDirection) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_abcdg := _b.Attr{}
	_abcdg.Name = name
	switch _cegff {
	case ST_TextDirectionUnset:
		_abcdg.Value = ""
	case ST_TextDirectionFromT:
		_abcdg.Value = "fromT"
	case ST_TextDirectionFromB:
		_abcdg.Value = "fromB"
	}
	return _abcdg, nil
}
func (_cfaga *ST_FlowDirection) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gebg, _gccea := d.Token()
	if _gccea != nil {
		return _gccea
	}
	if _bbcg, _fbacd := _gebg.(_b.EndElement); _fbacd && _bbcg.Name == start.Name {
		*_cfaga = 1
		return nil
	}
	if _cbddg, _effcb := _gebg.(_b.CharData); !_effcb {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gebg)
	} else {
		switch string(_cbddg) {
		case "":
			*_cfaga = 0
		case "row":
			*_cfaga = 1
		case "col":
			*_cfaga = 2
		}
	}
	_gebg, _gccea = d.Token()
	if _gccea != nil {
		return _gccea
	}
	if _acbed, _ggfg := _gebg.(_b.EndElement); _ggfg && _acbed.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gebg)
}
func (_abefb *ST_PrSetCustVal) ValidateWithPath(path string) error {
	_eaea := []string{}
	if _abefb.ST_Percentage != nil {
		_eaea = append(_eaea, "ST_Percentage")
	}
	if _abefb.Int32 != nil {
		_eaea = append(_eaea, "Int32")
	}
	if len(_eaea) > 1 {
		return _a.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _eaea)
	}
	return nil
}
func NewCT_StyleDefinition() *CT_StyleDefinition { _becc := &CT_StyleDefinition{}; return _becc }
func (_dbff *ST_ChildDirection) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dbff = 0
	case "horz":
		*_dbff = 1
	case "vert":
		*_dbff = 2
	}
	return nil
}
func NewStyleDefHdr() *StyleDefHdr {
	_ffbcb := &StyleDefHdr{}
	_ffbcb.CT_StyleDefinitionHeader = *NewCT_StyleDefinitionHeader()
	return _ffbcb
}
func (_gfdbf ST_ChildOrderType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_aegca := _b.Attr{}
	_aegca.Name = name
	switch _gfdbf {
	case ST_ChildOrderTypeUnset:
		_aegca.Value = ""
	case ST_ChildOrderTypeB:
		_aegca.Value = "b"
	case ST_ChildOrderTypeT:
		_aegca.Value = "t"
	}
	return _aegca, nil
}
func (_efeb ST_AnimOneStr) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_eggbc := _b.Attr{}
	_eggbc.Name = name
	switch _efeb {
	case ST_AnimOneStrUnset:
		_eggbc.Value = ""
	case ST_AnimOneStrNone:
		_eggbc.Value = "none"
	case ST_AnimOneStrOne:
		_eggbc.Value = "one"
	case ST_AnimOneStrBranch:
		_eggbc.Value = "branch"
	}
	return _eggbc, nil
}
func NewCT_Adj() *CT_Adj { _eeg := &CT_Adj{}; _eeg.IdxAttr = 1; return _eeg }

// ValidateWithPath validates the CT_SDName and its children, prefixing error messages with path
func (_fbef *CT_SDName) ValidateWithPath(path string) error { return nil }
func (_afab *CT_LayoutNode) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _afab.NameAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "name"}, Value: _a.Sprintf("\u0025v", *_afab.NameAttr)})
	}
	if _afab.StyleLblAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "styleLbl"}, Value: _a.Sprintf("\u0025v", *_afab.StyleLblAttr)})
	}
	if _afab.ChOrderAttr != ST_ChildOrderTypeUnset {
		_cecb, _fbdd := _afab.ChOrderAttr.MarshalXMLAttr(_b.Name{Local: "chOrder"})
		if _fbdd != nil {
			return _fbdd
		}
		start.Attr = append(start.Attr, _cecb)
	}
	if _afab.MoveWithAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "moveWith"}, Value: _a.Sprintf("\u0025v", *_afab.MoveWithAttr)})
	}
	e.EncodeToken(start)
	if _afab.Alg != nil {
		_eebd := _b.StartElement{Name: _b.Name{Local: "alg"}}
		for _, _cbgd := range _afab.Alg {
			e.EncodeElement(_cbgd, _eebd)
		}
	}
	if _afab.Shape != nil {
		_fbcb := _b.StartElement{Name: _b.Name{Local: "shape"}}
		for _, _gfee := range _afab.Shape {
			e.EncodeElement(_gfee, _fbcb)
		}
	}
	if _afab.PresOf != nil {
		_afff := _b.StartElement{Name: _b.Name{Local: "presOf"}}
		for _, _egcg := range _afab.PresOf {
			e.EncodeElement(_egcg, _afff)
		}
	}
	if _afab.ConstrLst != nil {
		_gbegd := _b.StartElement{Name: _b.Name{Local: "constrLst"}}
		for _, _dde := range _afab.ConstrLst {
			e.EncodeElement(_dde, _gbegd)
		}
	}
	if _afab.RuleLst != nil {
		_adaf := _b.StartElement{Name: _b.Name{Local: "ruleLst"}}
		for _, _cfde := range _afab.RuleLst {
			e.EncodeElement(_cfde, _adaf)
		}
	}
	if _afab.VarLst != nil {
		_cfcd := _b.StartElement{Name: _b.Name{Local: "varLst"}}
		for _, _cbaa := range _afab.VarLst {
			e.EncodeElement(_cbaa, _cfcd)
		}
	}
	if _afab.ForEach != nil {
		_acae := _b.StartElement{Name: _b.Name{Local: "forEach"}}
		for _, _cdda := range _afab.ForEach {
			e.EncodeElement(_cdda, _acae)
		}
	}
	if _afab.LayoutNode != nil {
		_dgfa := _b.StartElement{Name: _b.Name{Local: "layoutNode"}}
		for _, _cbbg := range _afab.LayoutNode {
			e.EncodeElement(_cbbg, _dgfa)
		}
	}
	if _afab.Choose != nil {
		_bgaf := _b.StartElement{Name: _b.Name{Local: "choose"}}
		for _, _cdag := range _afab.Choose {
			e.EncodeElement(_cdag, _bgaf)
		}
	}
	if _afab.ExtLst != nil {
		_badd := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		for _, _fdb := range _afab.ExtLst {
			e.EncodeElement(_fdb, _badd)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type CT_CxnList struct{ Cxn []*CT_Cxn }

func (_dcfea *ST_TextDirection) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dcfea = 0
	case "fromT":
		*_dcfea = 1
	case "fromB":
		*_dcfea = 2
	}
	return nil
}
func (_fcfc ST_CxnType) Validate() error { return _fcfc.ValidateWithPath("") }

type CT_Name struct {
	LangAttr *string
	ValAttr  string
}

// ValidateWithPath validates the CT_DiagramDefinitionHeaderLst and its children, prefixing error messages with path
func (_eaad *CT_DiagramDefinitionHeaderLst) ValidateWithPath(path string) error {
	for _bbef, _gdeg := range _eaad.LayoutDefHdr {
		if _gbbb := _gdeg.ValidateWithPath(_a.Sprintf("\u0025s\u002fLayoutDefHdr\u005b\u0025d\u005d", path, _bbef)); _gbbb != nil {
			return _gbbb
		}
	}
	return nil
}
func (_becde ST_DiagramTextAlignment) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_cggf := _b.Attr{}
	_cggf.Name = name
	switch _becde {
	case ST_DiagramTextAlignmentUnset:
		_cggf.Value = ""
	case ST_DiagramTextAlignmentL:
		_cggf.Value = "l"
	case ST_DiagramTextAlignmentCtr:
		_cggf.Value = "ctr"
	case ST_DiagramTextAlignmentR:
		_cggf.Value = "r"
	}
	return _cggf, nil
}
func (_dcad ST_AnimLvlStr) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dcad.String(), start)
}

type CT_Direction struct{ ValAttr ST_Direction }

func (_ef *CT_CTCategory) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _afe := range start.Attr {
		if _afe.Name.Local == "type" {
			_dcdb, _faa := _afe.Value, error(nil)
			if _faa != nil {
				return _faa
			}
			_ef.TypeAttr = _dcdb
			continue
		}
		if _afe.Name.Local == "pri" {
			_efb, _ade := _d.ParseUint(_afe.Value, 10, 32)
			if _ade != nil {
				return _ade
			}
			_ef.PriAttr = uint32(_efb)
			continue
		}
	}
	for {
		_bfb, _cabb := d.Token()
		if _cabb != nil {
			return _a.Errorf("parsing\u0020CT_CTCategory:\u0020\u0025s", _cabb)
		}
		if _bfg, _dbcf := _bfb.(_b.EndElement); _dbcf && _bfg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gfdc ST_FallbackDimension) String() string {
	switch _gfdc {
	case 0:
		return ""
	case 1:
		return "1D"
	case 2:
		return "2D"
	}
	return ""
}

type ST_AutoTextRotation byte

// ValidateWithPath validates the CT_ElemPropSet and its children, prefixing error messages with path
func (_ggca *CT_ElemPropSet) ValidateWithPath(path string) error {
	if _ggca.PresAssocIDAttr != nil {
		if _cfb := _ggca.PresAssocIDAttr.ValidateWithPath(path + "\u002fPresAssocIDAttr"); _cfb != nil {
			return _cfb
		}
	}
	if _ggca.CustScaleXAttr != nil {
		if _bdge := _ggca.CustScaleXAttr.ValidateWithPath(path + "\u002fCustScaleXAttr"); _bdge != nil {
			return _bdge
		}
	}
	if _ggca.CustScaleYAttr != nil {
		if _eafe := _ggca.CustScaleYAttr.ValidateWithPath(path + "\u002fCustScaleYAttr"); _eafe != nil {
			return _eafe
		}
	}
	if _ggca.CustLinFactXAttr != nil {
		if _ebdc := _ggca.CustLinFactXAttr.ValidateWithPath(path + "\u002fCustLinFactXAttr"); _ebdc != nil {
			return _ebdc
		}
	}
	if _ggca.CustLinFactYAttr != nil {
		if _gfdac := _ggca.CustLinFactYAttr.ValidateWithPath(path + "\u002fCustLinFactYAttr"); _gfdac != nil {
			return _gfdac
		}
	}
	if _ggca.CustLinFactNeighborXAttr != nil {
		if _cbffd := _ggca.CustLinFactNeighborXAttr.ValidateWithPath(path + "\u002fCustLinFactNeighborXAttr"); _cbffd != nil {
			return _cbffd
		}
	}
	if _ggca.CustLinFactNeighborYAttr != nil {
		if _ggd := _ggca.CustLinFactNeighborYAttr.ValidateWithPath(path + "\u002fCustLinFactNeighborYAttr"); _ggd != nil {
			return _ggd
		}
	}
	if _ggca.CustRadScaleRadAttr != nil {
		if _cggdd := _ggca.CustRadScaleRadAttr.ValidateWithPath(path + "/CustRadScaleRadAttr"); _cggdd != nil {
			return _cggdd
		}
	}
	if _ggca.CustRadScaleIncAttr != nil {
		if _cbefe := _ggca.CustRadScaleIncAttr.ValidateWithPath(path + "/CustRadScaleIncAttr"); _cbefe != nil {
			return _cbefe
		}
	}
	if _ggca.PresLayoutVars != nil {
		if _eac := _ggca.PresLayoutVars.ValidateWithPath(path + "\u002fPresLayoutVars"); _eac != nil {
			return _eac
		}
	}
	if _ggca.Style != nil {
		if _dge := _ggca.Style.ValidateWithPath(path + "\u002fStyle"); _dge != nil {
			return _dge
		}
	}
	return nil
}
func (_caeb ST_AxisType) String() string {
	switch _caeb {
	case 0:
		return ""
	case 1:
		return "self"
	case 2:
		return "ch"
	case 3:
		return "des"
	case 4:
		return "desOrSelf"
	case 5:
		return "par"
	case 6:
		return "ancst"
	case 7:
		return "ancstOrSelf"
	case 8:
		return "followSib"
	case 9:
		return "precedSib"
	case 10:
		return "follow"
	case 11:
		return "preced"
	case 12:
		return "root"
	case 13:
		return "none"
	}
	return ""
}

// Validate validates the CT_PresentationOf and its children
func (_fgdb *CT_PresentationOf) Validate() error { return _fgdb.ValidateWithPath("CT_PresentationOf") }
func (_effa *ST_FunctionType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_effa = 0
	case "cnt":
		*_effa = 1
	case "pos":
		*_effa = 2
	case "revPos":
		*_effa = 3
	case "posEven":
		*_effa = 4
	case "posOdd":
		*_effa = 5
	case "var":
		*_effa = 6
	case "depth":
		*_effa = 7
	case "maxDepth":
		*_effa = 8
	}
	return nil
}
func (_badag ST_ArrowheadStyle) ValidateWithPath(path string) error {
	switch _badag {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_badag))
	}
	return nil
}
func (_agb *CT_DataModel) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	_gbeg := _b.StartElement{Name: _b.Name{Local: "ptLst"}}
	e.EncodeElement(_agb.PtLst, _gbeg)
	if _agb.CxnLst != nil {
		_fbgd := _b.StartElement{Name: _b.Name{Local: "cxnLst"}}
		e.EncodeElement(_agb.CxnLst, _fbgd)
	}
	if _agb.Bg != nil {
		_dgag := _b.StartElement{Name: _b.Name{Local: "bg"}}
		e.EncodeElement(_agb.Bg, _dgag)
	}
	if _agb.Whole != nil {
		_beac := _b.StartElement{Name: _b.Name{Local: "whole"}}
		e.EncodeElement(_agb.Whole, _beac)
	}
	if _agb.ExtLst != nil {
		_ecfa := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_agb.ExtLst, _ecfa)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type CT_PtList struct{ Pt []*CT_Pt }

func (_fab *CT_ColorTransform) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ccf := range start.Attr {
		if _ccf.Name.Local == "uniqueId" {
			_gcfg, _afb := _ccf.Value, error(nil)
			if _afb != nil {
				return _afb
			}
			_fab.UniqueIdAttr = &_gcfg
			continue
		}
		if _ccf.Name.Local == "minVer" {
			_eggb, _cccd := _ccf.Value, error(nil)
			if _cccd != nil {
				return _cccd
			}
			_fab.MinVerAttr = &_eggb
			continue
		}
	}
_deba:
	for {
		_baf, _dfe := d.Token()
		if _dfe != nil {
			return _dfe
		}
		switch _dga := _baf.(type) {
		case _b.StartElement:
			switch _dga.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_cdgb := NewCT_CTName()
				if _cgbb := d.DecodeElement(_cdgb, &_dga); _cgbb != nil {
					return _cgbb
				}
				_fab.Title = append(_fab.Title, _cdgb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_beb := NewCT_CTDescription()
				if _eaa := d.DecodeElement(_beb, &_dga); _eaa != nil {
					return _eaa
				}
				_fab.Desc = append(_fab.Desc, _beb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_fab.CatLst = NewCT_CTCategories()
				if _gffg := d.DecodeElement(_fab.CatLst, &_dga); _gffg != nil {
					return _gffg
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "styleLbl"}:
				_dgb := NewCT_CTStyleLabel()
				if _gegg := d.DecodeElement(_dgb, &_dga); _gegg != nil {
					return _gegg
				}
				_fab.StyleLbl = append(_fab.StyleLbl, _dgb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_fab.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _bec := d.DecodeElement(_fab.ExtLst, &_dga); _bec != nil {
					return _bec
				}
			default:
				_ea.Log("skipping unsupported\u0020element\u0020on\u0020CT_ColorTransform\u0020\u0025v", _dga.Name)
				if _bfgc := d.Skip(); _bfgc != nil {
					return _bfgc
				}
			}
		case _b.EndElement:
			break _deba
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Constraints and its children, prefixing error messages with path
func (_ffdde *CT_Constraints) ValidateWithPath(path string) error {
	for _fdaa, _bgfd := range _ffdde.Constr {
		if _aaaa := _bgfd.ValidateWithPath(_a.Sprintf("\u0025s\u002fConstr\u005b\u0025d\u005d", path, _fdaa)); _aaaa != nil {
			return _aaaa
		}
	}
	return nil
}

type CT_TextProps struct {
	Sp3d   *_f.CT_Shape3D
	FlatTx *_f.CT_FlatText
}

func (_fbf *CT_Category) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "type"}, Value: _a.Sprintf("\u0025v", _fbf.TypeAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "pri"}, Value: _a.Sprintf("\u0025v", _fbf.PriAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_dbece *ST_LinearDirection) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ebcg, _acege := d.Token()
	if _acege != nil {
		return _acege
	}
	if _adafa, _fggdd := _ebcg.(_b.EndElement); _fggdd && _adafa.Name == start.Name {
		*_dbece = 1
		return nil
	}
	if _eccc, _decfg := _ebcg.(_b.CharData); !_decfg {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ebcg)
	} else {
		switch string(_eccc) {
		case "":
			*_dbece = 0
		case "fromL":
			*_dbece = 1
		case "fromR":
			*_dbece = 2
		case "fromT":
			*_dbece = 3
		case "fromB":
			*_dbece = 4
		}
	}
	_ebcg, _acege = d.Token()
	if _acege != nil {
		return _acege
	}
	if _aebec, _eabg := _ebcg.(_b.EndElement); _eabg && _aebec.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ebcg)
}

// Validate validates the CT_SDCategories and its children
func (_geebe *CT_SDCategories) Validate() error { return _geebe.ValidateWithPath("CT_SDCategories") }
func (_bgd *CT_Name) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _fgafd := range start.Attr {
		if _fgafd.Name.Local == "lang" {
			_cgeb, _febg := _fgafd.Value, error(nil)
			if _febg != nil {
				return _febg
			}
			_bgd.LangAttr = &_cgeb
			continue
		}
		if _fgafd.Name.Local == "val" {
			_fcfg, _eeaga := _fgafd.Value, error(nil)
			if _eeaga != nil {
				return _eeaga
			}
			_bgd.ValAttr = _fcfg
			continue
		}
	}
	for {
		_aabf, _adaa := d.Token()
		if _adaa != nil {
			return _a.Errorf("parsing\u0020CT_Name:\u0020\u0025s", _adaa)
		}
		if _ceea, _bffe := _aabf.(_b.EndElement); _bffe && _ceea.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bbfbec *CT_StyleDefinition) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bbfbec.UniqueIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "uniqueId"}, Value: _a.Sprintf("\u0025v", *_bbfbec.UniqueIdAttr)})
	}
	if _bbfbec.MinVerAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "minVer"}, Value: _a.Sprintf("\u0025v", *_bbfbec.MinVerAttr)})
	}
	e.EncodeToken(start)
	if _bbfbec.Title != nil {
		_ecgab := _b.StartElement{Name: _b.Name{Local: "title"}}
		for _, _bfgcf := range _bbfbec.Title {
			e.EncodeElement(_bfgcf, _ecgab)
		}
	}
	if _bbfbec.Desc != nil {
		_caece := _b.StartElement{Name: _b.Name{Local: "desc"}}
		for _, _baed := range _bbfbec.Desc {
			e.EncodeElement(_baed, _caece)
		}
	}
	if _bbfbec.CatLst != nil {
		_bdab := _b.StartElement{Name: _b.Name{Local: "catLst"}}
		e.EncodeElement(_bbfbec.CatLst, _bdab)
	}
	if _bbfbec.Scene3d != nil {
		_cfdd := _b.StartElement{Name: _b.Name{Local: "scene3d"}}
		e.EncodeElement(_bbfbec.Scene3d, _cfdd)
	}
	_agfdb := _b.StartElement{Name: _b.Name{Local: "styleLbl"}}
	for _, _baddc := range _bbfbec.StyleLbl {
		e.EncodeElement(_baddc, _agfdb)
	}
	if _bbfbec.ExtLst != nil {
		_dbfbb := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_bbfbec.ExtLst, _dbfbb)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_ccd *AG_ConstraintRefAttributes) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ccd.RefTypeAttr != ST_ConstraintTypeUnset {
		_ge, _aba := _ccd.RefTypeAttr.MarshalXMLAttr(_b.Name{Local: "refType"})
		if _aba != nil {
			return _aba
		}
		start.Attr = append(start.Attr, _ge)
	}
	if _ccd.RefForAttr != ST_ConstraintRelationshipUnset {
		_dd, _ac := _ccd.RefForAttr.MarshalXMLAttr(_b.Name{Local: "refFor"})
		if _ac != nil {
			return _ac
		}
		start.Attr = append(start.Attr, _dd)
	}
	if _ccd.RefForNameAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "refForName"}, Value: _a.Sprintf("\u0025v", *_ccd.RefForNameAttr)})
	}
	if _ccd.RefPtTypeAttr != ST_ElementTypeUnset {
		_ccbe, _cg := _ccd.RefPtTypeAttr.MarshalXMLAttr(_b.Name{Local: "refPtType"})
		if _cg != nil {
			return _cg
		}
		start.Attr = append(start.Attr, _ccbe)
	}
	return nil
}
func (_gfggc ST_CenterShapeMapping) ValidateWithPath(path string) error {
	switch _gfggc {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gfggc))
	}
	return nil
}

const (
	ST_ElementTypeUnset    ST_ElementType = 0
	ST_ElementTypeAll      ST_ElementType = 1
	ST_ElementTypeDoc      ST_ElementType = 2
	ST_ElementTypeNode     ST_ElementType = 3
	ST_ElementTypeNorm     ST_ElementType = 4
	ST_ElementTypeNonNorm  ST_ElementType = 5
	ST_ElementTypeAsst     ST_ElementType = 6
	ST_ElementTypeNonAsst  ST_ElementType = 7
	ST_ElementTypeParTrans ST_ElementType = 8
	ST_ElementTypePres     ST_ElementType = 9
	ST_ElementTypeSibTrans ST_ElementType = 10
)

func ParseSliceST_Booleans(s string) (ST_Booleans, error) { return ST_Booleans{}, nil }

type CT_ChildPref struct{ ValAttr *int32 }

func (_efcab ST_OutputShapeType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_efcab.String(), start)
}
func (_fafc *CT_PtList) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _fafc.Pt != nil {
		_bdee := _b.StartElement{Name: _b.Name{Local: "pt"}}
		for _, _ffcc := range _fafc.Pt {
			e.EncodeElement(_ffcc, _bdee)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_egfcc ST_ChildAlignment) String() string {
	switch _egfcc {
	case 0:
		return ""
	case 1:
		return "t"
	case 2:
		return "b"
	case 3:
		return "l"
	case 4:
		return "r"
	}
	return ""
}
func (_gef *CT_Category) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _abg := range start.Attr {
		if _abg.Name.Local == "type" {
			_cca, _cdg := _abg.Value, error(nil)
			if _cdg != nil {
				return _cdg
			}
			_gef.TypeAttr = _cca
			continue
		}
		if _abg.Name.Local == "pri" {
			_cbc, _eaee := _d.ParseUint(_abg.Value, 10, 32)
			if _eaee != nil {
				return _eaee
			}
			_gef.PriAttr = uint32(_cbc)
			continue
		}
	}
	for {
		_acg, _bcb := d.Token()
		if _bcb != nil {
			return _a.Errorf("parsing\u0020CT_Category:\u0020\u0025s", _bcb)
		}
		if _geb, _bce := _acg.(_b.EndElement); _bce && _geb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gaa *CT_Choose) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _gedb := range start.Attr {
		if _gedb.Name.Local == "name" {
			_gafb, _ecg := _gedb.Value, error(nil)
			if _ecg != nil {
				return _ecg
			}
			_gaa.NameAttr = &_gafb
			continue
		}
	}
_abca:
	for {
		_bgf, _dfa := d.Token()
		if _dfa != nil {
			return _dfa
		}
		switch _cae := _bgf.(type) {
		case _b.StartElement:
			switch _cae.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "if"}:
				_acb := NewCT_When()
				if _begf := d.DecodeElement(_acb, &_cae); _begf != nil {
					return _begf
				}
				_gaa.If = append(_gaa.If, _acb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "else"}:
				_gaa.Else = NewCT_Otherwise()
				if _baee := d.DecodeElement(_gaa.Else, &_cae); _baee != nil {
					return _baee
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element on CT_Choose \u0025v", _cae.Name)
				if _egg := d.Skip(); _egg != nil {
					return _egg
				}
			}
		case _b.EndElement:
			break _abca
		case _b.CharData:
		}
	}
	return nil
}
func (_eefe *CT_SampleData) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ecacb := range start.Attr {
		if _ecacb.Name.Local == "useDef" {
			_gfef, _cef := _d.ParseBool(_ecacb.Value)
			if _cef != nil {
				return _cef
			}
			_eefe.UseDefAttr = &_gfef
			continue
		}
	}
_dgcc:
	for {
		_ebgac, _aecc := d.Token()
		if _aecc != nil {
			return _aecc
		}
		switch _dafa := _ebgac.(type) {
		case _b.StartElement:
			switch _dafa.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "dataModel"}:
				_eefe.DataModel = NewCT_DataModel()
				if _fgbg := d.DecodeElement(_eefe.DataModel, &_dafa); _fgbg != nil {
					return _fgbg
				}
			default:
				_ea.Log("skipping unsupported element\u0020on\u0020CT_SampleData \u0025v", _dafa.Name)
				if _acbb := d.Skip(); _acbb != nil {
					return _acbb
				}
			}
		case _b.EndElement:
			break _dgcc
		case _b.CharData:
		}
	}
	return nil
}

// Validate validates the CT_CxnList and its children
func (_bege *CT_CxnList) Validate() error { return _bege.ValidateWithPath("CT_CxnList") }

type ST_CxnType byte

func (_faeb ST_ConnectorPoint) String() string {
	switch _faeb {
	case 0:
		return ""
	case 1:
		return "auto"
	case 2:
		return "bCtr"
	case 3:
		return "ctr"
	case 4:
		return "midL"
	case 5:
		return "midR"
	case 6:
		return "tCtr"
	case 7:
		return "bL"
	case 8:
		return "bR"
	case 9:
		return "tL"
	case 10:
		return "tR"
	case 11:
		return "radial"
	}
	return ""
}
func (_bfcd ST_PtType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bfcd.String(), start)
}

// ValidateWithPath validates the StyleDef and its children, prefixing error messages with path
func (_fccc *StyleDef) ValidateWithPath(path string) error {
	if _dcgdc := _fccc.CT_StyleDefinition.ValidateWithPath(path); _dcgdc != nil {
		return _dcgdc
	}
	return nil
}
func (_cedbd *ST_HierarchyAlignment) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_feeg, _fefbe := d.Token()
	if _fefbe != nil {
		return _fefbe
	}
	if _dgbbde, _ebgcc := _feeg.(_b.EndElement); _ebgcc && _dgbbde.Name == start.Name {
		*_cedbd = 1
		return nil
	}
	if _becb, _feaf := _feeg.(_b.CharData); !_feaf {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _feeg)
	} else {
		switch string(_becb) {
		case "":
			*_cedbd = 0
		case "tL":
			*_cedbd = 1
		case "tR":
			*_cedbd = 2
		case "tCtrCh":
			*_cedbd = 3
		case "tCtrDes":
			*_cedbd = 4
		case "bL":
			*_cedbd = 5
		case "bR":
			*_cedbd = 6
		case "bCtrCh":
			*_cedbd = 7
		case "bCtrDes":
			*_cedbd = 8
		case "lT":
			*_cedbd = 9
		case "lB":
			*_cedbd = 10
		case "lCtrCh":
			*_cedbd = 11
		case "lCtrDes":
			*_cedbd = 12
		case "rT":
			*_cedbd = 13
		case "rB":
			*_cedbd = 14
		case "rCtrCh":
			*_cedbd = 15
		case "rCtrDes":
			*_cedbd = 16
		}
	}
	_feeg, _fefbe = d.Token()
	if _fefbe != nil {
		return _fefbe
	}
	if _fecd, _ggbcg := _feeg.(_b.EndElement); _ggbcg && _fecd.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _feeg)
}
func (_bffad ST_HueDir) String() string {
	switch _bffad {
	case 0:
		return ""
	case 1:
		return "cw"
	case 2:
		return "ccw"
	}
	return ""
}

type CT_CTCategories struct{ Cat []*CT_CTCategory }

func NewAG_ConstraintAttributes() *AG_ConstraintAttributes {
	_db := &AG_ConstraintAttributes{}
	return _db
}
func (_ebcc ST_SecondaryChildAlignment) ValidateWithPath(path string) error {
	switch _ebcc {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ebcc))
	}
	return nil
}
func (_edde ST_ChildDirection) String() string {
	switch _edde {
	case 0:
		return ""
	case 1:
		return "horz"
	case 2:
		return "vert"
	}
	return ""
}

type ST_PyramidAccentTextMargin byte

// ValidateWithPath validates the CT_NumericRule and its children, prefixing error messages with path
func (_afge *CT_NumericRule) ValidateWithPath(path string) error {
	if _afge.ExtLst != nil {
		if _gcfe := _afge.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gcfe != nil {
			return _gcfe
		}
	}
	if _dgfeb := _afge.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _dgfeb != nil {
		return _dgfeb
	}
	if _eceg := _afge.ForAttr.ValidateWithPath(path + "\u002fForAttr"); _eceg != nil {
		return _eceg
	}
	if _fgde := _afge.PtTypeAttr.ValidateWithPath(path + "/PtTypeAttr"); _fgde != nil {
		return _fgde
	}
	return nil
}
func (_cafed ST_ConnectorRouting) String() string {
	switch _cafed {
	case 0:
		return ""
	case 1:
		return "stra"
	case 2:
		return "bend"
	case 3:
		return "curve"
	case 4:
		return "longCurve"
	}
	return ""
}
func (_effc ST_ElementType) ValidateWithPath(path string) error {
	switch _effc {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_effc))
	}
	return nil
}
func (_befac ST_Breakpoint) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_efdb := _b.Attr{}
	_efdb.Name = name
	switch _befac {
	case ST_BreakpointUnset:
		_efdb.Value = ""
	case ST_BreakpointEndCnv:
		_efdb.Value = "endCnv"
	case ST_BreakpointBal:
		_efdb.Value = "bal"
	case ST_BreakpointFixed:
		_efdb.Value = "fixed"
	}
	return _efdb, nil
}
func (_bdgbf ST_DiagramTextAlignment) String() string {
	switch _bdgbf {
	case 0:
		return ""
	case 1:
		return "l"
	case 2:
		return "ctr"
	case 3:
		return "r"
	}
	return ""
}

// ValidateWithPath validates the CT_LayoutNode and its children, prefixing error messages with path
func (_dffd *CT_LayoutNode) ValidateWithPath(path string) error {
	if _aced := _dffd.ChOrderAttr.ValidateWithPath(path + "\u002fChOrderAttr"); _aced != nil {
		return _aced
	}
	for _cdac, _ggdf := range _dffd.Alg {
		if _acdf := _ggdf.ValidateWithPath(_a.Sprintf("\u0025s\u002fAlg\u005b\u0025d\u005d", path, _cdac)); _acdf != nil {
			return _acdf
		}
	}
	for _dccb, _cacf := range _dffd.Shape {
		if _efaaf := _cacf.ValidateWithPath(_a.Sprintf("\u0025s\u002fShape\u005b\u0025d\u005d", path, _dccb)); _efaaf != nil {
			return _efaaf
		}
	}
	for _eccg, _fff := range _dffd.PresOf {
		if _fcg := _fff.ValidateWithPath(_a.Sprintf("\u0025s\u002fPresOf\u005b\u0025d\u005d", path, _eccg)); _fcg != nil {
			return _fcg
		}
	}
	for _bgfg, _feac := range _dffd.ConstrLst {
		if _gfcf := _feac.ValidateWithPath(_a.Sprintf("\u0025s/ConstrLst\u005b\u0025d\u005d", path, _bgfg)); _gfcf != nil {
			return _gfcf
		}
	}
	for _fcge, _gagd := range _dffd.RuleLst {
		if _bdag := _gagd.ValidateWithPath(_a.Sprintf("\u0025s\u002fRuleLst\u005b\u0025d\u005d", path, _fcge)); _bdag != nil {
			return _bdag
		}
	}
	for _facd, _gbcc := range _dffd.VarLst {
		if _egcb := _gbcc.ValidateWithPath(_a.Sprintf("\u0025s\u002fVarLst\u005b\u0025d\u005d", path, _facd)); _egcb != nil {
			return _egcb
		}
	}
	for _cbgg, _gfac := range _dffd.ForEach {
		if _ggcd := _gfac.ValidateWithPath(_a.Sprintf("\u0025s\u002fForEach\u005b\u0025d\u005d", path, _cbgg)); _ggcd != nil {
			return _ggcd
		}
	}
	for _gffdb, _bcd := range _dffd.LayoutNode {
		if _cgdg := _bcd.ValidateWithPath(_a.Sprintf("\u0025s\u002fLayoutNode\u005b\u0025d\u005d", path, _gffdb)); _cgdg != nil {
			return _cgdg
		}
	}
	for _edeb, _fafg := range _dffd.Choose {
		if _debg := _fafg.ValidateWithPath(_a.Sprintf("\u0025s\u002fChoose\u005b\u0025d\u005d", path, _edeb)); _debg != nil {
			return _debg
		}
	}
	for _bed, _cdcd := range _dffd.ExtLst {
		if _bdgf := _cdcd.ValidateWithPath(_a.Sprintf("\u0025s\u002fExtLst\u005b\u0025d\u005d", path, _bed)); _bdgf != nil {
			return _bdgf
		}
	}
	return nil
}
func (_ecgca ST_Offset) String() string {
	switch _ecgca {
	case 0:
		return ""
	case 1:
		return "ctr"
	case 2:
		return "off"
	}
	return ""
}
func (_cgedb ST_VerticalAlignment) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_cgedb.String(), start)
}
func (_egdbf *ColorsDefHdrLst) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_egdbf.CT_ColorTransformHeaderLst = *NewCT_ColorTransformHeaderLst()
_ebag:
	for {
		_cefe, _bdda := d.Token()
		if _bdda != nil {
			return _bdda
		}
		switch _fgca := _cefe.(type) {
		case _b.StartElement:
			switch _fgca.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "colorsDefHdr"}:
				_ddeg := NewCT_ColorTransformHeader()
				if _gfgbg := d.DecodeElement(_ddeg, &_fgca); _gfgbg != nil {
					return _gfgbg
				}
				_egdbf.ColorsDefHdr = append(_egdbf.ColorsDefHdr, _ddeg)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020ColorsDefHdrLst\u0020\u0025v", _fgca.Name)
				if _dbbcf := d.Skip(); _dbbcf != nil {
					return _dbbcf
				}
			}
		case _b.EndElement:
			break _ebag
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Otherwise and its children, prefixing error messages with path
func (_adbcf *CT_Otherwise) ValidateWithPath(path string) error {
	for _ecge, _acag := range _adbcf.Alg {
		if _gcdd := _acag.ValidateWithPath(_a.Sprintf("\u0025s\u002fAlg\u005b\u0025d\u005d", path, _ecge)); _gcdd != nil {
			return _gcdd
		}
	}
	for _eebgf, _bbcb := range _adbcf.Shape {
		if _abdg := _bbcb.ValidateWithPath(_a.Sprintf("\u0025s\u002fShape\u005b\u0025d\u005d", path, _eebgf)); _abdg != nil {
			return _abdg
		}
	}
	for _aaeee, _cgebg := range _adbcf.PresOf {
		if _dacg := _cgebg.ValidateWithPath(_a.Sprintf("\u0025s\u002fPresOf\u005b\u0025d\u005d", path, _aaeee)); _dacg != nil {
			return _dacg
		}
	}
	for _cafe, _dafb := range _adbcf.ConstrLst {
		if _aebeef := _dafb.ValidateWithPath(_a.Sprintf("\u0025s/ConstrLst\u005b\u0025d\u005d", path, _cafe)); _aebeef != nil {
			return _aebeef
		}
	}
	for _gbbe, _agcg := range _adbcf.RuleLst {
		if _fdcg := _agcg.ValidateWithPath(_a.Sprintf("\u0025s\u002fRuleLst\u005b\u0025d\u005d", path, _gbbe)); _fdcg != nil {
			return _fdcg
		}
	}
	for _ecdd, _fcgf := range _adbcf.ForEach {
		if _bfeb := _fcgf.ValidateWithPath(_a.Sprintf("\u0025s\u002fForEach\u005b\u0025d\u005d", path, _ecdd)); _bfeb != nil {
			return _bfeb
		}
	}
	for _ggba, _bdbe := range _adbcf.LayoutNode {
		if _ebeg := _bdbe.ValidateWithPath(_a.Sprintf("\u0025s\u002fLayoutNode\u005b\u0025d\u005d", path, _ggba)); _ebeg != nil {
			return _ebeg
		}
	}
	for _dded, _aaad := range _adbcf.Choose {
		if _cafef := _aaad.ValidateWithPath(_a.Sprintf("\u0025s\u002fChoose\u005b\u0025d\u005d", path, _dded)); _cafef != nil {
			return _cafef
		}
	}
	for _afaga, _fbaf := range _adbcf.ExtLst {
		if _aeff := _fbaf.ValidateWithPath(_a.Sprintf("\u0025s\u002fExtLst\u005b\u0025d\u005d", path, _afaga)); _aeff != nil {
			return _aeff
		}
	}
	return nil
}

// Validate validates the CT_CTCategories and its children
func (_bdd *CT_CTCategories) Validate() error { return _bdd.ValidateWithPath("CT_CTCategories") }
func (_fcbg *ST_HueDir) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fcbg = 0
	case "cw":
		*_fcbg = 1
	case "ccw":
		*_fcbg = 2
	}
	return nil
}
func (_aggf *ST_HierBranchStyle) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_aggf = 0
	case "l":
		*_aggf = 1
	case "r":
		*_aggf = 2
	case "hang":
		*_aggf = 3
	case "std":
		*_aggf = 4
	case "init":
		*_aggf = 5
	}
	return nil
}

const (
	ST_FlowDirectionUnset ST_FlowDirection = 0
	ST_FlowDirectionRow   ST_FlowDirection = 1
	ST_FlowDirectionCol   ST_FlowDirection = 2
)

func NewCT_AnimLvl() *CT_AnimLvl { _aaf := &CT_AnimLvl{}; return _aaf }
func (_bga *CT_AnimOne) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bga.ValAttr != ST_AnimOneStrUnset {
		_dad, _cgc := _bga.ValAttr.MarshalXMLAttr(_b.Name{Local: "val"})
		if _cgc != nil {
			return _cgc
		}
		start.Attr = append(start.Attr, _dad)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_bae *CT_AnimLvl) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bae.ValAttr != ST_AnimLvlStrUnset {
		_gbe, _ffg := _bae.ValAttr.MarshalXMLAttr(_b.Name{Local: "val"})
		if _ffg != nil {
			return _ffg
		}
		start.Attr = append(start.Attr, _gbe)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_PresentationOf and its children, prefixing error messages with path
func (_ebgca *CT_PresentationOf) ValidateWithPath(path string) error {
	if _ebgca.ExtLst != nil {
		if _gbbef := _ebgca.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gbbef != nil {
			return _gbbef
		}
	}
	return nil
}
func (_gafe ST_ModelId) String() string {
	if _gafe.Int32 != nil {
		return _a.Sprintf("\u0025v", *_gafe.Int32)
	}
	if _gafe.ST_Guid != nil {
		return _a.Sprintf("\u0025v", *_gafe.ST_Guid)
	}
	return ""
}

type ST_ArrowheadStyle byte
type ST_FunctionType byte

func NewStyleDefHdrLst() *StyleDefHdrLst {
	_baedd := &StyleDefHdrLst{}
	_baedd.CT_StyleDefinitionHeaderLst = *NewCT_StyleDefinitionHeaderLst()
	return _baedd
}
func _eecbc(_bdgdd bool) uint8 {
	if _bdgdd {
		return 1
	}
	return 0
}
func (_gfdab ST_ConnectorPoint) Validate() error { return _gfdab.ValidateWithPath("") }

// ValidateWithPath validates the CT_ColorTransformHeader and its children, prefixing error messages with path
func (_ebgb *CT_ColorTransformHeader) ValidateWithPath(path string) error {
	for _dgde, _accb := range _ebgb.Title {
		if _fgcg := _accb.ValidateWithPath(_a.Sprintf("\u0025s\u002fTitle\u005b\u0025d\u005d", path, _dgde)); _fgcg != nil {
			return _fgcg
		}
	}
	for _eed, _ffdd := range _ebgb.Desc {
		if _aaa := _ffdd.ValidateWithPath(_a.Sprintf("%s\u002fDesc\u005b\u0025d\u005d", path, _eed)); _aaa != nil {
			return _aaa
		}
	}
	if _ebgb.CatLst != nil {
		if _dage := _ebgb.CatLst.ValidateWithPath(path + "\u002fCatLst"); _dage != nil {
			return _dage
		}
	}
	if _ebgb.ExtLst != nil {
		if _gacb := _ebgb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gacb != nil {
			return _gacb
		}
	}
	return nil
}
func (_adfb ST_ClrAppMethod) Validate() error { return _adfb.ValidateWithPath("") }
func (_fcbd ST_FunctionOperator) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gada := _b.Attr{}
	_gada.Name = name
	switch _fcbd {
	case ST_FunctionOperatorUnset:
		_gada.Value = ""
	case ST_FunctionOperatorEqu:
		_gada.Value = "equ"
	case ST_FunctionOperatorNeq:
		_gada.Value = "neq"
	case ST_FunctionOperatorGt:
		_gada.Value = "gt"
	case ST_FunctionOperatorLt:
		_gada.Value = "lt"
	case ST_FunctionOperatorGte:
		_gada.Value = "gte"
	case ST_FunctionOperatorLte:
		_gada.Value = "lte"
	}
	return _gada, nil
}
func (_gaea *DataModel) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:di"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "dataModel"
	return _gaea.CT_DataModel.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_Pt and its children, prefixing error messages with path
func (_efgea *CT_Pt) ValidateWithPath(path string) error {
	if _dcgf := _efgea.ModelIdAttr.ValidateWithPath(path + "\u002fModelIdAttr"); _dcgf != nil {
		return _dcgf
	}
	if _abcg := _efgea.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _abcg != nil {
		return _abcg
	}
	if _efgea.CxnIdAttr != nil {
		if _dfbc := _efgea.CxnIdAttr.ValidateWithPath(path + "\u002fCxnIdAttr"); _dfbc != nil {
			return _dfbc
		}
	}
	if _efgea.PrSet != nil {
		if _dgbbd := _efgea.PrSet.ValidateWithPath(path + "\u002fPrSet"); _dgbbd != nil {
			return _dgbbd
		}
	}
	if _efgea.SpPr != nil {
		if _bfdd := _efgea.SpPr.ValidateWithPath(path + "\u002fSpPr"); _bfdd != nil {
			return _bfdd
		}
	}
	if _efgea.T != nil {
		if _gacae := _efgea.T.ValidateWithPath(path + "\u002fT"); _gacae != nil {
			return _gacae
		}
	}
	if _efgea.ExtLst != nil {
		if _ffdba := _efgea.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ffdba != nil {
			return _ffdba
		}
	}
	return nil
}
func (_bbcfg ST_PyramidAccentPosition) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_fdgfa := _b.Attr{}
	_fdgfa.Name = name
	switch _bbcfg {
	case ST_PyramidAccentPositionUnset:
		_fdgfa.Value = ""
	case ST_PyramidAccentPositionBef:
		_fdgfa.Value = "bef"
	case ST_PyramidAccentPositionAft:
		_fdgfa.Value = "aft"
	}
	return _fdgfa, nil
}

// ValidateWithPath validates the CT_DiagramDefinitionHeader and its children, prefixing error messages with path
func (_gcfa *CT_DiagramDefinitionHeader) ValidateWithPath(path string) error {
	for _aca, _cega := range _gcfa.Title {
		if _afcf := _cega.ValidateWithPath(_a.Sprintf("\u0025s\u002fTitle\u005b\u0025d\u005d", path, _aca)); _afcf != nil {
			return _afcf
		}
	}
	for _bggb, _abf := range _gcfa.Desc {
		if _aeaa := _abf.ValidateWithPath(_a.Sprintf("%s\u002fDesc\u005b\u0025d\u005d", path, _bggb)); _aeaa != nil {
			return _aeaa
		}
	}
	if _gcfa.CatLst != nil {
		if _agba := _gcfa.CatLst.ValidateWithPath(path + "\u002fCatLst"); _agba != nil {
			return _agba
		}
	}
	if _gcfa.ExtLst != nil {
		if _gcef := _gcfa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gcef != nil {
			return _gcef
		}
	}
	return nil
}
func (_bbb *CT_CTDescription) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _fbc := range start.Attr {
		if _fbc.Name.Local == "lang" {
			_gegd, _cfd := _fbc.Value, error(nil)
			if _cfd != nil {
				return _cfd
			}
			_bbb.LangAttr = &_gegd
			continue
		}
		if _fbc.Name.Local == "val" {
			_gfd, _aac := _fbc.Value, error(nil)
			if _aac != nil {
				return _aac
			}
			_bbb.ValAttr = _gfd
			continue
		}
	}
	for {
		_gfa, _gag := d.Token()
		if _gag != nil {
			return _a.Errorf("parsing\u0020CT_CTDescription: \u0025s", _gag)
		}
		if _ceac, _agc := _gfa.(_b.EndElement); _agc && _ceac.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gadg *ST_OutputShapeType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_gadg = 0
	case "none":
		*_gadg = 1
	case "conn":
		*_gadg = 2
	}
	return nil
}
func (_cbdfb *ST_HierBranchStyle) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_egfde, _eaef := d.Token()
	if _eaef != nil {
		return _eaef
	}
	if _faaad, _ceee := _egfde.(_b.EndElement); _ceee && _faaad.Name == start.Name {
		*_cbdfb = 1
		return nil
	}
	if _gcffd, _bebg := _egfde.(_b.CharData); !_bebg {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _egfde)
	} else {
		switch string(_gcffd) {
		case "":
			*_cbdfb = 0
		case "l":
			*_cbdfb = 1
		case "r":
			*_cbdfb = 2
		case "hang":
			*_cbdfb = 3
		case "std":
			*_cbdfb = 4
		case "init":
			*_cbdfb = 5
		}
	}
	_egfde, _eaef = d.Token()
	if _eaef != nil {
		return _eaef
	}
	if _agdgc, _dggd := _egfde.(_b.EndElement); _dggd && _agdgc.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _egfde)
}
func (_daaed ST_Offset) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_dgeff := _b.Attr{}
	_dgeff.Name = name
	switch _daaed {
	case ST_OffsetUnset:
		_dgeff.Value = ""
	case ST_OffsetCtr:
		_dgeff.Value = "ctr"
	case ST_OffsetOff:
		_dgeff.Value = "off"
	}
	return _dgeff, nil
}

type CT_ResizeHandles struct{ ValAttr ST_ResizeHandlesStr }

func (_bgeda ST_Breakpoint) Validate() error { return _bgeda.ValidateWithPath("") }
func (_ccdc *ST_CenterShapeMapping) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_ccdc = 0
	case "none":
		*_ccdc = 1
	case "fNode":
		*_ccdc = 2
	}
	return nil
}
func (_dgded ST_HierBranchStyle) String() string {
	switch _dgded {
	case 0:
		return ""
	case 1:
		return "l"
	case 2:
		return "r"
	case 3:
		return "hang"
	case 4:
		return "std"
	case 5:
		return "init"
	}
	return ""
}

// Validate validates the CT_Choose and its children
func (_aeg *CT_Choose) Validate() error { return _aeg.ValidateWithPath("CT_Choose") }
func (_dfdd *ST_FunctionOperator) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dfdd = 0
	case "equ":
		*_dfdd = 1
	case "neq":
		*_dfdd = 2
	case "gt":
		*_dfdd = 3
	case "lt":
		*_dfdd = 4
	case "gte":
		*_dfdd = 5
	case "lte":
		*_dfdd = 6
	}
	return nil
}

// ValidateWithPath validates the CT_ResizeHandles and its children, prefixing error messages with path
func (_fbga *CT_ResizeHandles) ValidateWithPath(path string) error {
	if _ggfc := _fbga.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _ggfc != nil {
		return _ggfc
	}
	return nil
}
func (_eggfa ST_AlgorithmType) Validate() error { return _eggfa.ValidateWithPath("") }
func (_ffgg ST_PyramidAccentTextMargin) ValidateWithPath(path string) error {
	switch _ffgg {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ffgg))
	}
	return nil
}
func NewLayoutDef() *LayoutDef {
	_bfcgf := &LayoutDef{}
	_bfcgf.CT_DiagramDefinition = *NewCT_DiagramDefinition()
	return _bfcgf
}

// ValidateWithPath validates the CT_LayoutVariablePropertySet and its children, prefixing error messages with path
func (_gdad *CT_LayoutVariablePropertySet) ValidateWithPath(path string) error {
	if _gdad.OrgChart != nil {
		if _aecb := _gdad.OrgChart.ValidateWithPath(path + "\u002fOrgChart"); _aecb != nil {
			return _aecb
		}
	}
	if _gdad.ChMax != nil {
		if _dcbb := _gdad.ChMax.ValidateWithPath(path + "\u002fChMax"); _dcbb != nil {
			return _dcbb
		}
	}
	if _gdad.ChPref != nil {
		if _bcbbg := _gdad.ChPref.ValidateWithPath(path + "\u002fChPref"); _bcbbg != nil {
			return _bcbbg
		}
	}
	if _gdad.BulletEnabled != nil {
		if _adeca := _gdad.BulletEnabled.ValidateWithPath(path + "\u002fBulletEnabled"); _adeca != nil {
			return _adeca
		}
	}
	if _gdad.Dir != nil {
		if _gddc := _gdad.Dir.ValidateWithPath(path + "\u002fDir"); _gddc != nil {
			return _gddc
		}
	}
	if _gdad.HierBranch != nil {
		if _fdgb := _gdad.HierBranch.ValidateWithPath(path + "/HierBranch"); _fdgb != nil {
			return _fdgb
		}
	}
	if _gdad.AnimOne != nil {
		if _cbfe := _gdad.AnimOne.ValidateWithPath(path + "\u002fAnimOne"); _cbfe != nil {
			return _cbfe
		}
	}
	if _gdad.AnimLvl != nil {
		if _bbeg := _gdad.AnimLvl.ValidateWithPath(path + "\u002fAnimLvl"); _bbeg != nil {
			return _bbeg
		}
	}
	if _gdad.ResizeHandles != nil {
		if _fcb := _gdad.ResizeHandles.ValidateWithPath(path + "\u002fResizeHandles"); _fcb != nil {
			return _fcb
		}
	}
	return nil
}

type CT_StyleDefinitionHeaderLst struct{ StyleDefHdr []*CT_StyleDefinitionHeader }

func (_fccebe ST_FallbackDimension) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_deeab := _b.Attr{}
	_deeab.Name = name
	switch _fccebe {
	case ST_FallbackDimensionUnset:
		_deeab.Value = ""
	case ST_FallbackDimension1D:
		_deeab.Value = "1D"
	case ST_FallbackDimension2D:
		_deeab.Value = "2D"
	}
	return _deeab, nil
}
func NewCT_AnimOne() *CT_AnimOne { _cee := &CT_AnimOne{}; return _cee }
func (_bdabg *ST_DiagramTextAlignment) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_bdabg = 0
	case "l":
		*_bdabg = 1
	case "ctr":
		*_bdabg = 2
	case "r":
		*_bdabg = 3
	}
	return nil
}
func (_aacc *ST_ConnectorRouting) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cabed, _adda := d.Token()
	if _adda != nil {
		return _adda
	}
	if _cacd, _bdcb := _cabed.(_b.EndElement); _bdcb && _cacd.Name == start.Name {
		*_aacc = 1
		return nil
	}
	if _ddgc, _bgaa := _cabed.(_b.CharData); !_bgaa {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cabed)
	} else {
		switch string(_ddgc) {
		case "":
			*_aacc = 0
		case "stra":
			*_aacc = 1
		case "bend":
			*_aacc = 2
		case "curve":
			*_aacc = 3
		case "longCurve":
			*_aacc = 4
		}
	}
	_cabed, _adda = d.Token()
	if _adda != nil {
		return _adda
	}
	if _faea, _eddaf := _cabed.(_b.EndElement); _eddaf && _faea.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cabed)
}

const (
	ST_DirectionUnset ST_Direction = 0
	ST_DirectionNorm  ST_Direction = 1
	ST_DirectionRev   ST_Direction = 2
)

type CT_SDName struct {
	LangAttr *string
	ValAttr  string
}

func (_abedg *ST_OutputShapeType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fgag, _bcgec := d.Token()
	if _bcgec != nil {
		return _bcgec
	}
	if _ggdb, _decde := _fgag.(_b.EndElement); _decde && _ggdb.Name == start.Name {
		*_abedg = 1
		return nil
	}
	if _becgb, _afada := _fgag.(_b.CharData); !_afada {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fgag)
	} else {
		switch string(_becgb) {
		case "":
			*_abedg = 0
		case "none":
			*_abedg = 1
		case "conn":
			*_abedg = 2
		}
	}
	_fgag, _bcgec = d.Token()
	if _bcgec != nil {
		return _bcgec
	}
	if _fcadg, _bcga := _fgag.(_b.EndElement); _bcga && _fcadg.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fgag)
}
func (_fdcad ST_ConnectorDimension) Validate() error { return _fdcad.ValidateWithPath("") }
func (_aadg ST_TextAnchorVertical) Validate() error  { return _aadg.ValidateWithPath("") }
func (_gfc *CT_Categories) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_gfe:
	for {
		_edc, _bbba := d.Token()
		if _bbba != nil {
			return _bbba
		}
		switch _cdff := _edc.(type) {
		case _b.StartElement:
			switch _cdff.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "cat"}:
				_gde := NewCT_Category()
				if _eda := d.DecodeElement(_gde, &_cdff); _eda != nil {
					return _eda
				}
				_gfc.Cat = append(_gfc.Cat, _gde)
			default:
				_ea.Log("skipping unsupported element\u0020on\u0020CT_Categories \u0025v", _cdff.Name)
				if _ffd := d.Skip(); _ffd != nil {
					return _ffd
				}
			}
		case _b.EndElement:
			break _gfe
		case _b.CharData:
		}
	}
	return nil
}

type ST_SecondaryLinearDirection byte

// ValidateWithPath validates the CT_RelIds and its children, prefixing error messages with path
func (_ffa *CT_RelIds) ValidateWithPath(path string) error { return nil }
func (_cbaaf ST_DiagramTextAlignment) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_cbaaf.String(), start)
}
func (_fccfe *LayoutDefHdr) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fccfe.CT_DiagramDefinitionHeader = *NewCT_DiagramDefinitionHeader()
	for _, _ggcdf := range start.Attr {
		if _ggcdf.Name.Local == "uniqueId" {
			_dcfbb, _befdg := _ggcdf.Value, error(nil)
			if _befdg != nil {
				return _befdg
			}
			_fccfe.UniqueIdAttr = _dcfbb
			continue
		}
		if _ggcdf.Name.Local == "minVer" {
			_badb, _bcfad := _ggcdf.Value, error(nil)
			if _bcfad != nil {
				return _bcfad
			}
			_fccfe.MinVerAttr = &_badb
			continue
		}
		if _ggcdf.Name.Local == "defStyle" {
			_geceb, _bebc := _ggcdf.Value, error(nil)
			if _bebc != nil {
				return _bebc
			}
			_fccfe.DefStyleAttr = &_geceb
			continue
		}
		if _ggcdf.Name.Local == "resId" {
			_fgegg, _afaff := _d.ParseInt(_ggcdf.Value, 10, 32)
			if _afaff != nil {
				return _afaff
			}
			_ffad := int32(_fgegg)
			_fccfe.ResIdAttr = &_ffad
			continue
		}
	}
_eaac:
	for {
		_ddagg, _agdee := d.Token()
		if _agdee != nil {
			return _agdee
		}
		switch _fdcbg := _ddagg.(type) {
		case _b.StartElement:
			switch _fdcbg.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_dffde := NewCT_Name()
				if _debe := d.DecodeElement(_dffde, &_fdcbg); _debe != nil {
					return _debe
				}
				_fccfe.Title = append(_fccfe.Title, _dffde)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_edae := NewCT_Description()
				if _ddaf := d.DecodeElement(_edae, &_fdcbg); _ddaf != nil {
					return _ddaf
				}
				_fccfe.Desc = append(_fccfe.Desc, _edae)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_fccfe.CatLst = NewCT_Categories()
				if _bacf := d.DecodeElement(_fccfe.CatLst, &_fdcbg); _bacf != nil {
					return _bacf
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_fccfe.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _cfgbc := d.DecodeElement(_fccfe.ExtLst, &_fdcbg); _cfgbc != nil {
					return _cfgbc
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020LayoutDefHdr\u0020\u0025v", _fdcbg.Name)
				if _bdeea := d.Skip(); _bdeea != nil {
					return _bdeea
				}
			}
		case _b.EndElement:
			break _eaac
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Constraint and its children, prefixing error messages with path
func (_bef *CT_Constraint) ValidateWithPath(path string) error {
	if _ebdf := _bef.OpAttr.ValidateWithPath(path + "\u002fOpAttr"); _ebdf != nil {
		return _ebdf
	}
	if _bef.ExtLst != nil {
		if _fac := _bef.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fac != nil {
			return _fac
		}
	}
	if _cbeef := _bef.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _cbeef != nil {
		return _cbeef
	}
	if _gefea := _bef.ForAttr.ValidateWithPath(path + "\u002fForAttr"); _gefea != nil {
		return _gefea
	}
	if _cbcc := _bef.PtTypeAttr.ValidateWithPath(path + "/PtTypeAttr"); _cbcc != nil {
		return _cbcc
	}
	if _dcab := _bef.RefTypeAttr.ValidateWithPath(path + "\u002fRefTypeAttr"); _dcab != nil {
		return _dcab
	}
	if _ffdb := _bef.RefForAttr.ValidateWithPath(path + "/RefForAttr"); _ffdb != nil {
		return _ffdb
	}
	if _gecg := _bef.RefPtTypeAttr.ValidateWithPath(path + "\u002fRefPtTypeAttr"); _gecg != nil {
		return _gecg
	}
	return nil
}
func (_edcg ST_Breakpoint) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_edcg.String(), start)
}

// Validate validates the CT_NumericRule and its children
func (_bgcae *CT_NumericRule) Validate() error { return _bgcae.ValidateWithPath("CT_NumericRule") }
func (_gacf ST_HierBranchStyle) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bbfa := _b.Attr{}
	_bbfa.Name = name
	switch _gacf {
	case ST_HierBranchStyleUnset:
		_bbfa.Value = ""
	case ST_HierBranchStyleL:
		_bbfa.Value = "l"
	case ST_HierBranchStyleR:
		_bbfa.Value = "r"
	case ST_HierBranchStyleHang:
		_bbfa.Value = "hang"
	case ST_HierBranchStyleStd:
		_bbfa.Value = "std"
	case ST_HierBranchStyleInit:
		_bbfa.Value = "init"
	}
	return _bbfa, nil
}
func (_acefg ST_CenterShapeMapping) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_acefg.String(), start)
}

type CT_ColorTransform struct {
	UniqueIdAttr *string
	MinVerAttr   *string
	Title        []*CT_CTName
	Desc         []*CT_CTDescription
	CatLst       *CT_CTCategories
	StyleLbl     []*CT_CTStyleLabel
	ExtLst       *_f.CT_OfficeArtExtensionList
}

func (_dgged ST_TextAnchorHorizontal) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dgged.String(), start)
}
func (_dfdc ST_ConnectorRouting) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bdbae := _b.Attr{}
	_bdbae.Name = name
	switch _dfdc {
	case ST_ConnectorRoutingUnset:
		_bdbae.Value = ""
	case ST_ConnectorRoutingStra:
		_bdbae.Value = "stra"
	case ST_ConnectorRoutingBend:
		_bdbae.Value = "bend"
	case ST_ConnectorRoutingCurve:
		_bdbae.Value = "curve"
	case ST_ConnectorRoutingLongCurve:
		_bdbae.Value = "longCurve"
	}
	return _bdbae, nil
}
func (_cfgg *CT_SDCategory) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "type"}, Value: _a.Sprintf("\u0025v", _cfgg.TypeAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "pri"}, Value: _a.Sprintf("\u0025v", _cfgg.PriAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_debb *ST_VariableType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_debb = 0
	case "none":
		*_debb = 1
	case "orgChart":
		*_debb = 2
	case "chMax":
		*_debb = 3
	case "chPref":
		*_debb = 4
	case "bulEnabled":
		*_debb = 5
	case "dir":
		*_debb = 6
	case "hierBranch":
		*_debb = 7
	case "animOne":
		*_debb = 8
	case "animLvl":
		*_debb = 9
	case "resizeHandles":
		*_debb = 10
	}
	return nil
}
func (_cdgg *CT_RelIds) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:dm"}, Value: _a.Sprintf("\u0025v", _cdgg.DmAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:lo"}, Value: _a.Sprintf("\u0025v", _cdgg.LoAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:qs"}, Value: _a.Sprintf("\u0025v", _cdgg.QsAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:cs"}, Value: _a.Sprintf("\u0025v", _cdgg.CsAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_cege ST_DiagramHorizontalAlignment) Validate() error { return _cege.ValidateWithPath("") }

// ValidateWithPath validates the StyleDefHdr and its children, prefixing error messages with path
func (_ggefd *StyleDefHdr) ValidateWithPath(path string) error {
	if _ageeg := _ggefd.CT_StyleDefinitionHeader.ValidateWithPath(path); _ageeg != nil {
		return _ageeg
	}
	return nil
}
func (_fbgca ST_FunctionOperator) String() string {
	switch _fbgca {
	case 0:
		return ""
	case 1:
		return "equ"
	case 2:
		return "neq"
	case 3:
		return "gt"
	case 4:
		return "lt"
	case 5:
		return "gte"
	case 6:
		return "lte"
	}
	return ""
}
func (_cfbc ST_PrSetCustVal) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _cfbc.ST_Percentage != nil {
		e.EncodeToken(_b.CharData(*_cfbc.ST_Percentage))
	}
	if _cfbc.Int32 != nil {
		e.EncodeToken(_b.CharData(_a.Sprintf("\u0025d", *_cfbc.Int32)))
	}
	return e.EncodeToken(_b.EndElement{Name: start.Name})
}

const (
	ST_BreakpointUnset  ST_Breakpoint = 0
	ST_BreakpointEndCnv ST_Breakpoint = 1
	ST_BreakpointBal    ST_Breakpoint = 2
	ST_BreakpointFixed  ST_Breakpoint = 3
)

func (_dffc *CT_StyleDefinitionHeader) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _fgfc := range start.Attr {
		if _fgfc.Name.Local == "uniqueId" {
			_beebg, _dfg := _fgfc.Value, error(nil)
			if _dfg != nil {
				return _dfg
			}
			_dffc.UniqueIdAttr = _beebg
			continue
		}
		if _fgfc.Name.Local == "minVer" {
			_gdde, _fgcb := _fgfc.Value, error(nil)
			if _fgcb != nil {
				return _fgcb
			}
			_dffc.MinVerAttr = &_gdde
			continue
		}
		if _fgfc.Name.Local == "resId" {
			_fdcd, _bbgb := _d.ParseInt(_fgfc.Value, 10, 32)
			if _bbgb != nil {
				return _bbgb
			}
			_faaf := int32(_fdcd)
			_dffc.ResIdAttr = &_faaf
			continue
		}
	}
_cffd:
	for {
		_edfbf, _fgda := d.Token()
		if _fgda != nil {
			return _fgda
		}
		switch _ddba := _edfbf.(type) {
		case _b.StartElement:
			switch _ddba.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_afde := NewCT_SDName()
				if _dabg := d.DecodeElement(_afde, &_ddba); _dabg != nil {
					return _dabg
				}
				_dffc.Title = append(_dffc.Title, _afde)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_cdabe := NewCT_SDDescription()
				if _acga := d.DecodeElement(_cdabe, &_ddba); _acga != nil {
					return _acga
				}
				_dffc.Desc = append(_dffc.Desc, _cdabe)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_dffc.CatLst = NewCT_SDCategories()
				if _cegab := d.DecodeElement(_dffc.CatLst, &_ddba); _cegab != nil {
					return _cegab
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_dffc.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _egfc := d.DecodeElement(_dffc.ExtLst, &_ddba); _egfc != nil {
					return _egfc
				}
			default:
				_ea.Log("skipping\u0020unsupported element\u0020on\u0020CT_StyleDefinitionHeader\u0020%v", _ddba.Name)
				if _dcdaa := d.Skip(); _dcdaa != nil {
					return _dcdaa
				}
			}
		case _b.EndElement:
			break _cffd
		case _b.CharData:
		}
	}
	return nil
}
func (_cceb *LayoutDefHdr) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:di"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "layoutDefHdr"
	return _cceb.CT_DiagramDefinitionHeader.MarshalXML(e, start)
}
func (_bffa ST_FunctionValue) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _bffa.Int32 != nil {
		e.EncodeToken(_b.CharData(_a.Sprintf("\u0025d", *_bffa.Int32)))
	}
	if _bffa.Bool != nil {
		e.EncodeToken(_b.CharData(_a.Sprintf("\u0025d", _eecbc(*_bffa.Bool))))
	}
	if _bffa.ST_Direction != ST_DirectionUnset {
		e.EncodeToken(_b.CharData(_bffa.ST_Direction.String()))
	}
	if _bffa.ST_HierBranchStyle != ST_HierBranchStyleUnset {
		e.EncodeToken(_b.CharData(_bffa.ST_HierBranchStyle.String()))
	}
	if _bffa.ST_AnimOneStr != ST_AnimOneStrUnset {
		e.EncodeToken(_b.CharData(_bffa.ST_AnimOneStr.String()))
	}
	if _bffa.ST_AnimLvlStr != ST_AnimLvlStrUnset {
		e.EncodeToken(_b.CharData(_bffa.ST_AnimLvlStr.String()))
	}
	if _bffa.ST_ResizeHandlesStr != ST_ResizeHandlesStrUnset {
		e.EncodeToken(_b.CharData(_bffa.ST_ResizeHandlesStr.String()))
	}
	return e.EncodeToken(_b.EndElement{Name: start.Name})
}
func (_egac *StyleDefHdr) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_egac.CT_StyleDefinitionHeader = *NewCT_StyleDefinitionHeader()
	for _, _ebcdd := range start.Attr {
		if _ebcdd.Name.Local == "uniqueId" {
			_abba, _cadfb := _ebcdd.Value, error(nil)
			if _cadfb != nil {
				return _cadfb
			}
			_egac.UniqueIdAttr = _abba
			continue
		}
		if _ebcdd.Name.Local == "minVer" {
			_afcad, _fgbb := _ebcdd.Value, error(nil)
			if _fgbb != nil {
				return _fgbb
			}
			_egac.MinVerAttr = &_afcad
			continue
		}
		if _ebcdd.Name.Local == "resId" {
			_ggde, _becgd := _d.ParseInt(_ebcdd.Value, 10, 32)
			if _becgd != nil {
				return _becgd
			}
			_beaag := int32(_ggde)
			_egac.ResIdAttr = &_beaag
			continue
		}
	}
_agcf:
	for {
		_bccb, _acagb := d.Token()
		if _acagb != nil {
			return _acagb
		}
		switch _fffe := _bccb.(type) {
		case _b.StartElement:
			switch _fffe.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "title"}:
				_aafe := NewCT_SDName()
				if _cbeac := d.DecodeElement(_aafe, &_fffe); _cbeac != nil {
					return _cbeac
				}
				_egac.Title = append(_egac.Title, _aafe)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "desc"}:
				_becda := NewCT_SDDescription()
				if _decb := d.DecodeElement(_becda, &_fffe); _decb != nil {
					return _decb
				}
				_egac.Desc = append(_egac.Desc, _becda)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "catLst"}:
				_egac.CatLst = NewCT_SDCategories()
				if _bgdg := d.DecodeElement(_egac.CatLst, &_fffe); _bgdg != nil {
					return _bgdg
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_egac.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _geda := d.DecodeElement(_egac.ExtLst, &_fffe); _geda != nil {
					return _geda
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020StyleDefHdr\u0020\u0025v", _fffe.Name)
				if _degb := d.Skip(); _degb != nil {
					return _degb
				}
			}
		case _b.EndElement:
			break _agcf
		case _b.CharData:
		}
	}
	return nil
}
func (_gdggb ST_SecondaryChildAlignment) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_gdggb.String(), start)
}
func (_bddeg *CT_RelIds) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bdec := range start.Attr {
		if _bdec.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bdec.Name.Local == "dm" || _bdec.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bdec.Name.Local == "dm" {
			_gcgg, _abgd := _bdec.Value, error(nil)
			if _abgd != nil {
				return _abgd
			}
			_bddeg.DmAttr = _gcgg
			continue
		}
		if _bdec.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bdec.Name.Local == "lo" || _bdec.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bdec.Name.Local == "lo" {
			_afceg, _bdeb := _bdec.Value, error(nil)
			if _bdeb != nil {
				return _bdeb
			}
			_bddeg.LoAttr = _afceg
			continue
		}
		if _bdec.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bdec.Name.Local == "qs" || _bdec.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bdec.Name.Local == "qs" {
			_bgbg, _gfcd := _bdec.Value, error(nil)
			if _gfcd != nil {
				return _gfcd
			}
			_bddeg.QsAttr = _bgbg
			continue
		}
		if _bdec.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bdec.Name.Local == "cs" || _bdec.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bdec.Name.Local == "cs" {
			_ggafc, _deda := _bdec.Value, error(nil)
			if _deda != nil {
				return _deda
			}
			_bddeg.CsAttr = _ggafc
			continue
		}
	}
	for {
		_efgec, _fbgc := d.Token()
		if _fbgc != nil {
			return _a.Errorf("parsing\u0020CT_RelIds:\u0020\u0025s", _fbgc)
		}
		if _cbcb, _edgad := _efgec.(_b.EndElement); _edgad && _cbcb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fag *CT_AdjLst) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _fag.Adj != nil {
		_aa := _b.StartElement{Name: _b.Name{Local: "adj"}}
		for _, _cbae := range _fag.Adj {
			e.EncodeElement(_cbae, _aa)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the LayoutDefHdr and its children, prefixing error messages with path
func (_aaeec *LayoutDefHdr) ValidateWithPath(path string) error {
	if _gbbeb := _aaeec.CT_DiagramDefinitionHeader.ValidateWithPath(path); _gbbeb != nil {
		return _gbbeb
	}
	return nil
}
func (_eaffd ST_OutputShapeType) ValidateWithPath(path string) error {
	switch _eaffd {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eaffd))
	}
	return nil
}
func (_dgbd ST_BendPoint) Validate() error { return _dgbd.ValidateWithPath("") }

// Validate validates the CT_Algorithm and its children
func (_bfdg *CT_Algorithm) Validate() error { return _bfdg.ValidateWithPath("CT_Algorithm") }

// Validate validates the StyleDefHdrLst and its children
func (_aaag *StyleDefHdrLst) Validate() error { return _aaag.ValidateWithPath("StyleDefHdrLst") }

type ST_AnimLvlStr byte

func (_bgafc ST_ConnectorPoint) ValidateWithPath(path string) error {
	switch _bgafc {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bgafc))
	}
	return nil
}
func (_gfga ST_Offset) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_gfga.String(), start)
}

type ST_UnsignedInts []uint32

func (_cgdbg ST_PyramidAccentPosition) Validate() error { return _cgdbg.ValidateWithPath("") }
func (_efag ST_ContinueDirection) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_ggad := _b.Attr{}
	_ggad.Name = name
	switch _efag {
	case ST_ContinueDirectionUnset:
		_ggad.Value = ""
	case ST_ContinueDirectionRevDir:
		_ggad.Value = "revDir"
	case ST_ContinueDirectionSameDir:
		_ggad.Value = "sameDir"
	}
	return _ggad, nil
}
func (_cdbef *ST_AutoTextRotation) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_cdbef = 0
	case "none":
		*_cdbef = 1
	case "upr":
		*_cdbef = 2
	case "grav":
		*_cdbef = 3
	}
	return nil
}
func (_edecd *ST_ContinueDirection) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_egde, _ggbe := d.Token()
	if _ggbe != nil {
		return _ggbe
	}
	if _ddec, _efbd := _egde.(_b.EndElement); _efbd && _ddec.Name == start.Name {
		*_edecd = 1
		return nil
	}
	if _eead, _gbaeg := _egde.(_b.CharData); !_gbaeg {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _egde)
	} else {
		switch string(_eead) {
		case "":
			*_edecd = 0
		case "revDir":
			*_edecd = 1
		case "sameDir":
			*_edecd = 2
		}
	}
	_egde, _ggbe = d.Token()
	if _ggbe != nil {
		return _ggbe
	}
	if _ceef, _fagab := _egde.(_b.EndElement); _fagab && _ceef.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _egde)
}
func (_gfaa ST_ChildOrderType) Validate() error { return _gfaa.ValidateWithPath("") }

const (
	ST_ConnectorPointUnset  ST_ConnectorPoint = 0
	ST_ConnectorPointAuto   ST_ConnectorPoint = 1
	ST_ConnectorPointBCtr   ST_ConnectorPoint = 2
	ST_ConnectorPointCtr    ST_ConnectorPoint = 3
	ST_ConnectorPointMidL   ST_ConnectorPoint = 4
	ST_ConnectorPointMidR   ST_ConnectorPoint = 5
	ST_ConnectorPointTCtr   ST_ConnectorPoint = 6
	ST_ConnectorPointBL     ST_ConnectorPoint = 7
	ST_ConnectorPointBR     ST_ConnectorPoint = 8
	ST_ConnectorPointTL     ST_ConnectorPoint = 9
	ST_ConnectorPointTR     ST_ConnectorPoint = 10
	ST_ConnectorPointRadial ST_ConnectorPoint = 11
)

// ValidateWithPath validates the CT_Name and its children, prefixing error messages with path
func (_affb *CT_Name) ValidateWithPath(path string) error { return nil }
func (_gcadd *LayoutDef) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:di"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "layoutDef"
	return _gcadd.CT_DiagramDefinition.MarshalXML(e, start)
}
func (_agbcg *ST_AxisType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ddga, _ccbf := d.Token()
	if _ccbf != nil {
		return _ccbf
	}
	if _ceeef, _egdg := _ddga.(_b.EndElement); _egdg && _ceeef.Name == start.Name {
		*_agbcg = 1
		return nil
	}
	if _adbcfa, _cfacd := _ddga.(_b.CharData); !_cfacd {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ddga)
	} else {
		switch string(_adbcfa) {
		case "":
			*_agbcg = 0
		case "self":
			*_agbcg = 1
		case "ch":
			*_agbcg = 2
		case "des":
			*_agbcg = 3
		case "desOrSelf":
			*_agbcg = 4
		case "par":
			*_agbcg = 5
		case "ancst":
			*_agbcg = 6
		case "ancstOrSelf":
			*_agbcg = 7
		case "followSib":
			*_agbcg = 8
		case "precedSib":
			*_agbcg = 9
		case "follow":
			*_agbcg = 10
		case "preced":
			*_agbcg = 11
		case "root":
			*_agbcg = 12
		case "none":
			*_agbcg = 13
		}
	}
	_ddga, _ccbf = d.Token()
	if _ccbf != nil {
		return _ccbf
	}
	if _eegag, _dgef := _ddga.(_b.EndElement); _dgef && _eegag.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ddga)
}
func (_baab *ST_ContinueDirection) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_baab = 0
	case "revDir":
		*_baab = 1
	case "sameDir":
		*_baab = 2
	}
	return nil
}

// ValidateWithPath validates the CT_Categories and its children, prefixing error messages with path
func (_ggf *CT_Categories) ValidateWithPath(path string) error {
	for _geae, _dbe := range _ggf.Cat {
		if _gff := _dbe.ValidateWithPath(_a.Sprintf("\u0025s\u002fCat\u005b\u0025d\u005d", path, _geae)); _gff != nil {
			return _gff
		}
	}
	return nil
}
func (_cdgff ST_ConnectorDimension) ValidateWithPath(path string) error {
	switch _cdgff {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cdgff))
	}
	return nil
}
func (_acd *CT_BulletEnabled) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _acd.ValAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "val"}, Value: _a.Sprintf("\u0025d", _eecbc(*_acd.ValAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_cfgea ST_ContinueDirection) String() string {
	switch _cfgea {
	case 0:
		return ""
	case 1:
		return "revDir"
	case 2:
		return "sameDir"
	}
	return ""
}
func (_fbdg ST_NodeVerticalAlignment) Validate() error { return _fbdg.ValidateWithPath("") }

// Validate validates the LayoutDefHdr and its children
func (_eebb *LayoutDefHdr) Validate() error { return _eebb.ValidateWithPath("LayoutDefHdr") }

// ValidateWithPath validates the CT_When and its children, prefixing error messages with path
func (_dbef *CT_When) ValidateWithPath(path string) error {
	if _dbef.FuncAttr == ST_FunctionTypeUnset {
		return _a.Errorf("\u0025s\u002fFuncAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _gdff := _dbef.FuncAttr.ValidateWithPath(path + "\u002fFuncAttr"); _gdff != nil {
		return _gdff
	}
	if _dbef.ArgAttr != nil {
		if _baeg := _dbef.ArgAttr.ValidateWithPath(path + "\u002fArgAttr"); _baeg != nil {
			return _baeg
		}
	}
	if _dbef.OpAttr == ST_FunctionOperatorUnset {
		return _a.Errorf("\u0025s\u002fOpAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bdfc := _dbef.OpAttr.ValidateWithPath(path + "\u002fOpAttr"); _bdfc != nil {
		return _bdfc
	}
	if _dcafa := _dbef.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _dcafa != nil {
		return _dcafa
	}
	for _bgef, _bdage := range _dbef.Alg {
		if _geba := _bdage.ValidateWithPath(_a.Sprintf("\u0025s\u002fAlg\u005b\u0025d\u005d", path, _bgef)); _geba != nil {
			return _geba
		}
	}
	for _acde, _bgefg := range _dbef.Shape {
		if _gebfa := _bgefg.ValidateWithPath(_a.Sprintf("\u0025s\u002fShape\u005b\u0025d\u005d", path, _acde)); _gebfa != nil {
			return _gebfa
		}
	}
	for _efca, _cfgb := range _dbef.PresOf {
		if _gbafc := _cfgb.ValidateWithPath(_a.Sprintf("\u0025s\u002fPresOf\u005b\u0025d\u005d", path, _efca)); _gbafc != nil {
			return _gbafc
		}
	}
	for _cdbfg, _edebf := range _dbef.ConstrLst {
		if _fca := _edebf.ValidateWithPath(_a.Sprintf("\u0025s/ConstrLst\u005b\u0025d\u005d", path, _cdbfg)); _fca != nil {
			return _fca
		}
	}
	for _aeeca, _abfa := range _dbef.RuleLst {
		if _afae := _abfa.ValidateWithPath(_a.Sprintf("\u0025s\u002fRuleLst\u005b\u0025d\u005d", path, _aeeca)); _afae != nil {
			return _afae
		}
	}
	for _cfacg, _cbeeed := range _dbef.ForEach {
		if _dcdf := _cbeeed.ValidateWithPath(_a.Sprintf("\u0025s\u002fForEach\u005b\u0025d\u005d", path, _cfacg)); _dcdf != nil {
			return _dcdf
		}
	}
	for _gfdb, _ggegd := range _dbef.LayoutNode {
		if _ebfd := _ggegd.ValidateWithPath(_a.Sprintf("\u0025s\u002fLayoutNode\u005b\u0025d\u005d", path, _gfdb)); _ebfd != nil {
			return _ebfd
		}
	}
	for _abbbc, _afdea := range _dbef.Choose {
		if _gfabc := _afdea.ValidateWithPath(_a.Sprintf("\u0025s\u002fChoose\u005b\u0025d\u005d", path, _abbbc)); _gfabc != nil {
			return _gfabc
		}
	}
	for _ffec, _dgdc := range _dbef.ExtLst {
		if _cdad := _dgdc.ValidateWithPath(_a.Sprintf("\u0025s\u002fExtLst\u005b\u0025d\u005d", path, _ffec)); _cdad != nil {
			return _cdad
		}
	}
	return nil
}
func (_cdef ST_PtType) Validate() error { return _cdef.ValidateWithPath("") }

const (
	ST_DiagramHorizontalAlignmentUnset ST_DiagramHorizontalAlignment = 0
	ST_DiagramHorizontalAlignmentL     ST_DiagramHorizontalAlignment = 1
	ST_DiagramHorizontalAlignmentCtr   ST_DiagramHorizontalAlignment = 2
	ST_DiagramHorizontalAlignmentR     ST_DiagramHorizontalAlignment = 3
	ST_DiagramHorizontalAlignmentNone  ST_DiagramHorizontalAlignment = 4
)

// Validate validates the ColorsDefHdrLst and its children
func (_caff *ColorsDefHdrLst) Validate() error { return _caff.ValidateWithPath("ColorsDefHdrLst") }
func (_cgdgf ST_PyramidAccentTextMargin) String() string {
	switch _cgdgf {
	case 0:
		return ""
	case 1:
		return "step"
	case 2:
		return "stack"
	}
	return ""
}

type LayoutDefHdrLst struct{ CT_DiagramDefinitionHeaderLst }
type CT_Description struct {
	LangAttr *string
	ValAttr  string
}

func (_adga *ST_AnimOneStr) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_adga = 0
	case "none":
		*_adga = 1
	case "one":
		*_adga = 2
	case "branch":
		*_adga = 3
	}
	return nil
}
func (_ecbg *CT_ElemPropSet) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ecbg.PresAssocIDAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "presAssocID"}, Value: _a.Sprintf("\u0025v", *_ecbg.PresAssocIDAttr)})
	}
	if _ecbg.PresNameAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "presName"}, Value: _a.Sprintf("\u0025v", *_ecbg.PresNameAttr)})
	}
	if _ecbg.PresStyleLblAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "presStyleLbl"}, Value: _a.Sprintf("\u0025v", *_ecbg.PresStyleLblAttr)})
	}
	if _ecbg.PresStyleIdxAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "presStyleIdx"}, Value: _a.Sprintf("\u0025v", *_ecbg.PresStyleIdxAttr)})
	}
	if _ecbg.PresStyleCntAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "presStyleCnt"}, Value: _a.Sprintf("\u0025v", *_ecbg.PresStyleCntAttr)})
	}
	if _ecbg.LoTypeIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "loTypeId"}, Value: _a.Sprintf("\u0025v", *_ecbg.LoTypeIdAttr)})
	}
	if _ecbg.LoCatIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "loCatId"}, Value: _a.Sprintf("\u0025v", *_ecbg.LoCatIdAttr)})
	}
	if _ecbg.QsTypeIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "qsTypeId"}, Value: _a.Sprintf("\u0025v", *_ecbg.QsTypeIdAttr)})
	}
	if _ecbg.QsCatIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "qsCatId"}, Value: _a.Sprintf("\u0025v", *_ecbg.QsCatIdAttr)})
	}
	if _ecbg.CsTypeIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "csTypeId"}, Value: _a.Sprintf("\u0025v", *_ecbg.CsTypeIdAttr)})
	}
	if _ecbg.CsCatIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "csCatId"}, Value: _a.Sprintf("\u0025v", *_ecbg.CsCatIdAttr)})
	}
	if _ecbg.Coherent3DOffAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coherent3DOff"}, Value: _a.Sprintf("\u0025d", _eecbc(*_ecbg.Coherent3DOffAttr))})
	}
	if _ecbg.PhldrTAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "phldrT"}, Value: _a.Sprintf("\u0025v", *_ecbg.PhldrTAttr)})
	}
	if _ecbg.PhldrAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "phldr"}, Value: _a.Sprintf("\u0025d", _eecbc(*_ecbg.PhldrAttr))})
	}
	if _ecbg.CustAngAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custAng"}, Value: _a.Sprintf("\u0025v", *_ecbg.CustAngAttr)})
	}
	if _ecbg.CustFlipVertAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custFlipVert"}, Value: _a.Sprintf("\u0025d", _eecbc(*_ecbg.CustFlipVertAttr))})
	}
	if _ecbg.CustFlipHorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custFlipHor"}, Value: _a.Sprintf("\u0025d", _eecbc(*_ecbg.CustFlipHorAttr))})
	}
	if _ecbg.CustSzXAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custSzX"}, Value: _a.Sprintf("\u0025v", *_ecbg.CustSzXAttr)})
	}
	if _ecbg.CustSzYAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custSzY"}, Value: _a.Sprintf("\u0025v", *_ecbg.CustSzYAttr)})
	}
	if _ecbg.CustScaleXAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custScaleX"}, Value: _a.Sprintf("\u0025v", *_ecbg.CustScaleXAttr)})
	}
	if _ecbg.CustScaleYAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custScaleY"}, Value: _a.Sprintf("\u0025v", *_ecbg.CustScaleYAttr)})
	}
	if _ecbg.CustTAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custT"}, Value: _a.Sprintf("\u0025d", _eecbc(*_ecbg.CustTAttr))})
	}
	if _ecbg.CustLinFactXAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custLinFactX"}, Value: _a.Sprintf("\u0025v", *_ecbg.CustLinFactXAttr)})
	}
	if _ecbg.CustLinFactYAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custLinFactY"}, Value: _a.Sprintf("\u0025v", *_ecbg.CustLinFactYAttr)})
	}
	if _ecbg.CustLinFactNeighborXAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custLinFactNeighborX"}, Value: _a.Sprintf("\u0025v", *_ecbg.CustLinFactNeighborXAttr)})
	}
	if _ecbg.CustLinFactNeighborYAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custLinFactNeighborY"}, Value: _a.Sprintf("\u0025v", *_ecbg.CustLinFactNeighborYAttr)})
	}
	if _ecbg.CustRadScaleRadAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custRadScaleRad"}, Value: _a.Sprintf("\u0025v", *_ecbg.CustRadScaleRadAttr)})
	}
	if _ecbg.CustRadScaleIncAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "custRadScaleInc"}, Value: _a.Sprintf("\u0025v", *_ecbg.CustRadScaleIncAttr)})
	}
	e.EncodeToken(start)
	if _ecbg.PresLayoutVars != nil {
		_ecgfg := _b.StartElement{Name: _b.Name{Local: "presLayoutVars"}}
		e.EncodeElement(_ecbg.PresLayoutVars, _ecgfg)
	}
	if _ecbg.Style != nil {
		_gbfe := _b.StartElement{Name: _b.Name{Local: "style"}}
		e.EncodeElement(_ecbg.Style, _gbfe)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_gdabb *CT_Pt) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "modelId"}, Value: _a.Sprintf("\u0025v", _gdabb.ModelIdAttr)})
	if _gdabb.TypeAttr != ST_PtTypeUnset {
		_feag, _dgcf := _gdabb.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _dgcf != nil {
			return _dgcf
		}
		start.Attr = append(start.Attr, _feag)
	}
	if _gdabb.CxnIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cxnId"}, Value: _a.Sprintf("\u0025v", *_gdabb.CxnIdAttr)})
	}
	e.EncodeToken(start)
	if _gdabb.PrSet != nil {
		_daeg := _b.StartElement{Name: _b.Name{Local: "prSet"}}
		e.EncodeElement(_gdabb.PrSet, _daeg)
	}
	if _gdabb.SpPr != nil {
		_gcfgf := _b.StartElement{Name: _b.Name{Local: "spPr"}}
		e.EncodeElement(_gdabb.SpPr, _gcfgf)
	}
	if _gdabb.T != nil {
		_cgcb := _b.StartElement{Name: _b.Name{Local: "t"}}
		e.EncodeElement(_gdabb.T, _cgcb)
	}
	if _gdabb.ExtLst != nil {
		_gecf := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_gdabb.ExtLst, _gecf)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_RelIds and its children
func (_deag *CT_RelIds) Validate() error { return _deag.ValidateWithPath("CT_RelIds") }
func (_ceeg ST_GrowDirection) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_ceeg.String(), start)
}

// ValidateWithPath validates the AG_ConstraintAttributes and its children, prefixing error messages with path
func (_ca *AG_ConstraintAttributes) ValidateWithPath(path string) error {
	if _bd := _ca.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _bd != nil {
		return _bd
	}
	if _gca := _ca.ForAttr.ValidateWithPath(path + "\u002fForAttr"); _gca != nil {
		return _gca
	}
	if _gd := _ca.PtTypeAttr.ValidateWithPath(path + "/PtTypeAttr"); _gd != nil {
		return _gd
	}
	return nil
}
func (_adbe *ST_TextAnchorVertical) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_adbe = 0
	case "t":
		*_adbe = 1
	case "mid":
		*_adbe = 2
	case "b":
		*_adbe = 3
	}
	return nil
}
func (_caecbg *ST_VariableType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dddaea, _cbggb := d.Token()
	if _cbggb != nil {
		return _cbggb
	}
	if _bfebg, _fcad := _dddaea.(_b.EndElement); _fcad && _bfebg.Name == start.Name {
		*_caecbg = 1
		return nil
	}
	if _fbddb, _afaae := _dddaea.(_b.CharData); !_afaae {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dddaea)
	} else {
		switch string(_fbddb) {
		case "":
			*_caecbg = 0
		case "none":
			*_caecbg = 1
		case "orgChart":
			*_caecbg = 2
		case "chMax":
			*_caecbg = 3
		case "chPref":
			*_caecbg = 4
		case "bulEnabled":
			*_caecbg = 5
		case "dir":
			*_caecbg = 6
		case "hierBranch":
			*_caecbg = 7
		case "animOne":
			*_caecbg = 8
		case "animLvl":
			*_caecbg = 9
		case "resizeHandles":
			*_caecbg = 10
		}
	}
	_dddaea, _cbggb = d.Token()
	if _cbggb != nil {
		return _cbggb
	}
	if _beee, _gfgag := _dddaea.(_b.EndElement); _gfgag && _beee.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dddaea)
}
func (_gcaa *ST_FunctionArgument) Validate() error { return _gcaa.ValidateWithPath("") }

type ST_FlowDirection byte

func (_fabca ST_FallbackDimension) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_fabca.String(), start)
}
func (_dgafg ST_ElementType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gabea := _b.Attr{}
	_gabea.Name = name
	switch _dgafg {
	case ST_ElementTypeUnset:
		_gabea.Value = ""
	case ST_ElementTypeAll:
		_gabea.Value = "all"
	case ST_ElementTypeDoc:
		_gabea.Value = "doc"
	case ST_ElementTypeNode:
		_gabea.Value = "node"
	case ST_ElementTypeNorm:
		_gabea.Value = "norm"
	case ST_ElementTypeNonNorm:
		_gabea.Value = "nonNorm"
	case ST_ElementTypeAsst:
		_gabea.Value = "asst"
	case ST_ElementTypeNonAsst:
		_gabea.Value = "nonAsst"
	case ST_ElementTypeParTrans:
		_gabea.Value = "parTrans"
	case ST_ElementTypePres:
		_gabea.Value = "pres"
	case ST_ElementTypeSibTrans:
		_gabea.Value = "sibTrans"
	}
	return _gabea, nil
}

const (
	ST_AutoTextRotationUnset ST_AutoTextRotation = 0
	ST_AutoTextRotationNone  ST_AutoTextRotation = 1
	ST_AutoTextRotationUpr   ST_AutoTextRotation = 2
	ST_AutoTextRotationGrav  ST_AutoTextRotation = 3
)

func (_effdb ST_FunctionType) String() string {
	switch _effdb {
	case 0:
		return ""
	case 1:
		return "cnt"
	case 2:
		return "pos"
	case 3:
		return "revPos"
	case 4:
		return "posEven"
	case 5:
		return "posOdd"
	case 6:
		return "var"
	case 7:
		return "depth"
	case 8:
		return "maxDepth"
	}
	return ""
}

// ST_FunctionValue is a union type
type ST_FunctionValue struct {
	Int32               *int32
	Bool                *bool
	ST_Direction        ST_Direction
	ST_HierBranchStyle  ST_HierBranchStyle
	ST_AnimOneStr       ST_AnimOneStr
	ST_AnimLvlStr       ST_AnimLvlStr
	ST_ResizeHandlesStr ST_ResizeHandlesStr
}

func (_afcgc *ST_ModelId) Validate() error { return _afcgc.ValidateWithPath("") }

// ValidateWithPath validates the CT_HierBranchStyle and its children, prefixing error messages with path
func (_deea *CT_HierBranchStyle) ValidateWithPath(path string) error {
	if _dcge := _deea.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _dcge != nil {
		return _dcge
	}
	return nil
}
func (_fbgdb *CT_LayoutVariablePropertySet) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _fbgdb.OrgChart != nil {
		_ebbe := _b.StartElement{Name: _b.Name{Local: "orgChart"}}
		e.EncodeElement(_fbgdb.OrgChart, _ebbe)
	}
	if _fbgdb.ChMax != nil {
		_afce := _b.StartElement{Name: _b.Name{Local: "chMax"}}
		e.EncodeElement(_fbgdb.ChMax, _afce)
	}
	if _fbgdb.ChPref != nil {
		_gbbcg := _b.StartElement{Name: _b.Name{Local: "chPref"}}
		e.EncodeElement(_fbgdb.ChPref, _gbbcg)
	}
	if _fbgdb.BulletEnabled != nil {
		_fgcc := _b.StartElement{Name: _b.Name{Local: "bulletEnabled"}}
		e.EncodeElement(_fbgdb.BulletEnabled, _fgcc)
	}
	if _fbgdb.Dir != nil {
		_cdcfd := _b.StartElement{Name: _b.Name{Local: "dir"}}
		e.EncodeElement(_fbgdb.Dir, _cdcfd)
	}
	if _fbgdb.HierBranch != nil {
		_fefb := _b.StartElement{Name: _b.Name{Local: "hierBranch"}}
		e.EncodeElement(_fbgdb.HierBranch, _fefb)
	}
	if _fbgdb.AnimOne != nil {
		_ecfb := _b.StartElement{Name: _b.Name{Local: "animOne"}}
		e.EncodeElement(_fbgdb.AnimOne, _ecfb)
	}
	if _fbgdb.AnimLvl != nil {
		_aeec := _b.StartElement{Name: _b.Name{Local: "animLvl"}}
		e.EncodeElement(_fbgdb.AnimLvl, _aeec)
	}
	if _fbgdb.ResizeHandles != nil {
		_cacac := _b.StartElement{Name: _b.Name{Local: "resizeHandles"}}
		e.EncodeElement(_fbgdb.ResizeHandles, _cacac)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_gbf *CT_Adj) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gbf.IdxAttr = 1
	for _, _gdgd := range start.Attr {
		if _gdgd.Name.Local == "idx" {
			_bfd, _feg := _d.ParseUint(_gdgd.Value, 10, 32)
			if _feg != nil {
				return _feg
			}
			_gbf.IdxAttr = uint32(_bfd)
			continue
		}
		if _gdgd.Name.Local == "val" {
			_adg, _fdd := _d.ParseFloat(_gdgd.Value, 64)
			if _fdd != nil {
				return _fdd
			}
			_gbf.ValAttr = _adg
			continue
		}
	}
	for {
		_dae, _gg := d.Token()
		if _gg != nil {
			return _a.Errorf("parsing\u0020CT_Adj:\u0020\u0025s", _gg)
		}
		if _fge, _af := _dae.(_b.EndElement); _af && _fge.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ccfbb *ST_Offset) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_ccfbb = 0
	case "ctr":
		*_ccfbb = 1
	case "off":
		*_ccfbb = 2
	}
	return nil
}
func NewCT_CTCategories() *CT_CTCategories { _edga := &CT_CTCategories{}; return _edga }

// Validate validates the CT_ChildMax and its children
func (_ebbc *CT_ChildMax) Validate() error { return _ebbc.ValidateWithPath("CT_ChildMax") }

// Validate validates the DataModel and its children
func (_ccggb *DataModel) Validate() error { return _ccggb.ValidateWithPath("DataModel") }

// Validate validates the CT_DiagramDefinitionHeaderLst and its children
func (_ebgf *CT_DiagramDefinitionHeaderLst) Validate() error {
	return _ebgf.ValidateWithPath("CT_DiagramDefinitionHeaderLst")
}
func (_acbff ST_ContinueDirection) Validate() error { return _acbff.ValidateWithPath("") }
func (_eecab ST_TextAnchorHorizontal) ValidateWithPath(path string) error {
	switch _eecab {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eecab))
	}
	return nil
}
func (_bbdef ST_StartingElement) String() string {
	switch _bbdef {
	case 0:
		return ""
	case 1:
		return "node"
	case 2:
		return "trans"
	}
	return ""
}

// ValidateWithPath validates the CT_ColorTransform and its children, prefixing error messages with path
func (_aedb *CT_ColorTransform) ValidateWithPath(path string) error {
	for _cgga, _cbddf := range _aedb.Title {
		if _bbc := _cbddf.ValidateWithPath(_a.Sprintf("\u0025s\u002fTitle\u005b\u0025d\u005d", path, _cgga)); _bbc != nil {
			return _bbc
		}
	}
	for _gcd, _gec := range _aedb.Desc {
		if _gfge := _gec.ValidateWithPath(_a.Sprintf("%s\u002fDesc\u005b\u0025d\u005d", path, _gcd)); _gfge != nil {
			return _gfge
		}
	}
	if _aedb.CatLst != nil {
		if _beca := _aedb.CatLst.ValidateWithPath(path + "\u002fCatLst"); _beca != nil {
			return _beca
		}
	}
	for _ceg, _eabc := range _aedb.StyleLbl {
		if _bbfbg := _eabc.ValidateWithPath(_a.Sprintf("\u0025s\u002fStyleLbl\u005b\u0025d\u005d", path, _ceg)); _bbfbg != nil {
			return _bbfbg
		}
	}
	if _aedb.ExtLst != nil {
		if _cdbg := _aedb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cdbg != nil {
			return _cdbg
		}
	}
	return nil
}

type ST_Booleans []bool

const (
	ST_VerticalAlignmentUnset ST_VerticalAlignment = 0
	ST_VerticalAlignmentT     ST_VerticalAlignment = 1
	ST_VerticalAlignmentMid   ST_VerticalAlignment = 2
	ST_VerticalAlignmentB     ST_VerticalAlignment = 3
	ST_VerticalAlignmentNone  ST_VerticalAlignment = 4
)

func (_ebgeg *CT_When) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ebgeg.FuncAttr = ST_FunctionType(1)
	_ebgeg.OpAttr = ST_FunctionOperator(1)
	for _, _agffa := range start.Attr {
		if _agffa.Name.Local == "name" {
			_bdgbe, _bccg := _agffa.Value, error(nil)
			if _bccg != nil {
				return _bccg
			}
			_ebgeg.NameAttr = &_bdgbe
			continue
		}
		if _agffa.Name.Local == "arg" {
			_ccbge, _eaaa := ParseUnionST_FunctionArgument(_agffa.Value)
			if _eaaa != nil {
				return _eaaa
			}
			_ebgeg.ArgAttr = &_ccbge
			continue
		}
		if _agffa.Name.Local == "val" {
			_agee, _ffac := ParseUnionST_FunctionValue(_agffa.Value)
			if _ffac != nil {
				return _ffac
			}
			_ebgeg.ValAttr = _agee
			continue
		}
		if _agffa.Name.Local == "func" {
			_ebgeg.FuncAttr.UnmarshalXMLAttr(_agffa)
			continue
		}
		if _agffa.Name.Local == "op" {
			_ebgeg.OpAttr.UnmarshalXMLAttr(_agffa)
			continue
		}
		if _agffa.Name.Local == "axis" {
			_ceec, _adccf := ParseSliceST_AxisTypes(_agffa.Value)
			if _adccf != nil {
				return _adccf
			}
			_ebgeg.AxisAttr = &_ceec
			continue
		}
		if _agffa.Name.Local == "ptType" {
			_bfbbd, _eebe := ParseSliceST_ElementTypes(_agffa.Value)
			if _eebe != nil {
				return _eebe
			}
			_ebgeg.PtTypeAttr = &_bfbbd
			continue
		}
		if _agffa.Name.Local == "hideLastTrans" {
			_gfea, _cbbe := ParseSliceST_Booleans(_agffa.Value)
			if _cbbe != nil {
				return _cbbe
			}
			_ebgeg.HideLastTransAttr = &_gfea
			continue
		}
		if _agffa.Name.Local == "st" {
			_baga, _ffaa := ParseSliceST_Ints(_agffa.Value)
			if _ffaa != nil {
				return _ffaa
			}
			_ebgeg.StAttr = &_baga
			continue
		}
		if _agffa.Name.Local == "cnt" {
			_abbb, _ebcb := ParseSliceST_UnsignedInts(_agffa.Value)
			if _ebcb != nil {
				return _ebcb
			}
			_ebgeg.CntAttr = &_abbb
			continue
		}
		if _agffa.Name.Local == "step" {
			_ebae, _bfff := ParseSliceST_Ints(_agffa.Value)
			if _bfff != nil {
				return _bfff
			}
			_ebgeg.StepAttr = &_ebae
			continue
		}
	}
_bebb:
	for {
		_cfbg, _ecgg := d.Token()
		if _ecgg != nil {
			return _ecgg
		}
		switch _dbace := _cfbg.(type) {
		case _b.StartElement:
			switch _dbace.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "alg"}:
				_aedda := NewCT_Algorithm()
				if _fbgb := d.DecodeElement(_aedda, &_dbace); _fbgb != nil {
					return _fbgb
				}
				_ebgeg.Alg = append(_ebgeg.Alg, _aedda)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "shape"}:
				_gefff := NewCT_Shape()
				if _ffffg := d.DecodeElement(_gefff, &_dbace); _ffffg != nil {
					return _ffffg
				}
				_ebgeg.Shape = append(_ebgeg.Shape, _gefff)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "presOf"}:
				_bbde := NewCT_PresentationOf()
				if _afbga := d.DecodeElement(_bbde, &_dbace); _afbga != nil {
					return _afbga
				}
				_ebgeg.PresOf = append(_ebgeg.PresOf, _bbde)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "constrLst"}:
				_eaeb := NewCT_Constraints()
				if _gbce := d.DecodeElement(_eaeb, &_dbace); _gbce != nil {
					return _gbce
				}
				_ebgeg.ConstrLst = append(_ebgeg.ConstrLst, _eaeb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "ruleLst"}:
				_cdggd := NewCT_Rules()
				if _fcceb := d.DecodeElement(_cdggd, &_dbace); _fcceb != nil {
					return _fcceb
				}
				_ebgeg.RuleLst = append(_ebgeg.RuleLst, _cdggd)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "forEach"}:
				_cgagf := NewCT_ForEach()
				if _efgef := d.DecodeElement(_cgagf, &_dbace); _efgef != nil {
					return _efgef
				}
				_ebgeg.ForEach = append(_ebgeg.ForEach, _cgagf)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "layoutNode"}:
				_bbegg := NewCT_LayoutNode()
				if _gbfbad := d.DecodeElement(_bbegg, &_dbace); _gbfbad != nil {
					return _gbfbad
				}
				_ebgeg.LayoutNode = append(_ebgeg.LayoutNode, _bbegg)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "choose"}:
				_fcffb := NewCT_Choose()
				if _agcbe := d.DecodeElement(_fcffb, &_dbace); _agcbe != nil {
					return _agcbe
				}
				_ebgeg.Choose = append(_ebgeg.Choose, _fcffb)
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_dcbg := _f.NewCT_OfficeArtExtensionList()
				if _gddcc := d.DecodeElement(_dcbg, &_dbace); _gddcc != nil {
					return _gddcc
				}
				_ebgeg.ExtLst = append(_ebgeg.ExtLst, _dcbg)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_When\u0020\u0025v", _dbace.Name)
				if _gfff := d.Skip(); _gfff != nil {
					return _gfff
				}
			}
		case _b.EndElement:
			break _bebb
		case _b.CharData:
		}
	}
	return nil
}
func (_ebe *CT_AdjLst) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_ddc:
	for {
		_ff, _cdb := d.Token()
		if _cdb != nil {
			return _cdb
		}
		switch _dff := _ff.(type) {
		case _b.StartElement:
			switch _dff.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "adj"}:
				_daf := NewCT_Adj()
				if _cdf := d.DecodeElement(_daf, &_dff); _cdf != nil {
					return _cdf
				}
				_ebe.Adj = append(_ebe.Adj, _daf)
			default:
				_ea.Log("skipping\u0020unsupported\u0020element on CT_AdjLst \u0025v", _dff.Name)
				if _bc := d.Skip(); _bc != nil {
					return _bc
				}
			}
		case _b.EndElement:
			break _ddc
		case _b.CharData:
		}
	}
	return nil
}
func (_dceba *CT_Otherwise) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _dceba.NameAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "name"}, Value: _a.Sprintf("\u0025v", *_dceba.NameAttr)})
	}
	e.EncodeToken(start)
	if _dceba.Alg != nil {
		_aabe := _b.StartElement{Name: _b.Name{Local: "alg"}}
		for _, _bgdc := range _dceba.Alg {
			e.EncodeElement(_bgdc, _aabe)
		}
	}
	if _dceba.Shape != nil {
		_affc := _b.StartElement{Name: _b.Name{Local: "shape"}}
		for _, _cedc := range _dceba.Shape {
			e.EncodeElement(_cedc, _affc)
		}
	}
	if _dceba.PresOf != nil {
		_bgcc := _b.StartElement{Name: _b.Name{Local: "presOf"}}
		for _, _abga := range _dceba.PresOf {
			e.EncodeElement(_abga, _bgcc)
		}
	}
	if _dceba.ConstrLst != nil {
		_gagg := _b.StartElement{Name: _b.Name{Local: "constrLst"}}
		for _, _dced := range _dceba.ConstrLst {
			e.EncodeElement(_dced, _gagg)
		}
	}
	if _dceba.RuleLst != nil {
		_agcc := _b.StartElement{Name: _b.Name{Local: "ruleLst"}}
		for _, _cdbag := range _dceba.RuleLst {
			e.EncodeElement(_cdbag, _agcc)
		}
	}
	if _dceba.ForEach != nil {
		_aeaaa := _b.StartElement{Name: _b.Name{Local: "forEach"}}
		for _, _aged := range _dceba.ForEach {
			e.EncodeElement(_aged, _aeaaa)
		}
	}
	if _dceba.LayoutNode != nil {
		_agfbb := _b.StartElement{Name: _b.Name{Local: "layoutNode"}}
		for _, _ddfa := range _dceba.LayoutNode {
			e.EncodeElement(_ddfa, _agfbb)
		}
	}
	if _dceba.Choose != nil {
		_dfeb := _b.StartElement{Name: _b.Name{Local: "choose"}}
		for _, _cfac := range _dceba.Choose {
			e.EncodeElement(_cfac, _dfeb)
		}
	}
	if _dceba.ExtLst != nil {
		_gede := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		for _, _bbcc := range _dceba.ExtLst {
			e.EncodeElement(_bbcc, _gede)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_babcf *ST_ResizeHandlesStr) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ceab, _efba := d.Token()
	if _efba != nil {
		return _efba
	}
	if _ggaaa, _cbcbg := _ceab.(_b.EndElement); _cbcbg && _ggaaa.Name == start.Name {
		*_babcf = 1
		return nil
	}
	if _aege, _bbcda := _ceab.(_b.CharData); !_bbcda {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ceab)
	} else {
		switch string(_aege) {
		case "":
			*_babcf = 0
		case "exact":
			*_babcf = 1
		case "rel":
			*_babcf = 2
		}
	}
	_ceab, _efba = d.Token()
	if _efba != nil {
		return _efba
	}
	if _gaad, _eeab := _ceab.(_b.EndElement); _eeab && _gaad.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ceab)
}
func (_cdbgd *CT_StyleDefinitionHeaderLst) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _cdbgd.StyleDefHdr != nil {
		_dbdfb := _b.StartElement{Name: _b.Name{Local: "styleDefHdr"}}
		for _, _decac := range _cdbgd.StyleDefHdr {
			e.EncodeElement(_decac, _dbdfb)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_cdbbd ST_ConstraintRelationship) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_cdbbd.String(), start)
}

type CT_CTStyleLabel struct {
	NameAttr       string
	FillClrLst     *CT_Colors
	LinClrLst      *CT_Colors
	EffectClrLst   *CT_Colors
	TxLinClrLst    *CT_Colors
	TxFillClrLst   *CT_Colors
	TxEffectClrLst *CT_Colors
	ExtLst         *_f.CT_OfficeArtExtensionList
}
type ST_OutputShapeType byte

func (_ggdg *ST_StartingElement) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_ggdg = 0
	case "node":
		*_ggdg = 1
	case "trans":
		*_ggdg = 2
	}
	return nil
}
func (_fada *CT_Shape) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _gdbce := range start.Attr {
		if _gdbce.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _gdbce.Name.Local == "blip" || _gdbce.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _gdbce.Name.Local == "blip" {
			_cbgf, _egfg := _gdbce.Value, error(nil)
			if _egfg != nil {
				return _egfg
			}
			_fada.BlipAttr = &_cbgf
			continue
		}
		if _gdbce.Name.Local == "rot" {
			_cgea, _addb := _d.ParseFloat(_gdbce.Value, 64)
			if _addb != nil {
				return _addb
			}
			_fada.RotAttr = &_cgea
			continue
		}
		if _gdbce.Name.Local == "type" {
			_cbdg, _acdg := ParseUnionST_LayoutShapeType(_gdbce.Value)
			if _acdg != nil {
				return _acdg
			}
			_fada.TypeAttr = &_cbdg
			continue
		}
		if _gdbce.Name.Local == "zOrderOff" {
			_caaf, _bcccf := _d.ParseInt(_gdbce.Value, 10, 32)
			if _bcccf != nil {
				return _bcccf
			}
			_eadff := int32(_caaf)
			_fada.ZOrderOffAttr = &_eadff
			continue
		}
		if _gdbce.Name.Local == "hideGeom" {
			_geaab, _gfabe := _d.ParseBool(_gdbce.Value)
			if _gfabe != nil {
				return _gfabe
			}
			_fada.HideGeomAttr = &_geaab
			continue
		}
		if _gdbce.Name.Local == "lkTxEntry" {
			_gbeb, _beebc := _d.ParseBool(_gdbce.Value)
			if _beebc != nil {
				return _beebc
			}
			_fada.LkTxEntryAttr = &_gbeb
			continue
		}
		if _gdbce.Name.Local == "blipPhldr" {
			_aebgc, _gded := _d.ParseBool(_gdbce.Value)
			if _gded != nil {
				return _gded
			}
			_fada.BlipPhldrAttr = &_aebgc
			continue
		}
	}
_ecffa:
	for {
		_agfg, _dabag := d.Token()
		if _dabag != nil {
			return _dabag
		}
		switch _abadd := _agfg.(type) {
		case _b.StartElement:
			switch _abadd.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "adjLst"}:
				_fada.AdjLst = NewCT_AdjLst()
				if _cfef := d.DecodeElement(_fada.AdjLst, &_abadd); _cfef != nil {
					return _cfef
				}
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_fada.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _ffcbe := d.DecodeElement(_fada.ExtLst, &_abadd); _ffcbe != nil {
					return _ffcbe
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Shape\u0020\u0025v", _abadd.Name)
				if _acfe := d.Skip(); _acfe != nil {
					return _acfe
				}
			}
		case _b.EndElement:
			break _ecffa
		case _b.CharData:
		}
	}
	return nil
}
func (_cgcgb *ST_Breakpoint) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_eadb, _bbdce := d.Token()
	if _bbdce != nil {
		return _bbdce
	}
	if _bbdaa, _dedc := _eadb.(_b.EndElement); _dedc && _bbdaa.Name == start.Name {
		*_cgcgb = 1
		return nil
	}
	if _ffacg, _fddec := _eadb.(_b.CharData); !_fddec {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eadb)
	} else {
		switch string(_ffacg) {
		case "":
			*_cgcgb = 0
		case "endCnv":
			*_cgcgb = 1
		case "bal":
			*_cgcgb = 2
		case "fixed":
			*_cgcgb = 3
		}
	}
	_eadb, _bbdce = d.Token()
	if _bbdce != nil {
		return _bbdce
	}
	if _ceaddd, _aaeed := _eadb.(_b.EndElement); _aaeed && _ceaddd.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eadb)
}
func (_aefgc ST_SecondaryLinearDirection) ValidateWithPath(path string) error {
	switch _aefgc {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aefgc))
	}
	return nil
}
func NewCT_CTDescription() *CT_CTDescription { _gdb := &CT_CTDescription{}; return _gdb }
func (_ecab *ST_ConnectorPoint) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_ecab = 0
	case "auto":
		*_ecab = 1
	case "bCtr":
		*_ecab = 2
	case "ctr":
		*_ecab = 3
	case "midL":
		*_ecab = 4
	case "midR":
		*_ecab = 5
	case "tCtr":
		*_ecab = 6
	case "bL":
		*_ecab = 7
	case "bR":
		*_ecab = 8
	case "tL":
		*_ecab = 9
	case "tR":
		*_ecab = 10
	case "radial":
		*_ecab = 11
	}
	return nil
}

// Validate validates the CT_ForEach and its children
func (_dbecc *CT_ForEach) Validate() error { return _dbecc.ValidateWithPath("CT_ForEach") }
func (_adbd ST_TextAnchorVertical) ValidateWithPath(path string) error {
	switch _adbd {
	case 0, 1, 2, 3:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_adbd))
	}
	return nil
}
func (_gabb ST_Offset) Validate() error { return _gabb.ValidateWithPath("") }
func (_cfec *ST_Breakpoint) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_cfec = 0
	case "endCnv":
		*_cfec = 1
	case "bal":
		*_cfec = 2
	case "fixed":
		*_cfec = 3
	}
	return nil
}
func (_eggcf ST_PyramidAccentTextMargin) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_adgcd := _b.Attr{}
	_adgcd.Name = name
	switch _eggcf {
	case ST_PyramidAccentTextMarginUnset:
		_adgcd.Value = ""
	case ST_PyramidAccentTextMarginStep:
		_adgcd.Value = "step"
	case ST_PyramidAccentTextMarginStack:
		_adgcd.Value = "stack"
	}
	return _adgcd, nil
}
func (_cddca ST_AutoTextRotation) String() string {
	switch _cddca {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "upr"
	case 3:
		return "grav"
	}
	return ""
}
func (_gegbg ST_PyramidAccentPosition) ValidateWithPath(path string) error {
	switch _gegbg {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gegbg))
	}
	return nil
}

// ValidateWithPath validates the CT_AnimLvl and its children, prefixing error messages with path
func (_cgg *CT_AnimLvl) ValidateWithPath(path string) error {
	if _fba := _cgg.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _fba != nil {
		return _fba
	}
	return nil
}
func (_ebad ST_OutputShapeType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_fbfgc := _b.Attr{}
	_fbfgc.Name = name
	switch _ebad {
	case ST_OutputShapeTypeUnset:
		_fbfgc.Value = ""
	case ST_OutputShapeTypeNone:
		_fbfgc.Value = "none"
	case ST_OutputShapeTypeConn:
		_fbfgc.Value = "conn"
	}
	return _fbfgc, nil
}

type CT_LayoutNode struct {
	NameAttr     *string
	StyleLblAttr *string
	ChOrderAttr  ST_ChildOrderType
	MoveWithAttr *string
	Alg          []*CT_Algorithm
	Shape        []*CT_Shape
	PresOf       []*CT_PresentationOf
	ConstrLst    []*CT_Constraints
	RuleLst      []*CT_Rules
	VarLst       []*CT_LayoutVariablePropertySet
	ForEach      []*CT_ForEach
	LayoutNode   []*CT_LayoutNode
	Choose       []*CT_Choose
	ExtLst       []*_f.CT_OfficeArtExtensionList
}

func (_dcdfa ST_ConstraintType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dcdfa.String(), start)
}
func (_bedf *RelIds) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:di"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "relIds"
	return _bedf.CT_RelIds.MarshalXML(e, start)
}

type CT_DiagramDefinitionHeader struct {
	UniqueIdAttr string
	MinVerAttr   *string
	DefStyleAttr *string
	ResIdAttr    *int32
	Title        []*CT_Name
	Desc         []*CT_Description
	CatLst       *CT_Categories
	ExtLst       *_f.CT_OfficeArtExtensionList
}

// Validate validates the CT_HierBranchStyle and its children
func (_abbd *CT_HierBranchStyle) Validate() error {
	return _abbd.ValidateWithPath("CT_HierBranchStyle")
}
func (_cbbf ST_ChildOrderType) ValidateWithPath(path string) error {
	switch _cbbf {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cbbf))
	}
	return nil
}
func (_cegf ST_SecondaryLinearDirection) String() string {
	switch _cegf {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "fromL"
	case 3:
		return "fromR"
	case 4:
		return "fromT"
	case 5:
		return "fromB"
	}
	return ""
}
func (_bee *CT_Cxn) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dgab := range start.Attr {
		if _dgab.Name.Local == "modelId" {
			_bbd, _daba := ParseUnionST_ModelId(_dgab.Value)
			if _daba != nil {
				return _daba
			}
			_bee.ModelIdAttr = _bbd
			continue
		}
		if _dgab.Name.Local == "type" {
			_bee.TypeAttr.UnmarshalXMLAttr(_dgab)
			continue
		}
		if _dgab.Name.Local == "srcId" {
			_ffge, _cdab := ParseUnionST_ModelId(_dgab.Value)
			if _cdab != nil {
				return _cdab
			}
			_bee.SrcIdAttr = _ffge
			continue
		}
		if _dgab.Name.Local == "destId" {
			_ada, _bddb := ParseUnionST_ModelId(_dgab.Value)
			if _bddb != nil {
				return _bddb
			}
			_bee.DestIdAttr = _ada
			continue
		}
		if _dgab.Name.Local == "srcOrd" {
			_gdgf, _fgbd := _d.ParseUint(_dgab.Value, 10, 32)
			if _fgbd != nil {
				return _fgbd
			}
			_bee.SrcOrdAttr = uint32(_gdgf)
			continue
		}
		if _dgab.Name.Local == "destOrd" {
			_geeb, _efge := _d.ParseUint(_dgab.Value, 10, 32)
			if _efge != nil {
				return _efge
			}
			_bee.DestOrdAttr = uint32(_geeb)
			continue
		}
		if _dgab.Name.Local == "parTransId" {
			_bad, _cebf := ParseUnionST_ModelId(_dgab.Value)
			if _cebf != nil {
				return _cebf
			}
			_bee.ParTransIdAttr = &_bad
			continue
		}
		if _dgab.Name.Local == "sibTransId" {
			_dgce, _abdc := ParseUnionST_ModelId(_dgab.Value)
			if _abdc != nil {
				return _abdc
			}
			_bee.SibTransIdAttr = &_dgce
			continue
		}
		if _dgab.Name.Local == "presId" {
			_fbgg, _eccf := _dgab.Value, error(nil)
			if _eccf != nil {
				return _eccf
			}
			_bee.PresIdAttr = &_fbgg
			continue
		}
	}
_bfad:
	for {
		_fbe, _dbee := d.Token()
		if _dbee != nil {
			return _dbee
		}
		switch _acgd := _fbe.(type) {
		case _b.StartElement:
			switch _acgd.Name {
			case _b.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", Local: "extLst"}:
				_bee.ExtLst = _f.NewCT_OfficeArtExtensionList()
				if _agad := d.DecodeElement(_bee.ExtLst, &_acgd); _agad != nil {
					return _agad
				}
			default:
				_ea.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Cxn\u0020\u0025v", _acgd.Name)
				if _faadc := d.Skip(); _faadc != nil {
					return _faadc
				}
			}
		case _b.EndElement:
			break _bfad
		case _b.CharData:
		}
	}
	return nil
}

type CT_Pt struct {
	ModelIdAttr ST_ModelId
	TypeAttr    ST_PtType
	CxnIdAttr   *ST_ModelId
	PrSet       *CT_ElemPropSet
	SpPr        *_f.CT_ShapeProperties
	T           *_f.CT_TextBody
	ExtLst      *_f.CT_OfficeArtExtensionList
}

func (_bdged *ST_FunctionValue) ValidateWithPath(path string) error {
	_gdace := []string{}
	if _bdged.Int32 != nil {
		_gdace = append(_gdace, "Int32")
	}
	if _bdged.Bool != nil {
		_gdace = append(_gdace, "Bool")
	}
	if _bdged.ST_Direction != ST_DirectionUnset {
		_gdace = append(_gdace, "ST_Direction")
	}
	if _bdged.ST_HierBranchStyle != ST_HierBranchStyleUnset {
		_gdace = append(_gdace, "ST_HierBranchStyle")
	}
	if _bdged.ST_AnimOneStr != ST_AnimOneStrUnset {
		_gdace = append(_gdace, "ST_AnimOneStr")
	}
	if _bdged.ST_AnimLvlStr != ST_AnimLvlStrUnset {
		_gdace = append(_gdace, "ST_AnimLvlStr")
	}
	if _bdged.ST_ResizeHandlesStr != ST_ResizeHandlesStrUnset {
		_gdace = append(_gdace, "ST_ResizeHandlesStr")
	}
	if len(_gdace) > 1 {
		return _a.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _gdace)
	}
	return nil
}

// ValidateWithPath validates the CT_StyleLabel and its children, prefixing error messages with path
func (_edca *CT_StyleLabel) ValidateWithPath(path string) error {
	if _edca.Scene3d != nil {
		if _dabab := _edca.Scene3d.ValidateWithPath(path + "\u002fScene3d"); _dabab != nil {
			return _dabab
		}
	}
	if _edca.Sp3d != nil {
		if _bfag := _edca.Sp3d.ValidateWithPath(path + "\u002fSp3d"); _bfag != nil {
			return _bfag
		}
	}
	if _edca.TxPr != nil {
		if _bebfe := _edca.TxPr.ValidateWithPath(path + "\u002fTxPr"); _bebfe != nil {
			return _bebfe
		}
	}
	if _edca.Style != nil {
		if _egdfa := _edca.Style.ValidateWithPath(path + "\u002fStyle"); _egdfa != nil {
			return _egdfa
		}
	}
	if _edca.ExtLst != nil {
		if _cegc := _edca.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cegc != nil {
			return _cegc
		}
	}
	return nil
}
func (_fdde *CT_DiagramDefinitionHeader) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "uniqueId"}, Value: _a.Sprintf("\u0025v", _fdde.UniqueIdAttr)})
	if _fdde.MinVerAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "minVer"}, Value: _a.Sprintf("\u0025v", *_fdde.MinVerAttr)})
	}
	if _fdde.DefStyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "defStyle"}, Value: _a.Sprintf("\u0025v", *_fdde.DefStyleAttr)})
	}
	if _fdde.ResIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "resId"}, Value: _a.Sprintf("\u0025v", *_fdde.ResIdAttr)})
	}
	e.EncodeToken(start)
	_feed := _b.StartElement{Name: _b.Name{Local: "title"}}
	for _, _cgae := range _fdde.Title {
		e.EncodeElement(_cgae, _feed)
	}
	_gfed := _b.StartElement{Name: _b.Name{Local: "desc"}}
	for _, _aab := range _fdde.Desc {
		e.EncodeElement(_aab, _gfed)
	}
	if _fdde.CatLst != nil {
		_ggg := _b.StartElement{Name: _b.Name{Local: "catLst"}}
		e.EncodeElement(_fdde.CatLst, _ggg)
	}
	if _fdde.ExtLst != nil {
		_gbg := _b.StartElement{Name: _b.Name{Local: "extLst"}}
		e.EncodeElement(_fdde.ExtLst, _gbg)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_efaaa *ST_SecondaryChildAlignment) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_efaaa = 0
	case "none":
		*_efaaa = 1
	case "t":
		*_efaaa = 2
	case "b":
		*_efaaa = 3
	case "l":
		*_efaaa = 4
	case "r":
		*_efaaa = 5
	}
	return nil
}
func (_cccb ST_TextBlockDirection) String() string {
	switch _cccb {
	case 0:
		return ""
	case 1:
		return "horz"
	case 2:
		return "vert"
	}
	return ""
}

type ST_SecondaryChildAlignment byte

func (_ddgbb ST_FunctionArgument) String() string {
	if _ddgbb.ST_VariableType != ST_VariableTypeUnset {
		return _ddgbb.ST_VariableType.String()
	}
	return ""
}
func (_acaa ST_ContinueDirection) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_acaa.String(), start)
}
func NewCT_Description() *CT_Description { _caecc := &CT_Description{}; return _caecc }

type CT_Cxn struct {
	ModelIdAttr    ST_ModelId
	TypeAttr       ST_CxnType
	SrcIdAttr      ST_ModelId
	DestIdAttr     ST_ModelId
	SrcOrdAttr     uint32
	DestOrdAttr    uint32
	ParTransIdAttr *ST_ModelId
	SibTransIdAttr *ST_ModelId
	PresIdAttr     *string
	ExtLst         *_f.CT_OfficeArtExtensionList
}

const (
	ST_DiagramTextAlignmentUnset ST_DiagramTextAlignment = 0
	ST_DiagramTextAlignmentL     ST_DiagramTextAlignment = 1
	ST_DiagramTextAlignmentCtr   ST_DiagramTextAlignment = 2
	ST_DiagramTextAlignmentR     ST_DiagramTextAlignment = 3
)
const (
	ST_ClrAppMethodUnset  ST_ClrAppMethod = 0
	ST_ClrAppMethodSpan   ST_ClrAppMethod = 1
	ST_ClrAppMethodCycle  ST_ClrAppMethod = 2
	ST_ClrAppMethodRepeat ST_ClrAppMethod = 3
)

func NewColorsDefHdr() *ColorsDefHdr {
	_gcff := &ColorsDefHdr{}
	_gcff.CT_ColorTransformHeader = *NewCT_ColorTransformHeader()
	return _gcff
}
func (_gbbf *ST_LayoutShapeType) ValidateWithPath(path string) error {
	_dcafg := []string{}
	if _gbbf.ST_ShapeType != _f.ST_ShapeTypeUnset {
		_dcafg = append(_dcafg, "ST_ShapeType")
	}
	if _gbbf.ST_OutputShapeType != ST_OutputShapeTypeUnset {
		_dcafg = append(_dcafg, "ST_OutputShapeType")
	}
	if len(_dcafg) > 1 {
		return _a.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _dcafg)
	}
	return nil
}
func (_fgaee ST_Offset) ValidateWithPath(path string) error {
	switch _fgaee {
	case 0, 1, 2:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fgaee))
	}
	return nil
}

// ValidateWithPath validates the CT_SampleData and its children, prefixing error messages with path
func (_bface *CT_SampleData) ValidateWithPath(path string) error {
	if _bface.DataModel != nil {
		if _cefa := _bface.DataModel.ValidateWithPath(path + "\u002fDataModel"); _cefa != nil {
			return _cefa
		}
	}
	return nil
}
func NewColorsDef() *ColorsDef {
	_dfca := &ColorsDef{}
	_dfca.CT_ColorTransform = *NewCT_ColorTransform()
	return _dfca
}
func (_cffb *CT_Constraints) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _cffb.Constr != nil {
		_gdbe := _b.StartElement{Name: _b.Name{Local: "constr"}}
		for _, _agcbg := range _cffb.Constr {
			e.EncodeElement(_agcbg, _gdbe)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_AnimLvl and its children
func (_daff *CT_AnimLvl) Validate() error { return _daff.ValidateWithPath("CT_AnimLvl") }
func NewCT_CTName() *CT_CTName            { _gfg := &CT_CTName{}; return _gfg }

// ValidateWithPath validates the CT_ChildMax and its children, prefixing error messages with path
func (_bggc *CT_ChildMax) ValidateWithPath(path string) error {
	if _bggc.ValAttr != nil {
		if *_bggc.ValAttr < -1 {
			return _a.Errorf("\u0025s/m\u002eValAttr must be\u0020\u003e\u003d\u0020\u002d1 \u0028have\u0020\u0025v\u0029", path, *_bggc.ValAttr)
		}
	}
	return nil
}

type ST_AnimOneStr byte

const (
	ST_ChildDirectionUnset ST_ChildDirection = 0
	ST_ChildDirectionHorz  ST_ChildDirection = 1
	ST_ChildDirectionVert  ST_ChildDirection = 2
)

func (_caacf *ST_BoolOperator) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_egad, _fgbaf := d.Token()
	if _fgbaf != nil {
		return _fgbaf
	}
	if _ccdf, _bbaaf := _egad.(_b.EndElement); _bbaaf && _ccdf.Name == start.Name {
		*_caacf = 1
		return nil
	}
	if _bfaaf, _fggef := _egad.(_b.CharData); !_fggef {
		return _a.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _egad)
	} else {
		switch string(_bfaaf) {
		case "":
			*_caacf = 0
		case "none":
			*_caacf = 1
		case "equ":
			*_caacf = 2
		case "gte":
			*_caacf = 3
		case "lte":
			*_caacf = 4
		}
	}
	_egad, _fgbaf = d.Token()
	if _fgbaf != nil {
		return _fgbaf
	}
	if _fagdd, _acaeg := _egad.(_b.EndElement); _acaeg && _fagdd.Name == start.Name {
		return nil
	}
	return _a.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _egad)
}
func (_fcbc ST_SecondaryLinearDirection) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_fcbc.String(), start)
}
func init() {
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_CTName", NewCT_CTName)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_CTDescription", NewCT_CTDescription)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_CTCategory", NewCT_CTCategory)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_CTCategories", NewCT_CTCategories)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Colors", NewCT_Colors)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_CTStyleLabel", NewCT_CTStyleLabel)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_ColorTransform", NewCT_ColorTransform)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_ColorTransformHeader", NewCT_ColorTransformHeader)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_ColorTransformHeaderLst", NewCT_ColorTransformHeaderLst)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Pt", NewCT_Pt)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_PtList", NewCT_PtList)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Cxn", NewCT_Cxn)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_CxnList", NewCT_CxnList)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_DataModel", NewCT_DataModel)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Constraint", NewCT_Constraint)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Constraints", NewCT_Constraints)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_NumericRule", NewCT_NumericRule)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Rules", NewCT_Rules)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_PresentationOf", NewCT_PresentationOf)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Adj", NewCT_Adj)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_AdjLst", NewCT_AdjLst)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Shape", NewCT_Shape)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Parameter", NewCT_Parameter)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Algorithm", NewCT_Algorithm)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_LayoutNode", NewCT_LayoutNode)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_ForEach", NewCT_ForEach)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_When", NewCT_When)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Otherwise", NewCT_Otherwise)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Choose", NewCT_Choose)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_SampleData", NewCT_SampleData)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Category", NewCT_Category)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Categories", NewCT_Categories)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Name", NewCT_Name)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Description", NewCT_Description)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_DiagramDefinition", NewCT_DiagramDefinition)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_DiagramDefinitionHeader", NewCT_DiagramDefinitionHeader)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_DiagramDefinitionHeaderLst", NewCT_DiagramDefinitionHeaderLst)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_RelIds", NewCT_RelIds)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_ElemPropSet", NewCT_ElemPropSet)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_OrgChart", NewCT_OrgChart)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_ChildMax", NewCT_ChildMax)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_ChildPref", NewCT_ChildPref)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_BulletEnabled", NewCT_BulletEnabled)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_Direction", NewCT_Direction)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_HierBranchStyle", NewCT_HierBranchStyle)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_AnimOne", NewCT_AnimOne)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_AnimLvl", NewCT_AnimLvl)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_ResizeHandles", NewCT_ResizeHandles)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_LayoutVariablePropertySet", NewCT_LayoutVariablePropertySet)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_SDName", NewCT_SDName)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_SDDescription", NewCT_SDDescription)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_SDCategory", NewCT_SDCategory)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_SDCategories", NewCT_SDCategories)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_TextProps", NewCT_TextProps)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_StyleLabel", NewCT_StyleLabel)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_StyleDefinition", NewCT_StyleDefinition)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_StyleDefinitionHeader", NewCT_StyleDefinitionHeader)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "CT_StyleDefinitionHeaderLst", NewCT_StyleDefinitionHeaderLst)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "colorsDef", NewColorsDef)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "colorsDefHdr", NewColorsDefHdr)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "colorsDefHdrLst", NewColorsDefHdrLst)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "dataModel", NewDataModel)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "layoutDef", NewLayoutDef)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "layoutDefHdr", NewLayoutDefHdr)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "layoutDefHdrLst", NewLayoutDefHdrLst)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "relIds", NewRelIds)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "styleDef", NewStyleDef)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "styleDefHdr", NewStyleDefHdr)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "styleDefHdrLst", NewStyleDefHdrLst)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "AG_IteratorAttributes", NewAG_IteratorAttributes)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "AG_ConstraintAttributes", NewAG_ConstraintAttributes)
	_ea.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fdiagram", "AG_ConstraintRefAttributes", NewAG_ConstraintRefAttributes)
}
func (_gcf *CT_CTCategory) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "type"}, Value: _a.Sprintf("\u0025v", _gcf.TypeAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "pri"}, Value: _a.Sprintf("\u0025v", _gcf.PriAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_CTCategories and its children, prefixing error messages with path
func (_aec *CT_CTCategories) ValidateWithPath(path string) error {
	for _cebb, _bde := range _aec.Cat {
		if _abad := _bde.ValidateWithPath(_a.Sprintf("\u0025s\u002fCat\u005b\u0025d\u005d", path, _cebb)); _abad != nil {
			return _abad
		}
	}
	return nil
}

type CT_DiagramDefinitionHeaderLst struct{ LayoutDefHdr []*CT_DiagramDefinitionHeader }

func (_afgdd ST_BoolOperator) ValidateWithPath(path string) error {
	switch _afgdd {
	case 0, 1, 2, 3, 4:
	default:
		return _a.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_afgdd))
	}
	return nil
}

// Validate validates the CT_CTStyleLabel and its children
func (_faad *CT_CTStyleLabel) Validate() error { return _faad.ValidateWithPath("CT_CTStyleLabel") }
