//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package picture

import (
	_g "encoding/xml"
	_c "gitee.com/greatmusicians/unioffice"
	_f "gitee.com/greatmusicians/unioffice/schema/soo/dml"
)

type CT_Picture struct {
	NvPicPr  *CT_PictureNonVisual
	BlipFill *_f.CT_BlipFillProperties
	SpPr     *_f.CT_ShapeProperties
}

func (_gf *CT_Picture) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gf.NvPicPr = NewCT_PictureNonVisual()
	_gf.BlipFill = _f.NewCT_BlipFillProperties()
	_gf.SpPr = _f.NewCT_ShapeProperties()
_dg:
	for {
		_gff, _e := d.Token()
		if _e != nil {
			return _e
		}
		switch _cc := _gff.(type) {
		case _g.StartElement:
			switch _cc.Name {
			case _g.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture", Local: "nvPicPr"}, _g.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fpicture", Local: "nvPicPr"}:
				if _ed := d.DecodeElement(_gf.NvPicPr, &_cc); _ed != nil {
					return _ed
				}
			case _g.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture", Local: "blipFill"}, _g.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fpicture", Local: "blipFill"}:
				if _gg := d.DecodeElement(_gf.BlipFill, &_cc); _gg != nil {
					return _gg
				}
			case _g.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture", Local: "spPr"}, _g.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fpicture", Local: "spPr"}:
				if _cda := d.DecodeElement(_gf.SpPr, &_cc); _cda != nil {
					return _cda
				}
			default:
				_c.Log("skipping unsupported\u0020element\u0020on\u0020CT_Picture\u0020\u0025v", _cc.Name)
				if _cef := d.Skip(); _cef != nil {
					return _cef
				}
			}
		case _g.EndElement:
			break _dg
		case _g.CharData:
		}
	}
	return nil
}
func NewCT_PictureNonVisual() *CT_PictureNonVisual {
	_bb := &CT_PictureNonVisual{}
	_bb.CNvPr = _f.NewCT_NonVisualDrawingProps()
	_bb.CNvPicPr = _f.NewCT_NonVisualPictureProperties()
	return _bb
}

// ValidateWithPath validates the CT_Picture and its children, prefixing error messages with path
func (_ab *CT_Picture) ValidateWithPath(path string) error {
	if _efc := _ab.NvPicPr.ValidateWithPath(path + "\u002fNvPicPr"); _efc != nil {
		return _efc
	}
	if _feg := _ab.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _feg != nil {
		return _feg
	}
	if _fb := _ab.SpPr.ValidateWithPath(path + "\u002fSpPr"); _fb != nil {
		return _fb
	}
	return nil
}

type CT_PictureNonVisual struct {
	CNvPr    *_f.CT_NonVisualDrawingProps
	CNvPicPr *_f.CT_NonVisualPictureProperties
}
type Pic struct{ CT_Picture }

func NewCT_Picture() *CT_Picture {
	_d := &CT_Picture{}
	_d.NvPicPr = NewCT_PictureNonVisual()
	_d.BlipFill = _f.NewCT_BlipFillProperties()
	_d.SpPr = _f.NewCT_ShapeProperties()
	return _d
}
func (_be *CT_PictureNonVisual) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_cf := _g.StartElement{Name: _g.Name{Local: "pic:cNvPr"}}
	e.EncodeElement(_be.CNvPr, _cf)
	_bg := _g.StartElement{Name: _g.Name{Local: "pic:cNvPicPr"}}
	e.EncodeElement(_be.CNvPicPr, _bg)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_bd *Pic) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture"})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:pic"}, Value: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture"})
//	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "pic:pic"
	return _bd.CT_Picture.MarshalXML(e, start)
}

// Validate validates the CT_Picture and its children
func (_ef *CT_Picture) Validate() error { return _ef.ValidateWithPath("CT_Picture") }
func (_ebc *Pic) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ebc.CT_Picture = *NewCT_Picture()
_gcd:
	for {
		_fc, _ec := d.Token()
		if _ec != nil {
			return _ec
		}
		switch _ee := _fc.(type) {
		case _g.StartElement:
			switch _ee.Name {
			case _g.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture", Local: "nvPicPr"}, _g.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fpicture", Local: "nvPicPr"}:
				if _ag := d.DecodeElement(_ebc.NvPicPr, &_ee); _ag != nil {
					return _ag
				}
			case _g.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture", Local: "blipFill"}, _g.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fpicture", Local: "blipFill"}:
				if _fdd := d.DecodeElement(_ebc.BlipFill, &_ee); _fdd != nil {
					return _fdd
				}
			case _g.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture", Local: "spPr"}, _g.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fpicture", Local: "spPr"}:
				if _ad := d.DecodeElement(_ebc.SpPr, &_ee); _ad != nil {
					return _ad
				}
			default:
				_c.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Pic\u0020\u0025v", _ee.Name)
				if _aa := d.Skip(); _aa != nil {
					return _aa
				}
			}
		case _g.EndElement:
			break _gcd
		case _g.CharData:
		}
	}
	return nil
}
func NewPic() *Pic { _af := &Pic{}; _af.CT_Picture = *NewCT_Picture(); return _af }

// Validate validates the Pic and its children
func (_egd *Pic) Validate() error { return _egd.ValidateWithPath("Pic") }

// Validate validates the CT_PictureNonVisual and its children
func (_fd *CT_PictureNonVisual) Validate() error { return _fd.ValidateWithPath("CT_PictureNonVisual") }
func (_cd *CT_Picture) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	_fe := _g.StartElement{Name: _g.Name{Local: "pic:nvPicPr"}}
	e.EncodeElement(_cd.NvPicPr, _fe)
	_a := _g.StartElement{Name: _g.Name{Local: "pic:blipFill"}}
	e.EncodeElement(_cd.BlipFill, _a)
	_ce := _g.StartElement{Name: _g.Name{Local: "pic:spPr"}}
	e.EncodeElement(_cd.SpPr, _ce)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Pic and its children, prefixing error messages with path
func (_da *Pic) ValidateWithPath(path string) error {
	if _dga := _da.CT_Picture.ValidateWithPath(path); _dga != nil {
		return _dga
	}
	return nil
}

// ValidateWithPath validates the CT_PictureNonVisual and its children, prefixing error messages with path
func (_cce *CT_PictureNonVisual) ValidateWithPath(path string) error {
	if _gc := _cce.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _gc != nil {
		return _gc
	}
	if _eda := _cce.CNvPicPr.ValidateWithPath(path + "\u002fCNvPicPr"); _eda != nil {
		return _eda
	}
	return nil
}
func (_fef *CT_PictureNonVisual) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fef.CNvPr = _f.NewCT_NonVisualDrawingProps()
	_fef.CNvPicPr = _f.NewCT_NonVisualPictureProperties()
_bgd:
	for {
		_dd, _eb := d.Token()
		if _eb != nil {
			return _eb
		}
		switch _ca := _dd.(type) {
		case _g.StartElement:
			switch _ca.Name {
			case _g.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture", Local: "cNvPr"}, _g.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fpicture", Local: "cNvPr"}:
				if _ba := d.DecodeElement(_fef.CNvPr, &_ca); _ba != nil {
					return _ba
				}
			case _g.Name{Space: "http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture", Local: "cNvPicPr"}, _g.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fpicture", Local: "cNvPicPr"}:
				if _eg := d.DecodeElement(_fef.CNvPicPr, &_ca); _eg != nil {
					return _eg
				}
			default:
				_c.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PictureNonVisual\u0020\u0025v", _ca.Name)
				if _cad := d.Skip(); _cad != nil {
					return _cad
				}
			}
		case _g.EndElement:
			break _bgd
		case _g.CharData:
		}
	}
	return nil
}
func init() {
	_c.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture", "CT_PictureNonVisual", NewCT_PictureNonVisual)
	_c.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture", "CT_Picture", NewCT_Picture)
	_c.RegisterConstructor("http:\u002f/schemas.openxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fpicture", "pic", NewPic)
}
