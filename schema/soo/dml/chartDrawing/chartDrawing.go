//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package chartDrawing

import (
	_dc "encoding/xml"
	_de "fmt"
	_g "gitee.com/greatmusicians/unioffice"
	_c "gitee.com/greatmusicians/unioffice/schema/soo/dml"
	_f "strconv"
)

type EG_ObjectChoicesChoice struct {
	Sp           *CT_Shape
	GrpSp        *CT_GroupShape
	GraphicFrame *CT_GraphicFrame
	CxnSp        *CT_Connector
	Pic          *CT_Picture
}

func (_eeg *CT_Drawing) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	start.Name.Local = "CT_Drawing"
	e.EncodeToken(start)
	if _eeg.EG_Anchor != nil {
		for _, _ge := range _eeg.EG_Anchor {
			_ge.MarshalXML(e, _dc.StartElement{})
		}
	}
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}
func NewCT_RelSizeAnchor() *CT_RelSizeAnchor {
	_dge := &CT_RelSizeAnchor{}
	_dge.From = NewCT_Marker()
	_dge.To = NewCT_Marker()
	return _dge
}
func NewEG_Anchor() *EG_Anchor { _ggc := &EG_Anchor{}; return _ggc }

type CT_GraphicFrame struct {
	MacroAttr        *string
	FPublishedAttr   *bool
	NvGraphicFramePr *CT_GraphicFrameNonVisual
	Xfrm             *_c.CT_Transform2D
	Graphic          *_c.Graphic
}

func NewCT_GraphicFrameNonVisual() *CT_GraphicFrameNonVisual {
	_dcfb := &CT_GraphicFrameNonVisual{}
	_dcfb.CNvPr = _c.NewCT_NonVisualDrawingProps()
	_dcfb.CNvGraphicFramePr = _c.NewCT_NonVisualGraphicFrameProperties()
	return _dcfb
}

// Validate validates the CT_RelSizeAnchor and its children
func (_bbd *CT_RelSizeAnchor) Validate() error { return _bbd.ValidateWithPath("CT_RelSizeAnchor") }

// ValidateWithPath validates the EG_Anchor and its children, prefixing error messages with path
func (_cgdc *EG_Anchor) ValidateWithPath(path string) error {
	if _cgdc.RelSizeAnchor != nil {
		if _ffb := _cgdc.RelSizeAnchor.ValidateWithPath(path + "\u002fRelSizeAnchor"); _ffb != nil {
			return _ffb
		}
	}
	if _cgdc.AbsSizeAnchor != nil {
		if _dfdg := _cgdc.AbsSizeAnchor.ValidateWithPath(path + "\u002fAbsSizeAnchor"); _dfdg != nil {
			return _dfdg
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ConnectorNonVisual and its children, prefixing error messages with path
func (_bbf *CT_ConnectorNonVisual) ValidateWithPath(path string) error {
	if _bcf := _bbf.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _bcf != nil {
		return _bcf
	}
	if _ecg := _bbf.CNvCxnSpPr.ValidateWithPath(path + "/CNvCxnSpPr"); _ecg != nil {
		return _ecg
	}
	return nil
}
func (_bfg *CT_GroupShapeChoice) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
_dcb:
	for {
		_eee, _dcbd := d.Token()
		if _dcbd != nil {
			return _dcbd
		}
		switch _fcb := _eee.(type) {
		case _dc.StartElement:
			switch _fcb.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "sp"}:
				_gaad := NewCT_Shape()
				if _efde := d.DecodeElement(_gaad, &_fcb); _efde != nil {
					return _efde
				}
				_bfg.Sp = append(_bfg.Sp, _gaad)
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "grpSp"}:
				_dcfbe := NewCT_GroupShape()
				if _bfb := d.DecodeElement(_dcfbe, &_fcb); _bfb != nil {
					return _bfb
				}
				_bfg.GrpSp = append(_bfg.GrpSp, _dcfbe)
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "graphicFrame"}:
				_def := NewCT_GraphicFrame()
				if _cgca := d.DecodeElement(_def, &_fcb); _cgca != nil {
					return _cgca
				}
				_bfg.GraphicFrame = append(_bfg.GraphicFrame, _def)
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cxnSp"}:
				_egd := NewCT_Connector()
				if _dgc := d.DecodeElement(_egd, &_fcb); _dgc != nil {
					return _dgc
				}
				_bfg.CxnSp = append(_bfg.CxnSp, _egd)
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "pic"}:
				_dcee := NewCT_Picture()
				if _adgd := d.DecodeElement(_dcee, &_fcb); _adgd != nil {
					return _adgd
				}
				_bfg.Pic = append(_bfg.Pic, _dcee)
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GroupShapeChoice\u0020\u0025v", _fcb.Name)
				if _aec := d.Skip(); _aec != nil {
					return _aec
				}
			}
		case _dc.EndElement:
			break _dcb
		case _dc.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Picture and its children
func (_bfff *CT_Picture) Validate() error { return _bfff.ValidateWithPath("CT_Picture") }
func (_baa *CT_GroupShapeChoice) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	if _baa.Sp != nil {
		_cfg := _dc.StartElement{Name: _dc.Name{Local: "sp"}}
		for _, _adc := range _baa.Sp {
			e.EncodeElement(_adc, _cfg)
		}
	}
	if _baa.GrpSp != nil {
		_bba := _dc.StartElement{Name: _dc.Name{Local: "grpSp"}}
		for _, _bgb := range _baa.GrpSp {
			e.EncodeElement(_bgb, _bba)
		}
	}
	if _baa.GraphicFrame != nil {
		_feg := _dc.StartElement{Name: _dc.Name{Local: "graphicFrame"}}
		for _, _cgg := range _baa.GraphicFrame {
			e.EncodeElement(_cgg, _feg)
		}
	}
	if _baa.CxnSp != nil {
		_dcd := _dc.StartElement{Name: _dc.Name{Local: "cxnSp"}}
		for _, _aca := range _baa.CxnSp {
			e.EncodeElement(_aca, _dcd)
		}
	}
	if _baa.Pic != nil {
		_cge := _dc.StartElement{Name: _dc.Name{Local: "pic"}}
		for _, _gbe := range _baa.Pic {
			e.EncodeElement(_gbe, _cge)
		}
	}
	return nil
}
func (_b *CT_AbsSizeAnchor) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	e.EncodeToken(start)
	_a := _dc.StartElement{Name: _dc.Name{Local: "from"}}
	e.EncodeElement(_b.From, _a)
	_da := _dc.StartElement{Name: _dc.Name{Local: "ext"}}
	e.EncodeElement(_b.Ext, _da)
	if _b.Choice != nil {
		_b.Choice.MarshalXML(e, _dc.StartElement{})
	}
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_GroupShapeChoice and its children
func (_aff *CT_GroupShapeChoice) Validate() error {
	return _aff.ValidateWithPath("CT_GroupShapeChoice")
}
func (_adb *CT_Drawing) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
_dfbb:
	for {
		_ffc, _dedf := d.Token()
		if _dedf != nil {
			return _dedf
		}
		switch _agf := _ffc.(type) {
		case _dc.StartElement:
			switch _agf.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "relSizeAnchor"}:
				_af := NewEG_Anchor()
				_af.RelSizeAnchor = NewCT_RelSizeAnchor()
				if _gcb := d.DecodeElement(_af.RelSizeAnchor, &_agf); _gcb != nil {
					return _gcb
				}
				_adb.EG_Anchor = append(_adb.EG_Anchor, _af)
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "absSizeAnchor"}:
				_cc := NewEG_Anchor()
				_cc.AbsSizeAnchor = NewCT_AbsSizeAnchor()
				if _cgf := d.DecodeElement(_cc.AbsSizeAnchor, &_agf); _cgf != nil {
					return _cgf
				}
				_adb.EG_Anchor = append(_adb.EG_Anchor, _cc)
			default:
				_g.Log("skipping unsupported\u0020element\u0020on\u0020CT_Drawing\u0020\u0025v", _agf.Name)
				if _ba := d.Skip(); _ba != nil {
					return _ba
				}
			}
		case _dc.EndElement:
			break _dfbb
		case _dc.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_GroupShapeNonVisual and its children, prefixing error messages with path
func (_bdbg *CT_GroupShapeNonVisual) ValidateWithPath(path string) error {
	if _dbef := _bdbg.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _dbef != nil {
		return _dbef
	}
	if _fbac := _bdbg.CNvGrpSpPr.ValidateWithPath(path + "/CNvGrpSpPr"); _fbac != nil {
		return _fbac
	}
	return nil
}

type CT_GroupShape struct {
	NvGrpSpPr *CT_GroupShapeNonVisual
	GrpSpPr   *_c.CT_GroupShapeProperties
	Choice    []*CT_GroupShapeChoice
}

func _dgbc(_fbgg bool) uint8 {
	if _fbgg {
		return 1
	}
	return 0
}

type CT_ConnectorNonVisual struct {
	CNvPr      *_c.CT_NonVisualDrawingProps
	CNvCxnSpPr *_c.CT_NonVisualConnectorProperties
}

// Validate validates the CT_Drawing and its children
func (_ecc *CT_Drawing) Validate() error { return _ecc.ValidateWithPath("CT_Drawing") }
func (_bbg *CT_Marker) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	e.EncodeToken(start)
	_cdg := _dc.StartElement{Name: _dc.Name{Local: "x"}}
	e.EncodeElement(_bbg.X, _cdg)
	_fad := _dc.StartElement{Name: _dc.Name{Local: "y"}}
	e.EncodeElement(_bbg.Y, _fad)
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}
func (_bd *CT_AbsSizeAnchor) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_bd.From = NewCT_Marker()
	_bd.Ext = _c.NewCT_PositiveSize2D()
_gb:
	for {
		_bf, _fe := d.Token()
		if _fe != nil {
			return _fe
		}
		switch _e := _bf.(type) {
		case _dc.StartElement:
			switch _e.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "from"}:
				if _eg := d.DecodeElement(_bd.From, &_e); _eg != nil {
					return _eg
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "ext"}:
				if _fa := d.DecodeElement(_bd.Ext, &_e); _fa != nil {
					return _fa
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "sp"}:
				_bd.Choice = NewEG_ObjectChoicesChoice()
				if _df := d.DecodeElement(&_bd.Choice.Sp, &_e); _df != nil {
					return _df
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "grpSp"}:
				_bd.Choice = NewEG_ObjectChoicesChoice()
				if _fd := d.DecodeElement(&_bd.Choice.GrpSp, &_e); _fd != nil {
					return _fd
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "graphicFrame"}:
				_bd.Choice = NewEG_ObjectChoicesChoice()
				if _fdd := d.DecodeElement(&_bd.Choice.GraphicFrame, &_e); _fdd != nil {
					return _fdd
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cxnSp"}:
				_bd.Choice = NewEG_ObjectChoicesChoice()
				if _be := d.DecodeElement(&_bd.Choice.CxnSp, &_e); _be != nil {
					return _be
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "pic"}:
				_bd.Choice = NewEG_ObjectChoicesChoice()
				if _gbg := d.DecodeElement(&_bd.Choice.Pic, &_e); _gbg != nil {
					return _gbg
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_AbsSizeAnchor\u0020\u0025v", _e.Name)
				if _aa := d.Skip(); _aa != nil {
					return _aa
				}
			}
		case _dc.EndElement:
			break _gb
		case _dc.CharData:
		}
	}
	return nil
}
func (_fddgb *CT_ShapeNonVisual) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_fddgb.CNvPr = _c.NewCT_NonVisualDrawingProps()
	_fddgb.CNvSpPr = _c.NewCT_NonVisualDrawingShapeProps()
_aeec:
	for {
		_eag, _eccf := d.Token()
		if _eccf != nil {
			return _eccf
		}
		switch _daf := _eag.(type) {
		case _dc.StartElement:
			switch _daf.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cNvPr"}:
				if _bbad := d.DecodeElement(_fddgb.CNvPr, &_daf); _bbad != nil {
					return _bbad
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cNvSpPr"}:
				if _bdea := d.DecodeElement(_fddgb.CNvSpPr, &_daf); _bdea != nil {
					return _bdea
				}
			default:
				_g.Log("skipping unsupported\u0020element\u0020on\u0020CT_ShapeNonVisual\u0020\u0025v", _daf.Name)
				if _eba := d.Skip(); _eba != nil {
					return _eba
				}
			}
		case _dc.EndElement:
			break _aeec
		case _dc.CharData:
		}
	}
	return nil
}

type CT_GraphicFrameNonVisual struct {
	CNvPr             *_c.CT_NonVisualDrawingProps
	CNvGraphicFramePr *_c.CT_NonVisualGraphicFrameProperties
}

func (_cab *CT_Marker) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_cab.X = 0.0
	_cab.Y = 0.0
_cdce:
	for {
		_aad, _ebb := d.Token()
		if _ebb != nil {
			return _ebb
		}
		switch _dfg := _aad.(type) {
		case _dc.StartElement:
			switch _dfg.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "x"}:
				if _dfbg := d.DecodeElement(&_cab.X, &_dfg); _dfbg != nil {
					return _dfbg
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "y"}:
				if _fg := d.DecodeElement(&_cab.Y, &_dfg); _fg != nil {
					return _fg
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element on CT_Marker \u0025v", _dfg.Name)
				if _afc := d.Skip(); _afc != nil {
					return _afc
				}
			}
		case _dc.EndElement:
			break _cdce
		case _dc.CharData:
		}
	}
	return nil
}
func (_cd *CT_Connector) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_cd.NvCxnSpPr = NewCT_ConnectorNonVisual()
	_cd.SpPr = _c.NewCT_ShapeProperties()
	for _, _faa := range start.Attr {
		if _faa.Name.Local == "macro" {
			_bg, _dcf := _faa.Value, error(nil)
			if _dcf != nil {
				return _dcf
			}
			_cd.MacroAttr = &_bg
			continue
		}
		if _faa.Name.Local == "fPublished" {
			_ff, _ddg := _f.ParseBool(_faa.Value)
			if _ddg != nil {
				return _ddg
			}
			_cd.FPublishedAttr = &_ff
			continue
		}
	}
_gg:
	for {
		_bbb, _ded := d.Token()
		if _ded != nil {
			return _ded
		}
		switch _fdf := _bbb.(type) {
		case _dc.StartElement:
			switch _fdf.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "nvCxnSpPr"}:
				if _dec := d.DecodeElement(_cd.NvCxnSpPr, &_fdf); _dec != nil {
					return _dec
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "spPr"}:
				if _bgd := d.DecodeElement(_cd.SpPr, &_fdf); _bgd != nil {
					return _bgd
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "style"}:
				_cd.Style = _c.NewCT_ShapeStyle()
				if _dg := d.DecodeElement(_cd.Style, &_fdf); _dg != nil {
					return _dg
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Connector\u0020\u0025v", _fdf.Name)
				if _bc := d.Skip(); _bc != nil {
					return _bc
				}
			}
		case _dc.EndElement:
			break _gg
		case _dc.CharData:
		}
	}
	return nil
}

// Validate validates the CT_GraphicFrameNonVisual and its children
func (_fag *CT_GraphicFrameNonVisual) Validate() error {
	return _fag.ValidateWithPath("CT_GraphicFrameNonVisual")
}
func NewCT_Drawing() *CT_Drawing { _ddfa := &CT_Drawing{}; return _ddfa }

// Validate validates the CT_Shape and its children
func (_fga *CT_Shape) Validate() error { return _fga.ValidateWithPath("CT_Shape") }
func NewCT_GroupShapeNonVisual() *CT_GroupShapeNonVisual {
	_gde := &CT_GroupShapeNonVisual{}
	_gde.CNvPr = _c.NewCT_NonVisualDrawingProps()
	_gde.CNvGrpSpPr = _c.NewCT_NonVisualGroupDrawingShapeProps()
	return _gde
}

// Validate validates the CT_ShapeNonVisual and its children
func (_ggaf *CT_ShapeNonVisual) Validate() error { return _ggaf.ValidateWithPath("CT_ShapeNonVisual") }
func NewCT_Marker() *CT_Marker                   { _bad := &CT_Marker{}; _bad.X = 0.0; _bad.Y = 0.0; return _bad }

// ValidateWithPath validates the EG_ObjectChoices and its children, prefixing error messages with path
func (_ace *EG_ObjectChoices) ValidateWithPath(path string) error {
	if _ace.Choice != nil {
		if _dcda := _ace.Choice.ValidateWithPath(path + "\u002fChoice"); _dcda != nil {
			return _dcda
		}
	}
	return nil
}
func NewCT_AbsSizeAnchor() *CT_AbsSizeAnchor {
	_cg := &CT_AbsSizeAnchor{}
	_cg.From = NewCT_Marker()
	_cg.Ext = _c.NewCT_PositiveSize2D()
	return _cg
}
func (_deeb *CT_GraphicFrameNonVisual) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	e.EncodeToken(start)
	_dced := _dc.StartElement{Name: _dc.Name{Local: "cNvPr"}}
	e.EncodeElement(_deeb.CNvPr, _dced)
	_bag := _dc.StartElement{Name: _dc.Name{Local: "cNvGraphicFramePr"}}
	e.EncodeElement(_deeb.CNvGraphicFramePr, _bag)
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}
func (_fbf *CT_Picture) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_fbf.NvPicPr = NewCT_PictureNonVisual()
	_fbf.BlipFill = _c.NewCT_BlipFillProperties()
	_fbf.SpPr = _c.NewCT_ShapeProperties()
	for _, _aegd := range start.Attr {
		if _aegd.Name.Local == "macro" {
			_aee, _eega := _aegd.Value, error(nil)
			if _eega != nil {
				return _eega
			}
			_fbf.MacroAttr = &_aee
			continue
		}
		if _aegd.Name.Local == "fPublished" {
			_afd, _fcaa := _f.ParseBool(_aegd.Value)
			if _fcaa != nil {
				return _fcaa
			}
			_fbf.FPublishedAttr = &_afd
			continue
		}
	}
_aed:
	for {
		_gef, _bde := d.Token()
		if _bde != nil {
			return _bde
		}
		switch _acd := _gef.(type) {
		case _dc.StartElement:
			switch _acd.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "nvPicPr"}:
				if _gbef := d.DecodeElement(_fbf.NvPicPr, &_acd); _gbef != nil {
					return _gbef
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "blipFill"}:
				if _ddgg := d.DecodeElement(_fbf.BlipFill, &_acd); _ddgg != nil {
					return _ddgg
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "spPr"}:
				if _ggac := d.DecodeElement(_fbf.SpPr, &_acd); _ggac != nil {
					return _ggac
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "style"}:
				_fbf.Style = _c.NewCT_ShapeStyle()
				if _cgb := d.DecodeElement(_fbf.Style, &_acd); _cgb != nil {
					return _cgb
				}
			default:
				_g.Log("skipping unsupported\u0020element\u0020on\u0020CT_Picture\u0020\u0025v", _acd.Name)
				if _bfdg := d.Skip(); _bfdg != nil {
					return _bfdg
				}
			}
		case _dc.EndElement:
			break _aed
		case _dc.CharData:
		}
	}
	return nil
}

type CT_Drawing struct{ EG_Anchor []*EG_Anchor }

func NewEG_ObjectChoicesChoice() *EG_ObjectChoicesChoice {
	_dfag := &EG_ObjectChoicesChoice{}
	return _dfag
}

// ValidateWithPath validates the CT_ShapeNonVisual and its children, prefixing error messages with path
func (_cde *CT_ShapeNonVisual) ValidateWithPath(path string) error {
	if _dfee := _cde.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _dfee != nil {
		return _dfee
	}
	if _gad := _cde.CNvSpPr.ValidateWithPath(path + "\u002fCNvSpPr"); _gad != nil {
		return _gad
	}
	return nil
}
func (_gea *CT_GroupShapeNonVisual) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_gea.CNvPr = _c.NewCT_NonVisualDrawingProps()
	_gea.CNvGrpSpPr = _c.NewCT_NonVisualGroupDrawingShapeProps()
_ddb:
	for {
		_bfbf, _fcbe := d.Token()
		if _fcbe != nil {
			return _fcbe
		}
		switch _acb := _bfbf.(type) {
		case _dc.StartElement:
			switch _acb.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cNvPr"}:
				if _edg := d.DecodeElement(_gea.CNvPr, &_acb); _edg != nil {
					return _edg
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cNvGrpSpPr"}:
				if _efdd := d.DecodeElement(_gea.CNvGrpSpPr, &_acb); _efdd != nil {
					return _efdd
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GroupShapeNonVisual\u0020\u0025v", _acb.Name)
				if _aacc := d.Skip(); _aacc != nil {
					return _aacc
				}
			}
		case _dc.EndElement:
			break _ddb
		case _dc.CharData:
		}
	}
	return nil
}
func (_cbf *CT_GroupShape) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	e.EncodeToken(start)
	_gbge := _dc.StartElement{Name: _dc.Name{Local: "nvGrpSpPr"}}
	e.EncodeElement(_cbf.NvGrpSpPr, _gbge)
	_bgde := _dc.StartElement{Name: _dc.Name{Local: "grpSpPr"}}
	e.EncodeElement(_cbf.GrpSpPr, _bgde)
	if _cbf.Choice != nil {
		for _, _aea := range _cbf.Choice {
			_aea.MarshalXML(e, _dc.StartElement{})
		}
	}
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}
func NewCT_GroupShapeChoice() *CT_GroupShapeChoice { _beeb := &CT_GroupShapeChoice{}; return _beeb }

// Validate validates the CT_Marker and its children
func (_bdf *CT_Marker) Validate() error { return _bdf.ValidateWithPath("CT_Marker") }

// Validate validates the CT_Connector and its children
func (_ca *CT_Connector) Validate() error { return _ca.ValidateWithPath("CT_Connector") }

type CT_Connector struct {
	MacroAttr      *string
	FPublishedAttr *bool
	NvCxnSpPr      *CT_ConnectorNonVisual
	SpPr           *_c.CT_ShapeProperties
	Style          *_c.CT_ShapeStyle
}
type CT_Marker struct {
	X float64
	Y float64
}

func (_ede *CT_Picture) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	if _ede.MacroAttr != nil {
		start.Attr = append(start.Attr, _dc.Attr{Name: _dc.Name{Local: "macro"}, Value: _de.Sprintf("\u0025v", *_ede.MacroAttr)})
	}
	if _ede.FPublishedAttr != nil {
		start.Attr = append(start.Attr, _dc.Attr{Name: _dc.Name{Local: "fPublished"}, Value: _de.Sprintf("\u0025d", _dgbc(*_ede.FPublishedAttr))})
	}
	e.EncodeToken(start)
	_cca := _dc.StartElement{Name: _dc.Name{Local: "nvPicPr"}}
	e.EncodeElement(_ede.NvPicPr, _cca)
	_gdg := _dc.StartElement{Name: _dc.Name{Local: "blipFill"}}
	e.EncodeElement(_ede.BlipFill, _gdg)
	_agee := _dc.StartElement{Name: _dc.Name{Local: "spPr"}}
	e.EncodeElement(_ede.SpPr, _agee)
	if _ede.Style != nil {
		_fca := _dc.StartElement{Name: _dc.Name{Local: "style"}}
		e.EncodeElement(_ede.Style, _fca)
	}
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}
func (_afg *EG_Anchor) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	if _afg.RelSizeAnchor != nil {
		_ebg := _dc.StartElement{Name: _dc.Name{Local: "relSizeAnchor"}}
		e.EncodeElement(_afg.RelSizeAnchor, _ebg)
	}
	if _afg.AbsSizeAnchor != nil {
		_egeed := _dc.StartElement{Name: _dc.Name{Local: "absSizeAnchor"}}
		e.EncodeElement(_afg.AbsSizeAnchor, _egeed)
	}
	return nil
}

// Validate validates the EG_ObjectChoicesChoice and its children
func (_begg *EG_ObjectChoicesChoice) Validate() error {
	return _begg.ValidateWithPath("EG_ObjectChoicesChoice")
}

// Validate validates the CT_PictureNonVisual and its children
func (_deb *CT_PictureNonVisual) Validate() error {
	return _deb.ValidateWithPath("CT_PictureNonVisual")
}

// ValidateWithPath validates the CT_Marker and its children, prefixing error messages with path
func (_daa *CT_Marker) ValidateWithPath(path string) error {
	if _daa.X < 0.0 {
		return _de.Errorf("\u0025s\u002fm\u002eX\u0020must\u0020be\u0020\u003e=\u00200\u002e0\u0020\u0028have\u0020\u0025v\u0029", path, _daa.X)
	}
	if _daa.X > 1.0 {
		return _de.Errorf("\u0025s\u002fm\u002eX\u0020must\u0020be\u0020\u003c=\u00201\u002e0\u0020\u0028have\u0020\u0025v\u0029", path, _daa.X)
	}
	if _daa.Y < 0.0 {
		return _de.Errorf("\u0025s\u002fm\u002eY\u0020must\u0020be\u0020\u003e=\u00200\u002e0\u0020\u0028have\u0020\u0025v\u0029", path, _daa.Y)
	}
	if _daa.Y > 1.0 {
		return _de.Errorf("\u0025s\u002fm\u002eY\u0020must\u0020be\u0020\u003c=\u00201\u002e0\u0020\u0028have\u0020\u0025v\u0029", path, _daa.Y)
	}
	return nil
}
func (_dee *CT_ConnectorNonVisual) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_dee.CNvPr = _c.NewCT_NonVisualDrawingProps()
	_dee.CNvCxnSpPr = _c.NewCT_NonVisualConnectorProperties()
_fddc:
	for {
		_ef, _cgc := d.Token()
		if _cgc != nil {
			return _cgc
		}
		switch _bge := _ef.(type) {
		case _dc.StartElement:
			switch _bge.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cNvPr"}:
				if _ae := d.DecodeElement(_dee.CNvPr, &_bge); _ae != nil {
					return _ae
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cNvCxnSpPr"}:
				if _bbc := d.DecodeElement(_dee.CNvCxnSpPr, &_bge); _bbc != nil {
					return _bbc
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on CT_ConnectorNonVisual\u0020\u0025v", _bge.Name)
				if _db := d.Skip(); _db != nil {
					return _db
				}
			}
		case _dc.EndElement:
			break _fddc
		case _dc.CharData:
		}
	}
	return nil
}

type CT_Shape struct {
	MacroAttr      *string
	TextlinkAttr   *string
	FLocksTextAttr *bool
	FPublishedAttr *bool
	NvSpPr         *CT_ShapeNonVisual
	SpPr           *_c.CT_ShapeProperties
	Style          *_c.CT_ShapeStyle
	TxBody         *_c.CT_TextBody
}

func (_abc *CT_GraphicFrame) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	if _abc.MacroAttr != nil {
		start.Attr = append(start.Attr, _dc.Attr{Name: _dc.Name{Local: "macro"}, Value: _de.Sprintf("\u0025v", *_abc.MacroAttr)})
	}
	if _abc.FPublishedAttr != nil {
		start.Attr = append(start.Attr, _dc.Attr{Name: _dc.Name{Local: "fPublished"}, Value: _de.Sprintf("\u0025d", _dgbc(*_abc.FPublishedAttr))})
	}
	e.EncodeToken(start)
	_fcg := _dc.StartElement{Name: _dc.Name{Local: "nvGraphicFramePr"}}
	e.EncodeElement(_abc.NvGraphicFramePr, _fcg)
	_dbe := _dc.StartElement{Name: _dc.Name{Local: "xfrm"}}
	e.EncodeElement(_abc.Xfrm, _dbe)
	_bef := _dc.StartElement{Name: _dc.Name{Local: "a:graphic"}}
	_bef.Attr = append(_bef.Attr, _dc.Attr{Name: _dc.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	e.EncodeElement(_abc.Graphic, _bef)
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}
func (_abe *CT_GroupShape) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_abe.NvGrpSpPr = NewCT_GroupShapeNonVisual()
	_abe.GrpSpPr = _c.NewCT_GroupShapeProperties()
_cce:
	for {
		_gdb, _dbc := d.Token()
		if _dbc != nil {
			return _dbc
		}
		switch _ecf := _gdb.(type) {
		case _dc.StartElement:
			switch _ecf.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "nvGrpSpPr"}:
				if _ega := d.DecodeElement(_abe.NvGrpSpPr, &_ecf); _ega != nil {
					return _ega
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "grpSpPr"}:
				if _efc := d.DecodeElement(_abe.GrpSpPr, &_ecf); _efc != nil {
					return _efc
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "sp"}:
				_bae := NewCT_GroupShapeChoice()
				if _cdc := d.DecodeElement(&_bae.Sp, &_ecf); _cdc != nil {
					return _cdc
				}
				_abe.Choice = append(_abe.Choice, _bae)
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "grpSp"}:
				_bab := NewCT_GroupShapeChoice()
				if _ce := d.DecodeElement(&_bab.GrpSp, &_ecf); _ce != nil {
					return _ce
				}
				_abe.Choice = append(_abe.Choice, _bab)
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "graphicFrame"}:
				_gec := NewCT_GroupShapeChoice()
				if _ccg := d.DecodeElement(&_gec.GraphicFrame, &_ecf); _ccg != nil {
					return _ccg
				}
				_abe.Choice = append(_abe.Choice, _gec)
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cxnSp"}:
				_gbb := NewCT_GroupShapeChoice()
				if _gaab := d.DecodeElement(&_gbb.CxnSp, &_ecf); _gaab != nil {
					return _gaab
				}
				_abe.Choice = append(_abe.Choice, _gbb)
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "pic"}:
				_afb := NewCT_GroupShapeChoice()
				if _aac := d.DecodeElement(&_afb.Pic, &_ecf); _aac != nil {
					return _aac
				}
				_abe.Choice = append(_abe.Choice, _afb)
			default:
				_g.Log("skipping unsupported element\u0020on\u0020CT_GroupShape \u0025v", _ecf.Name)
				if _cdd := d.Skip(); _cdd != nil {
					return _cdd
				}
			}
		case _dc.EndElement:
			break _cce
		case _dc.CharData:
		}
	}
	return nil
}

type EG_Anchor struct {
	RelSizeAnchor *CT_RelSizeAnchor
	AbsSizeAnchor *CT_AbsSizeAnchor
}

// ValidateWithPath validates the CT_GraphicFrame and its children, prefixing error messages with path
func (_cgd *CT_GraphicFrame) ValidateWithPath(path string) error {
	if _dab := _cgd.NvGraphicFramePr.ValidateWithPath(path + "\u002fNvGraphicFramePr"); _dab != nil {
		return _dab
	}
	if _dce := _cgd.Xfrm.ValidateWithPath(path + "\u002fXfrm"); _dce != nil {
		return _dce
	}
	if _adg := _cgd.Graphic.ValidateWithPath(path + "\u002fGraphic"); _adg != nil {
		return _adg
	}
	return nil
}
func NewCT_ShapeNonVisual() *CT_ShapeNonVisual {
	_cgba := &CT_ShapeNonVisual{}
	_cgba.CNvPr = _c.NewCT_NonVisualDrawingProps()
	_cgba.CNvSpPr = _c.NewCT_NonVisualDrawingShapeProps()
	return _cgba
}
func (_gbgb *CT_Shape) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	if _gbgb.MacroAttr != nil {
		start.Attr = append(start.Attr, _dc.Attr{Name: _dc.Name{Local: "macro"}, Value: _de.Sprintf("\u0025v", *_gbgb.MacroAttr)})
	}
	if _gbgb.TextlinkAttr != nil {
		start.Attr = append(start.Attr, _dc.Attr{Name: _dc.Name{Local: "textlink"}, Value: _de.Sprintf("\u0025v", *_gbgb.TextlinkAttr)})
	}
	if _gbgb.FLocksTextAttr != nil {
		start.Attr = append(start.Attr, _dc.Attr{Name: _dc.Name{Local: "fLocksText"}, Value: _de.Sprintf("\u0025d", _dgbc(*_gbgb.FLocksTextAttr))})
	}
	if _gbgb.FPublishedAttr != nil {
		start.Attr = append(start.Attr, _dc.Attr{Name: _dc.Name{Local: "fPublished"}, Value: _de.Sprintf("\u0025d", _dgbc(*_gbgb.FPublishedAttr))})
	}
	e.EncodeToken(start)
	_bfbb := _dc.StartElement{Name: _dc.Name{Local: "nvSpPr"}}
	e.EncodeElement(_gbgb.NvSpPr, _bfbb)
	_dbf := _dc.StartElement{Name: _dc.Name{Local: "spPr"}}
	e.EncodeElement(_gbgb.SpPr, _dbf)
	if _gbgb.Style != nil {
		_ggf := _dc.StartElement{Name: _dc.Name{Local: "style"}}
		e.EncodeElement(_gbgb.Style, _ggf)
	}
	if _gbgb.TxBody != nil {
		_gce := _dc.StartElement{Name: _dc.Name{Local: "txBody"}}
		e.EncodeElement(_gbgb.TxBody, _gce)
	}
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}
func NewCT_GraphicFrame() *CT_GraphicFrame {
	_ffa := &CT_GraphicFrame{}
	_ffa.NvGraphicFramePr = NewCT_GraphicFrameNonVisual()
	_ffa.Xfrm = _c.NewCT_Transform2D()
	_ffa.Graphic = _c.NewGraphic()
	return _ffa
}

// ValidateWithPath validates the CT_GraphicFrameNonVisual and its children, prefixing error messages with path
func (_gcg *CT_GraphicFrameNonVisual) ValidateWithPath(path string) error {
	if _dea := _gcg.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _dea != nil {
		return _dea
	}
	if _ggb := _gcg.CNvGraphicFramePr.ValidateWithPath(path + "\u002fCNvGraphicFramePr"); _ggb != nil {
		return _ggb
	}
	return nil
}

// Validate validates the CT_AbsSizeAnchor and its children
func (_bfd *CT_AbsSizeAnchor) Validate() error { return _bfd.ValidateWithPath("CT_AbsSizeAnchor") }

type CT_GroupShapeChoice struct {
	Sp           []*CT_Shape
	GrpSp        []*CT_GroupShape
	GraphicFrame []*CT_GraphicFrame
	CxnSp        []*CT_Connector
	Pic          []*CT_Picture
}

func NewCT_ConnectorNonVisual() *CT_ConnectorNonVisual {
	_ee := &CT_ConnectorNonVisual{}
	_ee.CNvPr = _c.NewCT_NonVisualDrawingProps()
	_ee.CNvCxnSpPr = _c.NewCT_NonVisualConnectorProperties()
	return _ee
}

// ValidateWithPath validates the CT_GroupShape and its children, prefixing error messages with path
func (_fdg *CT_GroupShape) ValidateWithPath(path string) error {
	if _gca := _fdg.NvGrpSpPr.ValidateWithPath(path + "\u002fNvGrpSpPr"); _gca != nil {
		return _gca
	}
	if _abfg := _fdg.GrpSpPr.ValidateWithPath(path + "\u002fGrpSpPr"); _abfg != nil {
		return _abfg
	}
	for _cef, _cgfa := range _fdg.Choice {
		if _bga := _cgfa.ValidateWithPath(_de.Sprintf("\u0025s\u002fChoice\u005b\u0025d\u005d", path, _cef)); _bga != nil {
			return _bga
		}
	}
	return nil
}

type EG_ObjectChoices struct{ Choice *EG_ObjectChoicesChoice }

func (_edb *EG_ObjectChoicesChoice) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
_cdcc:
	for {
		_ggfe, _debc := d.Token()
		if _debc != nil {
			return _debc
		}
		switch _dba := _ggfe.(type) {
		case _dc.StartElement:
			switch _dba.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "sp"}:
				_edb.Sp = NewCT_Shape()
				if _ecea := d.DecodeElement(_edb.Sp, &_dba); _ecea != nil {
					return _ecea
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "grpSp"}:
				_edb.GrpSp = NewCT_GroupShape()
				if _ddad := d.DecodeElement(_edb.GrpSp, &_dba); _ddad != nil {
					return _ddad
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "graphicFrame"}:
				_edb.GraphicFrame = NewCT_GraphicFrame()
				if _bbda := d.DecodeElement(_edb.GraphicFrame, &_dba); _bbda != nil {
					return _bbda
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cxnSp"}:
				_edb.CxnSp = NewCT_Connector()
				if _cad := d.DecodeElement(_edb.CxnSp, &_dba); _cad != nil {
					return _cad
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "pic"}:
				_edb.Pic = NewCT_Picture()
				if _fbe := d.DecodeElement(_edb.Pic, &_dba); _fbe != nil {
					return _fbe
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_ObjectChoicesChoice\u0020\u0025v", _dba.Name)
				if _abd := d.Skip(); _abd != nil {
					return _abd
				}
			}
		case _dc.EndElement:
			break _cdcc
		case _dc.CharData:
		}
	}
	return nil
}
func (_gdbd *EG_ObjectChoicesChoice) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	if _gdbd.Sp != nil {
		_gcgg := _dc.StartElement{Name: _dc.Name{Local: "sp"}}
		e.EncodeElement(_gdbd.Sp, _gcgg)
	}
	if _gdbd.GrpSp != nil {
		_cga := _dc.StartElement{Name: _dc.Name{Local: "grpSp"}}
		e.EncodeElement(_gdbd.GrpSp, _cga)
	}
	if _gdbd.GraphicFrame != nil {
		_bgc := _dc.StartElement{Name: _dc.Name{Local: "graphicFrame"}}
		e.EncodeElement(_gdbd.GraphicFrame, _bgc)
	}
	if _gdbd.CxnSp != nil {
		_dbg := _dc.StartElement{Name: _dc.Name{Local: "cxnSp"}}
		e.EncodeElement(_gdbd.CxnSp, _dbg)
	}
	if _gdbd.Pic != nil {
		_cdb := _dc.StartElement{Name: _dc.Name{Local: "pic"}}
		e.EncodeElement(_gdbd.Pic, _cdb)
	}
	return nil
}

// ValidateWithPath validates the CT_AbsSizeAnchor and its children, prefixing error messages with path
func (_eb *CT_AbsSizeAnchor) ValidateWithPath(path string) error {
	if _cf := _eb.From.ValidateWithPath(path + "\u002fFrom"); _cf != nil {
		return _cf
	}
	if _fc := _eb.Ext.ValidateWithPath(path + "\u002fExt"); _fc != nil {
		return _fc
	}
	if _eb.Choice != nil {
		if _dfb := _eb.Choice.ValidateWithPath(path + "\u002fChoice"); _dfb != nil {
			return _dfb
		}
	}
	return nil
}

type CT_RelSizeAnchor struct {
	From   *CT_Marker
	To     *CT_Marker
	Choice *EG_ObjectChoicesChoice
}

// ValidateWithPath validates the EG_ObjectChoicesChoice and its children, prefixing error messages with path
func (_abce *EG_ObjectChoicesChoice) ValidateWithPath(path string) error {
	if _abce.Sp != nil {
		if _eefa := _abce.Sp.ValidateWithPath(path + "\u002fSp"); _eefa != nil {
			return _eefa
		}
	}
	if _abce.GrpSp != nil {
		if _degb := _abce.GrpSp.ValidateWithPath(path + "\u002fGrpSp"); _degb != nil {
			return _degb
		}
	}
	if _abce.GraphicFrame != nil {
		if _bbcd := _abce.GraphicFrame.ValidateWithPath(path + "\u002fGraphicFrame"); _bbcd != nil {
			return _bbcd
		}
	}
	if _abce.CxnSp != nil {
		if _fef := _abce.CxnSp.ValidateWithPath(path + "\u002fCxnSp"); _fef != nil {
			return _fef
		}
	}
	if _abce.Pic != nil {
		if _dbcf := _abce.Pic.ValidateWithPath(path + "\u002fPic"); _dbcf != nil {
			return _dbcf
		}
	}
	return nil
}

// Validate validates the CT_GroupShape and its children
func (_bfe *CT_GroupShape) Validate() error { return _bfe.ValidateWithPath("CT_GroupShape") }
func (_dfa *EG_Anchor) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
_fcaf:
	for {
		_fdaa, _eegc := d.Token()
		if _eegc != nil {
			return _eegc
		}
		switch _fgb := _fdaa.(type) {
		case _dc.StartElement:
			switch _fgb.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "relSizeAnchor"}:
				_dfa.RelSizeAnchor = NewCT_RelSizeAnchor()
				if _affe := d.DecodeElement(_dfa.RelSizeAnchor, &_fgb); _affe != nil {
					return _affe
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "absSizeAnchor"}:
				_dfa.AbsSizeAnchor = NewCT_AbsSizeAnchor()
				if _agfb := d.DecodeElement(_dfa.AbsSizeAnchor, &_fgb); _agfb != nil {
					return _agfb
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element on EG_Anchor \u0025v", _fgb.Name)
				if _befg := d.Skip(); _befg != nil {
					return _befg
				}
			}
		case _dc.EndElement:
			break _fcaf
		case _dc.CharData:
		}
	}
	return nil
}
func NewCT_Connector() *CT_Connector {
	_ga := &CT_Connector{}
	_ga.NvCxnSpPr = NewCT_ConnectorNonVisual()
	_ga.SpPr = _c.NewCT_ShapeProperties()
	return _ga
}

type CT_ShapeNonVisual struct {
	CNvPr   *_c.CT_NonVisualDrawingProps
	CNvSpPr *_c.CT_NonVisualDrawingShapeProps
}

func (_faf *EG_ObjectChoices) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
_feea:
	for {
		_bagd, _bbca := d.Token()
		if _bbca != nil {
			return _bbca
		}
		switch _ccgb := _bagd.(type) {
		case _dc.StartElement:
			switch _ccgb.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "sp"}:
				_faf.Choice = NewEG_ObjectChoicesChoice()
				if _efba := d.DecodeElement(&_faf.Choice.Sp, &_ccgb); _efba != nil {
					return _efba
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "grpSp"}:
				_faf.Choice = NewEG_ObjectChoicesChoice()
				if _cgfb := d.DecodeElement(&_faf.Choice.GrpSp, &_ccgb); _cgfb != nil {
					return _cgfb
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "graphicFrame"}:
				_faf.Choice = NewEG_ObjectChoicesChoice()
				if _cdea := d.DecodeElement(&_faf.Choice.GraphicFrame, &_ccgb); _cdea != nil {
					return _cdea
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cxnSp"}:
				_faf.Choice = NewEG_ObjectChoicesChoice()
				if _aage := d.DecodeElement(&_faf.Choice.CxnSp, &_ccgb); _aage != nil {
					return _aage
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "pic"}:
				_faf.Choice = NewEG_ObjectChoicesChoice()
				if _ggca := d.DecodeElement(&_faf.Choice.Pic, &_ccgb); _ggca != nil {
					return _ggca
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_ObjectChoices\u0020\u0025v", _ccgb.Name)
				if _ddge := d.Skip(); _ddge != nil {
					return _ddge
				}
			}
		case _dc.EndElement:
			break _feea
		case _dc.CharData:
		}
	}
	return nil
}
func (_efdc *CT_ShapeNonVisual) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	e.EncodeToken(start)
	_gee := _dc.StartElement{Name: _dc.Name{Local: "cNvPr"}}
	e.EncodeElement(_efdc.CNvPr, _gee)
	_egee := _dc.StartElement{Name: _dc.Name{Local: "cNvSpPr"}}
	e.EncodeElement(_efdc.CNvSpPr, _egee)
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}

// Validate validates the EG_Anchor and its children
func (_ecga *EG_Anchor) Validate() error { return _ecga.ValidateWithPath("EG_Anchor") }

// ValidateWithPath validates the CT_PictureNonVisual and its children, prefixing error messages with path
func (_bgbc *CT_PictureNonVisual) ValidateWithPath(path string) error {
	if _baab := _bgbc.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _baab != nil {
		return _baab
	}
	if _cae := _bgbc.CNvPicPr.ValidateWithPath(path + "\u002fCNvPicPr"); _cae != nil {
		return _cae
	}
	return nil
}

type CT_GroupShapeNonVisual struct {
	CNvPr      *_c.CT_NonVisualDrawingProps
	CNvGrpSpPr *_c.CT_NonVisualGroupDrawingShapeProps
}
type CT_Picture struct {
	MacroAttr      *string
	FPublishedAttr *bool
	NvPicPr        *CT_PictureNonVisual
	BlipFill       *_c.CT_BlipFillProperties
	SpPr           *_c.CT_ShapeProperties
	Style          *_c.CT_ShapeStyle
}

func (_bb *CT_Connector) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	if _bb.MacroAttr != nil {
		start.Attr = append(start.Attr, _dc.Attr{Name: _dc.Name{Local: "macro"}, Value: _de.Sprintf("\u0025v", *_bb.MacroAttr)})
	}
	if _bb.FPublishedAttr != nil {
		start.Attr = append(start.Attr, _dc.Attr{Name: _dc.Name{Local: "fPublished"}, Value: _de.Sprintf("\u0025d", _dgbc(*_bb.FPublishedAttr))})
	}
	e.EncodeToken(start)
	_ad := _dc.StartElement{Name: _dc.Name{Local: "nvCxnSpPr"}}
	e.EncodeElement(_bb.NvCxnSpPr, _ad)
	_gc := _dc.StartElement{Name: _dc.Name{Local: "spPr"}}
	e.EncodeElement(_bb.SpPr, _gc)
	if _bb.Style != nil {
		_bbe := _dc.StartElement{Name: _dc.Name{Local: "style"}}
		e.EncodeElement(_bb.Style, _bbe)
	}
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}
func (_dca *EG_ObjectChoices) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	if _dca.Choice != nil {
		_dca.Choice.MarshalXML(e, _dc.StartElement{})
	}
	return nil
}
func NewCT_Shape() *CT_Shape {
	_efa := &CT_Shape{}
	_efa.NvSpPr = NewCT_ShapeNonVisual()
	_efa.SpPr = _c.NewCT_ShapeProperties()
	return _efa
}
func (_caa *CT_GraphicFrameNonVisual) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_caa.CNvPr = _c.NewCT_NonVisualDrawingProps()
	_caa.CNvGraphicFramePr = _c.NewCT_NonVisualGraphicFrameProperties()
_adae:
	for {
		_abff, _fcd := d.Token()
		if _fcd != nil {
			return _fcd
		}
		switch _dece := _abff.(type) {
		case _dc.StartElement:
			switch _dece.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cNvPr"}:
				if _fee := d.DecodeElement(_caa.CNvPr, &_dece); _fee != nil {
					return _fee
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cNvGraphicFramePr"}:
				if _ffd := d.DecodeElement(_caa.CNvGraphicFramePr, &_dece); _ffd != nil {
					return _ffd
				}
			default:
				_g.Log("skipping\u0020unsupported element\u0020on\u0020CT_GraphicFrameNonVisual\u0020%v", _dece.Name)
				if _fba := d.Skip(); _fba != nil {
					return _fba
				}
			}
		case _dc.EndElement:
			break _adae
		case _dc.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Connector and its children, prefixing error messages with path
func (_ddf *CT_Connector) ValidateWithPath(path string) error {
	if _fdfa := _ddf.NvCxnSpPr.ValidateWithPath(path + "\u002fNvCxnSpPr"); _fdfa != nil {
		return _fdfa
	}
	if _ab := _ddf.SpPr.ValidateWithPath(path + "\u002fSpPr"); _ab != nil {
		return _ab
	}
	if _ddf.Style != nil {
		if _ag := _ddf.Style.ValidateWithPath(path + "\u002fStyle"); _ag != nil {
			return _ag
		}
	}
	return nil
}

// ValidateWithPath validates the CT_RelSizeAnchor and its children, prefixing error messages with path
func (_afe *CT_RelSizeAnchor) ValidateWithPath(path string) error {
	if _gab := _afe.From.ValidateWithPath(path + "\u002fFrom"); _gab != nil {
		return _gab
	}
	if _baf := _afe.To.ValidateWithPath(path + "\u002fTo"); _baf != nil {
		return _baf
	}
	if _afe.Choice != nil {
		if _ffdd := _afe.Choice.ValidateWithPath(path + "\u002fChoice"); _ffdd != nil {
			return _ffdd
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Drawing and its children, prefixing error messages with path
func (_bee *CT_Drawing) ValidateWithPath(path string) error {
	for _efd, _aeg := range _bee.EG_Anchor {
		if _fff := _aeg.ValidateWithPath(_de.Sprintf("\u0025s/EG_Anchor\u005b\u0025d\u005d", path, _efd)); _fff != nil {
			return _fff
		}
	}
	return nil
}

// Validate validates the EG_ObjectChoices and its children
func (_edgf *EG_ObjectChoices) Validate() error { return _edgf.ValidateWithPath("EG_ObjectChoices") }
func (_ccd *CT_PictureNonVisual) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_ccd.CNvPr = _c.NewCT_NonVisualDrawingProps()
	_ccd.CNvPicPr = _c.NewCT_NonVisualPictureProperties()
_faae:
	for {
		_dfe, _decc := d.Token()
		if _decc != nil {
			return _decc
		}
		switch _aece := _dfe.(type) {
		case _dc.StartElement:
			switch _aece.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cNvPr"}:
				if _afbe := d.DecodeElement(_ccd.CNvPr, &_aece); _afbe != nil {
					return _afbe
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cNvPicPr"}:
				if _afdc := d.DecodeElement(_ccd.CNvPicPr, &_aece); _afdc != nil {
					return _afdc
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PictureNonVisual\u0020\u0025v", _aece.Name)
				if _ffcc := d.Skip(); _ffcc != nil {
					return _ffcc
				}
			}
		case _dc.EndElement:
			break _faae
		case _dc.CharData:
		}
	}
	return nil
}
func (_gd *CT_ConnectorNonVisual) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	e.EncodeToken(start)
	_ec := _dc.StartElement{Name: _dc.Name{Local: "cNvPr"}}
	e.EncodeElement(_gd.CNvPr, _ec)
	_ada := _dc.StartElement{Name: _dc.Name{Local: "cNvCxnSpPr"}}
	e.EncodeElement(_gd.CNvCxnSpPr, _ada)
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}
func (_egce *CT_GroupShapeNonVisual) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	e.EncodeToken(start)
	_fae := _dc.StartElement{Name: _dc.Name{Local: "cNvPr"}}
	e.EncodeElement(_egce.CNvPr, _fae)
	_dfd := _dc.StartElement{Name: _dc.Name{Local: "cNvGrpSpPr"}}
	e.EncodeElement(_egce.CNvGrpSpPr, _dfd)
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_ConnectorNonVisual and its children
func (_abf *CT_ConnectorNonVisual) Validate() error {
	return _abf.ValidateWithPath("CT_ConnectorNonVisual")
}

type CT_PictureNonVisual struct {
	CNvPr    *_c.CT_NonVisualDrawingProps
	CNvPicPr *_c.CT_NonVisualPictureProperties
}

func NewCT_GroupShape() *CT_GroupShape {
	_gdd := &CT_GroupShape{}
	_gdd.NvGrpSpPr = NewCT_GroupShapeNonVisual()
	_gdd.GrpSpPr = _c.NewCT_GroupShapeProperties()
	return _gdd
}
func (_gcc *CT_RelSizeAnchor) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	e.EncodeToken(start)
	_fbc := _dc.StartElement{Name: _dc.Name{Local: "from"}}
	e.EncodeElement(_gcc.From, _fbc)
	_bgaf := _dc.StartElement{Name: _dc.Name{Local: "to"}}
	e.EncodeElement(_gcc.To, _bgaf)
	if _gcc.Choice != nil {
		_gcc.Choice.MarshalXML(e, _dc.StartElement{})
	}
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}
func (_age *CT_GraphicFrame) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_age.NvGraphicFramePr = NewCT_GraphicFrameNonVisual()
	_age.Xfrm = _c.NewCT_Transform2D()
	_age.Graphic = _c.NewGraphic()
	for _, _deg := range start.Attr {
		if _deg.Name.Local == "macro" {
			_fb, _afa := _deg.Value, error(nil)
			if _afa != nil {
				return _afa
			}
			_age.MacroAttr = &_fb
			continue
		}
		if _deg.Name.Local == "fPublished" {
			_eea, _agc := _f.ParseBool(_deg.Value)
			if _agc != nil {
				return _agc
			}
			_age.FPublishedAttr = &_eea
			continue
		}
	}
_gae:
	for {
		_fdc, _gga := d.Token()
		if _gga != nil {
			return _gga
		}
		switch _dda := _fdc.(type) {
		case _dc.StartElement:
			switch _dda.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "nvGraphicFramePr"}:
				if _cb := d.DecodeElement(_age.NvGraphicFramePr, &_dda); _cb != nil {
					return _cb
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "xfrm"}:
				if _afae := d.DecodeElement(_age.Xfrm, &_dda); _afae != nil {
					return _afae
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "graphic"}, _dc.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "graphic"}:
				if _ea := d.DecodeElement(_age.Graphic, &_dda); _ea != nil {
					return _ea
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GraphicFrame\u0020\u0025v", _dda.Name)
				if _efe := d.Skip(); _efe != nil {
					return _efe
				}
			}
		case _dc.EndElement:
			break _gae
		case _dc.CharData:
		}
	}
	return nil
}
func NewCT_PictureNonVisual() *CT_PictureNonVisual {
	_acc := &CT_PictureNonVisual{}
	_acc.CNvPr = _c.NewCT_NonVisualDrawingProps()
	_acc.CNvPicPr = _c.NewCT_NonVisualPictureProperties()
	return _acc
}

// Validate validates the CT_GroupShapeNonVisual and its children
func (_gcd *CT_GroupShapeNonVisual) Validate() error {
	return _gcd.ValidateWithPath("CT_GroupShapeNonVisual")
}

type CT_AbsSizeAnchor struct {
	From   *CT_Marker
	Ext    *_c.CT_PositiveSize2D
	Choice *EG_ObjectChoicesChoice
}

// ValidateWithPath validates the CT_GroupShapeChoice and its children, prefixing error messages with path
func (_bdg *CT_GroupShapeChoice) ValidateWithPath(path string) error {
	for _egc, _bdb := range _bdg.Sp {
		if _cfc := _bdb.ValidateWithPath(_de.Sprintf("\u0025s\u002fSp\u005b\u0025d]", path, _egc)); _cfc != nil {
			return _cfc
		}
	}
	for _aef, _bff := range _bdg.GrpSp {
		if _ccc := _bff.ValidateWithPath(_de.Sprintf("\u0025s\u002fGrpSp\u005b\u0025d\u005d", path, _aef)); _ccc != nil {
			return _ccc
		}
	}
	for _ffcd, _aecc := range _bdg.GraphicFrame {
		if _ed := _aecc.ValidateWithPath(_de.Sprintf("\u0025s\u002fGraphicFrame\u005b\u0025d\u005d", path, _ffcd)); _ed != nil {
			return _ed
		}
	}
	for _cgga, _cbc := range _bdg.CxnSp {
		if _ged := _cbc.ValidateWithPath(_de.Sprintf("\u0025s\u002fCxnSp\u005b\u0025d\u005d", path, _cgga)); _ged != nil {
			return _ged
		}
	}
	for _eeb, _cfe := range _bdg.Pic {
		if _fddg := _cfe.ValidateWithPath(_de.Sprintf("\u0025s\u002fPic\u005b\u0025d\u005d", path, _eeb)); _fddg != nil {
			return _fddg
		}
	}
	return nil
}
func (_gedd *CT_RelSizeAnchor) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_gedd.From = NewCT_Marker()
	_gedd.To = NewCT_Marker()
_geg:
	for {
		_aaa, _dceb := d.Token()
		if _dceb != nil {
			return _dceb
		}
		switch _ege := _aaa.(type) {
		case _dc.StartElement:
			switch _ege.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "from"}:
				if _efb := d.DecodeElement(_gedd.From, &_ege); _efb != nil {
					return _efb
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "to"}:
				if _ece := d.DecodeElement(_gedd.To, &_ege); _ece != nil {
					return _ece
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "sp"}:
				_gedd.Choice = NewEG_ObjectChoicesChoice()
				if _aae := d.DecodeElement(&_gedd.Choice.Sp, &_ege); _aae != nil {
					return _aae
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "grpSp"}:
				_gedd.Choice = NewEG_ObjectChoicesChoice()
				if _beg := d.DecodeElement(&_gedd.Choice.GrpSp, &_ege); _beg != nil {
					return _beg
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "graphicFrame"}:
				_gedd.Choice = NewEG_ObjectChoicesChoice()
				if _afff := d.DecodeElement(&_gedd.Choice.GraphicFrame, &_ege); _afff != nil {
					return _afff
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "cxnSp"}:
				_gedd.Choice = NewEG_ObjectChoicesChoice()
				if _bed := d.DecodeElement(&_gedd.Choice.CxnSp, &_ege); _bed != nil {
					return _bed
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "pic"}:
				_gedd.Choice = NewEG_ObjectChoicesChoice()
				if _bdee := d.DecodeElement(&_gedd.Choice.Pic, &_ege); _bdee != nil {
					return _bdee
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RelSizeAnchor\u0020\u0025v", _ege.Name)
				if _fcc := d.Skip(); _fcc != nil {
					return _fcc
				}
			}
		case _dc.EndElement:
			break _geg
		case _dc.CharData:
		}
	}
	return nil
}
func NewEG_ObjectChoices() *EG_ObjectChoices { _efed := &EG_ObjectChoices{}; return _efed }
func (_abcb *CT_Shape) UnmarshalXML(d *_dc.Decoder, start _dc.StartElement) error {
	_abcb.NvSpPr = NewCT_ShapeNonVisual()
	_abcb.SpPr = _c.NewCT_ShapeProperties()
	for _, _dbd := range start.Attr {
		if _dbd.Name.Local == "macro" {
			_aag, _efbe := _dbd.Value, error(nil)
			if _efbe != nil {
				return _efbe
			}
			_abcb.MacroAttr = &_aag
			continue
		}
		if _dbd.Name.Local == "textlink" {
			_bgaa, _efg := _dbd.Value, error(nil)
			if _efg != nil {
				return _efg
			}
			_abcb.TextlinkAttr = &_bgaa
			continue
		}
		if _dbd.Name.Local == "fLocksText" {
			_accg, _afaf := _f.ParseBool(_dbd.Value)
			if _afaf != nil {
				return _afaf
			}
			_abcb.FLocksTextAttr = &_accg
			continue
		}
		if _dbd.Name.Local == "fPublished" {
			_geff, _bage := _f.ParseBool(_dbd.Value)
			if _bage != nil {
				return _bage
			}
			_abcb.FPublishedAttr = &_geff
			continue
		}
	}
_caeg:
	for {
		_fagd, _gdf := d.Token()
		if _gdf != nil {
			return _gdf
		}
		switch _afde := _fagd.(type) {
		case _dc.StartElement:
			switch _afde.Name {
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "nvSpPr"}:
				if _fcgb := d.DecodeElement(_abcb.NvSpPr, &_afde); _fcgb != nil {
					return _fcgb
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "spPr"}:
				if _deaa := d.DecodeElement(_abcb.SpPr, &_afde); _deaa != nil {
					return _deaa
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "style"}:
				_abcb.Style = _c.NewCT_ShapeStyle()
				if _afed := d.DecodeElement(_abcb.Style, &_afde); _afed != nil {
					return _afed
				}
			case _dc.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", Local: "txBody"}:
				_abcb.TxBody = _c.NewCT_TextBody()
				if _agfa := d.DecodeElement(_abcb.TxBody, &_afde); _agfa != nil {
					return _agfa
				}
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Shape\u0020\u0025v", _afde.Name)
				if _fda := d.Skip(); _fda != nil {
					return _fda
				}
			}
		case _dc.EndElement:
			break _caeg
		case _dc.CharData:
		}
	}
	return nil
}
func NewCT_Picture() *CT_Picture {
	_ecff := &CT_Picture{}
	_ecff.NvPicPr = NewCT_PictureNonVisual()
	_ecff.BlipFill = _c.NewCT_BlipFillProperties()
	_ecff.SpPr = _c.NewCT_ShapeProperties()
	return _ecff
}

// Validate validates the CT_GraphicFrame and its children
func (_gaa *CT_GraphicFrame) Validate() error { return _gaa.ValidateWithPath("CT_GraphicFrame") }
func (_dfba *CT_PictureNonVisual) MarshalXML(e *_dc.Encoder, start _dc.StartElement) error {
	e.EncodeToken(start)
	_bgg := _dc.StartElement{Name: _dc.Name{Local: "cNvPr"}}
	e.EncodeElement(_dfba.CNvPr, _bgg)
	_eef := _dc.StartElement{Name: _dc.Name{Local: "cNvPicPr"}}
	e.EncodeElement(_dfba.CNvPicPr, _eef)
	e.EncodeToken(_dc.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Picture and its children, prefixing error messages with path
func (_dcec *CT_Picture) ValidateWithPath(path string) error {
	if _eccd := _dcec.NvPicPr.ValidateWithPath(path + "\u002fNvPicPr"); _eccd != nil {
		return _eccd
	}
	if _agfd := _dcec.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _agfd != nil {
		return _agfd
	}
	if _cdf := _dcec.SpPr.ValidateWithPath(path + "\u002fSpPr"); _cdf != nil {
		return _cdf
	}
	if _dcec.Style != nil {
		if _gede := _dcec.Style.ValidateWithPath(path + "\u002fStyle"); _gede != nil {
			return _gede
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Shape and its children, prefixing error messages with path
func (_gdea *CT_Shape) ValidateWithPath(path string) error {
	if _agb := _gdea.NvSpPr.ValidateWithPath(path + "\u002fNvSpPr"); _agb != nil {
		return _agb
	}
	if _dac := _gdea.SpPr.ValidateWithPath(path + "\u002fSpPr"); _dac != nil {
		return _dac
	}
	if _gdea.Style != nil {
		if _dgb := _gdea.Style.ValidateWithPath(path + "\u002fStyle"); _dgb != nil {
			return _dgb
		}
	}
	if _gdea.TxBody != nil {
		if _ecgf := _gdea.TxBody.ValidateWithPath(path + "\u002fTxBody"); _ecgf != nil {
			return _ecgf
		}
	}
	return nil
}
func init() {
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_ShapeNonVisual", NewCT_ShapeNonVisual)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_Shape", NewCT_Shape)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_ConnectorNonVisual", NewCT_ConnectorNonVisual)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_Connector", NewCT_Connector)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_PictureNonVisual", NewCT_PictureNonVisual)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_Picture", NewCT_Picture)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_GraphicFrameNonVisual", NewCT_GraphicFrameNonVisual)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_GraphicFrame", NewCT_GraphicFrame)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_GroupShapeNonVisual", NewCT_GroupShapeNonVisual)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_GroupShape", NewCT_GroupShape)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_Marker", NewCT_Marker)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_RelSizeAnchor", NewCT_RelSizeAnchor)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_AbsSizeAnchor", NewCT_AbsSizeAnchor)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "CT_Drawing", NewCT_Drawing)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "EG_ObjectChoices", NewEG_ObjectChoices)
	_g.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats.org\u002fdrawingml\u002f2006\u002fchartDrawing", "EG_Anchor", NewEG_Anchor)
}
