//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package pml

import (
	_e "encoding/xml"
	_c "fmt"
	_ee "gitee.com/greatmusicians/unioffice"
	_cb "gitee.com/greatmusicians/unioffice/schema/soo/dml"
	_d "gitee.com/greatmusicians/unioffice/schema/soo/ofc/sharedTypes"
	_b "strconv"
	_fb "time"
)

func (_cecf *OleObj) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cecf.CT_OleObject = *NewCT_OleObject()
	for _, _ddeabb := range start.Attr {
		if _ddeabb.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _ddeabb.Name.Local == "id" {
			_fcff, _gffegd := _ddeabb.Value, error(nil)
			if _gffegd != nil {
				return _gffegd
			}
			_cecf.IdAttr = &_fcff
			continue
		}
		if _ddeabb.Name.Local == "spid" {
			_gbbd, _dagfc := _ddeabb.Value, error(nil)
			if _dagfc != nil {
				return _dagfc
			}
			_cecf.SpidAttr = &_gbbd
			continue
		}
		if _ddeabb.Name.Local == "name" {
			_dedef, _abgdgd := _ddeabb.Value, error(nil)
			if _abgdgd != nil {
				return _abgdgd
			}
			_cecf.NameAttr = &_dedef
			continue
		}
		if _ddeabb.Name.Local == "showAsIcon" {
			_eeefg, _gdfce := _b.ParseBool(_ddeabb.Value)
			if _gdfce != nil {
				return _gdfce
			}
			_cecf.ShowAsIconAttr = &_eeefg
			continue
		}
		if _ddeabb.Name.Local == "progId" {
			_gffege, _dggcg := _ddeabb.Value, error(nil)
			if _dggcg != nil {
				return _dggcg
			}
			_cecf.ProgIdAttr = &_gffege
			continue
		}
		if _ddeabb.Name.Local == "imgW" {
			_ebcg, _cfgbe := _b.ParseInt(_ddeabb.Value, 10, 32)
			if _cfgbe != nil {
				return _cfgbe
			}
			_aadd := int32(_ebcg)
			_cecf.ImgWAttr = &_aadd
			continue
		}
		if _ddeabb.Name.Local == "imgH" {
			_ffgcb, _bcfb := _b.ParseInt(_ddeabb.Value, 10, 32)
			if _bcfb != nil {
				return _bcfb
			}
			_ccbca := int32(_ffgcb)
			_cecf.ImgHAttr = &_ccbca
			continue
		}
	}
_abbef:
	for {
		_geec, _faeda := d.Token()
		if _faeda != nil {
			return _faeda
		}
		switch _eefca := _geec.(type) {
		case _e.StartElement:
			switch _eefca.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "embed"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "embed"}:
				_cecf.Choice = NewCT_OleObjectChoice()
				if _bcaeg := d.DecodeElement(&_cecf.Choice.Embed, &_eefca); _bcaeg != nil {
					return _bcaeg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "link"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "link"}:
				_cecf.Choice = NewCT_OleObjectChoice()
				if _aagbgf := d.DecodeElement(&_cecf.Choice.Link, &_eefca); _aagbgf != nil {
					return _aagbgf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "pic"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "pic"}:
				_cecf.Pic = NewCT_Picture()
				if _adbbe := d.DecodeElement(_cecf.Pic, &_eefca); _adbbe != nil {
					return _adbbe
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020OleObj\u0020\u0025v", _eefca.Name)
				if _bfffd := d.Skip(); _bfffd != nil {
					return _bfffd
				}
			}
		case _e.EndElement:
			break _abbef
		case _e.CharData:
		}
	}
	return nil
}
func NewCT_SlideTransitionChoice() *CT_SlideTransitionChoice {
	_feccc := &CT_SlideTransitionChoice{}
	return _feccc
}
func (_bbcg *CT_CustomShowList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _bbcg.CustShow != nil {
		_bcc := _e.StartElement{Name: _e.Name{Local: "p:custShow"}}
		for _, _bgbb := range _bbcg.CustShow {
			e.EncodeElement(_bgbb, _bcc)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_gead *CT_Slide) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gead.CSld = NewCT_CommonSlideData()
	for _, _bcfef := range start.Attr {
		if _bcfef.Name.Local == "show" {
			_babg, _cfgb := _b.ParseBool(_bcfef.Value)
			if _cfgb != nil {
				return _cfgb
			}
			_gead.ShowAttr = &_babg
			continue
		}
		if _bcfef.Name.Local == "showMasterSp" {
			_bcbc, _babge := _b.ParseBool(_bcfef.Value)
			if _babge != nil {
				return _babge
			}
			_gead.ShowMasterSpAttr = &_bcbc
			continue
		}
		if _bcfef.Name.Local == "showMasterPhAnim" {
			_ddaf, _ecca := _b.ParseBool(_bcfef.Value)
			if _ecca != nil {
				return _ecca
			}
			_gead.ShowMasterPhAnimAttr = &_ddaf
			continue
		}
	}
_bdag:
	for {
		_daggc, _cead := d.Token()
		if _cead != nil {
			return _cead
		}
		switch _baffc := _daggc.(type) {
		case _e.StartElement:
			switch _baffc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _agfab := d.DecodeElement(_gead.CSld, &_baffc); _agfab != nil {
					return _agfab
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMapOvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMapOvr"}:
				_gead.ClrMapOvr = _cb.NewCT_ColorMappingOverride()
				if _gcbgf := d.DecodeElement(_gead.ClrMapOvr, &_baffc); _gcbgf != nil {
					return _gcbgf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "transition"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "transition"}:
				_gead.Transition = NewCT_SlideTransition()
				if _beaeb := d.DecodeElement(_gead.Transition, &_baffc); _beaeb != nil {
					return _beaeb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "timing"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "timing"}:
				_gead.Timing = NewCT_SlideTiming()
				if _fbgga := d.DecodeElement(_gead.Timing, &_baffc); _fbgga != nil {
					return _fbgga
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_gead.ExtLst = NewCT_ExtensionListModify()
				if _cddf := d.DecodeElement(_gead.ExtLst, &_baffc); _cddf != nil {
					return _cddf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Slide\u0020\u0025v", _baffc.Name)
				if _fbggaf := d.Skip(); _fbggaf != nil {
					return _fbggaf
				}
			}
		case _e.EndElement:
			break _bdag
		case _e.CharData:
		}
	}
	return nil
}

type CT_SlideMasterIdListEntry struct {

	// Slide Master Identifier
	IdAttr  *uint32
	RIdAttr string
	ExtLst  *CT_ExtensionList
}

func (_cdfcb *ST_TLPreviousActionType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cgebg, _ggfbgd := d.Token()
	if _ggfbgd != nil {
		return _ggfbgd
	}
	if _egeba, _edagd := _cgebg.(_e.EndElement); _edagd && _egeba.Name == start.Name {
		*_cdfcb = 1
		return nil
	}
	if _bdcega, _cebfd := _cgebg.(_e.CharData); !_cebfd {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cgebg)
	} else {
		switch string(_bdcega) {
		case "":
			*_cdfcb = 0
		case "none":
			*_cdfcb = 1
		case "skipTimed":
			*_cdfcb = 2
		}
	}
	_cgebg, _ggfbgd = d.Token()
	if _ggfbgd != nil {
		return _ggfbgd
	}
	if _cebgad, _bdafd := _cgebg.(_e.EndElement); _bdafd && _cebgad.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cgebg)
}
func (_dceaa *ViewPr) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dceaa.CT_ViewProperties = *NewCT_ViewProperties()
	for _, _aebf := range start.Attr {
		if _aebf.Name.Local == "lastView" {
			_dceaa.LastViewAttr.UnmarshalXMLAttr(_aebf)
			continue
		}
		if _aebf.Name.Local == "showComments" {
			_eebf, _bdbcb := _b.ParseBool(_aebf.Value)
			if _bdbcb != nil {
				return _bdbcb
			}
			_dceaa.ShowCommentsAttr = &_eebf
			continue
		}
	}
_adaab:
	for {
		_cbfae, _eaaee := d.Token()
		if _eaaee != nil {
			return _eaaee
		}
		switch _ccgc := _cbfae.(type) {
		case _e.StartElement:
			switch _ccgc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "normalViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "normalViewPr"}:
				_dceaa.NormalViewPr = NewCT_NormalViewProperties()
				if _dcefc := d.DecodeElement(_dceaa.NormalViewPr, &_ccgc); _dcefc != nil {
					return _dcefc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "slideViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "slideViewPr"}:
				_dceaa.SlideViewPr = NewCT_SlideViewProperties()
				if _eedc := d.DecodeElement(_dceaa.SlideViewPr, &_ccgc); _eedc != nil {
					return _eedc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "outlineViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "outlineViewPr"}:
				_dceaa.OutlineViewPr = NewCT_OutlineViewProperties()
				if _fadag := d.DecodeElement(_dceaa.OutlineViewPr, &_ccgc); _fadag != nil {
					return _fadag
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "notesTextViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "notesTextViewPr"}:
				_dceaa.NotesTextViewPr = NewCT_NotesTextViewProperties()
				if _bbbd := d.DecodeElement(_dceaa.NotesTextViewPr, &_ccgc); _bbbd != nil {
					return _bbbd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sorterViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sorterViewPr"}:
				_dceaa.SorterViewPr = NewCT_SlideSorterViewProperties()
				if _cggfe := d.DecodeElement(_dceaa.SorterViewPr, &_ccgc); _cggfe != nil {
					return _cggfe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "notesViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "notesViewPr"}:
				_dceaa.NotesViewPr = NewCT_NotesViewProperties()
				if _fdgfb := d.DecodeElement(_dceaa.NotesViewPr, &_ccgc); _fdgfb != nil {
					return _fdgfb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "gridSpacing"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "gridSpacing"}:
				_dceaa.GridSpacing = _cb.NewCT_PositiveSize2D()
				if _acbcf := d.DecodeElement(_dceaa.GridSpacing, &_ccgc); _acbcf != nil {
					return _acbcf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_dceaa.ExtLst = NewCT_ExtensionList()
				if _ffadf := d.DecodeElement(_dceaa.ExtLst, &_ccgc); _ffadf != nil {
					return _ffadf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020ViewPr\u0020\u0025v", _ccgc.Name)
				if _bfdfg := d.Skip(); _bfdfg != nil {
					return _bfdfg
				}
			}
		case _e.EndElement:
			break _adaab
		case _e.CharData:
		}
	}
	return nil
}
func NewCT_GraphicalObjectFrame() *CT_GraphicalObjectFrame {
	_fcae := &CT_GraphicalObjectFrame{}
	_fcae.NvGraphicFramePr = NewCT_GraphicalObjectFrameNonVisual()
	_fcae.Xfrm = _cb.NewCT_Transform2D()
	_fcae.Graphic = _cb.NewGraphic()
	return _fcae
}

type CT_NormalViewProperties struct {

	// Show Outline Icons in Normal View
	ShowOutlineIconsAttr *bool

	// Snap Vertical Splitter
	SnapVertSplitterAttr *bool

	// State of the Vertical Splitter Bar
	VertBarStateAttr ST_SplitterBarState

	// State of the Horizontal Splitter Bar
	HorzBarStateAttr ST_SplitterBarState

	// Prefer Single View
	PreferSingleViewAttr *bool

	// Normal View Restored Left Properties
	RestoredLeft *CT_NormalViewPortion

	// Normal View Restored Top Properties
	RestoredTop *CT_NormalViewPortion
	ExtLst      *CT_ExtensionList
}

func NewCT_CustomerData() *CT_CustomerData { _aefc := &CT_CustomerData{}; return _aefc }
func (_ddffg ST_Direction) String() string {
	switch _ddffg {
	case 0:
		return ""
	case 1:
		return "horz"
	case 2:
		return "vert"
	}
	return ""
}

type SldLayout struct{ CT_SlideLayout }

func (_cfbe *CT_OutlineViewProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_ead := _e.StartElement{Name: _e.Name{Local: "p:cViewPr"}}
	e.EncodeElement(_cfbe.CViewPr, _ead)
	if _cfbe.SldLst != nil {
		_gcde := _e.StartElement{Name: _e.Name{Local: "p:sldLst"}}
		e.EncodeElement(_cfbe.SldLst, _gcde)
	}
	if _cfbe.ExtLst != nil {
		_dgaf := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_cfbe.ExtLst, _dgaf)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_aag *CT_CommonSlideData) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _aag.NameAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "name"}, Value: _c.Sprintf("\u0025v", *_aag.NameAttr)})
	}
	e.EncodeToken(start)
	if _aag.Bg != nil {
		_bfac := _e.StartElement{Name: _e.Name{Local: "p:bg"}}
		e.EncodeElement(_aag.Bg, _bfac)
	}
	_bcba := _e.StartElement{Name: _e.Name{Local: "p:spTree"}}
	e.EncodeElement(_aag.SpTree, _bcba)
	if _aag.CustDataLst != nil {
		_ggc := _e.StartElement{Name: _e.Name{Local: "p:custDataLst"}}
		e.EncodeElement(_aag.CustDataLst, _ggc)
	}
	if _aag.Controls != nil {
		_faf := _e.StartElement{Name: _e.Name{Local: "p:controls"}}
		e.EncodeElement(_aag.Controls, _faf)
	}
	if _aag.ExtLst != nil {
		_daab := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_aag.ExtLst, _daab)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewAG_TLBuild() *AG_TLBuild { _ced := &AG_TLBuild{}; return _ced }

// ValidateWithPath validates the CT_ApplicationNonVisualDrawingProps and its children, prefixing error messages with path
func (_da *CT_ApplicationNonVisualDrawingProps) ValidateWithPath(path string) error {
	if _da.Ph != nil {
		if _daa := _da.Ph.ValidateWithPath(path + "\u002fPh"); _daa != nil {
			return _daa
		}
	}
	if _da.AudioCd != nil {
		if _fdbe := _da.AudioCd.ValidateWithPath(path + "\u002fAudioCd"); _fdbe != nil {
			return _fdbe
		}
	}
	if _da.WavAudioFile != nil {
		if _aca := _da.WavAudioFile.ValidateWithPath(path + "\u002fWavAudioFile"); _aca != nil {
			return _aca
		}
	}
	if _da.AudioFile != nil {
		if _ebaa := _da.AudioFile.ValidateWithPath(path + "\u002fAudioFile"); _ebaa != nil {
			return _ebaa
		}
	}
	if _da.VideoFile != nil {
		if _dgeb := _da.VideoFile.ValidateWithPath(path + "\u002fVideoFile"); _dgeb != nil {
			return _dgeb
		}
	}
	if _da.QuickTimeFile != nil {
		if _cea := _da.QuickTimeFile.ValidateWithPath(path + "\u002fQuickTimeFile"); _cea != nil {
			return _cea
		}
	}
	if _da.CustDataLst != nil {
		if _dga := _da.CustDataLst.ValidateWithPath(path + "\u002fCustDataLst"); _dga != nil {
			return _dga
		}
	}
	if _da.ExtLst != nil {
		if _eedf := _da.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eedf != nil {
			return _eedf
		}
	}
	return nil
}

type CT_CommonViewProperties struct {

	// Variable Scale
	VarScaleAttr *bool

	// View Scale
	Scale *_cb.CT_Scale2D

	// View Origin
	Origin *_cb.CT_Point2D
}

func (_dgba *CT_TLAnimateEffectBehavior) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _dgba.TransitionAttr != ST_TLAnimateEffectTransitionUnset {
		_ggfeea, _gacc := _dgba.TransitionAttr.MarshalXMLAttr(_e.Name{Local: "transition"})
		if _gacc != nil {
			return _gacc
		}
		start.Attr = append(start.Attr, _ggfeea)
	}
	if _dgba.FilterAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "filter"}, Value: _c.Sprintf("\u0025v", *_dgba.FilterAttr)})
	}
	if _dgba.PrLstAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "prLst"}, Value: _c.Sprintf("\u0025v", *_dgba.PrLstAttr)})
	}
	e.EncodeToken(start)
	_ecad := _e.StartElement{Name: _e.Name{Local: "p:cBhvr"}}
	e.EncodeElement(_dgba.CBhvr, _ecad)
	if _dgba.Progress != nil {
		_eeaaf := _e.StartElement{Name: _e.Name{Local: "p:progress"}}
		e.EncodeElement(_dgba.Progress, _eeaaf)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_cdeffd ST_TLAnimateColorDirection) Validate() error { return _cdeffd.ValidateWithPath("") }

// ValidateWithPath validates the CT_TLBehaviorAttributeNameList and its children, prefixing error messages with path
func (_geccf *CT_TLBehaviorAttributeNameList) ValidateWithPath(path string) error { return nil }

const (
	ST_TLNextActionTypeUnset ST_TLNextActionType = 0
	ST_TLNextActionTypeNone  ST_TLNextActionType = 1
	ST_TLNextActionTypeSeek  ST_TLNextActionType = 2
)

// Validate validates the CT_CommonSlideData and its children
func (_efc *CT_CommonSlideData) Validate() error { return _efc.ValidateWithPath("CT_CommonSlideData") }

// Validate validates the EG_SlideListChoice and its children
func (_caaeb *EG_SlideListChoice) Validate() error {
	return _caaeb.ValidateWithPath("EG_SlideListChoice")
}

// Validate validates the CT_TLMediaNodeVideo and its children
func (_efcca *CT_TLMediaNodeVideo) Validate() error {
	return _efcca.ValidateWithPath("CT_TLMediaNodeVideo")
}

const (
	ST_TLTimeNodeMasterRelationUnset     ST_TLTimeNodeMasterRelation = 0
	ST_TLTimeNodeMasterRelationSameClick ST_TLTimeNodeMasterRelation = 1
	ST_TLTimeNodeMasterRelationLastClick ST_TLTimeNodeMasterRelation = 2
	ST_TLTimeNodeMasterRelationNextClick ST_TLTimeNodeMasterRelation = 3
)

// Validate validates the CT_SlideTiming and its children
func (_bacc *CT_SlideTiming) Validate() error { return _bacc.ValidateWithPath("CT_SlideTiming") }

// Validate validates the CT_TransitionStartSoundAction and its children
func (_ceaaf *CT_TransitionStartSoundAction) Validate() error {
	return _ceaaf.ValidateWithPath("CT_TransitionStartSoundAction")
}

// ValidateWithPath validates the Sld and its children, prefixing error messages with path
func (_fgdeb *Sld) ValidateWithPath(path string) error {
	if _dbcdd := _fgdeb.CT_Slide.ValidateWithPath(path); _dbcdd != nil {
		return _dbcdd
	}
	return nil
}
func (_fffa *CT_SlideViewProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_ageca := _e.StartElement{Name: _e.Name{Local: "p:cSldViewPr"}}
	e.EncodeElement(_fffa.CSldViewPr, _ageca)
	if _fffa.ExtLst != nil {
		_ebbc := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_fffa.ExtLst, _ebbc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_gfe *CT_Control) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gfe.SpidAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spid"}, Value: _c.Sprintf("\u0025v", *_gfe.SpidAttr)})
	}
	if _gfe.NameAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "name"}, Value: _c.Sprintf("\u0025v", *_gfe.NameAttr)})
	}
	if _gfe.ShowAsIconAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showAsIcon"}, Value: _c.Sprintf("\u0025d", _fdeab(*_gfe.ShowAsIconAttr))})
	}
	if _gfe.IdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", *_gfe.IdAttr)})
	}
	if _gfe.ImgWAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "imgW"}, Value: _c.Sprintf("\u0025v", *_gfe.ImgWAttr)})
	}
	if _gfe.ImgHAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "imgH"}, Value: _c.Sprintf("\u0025v", *_gfe.ImgHAttr)})
	}
	e.EncodeToken(start)
	if _gfe.ExtLst != nil {
		_bgcc := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_gfe.ExtLst, _bgcc)
	}
	if _gfe.Pic != nil {
		_cgae := _e.StartElement{Name: _e.Name{Local: "p:pic"}}
		e.EncodeElement(_gfe.Pic, _cgae)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_eedaa *ST_TLTimeAnimateValueTime) ValidateWithPath(path string) error {
	_gfec := []string{}
	if _eedaa.ST_PositiveFixedPercentage != nil {
		if _addgd := _eedaa.ST_PositiveFixedPercentage.ValidateWithPath(path + "/ST_PositiveFixedPercentage"); _addgd != nil {
			return _addgd
		}
		_gfec = append(_gfec, "ST_PositiveFixedPercentage")
	}
	if _eedaa.ST_TLTimeIndefinite != ST_TLTimeIndefiniteUnset {
		_gfec = append(_gfec, "ST_TLTimeIndefinite")
	}
	if len(_gfec) > 1 {
		return _c.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _gfec)
	}
	return nil
}

// ValidateWithPath validates the CT_NotesMasterIdList and its children, prefixing error messages with path
func (_cagaf *CT_NotesMasterIdList) ValidateWithPath(path string) error {
	if _cagaf.NotesMasterId != nil {
		if _fbcef := _cagaf.NotesMasterId.ValidateWithPath(path + "\u002fNotesMasterId"); _fbcef != nil {
			return _fbcef
		}
	}
	return nil
}
func NewViewPr() *ViewPr {
	_agegf := &ViewPr{}
	_agegf.CT_ViewProperties = *NewCT_ViewProperties()
	return _agegf
}

type CT_TLAnimateScaleBehavior struct {

	// Zoom Content
	ZoomContentsAttr *bool
	CBhvr            *CT_TLCommonBehaviorData

	// By
	By   *CT_TLPoint
	From *CT_TLPoint

	// To
	To *CT_TLPoint
}

func NewCT_ModifyVerifier() *CT_ModifyVerifier { _bcfg := &CT_ModifyVerifier{}; return _bcfg }
func NewCT_TLCommonBehaviorData() *CT_TLCommonBehaviorData {
	_dccfa := &CT_TLCommonBehaviorData{}
	_dccfa.CTn = NewCT_TLCommonTimeNodeData()
	_dccfa.TgtEl = NewCT_TLTimeTargetElement()
	return _dccfa
}

// Validate validates the CT_StringTag and its children
func (_dgdbf *CT_StringTag) Validate() error { return _dgdbf.ValidateWithPath("CT_StringTag") }

// ValidateWithPath validates the CT_CommentList and its children, prefixing error messages with path
func (_ccc *CT_CommentList) ValidateWithPath(path string) error {
	for _gcac, _eda := range _ccc.Cm {
		if _fdba := _eda.ValidateWithPath(_c.Sprintf("\u0025s\u002fCm\u005b\u0025d]", path, _gcac)); _fdba != nil {
			return _fdba
		}
	}
	return nil
}
func NewCT_Placeholder() *CT_Placeholder { _afcbd := &CT_Placeholder{}; return _afcbd }
func (_eacdc ST_TLTimeIndefinite) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_degag := _e.Attr{}
	_degag.Name = name
	switch _eacdc {
	case ST_TLTimeIndefiniteUnset:
		_degag.Value = ""
	case ST_TLTimeIndefiniteIndefinite:
		_degag.Value = "indefinite"
	}
	return _degag, nil
}

// Validate validates the CT_TLTimeAnimateValueList and its children
func (_bdba *CT_TLTimeAnimateValueList) Validate() error {
	return _bdba.ValidateWithPath("CT_TLTimeAnimateValueList")
}

type ST_PrintColorMode byte

func NewPresentationPr() *PresentationPr {
	_ddcde := &PresentationPr{}
	_ddcde.CT_PresentationProperties = *NewCT_PresentationProperties()
	return _ddcde
}
func (_ccgaf ST_TLNextActionType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_bgedc := _e.Attr{}
	_bgedc.Name = name
	switch _ccgaf {
	case ST_TLNextActionTypeUnset:
		_bgedc.Value = ""
	case ST_TLNextActionTypeNone:
		_bgedc.Value = "none"
	case ST_TLNextActionTypeSeek:
		_bgedc.Value = "seek"
	}
	return _bgedc, nil
}
func (_dggafa ST_WebColorType) ValidateWithPath(path string) error {
	switch _dggafa {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dggafa))
	}
	return nil
}

type CT_GuideList struct {

	// A Guide
	Guide []*CT_Guide
}

func (_abfeb *ST_TLParaBuildType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dgff, _bgdba := d.Token()
	if _bgdba != nil {
		return _bgdba
	}
	if _fdfgg, _ceceba := _dgff.(_e.EndElement); _ceceba && _fdfgg.Name == start.Name {
		*_abfeb = 1
		return nil
	}
	if _accf, _aeefg := _dgff.(_e.CharData); !_aeefg {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dgff)
	} else {
		switch string(_accf) {
		case "":
			*_abfeb = 0
		case "allAtOnce":
			*_abfeb = 1
		case "p":
			*_abfeb = 2
		case "cust":
			*_abfeb = 3
		case "whole":
			*_abfeb = 4
		}
	}
	_dgff, _bgdba = d.Token()
	if _bgdba != nil {
		return _bgdba
	}
	if _gdbea, _acgc := _dgff.(_e.EndElement); _acgc && _gdbea.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dgff)
}
func (_bbcdc ST_TLDiagramBuildType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_gbaeb := _e.Attr{}
	_gbaeb.Name = name
	switch _bbcdc {
	case ST_TLDiagramBuildTypeUnset:
		_gbaeb.Value = ""
	case ST_TLDiagramBuildTypeWhole:
		_gbaeb.Value = "whole"
	case ST_TLDiagramBuildTypeDepthByNode:
		_gbaeb.Value = "depthByNode"
	case ST_TLDiagramBuildTypeDepthByBranch:
		_gbaeb.Value = "depthByBranch"
	case ST_TLDiagramBuildTypeBreadthByNode:
		_gbaeb.Value = "breadthByNode"
	case ST_TLDiagramBuildTypeBreadthByLvl:
		_gbaeb.Value = "breadthByLvl"
	case ST_TLDiagramBuildTypeCw:
		_gbaeb.Value = "cw"
	case ST_TLDiagramBuildTypeCwIn:
		_gbaeb.Value = "cwIn"
	case ST_TLDiagramBuildTypeCwOut:
		_gbaeb.Value = "cwOut"
	case ST_TLDiagramBuildTypeCcw:
		_gbaeb.Value = "ccw"
	case ST_TLDiagramBuildTypeCcwIn:
		_gbaeb.Value = "ccwIn"
	case ST_TLDiagramBuildTypeCcwOut:
		_gbaeb.Value = "ccwOut"
	case ST_TLDiagramBuildTypeInByRing:
		_gbaeb.Value = "inByRing"
	case ST_TLDiagramBuildTypeOutByRing:
		_gbaeb.Value = "outByRing"
	case ST_TLDiagramBuildTypeUp:
		_gbaeb.Value = "up"
	case ST_TLDiagramBuildTypeDown:
		_gbaeb.Value = "down"
	case ST_TLDiagramBuildTypeAllAtOnce:
		_gbaeb.Value = "allAtOnce"
	case ST_TLDiagramBuildTypeCust:
		_gbaeb.Value = "cust"
	}
	return _gbaeb, nil
}
func (_aadfa *CT_TLCommandBehavior) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_aadfa.CBhvr = NewCT_TLCommonBehaviorData()
	for _, _dbec := range start.Attr {
		if _dbec.Name.Local == "type" {
			_aadfa.TypeAttr.UnmarshalXMLAttr(_dbec)
			continue
		}
		if _dbec.Name.Local == "cmd" {
			_affa, _fdddg := _dbec.Value, error(nil)
			if _fdddg != nil {
				return _fdddg
			}
			_aadfa.CmdAttr = &_affa
			continue
		}
	}
_bedef:
	for {
		_babed, _efafd := d.Token()
		if _efafd != nil {
			return _efafd
		}
		switch _dgeac := _babed.(type) {
		case _e.StartElement:
			switch _dgeac.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cBhvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cBhvr"}:
				if _gbfab := d.DecodeElement(_aadfa.CBhvr, &_dgeac); _gbfab != nil {
					return _gbfab
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_TLCommandBehavior\u0020\u0025v", _dgeac.Name)
				if _ggded := d.Skip(); _ggded != nil {
					return _ggded
				}
			}
		case _e.EndElement:
			break _bedef
		case _e.CharData:
		}
	}
	return nil
}
func (_aaaag ST_TLDiagramBuildType) String() string {
	switch _aaaag {
	case 0:
		return ""
	case 1:
		return "whole"
	case 2:
		return "depthByNode"
	case 3:
		return "depthByBranch"
	case 4:
		return "breadthByNode"
	case 5:
		return "breadthByLvl"
	case 6:
		return "cw"
	case 7:
		return "cwIn"
	case 8:
		return "cwOut"
	case 9:
		return "ccw"
	case 10:
		return "ccwIn"
	case 11:
		return "ccwOut"
	case 12:
		return "inByRing"
	case 13:
		return "outByRing"
	case 14:
		return "up"
	case 15:
		return "down"
	case 16:
		return "allAtOnce"
	case 17:
		return "cust"
	}
	return ""
}

const (
	ST_TLAnimateBehaviorCalcModeUnset    ST_TLAnimateBehaviorCalcMode = 0
	ST_TLAnimateBehaviorCalcModeDiscrete ST_TLAnimateBehaviorCalcMode = 1
	ST_TLAnimateBehaviorCalcModeLin      ST_TLAnimateBehaviorCalcMode = 2
	ST_TLAnimateBehaviorCalcModeFmla     ST_TLAnimateBehaviorCalcMode = 3
)

// ValidateWithPath validates the CT_TLOleChartTargetElement and its children, prefixing error messages with path
func (_cbcag *CT_TLOleChartTargetElement) ValidateWithPath(path string) error {
	if _cbcag.TypeAttr == ST_TLChartSubelementTypeUnset {
		return _c.Errorf("\u0025s\u002fTypeAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bfgc := _cbcag.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _bfgc != nil {
		return _bfgc
	}
	return nil
}
func (_aebb *CT_TLAnimateScaleBehavior) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_aebb.CBhvr = NewCT_TLCommonBehaviorData()
	for _, _eaabaf := range start.Attr {
		if _eaabaf.Name.Local == "zoomContents" {
			_ffgg, _fbbcf := _b.ParseBool(_eaabaf.Value)
			if _fbbcf != nil {
				return _fbbcf
			}
			_aebb.ZoomContentsAttr = &_ffgg
			continue
		}
	}
_dgacb:
	for {
		_daebc, _eadec := d.Token()
		if _eadec != nil {
			return _eadec
		}
		switch _dbdf := _daebc.(type) {
		case _e.StartElement:
			switch _dbdf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cBhvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cBhvr"}:
				if _bedge := d.DecodeElement(_aebb.CBhvr, &_dbdf); _bedge != nil {
					return _bedge
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "by"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "by"}:
				_aebb.By = NewCT_TLPoint()
				if _bfeaa := d.DecodeElement(_aebb.By, &_dbdf); _bfeaa != nil {
					return _bfeaa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "from"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "from"}:
				_aebb.From = NewCT_TLPoint()
				if _afbb := d.DecodeElement(_aebb.From, &_dbdf); _afbb != nil {
					return _afbb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "to"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "to"}:
				_aebb.To = NewCT_TLPoint()
				if _ebecf := d.DecodeElement(_aebb.To, &_dbdf); _ebecf != nil {
					return _ebecf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLAnimateScaleBehavior\u0020\u0025v", _dbdf.Name)
				if _geegc := d.Skip(); _geegc != nil {
					return _geegc
				}
			}
		case _e.EndElement:
			break _dgacb
		case _e.CharData:
		}
	}
	return nil
}

type CT_HtmlPublishProperties struct {

	// Show Speaker Notes
	ShowSpeakerNotesAttr *bool

	// Target Output Profile
	TargetAttr *string

	// HTML Output Title
	TitleAttr *string
	IdAttr    string

	// All Slides
	SldAll *CT_Empty

	// Slide Range
	SldRg *CT_IndexRange

	// Custom Show
	CustShow *CT_CustomShowId
	ExtLst   *CT_ExtensionList
}

// ValidateWithPath validates the SldSyncPr and its children, prefixing error messages with path
func (_eege *SldSyncPr) ValidateWithPath(path string) error {
	if _eccfe := _eege.CT_SlideSyncProperties.ValidateWithPath(path); _eccfe != nil {
		return _eccfe
	}
	return nil
}
func (_beff *CT_TLBuildDiagram) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _beff.BldAttr != ST_TLDiagramBuildTypeUnset {
		_aadgf, _ffdg := _beff.BldAttr.MarshalXMLAttr(_e.Name{Local: "bld"})
		if _ffdg != nil {
			return _ffdg
		}
		start.Attr = append(start.Attr, _aadgf)
	}
	if _beff.SpidAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spid"}, Value: _c.Sprintf("\u0025v", *_beff.SpidAttr)})
	}
	if _beff.GrpIdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "grpId"}, Value: _c.Sprintf("\u0025v", *_beff.GrpIdAttr)})
	}
	if _beff.UiExpandAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "uiExpand"}, Value: _c.Sprintf("\u0025d", _fdeab(*_beff.UiExpandAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_gcga *CT_SlideLayoutIdListEntry) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _fbbga := range start.Attr {
		if _fbbga.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _fbbga.Name.Local == "id" || _fbbga.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _fbbga.Name.Local == "id" {
			_afdf, _dfef := _fbbga.Value, error(nil)
			if _dfef != nil {
				return _dfef
			}
			_gcga.RIdAttr = _afdf
			continue
		}
		if _fbbga.Name.Local == "id" {
			_caag, _egbd := _b.ParseUint(_fbbga.Value, 10, 32)
			if _egbd != nil {
				return _egbd
			}
			_gcad := uint32(_caag)
			_gcga.IdAttr = &_gcad
			continue
		}
	}
_adbfg:
	for {
		_cgec, _bedea := d.Token()
		if _bedea != nil {
			return _bedea
		}
		switch _abbga := _cgec.(type) {
		case _e.StartElement:
			switch _abbga.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_gcga.ExtLst = NewCT_ExtensionList()
				if _geed := d.DecodeElement(_gcga.ExtLst, &_abbga); _geed != nil {
					return _geed
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SlideLayoutIdListEntry\u0020\u0025v", _abbga.Name)
				if _becbf := d.Skip(); _becbf != nil {
					return _becbf
				}
			}
		case _e.EndElement:
			break _adbfg
		case _e.CharData:
		}
	}
	return nil
}

type CT_TLTimeAnimateValueList struct {

	// Time Animate Value
	Tav []*CT_TLTimeAnimateValue
}

func (_addg *CT_Shape) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_addg.NvSpPr = NewCT_ShapeNonVisual()
	_addg.SpPr = _cb.NewCT_ShapeProperties()
	for _, _gagab := range start.Attr {
		if _gagab.Name.Local == "useBgFill" {
			_bgfcb, _acecg := _b.ParseBool(_gagab.Value)
			if _acecg != nil {
				return _acecg
			}
			_addg.UseBgFillAttr = &_bgfcb
			continue
		}
	}
_ecff:
	for {
		_cddgc, _fcde := d.Token()
		if _fcde != nil {
			return _fcde
		}
		switch _ggda := _cddgc.(type) {
		case _e.StartElement:
			switch _ggda.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "nvSpPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "nvSpPr"}:
				if _fecc := d.DecodeElement(_addg.NvSpPr, &_ggda); _fecc != nil {
					return _fecc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "spPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "spPr"}:
				if _eccef := d.DecodeElement(_addg.SpPr, &_ggda); _eccef != nil {
					return _eccef
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "style"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "style"}:
				_addg.Style = _cb.NewCT_ShapeStyle()
				if _dcgc := d.DecodeElement(_addg.Style, &_ggda); _dcgc != nil {
					return _dcgc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "txBody"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "txBody"}:
				_addg.TxBody = _cb.NewCT_TextBody()
				if _ebbg := d.DecodeElement(_addg.TxBody, &_ggda); _ebbg != nil {
					return _ebbg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_addg.ExtLst = NewCT_ExtensionListModify()
				if _eadf := d.DecodeElement(_addg.ExtLst, &_ggda); _eadf != nil {
					return _eadf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Shape\u0020\u0025v", _ggda.Name)
				if _dffd := d.Skip(); _dffd != nil {
					return _dffd
				}
			}
		case _e.EndElement:
			break _ecff
		case _e.CharData:
		}
	}
	return nil
}
func (_cbgf *CT_GraphicalObjectFrameNonVisual) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_gfb := _e.StartElement{Name: _e.Name{Local: "p:cNvPr"}}
	e.EncodeElement(_cbgf.CNvPr, _gfb)
	_bcca := _e.StartElement{Name: _e.Name{Local: "p:cNvGraphicFramePr"}}
	e.EncodeElement(_cbgf.CNvGraphicFramePr, _bcca)
	_bdbe := _e.StartElement{Name: _e.Name{Local: "p:nvPr"}}
	e.EncodeElement(_cbgf.NvPr, _bdbe)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_OutlineViewSlideEntry() *CT_OutlineViewSlideEntry {
	_egcf := &CT_OutlineViewSlideEntry{}
	return _egcf
}
func (_egggeg *CT_TagList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _egggeg.Tag != nil {
		_dabf := _e.StartElement{Name: _e.Name{Local: "p:tag"}}
		for _, _fefda := range _egggeg.Tag {
			e.EncodeElement(_fefda, _dabf)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_dbedf *ST_TransitionEightDirectionType) ValidateWithPath(path string) error {
	_fefdd := []string{}
	if _dbedf.ST_TransitionSideDirectionType != ST_TransitionSideDirectionTypeUnset {
		_fefdd = append(_fefdd, "ST_TransitionSideDirectionType")
	}
	if _dbedf.ST_TransitionCornerDirectionType != ST_TransitionCornerDirectionTypeUnset {
		_fefdd = append(_fefdd, "ST_TransitionCornerDirectionType")
	}
	if len(_fefdd) > 1 {
		return _c.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _fefdd)
	}
	return nil
}
func (_gadbb *ST_SlideLayoutType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_gadbb = 0
	case "title":
		*_gadbb = 1
	case "tx":
		*_gadbb = 2
	case "twoColTx":
		*_gadbb = 3
	case "tbl":
		*_gadbb = 4
	case "txAndChart":
		*_gadbb = 5
	case "chartAndTx":
		*_gadbb = 6
	case "dgm":
		*_gadbb = 7
	case "chart":
		*_gadbb = 8
	case "txAndClipArt":
		*_gadbb = 9
	case "clipArtAndTx":
		*_gadbb = 10
	case "titleOnly":
		*_gadbb = 11
	case "blank":
		*_gadbb = 12
	case "txAndObj":
		*_gadbb = 13
	case "objAndTx":
		*_gadbb = 14
	case "objOnly":
		*_gadbb = 15
	case "obj":
		*_gadbb = 16
	case "txAndMedia":
		*_gadbb = 17
	case "mediaAndTx":
		*_gadbb = 18
	case "objOverTx":
		*_gadbb = 19
	case "txOverObj":
		*_gadbb = 20
	case "txAndTwoObj":
		*_gadbb = 21
	case "twoObjAndTx":
		*_gadbb = 22
	case "twoObjOverTx":
		*_gadbb = 23
	case "fourObj":
		*_gadbb = 24
	case "vertTx":
		*_gadbb = 25
	case "clipArtAndVertTx":
		*_gadbb = 26
	case "vertTitleAndTx":
		*_gadbb = 27
	case "vertTitleAndTxOverChart":
		*_gadbb = 28
	case "twoObj":
		*_gadbb = 29
	case "objAndTwoObj":
		*_gadbb = 30
	case "twoObjAndObj":
		*_gadbb = 31
	case "cust":
		*_gadbb = 32
	case "secHead":
		*_gadbb = 33
	case "twoTxTwoObj":
		*_gadbb = 34
	case "objTx":
		*_gadbb = 35
	case "picTx":
		*_gadbb = 36
	}
	return nil
}
func (_edgab ST_PhotoAlbumFrameShape) Validate() error { return _edgab.ValidateWithPath("") }

// Validate validates the CT_CustomShowId and its children
func (_fece *CT_CustomShowId) Validate() error { return _fece.ValidateWithPath("CT_CustomShowId") }
func (_aac *CT_GroupShape) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_aac.NvGrpSpPr = NewCT_GroupShapeNonVisual()
	_aac.GrpSpPr = _cb.NewCT_GroupShapeProperties()
_aefg:
	for {
		_fcce, _ffab := d.Token()
		if _ffab != nil {
			return _ffab
		}
		switch _ggfc := _fcce.(type) {
		case _e.StartElement:
			switch _ggfc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "nvGrpSpPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "nvGrpSpPr"}:
				if _ggdb := d.DecodeElement(_aac.NvGrpSpPr, &_ggfc); _ggdb != nil {
					return _ggdb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "grpSpPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "grpSpPr"}:
				if _gffcb := d.DecodeElement(_aac.GrpSpPr, &_ggfc); _gffcb != nil {
					return _gffcb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sp"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sp"}:
				_dee := NewCT_GroupShapeChoice()
				if _ecee := d.DecodeElement(&_dee.Sp, &_ggfc); _ecee != nil {
					return _ecee
				}
				_aac.Choice = append(_aac.Choice, _dee)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "grpSp"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "grpSp"}:
				_cgbc := NewCT_GroupShapeChoice()
				if _gcda := d.DecodeElement(&_cgbc.GrpSp, &_ggfc); _gcda != nil {
					return _gcda
				}
				_aac.Choice = append(_aac.Choice, _cgbc)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "graphicFrame"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "graphicFrame"}:
				_gbfc := NewCT_GroupShapeChoice()
				if _fceb := d.DecodeElement(&_gbfc.GraphicFrame, &_ggfc); _fceb != nil {
					return _fceb
				}
				_aac.Choice = append(_aac.Choice, _gbfc)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cxnSp"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cxnSp"}:
				_dbga := NewCT_GroupShapeChoice()
				if _cbafa := d.DecodeElement(&_dbga.CxnSp, &_ggfc); _cbafa != nil {
					return _cbafa
				}
				_aac.Choice = append(_aac.Choice, _dbga)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "pic"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "pic"}:
				_eced := NewCT_GroupShapeChoice()
				if _ecccb := d.DecodeElement(&_eced.Pic, &_ggfc); _ecccb != nil {
					return _ecccb
				}
				_aac.Choice = append(_aac.Choice, _eced)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "contentPart"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "contentPart"}:
				_gfac := NewCT_GroupShapeChoice()
				if _feef := d.DecodeElement(&_gfac.ContentPart, &_ggfc); _feef != nil {
					return _feef
				}
				_aac.Choice = append(_aac.Choice, _gfac)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_aac.ExtLst = NewCT_ExtensionListModify()
				if _agdg := d.DecodeElement(_aac.ExtLst, &_ggfc); _agdg != nil {
					return _agdg
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_GroupShape \u0025v", _ggfc.Name)
				if _cecc := d.Skip(); _cecc != nil {
					return _cecc
				}
			}
		case _e.EndElement:
			break _aefg
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_BackgroundProperties and its children, prefixing error messages with path
func (_cec *CT_BackgroundProperties) ValidateWithPath(path string) error {
	if _cec.NoFill != nil {
		if _cfaa := _cec.NoFill.ValidateWithPath(path + "\u002fNoFill"); _cfaa != nil {
			return _cfaa
		}
	}
	if _cec.SolidFill != nil {
		if _dda := _cec.SolidFill.ValidateWithPath(path + "\u002fSolidFill"); _dda != nil {
			return _dda
		}
	}
	if _cec.GradFill != nil {
		if _bdd := _cec.GradFill.ValidateWithPath(path + "\u002fGradFill"); _bdd != nil {
			return _bdd
		}
	}
	if _cec.BlipFill != nil {
		if _dbff := _cec.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _dbff != nil {
			return _dbff
		}
	}
	if _cec.PattFill != nil {
		if _gcb := _cec.PattFill.ValidateWithPath(path + "\u002fPattFill"); _gcb != nil {
			return _gcb
		}
	}
	if _cec.GrpFill != nil {
		if _bfe := _cec.GrpFill.ValidateWithPath(path + "\u002fGrpFill"); _bfe != nil {
			return _bfe
		}
	}
	if _cec.EffectLst != nil {
		if _ddac := _cec.EffectLst.ValidateWithPath(path + "\u002fEffectLst"); _ddac != nil {
			return _ddac
		}
	}
	if _cec.EffectDag != nil {
		if _egc := _cec.EffectDag.ValidateWithPath(path + "\u002fEffectDag"); _egc != nil {
			return _egc
		}
	}
	if _cec.ExtLst != nil {
		if _bae := _cec.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bae != nil {
			return _bae
		}
	}
	return nil
}

// Validate validates the CT_TLTimeNodeParallel and its children
func (_fcedg *CT_TLTimeNodeParallel) Validate() error {
	return _fcedg.ValidateWithPath("CT_TLTimeNodeParallel")
}

// Validate validates the CT_CommentList and its children
func (_cdb *CT_CommentList) Validate() error { return _cdb.ValidateWithPath("CT_CommentList") }

// ValidateWithPath validates the CT_NotesMasterIdListEntry and its children, prefixing error messages with path
func (_fbfc *CT_NotesMasterIdListEntry) ValidateWithPath(path string) error {
	if _fbfc.ExtLst != nil {
		if _dfgdg := _fbfc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dfgdg != nil {
			return _dfgdg
		}
	}
	return nil
}
func NewCT_NormalViewPortion() *CT_NormalViewPortion {
	_bcceed := &CT_NormalViewPortion{}
	return _bcceed
}
func (_edf *CT_CommentList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_agf:
	for {
		_acbc, _fae := d.Token()
		if _fae != nil {
			return _fae
		}
		switch _bceae := _acbc.(type) {
		case _e.StartElement:
			switch _bceae.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cm"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cm"}:
				_ccea := NewCT_Comment()
				if _fec := d.DecodeElement(_ccea, &_bceae); _fec != nil {
					return _fec
				}
				_edf.Cm = append(_edf.Cm, _ccea)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CommentList\u0020\u0025v", _bceae.Name)
				if _bff := d.Skip(); _bff != nil {
					return _bff
				}
			}
		case _e.EndElement:
			break _agf
		case _e.CharData:
		}
	}
	return nil
}
func (_dade *CT_Placeholder) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _bdgd := range start.Attr {
		if _bdgd.Name.Local == "type" {
			_dade.TypeAttr.UnmarshalXMLAttr(_bdgd)
			continue
		}
		if _bdgd.Name.Local == "orient" {
			_dade.OrientAttr.UnmarshalXMLAttr(_bdgd)
			continue
		}
		if _bdgd.Name.Local == "sz" {
			_dade.SzAttr.UnmarshalXMLAttr(_bdgd)
			continue
		}
		if _bdgd.Name.Local == "idx" {
			_agca, _acag := _b.ParseUint(_bdgd.Value, 10, 32)
			if _acag != nil {
				return _acag
			}
			_gagb := uint32(_agca)
			_dade.IdxAttr = &_gagb
			continue
		}
		if _bdgd.Name.Local == "hasCustomPrompt" {
			_gaae, _befga := _b.ParseBool(_bdgd.Value)
			if _befga != nil {
				return _befga
			}
			_dade.HasCustomPromptAttr = &_gaae
			continue
		}
	}
_aefee:
	for {
		_dagg, _cabf := d.Token()
		if _cabf != nil {
			return _cabf
		}
		switch _eeaa := _dagg.(type) {
		case _e.StartElement:
			switch _eeaa.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_dade.ExtLst = NewCT_ExtensionListModify()
				if _bgbdf := d.DecodeElement(_dade.ExtLst, &_eeaa); _bgbdf != nil {
					return _bgbdf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Placeholder\u0020\u0025v", _eeaa.Name)
				if _dfbgc := d.Skip(); _dfbgc != nil {
					return _dfbgc
				}
			}
		case _e.EndElement:
			break _aefee
		case _e.CharData:
		}
	}
	return nil
}
func (_baadb *CT_Picture) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_ggbc := _e.StartElement{Name: _e.Name{Local: "p:nvPicPr"}}
	e.EncodeElement(_baadb.NvPicPr, _ggbc)
	_fdgc := _e.StartElement{Name: _e.Name{Local: "p:blipFill"}}
	e.EncodeElement(_baadb.BlipFill, _fdgc)
	_gfacd := _e.StartElement{Name: _e.Name{Local: "p:spPr"}}
	e.EncodeElement(_baadb.SpPr, _gfacd)
	if _baadb.Style != nil {
		_dgce := _e.StartElement{Name: _e.Name{Local: "p:style"}}
		e.EncodeElement(_baadb.Style, _dgce)
	}
	if _baadb.ExtLst != nil {
		_efbf := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_baadb.ExtLst, _efbf)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_PresentationProperties and its children, prefixing error messages with path
func (_gcece *CT_PresentationProperties) ValidateWithPath(path string) error {
	if _gcece.HtmlPubPr != nil {
		if _bcbe := _gcece.HtmlPubPr.ValidateWithPath(path + "\u002fHtmlPubPr"); _bcbe != nil {
			return _bcbe
		}
	}
	if _gcece.WebPr != nil {
		if _egbgg := _gcece.WebPr.ValidateWithPath(path + "\u002fWebPr"); _egbgg != nil {
			return _egbgg
		}
	}
	if _gcece.PrnPr != nil {
		if _gagad := _gcece.PrnPr.ValidateWithPath(path + "\u002fPrnPr"); _gagad != nil {
			return _gagad
		}
	}
	if _gcece.ShowPr != nil {
		if _afbe := _gcece.ShowPr.ValidateWithPath(path + "\u002fShowPr"); _afbe != nil {
			return _afbe
		}
	}
	if _gcece.ClrMru != nil {
		if _aeeg := _gcece.ClrMru.ValidateWithPath(path + "\u002fClrMru"); _aeeg != nil {
			return _aeeg
		}
	}
	if _gcece.ExtLst != nil {
		if _aeffb := _gcece.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _aeffb != nil {
			return _aeffb
		}
	}
	return nil
}

type CT_TLCommandBehavior struct {

	// Command Type
	TypeAttr ST_TLCommandType

	// Command
	CmdAttr *string
	CBhvr   *CT_TLCommonBehaviorData
}

func NewCT_SlideSize() *CT_SlideSize {
	_dcdg := &CT_SlideSize{}
	_dcdg.CxAttr = 914400
	_dcdg.CyAttr = 914400
	return _dcdg
}
func (_gfaba *CT_TLIterateIntervalPercentage) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _bffe := range start.Attr {
		if _bffe.Name.Local == "val" {
			_fecfb, _fgacd := ParseUnionST_PositivePercentage(_bffe.Value)
			if _fgacd != nil {
				return _fgacd
			}
			_gfaba.ValAttr = _fecfb
			continue
		}
	}
	for {
		_ffbag, _eeabe := d.Token()
		if _eeabe != nil {
			return _c.Errorf("parsing\u0020CT_TLIterateIntervalPercentage:\u0020\u0025s", _eeabe)
		}
		if _cggfce, _ecea := _ffbag.(_e.EndElement); _ecea && _cggfce.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_OrientationTransition struct {

	// Transition Direction
	DirAttr ST_Direction
}

// Validate validates the CT_BackgroundProperties and its children
func (_adc *CT_BackgroundProperties) Validate() error {
	return _adc.ValidateWithPath("CT_BackgroundProperties")
}
func (_fcgaea *CT_TLTimeConditionList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_aaff := _e.StartElement{Name: _e.Name{Local: "p:cond"}}
	for _, _fafeg := range _fcgaea.Cond {
		e.EncodeElement(_fafeg, _aaff)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_ceed *CT_HandoutMasterIdList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _ceed.HandoutMasterId != nil {
		_fdgd := _e.StartElement{Name: _e.Name{Local: "p:handoutMasterId"}}
		e.EncodeElement(_ceed.HandoutMasterId, _fdgd)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_feag *CT_Rel) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _egbee := range start.Attr {
		if _egbee.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _egbee.Name.Local == "id" || _egbee.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _egbee.Name.Local == "id" {
			_ecfc, _ccgbc := _egbee.Value, error(nil)
			if _ccgbc != nil {
				return _ccgbc
			}
			_feag.IdAttr = _ecfc
			continue
		}
	}
	for {
		_ffff, _gfab := d.Token()
		if _gfab != nil {
			return _c.Errorf("parsing\u0020CT_Rel:\u0020\u0025s", _gfab)
		}
		if _fbff, _ebff := _ffff.(_e.EndElement); _ebff && _fbff.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_PhotoAlbumFrameShapeUnset       ST_PhotoAlbumFrameShape = 0
	ST_PhotoAlbumFrameShapeFrameStyle1 ST_PhotoAlbumFrameShape = 1
	ST_PhotoAlbumFrameShapeFrameStyle2 ST_PhotoAlbumFrameShape = 2
	ST_PhotoAlbumFrameShapeFrameStyle3 ST_PhotoAlbumFrameShape = 3
	ST_PhotoAlbumFrameShapeFrameStyle4 ST_PhotoAlbumFrameShape = 4
	ST_PhotoAlbumFrameShapeFrameStyle5 ST_PhotoAlbumFrameShape = 5
	ST_PhotoAlbumFrameShapeFrameStyle6 ST_PhotoAlbumFrameShape = 6
	ST_PhotoAlbumFrameShapeFrameStyle7 ST_PhotoAlbumFrameShape = 7
)

func (_dgbbf ST_TLNextActionType) String() string {
	switch _dgbbf {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "seek"
	}
	return ""
}

// ValidateWithPath validates the CT_Extension and its children, prefixing error messages with path
func (_eff *CT_Extension) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_TLPoint and its children
func (_egcbb *CT_TLPoint) Validate() error { return _egcbb.ValidateWithPath("CT_TLPoint") }
func (_ceag *CT_CustomShow) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "name"}, Value: _c.Sprintf("\u0025v", _ceag.NameAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "id"}, Value: _c.Sprintf("\u0025v", _ceag.IdAttr)})
	e.EncodeToken(start)
	_bebf := _e.StartElement{Name: _e.Name{Local: "p:sldLst"}}
	e.EncodeElement(_ceag.SldLst, _bebf)
	if _ceag.ExtLst != nil {
		_fgbe := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ceag.ExtLst, _fgbe)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_aaaa *SldLayout) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:sldLayout"
	return _aaaa.CT_SlideLayout.MarshalXML(e, start)
}
func (_cecba ST_TLOleChartBuildType) Validate() error { return _cecba.ValidateWithPath("") }
func NewCT_ShapeNonVisual() *CT_ShapeNonVisual {
	_bbfbe := &CT_ShapeNonVisual{}
	_bbfbe.CNvPr = _cb.NewCT_NonVisualDrawingProps()
	_bbfbe.CNvSpPr = _cb.NewCT_NonVisualDrawingShapeProps()
	_bbfbe.NvPr = NewCT_ApplicationNonVisualDrawingProps()
	return _bbfbe
}
func (_dgfgeb *CT_TLTriggerTimeNodeID) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "val"}, Value: _c.Sprintf("\u0025v", _dgfgeb.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TLTemplateList and its children
func (_bgcba *CT_TLTemplateList) Validate() error {
	return _bgcba.ValidateWithPath("CT_TLTemplateList")
}
func NewEG_ChildSlide() *EG_ChildSlide { _gaaba := &EG_ChildSlide{}; return _gaaba }

// Validate validates the CT_HandoutMasterIdListEntry and its children
func (_ecf *CT_HandoutMasterIdListEntry) Validate() error {
	return _ecf.ValidateWithPath("CT_HandoutMasterIdListEntry")
}

// ValidateWithPath validates the CT_TLOleBuildChart and its children, prefixing error messages with path
func (_gbaeg *CT_TLOleBuildChart) ValidateWithPath(path string) error {
	if _eacc := _gbaeg.BldAttr.ValidateWithPath(path + "\u002fBldAttr"); _eacc != nil {
		return _eacc
	}
	return nil
}
func (_dacaa ST_SlideLayoutType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_bgefb := _e.Attr{}
	_bgefb.Name = name
	switch _dacaa {
	case ST_SlideLayoutTypeUnset:
		_bgefb.Value = ""
	case ST_SlideLayoutTypeTitle:
		_bgefb.Value = "title"
	case ST_SlideLayoutTypeTx:
		_bgefb.Value = "tx"
	case ST_SlideLayoutTypeTwoColTx:
		_bgefb.Value = "twoColTx"
	case ST_SlideLayoutTypeTbl:
		_bgefb.Value = "tbl"
	case ST_SlideLayoutTypeTxAndChart:
		_bgefb.Value = "txAndChart"
	case ST_SlideLayoutTypeChartAndTx:
		_bgefb.Value = "chartAndTx"
	case ST_SlideLayoutTypeDgm:
		_bgefb.Value = "dgm"
	case ST_SlideLayoutTypeChart:
		_bgefb.Value = "chart"
	case ST_SlideLayoutTypeTxAndClipArt:
		_bgefb.Value = "txAndClipArt"
	case ST_SlideLayoutTypeClipArtAndTx:
		_bgefb.Value = "clipArtAndTx"
	case ST_SlideLayoutTypeTitleOnly:
		_bgefb.Value = "titleOnly"
	case ST_SlideLayoutTypeBlank:
		_bgefb.Value = "blank"
	case ST_SlideLayoutTypeTxAndObj:
		_bgefb.Value = "txAndObj"
	case ST_SlideLayoutTypeObjAndTx:
		_bgefb.Value = "objAndTx"
	case ST_SlideLayoutTypeObjOnly:
		_bgefb.Value = "objOnly"
	case ST_SlideLayoutTypeObj:
		_bgefb.Value = "obj"
	case ST_SlideLayoutTypeTxAndMedia:
		_bgefb.Value = "txAndMedia"
	case ST_SlideLayoutTypeMediaAndTx:
		_bgefb.Value = "mediaAndTx"
	case ST_SlideLayoutTypeObjOverTx:
		_bgefb.Value = "objOverTx"
	case ST_SlideLayoutTypeTxOverObj:
		_bgefb.Value = "txOverObj"
	case ST_SlideLayoutTypeTxAndTwoObj:
		_bgefb.Value = "txAndTwoObj"
	case ST_SlideLayoutTypeTwoObjAndTx:
		_bgefb.Value = "twoObjAndTx"
	case ST_SlideLayoutTypeTwoObjOverTx:
		_bgefb.Value = "twoObjOverTx"
	case ST_SlideLayoutTypeFourObj:
		_bgefb.Value = "fourObj"
	case ST_SlideLayoutTypeVertTx:
		_bgefb.Value = "vertTx"
	case ST_SlideLayoutTypeClipArtAndVertTx:
		_bgefb.Value = "clipArtAndVertTx"
	case ST_SlideLayoutTypeVertTitleAndTx:
		_bgefb.Value = "vertTitleAndTx"
	case ST_SlideLayoutTypeVertTitleAndTxOverChart:
		_bgefb.Value = "vertTitleAndTxOverChart"
	case ST_SlideLayoutTypeTwoObj:
		_bgefb.Value = "twoObj"
	case ST_SlideLayoutTypeObjAndTwoObj:
		_bgefb.Value = "objAndTwoObj"
	case ST_SlideLayoutTypeTwoObjAndObj:
		_bgefb.Value = "twoObjAndObj"
	case ST_SlideLayoutTypeCust:
		_bgefb.Value = "cust"
	case ST_SlideLayoutTypeSecHead:
		_bgefb.Value = "secHead"
	case ST_SlideLayoutTypeTwoTxTwoObj:
		_bgefb.Value = "twoTxTwoObj"
	case ST_SlideLayoutTypeObjTx:
		_bgefb.Value = "objTx"
	case ST_SlideLayoutTypePicTx:
		_bgefb.Value = "picTx"
	}
	return _bgefb, nil
}
func NewCT_ShowProperties() *CT_ShowProperties { _efde := &CT_ShowProperties{}; return _efde }
func (_cgccf ST_PhotoAlbumFrameShape) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_cdeg := _e.Attr{}
	_cdeg.Name = name
	switch _cgccf {
	case ST_PhotoAlbumFrameShapeUnset:
		_cdeg.Value = ""
	case ST_PhotoAlbumFrameShapeFrameStyle1:
		_cdeg.Value = "frameStyle1"
	case ST_PhotoAlbumFrameShapeFrameStyle2:
		_cdeg.Value = "frameStyle2"
	case ST_PhotoAlbumFrameShapeFrameStyle3:
		_cdeg.Value = "frameStyle3"
	case ST_PhotoAlbumFrameShapeFrameStyle4:
		_cdeg.Value = "frameStyle4"
	case ST_PhotoAlbumFrameShapeFrameStyle5:
		_cdeg.Value = "frameStyle5"
	case ST_PhotoAlbumFrameShapeFrameStyle6:
		_cdeg.Value = "frameStyle6"
	case ST_PhotoAlbumFrameShapeFrameStyle7:
		_cdeg.Value = "frameStyle7"
	}
	return _cdeg, nil
}

type CT_TLMediaNodeAudio struct {

	// Is Narration
	IsNarrationAttr *bool

	// Common Media Node Properties
	CMediaNode *CT_TLCommonMediaNodeData
}
type CT_TLTemplate struct {

	// Level
	LvlAttr *uint32

	// Time Node List
	TnLst *CT_TimeNodeList
}

func NewCT_PresentationProperties() *CT_PresentationProperties {
	_aadca := &CT_PresentationProperties{}
	return _aadca
}

// Validate validates the CT_BuildList and its children
func (_dgc *CT_BuildList) Validate() error { return _dgc.ValidateWithPath("CT_BuildList") }
func (_baddb *ST_TLChartSubelementType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_baddb = 0
	case "gridLegend":
		*_baddb = 1
	case "series":
		*_baddb = 2
	case "category":
		*_baddb = 3
	case "ptInSeries":
		*_baddb = 4
	case "ptInCategory":
		*_baddb = 5
	}
	return nil
}
func (_aeda ST_TLTime) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _aeda.Uint32 != nil {
		e.EncodeToken(_e.CharData(_c.Sprintf("\u0025d", *_aeda.Uint32)))
	}
	if _aeda.ST_TLTimeIndefinite != ST_TLTimeIndefiniteUnset {
		e.EncodeToken(_e.CharData(_aeda.ST_TLTimeIndefinite.String()))
	}
	return e.EncodeToken(_e.EndElement{Name: start.Name})
}

type ST_TLAnimateMotionBehaviorOrigin byte

func (_acff ST_TLAnimateColorSpace) ValidateWithPath(path string) error {
	switch _acff {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_acff))
	}
	return nil
}
func (_ffbfg *CT_TLOleBuildChart) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ffbfg.BldAttr != ST_TLOleChartBuildTypeUnset {
		_dbdde, _gbbe := _ffbfg.BldAttr.MarshalXMLAttr(_e.Name{Local: "bld"})
		if _gbbe != nil {
			return _gbbe
		}
		start.Attr = append(start.Attr, _dbdde)
	}
	if _ffbfg.AnimBgAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "animBg"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ffbfg.AnimBgAttr))})
	}
	if _ffbfg.SpidAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spid"}, Value: _c.Sprintf("\u0025v", *_ffbfg.SpidAttr)})
	}
	if _ffbfg.GrpIdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "grpId"}, Value: _c.Sprintf("\u0025v", *_ffbfg.GrpIdAttr)})
	}
	if _ffbfg.UiExpandAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "uiExpand"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ffbfg.UiExpandAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_fgcb *CT_TLGraphicalObjectBuild) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _fgcb.SpidAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spid"}, Value: _c.Sprintf("\u0025v", *_fgcb.SpidAttr)})
	}
	if _fgcb.GrpIdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "grpId"}, Value: _c.Sprintf("\u0025v", *_fgcb.GrpIdAttr)})
	}
	if _fgcb.UiExpandAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "uiExpand"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fgcb.UiExpandAttr))})
	}
	e.EncodeToken(start)
	if _fgcb.BldAsOne != nil {
		_ffaef := _e.StartElement{Name: _e.Name{Local: "p:bldAsOne"}}
		e.EncodeElement(_fgcb.BldAsOne, _ffaef)
	}
	if _fgcb.BldSub != nil {
		_dacedb := _e.StartElement{Name: _e.Name{Local: "p:bldSub"}}
		e.EncodeElement(_fgcb.BldSub, _dacedb)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_SlideLayout and its children, prefixing error messages with path
func (_cgfa *CT_SlideLayout) ValidateWithPath(path string) error {
	if _daadc := _cgfa.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _daadc != nil {
		return _daadc
	}
	if _eacb := _cgfa.CSld.ValidateWithPath(path + "\u002fCSld"); _eacb != nil {
		return _eacb
	}
	if _cgfa.ClrMapOvr != nil {
		if _faag := _cgfa.ClrMapOvr.ValidateWithPath(path + "\u002fClrMapOvr"); _faag != nil {
			return _faag
		}
	}
	if _cgfa.Transition != nil {
		if _cdac := _cgfa.Transition.ValidateWithPath(path + "/Transition"); _cdac != nil {
			return _cdac
		}
	}
	if _cgfa.Timing != nil {
		if _bdebg := _cgfa.Timing.ValidateWithPath(path + "\u002fTiming"); _bdebg != nil {
			return _bdebg
		}
	}
	if _cgfa.Hf != nil {
		if _baecf := _cgfa.Hf.ValidateWithPath(path + "\u002fHf"); _baecf != nil {
			return _baecf
		}
	}
	if _cgfa.ExtLst != nil {
		if _bdfe := _cgfa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bdfe != nil {
			return _bdfe
		}
	}
	return nil
}

// Validate validates the CT_TLAnimVariantIntegerVal and its children
func (_bdbc *CT_TLAnimVariantIntegerVal) Validate() error {
	return _bdbc.ValidateWithPath("CT_TLAnimVariantIntegerVal")
}
func (_agfac *CT_SlideIdList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_fgdc:
	for {
		_abeaba, _fffce := d.Token()
		if _fffce != nil {
			return _fffce
		}
		switch _ggab := _abeaba.(type) {
		case _e.StartElement:
			switch _ggab.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldId"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldId"}:
				_deccb := NewCT_SlideIdListEntry()
				if _ecag := d.DecodeElement(_deccb, &_ggab); _ecag != nil {
					return _ecag
				}
				_agfac.SldId = append(_agfac.SldId, _deccb)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SlideIdList\u0020\u0025v", _ggab.Name)
				if _abcc := d.Skip(); _abcc != nil {
					return _abcc
				}
			}
		case _e.EndElement:
			break _fgdc
		case _e.CharData:
		}
	}
	return nil
}
func NewCT_CustomShow() *CT_CustomShow {
	_cgaf := &CT_CustomShow{}
	_cgaf.SldLst = NewCT_SlideRelationshipList()
	return _cgaf
}
func (_gcdga ST_TransitionSpeed) String() string {
	switch _gcdga {
	case 0:
		return ""
	case 1:
		return "slow"
	case 2:
		return "med"
	case 3:
		return "fast"
	}
	return ""
}

// Validate validates the CT_TLOleBuildChart and its children
func (_agba *CT_TLOleBuildChart) Validate() error {
	return _agba.ValidateWithPath("CT_TLOleBuildChart")
}

const (
	ST_TLChartSubelementTypeUnset        ST_TLChartSubelementType = 0
	ST_TLChartSubelementTypeGridLegend   ST_TLChartSubelementType = 1
	ST_TLChartSubelementTypeSeries       ST_TLChartSubelementType = 2
	ST_TLChartSubelementTypeCategory     ST_TLChartSubelementType = 3
	ST_TLChartSubelementTypePtInSeries   ST_TLChartSubelementType = 4
	ST_TLChartSubelementTypePtInCategory ST_TLChartSubelementType = 5
)
const (
	ST_TLBehaviorOverrideTypeUnset      ST_TLBehaviorOverrideType = 0
	ST_TLBehaviorOverrideTypeNormal     ST_TLBehaviorOverrideType = 1
	ST_TLBehaviorOverrideTypeChildStyle ST_TLBehaviorOverrideType = 2
)

// ValidateWithPath validates the CT_CustomerDataList and its children, prefixing error messages with path
func (_ccfaf *CT_CustomerDataList) ValidateWithPath(path string) error {
	for _efad, _daf := range _ccfaf.CustData {
		if _edee := _daf.ValidateWithPath(_c.Sprintf("\u0025s\u002fCustData\u005b\u0025d\u005d", path, _efad)); _edee != nil {
			return _edee
		}
	}
	if _ccfaf.Tags != nil {
		if _fca := _ccfaf.Tags.ValidateWithPath(path + "\u002fTags"); _fca != nil {
			return _fca
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TLAnimateEffectBehavior and its children, prefixing error messages with path
func (_cbcgc *CT_TLAnimateEffectBehavior) ValidateWithPath(path string) error {
	if _dged := _cbcgc.TransitionAttr.ValidateWithPath(path + "\u002fTransitionAttr"); _dged != nil {
		return _dged
	}
	if _ggfdd := _cbcgc.CBhvr.ValidateWithPath(path + "\u002fCBhvr"); _ggfdd != nil {
		return _ggfdd
	}
	if _cbcgc.Progress != nil {
		if _fdge := _cbcgc.Progress.ValidateWithPath(path + "\u002fProgress"); _fdge != nil {
			return _fdge
		}
	}
	return nil
}
func (_geff *ST_TransitionCornerDirectionType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_geff = 0
	case "lu":
		*_geff = 1
	case "ru":
		*_geff = 2
	case "ld":
		*_geff = 3
	case "rd":
		*_geff = 4
	}
	return nil
}

// ValidateWithPath validates the CT_Rel and its children, prefixing error messages with path
func (_ccdcb *CT_Rel) ValidateWithPath(path string) error { return nil }
func (_egee *ST_TLTimeNodeType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_egee = 0
	case "clickEffect":
		*_egee = 1
	case "withEffect":
		*_egee = 2
	case "afterEffect":
		*_egee = 3
	case "mainSeq":
		*_egee = 4
	case "interactiveSeq":
		*_egee = 5
	case "clickPar":
		*_egee = 6
	case "withGroup":
		*_egee = 7
	case "afterGroup":
		*_egee = 8
	case "tmRoot":
		*_egee = 9
	}
	return nil
}
func NewCT_Guide() *CT_Guide { _gbbf := &CT_Guide{}; return _gbbf }
func (_bcec *CT_TLTimeNodeExclusive) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_bcec.CTn = NewCT_TLCommonTimeNodeData()
_ffdge:
	for {
		_caed, _dgfea := d.Token()
		if _dgfea != nil {
			return _dgfea
		}
		switch _dcdgb := _caed.(type) {
		case _e.StartElement:
			switch _dcdgb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cTn"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cTn"}:
				if _gfbgb := d.DecodeElement(_bcec.CTn, &_dcdgb); _gfbgb != nil {
					return _gfbgb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLTimeNodeExclusive\u0020\u0025v", _dcdgb.Name)
				if _fbgff := d.Skip(); _fbgff != nil {
					return _fbgff
				}
			}
		case _e.EndElement:
			break _ffdge
		case _e.CharData:
		}
	}
	return nil
}
func (_dgdag ST_TLParaBuildType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_bfaege := _e.Attr{}
	_bfaege.Name = name
	switch _dgdag {
	case ST_TLParaBuildTypeUnset:
		_bfaege.Value = ""
	case ST_TLParaBuildTypeAllAtOnce:
		_bfaege.Value = "allAtOnce"
	case ST_TLParaBuildTypeP:
		_bfaege.Value = "p"
	case ST_TLParaBuildTypeCust:
		_bfaege.Value = "cust"
	case ST_TLParaBuildTypeWhole:
		_bfaege.Value = "whole"
	}
	return _bfaege, nil
}
func (_efega *CT_TLTemplateList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_gabbc:
	for {
		_ceaab, _gagf := d.Token()
		if _gagf != nil {
			return _gagf
		}
		switch _acgd := _ceaab.(type) {
		case _e.StartElement:
			switch _acgd.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tmpl"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tmpl"}:
				_gdeaf := NewCT_TLTemplate()
				if _fefc := d.DecodeElement(_gdeaf, &_acgd); _fefc != nil {
					return _fefc
				}
				_efega.Tmpl = append(_efega.Tmpl, _gdeaf)
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_TLTemplateList\u0020\u0025v", _acgd.Name)
				if _cgbf := d.Skip(); _cgbf != nil {
					return _cgbf
				}
			}
		case _e.EndElement:
			break _gabbc
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_TLByHslColorTransform and its children
func (_gccge *CT_TLByHslColorTransform) Validate() error {
	return _gccge.ValidateWithPath("CT_TLByHslColorTransform")
}
func (_facb *CT_SlideViewProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_facb.CSldViewPr = NewCT_CommonSlideViewProperties()
_dgea:
	for {
		_bfba, _efcf := d.Token()
		if _efcf != nil {
			return _efcf
		}
		switch _ggbd := _bfba.(type) {
		case _e.StartElement:
			switch _ggbd.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSldViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSldViewPr"}:
				if _cceaea := d.DecodeElement(_facb.CSldViewPr, &_ggbd); _cceaea != nil {
					return _cceaea
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_facb.ExtLst = NewCT_ExtensionList()
				if _ccbg := d.DecodeElement(_facb.ExtLst, &_ggbd); _ccbg != nil {
					return _ccbg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SlideViewProperties\u0020\u0025v", _ggbd.Name)
				if _dabd := d.Skip(); _dabd != nil {
					return _dabd
				}
			}
		case _e.EndElement:
			break _dgea
		case _e.CharData:
		}
	}
	return nil
}
func (_eggbc ST_ViewType) String() string {
	switch _eggbc {
	case 0:
		return ""
	case 1:
		return "sldView"
	case 2:
		return "sldMasterView"
	case 3:
		return "notesView"
	case 4:
		return "handoutView"
	case 5:
		return "notesMasterView"
	case 6:
		return "outlineView"
	case 7:
		return "sldSorterView"
	case 8:
		return "sldThumbnailView"
	}
	return ""
}
func (_babff *ST_TLOleChartBuildType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_acgfd, _bbcag := d.Token()
	if _bbcag != nil {
		return _bbcag
	}
	if _bbecd, _edaf := _acgfd.(_e.EndElement); _edaf && _bbecd.Name == start.Name {
		*_babff = 1
		return nil
	}
	if _debb, _cabbb := _acgfd.(_e.CharData); !_cabbb {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _acgfd)
	} else {
		switch string(_debb) {
		case "":
			*_babff = 0
		case "allAtOnce":
			*_babff = 1
		case "series":
			*_babff = 2
		case "category":
			*_babff = 3
		case "seriesEl":
			*_babff = 4
		case "categoryEl":
			*_babff = 5
		}
	}
	_acgfd, _bbcag = d.Token()
	if _bbcag != nil {
		return _bbcag
	}
	if _eaacc, _ebdeb := _acgfd.(_e.EndElement); _ebdeb && _eaacc.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _acgfd)
}
func (_acede ST_TLAnimateColorSpace) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_dcdga := _e.Attr{}
	_dcdga.Name = name
	switch _acede {
	case ST_TLAnimateColorSpaceUnset:
		_dcdga.Value = ""
	case ST_TLAnimateColorSpaceRgb:
		_dcdga.Value = "rgb"
	case ST_TLAnimateColorSpaceHsl:
		_dcdga.Value = "hsl"
	}
	return _dcdga, nil
}
func (_dffaa *EG_ChildSlide) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_cfede:
	for {
		_egdb, _bfeb := d.Token()
		if _bfeb != nil {
			return _bfeb
		}
		switch _fbgge := _egdb.(type) {
		case _e.StartElement:
			switch _fbgge.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMapOvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMapOvr"}:
				_dffaa.ClrMapOvr = _cb.NewCT_ColorMappingOverride()
				if _gggbe := d.DecodeElement(_dffaa.ClrMapOvr, &_fbgge); _gggbe != nil {
					return _gggbe
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020EG_ChildSlide \u0025v", _fbgge.Name)
				if _decgd := d.Skip(); _decgd != nil {
					return _decgd
				}
			}
		case _e.EndElement:
			break _cfede
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SlideIdList and its children, prefixing error messages with path
func (_dada *CT_SlideIdList) ValidateWithPath(path string) error {
	for _ggbg, _ffdb := range _dada.SldId {
		if _gcabd := _ffdb.ValidateWithPath(_c.Sprintf("\u0025s\u002fSldId\u005b\u0025d\u005d", path, _ggbg)); _gcabd != nil {
			return _gcabd
		}
	}
	return nil
}

// Validate validates the CT_NormalViewProperties and its children
func (_adcf *CT_NormalViewProperties) Validate() error {
	return _adcf.ValidateWithPath("CT_NormalViewProperties")
}

type CT_SlideLayout struct {

	// Matching Name
	MatchingNameAttr *string

	// Slide Layout Type
	TypeAttr ST_SlideLayoutType

	// Preserve Slide Layout
	PreserveAttr *bool

	// Is User Drawn
	UserDrawnAttr *bool

	// Common slide data for slide layouts
	CSld *CT_CommonSlideData

	// Color Scheme Map Override
	ClrMapOvr *_cb.CT_ColorMappingOverride

	// Slide Transition for a Slide Layout
	Transition *CT_SlideTransition

	// Slide Timing Information for a Slide Layout
	Timing *CT_SlideTiming

	// Header/Footer information for a slide layout
	Hf                   *CT_HeaderFooter
	ExtLst               *CT_ExtensionListModify
	ShowMasterSpAttr     *bool
	ShowMasterPhAnimAttr *bool
}

func (_ccbdf *EG_TopLevelSlide) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_ccbdf.ClrMap = _cb.NewCT_ColorMapping()
_fdda:
	for {
		_fedba, _gbcgg := d.Token()
		if _gbcgg != nil {
			return _gbcgg
		}
		switch _caece := _fedba.(type) {
		case _e.StartElement:
			switch _caece.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMap"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMap"}:
				if _cadf := d.DecodeElement(_ccbdf.ClrMap, &_caece); _cadf != nil {
					return _cadf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_TopLevelSlide\u0020\u0025v", _caece.Name)
				if _dagef := d.Skip(); _dagef != nil {
					return _dagef
				}
			}
		case _e.EndElement:
			break _fdda
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_NotesMaster and its children, prefixing error messages with path
func (_ecge *CT_NotesMaster) ValidateWithPath(path string) error {
	if _dfee := _ecge.CSld.ValidateWithPath(path + "\u002fCSld"); _dfee != nil {
		return _dfee
	}
	if _gbfd := _ecge.ClrMap.ValidateWithPath(path + "\u002fClrMap"); _gbfd != nil {
		return _gbfd
	}
	if _ecge.Hf != nil {
		if _eeecf := _ecge.Hf.ValidateWithPath(path + "\u002fHf"); _eeecf != nil {
			return _eeecf
		}
	}
	if _ecge.NotesStyle != nil {
		if _ggcg := _ecge.NotesStyle.ValidateWithPath(path + "/NotesStyle"); _ggcg != nil {
			return _ggcg
		}
	}
	if _ecge.ExtLst != nil {
		if _gacee := _ecge.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gacee != nil {
			return _gacee
		}
	}
	return nil
}

// Validate validates the CT_ExtensionList and its children
func (_gcaf *CT_ExtensionList) Validate() error { return _gcaf.ValidateWithPath("CT_ExtensionList") }

// Validate validates the AG_TLBuild and its children
func (_gb *AG_TLBuild) Validate() error { return _gb.ValidateWithPath("AG_TLBuild") }
func NewCT_PhotoAlbum() *CT_PhotoAlbum  { _eaag := &CT_PhotoAlbum{}; return _eaag }

// ValidateWithPath validates the OleObj and its children, prefixing error messages with path
func (_fcaa *OleObj) ValidateWithPath(path string) error {
	if _gbbga := _fcaa.CT_OleObject.ValidateWithPath(path); _gbbga != nil {
		return _gbbga
	}
	return nil
}
func (_fbcgg *TagLst) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:tagLst"
	return _fbcgg.CT_TagList.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_OutlineViewSlideList and its children, prefixing error messages with path
func (_fedbf *CT_OutlineViewSlideList) ValidateWithPath(path string) error {
	for _aae, _dbada := range _fedbf.Sld {
		if _abeab := _dbada.ValidateWithPath(_c.Sprintf("\u0025s\u002fSld\u005b\u0025d\u005d", path, _aae)); _abeab != nil {
			return _abeab
		}
	}
	return nil
}
func (_bfegb *CT_SlideLayout) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _bfegb.MatchingNameAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "matchingName"}, Value: _c.Sprintf("\u0025v", *_bfegb.MatchingNameAttr)})
	}
	if _bfegb.TypeAttr != ST_SlideLayoutTypeUnset {
		_efggfa, _dbfb := _bfegb.TypeAttr.MarshalXMLAttr(_e.Name{Local: "type"})
		if _dbfb != nil {
			return _dbfb
		}
		start.Attr = append(start.Attr, _efggfa)
	}
	if _bfegb.PreserveAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "preserve"}, Value: _c.Sprintf("\u0025d", _fdeab(*_bfegb.PreserveAttr))})
	}
	if _bfegb.UserDrawnAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "userDrawn"}, Value: _c.Sprintf("\u0025d", _fdeab(*_bfegb.UserDrawnAttr))})
	}
	if _bfegb.ShowMasterSpAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showMasterSp"}, Value: _c.Sprintf("\u0025d", _fdeab(*_bfegb.ShowMasterSpAttr))})
	}
	if _bfegb.ShowMasterPhAnimAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showMasterPhAnim"}, Value: _c.Sprintf("\u0025d", _fdeab(*_bfegb.ShowMasterPhAnimAttr))})
	}
	e.EncodeToken(start)
	_dcddd := _e.StartElement{Name: _e.Name{Local: "p:cSld"}}
	e.EncodeElement(_bfegb.CSld, _dcddd)
	if _bfegb.ClrMapOvr != nil {
		_cggfc := _e.StartElement{Name: _e.Name{Local: "p:clrMapOvr"}}
		e.EncodeElement(_bfegb.ClrMapOvr, _cggfc)
	}
	if _bfegb.Transition != nil {
		_eadd := _e.StartElement{Name: _e.Name{Local: "p:transition"}}
		e.EncodeElement(_bfegb.Transition, _eadd)
	}
	if _bfegb.Timing != nil {
		_aeeef := _e.StartElement{Name: _e.Name{Local: "p:timing"}}
		e.EncodeElement(_bfegb.Timing, _aeeef)
	}
	if _bfegb.Hf != nil {
		_ccaf := _e.StartElement{Name: _e.Name{Local: "p:hf"}}
		e.EncodeElement(_bfegb.Hf, _ccaf)
	}
	if _bfegb.ExtLst != nil {
		_acgbb := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_bfegb.ExtLst, _acgbb)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_TLAnimateBehavior() *CT_TLAnimateBehavior {
	_eeaad := &CT_TLAnimateBehavior{}
	_eeaad.CBhvr = NewCT_TLCommonBehaviorData()
	return _eeaad
}
func (_faeb *ST_TLAnimateBehaviorCalcMode) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dbebg, _afgg := d.Token()
	if _afgg != nil {
		return _afgg
	}
	if _deecc, _ceabc := _dbebg.(_e.EndElement); _ceabc && _deecc.Name == start.Name {
		*_faeb = 1
		return nil
	}
	if _adbfd, _gfaae := _dbebg.(_e.CharData); !_gfaae {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dbebg)
	} else {
		switch string(_adbfd) {
		case "":
			*_faeb = 0
		case "discrete":
			*_faeb = 1
		case "lin":
			*_faeb = 2
		case "fmla":
			*_faeb = 3
		}
	}
	_dbebg, _afgg = d.Token()
	if _afgg != nil {
		return _afgg
	}
	if _ecgcd, _fbdcc := _dbebg.(_e.EndElement); _fbdcc && _ecgcd.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dbebg)
}

// Validate validates the CT_EmbeddedFontList and its children
func (_ceaf *CT_EmbeddedFontList) Validate() error {
	return _ceaf.ValidateWithPath("CT_EmbeddedFontList")
}
func NewCT_TLCommandBehavior() *CT_TLCommandBehavior {
	_cbaeb := &CT_TLCommandBehavior{}
	_cbaeb.CBhvr = NewCT_TLCommonBehaviorData()
	return _cbaeb
}
func (_dffag ST_TLTimeNodeMasterRelation) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_bfeeg := _e.Attr{}
	_bfeeg.Name = name
	switch _dffag {
	case ST_TLTimeNodeMasterRelationUnset:
		_bfeeg.Value = ""
	case ST_TLTimeNodeMasterRelationSameClick:
		_bfeeg.Value = "sameClick"
	case ST_TLTimeNodeMasterRelationLastClick:
		_bfeeg.Value = "lastClick"
	case ST_TLTimeNodeMasterRelationNextClick:
		_bfeeg.Value = "nextClick"
	}
	return _bfeeg, nil
}

type ST_TLChartSubelementType byte
type CT_SmartTags struct{ IdAttr string }

// ValidateWithPath validates the SldLayout and its children, prefixing error messages with path
func (_abgdde *SldLayout) ValidateWithPath(path string) error {
	if _bbbe := _abgdde.CT_SlideLayout.ValidateWithPath(path); _bbbe != nil {
		return _bbbe
	}
	return nil
}
func (_eedfd *CT_TLBehaviorAttributeNameList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_bfcg := _e.StartElement{Name: _e.Name{Local: "p:attrName"}}
	for _, _fcfc := range _eedfd.AttrName {
		e.EncodeElement(_fcfc, _bfcg)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_TLCommonBehaviorData struct {

	// Additive
	AdditiveAttr ST_TLBehaviorAdditiveType

	// Accumulate
	AccumulateAttr ST_TLBehaviorAccumulateType

	// Transform Type
	XfrmTypeAttr ST_TLBehaviorTransformType

	// From
	FromAttr *string

	// To
	ToAttr *string

	// By
	ByAttr *string

	// Runtime Context
	RctxAttr *string

	// Override
	OverrideAttr ST_TLBehaviorOverrideType
	CTn          *CT_TLCommonTimeNodeData

	// Target Element
	TgtEl *CT_TLTimeTargetElement

	// Attribute Name List
	AttrNameLst *CT_TLBehaviorAttributeNameList
}

func (_abfdc ST_TLAnimateEffectTransition) Validate() error { return _abfdc.ValidateWithPath("") }
func (_edcf *CT_ExtensionList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _edcf.Ext != nil {
		_ebgd := _e.StartElement{Name: _e.Name{Local: "p:ext"}}
		for _, _gcec := range _edcf.Ext {
			e.EncodeElement(_gcec, _ebgd)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_SlideMasterIdList() *CT_SlideMasterIdList {
	_cbeea := &CT_SlideMasterIdList{}
	return _cbeea
}
func (_ddab *CT_Empty) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for {
		_acbe, _cddg := d.Token()
		if _cddg != nil {
			return _c.Errorf("parsing\u0020CT_Empty: \u0025s", _cddg)
		}
		if _eega, _cdgb := _acbe.(_e.EndElement); _cdgb && _eega.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dedeff ST_PhotoAlbumFrameShape) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_dedeff.String(), start)
}
func (_eeggf *ST_PlaceholderType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_eeggf = 0
	case "title":
		*_eeggf = 1
	case "body":
		*_eeggf = 2
	case "ctrTitle":
		*_eeggf = 3
	case "subTitle":
		*_eeggf = 4
	case "dt":
		*_eeggf = 5
	case "sldNum":
		*_eeggf = 6
	case "ftr":
		*_eeggf = 7
	case "hdr":
		*_eeggf = 8
	case "obj":
		*_eeggf = 9
	case "chart":
		*_eeggf = 10
	case "tbl":
		*_eeggf = 11
	case "clipArt":
		*_eeggf = 12
	case "dgm":
		*_eeggf = 13
	case "media":
		*_eeggf = 14
	case "sldImg":
		*_eeggf = 15
	case "pic":
		*_eeggf = 16
	}
	return nil
}
func (_fffac *CT_TLTimeCondition) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _fdeef := range start.Attr {
		if _fdeef.Name.Local == "evt" {
			_fffac.EvtAttr.UnmarshalXMLAttr(_fdeef)
			continue
		}
		if _fdeef.Name.Local == "delay" {
			_fabff, _bffg := ParseUnionST_TLTime(_fdeef.Value)
			if _bffg != nil {
				return _bffg
			}
			_fffac.DelayAttr = &_fabff
			continue
		}
	}
_edfa:
	for {
		_egcg, _fbgac := d.Token()
		if _fbgac != nil {
			return _fbgac
		}
		switch _ageb := _egcg.(type) {
		case _e.StartElement:
			switch _ageb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tgtEl"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tgtEl"}:
				_fffac.TgtEl = NewCT_TLTimeTargetElement()
				if _bffeb := d.DecodeElement(_fffac.TgtEl, &_ageb); _bffeb != nil {
					return _bffeb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tn"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tn"}:
				_fffac.Tn = NewCT_TLTriggerTimeNodeID()
				if _feefd := d.DecodeElement(_fffac.Tn, &_ageb); _feefd != nil {
					return _feefd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "rtn"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "rtn"}:
				_fffac.Rtn = NewCT_TLTriggerRuntimeNode()
				if _ddagd := d.DecodeElement(_fffac.Rtn, &_ageb); _ddagd != nil {
					return _ddagd
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_TLTimeCondition\u0020\u0025v", _ageb.Name)
				if _dbbab := d.Skip(); _dbbab != nil {
					return _dbbab
				}
			}
		case _e.EndElement:
			break _edfa
		case _e.CharData:
		}
	}
	return nil
}
func (_fdaeb ST_SlideSizeType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_fdaeb.String(), start)
}
func NewCT_TLBuildDiagram() *CT_TLBuildDiagram { _fbad := &CT_TLBuildDiagram{}; return _fbad }
func (_acdfa *CT_IndexRange) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _deafe := range start.Attr {
		if _deafe.Name.Local == "st" {
			_gfbc, _ebgeg := _b.ParseUint(_deafe.Value, 10, 32)
			if _ebgeg != nil {
				return _ebgeg
			}
			_acdfa.StAttr = uint32(_gfbc)
			continue
		}
		if _deafe.Name.Local == "end" {
			_ggdc, _bdgff := _b.ParseUint(_deafe.Value, 10, 32)
			if _bdgff != nil {
				return _bdgff
			}
			_acdfa.EndAttr = uint32(_ggdc)
			continue
		}
	}
	for {
		_begg, _edfdg := d.Token()
		if _edfdg != nil {
			return _c.Errorf("parsing\u0020CT_IndexRange:\u0020\u0025s", _edfdg)
		}
		if _afcdg, _fcd := _begg.(_e.EndElement); _fcd && _afcdg.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_TLBuildParagraph and its children
func (_gcce *CT_TLBuildParagraph) Validate() error {
	return _gcce.ValidateWithPath("CT_TLBuildParagraph")
}

type CT_HeaderFooter struct {

	// Slide Number Placeholder
	SldNumAttr *bool

	// Header Placeholder
	HdrAttr *bool

	// Footer Placeholder
	FtrAttr *bool

	// Date/Time Placeholder
	DtAttr *bool
	ExtLst *CT_ExtensionListModify
}

func (_egbca *CT_TLCommandBehavior) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _egbca.TypeAttr != ST_TLCommandTypeUnset {
		_adaff, _dbadb := _egbca.TypeAttr.MarshalXMLAttr(_e.Name{Local: "type"})
		if _dbadb != nil {
			return _dbadb
		}
		start.Attr = append(start.Attr, _adaff)
	}
	if _egbca.CmdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "cmd"}, Value: _c.Sprintf("\u0025v", *_egbca.CmdAttr)})
	}
	e.EncodeToken(start)
	_cbcfc := _e.StartElement{Name: _e.Name{Local: "p:cBhvr"}}
	e.EncodeElement(_egbca.CBhvr, _cbcfc)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_bdda *CT_TLAnimateMotionBehavior) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _bdda.OriginAttr != ST_TLAnimateMotionBehaviorOriginUnset {
		_cdgad, _bccef := _bdda.OriginAttr.MarshalXMLAttr(_e.Name{Local: "origin"})
		if _bccef != nil {
			return _bccef
		}
		start.Attr = append(start.Attr, _cdgad)
	}
	if _bdda.PathAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "path"}, Value: _c.Sprintf("\u0025v", *_bdda.PathAttr)})
	}
	if _bdda.PathEditModeAttr != ST_TLAnimateMotionPathEditModeUnset {
		_aaea, _aeef := _bdda.PathEditModeAttr.MarshalXMLAttr(_e.Name{Local: "pathEditMode"})
		if _aeef != nil {
			return _aeef
		}
		start.Attr = append(start.Attr, _aaea)
	}
	if _bdda.RAngAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "rAng"}, Value: _c.Sprintf("\u0025v", *_bdda.RAngAttr)})
	}
	if _bdda.PtsTypesAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "ptsTypes"}, Value: _c.Sprintf("\u0025v", *_bdda.PtsTypesAttr)})
	}
	e.EncodeToken(start)
	_ebfbb := _e.StartElement{Name: _e.Name{Local: "p:cBhvr"}}
	e.EncodeElement(_bdda.CBhvr, _ebfbb)
	if _bdda.By != nil {
		_efbb := _e.StartElement{Name: _e.Name{Local: "p:by"}}
		e.EncodeElement(_bdda.By, _efbb)
	}
	if _bdda.From != nil {
		_feggc := _e.StartElement{Name: _e.Name{Local: "p:from"}}
		e.EncodeElement(_bdda.From, _feggc)
	}
	if _bdda.To != nil {
		_geae := _e.StartElement{Name: _e.Name{Local: "p:to"}}
		e.EncodeElement(_bdda.To, _geae)
	}
	if _bdda.RCtr != nil {
		_dbafg := _e.StartElement{Name: _e.Name{Local: "p:rCtr"}}
		e.EncodeElement(_bdda.RCtr, _dbafg)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Guide and its children, prefixing error messages with path
func (_faab *CT_Guide) ValidateWithPath(path string) error {
	if _adde := _faab.OrientAttr.ValidateWithPath(path + "/OrientAttr"); _adde != nil {
		return _adde
	}
	if _faab.PosAttr != nil {
		if _dbed := _faab.PosAttr.ValidateWithPath(path + "\u002fPosAttr"); _dbed != nil {
			return _dbed
		}
	}
	return nil
}
func (_aagf *CT_TLGraphicalObjectBuild) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _egbaa := range start.Attr {
		if _egbaa.Name.Local == "spid" {
			_bdecb, _bdgdee := _b.ParseUint(_egbaa.Value, 10, 32)
			if _bdgdee != nil {
				return _bdgdee
			}
			_ddbb := uint32(_bdecb)
			_aagf.SpidAttr = &_ddbb
			continue
		}
		if _egbaa.Name.Local == "grpId" {
			_gagd, _beceg := _b.ParseUint(_egbaa.Value, 10, 32)
			if _beceg != nil {
				return _beceg
			}
			_gcfbb := uint32(_gagd)
			_aagf.GrpIdAttr = &_gcfbb
			continue
		}
		if _egbaa.Name.Local == "uiExpand" {
			_dccb, _cffbdc := _b.ParseBool(_egbaa.Value)
			if _cffbdc != nil {
				return _cffbdc
			}
			_aagf.UiExpandAttr = &_dccb
			continue
		}
	}
_ffaag:
	for {
		_facc, _fgbea := d.Token()
		if _fgbea != nil {
			return _fgbea
		}
		switch _bbde := _facc.(type) {
		case _e.StartElement:
			switch _bbde.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bldAsOne"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bldAsOne"}:
				_aagf.BldAsOne = NewCT_Empty()
				if _cafcg := d.DecodeElement(_aagf.BldAsOne, &_bbde); _cafcg != nil {
					return _cafcg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bldSub"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bldSub"}:
				_aagf.BldSub = _cb.NewCT_AnimationGraphicalObjectBuildProperties()
				if _dggd := d.DecodeElement(_aagf.BldSub, &_bbde); _dggd != nil {
					return _dggd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLGraphicalObjectBuild\u0020\u0025v", _bbde.Name)
				if _aceaa := d.Skip(); _aceaa != nil {
					return _aceaa
				}
			}
		case _e.EndElement:
			break _ffaag
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_OptionalBlackTransition and its children, prefixing error messages with path
func (_eeeb *CT_OptionalBlackTransition) ValidateWithPath(path string) error { return nil }

type CT_Picture struct {

	// Non-Visual Properties for a Picture
	NvPicPr *CT_PictureNonVisual

	// Picture Fill
	BlipFill *_cb.CT_BlipFillProperties
	SpPr     *_cb.CT_ShapeProperties
	Style    *_cb.CT_ShapeStyle
	ExtLst   *CT_ExtensionListModify
}

func (_dadgd *CT_TLCommonTimeNodeData) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _ffcdfb := range start.Attr {
		if _ffcdfb.Name.Local == "tmFilter" {
			_abaae, _fedfd := _ffcdfb.Value, error(nil)
			if _fedfd != nil {
				return _fedfd
			}
			_dadgd.TmFilterAttr = &_abaae
			continue
		}
		if _ffcdfb.Name.Local == "evtFilter" {
			_caef, _accag := _ffcdfb.Value, error(nil)
			if _accag != nil {
				return _accag
			}
			_dadgd.EvtFilterAttr = &_caef
			continue
		}
		if _ffcdfb.Name.Local == "presetID" {
			_bgca, _ggbcf := _b.ParseInt(_ffcdfb.Value, 10, 32)
			if _ggbcf != nil {
				return _ggbcf
			}
			_bbdba := int32(_bgca)
			_dadgd.PresetIDAttr = &_bbdba
			continue
		}
		if _ffcdfb.Name.Local == "display" {
			_aaed, _bedgd := _b.ParseBool(_ffcdfb.Value)
			if _bedgd != nil {
				return _bedgd
			}
			_dadgd.DisplayAttr = &_aaed
			continue
		}
		if _ffcdfb.Name.Local == "presetSubtype" {
			_gacfc, _fffe := _b.ParseInt(_ffcdfb.Value, 10, 32)
			if _fffe != nil {
				return _fffe
			}
			_aegd := int32(_gacfc)
			_dadgd.PresetSubtypeAttr = &_aegd
			continue
		}
		if _ffcdfb.Name.Local == "masterRel" {
			_dadgd.MasterRelAttr.UnmarshalXMLAttr(_ffcdfb)
			continue
		}
		if _ffcdfb.Name.Local == "repeatCount" {
			_edgge, _bgdbb := ParseUnionST_TLTime(_ffcdfb.Value)
			if _bgdbb != nil {
				return _bgdbb
			}
			_dadgd.RepeatCountAttr = &_edgge
			continue
		}
		if _ffcdfb.Name.Local == "bldLvl" {
			_dcggb, _bdeae := _b.ParseInt(_ffcdfb.Value, 10, 32)
			if _bdeae != nil {
				return _bdeae
			}
			_aggff := int32(_dcggb)
			_dadgd.BldLvlAttr = &_aggff
			continue
		}
		if _ffcdfb.Name.Local == "spd" {
			_fdde, _adbbc := ParseUnionST_Percentage(_ffcdfb.Value)
			if _adbbc != nil {
				return _adbbc
			}
			_dadgd.SpdAttr = &_fdde
			continue
		}
		if _ffcdfb.Name.Local == "grpId" {
			_cdeadd, _gagg := _b.ParseUint(_ffcdfb.Value, 10, 32)
			if _gagg != nil {
				return _gagg
			}
			_egbad := uint32(_cdeadd)
			_dadgd.GrpIdAttr = &_egbad
			continue
		}
		if _ffcdfb.Name.Local == "afterEffect" {
			_bcgfe, _befc := _b.ParseBool(_ffcdfb.Value)
			if _befc != nil {
				return _befc
			}
			_dadgd.AfterEffectAttr = &_bcgfe
			continue
		}
		if _ffcdfb.Name.Local == "id" {
			_efadb, _cegb := _b.ParseUint(_ffcdfb.Value, 10, 32)
			if _cegb != nil {
				return _cegb
			}
			_ddbfa := uint32(_efadb)
			_dadgd.IdAttr = &_ddbfa
			continue
		}
		if _ffcdfb.Name.Local == "nodePh" {
			_cfbga, _bafcb := _b.ParseBool(_ffcdfb.Value)
			if _bafcb != nil {
				return _bafcb
			}
			_dadgd.NodePhAttr = &_cfbga
			continue
		}
		if _ffcdfb.Name.Local == "accel" {
			_bdeba, _dccgg := ParseUnionST_PositiveFixedPercentage(_ffcdfb.Value)
			if _dccgg != nil {
				return _dccgg
			}
			_dadgd.AccelAttr = &_bdeba
			continue
		}
		if _ffcdfb.Name.Local == "decel" {
			_edbcd, _deaag := ParseUnionST_PositiveFixedPercentage(_ffcdfb.Value)
			if _deaag != nil {
				return _deaag
			}
			_dadgd.DecelAttr = &_edbcd
			continue
		}
		if _ffcdfb.Name.Local == "restart" {
			_dadgd.RestartAttr.UnmarshalXMLAttr(_ffcdfb)
			continue
		}
		if _ffcdfb.Name.Local == "nodeType" {
			_dadgd.NodeTypeAttr.UnmarshalXMLAttr(_ffcdfb)
			continue
		}
		if _ffcdfb.Name.Local == "presetClass" {
			_dadgd.PresetClassAttr.UnmarshalXMLAttr(_ffcdfb)
			continue
		}
		if _ffcdfb.Name.Local == "repeatDur" {
			_cegbd, _dggg := ParseUnionST_TLTime(_ffcdfb.Value)
			if _dggg != nil {
				return _dggg
			}
			_dadgd.RepeatDurAttr = &_cegbd
			continue
		}
		if _ffcdfb.Name.Local == "syncBehavior" {
			_dadgd.SyncBehaviorAttr.UnmarshalXMLAttr(_ffcdfb)
			continue
		}
		if _ffcdfb.Name.Local == "autoRev" {
			_efddb, _defg := _b.ParseBool(_ffcdfb.Value)
			if _defg != nil {
				return _defg
			}
			_dadgd.AutoRevAttr = &_efddb
			continue
		}
		if _ffcdfb.Name.Local == "fill" {
			_dadgd.FillAttr.UnmarshalXMLAttr(_ffcdfb)
			continue
		}
		if _ffcdfb.Name.Local == "dur" {
			_cbcbc, _dagbb := ParseUnionST_TLTime(_ffcdfb.Value)
			if _dagbb != nil {
				return _dagbb
			}
			_dadgd.DurAttr = &_cbcbc
			continue
		}
	}
_gegfe:
	for {
		_eeag, _ddfe := d.Token()
		if _ddfe != nil {
			return _ddfe
		}
		switch _fggg := _eeag.(type) {
		case _e.StartElement:
			switch _fggg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "stCondLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "stCondLst"}:
				_dadgd.StCondLst = NewCT_TLTimeConditionList()
				if _dcdaa := d.DecodeElement(_dadgd.StCondLst, &_fggg); _dcdaa != nil {
					return _dcdaa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "endCondLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "endCondLst"}:
				_dadgd.EndCondLst = NewCT_TLTimeConditionList()
				if _bffae := d.DecodeElement(_dadgd.EndCondLst, &_fggg); _bffae != nil {
					return _bffae
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "endSync"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "endSync"}:
				_dadgd.EndSync = NewCT_TLTimeCondition()
				if _gcge := d.DecodeElement(_dadgd.EndSync, &_fggg); _gcge != nil {
					return _gcge
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "iterate"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "iterate"}:
				_dadgd.Iterate = NewCT_TLIterateData()
				if _ccfae := d.DecodeElement(_dadgd.Iterate, &_fggg); _ccfae != nil {
					return _ccfae
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "childTnLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "childTnLst"}:
				_dadgd.ChildTnLst = NewCT_TimeNodeList()
				if _cagbd := d.DecodeElement(_dadgd.ChildTnLst, &_fggg); _cagbd != nil {
					return _cagbd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "subTnLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "subTnLst"}:
				_dadgd.SubTnLst = NewCT_TimeNodeList()
				if _dbgc := d.DecodeElement(_dadgd.SubTnLst, &_fggg); _dbgc != nil {
					return _dbgc
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_TLCommonTimeNodeData \u0025v", _fggg.Name)
				if _bbcgfc := d.Skip(); _bbcgfc != nil {
					return _bbcgfc
				}
			}
		case _e.EndElement:
			break _gegfe
		case _e.CharData:
		}
	}
	return nil
}
func (_abddd *CT_CommonSlideData) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_abddd.SpTree = NewCT_GroupShape()
	for _, _dba := range start.Attr {
		if _dba.Name.Local == "name" {
			_eaab, _ecb := _dba.Value, error(nil)
			if _ecb != nil {
				return _ecb
			}
			_abddd.NameAttr = &_eaab
			continue
		}
	}
_gdf:
	for {
		_dcd, _bfaf := d.Token()
		if _bfaf != nil {
			return _bfaf
		}
		switch _aee := _dcd.(type) {
		case _e.StartElement:
			switch _aee.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bg"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bg"}:
				_abddd.Bg = NewCT_Background()
				if _dfba := d.DecodeElement(_abddd.Bg, &_aee); _dfba != nil {
					return _dfba
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "spTree"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "spTree"}:
				if _bgb := d.DecodeElement(_abddd.SpTree, &_aee); _bgb != nil {
					return _bgb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "custDataLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "custDataLst"}:
				_abddd.CustDataLst = NewCT_CustomerDataList()
				if _gea := d.DecodeElement(_abddd.CustDataLst, &_aee); _gea != nil {
					return _gea
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "controls"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "controls"}:
				_abddd.Controls = NewCT_ControlList()
				if _cffc := d.DecodeElement(_abddd.Controls, &_aee); _cffc != nil {
					return _cffc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_abddd.ExtLst = NewCT_ExtensionList()
				if _accd := d.DecodeElement(_abddd.ExtLst, &_aee); _accd != nil {
					return _accd
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_CommonSlideData\u0020\u0025v", _aee.Name)
				if _efd := d.Skip(); _efd != nil {
					return _efd
				}
			}
		case _e.EndElement:
			break _gdf
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_EmbeddedFontDataId and its children
func (_cega *CT_EmbeddedFontDataId) Validate() error {
	return _cega.ValidateWithPath("CT_EmbeddedFontDataId")
}
func (_babe *CT_TLAnimateColorBehavior) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _babe.ClrSpcAttr != ST_TLAnimateColorSpaceUnset {
		_geba, _ccdca := _babe.ClrSpcAttr.MarshalXMLAttr(_e.Name{Local: "clrSpc"})
		if _ccdca != nil {
			return _ccdca
		}
		start.Attr = append(start.Attr, _geba)
	}
	if _babe.DirAttr != ST_TLAnimateColorDirectionUnset {
		_dbba, _gacb := _babe.DirAttr.MarshalXMLAttr(_e.Name{Local: "dir"})
		if _gacb != nil {
			return _gacb
		}
		start.Attr = append(start.Attr, _dbba)
	}
	e.EncodeToken(start)
	_gdgg := _e.StartElement{Name: _e.Name{Local: "p:cBhvr"}}
	e.EncodeElement(_babe.CBhvr, _gdgg)
	if _babe.By != nil {
		_deccc := _e.StartElement{Name: _e.Name{Local: "p:by"}}
		e.EncodeElement(_babe.By, _deccc)
	}
	if _babe.From != nil {
		_dagga := _e.StartElement{Name: _e.Name{Local: "p:from"}}
		e.EncodeElement(_babe.From, _dagga)
	}
	if _babe.To != nil {
		_bbeee := _e.StartElement{Name: _e.Name{Local: "p:to"}}
		e.EncodeElement(_babe.To, _bbeee)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_InOutTransition and its children
func (_ebe *CT_InOutTransition) Validate() error { return _ebe.ValidateWithPath("CT_InOutTransition") }
func (_aabb *CT_TransitionStartSoundAction) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_aabb.Snd = _cb.NewCT_EmbeddedWAVAudioFile()
	for _, _gcba := range start.Attr {
		if _gcba.Name.Local == "loop" {
			_fcgcd, _eaca := _b.ParseBool(_gcba.Value)
			if _eaca != nil {
				return _eaca
			}
			_aabb.LoopAttr = &_fcgcd
			continue
		}
	}
_eacce:
	for {
		_cdaaa, _baebcb := d.Token()
		if _baebcb != nil {
			return _baebcb
		}
		switch _gbfg := _cdaaa.(type) {
		case _e.StartElement:
			switch _gbfg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "snd"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "snd"}:
				if _fecfa := d.DecodeElement(_aabb.Snd, &_gbfg); _fecfa != nil {
					return _fecfa
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_TransitionStartSoundAction\u0020%v", _gbfg.Name)
				if _dgefgg := d.Skip(); _dgefgg != nil {
					return _dgefgg
				}
			}
		case _e.EndElement:
			break _eacce
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_HandoutMaster and its children, prefixing error messages with path
func (_efaf *CT_HandoutMaster) ValidateWithPath(path string) error {
	if _dbeg := _efaf.CSld.ValidateWithPath(path + "\u002fCSld"); _dbeg != nil {
		return _dbeg
	}
	if _afab := _efaf.ClrMap.ValidateWithPath(path + "\u002fClrMap"); _afab != nil {
		return _afab
	}
	if _efaf.Hf != nil {
		if _fbfa := _efaf.Hf.ValidateWithPath(path + "\u002fHf"); _fbfa != nil {
			return _fbfa
		}
	}
	if _efaf.ExtLst != nil {
		if _acea := _efaf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _acea != nil {
			return _acea
		}
	}
	return nil
}

type ST_IterateType byte

func (_dbaa *CT_SlideTransitionChoice) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_gefcd:
	for {
		_cgacbg, _efdfe := d.Token()
		if _efdfe != nil {
			return _efdfe
		}
		switch _fcaga := _cgacbg.(type) {
		case _e.StartElement:
			switch _fcaga.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "blinds"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "blinds"}:
				_dbaa.Blinds = NewCT_OrientationTransition()
				if _egfgd := d.DecodeElement(_dbaa.Blinds, &_fcaga); _egfgd != nil {
					return _egfgd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "checker"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "checker"}:
				_dbaa.Checker = NewCT_OrientationTransition()
				if _fabcd := d.DecodeElement(_dbaa.Checker, &_fcaga); _fabcd != nil {
					return _fabcd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "circle"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "circle"}:
				_dbaa.Circle = NewCT_Empty()
				if _egfb := d.DecodeElement(_dbaa.Circle, &_fcaga); _egfb != nil {
					return _egfb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "dissolve"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "dissolve"}:
				_dbaa.Dissolve = NewCT_Empty()
				if _bfded := d.DecodeElement(_dbaa.Dissolve, &_fcaga); _bfded != nil {
					return _bfded
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "comb"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "comb"}:
				_dbaa.Comb = NewCT_OrientationTransition()
				if _effe := d.DecodeElement(_dbaa.Comb, &_fcaga); _effe != nil {
					return _effe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cover"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cover"}:
				_dbaa.Cover = NewCT_EightDirectionTransition()
				if _bdbg := d.DecodeElement(_dbaa.Cover, &_fcaga); _bdbg != nil {
					return _bdbg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cut"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cut"}:
				_dbaa.Cut = NewCT_OptionalBlackTransition()
				if _cegc := d.DecodeElement(_dbaa.Cut, &_fcaga); _cegc != nil {
					return _cegc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "diamond"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "diamond"}:
				_dbaa.Diamond = NewCT_Empty()
				if _cdda := d.DecodeElement(_dbaa.Diamond, &_fcaga); _cdda != nil {
					return _cdda
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "fade"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "fade"}:
				_dbaa.Fade = NewCT_OptionalBlackTransition()
				if _bbge := d.DecodeElement(_dbaa.Fade, &_fcaga); _bbge != nil {
					return _bbge
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "newsflash"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "newsflash"}:
				_dbaa.Newsflash = NewCT_Empty()
				if _bdff := d.DecodeElement(_dbaa.Newsflash, &_fcaga); _bdff != nil {
					return _bdff
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "plus"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "plus"}:
				_dbaa.Plus = NewCT_Empty()
				if _gfge := d.DecodeElement(_dbaa.Plus, &_fcaga); _gfge != nil {
					return _gfge
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "pull"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "pull"}:
				_dbaa.Pull = NewCT_EightDirectionTransition()
				if _edac := d.DecodeElement(_dbaa.Pull, &_fcaga); _edac != nil {
					return _edac
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "push"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "push"}:
				_dbaa.Push = NewCT_SideDirectionTransition()
				if _ceabe := d.DecodeElement(_dbaa.Push, &_fcaga); _ceabe != nil {
					return _ceabe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "random"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "random"}:
				_dbaa.Random = NewCT_Empty()
				if _acdfc := d.DecodeElement(_dbaa.Random, &_fcaga); _acdfc != nil {
					return _acdfc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "randomBar"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "randomBar"}:
				_dbaa.RandomBar = NewCT_OrientationTransition()
				if _cgaa := d.DecodeElement(_dbaa.RandomBar, &_fcaga); _cgaa != nil {
					return _cgaa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "split"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "split"}:
				_dbaa.Split = NewCT_SplitTransition()
				if _gdcef := d.DecodeElement(_dbaa.Split, &_fcaga); _gdcef != nil {
					return _gdcef
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "strips"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "strips"}:
				_dbaa.Strips = NewCT_CornerDirectionTransition()
				if _gbge := d.DecodeElement(_dbaa.Strips, &_fcaga); _gbge != nil {
					return _gbge
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "wedge"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "wedge"}:
				_dbaa.Wedge = NewCT_Empty()
				if _eagc := d.DecodeElement(_dbaa.Wedge, &_fcaga); _eagc != nil {
					return _eagc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "wheel"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "wheel"}:
				_dbaa.Wheel = NewCT_WheelTransition()
				if _bdad := d.DecodeElement(_dbaa.Wheel, &_fcaga); _bdad != nil {
					return _bdad
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "wipe"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "wipe"}:
				_dbaa.Wipe = NewCT_SideDirectionTransition()
				if _bgddd := d.DecodeElement(_dbaa.Wipe, &_fcaga); _bgddd != nil {
					return _bgddd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "zoom"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "zoom"}:
				_dbaa.Zoom = NewCT_InOutTransition()
				if _afaf := d.DecodeElement(_dbaa.Zoom, &_fcaga); _afaf != nil {
					return _afaf
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_SlideTransitionChoice\u0020%v", _fcaga.Name)
				if _adgf := d.Skip(); _adgf != nil {
					return _adgf
				}
			}
		case _e.EndElement:
			break _gefcd
		case _e.CharData:
		}
	}
	return nil
}

const (
	ST_TLTriggerRuntimeNodeUnset ST_TLTriggerRuntimeNode = 0
	ST_TLTriggerRuntimeNodeFirst ST_TLTriggerRuntimeNode = 1
	ST_TLTriggerRuntimeNodeLast  ST_TLTriggerRuntimeNode = 2
	ST_TLTriggerRuntimeNodeAll   ST_TLTriggerRuntimeNode = 3
)

func (_dgdb *CT_EightDirectionTransition) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _dgdb.DirAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "dir"}, Value: _c.Sprintf("\u0025v", *_dgdb.DirAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_TLPoint() *CT_TLPoint { _cdaed := &CT_TLPoint{}; return _cdaed }

type CT_TLTimeAnimateValue struct {

	// Time
	TmAttr *ST_TLTimeAnimateValueTime

	// Formula
	FmlaAttr *string

	// Value
	Val *CT_TLAnimVariant
}

func (_dfe *CT_CustomerDataList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_cdgfa:
	for {
		_dbc, _bbd := d.Token()
		if _bbd != nil {
			return _bbd
		}
		switch _agbe := _dbc.(type) {
		case _e.StartElement:
			switch _agbe.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "custData"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "custData"}:
				_def := NewCT_CustomerData()
				if _fced := d.DecodeElement(_def, &_agbe); _fced != nil {
					return _fced
				}
				_dfe.CustData = append(_dfe.CustData, _def)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tags"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tags"}:
				_dfe.Tags = NewCT_TagsData()
				if _ecce := d.DecodeElement(_dfe.Tags, &_agbe); _ecce != nil {
					return _ecce
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CustomerDataList\u0020\u0025v", _agbe.Name)
				if _abgd := d.Skip(); _abgd != nil {
					return _abgd
				}
			}
		case _e.EndElement:
			break _cdgfa
		case _e.CharData:
		}
	}
	return nil
}
func (_egccb *ST_PrintColorMode) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_egccb = 0
	case "bw":
		*_egccb = 1
	case "gray":
		*_egccb = 2
	case "clr":
		*_egccb = 3
	}
	return nil
}
func (_edfd *CT_HtmlPublishProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _edfd.ShowSpeakerNotesAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showSpeakerNotes"}, Value: _c.Sprintf("\u0025d", _fdeab(*_edfd.ShowSpeakerNotesAttr))})
	}
	if _edfd.TargetAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "target"}, Value: _c.Sprintf("\u0025v", *_edfd.TargetAttr)})
	}
	if _edfd.TitleAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "title"}, Value: _c.Sprintf("\u0025v", *_edfd.TitleAttr)})
	}
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _edfd.IdAttr)})
	e.EncodeToken(start)
	if _edfd.SldAll != nil {
		_cfeb := _e.StartElement{Name: _e.Name{Local: "p:sldAll"}}
		e.EncodeElement(_edfd.SldAll, _cfeb)
	}
	if _edfd.SldRg != nil {
		_cgffa := _e.StartElement{Name: _e.Name{Local: "p:sldRg"}}
		e.EncodeElement(_edfd.SldRg, _cgffa)
	}
	if _edfd.CustShow != nil {
		_faecb := _e.StartElement{Name: _e.Name{Local: "p:custShow"}}
		e.EncodeElement(_edfd.CustShow, _faecb)
	}
	if _edfd.ExtLst != nil {
		_gbc := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_edfd.ExtLst, _gbc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_TimeNodeList struct {

	// Parallel Time Node
	Par []*CT_TLTimeNodeParallel

	// Sequence Time Node
	Seq []*CT_TLTimeNodeSequence

	// Exclusive
	Excl []*CT_TLTimeNodeExclusive

	// Animate
	Anim []*CT_TLAnimateBehavior

	// Animate Color Behavior
	AnimClr []*CT_TLAnimateColorBehavior

	// Animate Effect
	AnimEffect []*CT_TLAnimateEffectBehavior

	// Animate Motion
	AnimMotion []*CT_TLAnimateMotionBehavior

	// Animate Rotation
	AnimRot []*CT_TLAnimateRotationBehavior

	// Animate Scale
	AnimScale []*CT_TLAnimateScaleBehavior

	// Command
	Cmd []*CT_TLCommandBehavior

	// Set Time Node Behavior
	Set []*CT_TLSetBehavior

	// Audio
	Audio []*CT_TLMediaNodeAudio

	// Video
	Video []*CT_TLMediaNodeVideo
}

func (_efba ST_TransitionInOutDirectionType) Validate() error { return _efba.ValidateWithPath("") }
func (_acadg ST_TLTimeIndefinite) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_acadg.String(), start)
}

type EG_ChildSlide struct {

	// Color Scheme Map Override
	ClrMapOvr *_cb.CT_ColorMappingOverride
}

func NewCT_CommonSlideData() *CT_CommonSlideData {
	_fbcd := &CT_CommonSlideData{}
	_fbcd.SpTree = NewCT_GroupShape()
	return _fbcd
}
func (_ddbef *CT_TLOleBuildChart) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _aeag := range start.Attr {
		if _aeag.Name.Local == "bld" {
			_ddbef.BldAttr.UnmarshalXMLAttr(_aeag)
			continue
		}
		if _aeag.Name.Local == "animBg" {
			_ddga, _cedb := _b.ParseBool(_aeag.Value)
			if _cedb != nil {
				return _cedb
			}
			_ddbef.AnimBgAttr = &_ddga
			continue
		}
		if _aeag.Name.Local == "spid" {
			_ecbdd, _cede := _b.ParseUint(_aeag.Value, 10, 32)
			if _cede != nil {
				return _cede
			}
			_ecgde := uint32(_ecbdd)
			_ddbef.SpidAttr = &_ecgde
			continue
		}
		if _aeag.Name.Local == "grpId" {
			_cfeeb, _cgde := _b.ParseUint(_aeag.Value, 10, 32)
			if _cgde != nil {
				return _cgde
			}
			_ddcgc := uint32(_cfeeb)
			_ddbef.GrpIdAttr = &_ddcgc
			continue
		}
		if _aeag.Name.Local == "uiExpand" {
			_gbdg, _dgeaca := _b.ParseBool(_aeag.Value)
			if _dgeaca != nil {
				return _dgeaca
			}
			_ddbef.UiExpandAttr = &_gbdg
			continue
		}
	}
	for {
		_ffcge, _gebe := d.Token()
		if _gebe != nil {
			return _c.Errorf("parsing\u0020CT_TLOleBuildChart:\u0020\u0025s", _gebe)
		}
		if _ebggd, _dbgag := _ffcge.(_e.EndElement); _dbgag && _ebggd.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_PresentationProperties struct {

	// HTML Publishing Properties
	HtmlPubPr *CT_HtmlPublishProperties

	// Web Properties
	WebPr *CT_WebProperties

	// Printing Properties
	PrnPr *CT_PrintProperties

	// Presentation-wide Show Properties
	ShowPr *CT_ShowProperties

	// Color MRU
	ClrMru *_cb.CT_ColorMRU
	ExtLst *CT_ExtensionList
}

func (_gdfgea ST_ViewType) Validate() error { return _gdfgea.ValidateWithPath("") }
func NewEG_Background() *EG_Background      { _fffcd := &EG_Background{}; return _fffcd }
func (_bde *AG_Ole) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _bde.SpidAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spid"}, Value: _c.Sprintf("\u0025v", *_bde.SpidAttr)})
	}
	if _bde.NameAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "name"}, Value: _c.Sprintf("\u0025v", *_bde.NameAttr)})
	}
	if _bde.ShowAsIconAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showAsIcon"}, Value: _c.Sprintf("\u0025d", _fdeab(*_bde.ShowAsIconAttr))})
	}
	if _bde.IdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", *_bde.IdAttr)})
	}
	if _bde.ImgWAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "imgW"}, Value: _c.Sprintf("\u0025v", *_bde.ImgWAttr)})
	}
	if _bde.ImgHAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "imgH"}, Value: _c.Sprintf("\u0025v", *_bde.ImgHAttr)})
	}
	return nil
}
func NewCT_SlideViewProperties() *CT_SlideViewProperties {
	_aacg := &CT_SlideViewProperties{}
	_aacg.CSldViewPr = NewCT_CommonSlideViewProperties()
	return _aacg
}

type CT_PrintProperties struct {

	// Print Output
	PrnWhatAttr ST_PrintWhat

	// Print Color Mode
	ClrModeAttr ST_PrintColorMode

	// Print Hidden Slides
	HiddenSlidesAttr *bool

	// Scale to Fit Paper when printing
	ScaleToFitPaperAttr *bool

	// Frame slides when printing
	FrameSlidesAttr *bool
	ExtLst          *CT_ExtensionList
}

func (_aacfb *ST_TLAnimateMotionBehaviorOrigin) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_aacfb = 0
	case "parent":
		*_aacfb = 1
	case "layout":
		*_aacfb = 2
	}
	return nil
}
func (_fgege ST_TLDiagramBuildType) Validate() error { return _fgege.ValidateWithPath("") }

type CT_SlideIdList struct {

	// Slide ID
	SldId []*CT_SlideIdListEntry
}
type CT_TLAnimVariantFloatVal struct {

	// Value
	ValAttr float32
}

// ValidateWithPath validates the CT_HandoutMasterIdListEntry and its children, prefixing error messages with path
func (_gdcb *CT_HandoutMasterIdListEntry) ValidateWithPath(path string) error {
	if _gdcb.ExtLst != nil {
		if _ebge := _gdcb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ebge != nil {
			return _ebge
		}
	}
	return nil
}

type CmLst struct{ CT_CommentList }

func (_cccb *CT_HeaderFooter) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _cccb.SldNumAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "sldNum"}, Value: _c.Sprintf("\u0025d", _fdeab(*_cccb.SldNumAttr))})
	}
	if _cccb.HdrAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "hdr"}, Value: _c.Sprintf("\u0025d", _fdeab(*_cccb.HdrAttr))})
	}
	if _cccb.FtrAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "ftr"}, Value: _c.Sprintf("\u0025d", _fdeab(*_cccb.FtrAttr))})
	}
	if _cccb.DtAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "dt"}, Value: _c.Sprintf("\u0025d", _fdeab(*_cccb.DtAttr))})
	}
	e.EncodeToken(start)
	if _cccb.ExtLst != nil {
		_cbdd := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_cccb.ExtLst, _cbdd)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type ST_TLTriggerEvent byte

func (_gggedd *ST_TLBehaviorTransformType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_gggedd = 0
	case "pt":
		*_gggedd = 1
	case "img":
		*_gggedd = 2
	}
	return nil
}
func (_ceffea *ST_PrintWhat) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_ceffea = 0
	case "slides":
		*_ceffea = 1
	case "handouts1":
		*_ceffea = 2
	case "handouts2":
		*_ceffea = 3
	case "handouts3":
		*_ceffea = 4
	case "handouts4":
		*_ceffea = 5
	case "handouts6":
		*_ceffea = 6
	case "handouts9":
		*_ceffea = 7
	case "notes":
		*_ceffea = 8
	case "outline":
		*_ceffea = 9
	}
	return nil
}

// Validate validates the CT_TransitionSoundAction and its children
func (_gbaef *CT_TransitionSoundAction) Validate() error {
	return _gbaef.ValidateWithPath("CT_TransitionSoundAction")
}
func (_ffgcg *Sld) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_ffgcg.CT_Slide = *NewCT_Slide()
	for _, _afca := range start.Attr {
		if _afca.Name.Local == "show" {
			_bgedg, _adfdd := _b.ParseBool(_afca.Value)
			if _adfdd != nil {
				return _adfdd
			}
			_ffgcg.ShowAttr = &_bgedg
			continue
		}
		if _afca.Name.Local == "showMasterSp" {
			_fbfbeb, _gefed := _b.ParseBool(_afca.Value)
			if _gefed != nil {
				return _gefed
			}
			_ffgcg.ShowMasterSpAttr = &_fbfbeb
			continue
		}
		if _afca.Name.Local == "showMasterPhAnim" {
			_ddfda, _gdag := _b.ParseBool(_afca.Value)
			if _gdag != nil {
				return _gdag
			}
			_ffgcg.ShowMasterPhAnimAttr = &_ddfda
			continue
		}
	}
_dgfgf:
	for {
		_gagbf, _cdfgca := d.Token()
		if _cdfgca != nil {
			return _cdfgca
		}
		switch _cbga := _gagbf.(type) {
		case _e.StartElement:
			switch _cbga.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _cgdcg := d.DecodeElement(_ffgcg.CSld, &_cbga); _cgdcg != nil {
					return _cgdcg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMapOvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMapOvr"}:
				_ffgcg.ClrMapOvr = _cb.NewCT_ColorMappingOverride()
				if _eeeg := d.DecodeElement(_ffgcg.ClrMapOvr, &_cbga); _eeeg != nil {
					return _eeeg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "transition"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "transition"}:
				_ffgcg.Transition = NewCT_SlideTransition()
				if _eecgg := d.DecodeElement(_ffgcg.Transition, &_cbga); _eecgg != nil {
					return _eecgg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "timing"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "timing"}:
				_ffgcg.Timing = NewCT_SlideTiming()
				if _efgaf := d.DecodeElement(_ffgcg.Timing, &_cbga); _efgaf != nil {
					return _efgaf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_ffgcg.ExtLst = NewCT_ExtensionListModify()
				if _ebbdb := d.DecodeElement(_ffgcg.ExtLst, &_cbga); _ebbdb != nil {
					return _ebbdb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Sld\u0020\u0025v", _cbga.Name)
				if _eaadc := d.Skip(); _eaadc != nil {
					return _eaadc
				}
			}
		case _e.EndElement:
			break _dgfgf
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Comment and its children, prefixing error messages with path
func (_fbe *CT_Comment) ValidateWithPath(path string) error {
	if _egd := _fbe.Pos.ValidateWithPath(path + "\u002fPos"); _egd != nil {
		return _egd
	}
	if _fbe.ExtLst != nil {
		if _fcbd := _fbe.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fcbd != nil {
			return _fcbd
		}
	}
	return nil
}
func (_gddfg *ST_TLBehaviorAdditiveType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_acfad, _gddfe := d.Token()
	if _gddfe != nil {
		return _gddfe
	}
	if _dbcge, _bbfgf := _acfad.(_e.EndElement); _bbfgf && _dbcge.Name == start.Name {
		*_gddfg = 1
		return nil
	}
	if _ggdad, _ffge := _acfad.(_e.CharData); !_ffge {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _acfad)
	} else {
		switch string(_ggdad) {
		case "":
			*_gddfg = 0
		case "base":
			*_gddfg = 1
		case "sum":
			*_gddfg = 2
		case "repl":
			*_gddfg = 3
		case "mult":
			*_gddfg = 4
		case "none":
			*_gddfg = 5
		}
	}
	_acfad, _gddfe = d.Token()
	if _gddfe != nil {
		return _gddfe
	}
	if _ebffa, _gfgec := _acfad.(_e.EndElement); _gfgec && _ebffa.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _acfad)
}

// ValidateWithPath validates the CT_TLAnimateBehavior and its children, prefixing error messages with path
func (_fbcac *CT_TLAnimateBehavior) ValidateWithPath(path string) error {
	if _dbcfg := _fbcac.CalcmodeAttr.ValidateWithPath(path + "\u002fCalcmodeAttr"); _dbcfg != nil {
		return _dbcfg
	}
	if _bcbde := _fbcac.ValueTypeAttr.ValidateWithPath(path + "\u002fValueTypeAttr"); _bcbde != nil {
		return _bcbde
	}
	if _adfa := _fbcac.CBhvr.ValidateWithPath(path + "\u002fCBhvr"); _adfa != nil {
		return _adfa
	}
	if _fbcac.TavLst != nil {
		if _bagd := _fbcac.TavLst.ValidateWithPath(path + "\u002fTavLst"); _bagd != nil {
			return _bagd
		}
	}
	return nil
}
func (_gcddb ST_TLTimeAnimateValueTime) String() string {
	if _gcddb.ST_PositiveFixedPercentage != nil {
		return _gcddb.ST_PositiveFixedPercentage.String()
	}
	if _gcddb.ST_TLTimeIndefinite != ST_TLTimeIndefiniteUnset {
		return _gcddb.ST_TLTimeIndefinite.String()
	}
	return ""
}
func (_dfdg *CT_TLIterateIntervalTime) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _baceb := range start.Attr {
		if _baceb.Name.Local == "val" {
			_agff, _gecgb := ParseUnionST_TLTime(_baceb.Value)
			if _gecgb != nil {
				return _gecgb
			}
			_dfdg.ValAttr = _agff
			continue
		}
	}
	for {
		_cbdcfg, _ccgbcb := d.Token()
		if _ccgbcb != nil {
			return _c.Errorf("parsing CT_TLIterateIntervalTime:\u0020%s", _ccgbcb)
		}
		if _agbea, _cegbg := _cbdcfg.(_e.EndElement); _cegbg && _agbea.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_TLAnimateMotionBehaviorOriginUnset  ST_TLAnimateMotionBehaviorOrigin = 0
	ST_TLAnimateMotionBehaviorOriginParent ST_TLAnimateMotionBehaviorOrigin = 1
	ST_TLAnimateMotionBehaviorOriginLayout ST_TLAnimateMotionBehaviorOrigin = 2
)

func (_cfbg *CT_SmartTags) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _fbebf := range start.Attr {
		if _fbebf.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _fbebf.Name.Local == "id" || _fbebf.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _fbebf.Name.Local == "id" {
			_befd, _gbacg := _fbebf.Value, error(nil)
			if _gbacg != nil {
				return _gbacg
			}
			_cfbg.IdAttr = _befd
			continue
		}
	}
	for {
		_bdeg, _dabdb := d.Token()
		if _dabdb != nil {
			return _c.Errorf("parsing\u0020CT_SmartTags:\u0020\u0025s", _dabdb)
		}
		if _abfe, _bebbed := _bdeg.(_e.EndElement); _bebbed && _abfe.Name == start.Name {
			break
		}
	}
	return nil
}
func _fdeab(_accdg bool) uint8 {
	if _accdg {
		return 1
	}
	return 0
}
func (_fdgde *CT_TLAnimVariantIntegerVal) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "val"}, Value: _c.Sprintf("\u0025v", _fdgde.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_fbdeg ST_PhotoAlbumFrameShape) String() string {
	switch _fbdeg {
	case 0:
		return ""
	case 1:
		return "frameStyle1"
	case 2:
		return "frameStyle2"
	case 3:
		return "frameStyle3"
	case 4:
		return "frameStyle4"
	case 5:
		return "frameStyle5"
	case 6:
		return "frameStyle6"
	case 7:
		return "frameStyle7"
	}
	return ""
}
func (_gdfca *PresentationPr) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:presentationPr"
	return _gdfca.CT_PresentationProperties.MarshalXML(e, start)
}
func (_bdaa *ST_TLTriggerRuntimeNode) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_bdaa = 0
	case "first":
		*_bdaa = 1
	case "last":
		*_bdaa = 2
	case "all":
		*_bdaa = 3
	}
	return nil
}

type CT_NotesTextViewProperties struct {

	// Base properties for Notes View
	CViewPr *CT_CommonViewProperties
	ExtLst  *CT_ExtensionList
}

func NewCmAuthorLst() *CmAuthorLst {
	_afeb := &CmAuthorLst{}
	_afeb.CT_CommentAuthorList = *NewCT_CommentAuthorList()
	return _afeb
}
func NewCT_SlideMaster() *CT_SlideMaster {
	_geaga := &CT_SlideMaster{}
	_geaga.CSld = NewCT_CommonSlideData()
	_geaga.ClrMap = _cb.NewCT_ColorMapping()
	return _geaga
}
func NewCT_SlideRelationshipListEntry() *CT_SlideRelationshipListEntry {
	_ggaa := &CT_SlideRelationshipListEntry{}
	return _ggaa
}
func (_fgeeb ST_TLTimeNodeType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_ccgac := _e.Attr{}
	_ccgac.Name = name
	switch _fgeeb {
	case ST_TLTimeNodeTypeUnset:
		_ccgac.Value = ""
	case ST_TLTimeNodeTypeClickEffect:
		_ccgac.Value = "clickEffect"
	case ST_TLTimeNodeTypeWithEffect:
		_ccgac.Value = "withEffect"
	case ST_TLTimeNodeTypeAfterEffect:
		_ccgac.Value = "afterEffect"
	case ST_TLTimeNodeTypeMainSeq:
		_ccgac.Value = "mainSeq"
	case ST_TLTimeNodeTypeInteractiveSeq:
		_ccgac.Value = "interactiveSeq"
	case ST_TLTimeNodeTypeClickPar:
		_ccgac.Value = "clickPar"
	case ST_TLTimeNodeTypeWithGroup:
		_ccgac.Value = "withGroup"
	case ST_TLTimeNodeTypeAfterGroup:
		_ccgac.Value = "afterGroup"
	case ST_TLTimeNodeTypeTmRoot:
		_ccgac.Value = "tmRoot"
	}
	return _ccgac, nil
}

// ValidateWithPath validates the CT_ExtensionListModify and its children, prefixing error messages with path
func (_bfd *CT_ExtensionListModify) ValidateWithPath(path string) error {
	for _cdde, _baeb := range _bfd.Ext {
		if _dbad := _baeb.ValidateWithPath(_c.Sprintf("\u0025s\u002fExt\u005b\u0025d\u005d", path, _cdde)); _dbad != nil {
			return _dbad
		}
	}
	return nil
}

type CT_WebProperties struct {

	// Show animation in HTML output
	ShowAnimationAttr *bool

	// Resize graphics in HTML output
	ResizeGraphicsAttr *bool

	// Allow PNG in HTML output
	AllowPngAttr *bool

	// Rely on VML for HTML output
	RelyOnVmlAttr *bool

	// Organize HTML output in folders
	OrganizeInFoldersAttr *bool

	// Use long file names in HTML output
	UseLongFilenamesAttr *bool

	// Image size for HTML output
	ImgSzAttr ST_WebScreenSize

	// Encoding for HTML output
	EncodingAttr *string

	// Slide Navigation Colors for HTML output
	ClrAttr ST_WebColorType
	ExtLst  *CT_ExtensionList
}

// ValidateWithPath validates the CT_SmartTags and its children, prefixing error messages with path
func (_deba *CT_SmartTags) ValidateWithPath(path string) error { return nil }
func (_cbdf ST_WebScreenSize) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_cbdf.String(), start)
}

// ValidateWithPath validates the AG_ChildSlide and its children, prefixing error messages with path
func (_bd *AG_ChildSlide) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_OleObjectChoice and its children, prefixing error messages with path
func (_fgcc *CT_OleObjectChoice) ValidateWithPath(path string) error {
	if _fgcc.Embed != nil {
		if _bbeb := _fgcc.Embed.ValidateWithPath(path + "\u002fEmbed"); _bbeb != nil {
			return _bbeb
		}
	}
	if _fgcc.Link != nil {
		if _cceae := _fgcc.Link.ValidateWithPath(path + "\u002fLink"); _cceae != nil {
			return _cceae
		}
	}
	return nil
}

type CT_TLAnimVariantIntegerVal struct {

	// Value
	ValAttr int32
}

func (_afaed *ST_TLTimeNodeType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fbdbd, _ccdd := d.Token()
	if _ccdd != nil {
		return _ccdd
	}
	if _ecda, _cfbbg := _fbdbd.(_e.EndElement); _cfbbg && _ecda.Name == start.Name {
		*_afaed = 1
		return nil
	}
	if _becga, _agbge := _fbdbd.(_e.CharData); !_agbge {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fbdbd)
	} else {
		switch string(_becga) {
		case "":
			*_afaed = 0
		case "clickEffect":
			*_afaed = 1
		case "withEffect":
			*_afaed = 2
		case "afterEffect":
			*_afaed = 3
		case "mainSeq":
			*_afaed = 4
		case "interactiveSeq":
			*_afaed = 5
		case "clickPar":
			*_afaed = 6
		case "withGroup":
			*_afaed = 7
		case "afterGroup":
			*_afaed = 8
		case "tmRoot":
			*_afaed = 9
		}
	}
	_fbdbd, _ccdd = d.Token()
	if _ccdd != nil {
		return _ccdd
	}
	if _gaceef, _ffbac := _fbdbd.(_e.EndElement); _ffbac && _gaceef.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fbdbd)
}

type CT_TLAnimateColorBehavior struct {

	// Color Space
	ClrSpcAttr ST_TLAnimateColorSpace

	// Direction
	DirAttr ST_TLAnimateColorDirection
	CBhvr   *CT_TLCommonBehaviorData

	// By
	By *CT_TLByAnimateColorTransform

	// From
	From *_cb.CT_Color

	// To
	To *_cb.CT_Color
}

func (_gcgce ST_TLChartSubelementType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_gcgce.String(), start)
}

// ValidateWithPath validates the CT_SlideLayoutIdList and its children, prefixing error messages with path
func (_ededf *CT_SlideLayoutIdList) ValidateWithPath(path string) error {
	for _fcac, _fcdec := range _ededf.SldLayoutId {
		if _ggcda := _fcdec.ValidateWithPath(_c.Sprintf("\u0025s\u002fSldLayoutId\u005b\u0025d\u005d", path, _fcac)); _ggcda != nil {
			return _ggcda
		}
	}
	return nil
}

type CT_OleObjectChoice struct {
	Embed *CT_OleObjectEmbed
	Link  *CT_OleObjectLink
}
type ST_TLTimeNodePresetClassType byte
type CT_TLSetBehavior struct {

	// Common Behavior
	CBhvr *CT_TLCommonBehaviorData

	// To
	To *CT_TLAnimVariant
}

// ValidateWithPath validates the CT_HeaderFooter and its children, prefixing error messages with path
func (_dfgd *CT_HeaderFooter) ValidateWithPath(path string) error {
	if _dfgd.ExtLst != nil {
		if _adbc := _dfgd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _adbc != nil {
			return _adbc
		}
	}
	return nil
}
func (_gcbaa ST_TLTriggerRuntimeNode) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_ecbac := _e.Attr{}
	_ecbac.Name = name
	switch _gcbaa {
	case ST_TLTriggerRuntimeNodeUnset:
		_ecbac.Value = ""
	case ST_TLTriggerRuntimeNodeFirst:
		_ecbac.Value = "first"
	case ST_TLTriggerRuntimeNodeLast:
		_ecbac.Value = "last"
	case ST_TLTriggerRuntimeNodeAll:
		_ecbac.Value = "all"
	}
	return _ecbac, nil
}

// ValidateWithPath validates the CT_TLCommonBehaviorData and its children, prefixing error messages with path
func (_geeaf *CT_TLCommonBehaviorData) ValidateWithPath(path string) error {
	if _dadcg := _geeaf.AdditiveAttr.ValidateWithPath(path + "\u002fAdditiveAttr"); _dadcg != nil {
		return _dadcg
	}
	if _gdba := _geeaf.AccumulateAttr.ValidateWithPath(path + "\u002fAccumulateAttr"); _gdba != nil {
		return _gdba
	}
	if _cbdca := _geeaf.XfrmTypeAttr.ValidateWithPath(path + "\u002fXfrmTypeAttr"); _cbdca != nil {
		return _cbdca
	}
	if _bffbf := _geeaf.OverrideAttr.ValidateWithPath(path + "\u002fOverrideAttr"); _bffbf != nil {
		return _bffbf
	}
	if _agegb := _geeaf.CTn.ValidateWithPath(path + "\u002fCTn"); _agegb != nil {
		return _agegb
	}
	if _edbgd := _geeaf.TgtEl.ValidateWithPath(path + "\u002fTgtEl"); _edbgd != nil {
		return _edbgd
	}
	if _geeaf.AttrNameLst != nil {
		if _fddf := _geeaf.AttrNameLst.ValidateWithPath(path + "\u002fAttrNameLst"); _fddf != nil {
			return _fddf
		}
	}
	return nil
}

// Validate validates the CT_SlideMasterIdList and its children
func (_ddbdg *CT_SlideMasterIdList) Validate() error {
	return _ddbdg.ValidateWithPath("CT_SlideMasterIdList")
}

type CT_GroupShapeChoice struct {
	Sp           []*CT_Shape
	GrpSp        []*CT_GroupShape
	GraphicFrame []*CT_GraphicalObjectFrame
	CxnSp        []*CT_Connector
	Pic          []*CT_Picture
	ContentPart  []*CT_Rel
}

// Validate validates the CT_WheelTransition and its children
func (_deedg *CT_WheelTransition) Validate() error {
	return _deedg.ValidateWithPath("CT_WheelTransition")
}
func (_gdef *Presentation) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:presentation"
	return _gdef.CT_Presentation.MarshalXML(e, start)
}

type CmAuthorLst struct{ CT_CommentAuthorList }

func (_eeee *CT_NotesViewProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_eeee.CSldViewPr = NewCT_CommonSlideViewProperties()
_efdf:
	for {
		_gddf, _fadf := d.Token()
		if _fadf != nil {
			return _fadf
		}
		switch _ggged := _gddf.(type) {
		case _e.StartElement:
			switch _ggged.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSldViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSldViewPr"}:
				if _eecf := d.DecodeElement(_eeee.CSldViewPr, &_ggged); _eecf != nil {
					return _eecf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_eeee.ExtLst = NewCT_ExtensionList()
				if _edgc := d.DecodeElement(_eeee.ExtLst, &_ggged); _edgc != nil {
					return _edgc
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_NotesViewProperties\u0020\u0025v", _ggged.Name)
				if _ggfb := d.Skip(); _ggfb != nil {
					return _ggfb
				}
			}
		case _e.EndElement:
			break _efdf
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_ApplicationNonVisualDrawingProps and its children
func (_dd *CT_ApplicationNonVisualDrawingProps) Validate() error {
	return _dd.ValidateWithPath("CT_ApplicationNonVisualDrawingProps")
}

// ValidateWithPath validates the CT_ConnectorNonVisual and its children, prefixing error messages with path
func (_fbae *CT_ConnectorNonVisual) ValidateWithPath(path string) error {
	if _gee := _fbae.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _gee != nil {
		return _gee
	}
	if _abee := _fbae.CNvCxnSpPr.ValidateWithPath(path + "/CNvCxnSpPr"); _abee != nil {
		return _abee
	}
	if _acd := _fbae.NvPr.ValidateWithPath(path + "\u002fNvPr"); _acd != nil {
		return _acd
	}
	return nil
}

// Validate validates the CT_Rel and its children
func (_adcb *CT_Rel) Validate() error { return _adcb.ValidateWithPath("CT_Rel") }

// ValidateWithPath validates the EG_ExtensionList and its children, prefixing error messages with path
func (_dgdd *EG_ExtensionList) ValidateWithPath(path string) error {
	for _baea, _eaeab := range _dgdd.Ext {
		if _begd := _eaeab.ValidateWithPath(_c.Sprintf("\u0025s\u002fExt\u005b\u0025d\u005d", path, _baea)); _begd != nil {
			return _begd
		}
	}
	return nil
}
func (_bddff ST_TLChartSubelementType) ValidateWithPath(path string) error {
	switch _bddff {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bddff))
	}
	return nil
}

// Validate validates the CT_GroupShapeNonVisual and its children
func (_gabb *CT_GroupShapeNonVisual) Validate() error {
	return _gabb.ValidateWithPath("CT_GroupShapeNonVisual")
}
func (_cbdce *CT_TLTimeNodeSequence) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cbdce.CTn = NewCT_TLCommonTimeNodeData()
	for _, _ggdaba := range start.Attr {
		if _ggdaba.Name.Local == "concurrent" {
			_gfaa, _bceaa := _b.ParseBool(_ggdaba.Value)
			if _bceaa != nil {
				return _bceaa
			}
			_cbdce.ConcurrentAttr = &_gfaa
			continue
		}
		if _ggdaba.Name.Local == "prevAc" {
			_cbdce.PrevAcAttr.UnmarshalXMLAttr(_ggdaba)
			continue
		}
		if _ggdaba.Name.Local == "nextAc" {
			_cbdce.NextAcAttr.UnmarshalXMLAttr(_ggdaba)
			continue
		}
	}
_fcca:
	for {
		_daafea, _eafgc := d.Token()
		if _eafgc != nil {
			return _eafgc
		}
		switch _bgfff := _daafea.(type) {
		case _e.StartElement:
			switch _bgfff.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cTn"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cTn"}:
				if _feba := d.DecodeElement(_cbdce.CTn, &_bgfff); _feba != nil {
					return _feba
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "prevCondLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "prevCondLst"}:
				_cbdce.PrevCondLst = NewCT_TLTimeConditionList()
				if _efcce := d.DecodeElement(_cbdce.PrevCondLst, &_bgfff); _efcce != nil {
					return _efcce
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "nextCondLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "nextCondLst"}:
				_cbdce.NextCondLst = NewCT_TLTimeConditionList()
				if _cdfcf := d.DecodeElement(_cbdce.NextCondLst, &_bgfff); _cdfcf != nil {
					return _cdfcf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_TLTimeNodeSequence\u0020\u0025v", _bgfff.Name)
				if _dabb := d.Skip(); _dabb != nil {
					return _dabb
				}
			}
		case _e.EndElement:
			break _fcca
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the EG_TopLevelSlide and its children, prefixing error messages with path
func (_dggc *EG_TopLevelSlide) ValidateWithPath(path string) error {
	if _cbccd := _dggc.ClrMap.ValidateWithPath(path + "\u002fClrMap"); _cbccd != nil {
		return _cbccd
	}
	return nil
}

// ST_TransitionEightDirectionType is a union type
type ST_TransitionEightDirectionType struct {
	ST_TransitionSideDirectionType   ST_TransitionSideDirectionType
	ST_TransitionCornerDirectionType ST_TransitionCornerDirectionType
}

func NewCT_SideDirectionTransition() *CT_SideDirectionTransition {
	_fgeeg := &CT_SideDirectionTransition{}
	return _fgeeg
}

// Validate validates the CT_OptionalBlackTransition and its children
func (_dgac *CT_OptionalBlackTransition) Validate() error {
	return _dgac.ValidateWithPath("CT_OptionalBlackTransition")
}
func NewCT_NotesMaster() *CT_NotesMaster {
	_gbaa := &CT_NotesMaster{}
	_gbaa.CSld = NewCT_CommonSlideData()
	_gbaa.ClrMap = _cb.NewCT_ColorMapping()
	return _gbaa
}

// Validate validates the CT_TLTimeAnimateValue and its children
func (_aabdd *CT_TLTimeAnimateValue) Validate() error {
	return _aabdd.ValidateWithPath("CT_TLTimeAnimateValue")
}
func (_aaad *CT_ConnectorNonVisual) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_aaad.CNvPr = _cb.NewCT_NonVisualDrawingProps()
	_aaad.CNvCxnSpPr = _cb.NewCT_NonVisualConnectorProperties()
	_aaad.NvPr = NewCT_ApplicationNonVisualDrawingProps()
_gfca:
	for {
		_ecaf, _becac := d.Token()
		if _becac != nil {
			return _becac
		}
		switch _ade := _ecaf.(type) {
		case _e.StartElement:
			switch _ade.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cNvPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cNvPr"}:
				if _gcae := d.DecodeElement(_aaad.CNvPr, &_ade); _gcae != nil {
					return _gcae
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cNvCxnSpPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cNvCxnSpPr"}:
				if _aadg := d.DecodeElement(_aaad.CNvCxnSpPr, &_ade); _aadg != nil {
					return _aadg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "nvPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "nvPr"}:
				if _gcgb := d.DecodeElement(_aaad.NvPr, &_ade); _gcgb != nil {
					return _gcgb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_ConnectorNonVisual\u0020\u0025v", _ade.Name)
				if _cebb := d.Skip(); _cebb != nil {
					return _cebb
				}
			}
		case _e.EndElement:
			break _gfca
		case _e.CharData:
		}
	}
	return nil
}
func (_gdcea *CT_TLTimeAnimateValue) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _ffaec := range start.Attr {
		if _ffaec.Name.Local == "tm" {
			_gebbe, _dgbab := ParseUnionST_TLTimeAnimateValueTime(_ffaec.Value)
			if _dgbab != nil {
				return _dgbab
			}
			_gdcea.TmAttr = &_gebbe
			continue
		}
		if _ffaec.Name.Local == "fmla" {
			_dcbfga, _daaaf := _ffaec.Value, error(nil)
			if _daaaf != nil {
				return _daaaf
			}
			_gdcea.FmlaAttr = &_dcbfga
			continue
		}
	}
_fbdeeg:
	for {
		_abbfb, _dadgg := d.Token()
		if _dadgg != nil {
			return _dadgg
		}
		switch _fffeb := _abbfb.(type) {
		case _e.StartElement:
			switch _fffeb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "val"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "val"}:
				_gdcea.Val = NewCT_TLAnimVariant()
				if _agdb := d.DecodeElement(_gdcea.Val, &_fffeb); _agdb != nil {
					return _agdb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_TLTimeAnimateValue\u0020\u0025v", _fffeb.Name)
				if _afgca := d.Skip(); _afgca != nil {
					return _afgca
				}
			}
		case _e.EndElement:
			break _fbdeeg
		case _e.CharData:
		}
	}
	return nil
}

type CT_TLGraphicalObjectBuild struct {

	// Build As One
	BldAsOne *CT_Empty

	// Build Sub Elements
	BldSub       *_cb.CT_AnimationGraphicalObjectBuildProperties
	SpidAttr     *uint32
	GrpIdAttr    *uint32
	UiExpandAttr *bool
}

// Validate validates the CT_SlideTransition and its children
func (_dgace *CT_SlideTransition) Validate() error {
	return _dgace.ValidateWithPath("CT_SlideTransition")
}
func (_abacd ST_TransitionSpeed) Validate() error { return _abacd.ValidateWithPath("") }

// Validate validates the CT_PrintProperties and its children
func (_dggec *CT_PrintProperties) Validate() error {
	return _dggec.ValidateWithPath("CT_PrintProperties")
}
func (_gdda *CT_ShapeNonVisual) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_daeab := _e.StartElement{Name: _e.Name{Local: "p:cNvPr"}}
	e.EncodeElement(_gdda.CNvPr, _daeab)
	_dceb := _e.StartElement{Name: _e.Name{Local: "p:cNvSpPr"}}
	e.EncodeElement(_gdda.CNvSpPr, _dceb)
	_gdadg := _e.StartElement{Name: _e.Name{Local: "p:nvPr"}}
	e.EncodeElement(_gdda.NvPr, _gdadg)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_dgaab ST_TLParaBuildType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_dgaab.String(), start)
}
func NewCT_TLTriggerTimeNodeID() *CT_TLTriggerTimeNodeID {
	_acadd := &CT_TLTriggerTimeNodeID{}
	return _acadd
}
func (_adecc *ST_TLTimeNodeMasterRelation) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_bgfea, _dcfbf := d.Token()
	if _dcfbf != nil {
		return _dcfbf
	}
	if _bfaa, _dfcgf := _bgfea.(_e.EndElement); _dfcgf && _bfaa.Name == start.Name {
		*_adecc = 1
		return nil
	}
	if _ebdef, _daade := _bgfea.(_e.CharData); !_daade {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bgfea)
	} else {
		switch string(_ebdef) {
		case "":
			*_adecc = 0
		case "sameClick":
			*_adecc = 1
		case "lastClick":
			*_adecc = 2
		case "nextClick":
			*_adecc = 3
		}
	}
	_bgfea, _dcfbf = d.Token()
	if _dcfbf != nil {
		return _dcfbf
	}
	if _egfcg, _cdfcg := _bgfea.(_e.EndElement); _cdfcg && _egfcg.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bgfea)
}
func (_cfaf *CT_ViewProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cbgbd := range start.Attr {
		if _cbgbd.Name.Local == "lastView" {
			_cfaf.LastViewAttr.UnmarshalXMLAttr(_cbgbd)
			continue
		}
		if _cbgbd.Name.Local == "showComments" {
			_ddcff, _adga := _b.ParseBool(_cbgbd.Value)
			if _adga != nil {
				return _adga
			}
			_cfaf.ShowCommentsAttr = &_ddcff
			continue
		}
	}
_gebfg:
	for {
		_gfedgb, _ceccb := d.Token()
		if _ceccb != nil {
			return _ceccb
		}
		switch _dagdg := _gfedgb.(type) {
		case _e.StartElement:
			switch _dagdg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "normalViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "normalViewPr"}:
				_cfaf.NormalViewPr = NewCT_NormalViewProperties()
				if _fbfbe := d.DecodeElement(_cfaf.NormalViewPr, &_dagdg); _fbfbe != nil {
					return _fbfbe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "slideViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "slideViewPr"}:
				_cfaf.SlideViewPr = NewCT_SlideViewProperties()
				if _bdffbc := d.DecodeElement(_cfaf.SlideViewPr, &_dagdg); _bdffbc != nil {
					return _bdffbc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "outlineViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "outlineViewPr"}:
				_cfaf.OutlineViewPr = NewCT_OutlineViewProperties()
				if _gfbee := d.DecodeElement(_cfaf.OutlineViewPr, &_dagdg); _gfbee != nil {
					return _gfbee
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "notesTextViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "notesTextViewPr"}:
				_cfaf.NotesTextViewPr = NewCT_NotesTextViewProperties()
				if _added := d.DecodeElement(_cfaf.NotesTextViewPr, &_dagdg); _added != nil {
					return _added
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sorterViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sorterViewPr"}:
				_cfaf.SorterViewPr = NewCT_SlideSorterViewProperties()
				if _bceec := d.DecodeElement(_cfaf.SorterViewPr, &_dagdg); _bceec != nil {
					return _bceec
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "notesViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "notesViewPr"}:
				_cfaf.NotesViewPr = NewCT_NotesViewProperties()
				if _daef := d.DecodeElement(_cfaf.NotesViewPr, &_dagdg); _daef != nil {
					return _daef
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "gridSpacing"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "gridSpacing"}:
				_cfaf.GridSpacing = _cb.NewCT_PositiveSize2D()
				if _gbccd := d.DecodeElement(_cfaf.GridSpacing, &_dagdg); _gbccd != nil {
					return _gbccd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_cfaf.ExtLst = NewCT_ExtensionList()
				if _gbdb := d.DecodeElement(_cfaf.ExtLst, &_dagdg); _gbdb != nil {
					return _gbdb
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_ViewProperties\u0020\u0025v", _dagdg.Name)
				if _ddbaf := d.Skip(); _ddbaf != nil {
					return _ddbaf
				}
			}
		case _e.EndElement:
			break _gebfg
		case _e.CharData:
		}
	}
	return nil
}
func (_dagaa ST_ViewType) ValidateWithPath(path string) error {
	switch _dagaa {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dagaa))
	}
	return nil
}

// ValidateWithPath validates the CT_OutlineViewSlideEntry and its children, prefixing error messages with path
func (_bccdd *CT_OutlineViewSlideEntry) ValidateWithPath(path string) error { return nil }

type CT_SideDirectionTransition struct {

	// Direction
	DirAttr ST_TransitionSideDirectionType
}

func ParseUnionST_TransitionEightDirectionType(s string) (ST_TransitionEightDirectionType, error) {
	return ST_TransitionEightDirectionType{}, nil
}

type CT_SlideMaster struct {

	// Preserve Slide Master
	PreserveAttr *bool

	// Common slide data for slide masters
	CSld *CT_CommonSlideData

	// Color Scheme Map
	ClrMap *_cb.CT_ColorMapping

	// List of Slide Layouts
	SldLayoutIdLst *CT_SlideLayoutIdList

	// Slide Transition for a Slide Master
	Transition *CT_SlideTransition

	// Slide Timing Information for Slide Masters
	Timing *CT_SlideTiming

	// Header/Footer information for a slide master
	Hf *CT_HeaderFooter

	// Slide Master Text Styles
	TxStyles *CT_SlideMasterTextStyles
	ExtLst   *CT_ExtensionListModify
}

func (_dab *CT_NotesMaster) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_aded := _e.StartElement{Name: _e.Name{Local: "p:cSld"}}
	e.EncodeElement(_dab.CSld, _aded)
	_dcfgb := _e.StartElement{Name: _e.Name{Local: "p:clrMap"}}
	e.EncodeElement(_dab.ClrMap, _dcfgb)
	if _dab.Hf != nil {
		_cdcc := _e.StartElement{Name: _e.Name{Local: "p:hf"}}
		e.EncodeElement(_dab.Hf, _cdcc)
	}
	if _dab.NotesStyle != nil {
		_geea := _e.StartElement{Name: _e.Name{Local: "p:notesStyle"}}
		e.EncodeElement(_dab.NotesStyle, _geea)
	}
	if _dab.ExtLst != nil {
		_fadc := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_dab.ExtLst, _fadc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_ebbb *CT_OleObjectLink) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _ebca := range start.Attr {
		if _ebca.Name.Local == "updateAutomatic" {
			_fedff, _aabgc := _b.ParseBool(_ebca.Value)
			if _aabgc != nil {
				return _aabgc
			}
			_ebbb.UpdateAutomaticAttr = &_fedff
			continue
		}
	}
_bgf:
	for {
		_gdbc, _cdced := d.Token()
		if _cdced != nil {
			return _cdced
		}
		switch _gbgc := _gdbc.(type) {
		case _e.StartElement:
			switch _gbgc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_ebbb.ExtLst = NewCT_ExtensionList()
				if _bgad := d.DecodeElement(_ebbb.ExtLst, &_gbgc); _bgad != nil {
					return _bgad
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OleObjectLink\u0020\u0025v", _gbgc.Name)
				if _geggb := d.Skip(); _geggb != nil {
					return _geggb
				}
			}
		case _e.EndElement:
			break _bgf
		case _e.CharData:
		}
	}
	return nil
}

type ST_TLBehaviorAccumulateType byte

func (_dbagd *CT_TLTimeTargetElement) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_eddb:
	for {
		_febc, _eafcb := d.Token()
		if _eafcb != nil {
			return _eafcb
		}
		switch _gfdbe := _febc.(type) {
		case _e.StartElement:
			switch _gfdbe.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldTgt"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldTgt"}:
				_dbagd.SldTgt = NewCT_Empty()
				if _gaefgc := d.DecodeElement(_dbagd.SldTgt, &_gfdbe); _gaefgc != nil {
					return _gaefgc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sndTgt"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sndTgt"}:
				_dbagd.SndTgt = _cb.NewCT_EmbeddedWAVAudioFile()
				if _ffgga := d.DecodeElement(_dbagd.SndTgt, &_gfdbe); _ffgga != nil {
					return _ffgga
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "spTgt"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "spTgt"}:
				_dbagd.SpTgt = NewCT_TLShapeTargetElement()
				if _eeadb := d.DecodeElement(_dbagd.SpTgt, &_gfdbe); _eeadb != nil {
					return _eeadb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "inkTgt"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "inkTgt"}:
				_dbagd.InkTgt = NewCT_TLSubShapeId()
				if _eadaf := d.DecodeElement(_dbagd.InkTgt, &_gfdbe); _eadaf != nil {
					return _eadaf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLTimeTargetElement\u0020\u0025v", _gfdbe.Name)
				if _ceda := d.Skip(); _ceda != nil {
					return _ceda
				}
			}
		case _e.EndElement:
			break _eddb
		case _e.CharData:
		}
	}
	return nil
}
func (_ffaa *CT_Rel) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _ffaa.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_OleObjectEmbed() *CT_OleObjectEmbed { _fggc := &CT_OleObjectEmbed{}; return _fggc }
func (_aeed ST_PrintWhat) ValidateWithPath(path string) error {
	switch _aeed {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aeed))
	}
	return nil
}
func (_adcdg *ST_TLAnimateColorDirection) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_edddc, _cbbec := d.Token()
	if _cbbec != nil {
		return _cbbec
	}
	if _gcgbc, _ebddc := _edddc.(_e.EndElement); _ebddc && _gcgbc.Name == start.Name {
		*_adcdg = 1
		return nil
	}
	if _dffdb, _badb := _edddc.(_e.CharData); !_badb {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _edddc)
	} else {
		switch string(_dffdb) {
		case "":
			*_adcdg = 0
		case "cw":
			*_adcdg = 1
		case "ccw":
			*_adcdg = 2
		}
	}
	_edddc, _cbbec = d.Token()
	if _cbbec != nil {
		return _cbbec
	}
	if _dgggbc, _eacab := _edddc.(_e.EndElement); _eacab && _dgggbc.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _edddc)
}

// Validate validates the CT_TLCommonTimeNodeData and its children
func (_fagfd *CT_TLCommonTimeNodeData) Validate() error {
	return _fagfd.ValidateWithPath("CT_TLCommonTimeNodeData")
}
func (_aceec *CT_SlideMasterIdListEntry) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _gcfac := range start.Attr {
		if _gcfac.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _gcfac.Name.Local == "id" || _gcfac.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _gcfac.Name.Local == "id" {
			_fgfbf, _abfd := _gcfac.Value, error(nil)
			if _abfd != nil {
				return _abfd
			}
			_aceec.RIdAttr = _fgfbf
			continue
		}
		if _gcfac.Name.Local == "id" {
			_dgbfe, _gbcb := _b.ParseUint(_gcfac.Value, 10, 32)
			if _gbcb != nil {
				return _gbcb
			}
			_agbbf := uint32(_dgbfe)
			_aceec.IdAttr = &_agbbf
			continue
		}
	}
_bfdc:
	for {
		_gecg, _bfge := d.Token()
		if _bfge != nil {
			return _bfge
		}
		switch _gdbb := _gecg.(type) {
		case _e.StartElement:
			switch _gdbb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_aceec.ExtLst = NewCT_ExtensionList()
				if _eefga := d.DecodeElement(_aceec.ExtLst, &_gdbb); _eefga != nil {
					return _eefga
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SlideMasterIdListEntry\u0020\u0025v", _gdbb.Name)
				if _dgcb := d.Skip(); _dgcb != nil {
					return _dgcb
				}
			}
		case _e.EndElement:
			break _bfdc
		case _e.CharData:
		}
	}
	return nil
}
func (_cfec *CT_ModifyVerifier) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _daeb := range start.Attr {
		if _daeb.Name.Local == "spinCount" {
			_ggfee, _ffaga := _b.ParseUint(_daeb.Value, 10, 32)
			if _ffaga != nil {
				return _ffaga
			}
			_abac := uint32(_ggfee)
			_cfec.SpinCountAttr = &_abac
			continue
		}
		if _daeb.Name.Local == "algorithmName" {
			_cfbf, _fdbfc := _daeb.Value, error(nil)
			if _fdbfc != nil {
				return _fdbfc
			}
			_cfec.AlgorithmNameAttr = &_cfbf
			continue
		}
		if _daeb.Name.Local == "saltData" {
			_geb, _dfaab := _daeb.Value, error(nil)
			if _dfaab != nil {
				return _dfaab
			}
			_cfec.SaltDataAttr = &_geb
			continue
		}
		if _daeb.Name.Local == "saltValue" {
			_abba, _affd := _daeb.Value, error(nil)
			if _affd != nil {
				return _affd
			}
			_cfec.SaltValueAttr = &_abba
			continue
		}
		if _daeb.Name.Local == "cryptProviderType" {
			_cfec.CryptProviderTypeAttr.UnmarshalXMLAttr(_daeb)
			continue
		}
		if _daeb.Name.Local == "cryptAlgorithmClass" {
			_cfec.CryptAlgorithmClassAttr.UnmarshalXMLAttr(_daeb)
			continue
		}
		if _daeb.Name.Local == "cryptAlgorithmType" {
			_cfec.CryptAlgorithmTypeAttr.UnmarshalXMLAttr(_daeb)
			continue
		}
		if _daeb.Name.Local == "cryptAlgorithmSid" {
			_bbce, _cfecg := _b.ParseUint(_daeb.Value, 10, 32)
			if _cfecg != nil {
				return _cfecg
			}
			_gdce := uint32(_bbce)
			_cfec.CryptAlgorithmSidAttr = &_gdce
			continue
		}
		if _daeb.Name.Local == "hashValue" {
			_cfed, _dcec := _daeb.Value, error(nil)
			if _dcec != nil {
				return _dcec
			}
			_cfec.HashValueAttr = &_cfed
			continue
		}
		if _daeb.Name.Local == "spinValue" {
			_degd, _cgbb := _b.ParseUint(_daeb.Value, 10, 32)
			if _cgbb != nil {
				return _cgbb
			}
			_eeab := uint32(_degd)
			_cfec.SpinValueAttr = &_eeab
			continue
		}
		if _daeb.Name.Local == "hashData" {
			_bece, _befa := _daeb.Value, error(nil)
			if _befa != nil {
				return _befa
			}
			_cfec.HashDataAttr = &_bece
			continue
		}
		if _daeb.Name.Local == "cryptProvider" {
			_cafg, _dcfg := _daeb.Value, error(nil)
			if _dcfg != nil {
				return _dcfg
			}
			_cfec.CryptProviderAttr = &_cafg
			continue
		}
		if _daeb.Name.Local == "algIdExt" {
			_eegc, _agbb := _b.ParseUint(_daeb.Value, 10, 32)
			if _agbb != nil {
				return _agbb
			}
			_dedd := uint32(_eegc)
			_cfec.AlgIdExtAttr = &_dedd
			continue
		}
		if _daeb.Name.Local == "algIdExtSource" {
			_cgbce, _ffbbd := _daeb.Value, error(nil)
			if _ffbbd != nil {
				return _ffbbd
			}
			_cfec.AlgIdExtSourceAttr = &_cgbce
			continue
		}
		if _daeb.Name.Local == "cryptProviderTypeExt" {
			_fdea, _fcged := _b.ParseUint(_daeb.Value, 10, 32)
			if _fcged != nil {
				return _fcged
			}
			_gceca := uint32(_fdea)
			_cfec.CryptProviderTypeExtAttr = &_gceca
			continue
		}
		if _daeb.Name.Local == "cryptProviderTypeExtSource" {
			_ebag, _gbfea := _daeb.Value, error(nil)
			if _gbfea != nil {
				return _gbfea
			}
			_cfec.CryptProviderTypeExtSourceAttr = &_ebag
			continue
		}
	}
	for {
		_bdec, _dfd := d.Token()
		if _dfd != nil {
			return _c.Errorf("parsing\u0020CT_ModifyVerifier: \u0025s", _dfd)
		}
		if _bfdf, _cgfd := _bdec.(_e.EndElement); _cgfd && _bfdf.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_OutlineViewProperties and its children, prefixing error messages with path
func (_caeea *CT_OutlineViewProperties) ValidateWithPath(path string) error {
	if _eaadb := _caeea.CViewPr.ValidateWithPath(path + "\u002fCViewPr"); _eaadb != nil {
		return _eaadb
	}
	if _caeea.SldLst != nil {
		if _dabe := _caeea.SldLst.ValidateWithPath(path + "\u002fSldLst"); _dabe != nil {
			return _dabe
		}
	}
	if _caeea.ExtLst != nil {
		if _ageg := _caeea.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ageg != nil {
			return _ageg
		}
	}
	return nil
}
func (_bfdef *CT_HandoutMasterIdListEntry) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cada := range start.Attr {
		if _cada.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _cada.Name.Local == "id" || _cada.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _cada.Name.Local == "id" {
			_cgea, _edbc := _cada.Value, error(nil)
			if _edbc != nil {
				return _edbc
			}
			_bfdef.IdAttr = _cgea
			continue
		}
	}
_fcaf:
	for {
		_cagf, _aaab := d.Token()
		if _aaab != nil {
			return _aaab
		}
		switch _gaga := _cagf.(type) {
		case _e.StartElement:
			switch _gaga.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_bfdef.ExtLst = NewCT_ExtensionList()
				if _cgee := d.DecodeElement(_bfdef.ExtLst, &_gaga); _cgee != nil {
					return _cgee
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_HandoutMasterIdListEntry\u0020\u0025v", _gaga.Name)
				if _facaa := d.Skip(); _facaa != nil {
					return _facaa
				}
			}
		case _e.EndElement:
			break _fcaf
		case _e.CharData:
		}
	}
	return nil
}
func (_gccb *CT_BuildList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _gccb.BldP != nil {
		_cbca := _e.StartElement{Name: _e.Name{Local: "p:bldP"}}
		for _, _ggbe := range _gccb.BldP {
			e.EncodeElement(_ggbe, _cbca)
		}
	}
	if _gccb.BldDgm != nil {
		_ffe := _e.StartElement{Name: _e.Name{Local: "p:bldDgm"}}
		for _, _cgc := range _gccb.BldDgm {
			e.EncodeElement(_cgc, _ffe)
		}
	}
	if _gccb.BldOleChart != nil {
		_bdf := _e.StartElement{Name: _e.Name{Local: "p:bldOleChart"}}
		for _, _fcf := range _gccb.BldOleChart {
			e.EncodeElement(_fcf, _bdf)
		}
	}
	if _gccb.BldGraphic != nil {
		_dbe := _e.StartElement{Name: _e.Name{Local: "p:bldGraphic"}}
		for _, _bca := range _gccb.BldGraphic {
			e.EncodeElement(_bca, _dbe)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_dbdb *CT_SlideLayout) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dbdb.CSld = NewCT_CommonSlideData()
	for _, _gdafe := range start.Attr {
		if _gdafe.Name.Local == "matchingName" {
			_beaga, _ffgf := _gdafe.Value, error(nil)
			if _ffgf != nil {
				return _ffgf
			}
			_dbdb.MatchingNameAttr = &_beaga
			continue
		}
		if _gdafe.Name.Local == "type" {
			_dbdb.TypeAttr.UnmarshalXMLAttr(_gdafe)
			continue
		}
		if _gdafe.Name.Local == "preserve" {
			_ebeca, _ffbd := _b.ParseBool(_gdafe.Value)
			if _ffbd != nil {
				return _ffbd
			}
			_dbdb.PreserveAttr = &_ebeca
			continue
		}
		if _gdafe.Name.Local == "userDrawn" {
			_cedf, _gafbg := _b.ParseBool(_gdafe.Value)
			if _gafbg != nil {
				return _gafbg
			}
			_dbdb.UserDrawnAttr = &_cedf
			continue
		}
		if _gdafe.Name.Local == "showMasterSp" {
			_bbgbb, _eefcg := _b.ParseBool(_gdafe.Value)
			if _eefcg != nil {
				return _eefcg
			}
			_dbdb.ShowMasterSpAttr = &_bbgbb
			continue
		}
		if _gdafe.Name.Local == "showMasterPhAnim" {
			_accb, _fbfeb := _b.ParseBool(_gdafe.Value)
			if _fbfeb != nil {
				return _fbfeb
			}
			_dbdb.ShowMasterPhAnimAttr = &_accb
			continue
		}
	}
_aeae:
	for {
		_dfcg, _bedg := d.Token()
		if _bedg != nil {
			return _bedg
		}
		switch _acgf := _dfcg.(type) {
		case _e.StartElement:
			switch _acgf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _dgfg := d.DecodeElement(_dbdb.CSld, &_acgf); _dgfg != nil {
					return _dgfg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMapOvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMapOvr"}:
				_dbdb.ClrMapOvr = _cb.NewCT_ColorMappingOverride()
				if _cecea := d.DecodeElement(_dbdb.ClrMapOvr, &_acgf); _cecea != nil {
					return _cecea
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "transition"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "transition"}:
				_dbdb.Transition = NewCT_SlideTransition()
				if _adeb := d.DecodeElement(_dbdb.Transition, &_acgf); _adeb != nil {
					return _adeb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "timing"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "timing"}:
				_dbdb.Timing = NewCT_SlideTiming()
				if _ggbcc := d.DecodeElement(_dbdb.Timing, &_acgf); _ggbcc != nil {
					return _ggbcc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "hf"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "hf"}:
				_dbdb.Hf = NewCT_HeaderFooter()
				if _ffaea := d.DecodeElement(_dbdb.Hf, &_acgf); _ffaea != nil {
					return _ffaea
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_dbdb.ExtLst = NewCT_ExtensionListModify()
				if _dbcc := d.DecodeElement(_dbdb.ExtLst, &_acgf); _dbcc != nil {
					return _dbcc
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SlideLayout\u0020\u0025v", _acgf.Name)
				if _ceeed := d.Skip(); _ceeed != nil {
					return _ceeed
				}
			}
		case _e.EndElement:
			break _aeae
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_TLAnimateEffectBehavior and its children
func (_agde *CT_TLAnimateEffectBehavior) Validate() error {
	return _agde.ValidateWithPath("CT_TLAnimateEffectBehavior")
}

// ValidateWithPath validates the CT_NotesSlide and its children, prefixing error messages with path
func (_cgada *CT_NotesSlide) ValidateWithPath(path string) error {
	if _gegf := _cgada.CSld.ValidateWithPath(path + "\u002fCSld"); _gegf != nil {
		return _gegf
	}
	if _cgada.ClrMapOvr != nil {
		if _dabg := _cgada.ClrMapOvr.ValidateWithPath(path + "\u002fClrMapOvr"); _dabg != nil {
			return _dabg
		}
	}
	if _cgada.ExtLst != nil {
		if _bccac := _cgada.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bccac != nil {
			return _bccac
		}
	}
	return nil
}
func (_fggad ST_TLTimeNodeMasterRelation) String() string {
	switch _fggad {
	case 0:
		return ""
	case 1:
		return "sameClick"
	case 2:
		return "lastClick"
	case 3:
		return "nextClick"
	}
	return ""
}

// ValidateWithPath validates the CT_Control and its children, prefixing error messages with path
func (_gdfg *CT_Control) ValidateWithPath(path string) error {
	if _gdfg.ExtLst != nil {
		if _eeaf := _gdfg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eeaf != nil {
			return _eeaf
		}
	}
	if _gdfg.Pic != nil {
		if _gcbdb := _gdfg.Pic.ValidateWithPath(path + "\u002fPic"); _gcbdb != nil {
			return _gcbdb
		}
	}
	if _gdfg.ImgWAttr != nil {
		if *_gdfg.ImgWAttr < 0 {
			return _c.Errorf("\u0025s/m\u002eImgWAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_gdfg.ImgWAttr)
		}
	}
	if _gdfg.ImgHAttr != nil {
		if *_gdfg.ImgHAttr < 0 {
			return _c.Errorf("\u0025s/m\u002eImgHAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_gdfg.ImgHAttr)
		}
	}
	return nil
}
func (_bfed *CT_NormalViewProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_bfed.RestoredLeft = NewCT_NormalViewPortion()
	_bfed.RestoredTop = NewCT_NormalViewPortion()
	for _, _cafe := range start.Attr {
		if _cafe.Name.Local == "showOutlineIcons" {
			_gcfg, _bgcg := _b.ParseBool(_cafe.Value)
			if _bgcg != nil {
				return _bgcg
			}
			_bfed.ShowOutlineIconsAttr = &_gcfg
			continue
		}
		if _cafe.Name.Local == "snapVertSplitter" {
			_dcada, _fafb := _b.ParseBool(_cafe.Value)
			if _fafb != nil {
				return _fafb
			}
			_bfed.SnapVertSplitterAttr = &_dcada
			continue
		}
		if _cafe.Name.Local == "vertBarState" {
			_bfed.VertBarStateAttr.UnmarshalXMLAttr(_cafe)
			continue
		}
		if _cafe.Name.Local == "horzBarState" {
			_bfed.HorzBarStateAttr.UnmarshalXMLAttr(_cafe)
			continue
		}
		if _cafe.Name.Local == "preferSingleView" {
			_gdfc, _ccfe := _b.ParseBool(_cafe.Value)
			if _ccfe != nil {
				return _ccfe
			}
			_bfed.PreferSingleViewAttr = &_gdfc
			continue
		}
	}
_gada:
	for {
		_afcdd, _dede := d.Token()
		if _dede != nil {
			return _dede
		}
		switch _gdfdf := _afcdd.(type) {
		case _e.StartElement:
			switch _gdfdf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "restoredLeft"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "restoredLeft"}:
				if _gffe := d.DecodeElement(_bfed.RestoredLeft, &_gdfdf); _gffe != nil {
					return _gffe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "restoredTop"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "restoredTop"}:
				if _cgba := d.DecodeElement(_bfed.RestoredTop, &_gdfdf); _cgba != nil {
					return _cgba
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_bfed.ExtLst = NewCT_ExtensionList()
				if _bdab := d.DecodeElement(_bfed.ExtLst, &_gdfdf); _bdab != nil {
					return _bdab
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_NormalViewProperties \u0025v", _gdfdf.Name)
				if _efcb := d.Skip(); _efcb != nil {
					return _efcb
				}
			}
		case _e.EndElement:
			break _gada
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TLTemplateList and its children, prefixing error messages with path
func (_ccgfac *CT_TLTemplateList) ValidateWithPath(path string) error {
	for _bebaa, _efga := range _ccgfac.Tmpl {
		if _gecf := _efga.ValidateWithPath(_c.Sprintf("%s\u002fTmpl\u005b\u0025d\u005d", path, _bebaa)); _gecf != nil {
			return _gecf
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TLCommonMediaNodeData and its children, prefixing error messages with path
func (_acdfcd *CT_TLCommonMediaNodeData) ValidateWithPath(path string) error {
	if _acdfcd.VolAttr != nil {
		if _edaga := _acdfcd.VolAttr.ValidateWithPath(path + "\u002fVolAttr"); _edaga != nil {
			return _edaga
		}
	}
	if _bbcef := _acdfcd.CTn.ValidateWithPath(path + "\u002fCTn"); _bbcef != nil {
		return _bbcef
	}
	if _fadb := _acdfcd.TgtEl.ValidateWithPath(path + "\u002fTgtEl"); _fadb != nil {
		return _fadb
	}
	return nil
}
func NewCT_TLIterateIntervalPercentage() *CT_TLIterateIntervalPercentage {
	_ffcg := &CT_TLIterateIntervalPercentage{}
	return _ffcg
}

// Validate validates the CT_GroupShape and its children
func (_cefff *CT_GroupShape) Validate() error { return _cefff.ValidateWithPath("CT_GroupShape") }

// Validate validates the EG_ChildSlide and its children
func (_fcded *EG_ChildSlide) Validate() error { return _fcded.ValidateWithPath("EG_ChildSlide") }
func (_ddb *CT_Comment) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "authorId"}, Value: _c.Sprintf("\u0025v", _ddb.AuthorIdAttr)})
	if _ddb.DtAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "dt"}, Value: _c.Sprintf("\u0025v", *_ddb.DtAttr)})
	}
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "idx"}, Value: _c.Sprintf("\u0025v", _ddb.IdxAttr)})
	e.EncodeToken(start)
	_cee := _e.StartElement{Name: _e.Name{Local: "p:pos"}}
	e.EncodeElement(_ddb.Pos, _cee)
	_fcb := _e.StartElement{Name: _e.Name{Local: "p:text"}}
	_ee.AddPreserveSpaceAttr(&_fcb, _ddb.Text)
	e.EncodeElement(_ddb.Text, _fcb)
	if _ddb.ExtLst != nil {
		_acb := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ddb.ExtLst, _acb)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TLAnimateRotationBehavior and its children
func (_agcb *CT_TLAnimateRotationBehavior) Validate() error {
	return _agcb.ValidateWithPath("CT_TLAnimateRotationBehavior")
}
func (_gdfcf ST_PlaceholderSize) Validate() error { return _gdfcf.ValidateWithPath("") }
func (_egcceb ST_TLPreviousActionType) String() string {
	switch _egcceb {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "skipTimed"
	}
	return ""
}

// Validate validates the CT_TLGraphicalObjectBuild and its children
func (_faaeg *CT_TLGraphicalObjectBuild) Validate() error {
	return _faaeg.ValidateWithPath("CT_TLGraphicalObjectBuild")
}
func (_gebfd *ST_IterateType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_gebfd = 0
	case "el":
		*_gebfd = 1
	case "wd":
		*_gebfd = 2
	case "lt":
		*_gebfd = 3
	}
	return nil
}

type CT_TLTimeNodeParallel struct {

	// Parallel TimeNode
	CTn *CT_TLCommonTimeNodeData
}

const (
	ST_TLParaBuildTypeUnset     ST_TLParaBuildType = 0
	ST_TLParaBuildTypeAllAtOnce ST_TLParaBuildType = 1
	ST_TLParaBuildTypeP         ST_TLParaBuildType = 2
	ST_TLParaBuildTypeCust      ST_TLParaBuildType = 3
	ST_TLParaBuildTypeWhole     ST_TLParaBuildType = 4
)

func (_dcgdg *CT_TLByAnimateColorTransform) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_babbd:
	for {
		_egdc, _acaa := d.Token()
		if _acaa != nil {
			return _acaa
		}
		switch _fefbc := _egdc.(type) {
		case _e.StartElement:
			switch _fefbc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "rgb"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "rgb"}:
				_dcgdg.Rgb = NewCT_TLByRgbColorTransform()
				if _gaagc := d.DecodeElement(_dcgdg.Rgb, &_fefbc); _gaagc != nil {
					return _gaagc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "hsl"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "hsl"}:
				_dcgdg.Hsl = NewCT_TLByHslColorTransform()
				if _ffgc := d.DecodeElement(_dcgdg.Hsl, &_fefbc); _ffgc != nil {
					return _ffgc
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_TLByAnimateColorTransform\u0020\u0025v", _fefbc.Name)
				if _egcbg := d.Skip(); _egcbg != nil {
					return _egcbg
				}
			}
		case _e.EndElement:
			break _babbd
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_SlideLayout and its children
func (_cbde *CT_SlideLayout) Validate() error    { return _cbde.ValidateWithPath("CT_SlideLayout") }
func NewCT_SplitTransition() *CT_SplitTransition { _gcbc := &CT_SplitTransition{}; return _gcbc }
func NewCT_TLAnimateRotationBehavior() *CT_TLAnimateRotationBehavior {
	_dccf := &CT_TLAnimateRotationBehavior{}
	_dccf.CBhvr = NewCT_TLCommonBehaviorData()
	return _dccf
}

const (
	ST_TransitionSpeedUnset ST_TransitionSpeed = 0
	ST_TransitionSpeedSlow  ST_TransitionSpeed = 1
	ST_TransitionSpeedMed   ST_TransitionSpeed = 2
	ST_TransitionSpeedFast  ST_TransitionSpeed = 3
)

type CT_NormalViewPortion struct {

	// Normal View Dimension Size
	SzAttr _cb.ST_PositiveFixedPercentage

	// Auto Adjust Normal View
	AutoAdjustAttr *bool
}

// Validate validates the CT_Shape and its children
func (_agge *CT_Shape) Validate() error { return _agge.ValidateWithPath("CT_Shape") }
func (_eaf *CT_EmbeddedFontListEntry) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_aab := _e.StartElement{Name: _e.Name{Local: "p:font"}}
	e.EncodeElement(_eaf.Font, _aab)
	if _eaf.Regular != nil {
		_abce := _e.StartElement{Name: _e.Name{Local: "p:regular"}}
		e.EncodeElement(_eaf.Regular, _abce)
	}
	if _eaf.Bold != nil {
		_deaga := _e.StartElement{Name: _e.Name{Local: "p:bold"}}
		e.EncodeElement(_eaf.Bold, _deaga)
	}
	if _eaf.Italic != nil {
		_cdca := _e.StartElement{Name: _e.Name{Local: "p:italic"}}
		e.EncodeElement(_eaf.Italic, _cdca)
	}
	if _eaf.BoldItalic != nil {
		_ddee := _e.StartElement{Name: _e.Name{Local: "p:boldItalic"}}
		e.EncodeElement(_eaf.BoldItalic, _ddee)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_ebadg *CT_TLAnimVariant) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_dcfa:
	for {
		_bbdf, _dggac := d.Token()
		if _dggac != nil {
			return _dggac
		}
		switch _ddgca := _bbdf.(type) {
		case _e.StartElement:
			switch _ddgca.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "boolVal"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "boolVal"}:
				_ebadg.BoolVal = NewCT_TLAnimVariantBooleanVal()
				if _gdbba := d.DecodeElement(_ebadg.BoolVal, &_ddgca); _gdbba != nil {
					return _gdbba
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "intVal"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "intVal"}:
				_ebadg.IntVal = NewCT_TLAnimVariantIntegerVal()
				if _gfbcb := d.DecodeElement(_ebadg.IntVal, &_ddgca); _gfbcb != nil {
					return _gfbcb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "fltVal"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "fltVal"}:
				_ebadg.FltVal = NewCT_TLAnimVariantFloatVal()
				if _ggdab := d.DecodeElement(_ebadg.FltVal, &_ddgca); _ggdab != nil {
					return _ggdab
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "strVal"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "strVal"}:
				_ebadg.StrVal = NewCT_TLAnimVariantStringVal()
				if _bdfb := d.DecodeElement(_ebadg.StrVal, &_ddgca); _bdfb != nil {
					return _bdfb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrVal"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrVal"}:
				_ebadg.ClrVal = _cb.NewCT_Color()
				if _bgfec := d.DecodeElement(_ebadg.ClrVal, &_ddgca); _bgfec != nil {
					return _bgfec
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLAnimVariant\u0020\u0025v", _ddgca.Name)
				if _ccggf := d.Skip(); _ccggf != nil {
					return _ccggf
				}
			}
		case _e.EndElement:
			break _dcfa
		case _e.CharData:
		}
	}
	return nil
}

type CT_SlideLayoutIdList struct {

	// Slide Layout Id
	SldLayoutId []*CT_SlideLayoutIdListEntry
}

func (_fgeg *CT_OptionalBlackTransition) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _fgeg.ThruBlkAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "thruBlk"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fgeg.ThruBlkAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_ecgfc ST_IterateType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_efcff := _e.Attr{}
	_efcff.Name = name
	switch _ecgfc {
	case ST_IterateTypeUnset:
		_efcff.Value = ""
	case ST_IterateTypeEl:
		_efcff.Value = "el"
	case ST_IterateTypeWd:
		_efcff.Value = "wd"
	case ST_IterateTypeLt:
		_efcff.Value = "lt"
	}
	return _efcff, nil
}
func (_eaefcf ST_Direction) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_eaefcf.String(), start)
}

const (
	ST_SlideSizeTypeUnset       ST_SlideSizeType = 0
	ST_SlideSizeTypeScreen4x3   ST_SlideSizeType = 1
	ST_SlideSizeTypeLetter      ST_SlideSizeType = 2
	ST_SlideSizeTypeA4          ST_SlideSizeType = 3
	ST_SlideSizeType35mm        ST_SlideSizeType = 4
	ST_SlideSizeTypeOverhead    ST_SlideSizeType = 5
	ST_SlideSizeTypeBanner      ST_SlideSizeType = 6
	ST_SlideSizeTypeCustom      ST_SlideSizeType = 7
	ST_SlideSizeTypeLedger      ST_SlideSizeType = 8
	ST_SlideSizeTypeA3          ST_SlideSizeType = 9
	ST_SlideSizeTypeB4ISO       ST_SlideSizeType = 10
	ST_SlideSizeTypeB5ISO       ST_SlideSizeType = 11
	ST_SlideSizeTypeB4JIS       ST_SlideSizeType = 12
	ST_SlideSizeTypeB5JIS       ST_SlideSizeType = 13
	ST_SlideSizeTypeHagakiCard  ST_SlideSizeType = 14
	ST_SlideSizeTypeScreen16x9  ST_SlideSizeType = 15
	ST_SlideSizeTypeScreen16x10 ST_SlideSizeType = 16
)

func (_cebfg ST_TLBehaviorAccumulateType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_cebfg.String(), start)
}

type CT_CustomShowId struct {

	// Custom Show Identifier
	IdAttr uint32
}

func (_gfbfa *ST_TLTriggerRuntimeNode) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fadfcg, _ebedg := d.Token()
	if _ebedg != nil {
		return _ebedg
	}
	if _eece, _bdceg := _fadfcg.(_e.EndElement); _bdceg && _eece.Name == start.Name {
		*_gfbfa = 1
		return nil
	}
	if _ebfgb, _cfcbd := _fadfcg.(_e.CharData); !_cfcbd {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fadfcg)
	} else {
		switch string(_ebfgb) {
		case "":
			*_gfbfa = 0
		case "first":
			*_gfbfa = 1
		case "last":
			*_gfbfa = 2
		case "all":
			*_gfbfa = 3
		}
	}
	_fadfcg, _ebedg = d.Token()
	if _ebedg != nil {
		return _ebedg
	}
	if _eddga, _deacf := _fadfcg.(_e.EndElement); _deacf && _eddga.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fadfcg)
}
func (_daecd ST_TLBehaviorTransformType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_daecd.String(), start)
}
func NewCT_BackgroundProperties() *CT_BackgroundProperties {
	_cdg := &CT_BackgroundProperties{}
	return _cdg
}
func (_dgfa *CT_TLTimeTargetElement) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _dgfa.SldTgt != nil {
		_ecdd := _e.StartElement{Name: _e.Name{Local: "p:sldTgt"}}
		e.EncodeElement(_dgfa.SldTgt, _ecdd)
	}
	if _dgfa.SndTgt != nil {
		_fcfaf := _e.StartElement{Name: _e.Name{Local: "p:sndTgt"}}
		e.EncodeElement(_dgfa.SndTgt, _fcfaf)
	}
	if _dgfa.SpTgt != nil {
		_bdgdc := _e.StartElement{Name: _e.Name{Local: "p:spTgt"}}
		e.EncodeElement(_dgfa.SpTgt, _bdgdc)
	}
	if _dgfa.InkTgt != nil {
		_bfad := _e.StartElement{Name: _e.Name{Local: "p:inkTgt"}}
		e.EncodeElement(_dgfa.InkTgt, _bfad)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_ViewProperties struct {

	// Last View
	LastViewAttr ST_ViewType

	// Show Comments
	ShowCommentsAttr *bool

	// Normal View Properties
	NormalViewPr *CT_NormalViewProperties

	// Slide View Properties
	SlideViewPr *CT_SlideViewProperties

	// Outline View Properties
	OutlineViewPr *CT_OutlineViewProperties

	// Notes Text View Properties
	NotesTextViewPr *CT_NotesTextViewProperties

	// Slide Sorter View Properties
	SorterViewPr *CT_SlideSorterViewProperties

	// Notes View Properties
	NotesViewPr *CT_NotesViewProperties

	// Grid Spacing
	GridSpacing *_cb.CT_PositiveSize2D
	ExtLst      *CT_ExtensionList
}

func (_cefe ST_TLAnimateMotionPathEditMode) Validate() error { return _cefe.ValidateWithPath("") }

// Validate validates the CT_OutlineViewSlideEntry and its children
func (_cedd *CT_OutlineViewSlideEntry) Validate() error {
	return _cedd.ValidateWithPath("CT_OutlineViewSlideEntry")
}
func (_fgfbg *ST_ViewType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_fgfbg = 0
	case "sldView":
		*_fgfbg = 1
	case "sldMasterView":
		*_fgfbg = 2
	case "notesView":
		*_fgfbg = 3
	case "handoutView":
		*_fgfbg = 4
	case "notesMasterView":
		*_fgfbg = 5
	case "outlineView":
		*_fgfbg = 6
	case "sldSorterView":
		*_fgfbg = 7
	case "sldThumbnailView":
		*_fgfbg = 8
	}
	return nil
}
func (_bfcac *CmAuthorLst) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:cmAuthorLst"
	return _bfcac.CT_CommentAuthorList.MarshalXML(e, start)
}

const (
	ST_TLTriggerEventUnset       ST_TLTriggerEvent = 0
	ST_TLTriggerEventOnBegin     ST_TLTriggerEvent = 1
	ST_TLTriggerEventOnEnd       ST_TLTriggerEvent = 2
	ST_TLTriggerEventBegin       ST_TLTriggerEvent = 3
	ST_TLTriggerEventEnd         ST_TLTriggerEvent = 4
	ST_TLTriggerEventOnClick     ST_TLTriggerEvent = 5
	ST_TLTriggerEventOnDblClick  ST_TLTriggerEvent = 6
	ST_TLTriggerEventOnMouseOver ST_TLTriggerEvent = 7
	ST_TLTriggerEventOnMouseOut  ST_TLTriggerEvent = 8
	ST_TLTriggerEventOnNext      ST_TLTriggerEvent = 9
	ST_TLTriggerEventOnPrev      ST_TLTriggerEvent = 10
	ST_TLTriggerEventOnStopAudio ST_TLTriggerEvent = 11
)

// Validate validates the CT_TLTriggerTimeNodeID and its children
func (_feafa *CT_TLTriggerTimeNodeID) Validate() error {
	return _feafa.ValidateWithPath("CT_TLTriggerTimeNodeID")
}

// Validate validates the Sld and its children
func (_gadf *Sld) Validate() error { return _gadf.ValidateWithPath("Sld") }

// Validate validates the CT_ShowProperties and its children
func (_ddca *CT_ShowProperties) Validate() error { return _ddca.ValidateWithPath("CT_ShowProperties") }
func (_fbdeef ST_TLTimeNodeSyncType) String() string {
	switch _fbdeef {
	case 0:
		return ""
	case 1:
		return "canSlip"
	case 2:
		return "locked"
	}
	return ""
}
func (_edag *CT_SlideIdList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _edag.SldId != nil {
		_abbdc := _e.StartElement{Name: _e.Name{Local: "p:sldId"}}
		for _, _gedda := range _edag.SldId {
			e.EncodeElement(_gedda, _abbdc)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_dedg *CT_SlideTransition) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _gcea := range start.Attr {
		if _gcea.Name.Local == "spd" {
			_dedg.SpdAttr.UnmarshalXMLAttr(_gcea)
			continue
		}
		if _gcea.Name.Local == "advClick" {
			_dgga, _ecfea := _b.ParseBool(_gcea.Value)
			if _ecfea != nil {
				return _ecfea
			}
			_dedg.AdvClickAttr = &_dgga
			continue
		}
		if _gcea.Name.Local == "advTm" {
			_fadfc, _bafeg := _b.ParseUint(_gcea.Value, 10, 32)
			if _bafeg != nil {
				return _bafeg
			}
			_gcbe := uint32(_fadfc)
			_dedg.AdvTmAttr = &_gcbe
			continue
		}
	}
_bceb:
	for {
		_gdeg, _eecfg := d.Token()
		if _eecfg != nil {
			return _eecfg
		}
		switch _eada := _gdeg.(type) {
		case _e.StartElement:
			switch _eada.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "blinds"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "blinds"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _fbggc := d.DecodeElement(&_dedg.Choice.Blinds, &_eada); _fbggc != nil {
					return _fbggc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "checker"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "checker"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _edde := d.DecodeElement(&_dedg.Choice.Checker, &_eada); _edde != nil {
					return _edde
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "circle"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "circle"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _fdbbb := d.DecodeElement(&_dedg.Choice.Circle, &_eada); _fdbbb != nil {
					return _fdbbb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "dissolve"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "dissolve"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _fbfbf := d.DecodeElement(&_dedg.Choice.Dissolve, &_eada); _fbfbf != nil {
					return _fbfbf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "comb"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "comb"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _aefdc := d.DecodeElement(&_dedg.Choice.Comb, &_eada); _aefdc != nil {
					return _aefdc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cover"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cover"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _edfdge := d.DecodeElement(&_dedg.Choice.Cover, &_eada); _edfdge != nil {
					return _edfdge
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cut"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cut"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _ceece := d.DecodeElement(&_dedg.Choice.Cut, &_eada); _ceece != nil {
					return _ceece
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "diamond"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "diamond"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _edbce := d.DecodeElement(&_dedg.Choice.Diamond, &_eada); _edbce != nil {
					return _edbce
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "fade"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "fade"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _badg := d.DecodeElement(&_dedg.Choice.Fade, &_eada); _badg != nil {
					return _badg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "newsflash"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "newsflash"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _ebfgg := d.DecodeElement(&_dedg.Choice.Newsflash, &_eada); _ebfgg != nil {
					return _ebfgg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "plus"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "plus"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _ggag := d.DecodeElement(&_dedg.Choice.Plus, &_eada); _ggag != nil {
					return _ggag
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "pull"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "pull"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _eegcb := d.DecodeElement(&_dedg.Choice.Pull, &_eada); _eegcb != nil {
					return _eegcb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "push"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "push"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _ebgdc := d.DecodeElement(&_dedg.Choice.Push, &_eada); _ebgdc != nil {
					return _ebgdc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "random"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "random"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _cdeaa := d.DecodeElement(&_dedg.Choice.Random, &_eada); _cdeaa != nil {
					return _cdeaa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "randomBar"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "randomBar"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _gaef := d.DecodeElement(&_dedg.Choice.RandomBar, &_eada); _gaef != nil {
					return _gaef
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "split"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "split"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _ddfae := d.DecodeElement(&_dedg.Choice.Split, &_eada); _ddfae != nil {
					return _ddfae
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "strips"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "strips"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _ddea := d.DecodeElement(&_dedg.Choice.Strips, &_eada); _ddea != nil {
					return _ddea
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "wedge"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "wedge"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _baddf := d.DecodeElement(&_dedg.Choice.Wedge, &_eada); _baddf != nil {
					return _baddf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "wheel"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "wheel"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _ccfbb := d.DecodeElement(&_dedg.Choice.Wheel, &_eada); _ccfbb != nil {
					return _ccfbb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "wipe"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "wipe"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _bcedc := d.DecodeElement(&_dedg.Choice.Wipe, &_eada); _bcedc != nil {
					return _bcedc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "zoom"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "zoom"}:
				_dedg.Choice = NewCT_SlideTransitionChoice()
				if _dgbfc := d.DecodeElement(&_dedg.Choice.Zoom, &_eada); _dgbfc != nil {
					return _dgbfc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sndAc"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sndAc"}:
				_dedg.SndAc = NewCT_TransitionSoundAction()
				if _adfb := d.DecodeElement(_dedg.SndAc, &_eada); _adfb != nil {
					return _adfb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_dedg.ExtLst = NewCT_ExtensionListModify()
				if _faaa := d.DecodeElement(_dedg.ExtLst, &_eada); _faaa != nil {
					return _faaa
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_SlideTransition\u0020\u0025v", _eada.Name)
				if _bgcgc := d.Skip(); _bgcgc != nil {
					return _bgcgc
				}
			}
		case _e.EndElement:
			break _bceb
		case _e.CharData:
		}
	}
	return nil
}

const (
	ST_DirectionUnset ST_Direction = 0
	ST_DirectionHorz  ST_Direction = 1
	ST_DirectionVert  ST_Direction = 2
)

func NewSldLayout() *SldLayout {
	_bafbeg := &SldLayout{}
	_bafbeg.CT_SlideLayout = *NewCT_SlideLayout()
	return _bafbeg
}

type CT_HandoutMasterIdListEntry struct {
	IdAttr string
	ExtLst *CT_ExtensionList
}

func NewCT_Background() *CT_Background { _dbf := &CT_Background{}; return _dbf }
func (_ef *AG_ChildSlide) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ef.ShowMasterSpAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showMasterSp"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ef.ShowMasterSpAttr))})
	}
	if _ef.ShowMasterPhAnimAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showMasterPhAnim"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ef.ShowMasterPhAnimAttr))})
	}
	return nil
}
func (_dafed ST_SlideSizeType) Validate() error { return _dafed.ValidateWithPath("") }
func (_ddgb *CT_NormalViewPortion) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _fcad := range start.Attr {
		if _fcad.Name.Local == "sz" {
			_gbae, _gebb := ParseUnionST_PositiveFixedPercentage(_fcad.Value)
			if _gebb != nil {
				return _gebb
			}
			_ddgb.SzAttr = _gbae
			continue
		}
		if _fcad.Name.Local == "autoAdjust" {
			_cdga, _afgfe := _b.ParseBool(_fcad.Value)
			if _afgfe != nil {
				return _afgfe
			}
			_ddgb.AutoAdjustAttr = &_cdga
			continue
		}
	}
	for {
		_gaca, _ccgb := d.Token()
		if _ccgb != nil {
			return _c.Errorf("parsing\u0020CT_NormalViewPortion:\u0020\u0025s", _ccgb)
		}
		if _gde, _fbce := _gaca.(_e.EndElement); _fbce && _gde.Name == start.Name {
			break
		}
	}
	return nil
}

type ST_TLBehaviorTransformType byte

func (_acabg *CT_Shape) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _acabg.UseBgFillAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "useBgFill"}, Value: _c.Sprintf("\u0025d", _fdeab(*_acabg.UseBgFillAttr))})
	}
	e.EncodeToken(start)
	_aefcg := _e.StartElement{Name: _e.Name{Local: "p:nvSpPr"}}
	e.EncodeElement(_acabg.NvSpPr, _aefcg)
	_daae := _e.StartElement{Name: _e.Name{Local: "p:spPr"}}
	e.EncodeElement(_acabg.SpPr, _daae)
	if _acabg.Style != nil {
		_cfff := _e.StartElement{Name: _e.Name{Local: "p:style"}}
		e.EncodeElement(_acabg.Style, _cfff)
	}
	if _acabg.TxBody != nil {
		_feafb := _e.StartElement{Name: _e.Name{Local: "p:txBody"}}
		e.EncodeElement(_acabg.TxBody, _feafb)
	}
	if _acabg.ExtLst != nil {
		_egfc := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_acabg.ExtLst, _egfc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_ShapeNonVisual and its children, prefixing error messages with path
func (_afae *CT_ShapeNonVisual) ValidateWithPath(path string) error {
	if _gbca := _afae.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _gbca != nil {
		return _gbca
	}
	if _ebda := _afae.CNvSpPr.ValidateWithPath(path + "\u002fCNvSpPr"); _ebda != nil {
		return _ebda
	}
	if _ceba := _afae.NvPr.ValidateWithPath(path + "\u002fNvPr"); _ceba != nil {
		return _ceba
	}
	return nil
}
func (_cacdb *SldMaster) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cacdb.CT_SlideMaster = *NewCT_SlideMaster()
	for _, _fbaef := range start.Attr {
		if _fbaef.Name.Local == "preserve" {
			_eaed, _fbef := _b.ParseBool(_fbaef.Value)
			if _fbef != nil {
				return _fbef
			}
			_cacdb.PreserveAttr = &_eaed
			continue
		}
	}
_abebf:
	for {
		_dddff, _bdada := d.Token()
		if _bdada != nil {
			return _bdada
		}
		switch _baabd := _dddff.(type) {
		case _e.StartElement:
			switch _baabd.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _deacg := d.DecodeElement(_cacdb.CSld, &_baabd); _deacg != nil {
					return _deacg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMap"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMap"}:
				if _dbbe := d.DecodeElement(_cacdb.ClrMap, &_baabd); _dbbe != nil {
					return _dbbe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldLayoutIdLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldLayoutIdLst"}:
				_cacdb.SldLayoutIdLst = NewCT_SlideLayoutIdList()
				if _eefb := d.DecodeElement(_cacdb.SldLayoutIdLst, &_baabd); _eefb != nil {
					return _eefb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "transition"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "transition"}:
				_cacdb.Transition = NewCT_SlideTransition()
				if _dceg := d.DecodeElement(_cacdb.Transition, &_baabd); _dceg != nil {
					return _dceg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "timing"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "timing"}:
				_cacdb.Timing = NewCT_SlideTiming()
				if _egefc := d.DecodeElement(_cacdb.Timing, &_baabd); _egefc != nil {
					return _egefc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "hf"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "hf"}:
				_cacdb.Hf = NewCT_HeaderFooter()
				if _aafa := d.DecodeElement(_cacdb.Hf, &_baabd); _aafa != nil {
					return _aafa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "txStyles"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "txStyles"}:
				_cacdb.TxStyles = NewCT_SlideMasterTextStyles()
				if _egcbd := d.DecodeElement(_cacdb.TxStyles, &_baabd); _egcbd != nil {
					return _egcbd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_cacdb.ExtLst = NewCT_ExtensionListModify()
				if _gggga := d.DecodeElement(_cacdb.ExtLst, &_baabd); _gggga != nil {
					return _gggga
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on SldMaster \u0025v", _baabd.Name)
				if _gcagg := d.Skip(); _gcagg != nil {
					return _gcagg
				}
			}
		case _e.EndElement:
			break _abebf
		case _e.CharData:
		}
	}
	return nil
}

// ST_TLTimeAnimateValueTime is a union type
type ST_TLTimeAnimateValueTime struct {
	ST_PositiveFixedPercentage *_cb.ST_PositiveFixedPercentage
	ST_TLTimeIndefinite        ST_TLTimeIndefinite
}

func (_fcab *CT_PrintProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _fcab.PrnWhatAttr != ST_PrintWhatUnset {
		_dagf, _affe := _fcab.PrnWhatAttr.MarshalXMLAttr(_e.Name{Local: "prnWhat"})
		if _affe != nil {
			return _affe
		}
		start.Attr = append(start.Attr, _dagf)
	}
	if _fcab.ClrModeAttr != ST_PrintColorModeUnset {
		_ggbaa, _aafcd := _fcab.ClrModeAttr.MarshalXMLAttr(_e.Name{Local: "clrMode"})
		if _aafcd != nil {
			return _aafcd
		}
		start.Attr = append(start.Attr, _ggbaa)
	}
	if _fcab.HiddenSlidesAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "hiddenSlides"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fcab.HiddenSlidesAttr))})
	}
	if _fcab.ScaleToFitPaperAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "scaleToFitPaper"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fcab.ScaleToFitPaperAttr))})
	}
	if _fcab.FrameSlidesAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "frameSlides"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fcab.FrameSlidesAttr))})
	}
	e.EncodeToken(start)
	if _fcab.ExtLst != nil {
		_dcfga := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_fcab.ExtLst, _dcfga)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_TransitionSoundAction struct {

	// Start Sound Action
	StSnd *CT_TransitionStartSoundAction

	// Stop Sound Action
	EndSnd *CT_Empty
}

func (_ddcdf *CT_TLTimeAnimateValueList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_edccd:
	for {
		_eabe, _gdbef := d.Token()
		if _gdbef != nil {
			return _gdbef
		}
		switch _egaca := _eabe.(type) {
		case _e.StartElement:
			switch _egaca.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tav"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tav"}:
				_gdfge := NewCT_TLTimeAnimateValue()
				if _ggcba := d.DecodeElement(_gdfge, &_egaca); _ggcba != nil {
					return _ggcba
				}
				_ddcdf.Tav = append(_ddcdf.Tav, _gdfge)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLTimeAnimateValueList\u0020\u0025v", _egaca.Name)
				if _aaeb := d.Skip(); _aaeb != nil {
					return _aaeb
				}
			}
		case _e.EndElement:
			break _edccd
		case _e.CharData:
		}
	}
	return nil
}

type ST_TLBehaviorOverrideType byte

func NewCT_Empty() *CT_Empty { _gcaa := &CT_Empty{}; return _gcaa }
func NewCT_TLAnimateColorBehavior() *CT_TLAnimateColorBehavior {
	_gcfe := &CT_TLAnimateColorBehavior{}
	_gcfe.CBhvr = NewCT_TLCommonBehaviorData()
	return _gcfe
}

// ValidateWithPath validates the CT_InOutTransition and its children, prefixing error messages with path
func (_ccef *CT_InOutTransition) ValidateWithPath(path string) error {
	if _feea := _ccef.DirAttr.ValidateWithPath(path + "\u002fDirAttr"); _feea != nil {
		return _feea
	}
	return nil
}
func NewCT_SlideMasterTextStyles() *CT_SlideMasterTextStyles {
	_afgff := &CT_SlideMasterTextStyles{}
	return _afgff
}

// ValidateWithPath validates the CT_GroupShapeNonVisual and its children, prefixing error messages with path
func (_ecba *CT_GroupShapeNonVisual) ValidateWithPath(path string) error {
	if _afed := _ecba.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _afed != nil {
		return _afed
	}
	if _faec := _ecba.CNvGrpSpPr.ValidateWithPath(path + "/CNvGrpSpPr"); _faec != nil {
		return _faec
	}
	if _gegb := _ecba.NvPr.ValidateWithPath(path + "\u002fNvPr"); _gegb != nil {
		return _gegb
	}
	return nil
}

type CT_TLAnimateMotionBehavior struct {

	// Origin
	OriginAttr ST_TLAnimateMotionBehaviorOrigin

	// Path
	PathAttr *string

	// Path Edit Mode
	PathEditModeAttr ST_TLAnimateMotionPathEditMode

	// Relative Angle
	RAngAttr *int32

	// Points Types
	PtsTypesAttr *string
	CBhvr        *CT_TLCommonBehaviorData
	By           *CT_TLPoint

	// From
	From *CT_TLPoint
	To   *CT_TLPoint

	// Rotation Center
	RCtr *CT_TLPoint
}

func (_faeg *CT_GroupShape) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_cbgb := _e.StartElement{Name: _e.Name{Local: "p:nvGrpSpPr"}}
	e.EncodeElement(_faeg.NvGrpSpPr, _cbgb)
	_eccc := _e.StartElement{Name: _e.Name{Local: "p:grpSpPr"}}
	e.EncodeElement(_faeg.GrpSpPr, _eccc)
	if _faeg.Choice != nil {
		for _, _ffbc := range _faeg.Choice {
			_ffbc.MarshalXML(e, _e.StartElement{})
		}
	}
	if _faeg.ExtLst != nil {
		_cbfb := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_faeg.ExtLst, _cbfb)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_eefee *ST_TLTimeNodePresetClassType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_eefee = 0
	case "entr":
		*_eefee = 1
	case "exit":
		*_eefee = 2
	case "emph":
		*_eefee = 3
	case "path":
		*_eefee = 4
	case "verb":
		*_eefee = 5
	case "mediacall":
		*_eefee = 6
	}
	return nil
}

// Validate validates the CT_CommentAuthorList and its children
func (_aga *CT_CommentAuthorList) Validate() error {
	return _aga.ValidateWithPath("CT_CommentAuthorList")
}
func NewCT_TagsData() *CT_TagsData { _geaa := &CT_TagsData{}; return _geaa }

const (
	ST_IterateTypeUnset ST_IterateType = 0
	ST_IterateTypeEl    ST_IterateType = 1
	ST_IterateTypeWd    ST_IterateType = 2
	ST_IterateTypeLt    ST_IterateType = 3
)

// ValidateWithPath validates the CT_EmbeddedFontListEntry and its children, prefixing error messages with path
func (_agbf *CT_EmbeddedFontListEntry) ValidateWithPath(path string) error {
	if _bccd := _agbf.Font.ValidateWithPath(path + "\u002fFont"); _bccd != nil {
		return _bccd
	}
	if _agbf.Regular != nil {
		if _ceceb := _agbf.Regular.ValidateWithPath(path + "\u002fRegular"); _ceceb != nil {
			return _ceceb
		}
	}
	if _agbf.Bold != nil {
		if _ceeg := _agbf.Bold.ValidateWithPath(path + "\u002fBold"); _ceeg != nil {
			return _ceeg
		}
	}
	if _agbf.Italic != nil {
		if _ecdb := _agbf.Italic.ValidateWithPath(path + "\u002fItalic"); _ecdb != nil {
			return _ecdb
		}
	}
	if _agbf.BoldItalic != nil {
		if _agec := _agbf.BoldItalic.ValidateWithPath(path + "/BoldItalic"); _agec != nil {
			return _agec
		}
	}
	return nil
}
func (_aeded *CT_SlideSize) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_aeded.CxAttr = 914400
	_aeded.CyAttr = 914400
	for _, _aeggba := range start.Attr {
		if _aeggba.Name.Local == "cx" {
			_abec, _efadd := _b.ParseInt(_aeggba.Value, 10, 32)
			if _efadd != nil {
				return _efadd
			}
			_aeded.CxAttr = int32(_abec)
			continue
		}
		if _aeggba.Name.Local == "cy" {
			_ggcb, _aacb := _b.ParseInt(_aeggba.Value, 10, 32)
			if _aacb != nil {
				return _aacb
			}
			_aeded.CyAttr = int32(_ggcb)
			continue
		}
		if _aeggba.Name.Local == "type" {
			_aeded.TypeAttr.UnmarshalXMLAttr(_aeggba)
			continue
		}
	}
	for {
		_dega, _gbdfe := d.Token()
		if _gbdfe != nil {
			return _c.Errorf("parsing\u0020CT_SlideSize:\u0020\u0025s", _gbdfe)
		}
		if _gabf, _baee := _dega.(_e.EndElement); _baee && _gabf.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_TLAnimVariant() *CT_TLAnimVariant                  { _bdffb := &CT_TLAnimVariant{}; return _bdffb }
func (_edgbbf ST_TLAnimateBehaviorValueType) Validate() error { return _edgbbf.ValidateWithPath("") }
func (_bcffc ST_TLTimeNodePresetClassType) String() string {
	switch _bcffc {
	case 0:
		return ""
	case 1:
		return "entr"
	case 2:
		return "exit"
	case 3:
		return "emph"
	case 4:
		return "path"
	case 5:
		return "verb"
	case 6:
		return "mediacall"
	}
	return ""
}
func (_adgc *CT_CustomShow) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_adgc.SldLst = NewCT_SlideRelationshipList()
	for _, _gcf := range start.Attr {
		if _gcf.Name.Local == "name" {
			_dcea, _cfbc := _gcf.Value, error(nil)
			if _cfbc != nil {
				return _cfbc
			}
			_adgc.NameAttr = _dcea
			continue
		}
		if _gcf.Name.Local == "id" {
			_bfbc, _fgg := _b.ParseUint(_gcf.Value, 10, 32)
			if _fgg != nil {
				return _fgg
			}
			_adgc.IdAttr = uint32(_bfbc)
			continue
		}
	}
_gafe:
	for {
		_cagg, _fegg := d.Token()
		if _fegg != nil {
			return _fegg
		}
		switch _agaf := _cagg.(type) {
		case _e.StartElement:
			switch _agaf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldLst"}:
				if _bbfc := d.DecodeElement(_adgc.SldLst, &_agaf); _bbfc != nil {
					return _bbfc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_adgc.ExtLst = NewCT_ExtensionList()
				if _ceff := d.DecodeElement(_adgc.ExtLst, &_agaf); _ceff != nil {
					return _ceff
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_CustomShow \u0025v", _agaf.Name)
				if _fgbb := d.Skip(); _fgbb != nil {
					return _fgbb
				}
			}
		case _e.EndElement:
			break _gafe
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the AG_TLBuild and its children, prefixing error messages with path
func (_fbg *AG_TLBuild) ValidateWithPath(path string) error { return nil }
func (_abgdg *CT_SlideSize) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "cx"}, Value: _c.Sprintf("\u0025v", _abgdg.CxAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "cy"}, Value: _c.Sprintf("\u0025v", _abgdg.CyAttr)})
	if _abgdg.TypeAttr != ST_SlideSizeTypeUnset {
		_dgcbb, _gdcf := _abgdg.TypeAttr.MarshalXMLAttr(_e.Name{Local: "type"})
		if _gdcf != nil {
			return _gdcf
		}
		start.Attr = append(start.Attr, _dgcbb)
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_Shape struct {

	// Use Background Fill
	UseBgFillAttr *bool

	// Non-Visual Properties for a Shape
	NvSpPr *CT_ShapeNonVisual
	SpPr   *_cb.CT_ShapeProperties

	// Shape Style
	Style *_cb.CT_ShapeStyle

	// Shape Text Body
	TxBody *_cb.CT_TextBody
	ExtLst *CT_ExtensionListModify
}
type ST_TLAnimateColorDirection byte

func (_egage ST_TransitionSideDirectionType) ValidateWithPath(path string) error {
	switch _egage {
	case 0, 1, 2, 3, 4:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_egage))
	}
	return nil
}

// ValidateWithPath validates the CT_Placeholder and its children, prefixing error messages with path
func (_dddf *CT_Placeholder) ValidateWithPath(path string) error {
	if _gbdf := _dddf.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _gbdf != nil {
		return _gbdf
	}
	if _aegc := _dddf.OrientAttr.ValidateWithPath(path + "/OrientAttr"); _aegc != nil {
		return _aegc
	}
	if _eagg := _dddf.SzAttr.ValidateWithPath(path + "\u002fSzAttr"); _eagg != nil {
		return _eagg
	}
	if _dddf.ExtLst != nil {
		if _bcfe := _dddf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bcfe != nil {
			return _bcfe
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TLTimeAnimateValueList and its children, prefixing error messages with path
func (_aaaf *CT_TLTimeAnimateValueList) ValidateWithPath(path string) error {
	for _abgdd, _efccfc := range _aaaf.Tav {
		if _egae := _efccfc.ValidateWithPath(_c.Sprintf("\u0025s\u002fTav\u005b\u0025d\u005d", path, _abgdd)); _egae != nil {
			return _egae
		}
	}
	return nil
}

type Sld struct{ CT_Slide }

func (_dbaaf *ST_TLAnimateColorDirection) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_dbaaf = 0
	case "cw":
		*_dbaaf = 1
	case "ccw":
		*_dbaaf = 2
	}
	return nil
}
func (_efdca *ST_ViewType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cbfbf, _cdeaf := d.Token()
	if _cdeaf != nil {
		return _cdeaf
	}
	if _febd, _fcaef := _cbfbf.(_e.EndElement); _fcaef && _febd.Name == start.Name {
		*_efdca = 1
		return nil
	}
	if _ebfgd, _fead := _cbfbf.(_e.CharData); !_fead {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cbfbf)
	} else {
		switch string(_ebfgd) {
		case "":
			*_efdca = 0
		case "sldView":
			*_efdca = 1
		case "sldMasterView":
			*_efdca = 2
		case "notesView":
			*_efdca = 3
		case "handoutView":
			*_efdca = 4
		case "notesMasterView":
			*_efdca = 5
		case "outlineView":
			*_efdca = 6
		case "sldSorterView":
			*_efdca = 7
		case "sldThumbnailView":
			*_efdca = 8
		}
	}
	_cbfbf, _cdeaf = d.Token()
	if _cdeaf != nil {
		return _cdeaf
	}
	if _bcgff, _ebaeg := _cbfbf.(_e.EndElement); _ebaeg && _bcgff.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cbfbf)
}
func (_fcea ST_TLBehaviorAdditiveType) ValidateWithPath(path string) error {
	switch _fcea {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fcea))
	}
	return nil
}
func (_cfggd ST_TransitionSpeed) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_gbfaa := _e.Attr{}
	_gbfaa.Name = name
	switch _cfggd {
	case ST_TransitionSpeedUnset:
		_gbfaa.Value = ""
	case ST_TransitionSpeedSlow:
		_gbfaa.Value = "slow"
	case ST_TransitionSpeedMed:
		_gbfaa.Value = "med"
	case ST_TransitionSpeedFast:
		_gbfaa.Value = "fast"
	}
	return _gbfaa, nil
}
func (_cebgfg *ST_WebScreenSize) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_acfea, _dagcc := d.Token()
	if _dagcc != nil {
		return _dagcc
	}
	if _fdcbf, _bfacb := _acfea.(_e.EndElement); _bfacb && _fdcbf.Name == start.Name {
		*_cebgfg = 1
		return nil
	}
	if _dffbd, _daeea := _acfea.(_e.CharData); !_daeea {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _acfea)
	} else {
		switch string(_dffbd) {
		case "":
			*_cebgfg = 0
		case "544x376":
			*_cebgfg = 1
		case "640x480":
			*_cebgfg = 2
		case "720x512":
			*_cebgfg = 3
		case "800x600":
			*_cebgfg = 4
		case "1024x768":
			*_cebgfg = 5
		case "1152x882":
			*_cebgfg = 6
		case "1152x900":
			*_cebgfg = 7
		case "1280x1024":
			*_cebgfg = 8
		case "1600x1200":
			*_cebgfg = 9
		case "1800x1400":
			*_cebgfg = 10
		case "1920x1200":
			*_cebgfg = 11
		}
	}
	_acfea, _dagcc = d.Token()
	if _dagcc != nil {
		return _dagcc
	}
	if _gecdf, _feac := _acfea.(_e.EndElement); _feac && _gecdf.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _acfea)
}
func (_afbff *ST_TLCommandType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_afbff = 0
	case "evt":
		*_afbff = 1
	case "call":
		*_afbff = 2
	case "verb":
		*_afbff = 3
	}
	return nil
}
func NewCT_TLByAnimateColorTransform() *CT_TLByAnimateColorTransform {
	_ggdgc := &CT_TLByAnimateColorTransform{}
	return _ggdgc
}

// Validate validates the CT_TLAnimateMotionBehavior and its children
func (_dcebe *CT_TLAnimateMotionBehavior) Validate() error {
	return _dcebe.ValidateWithPath("CT_TLAnimateMotionBehavior")
}
func (_fedbfb *ST_TLTimeNodeSyncType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_fedbfb = 0
	case "canSlip":
		*_fedbfb = 1
	case "locked":
		*_fedbfb = 2
	}
	return nil
}
func (_dgg *CT_CustomShowList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_edcg:
	for {
		_gffa, _bdeea := d.Token()
		if _bdeea != nil {
			return _bdeea
		}
		switch _afag := _gffa.(type) {
		case _e.StartElement:
			switch _afag.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "custShow"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "custShow"}:
				_cbff := NewCT_CustomShow()
				if _gcdd := d.DecodeElement(_cbff, &_afag); _gcdd != nil {
					return _gcdd
				}
				_dgg.CustShow = append(_dgg.CustShow, _cbff)
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_CustomShowList\u0020\u0025v", _afag.Name)
				if _gbgg := d.Skip(); _gbgg != nil {
					return _gbgg
				}
			}
		case _e.EndElement:
			break _edcg
		case _e.CharData:
		}
	}
	return nil
}
func (_dbgdg *ST_TLAnimateBehaviorValueType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_dbgdg = 0
	case "str":
		*_dbgdg = 1
	case "num":
		*_dbgdg = 2
	case "clr":
		*_dbgdg = 3
	}
	return nil
}
func (_aagbg *CT_TLCommonBehaviorData) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_aagbg.CTn = NewCT_TLCommonTimeNodeData()
	_aagbg.TgtEl = NewCT_TLTimeTargetElement()
	for _, _geabc := range start.Attr {
		if _geabc.Name.Local == "additive" {
			_aagbg.AdditiveAttr.UnmarshalXMLAttr(_geabc)
			continue
		}
		if _geabc.Name.Local == "accumulate" {
			_aagbg.AccumulateAttr.UnmarshalXMLAttr(_geabc)
			continue
		}
		if _geabc.Name.Local == "xfrmType" {
			_aagbg.XfrmTypeAttr.UnmarshalXMLAttr(_geabc)
			continue
		}
		if _geabc.Name.Local == "from" {
			_gffbe, _gcee := _geabc.Value, error(nil)
			if _gcee != nil {
				return _gcee
			}
			_aagbg.FromAttr = &_gffbe
			continue
		}
		if _geabc.Name.Local == "to" {
			_abege, _efggc := _geabc.Value, error(nil)
			if _efggc != nil {
				return _efggc
			}
			_aagbg.ToAttr = &_abege
			continue
		}
		if _geabc.Name.Local == "by" {
			_eabfb, _gbeba := _geabc.Value, error(nil)
			if _gbeba != nil {
				return _gbeba
			}
			_aagbg.ByAttr = &_eabfb
			continue
		}
		if _geabc.Name.Local == "rctx" {
			_edgbg, _ebgeb := _geabc.Value, error(nil)
			if _ebgeb != nil {
				return _ebgeb
			}
			_aagbg.RctxAttr = &_edgbg
			continue
		}
		if _geabc.Name.Local == "override" {
			_aagbg.OverrideAttr.UnmarshalXMLAttr(_geabc)
			continue
		}
	}
_abfbf:
	for {
		_gcegd, _egec := d.Token()
		if _egec != nil {
			return _egec
		}
		switch _abed := _gcegd.(type) {
		case _e.StartElement:
			switch _abed.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cTn"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cTn"}:
				if _eccea := d.DecodeElement(_aagbg.CTn, &_abed); _eccea != nil {
					return _eccea
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tgtEl"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tgtEl"}:
				if _bgab := d.DecodeElement(_aagbg.TgtEl, &_abed); _bgab != nil {
					return _bgab
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "attrNameLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "attrNameLst"}:
				_aagbg.AttrNameLst = NewCT_TLBehaviorAttributeNameList()
				if _fffgf := d.DecodeElement(_aagbg.AttrNameLst, &_abed); _fffgf != nil {
					return _fffgf
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_TLCommonBehaviorData \u0025v", _abed.Name)
				if _dfbaac := d.Skip(); _dfbaac != nil {
					return _dfbaac
				}
			}
		case _e.EndElement:
			break _abfbf
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_HandoutMaster and its children
func (_bfg *CT_HandoutMaster) Validate() error { return _bfg.ValidateWithPath("CT_HandoutMaster") }
func (_ffda *CT_SlideSyncProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "serverSldId"}, Value: _c.Sprintf("\u0025v", _ffda.ServerSldIdAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "serverSldModifiedTime"}, Value: _c.Sprintf("\u0025v", _ffda.ServerSldModifiedTimeAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "clientInsertedTime"}, Value: _c.Sprintf("\u0025v", _ffda.ClientInsertedTimeAttr)})
	e.EncodeToken(start)
	if _ffda.ExtLst != nil {
		_gegaa := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ffda.ExtLst, _gegaa)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_bgdb *CT_GuideList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _bgdb.Guide != nil {
		_begb := _e.StartElement{Name: _e.Name{Local: "p:guide"}}
		for _, _adbg := range _bgdb.Guide {
			e.EncodeElement(_adbg, _begb)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_ffggf ST_TLTimeNodeFillType) String() string {
	switch _ffggf {
	case 0:
		return ""
	case 1:
		return "remove"
	case 2:
		return "freeze"
	case 3:
		return "hold"
	case 4:
		return "transition"
	}
	return ""
}

// ValidateWithPath validates the CT_TimeNodeList and its children, prefixing error messages with path
func (_ceef *CT_TimeNodeList) ValidateWithPath(path string) error {
	for _cgdaa, _aedf := range _ceef.Par {
		if _begaf := _aedf.ValidateWithPath(_c.Sprintf("\u0025s\u002fPar\u005b\u0025d\u005d", path, _cgdaa)); _begaf != nil {
			return _begaf
		}
	}
	for _ecacf, _efgfd := range _ceef.Seq {
		if _fecgg := _efgfd.ValidateWithPath(_c.Sprintf("\u0025s\u002fSeq\u005b\u0025d\u005d", path, _ecacf)); _fecgg != nil {
			return _fecgg
		}
	}
	for _dcaee, _ffddf := range _ceef.Excl {
		if _daeee := _ffddf.ValidateWithPath(_c.Sprintf("%s\u002fExcl\u005b\u0025d\u005d", path, _dcaee)); _daeee != nil {
			return _daeee
		}
	}
	for _ddedcb, _bebg := range _ceef.Anim {
		if _dbedd := _bebg.ValidateWithPath(_c.Sprintf("%s\u002fAnim\u005b\u0025d\u005d", path, _ddedcb)); _dbedd != nil {
			return _dbedd
		}
	}
	for _dgbec, _abfbc := range _ceef.AnimClr {
		if _bagg := _abfbc.ValidateWithPath(_c.Sprintf("\u0025s\u002fAnimClr\u005b\u0025d\u005d", path, _dgbec)); _bagg != nil {
			return _bagg
		}
	}
	for _ecbga, _bada := range _ceef.AnimEffect {
		if _edfde := _bada.ValidateWithPath(_c.Sprintf("\u0025s\u002fAnimEffect\u005b\u0025d\u005d", path, _ecbga)); _edfde != nil {
			return _edfde
		}
	}
	for _dfbc, _ecgad := range _ceef.AnimMotion {
		if _cabb := _ecgad.ValidateWithPath(_c.Sprintf("\u0025s\u002fAnimMotion\u005b\u0025d\u005d", path, _dfbc)); _cabb != nil {
			return _cabb
		}
	}
	for _bdfg, _ggedg := range _ceef.AnimRot {
		if _ddbgd := _ggedg.ValidateWithPath(_c.Sprintf("\u0025s\u002fAnimRot\u005b\u0025d\u005d", path, _bdfg)); _ddbgd != nil {
			return _ddbgd
		}
	}
	for _ebafaa, _cdgba := range _ceef.AnimScale {
		if _bfedf := _cdgba.ValidateWithPath(_c.Sprintf("\u0025s/AnimScale\u005b\u0025d\u005d", path, _ebafaa)); _bfedf != nil {
			return _bfedf
		}
	}
	for _bbcd, _bbgcg := range _ceef.Cmd {
		if _aedea := _bbgcg.ValidateWithPath(_c.Sprintf("\u0025s\u002fCmd\u005b\u0025d\u005d", path, _bbcd)); _aedea != nil {
			return _aedea
		}
	}
	for _dddd, _cbeb := range _ceef.Set {
		if _cbcd := _cbeb.ValidateWithPath(_c.Sprintf("\u0025s\u002fSet\u005b\u0025d\u005d", path, _dddd)); _cbcd != nil {
			return _cbcd
		}
	}
	for _efge, _gcefb := range _ceef.Audio {
		if _abag := _gcefb.ValidateWithPath(_c.Sprintf("\u0025s\u002fAudio\u005b\u0025d\u005d", path, _efge)); _abag != nil {
			return _abag
		}
	}
	for _baebb, _dafe := range _ceef.Video {
		if _fgcfg := _dafe.ValidateWithPath(_c.Sprintf("\u0025s\u002fVideo\u005b\u0025d\u005d", path, _baebb)); _fgcfg != nil {
			return _fgcfg
		}
	}
	return nil
}
func (_edgb *CT_CommonViewProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_edgb.Scale = _cb.NewCT_Scale2D()
	_edgb.Origin = _cb.NewCT_Point2D()
	for _, _bfacd := range start.Attr {
		if _bfacd.Name.Local == "varScale" {
			_gcdg, _ffb := _b.ParseBool(_bfacd.Value)
			if _ffb != nil {
				return _ffb
			}
			_edgb.VarScaleAttr = &_gcdg
			continue
		}
	}
_fgd:
	for {
		_cfe, _cae := d.Token()
		if _cae != nil {
			return _cae
		}
		switch _gcbd := _cfe.(type) {
		case _e.StartElement:
			switch _gcbd.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "scale"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "scale"}:
				if _ccf := d.DecodeElement(_edgb.Scale, &_gcbd); _ccf != nil {
					return _ccf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "origin"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "origin"}:
				if _acba := d.DecodeElement(_edgb.Origin, &_gcbd); _acba != nil {
					return _acba
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_CommonViewProperties \u0025v", _gcbd.Name)
				if _abea := d.Skip(); _abea != nil {
					return _abea
				}
			}
		case _e.EndElement:
			break _fgd
		case _e.CharData:
		}
	}
	return nil
}
func (_afdaa *Notes) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_afdaa.CT_NotesSlide = *NewCT_NotesSlide()
	for _, _bbdge := range start.Attr {
		if _bbdge.Name.Local == "showMasterSp" {
			_gfcda, _bcaea := _b.ParseBool(_bbdge.Value)
			if _bcaea != nil {
				return _bcaea
			}
			_afdaa.ShowMasterSpAttr = &_gfcda
			continue
		}
		if _bbdge.Name.Local == "showMasterPhAnim" {
			_ggfgb, _bgbba := _b.ParseBool(_bbdge.Value)
			if _bgbba != nil {
				return _bgbba
			}
			_afdaa.ShowMasterPhAnimAttr = &_ggfgb
			continue
		}
	}
_bacf:
	for {
		_fcdc, _adgcb := d.Token()
		if _adgcb != nil {
			return _adgcb
		}
		switch _baeef := _fcdc.(type) {
		case _e.StartElement:
			switch _baeef.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _gdgbf := d.DecodeElement(_afdaa.CSld, &_baeef); _gdgbf != nil {
					return _gdgbf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMapOvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMapOvr"}:
				_afdaa.ClrMapOvr = _cb.NewCT_ColorMappingOverride()
				if _ccfcc := d.DecodeElement(_afdaa.ClrMapOvr, &_baeef); _ccfcc != nil {
					return _ccfcc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_afdaa.ExtLst = NewCT_ExtensionListModify()
				if _fedbd := d.DecodeElement(_afdaa.ExtLst, &_baeef); _fedbd != nil {
					return _fedbd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on Notes \u0025v", _baeef.Name)
				if _gbceb := d.Skip(); _gbceb != nil {
					return _gbceb
				}
			}
		case _e.EndElement:
			break _bacf
		case _e.CharData:
		}
	}
	return nil
}
func (_gbf *CT_ControlList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _gbf.Control != nil {
		_ffbb := _e.StartElement{Name: _e.Name{Local: "p:control"}}
		for _, _gafd := range _gbf.Control {
			e.EncodeElement(_gafd, _ffbb)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_SmartTags() *CT_SmartTags { _efea := &CT_SmartTags{}; return _efea }
func (_daafd ST_TLAnimateBehaviorCalcMode) ValidateWithPath(path string) error {
	switch _daafd {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_daafd))
	}
	return nil
}

// Validate validates the CT_SmartTags and its children
func (_eeca *CT_SmartTags) Validate() error { return _eeca.ValidateWithPath("CT_SmartTags") }
func (_bcfc *CT_TLByRgbColorTransform) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _fccd := range start.Attr {
		if _fccd.Name.Local == "r" {
			_fgdf, _fdaf := ParseUnionST_FixedPercentage(_fccd.Value)
			if _fdaf != nil {
				return _fdaf
			}
			_bcfc.RAttr = _fgdf
			continue
		}
		if _fccd.Name.Local == "g" {
			_abbdf, _dabgga := ParseUnionST_FixedPercentage(_fccd.Value)
			if _dabgga != nil {
				return _dabgga
			}
			_bcfc.GAttr = _abbdf
			continue
		}
		if _fccd.Name.Local == "b" {
			_ebab, _feda := ParseUnionST_FixedPercentage(_fccd.Value)
			if _feda != nil {
				return _feda
			}
			_bcfc.BAttr = _ebab
			continue
		}
	}
	for {
		_cced, _bdggd := d.Token()
		if _bdggd != nil {
			return _c.Errorf("parsing CT_TLByRgbColorTransform:\u0020%s", _bdggd)
		}
		if _bdaeb, _fcfg := _cced.(_e.EndElement); _fcfg && _bdaeb.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_TLAnimVariant and its children
func (_fbbb *CT_TLAnimVariant) Validate() error { return _fbbb.ValidateWithPath("CT_TLAnimVariant") }

// Validate validates the SldLayout and its children
func (_dceaf *SldLayout) Validate() error    { return _dceaf.ValidateWithPath("SldLayout") }
func NewCT_ExtensionList() *CT_ExtensionList { _becf := &CT_ExtensionList{}; return _becf }
func (_fcbb *CT_TLSubShapeId) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spid"}, Value: _c.Sprintf("\u0025v", _fcbb.SpidAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_CornerDirectionTransition and its children, prefixing error messages with path
func (_egaa *CT_CornerDirectionTransition) ValidateWithPath(path string) error {
	if _fed := _egaa.DirAttr.ValidateWithPath(path + "\u002fDirAttr"); _fed != nil {
		return _fed
	}
	return nil
}
func (_fffgd ST_IterateType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_fffgd.String(), start)
}
func (_aaag *CT_TLPoint) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "x"}, Value: _c.Sprintf("\u0025v", _aaag.XAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "y"}, Value: _c.Sprintf("\u0025v", _aaag.YAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_daggge *CT_TLMediaNodeVideo) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_daggge.CMediaNode = NewCT_TLCommonMediaNodeData()
	for _, _gedeb := range start.Attr {
		if _gedeb.Name.Local == "fullScrn" {
			_gdcde, _adeedf := _b.ParseBool(_gedeb.Value)
			if _adeedf != nil {
				return _adeedf
			}
			_daggge.FullScrnAttr = &_gdcde
			continue
		}
	}
_ebafd:
	for {
		_gcgff, _defad := d.Token()
		if _defad != nil {
			return _defad
		}
		switch _decaf := _gcgff.(type) {
		case _e.StartElement:
			switch _decaf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cMediaNode"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cMediaNode"}:
				if _aafe := d.DecodeElement(_daggge.CMediaNode, &_decaf); _aafe != nil {
					return _aafe
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLMediaNodeVideo\u0020\u0025v", _decaf.Name)
				if _dfgcg := d.Skip(); _dfgcg != nil {
					return _dfgcg
				}
			}
		case _e.EndElement:
			break _ebafd
		case _e.CharData:
		}
	}
	return nil
}
func (_fcedb *CT_TLAnimateMotionBehavior) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fcedb.CBhvr = NewCT_TLCommonBehaviorData()
	for _, _edbag := range start.Attr {
		if _edbag.Name.Local == "origin" {
			_fcedb.OriginAttr.UnmarshalXMLAttr(_edbag)
			continue
		}
		if _edbag.Name.Local == "path" {
			_gbba, _aadfb := _edbag.Value, error(nil)
			if _aadfb != nil {
				return _aadfb
			}
			_fcedb.PathAttr = &_gbba
			continue
		}
		if _edbag.Name.Local == "pathEditMode" {
			_fcedb.PathEditModeAttr.UnmarshalXMLAttr(_edbag)
			continue
		}
		if _edbag.Name.Local == "rAng" {
			_bgga, _cgca := _b.ParseInt(_edbag.Value, 10, 32)
			if _cgca != nil {
				return _cgca
			}
			_bdae := int32(_bgga)
			_fcedb.RAngAttr = &_bdae
			continue
		}
		if _edbag.Name.Local == "ptsTypes" {
			_cfac, _dbdg := _edbag.Value, error(nil)
			if _dbdg != nil {
				return _dbdg
			}
			_fcedb.PtsTypesAttr = &_cfac
			continue
		}
	}
_aacga:
	for {
		_aceef, _beec := d.Token()
		if _beec != nil {
			return _beec
		}
		switch _gaecd := _aceef.(type) {
		case _e.StartElement:
			switch _gaecd.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cBhvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cBhvr"}:
				if _ebagb := d.DecodeElement(_fcedb.CBhvr, &_gaecd); _ebagb != nil {
					return _ebagb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "by"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "by"}:
				_fcedb.By = NewCT_TLPoint()
				if _fgfg := d.DecodeElement(_fcedb.By, &_gaecd); _fgfg != nil {
					return _fgfg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "from"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "from"}:
				_fcedb.From = NewCT_TLPoint()
				if _fbcdd := d.DecodeElement(_fcedb.From, &_gaecd); _fbcdd != nil {
					return _fbcdd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "to"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "to"}:
				_fcedb.To = NewCT_TLPoint()
				if _fcef := d.DecodeElement(_fcedb.To, &_gaecd); _fcef != nil {
					return _fcef
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "rCtr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "rCtr"}:
				_fcedb.RCtr = NewCT_TLPoint()
				if _dggad := d.DecodeElement(_fcedb.RCtr, &_gaecd); _dggad != nil {
					return _dggad
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLAnimateMotionBehavior\u0020\u0025v", _gaecd.Name)
				if _bbgc := d.Skip(); _bbgc != nil {
					return _bbgc
				}
			}
		case _e.EndElement:
			break _aacga
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_OleObjectLink and its children
func (_bgccd *CT_OleObjectLink) Validate() error { return _bgccd.ValidateWithPath("CT_OleObjectLink") }
func (_feefb ST_TLAnimateBehaviorValueType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_gbde := _e.Attr{}
	_gbde.Name = name
	switch _feefb {
	case ST_TLAnimateBehaviorValueTypeUnset:
		_gbde.Value = ""
	case ST_TLAnimateBehaviorValueTypeStr:
		_gbde.Value = "str"
	case ST_TLAnimateBehaviorValueTypeNum:
		_gbde.Value = "num"
	case ST_TLAnimateBehaviorValueTypeClr:
		_gbde.Value = "clr"
	}
	return _gbde, nil
}
func NewCT_TLSubShapeId() *CT_TLSubShapeId { _afafd := &CT_TLSubShapeId{}; return _afafd }
func (_abdca *CT_SlideSyncProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _dfce := range start.Attr {
		if _dfce.Name.Local == "serverSldId" {
			_egcdc, _bebfd := _dfce.Value, error(nil)
			if _bebfd != nil {
				return _bebfd
			}
			_abdca.ServerSldIdAttr = _egcdc
			continue
		}
		if _dfce.Name.Local == "serverSldModifiedTime" {
			_cceg, _eageg := ParseStdlibTime(_dfce.Value)
			if _eageg != nil {
				return _eageg
			}
			_abdca.ServerSldModifiedTimeAttr = _cceg
			continue
		}
		if _dfce.Name.Local == "clientInsertedTime" {
			_dgfgb, _ebgg := ParseStdlibTime(_dfce.Value)
			if _ebgg != nil {
				return _ebgg
			}
			_abdca.ClientInsertedTimeAttr = _dgfgb
			continue
		}
	}
_fbfebf:
	for {
		_ffcdf, _ffga := d.Token()
		if _ffga != nil {
			return _ffga
		}
		switch _gfcb := _ffcdf.(type) {
		case _e.StartElement:
			switch _gfcb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_abdca.ExtLst = NewCT_ExtensionList()
				if _fgbc := d.DecodeElement(_abdca.ExtLst, &_gfcb); _fgbc != nil {
					return _fgbc
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SlideSyncProperties\u0020\u0025v", _gfcb.Name)
				if _adaaf := d.Skip(); _adaaf != nil {
					return _adaaf
				}
			}
		case _e.EndElement:
			break _fbfebf
		case _e.CharData:
		}
	}
	return nil
}
func (_ga *CT_ApplicationNonVisualDrawingProps) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ga.IsPhotoAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "isPhoto"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ga.IsPhotoAttr))})
	}
	if _ga.UserDrawnAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "userDrawn"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ga.UserDrawnAttr))})
	}
	e.EncodeToken(start)
	if _ga.Ph != nil {
		_bg := _e.StartElement{Name: _e.Name{Local: "p:ph"}}
		e.EncodeElement(_ga.Ph, _bg)
	}
	if _ga.AudioCd != nil {
		_ec := _e.StartElement{Name: _e.Name{Local: "p:audioCd"}}
		e.EncodeElement(_ga.AudioCd, _ec)
	}
	if _ga.WavAudioFile != nil {
		_eed := _e.StartElement{Name: _e.Name{Local: "p:wavAudioFile"}}
		e.EncodeElement(_ga.WavAudioFile, _eed)
	}
	if _ga.AudioFile != nil {
		_ccg := _e.StartElement{Name: _e.Name{Local: "p:audioFile"}}
		e.EncodeElement(_ga.AudioFile, _ccg)
	}
	if _ga.VideoFile != nil {
		_fa := _e.StartElement{Name: _e.Name{Local: "p:videoFile"}}
		e.EncodeElement(_ga.VideoFile, _fa)
	}
	if _ga.QuickTimeFile != nil {
		_baf := _e.StartElement{Name: _e.Name{Local: "p:quickTimeFile"}}
		e.EncodeElement(_ga.QuickTimeFile, _baf)
	}
	if _ga.CustDataLst != nil {
		_eca := _e.StartElement{Name: _e.Name{Local: "p:custDataLst"}}
		e.EncodeElement(_ga.CustDataLst, _eca)
	}
	if _ga.ExtLst != nil {
		_dge := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ga.ExtLst, _dge)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_cdcgc *CT_ViewProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _cdcgc.LastViewAttr != ST_ViewTypeUnset {
		_gggbg, _bddfe := _cdcgc.LastViewAttr.MarshalXMLAttr(_e.Name{Local: "lastView"})
		if _bddfe != nil {
			return _bddfe
		}
		start.Attr = append(start.Attr, _gggbg)
	}
	if _cdcgc.ShowCommentsAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showComments"}, Value: _c.Sprintf("\u0025d", _fdeab(*_cdcgc.ShowCommentsAttr))})
	}
	e.EncodeToken(start)
	if _cdcgc.NormalViewPr != nil {
		_cdcgce := _e.StartElement{Name: _e.Name{Local: "p:normalViewPr"}}
		e.EncodeElement(_cdcgc.NormalViewPr, _cdcgce)
	}
	if _cdcgc.SlideViewPr != nil {
		_cgce := _e.StartElement{Name: _e.Name{Local: "p:slideViewPr"}}
		e.EncodeElement(_cdcgc.SlideViewPr, _cgce)
	}
	if _cdcgc.OutlineViewPr != nil {
		_ddec := _e.StartElement{Name: _e.Name{Local: "p:outlineViewPr"}}
		e.EncodeElement(_cdcgc.OutlineViewPr, _ddec)
	}
	if _cdcgc.NotesTextViewPr != nil {
		_dgca := _e.StartElement{Name: _e.Name{Local: "p:notesTextViewPr"}}
		e.EncodeElement(_cdcgc.NotesTextViewPr, _dgca)
	}
	if _cdcgc.SorterViewPr != nil {
		_bdeff := _e.StartElement{Name: _e.Name{Local: "p:sorterViewPr"}}
		e.EncodeElement(_cdcgc.SorterViewPr, _bdeff)
	}
	if _cdcgc.NotesViewPr != nil {
		_bceeb := _e.StartElement{Name: _e.Name{Local: "p:notesViewPr"}}
		e.EncodeElement(_cdcgc.NotesViewPr, _bceeb)
	}
	if _cdcgc.GridSpacing != nil {
		_feca := _e.StartElement{Name: _e.Name{Local: "p:gridSpacing"}}
		e.EncodeElement(_cdcgc.GridSpacing, _feca)
	}
	if _cdcgc.ExtLst != nil {
		_cdacg := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_cdcgc.ExtLst, _cdacg)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_ShowInfoKiosk struct {

	// Restart Show
	RestartAttr *uint32
}

// Validate validates the CT_TLOleChartTargetElement and its children
func (_cbaab *CT_TLOleChartTargetElement) Validate() error {
	return _cbaab.ValidateWithPath("CT_TLOleChartTargetElement")
}
func (_ecec ST_SlideLayoutType) String() string {
	switch _ecec {
	case 0:
		return ""
	case 1:
		return "title"
	case 2:
		return "tx"
	case 3:
		return "twoColTx"
	case 4:
		return "tbl"
	case 5:
		return "txAndChart"
	case 6:
		return "chartAndTx"
	case 7:
		return "dgm"
	case 8:
		return "chart"
	case 9:
		return "txAndClipArt"
	case 10:
		return "clipArtAndTx"
	case 11:
		return "titleOnly"
	case 12:
		return "blank"
	case 13:
		return "txAndObj"
	case 14:
		return "objAndTx"
	case 15:
		return "objOnly"
	case 16:
		return "obj"
	case 17:
		return "txAndMedia"
	case 18:
		return "mediaAndTx"
	case 19:
		return "objOverTx"
	case 20:
		return "txOverObj"
	case 21:
		return "txAndTwoObj"
	case 22:
		return "twoObjAndTx"
	case 23:
		return "twoObjOverTx"
	case 24:
		return "fourObj"
	case 25:
		return "vertTx"
	case 26:
		return "clipArtAndVertTx"
	case 27:
		return "vertTitleAndTx"
	case 28:
		return "vertTitleAndTxOverChart"
	case 29:
		return "twoObj"
	case 30:
		return "objAndTwoObj"
	case 31:
		return "twoObjAndObj"
	case 32:
		return "cust"
	case 33:
		return "secHead"
	case 34:
		return "twoTxTwoObj"
	case 35:
		return "objTx"
	case 36:
		return "picTx"
	}
	return ""
}
func (_ebdcf *EG_ShowType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_afagd:
	for {
		_bdfa, _bcae := d.Token()
		if _bcae != nil {
			return _bcae
		}
		switch _cfag := _bdfa.(type) {
		case _e.StartElement:
			switch _cfag.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "present"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "present"}:
				_ebdcf.Present = NewCT_Empty()
				if _dedgc := d.DecodeElement(_ebdcf.Present, &_cfag); _dedgc != nil {
					return _dedgc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "browse"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "browse"}:
				_ebdcf.Browse = NewCT_ShowInfoBrowse()
				if _ededa := d.DecodeElement(_ebdcf.Browse, &_cfag); _ededa != nil {
					return _ededa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "kiosk"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "kiosk"}:
				_ebdcf.Kiosk = NewCT_ShowInfoKiosk()
				if _ceccg := d.DecodeElement(_ebdcf.Kiosk, &_cfag); _ceccg != nil {
					return _ceccg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_ShowType\u0020\u0025v", _cfag.Name)
				if _ccae := d.Skip(); _ccae != nil {
					return _ccae
				}
			}
		case _e.EndElement:
			break _afagd
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_HeaderFooter and its children
func (_ded *CT_HeaderFooter) Validate() error { return _ded.ValidateWithPath("CT_HeaderFooter") }
func (_dgegg ST_PlaceholderSize) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_cfcdf := _e.Attr{}
	_cfcdf.Name = name
	switch _dgegg {
	case ST_PlaceholderSizeUnset:
		_cfcdf.Value = ""
	case ST_PlaceholderSizeFull:
		_cfcdf.Value = "full"
	case ST_PlaceholderSizeHalf:
		_cfcdf.Value = "half"
	case ST_PlaceholderSizeQuarter:
		_cfcdf.Value = "quarter"
	}
	return _cfcdf, nil
}

// Validate validates the CT_TLSetBehavior and its children
func (_aeefe *CT_TLSetBehavior) Validate() error { return _aeefe.ValidateWithPath("CT_TLSetBehavior") }

type EG_ExtensionList struct {

	// Extension
	Ext []*CT_Extension
}

func (_dedgcd *ST_TLTimeIndefinite) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dgbfb, _cebfa := d.Token()
	if _cebfa != nil {
		return _cebfa
	}
	if _gcfec, _dfged := _dgbfb.(_e.EndElement); _dfged && _gcfec.Name == start.Name {
		*_dedgcd = 1
		return nil
	}
	if _bagce, _ecfgf := _dgbfb.(_e.CharData); !_ecfgf {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dgbfb)
	} else {
		switch string(_bagce) {
		case "":
			*_dedgcd = 0
		case "indefinite":
			*_dedgcd = 1
		}
	}
	_dgbfb, _cebfa = d.Token()
	if _cebfa != nil {
		return _cebfa
	}
	if _fgacbe, _cbeac := _dgbfb.(_e.EndElement); _cbeac && _fgacbe.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dgbfb)
}
func (_fcfgd ST_TLAnimateEffectTransition) ValidateWithPath(path string) error {
	switch _fcfgd {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fcfgd))
	}
	return nil
}
func (_eacge ST_PrintWhat) String() string {
	switch _eacge {
	case 0:
		return ""
	case 1:
		return "slides"
	case 2:
		return "handouts1"
	case 3:
		return "handouts2"
	case 4:
		return "handouts3"
	case 5:
		return "handouts4"
	case 6:
		return "handouts6"
	case 7:
		return "handouts9"
	case 8:
		return "notes"
	case 9:
		return "outline"
	}
	return ""
}
func NewCT_OleObjectChoice() *CT_OleObjectChoice { _gfagb := &CT_OleObjectChoice{}; return _gfagb }

// Validate validates the HandoutMaster and its children
func (_ccgae *HandoutMaster) Validate() error { return _ccgae.ValidateWithPath("HandoutMaster") }
func (_cbaac *ST_TLBehaviorTransformType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gfcfa, _aagcg := d.Token()
	if _aagcg != nil {
		return _aagcg
	}
	if _ebgb, _fbadf := _gfcfa.(_e.EndElement); _fbadf && _ebgb.Name == start.Name {
		*_cbaac = 1
		return nil
	}
	if _cgdab, _agebc := _gfcfa.(_e.CharData); !_agebc {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gfcfa)
	} else {
		switch string(_cgdab) {
		case "":
			*_cbaac = 0
		case "pt":
			*_cbaac = 1
		case "img":
			*_cbaac = 2
		}
	}
	_gfcfa, _aagcg = d.Token()
	if _aagcg != nil {
		return _aagcg
	}
	if _eaadd, _bggga := _gfcfa.(_e.EndElement); _bggga && _eaadd.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gfcfa)
}

type CT_TLIterateData struct {

	// Iterate Type
	TypeAttr ST_IterateType

	// Backwards
	BackwardsAttr *bool

	// Time Absolute
	TmAbs *CT_TLIterateIntervalTime

	// Time Percentage
	TmPct *CT_TLIterateIntervalPercentage
}

// ValidateWithPath validates the CT_TLIterateIntervalPercentage and its children, prefixing error messages with path
func (_bbcf *CT_TLIterateIntervalPercentage) ValidateWithPath(path string) error {
	if _dabc := _bbcf.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _dabc != nil {
		return _dabc
	}
	return nil
}

type CT_TLCommonMediaNodeData struct {

	// Volume
	VolAttr *_cb.ST_PositiveFixedPercentage

	// Mute
	MuteAttr *bool

	// Number of Slides
	NumSldAttr *uint32

	// Show When Stopped
	ShowWhenStoppedAttr *bool

	// Common Time Node Properties
	CTn   *CT_TLCommonTimeNodeData
	TgtEl *CT_TLTimeTargetElement
}

const (
	ST_TLAnimateBehaviorValueTypeUnset ST_TLAnimateBehaviorValueType = 0
	ST_TLAnimateBehaviorValueTypeStr   ST_TLAnimateBehaviorValueType = 1
	ST_TLAnimateBehaviorValueTypeNum   ST_TLAnimateBehaviorValueType = 2
	ST_TLAnimateBehaviorValueTypeClr   ST_TLAnimateBehaviorValueType = 3
)

func NewCT_Control() *CT_Control { _aeg := &CT_Control{}; return _aeg }

type CT_CommentAuthor struct {

	// Comment Author ID
	IdAttr uint32

	// Comment Author Name
	NameAttr string

	// Comment Author Initials
	InitialsAttr string

	// Index of Comment Author's last comment
	LastIdxAttr uint32

	// Comment Author Color Index
	ClrIdxAttr uint32
	ExtLst     *CT_ExtensionList
}

// Validate validates the CT_TLIterateIntervalPercentage and its children
func (_gegac *CT_TLIterateIntervalPercentage) Validate() error {
	return _gegac.ValidateWithPath("CT_TLIterateIntervalPercentage")
}

// ValidateWithPath validates the CT_TLAnimateColorBehavior and its children, prefixing error messages with path
func (_faaef *CT_TLAnimateColorBehavior) ValidateWithPath(path string) error {
	if _edcfe := _faaef.ClrSpcAttr.ValidateWithPath(path + "/ClrSpcAttr"); _edcfe != nil {
		return _edcfe
	}
	if _bgcfd := _faaef.DirAttr.ValidateWithPath(path + "\u002fDirAttr"); _bgcfd != nil {
		return _bgcfd
	}
	if _ggaaa := _faaef.CBhvr.ValidateWithPath(path + "\u002fCBhvr"); _ggaaa != nil {
		return _ggaaa
	}
	if _faaef.By != nil {
		if _cbfaa := _faaef.By.ValidateWithPath(path + "\u002fBy"); _cbfaa != nil {
			return _cbfaa
		}
	}
	if _faaef.From != nil {
		if _fdddb := _faaef.From.ValidateWithPath(path + "\u002fFrom"); _fdddb != nil {
			return _fdddb
		}
	}
	if _faaef.To != nil {
		if _aeaa := _faaef.To.ValidateWithPath(path + "\u002fTo"); _aeaa != nil {
			return _aeaa
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ModifyVerifier and its children, prefixing error messages with path
func (_fffc *CT_ModifyVerifier) ValidateWithPath(path string) error {
	if _caga := _fffc.CryptProviderTypeAttr.ValidateWithPath(path + "\u002fCryptProviderTypeAttr"); _caga != nil {
		return _caga
	}
	if _adea := _fffc.CryptAlgorithmClassAttr.ValidateWithPath(path + "\u002fCryptAlgorithmClassAttr"); _adea != nil {
		return _adea
	}
	if _gfccf := _fffc.CryptAlgorithmTypeAttr.ValidateWithPath(path + "\u002fCryptAlgorithmTypeAttr"); _gfccf != nil {
		return _gfccf
	}
	return nil
}
func ParseUnionST_PositiveFixedPercentage(s string) (_cb.ST_PositiveFixedPercentage, error) {
	return _cb.ParseUnionST_PositiveFixedPercentage(s)
}

// ValidateWithPath validates the CT_ShowProperties and its children, prefixing error messages with path
func (_bbdga *CT_ShowProperties) ValidateWithPath(path string) error {
	if _bbdga.Present != nil {
		if _bdabb := _bbdga.Present.ValidateWithPath(path + "\u002fPresent"); _bdabb != nil {
			return _bdabb
		}
	}
	if _bbdga.Browse != nil {
		if _ddfag := _bbdga.Browse.ValidateWithPath(path + "\u002fBrowse"); _ddfag != nil {
			return _ddfag
		}
	}
	if _bbdga.Kiosk != nil {
		if _ffcdg := _bbdga.Kiosk.ValidateWithPath(path + "\u002fKiosk"); _ffcdg != nil {
			return _ffcdg
		}
	}
	if _bbdga.SldAll != nil {
		if _acef := _bbdga.SldAll.ValidateWithPath(path + "\u002fSldAll"); _acef != nil {
			return _acef
		}
	}
	if _bbdga.SldRg != nil {
		if _aecc := _bbdga.SldRg.ValidateWithPath(path + "\u002fSldRg"); _aecc != nil {
			return _aecc
		}
	}
	if _bbdga.CustShow != nil {
		if _gbdag := _bbdga.CustShow.ValidateWithPath(path + "\u002fCustShow"); _gbdag != nil {
			return _gbdag
		}
	}
	if _bbdga.PenClr != nil {
		if _agadf := _bbdga.PenClr.ValidateWithPath(path + "\u002fPenClr"); _agadf != nil {
			return _agadf
		}
	}
	if _bbdga.ExtLst != nil {
		if _efce := _bbdga.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _efce != nil {
			return _efce
		}
	}
	return nil
}
func (_babf ST_TLAnimateBehaviorCalcMode) Validate() error { return _babf.ValidateWithPath("") }

type CT_Extension struct {

	// Uniform Resource Identifier
	UriAttr string
	Any     []_ee.Any
}

const (
	ST_TLAnimateColorSpaceUnset ST_TLAnimateColorSpace = 0
	ST_TLAnimateColorSpaceRgb   ST_TLAnimateColorSpace = 1
	ST_TLAnimateColorSpaceHsl   ST_TLAnimateColorSpace = 2
)

// Validate validates the AG_ChildSlide and its children
func (_gd *AG_ChildSlide) Validate() error { return _gd.ValidateWithPath("AG_ChildSlide") }

type CT_TLTimeNodeExclusive struct {

	// Common TimeNode Properties
	CTn *CT_TLCommonTimeNodeData
}

func (_effg ST_TLNextActionType) ValidateWithPath(path string) error {
	switch _effg {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_effg))
	}
	return nil
}

type CT_CommentAuthorList struct {

	// Comment Author
	CmAuthor []*CT_CommentAuthor
}

func (_dcgcf ST_TLCommandType) Validate() error { return _dcgcf.ValidateWithPath("") }

type CT_EightDirectionTransition struct {

	// Direction
	DirAttr *ST_TransitionEightDirectionType
}

func (_ebaf *CT_CommentAuthor) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _afcda := range start.Attr {
		if _afcda.Name.Local == "id" {
			_beca, _abf := _b.ParseUint(_afcda.Value, 10, 32)
			if _abf != nil {
				return _abf
			}
			_ebaf.IdAttr = uint32(_beca)
			continue
		}
		if _afcda.Name.Local == "name" {
			_abe, _eeae := _afcda.Value, error(nil)
			if _eeae != nil {
				return _eeae
			}
			_ebaf.NameAttr = _abe
			continue
		}
		if _afcda.Name.Local == "initials" {
			_ffee, _gba := _afcda.Value, error(nil)
			if _gba != nil {
				return _gba
			}
			_ebaf.InitialsAttr = _ffee
			continue
		}
		if _afcda.Name.Local == "lastIdx" {
			_bga, _cfgc := _b.ParseUint(_afcda.Value, 10, 32)
			if _cfgc != nil {
				return _cfgc
			}
			_ebaf.LastIdxAttr = uint32(_bga)
			continue
		}
		if _afcda.Name.Local == "clrIdx" {
			_cdgg, _adab := _b.ParseUint(_afcda.Value, 10, 32)
			if _adab != nil {
				return _adab
			}
			_ebaf.ClrIdxAttr = uint32(_cdgg)
			continue
		}
	}
_cfd:
	for {
		_daaa, _fg := d.Token()
		if _fg != nil {
			return _fg
		}
		switch _dgf := _daaa.(type) {
		case _e.StartElement:
			switch _dgf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_ebaf.ExtLst = NewCT_ExtensionList()
				if _agb := d.DecodeElement(_ebaf.ExtLst, &_dgf); _agb != nil {
					return _agb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_CommentAuthor\u0020\u0025v", _dgf.Name)
				if _gdb := d.Skip(); _gdb != nil {
					return _gdb
				}
			}
		case _e.EndElement:
			break _cfd
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_SlideSorterViewProperties and its children
func (_ddcea *CT_SlideSorterViewProperties) Validate() error {
	return _ddcea.ValidateWithPath("CT_SlideSorterViewProperties")
}
func NewCT_ApplicationNonVisualDrawingProps() *CT_ApplicationNonVisualDrawingProps {
	_ebg := &CT_ApplicationNonVisualDrawingProps{}
	return _ebg
}

type CT_SlideTransition struct {

	// Transition Speed
	SpdAttr ST_TransitionSpeed

	// Advance on Click
	AdvClickAttr *bool

	// Advance after time
	AdvTmAttr *uint32
	Choice    *CT_SlideTransitionChoice

	// Sound Action
	SndAc  *CT_TransitionSoundAction
	ExtLst *CT_ExtensionListModify
}

func NewCT_SlideLayoutIdListEntry() *CT_SlideLayoutIdListEntry {
	_bdef := &CT_SlideLayoutIdListEntry{}
	return _bdef
}
func (_dggf *CT_Extension) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _fedb := range start.Attr {
		if _fedb.Name.Local == "uri" {
			_ceac, _gefc := _fedb.Value, error(nil)
			if _gefc != nil {
				return _gefc
			}
			_dggf.UriAttr = _ceac
			continue
		}
	}
_ccdf:
	for {
		_edca, _dfbg := d.Token()
		if _dfbg != nil {
			return _dfbg
		}
		switch _debe := _edca.(type) {
		case _e.StartElement:
			switch _debe.Name {
			default:
				if _gaab, _gadbd := _ee.CreateElement(_debe); _gadbd != nil {
					return _gadbd
				} else {
					if _gecd := d.DecodeElement(_gaab, &_debe); _gecd != nil {
						return _gecd
					}
					_dggf.Any = append(_dggf.Any, _gaab)
				}
			}
		case _e.EndElement:
			break _ccdf
		case _e.CharData:
		}
	}
	return nil
}

type CT_TagsData struct{ IdAttr string }

// ValidateWithPath validates the CT_TLTimeNodeParallel and its children, prefixing error messages with path
func (_eead *CT_TLTimeNodeParallel) ValidateWithPath(path string) error {
	if _cgeef := _eead.CTn.ValidateWithPath(path + "\u002fCTn"); _cgeef != nil {
		return _cgeef
	}
	return nil
}
func (_faff *CT_OutlineViewSlideEntry) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _faff.IdAttr)})
	if _faff.CollapseAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "collapse"}, Value: _c.Sprintf("\u0025d", _fdeab(*_faff.CollapseAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_TLAnimateBehavior struct {

	// By
	ByAttr *string

	// From
	FromAttr *string

	// To
	ToAttr *string

	// Calculation Mode
	CalcmodeAttr ST_TLAnimateBehaviorCalcMode

	// Value Type
	ValueTypeAttr ST_TLAnimateBehaviorValueType
	CBhvr         *CT_TLCommonBehaviorData

	// Time Animated Value List
	TavLst *CT_TLTimeAnimateValueList
}

// Validate validates the CT_GraphicalObjectFrameNonVisual and its children
func (_aebc *CT_GraphicalObjectFrameNonVisual) Validate() error {
	return _aebc.ValidateWithPath("CT_GraphicalObjectFrameNonVisual")
}

type EG_Background struct {

	// Background Properties
	BgPr *CT_BackgroundProperties

	// Background Style Reference
	BgRef *_cb.CT_StyleMatrixReference
}

func (_dfefe *CT_SlideMasterIdList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _dfefe.SldMasterId != nil {
		_ddced := _e.StartElement{Name: _e.Name{Local: "p:sldMasterId"}}
		for _, _fcfd := range _dfefe.SldMasterId {
			e.EncodeElement(_fcfd, _ddced)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_geeda *ST_TLTimeNodeRestartType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_geeda = 0
	case "always":
		*_geeda = 1
	case "whenNotActive":
		*_geeda = 2
	case "never":
		*_geeda = 3
	}
	return nil
}
func (_adfcb *ST_TLAnimateColorSpace) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_adfcb = 0
	case "rgb":
		*_adfcb = 1
	case "hsl":
		*_adfcb = 2
	}
	return nil
}

type ST_WebColorType byte

func (_beaea *CT_TransitionStartSoundAction) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _beaea.LoopAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "loop"}, Value: _c.Sprintf("\u0025d", _fdeab(*_beaea.LoopAttr))})
	}
	e.EncodeToken(start)
	_faagf := _e.StartElement{Name: _e.Name{Local: "p:snd"}}
	e.EncodeElement(_beaea.Snd, _faagf)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_Picture() *CT_Picture {
	_aebgb := &CT_Picture{}
	_aebgb.NvPicPr = NewCT_PictureNonVisual()
	_aebgb.BlipFill = _cb.NewCT_BlipFillProperties()
	_aebgb.SpPr = _cb.NewCT_ShapeProperties()
	return _aebgb
}
func (_dege ST_TransitionInOutDirectionType) String() string {
	switch _dege {
	case 0:
		return ""
	case 1:
		return "out"
	case 2:
		return "in"
	}
	return ""
}
func (_ffbage *NotesMaster) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:notesMaster"
	return _ffbage.CT_NotesMaster.MarshalXML(e, start)
}

// Validate validates the CT_CornerDirectionTransition and its children
func (_gfg *CT_CornerDirectionTransition) Validate() error {
	return _gfg.ValidateWithPath("CT_CornerDirectionTransition")
}

type ST_SlideLayoutType byte

// ValidateWithPath validates the Notes and its children, prefixing error messages with path
func (_abcfd *Notes) ValidateWithPath(path string) error {
	if _ffbe := _abcfd.CT_NotesSlide.ValidateWithPath(path); _ffbe != nil {
		return _ffbe
	}
	return nil
}
func (_acbge *CT_TLAnimateRotationBehavior) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _acbge.ByAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "by"}, Value: _c.Sprintf("\u0025v", *_acbge.ByAttr)})
	}
	if _acbge.FromAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "from"}, Value: _c.Sprintf("\u0025v", *_acbge.FromAttr)})
	}
	if _acbge.ToAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "to"}, Value: _c.Sprintf("\u0025v", *_acbge.ToAttr)})
	}
	e.EncodeToken(start)
	_cdafb := _e.StartElement{Name: _e.Name{Local: "p:cBhvr"}}
	e.EncodeElement(_acbge.CBhvr, _cdafb)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_CustomerData and its children, prefixing error messages with path
func (_edfe *CT_CustomerData) ValidateWithPath(path string) error { return nil }
func (_bbdbb *CT_TLBuildParagraph) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _bbdbb.BuildAttr != ST_TLParaBuildTypeUnset {
		_acbbg, _gccg := _bbdbb.BuildAttr.MarshalXMLAttr(_e.Name{Local: "build"})
		if _gccg != nil {
			return _gccg
		}
		start.Attr = append(start.Attr, _acbbg)
	}
	if _bbdbb.BldLvlAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "bldLvl"}, Value: _c.Sprintf("\u0025v", *_bbdbb.BldLvlAttr)})
	}
	if _bbdbb.AnimBgAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "animBg"}, Value: _c.Sprintf("\u0025d", _fdeab(*_bbdbb.AnimBgAttr))})
	}
	if _bbdbb.AutoUpdateAnimBgAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "autoUpdateAnimBg"}, Value: _c.Sprintf("\u0025d", _fdeab(*_bbdbb.AutoUpdateAnimBgAttr))})
	}
	if _bbdbb.RevAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "rev"}, Value: _c.Sprintf("\u0025d", _fdeab(*_bbdbb.RevAttr))})
	}
	if _bbdbb.AdvAutoAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "advAuto"}, Value: _c.Sprintf("\u0025v", *_bbdbb.AdvAutoAttr)})
	}
	if _bbdbb.SpidAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spid"}, Value: _c.Sprintf("\u0025v", *_bbdbb.SpidAttr)})
	}
	if _bbdbb.GrpIdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "grpId"}, Value: _c.Sprintf("\u0025v", *_bbdbb.GrpIdAttr)})
	}
	if _bbdbb.UiExpandAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "uiExpand"}, Value: _c.Sprintf("\u0025d", _fdeab(*_bbdbb.UiExpandAttr))})
	}
	e.EncodeToken(start)
	if _bbdbb.TmplLst != nil {
		_fgbbdd := _e.StartElement{Name: _e.Name{Local: "p:tmplLst"}}
		e.EncodeElement(_bbdbb.TmplLst, _fgbbdd)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TLBehaviorAttributeNameList and its children
func (_gcdffg *CT_TLBehaviorAttributeNameList) Validate() error {
	return _gcdffg.ValidateWithPath("CT_TLBehaviorAttributeNameList")
}
func (_gdbeff ST_TLTriggerEvent) ValidateWithPath(path string) error {
	switch _gdbeff {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gdbeff))
	}
	return nil
}
func (_dbdfc ST_OleObjectFollowColorScheme) ValidateWithPath(path string) error {
	switch _dbdfc {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dbdfc))
	}
	return nil
}

// ValidateWithPath validates the CT_NormalViewProperties and its children, prefixing error messages with path
func (_cffb *CT_NormalViewProperties) ValidateWithPath(path string) error {
	if _cgadf := _cffb.VertBarStateAttr.ValidateWithPath(path + "\u002fVertBarStateAttr"); _cgadf != nil {
		return _cgadf
	}
	if _adbcg := _cffb.HorzBarStateAttr.ValidateWithPath(path + "\u002fHorzBarStateAttr"); _adbcg != nil {
		return _adbcg
	}
	if _eeec := _cffb.RestoredLeft.ValidateWithPath(path + "\u002fRestoredLeft"); _eeec != nil {
		return _eeec
	}
	if _bgae := _cffb.RestoredTop.ValidateWithPath(path + "\u002fRestoredTop"); _bgae != nil {
		return _bgae
	}
	if _cffb.ExtLst != nil {
		if _faba := _cffb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _faba != nil {
			return _faba
		}
	}
	return nil
}
func NewCT_OptionalBlackTransition() *CT_OptionalBlackTransition {
	_afbgd := &CT_OptionalBlackTransition{}
	return _afbgd
}

// Validate validates the CT_TLTextTargetElement and its children
func (_bbgd *CT_TLTextTargetElement) Validate() error {
	return _bbgd.ValidateWithPath("CT_TLTextTargetElement")
}

// ValidateWithPath validates the CT_OleObject and its children, prefixing error messages with path
func (_agbbb *CT_OleObject) ValidateWithPath(path string) error {
	if _fgdgc := _agbbb.Choice.ValidateWithPath(path + "\u002fChoice"); _fgdgc != nil {
		return _fgdgc
	}
	if _agbbb.Pic != nil {
		if _deagc := _agbbb.Pic.ValidateWithPath(path + "\u002fPic"); _deagc != nil {
			return _deagc
		}
	}
	if _agbbb.ImgWAttr != nil {
		if *_agbbb.ImgWAttr < 0 {
			return _c.Errorf("\u0025s/m\u002eImgWAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_agbbb.ImgWAttr)
		}
	}
	if _agbbb.ImgHAttr != nil {
		if *_agbbb.ImgHAttr < 0 {
			return _c.Errorf("\u0025s/m\u002eImgHAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_agbbb.ImgHAttr)
		}
	}
	return nil
}

// ValidateWithPath validates the CT_ExtensionList and its children, prefixing error messages with path
func (_cgfg *CT_ExtensionList) ValidateWithPath(path string) error {
	for _eggg, _dcdd := range _cgfg.Ext {
		if _gbbc := _dcdd.ValidateWithPath(_c.Sprintf("\u0025s\u002fExt\u005b\u0025d\u005d", path, _eggg)); _gbbc != nil {
			return _gbbc
		}
	}
	return nil
}
func (_cedga *CT_TLTimeNodeSequence) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _cedga.ConcurrentAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "concurrent"}, Value: _c.Sprintf("\u0025d", _fdeab(*_cedga.ConcurrentAttr))})
	}
	if _cedga.PrevAcAttr != ST_TLPreviousActionTypeUnset {
		_efcd, _fdcbg := _cedga.PrevAcAttr.MarshalXMLAttr(_e.Name{Local: "prevAc"})
		if _fdcbg != nil {
			return _fdcbg
		}
		start.Attr = append(start.Attr, _efcd)
	}
	if _cedga.NextAcAttr != ST_TLNextActionTypeUnset {
		_acgfg, _degg := _cedga.NextAcAttr.MarshalXMLAttr(_e.Name{Local: "nextAc"})
		if _degg != nil {
			return _degg
		}
		start.Attr = append(start.Attr, _acgfg)
	}
	e.EncodeToken(start)
	_afbgb := _e.StartElement{Name: _e.Name{Local: "p:cTn"}}
	e.EncodeElement(_cedga.CTn, _afbgb)
	if _cedga.PrevCondLst != nil {
		_afcdc := _e.StartElement{Name: _e.Name{Local: "p:prevCondLst"}}
		e.EncodeElement(_cedga.PrevCondLst, _afcdc)
	}
	if _cedga.NextCondLst != nil {
		_ccefc := _e.StartElement{Name: _e.Name{Local: "p:nextCondLst"}}
		e.EncodeElement(_cedga.NextCondLst, _ccefc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type ST_TLTriggerRuntimeNode byte
type CT_GroupShapeNonVisual struct {

	// Non-visual Drawing Properties
	CNvPr *_cb.CT_NonVisualDrawingProps

	// Non-Visual Group Shape Drawing Properties
	CNvGrpSpPr *_cb.CT_NonVisualGroupDrawingShapeProps

	// Non-Visual Properties
	NvPr *CT_ApplicationNonVisualDrawingProps
}

func NewCT_TLOleChartTargetElement() *CT_TLOleChartTargetElement {
	_cgacf := &CT_TLOleChartTargetElement{}
	_cgacf.TypeAttr = ST_TLChartSubelementType(1)
	return _cgacf
}
func (_dfcb *CT_TLAnimateBehavior) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dfcb.CBhvr = NewCT_TLCommonBehaviorData()
	for _, _efca := range start.Attr {
		if _efca.Name.Local == "by" {
			_ecdbd, _eaefd := _efca.Value, error(nil)
			if _eaefd != nil {
				return _eaefd
			}
			_dfcb.ByAttr = &_ecdbd
			continue
		}
		if _efca.Name.Local == "from" {
			_edadf, _dcbe := _efca.Value, error(nil)
			if _dcbe != nil {
				return _dcbe
			}
			_dfcb.FromAttr = &_edadf
			continue
		}
		if _efca.Name.Local == "to" {
			_edfc, _bfgde := _efca.Value, error(nil)
			if _bfgde != nil {
				return _bfgde
			}
			_dfcb.ToAttr = &_edfc
			continue
		}
		if _efca.Name.Local == "calcmode" {
			_dfcb.CalcmodeAttr.UnmarshalXMLAttr(_efca)
			continue
		}
		if _efca.Name.Local == "valueType" {
			_dfcb.ValueTypeAttr.UnmarshalXMLAttr(_efca)
			continue
		}
	}
_ebeb:
	for {
		_caeeac, _eddc := d.Token()
		if _eddc != nil {
			return _eddc
		}
		switch _ffcc := _caeeac.(type) {
		case _e.StartElement:
			switch _ffcc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cBhvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cBhvr"}:
				if _dbcg := d.DecodeElement(_dfcb.CBhvr, &_ffcc); _dbcg != nil {
					return _dbcg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tavLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tavLst"}:
				_dfcb.TavLst = NewCT_TLTimeAnimateValueList()
				if _aefcgg := d.DecodeElement(_dfcb.TavLst, &_ffcc); _aefcgg != nil {
					return _aefcgg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_TLAnimateBehavior\u0020\u0025v", _ffcc.Name)
				if _cgffe := d.Skip(); _cgffe != nil {
					return _cgffe
				}
			}
		case _e.EndElement:
			break _ebeb
		case _e.CharData:
		}
	}
	return nil
}
func (_gffg *CT_OutlineViewSlideList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _gffg.Sld != nil {
		_cde := _e.StartElement{Name: _e.Name{Local: "p:sld"}}
		for _, _gaea := range _gffg.Sld {
			e.EncodeElement(_gaea, _cde)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TLTriggerRuntimeNode and its children, prefixing error messages with path
func (_ggdd *CT_TLTriggerRuntimeNode) ValidateWithPath(path string) error {
	if _ggdd.ValAttr == ST_TLTriggerRuntimeNodeUnset {
		return _c.Errorf("\u0025s\u002fValAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _bddfb := _ggdd.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _bddfb != nil {
		return _bddfb
	}
	return nil
}
func (_bgbdfb ST_TLCommandType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_bgbdfb.String(), start)
}

// Validate validates the CT_TLMediaNodeAudio and its children
func (_deec *CT_TLMediaNodeAudio) Validate() error {
	return _deec.ValidateWithPath("CT_TLMediaNodeAudio")
}
func ParseUnionST_PositivePercentage(s string) (_cb.ST_PositivePercentage, error) {
	return _cb.ParseUnionST_PositivePercentage(s)
}
func (_edgdg ST_TLTimeNodeSyncType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_bbggb := _e.Attr{}
	_bbggb.Name = name
	switch _edgdg {
	case ST_TLTimeNodeSyncTypeUnset:
		_bbggb.Value = ""
	case ST_TLTimeNodeSyncTypeCanSlip:
		_bbggb.Value = "canSlip"
	case ST_TLTimeNodeSyncTypeLocked:
		_bbggb.Value = "locked"
	}
	return _bbggb, nil
}
func NewCT_TLTextTargetElement() *CT_TLTextTargetElement {
	_bcbcd := &CT_TLTextTargetElement{}
	return _bcbcd
}
func (_ccdfb *CT_NotesMasterIdListEntry) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _ccdfb.IdAttr)})
	e.EncodeToken(start)
	if _ccdfb.ExtLst != nil {
		_fdee := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ccdfb.ExtLst, _fdee)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_Control struct {
	ExtLst         *CT_ExtensionList
	Pic            *CT_Picture
	SpidAttr       *string
	NameAttr       *string
	ShowAsIconAttr *bool
	IdAttr         *string
	ImgWAttr       *int32
	ImgHAttr       *int32
}

// Validate validates the CT_TLCommandBehavior and its children
func (_fcefg *CT_TLCommandBehavior) Validate() error {
	return _fcefg.ValidateWithPath("CT_TLCommandBehavior")
}
func (_egefd ST_TLTriggerRuntimeNode) Validate() error { return _egefd.ValidateWithPath("") }

type CT_CommonSlideData struct {

	// Name
	NameAttr *string

	// Slide Background
	Bg *CT_Background

	// Shape Tree
	SpTree *CT_GroupShape

	// Customer Data List
	CustDataLst *CT_CustomerDataList

	// List of controls
	Controls *CT_ControlList
	ExtLst   *CT_ExtensionList
}

func (_acfff ST_TLAnimateMotionPathEditMode) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_cbgd := _e.Attr{}
	_cbgd.Name = name
	switch _acfff {
	case ST_TLAnimateMotionPathEditModeUnset:
		_cbgd.Value = ""
	case ST_TLAnimateMotionPathEditModeRelative:
		_cbgd.Value = "relative"
	case ST_TLAnimateMotionPathEditModeFixed:
		_cbgd.Value = "fixed"
	}
	return _cbgd, nil
}
func NewCT_TLByHslColorTransform() *CT_TLByHslColorTransform {
	_eagea := &CT_TLByHslColorTransform{}
	return _eagea
}
func (_dbgac *CT_TLTriggerTimeNodeID) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cdfce := range start.Attr {
		if _cdfce.Name.Local == "val" {
			_dcedc, _cfeae := _b.ParseUint(_cdfce.Value, 10, 32)
			if _cfeae != nil {
				return _cfeae
			}
			_dbgac.ValAttr = uint32(_dcedc)
			continue
		}
	}
	for {
		_cfcc, _gbab := d.Token()
		if _gbab != nil {
			return _c.Errorf("parsing\u0020CT_TLTriggerTimeNodeID:\u0020\u0025s", _gbab)
		}
		if _gecga, _cfgea := _cfcc.(_e.EndElement); _cfgea && _gecga.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TLByRgbColorTransform and its children, prefixing error messages with path
func (_gcbdf *CT_TLByRgbColorTransform) ValidateWithPath(path string) error {
	if _fgdb := _gcbdf.RAttr.ValidateWithPath(path + "\u002fRAttr"); _fgdb != nil {
		return _fgdb
	}
	if _fbgf := _gcbdf.GAttr.ValidateWithPath(path + "\u002fGAttr"); _fbgf != nil {
		return _fbgf
	}
	if _faeaf := _gcbdf.BAttr.ValidateWithPath(path + "\u002fBAttr"); _faeaf != nil {
		return _faeaf
	}
	return nil
}

// Validate validates the CT_SlideSize and its children
func (_eecc *CT_SlideSize) Validate() error { return _eecc.ValidateWithPath("CT_SlideSize") }
func (_gcgadb *EG_SlideListChoice) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_acedb:
	for {
		_daada, _fcabb := d.Token()
		if _fcabb != nil {
			return _fcabb
		}
		switch _edbec := _daada.(type) {
		case _e.StartElement:
			switch _edbec.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldAll"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldAll"}:
				_gcgadb.SldAll = NewCT_Empty()
				if _eaaaa := d.DecodeElement(_gcgadb.SldAll, &_edbec); _eaaaa != nil {
					return _eaaaa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldRg"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldRg"}:
				_gcgadb.SldRg = NewCT_IndexRange()
				if _afdg := d.DecodeElement(_gcgadb.SldRg, &_edbec); _afdg != nil {
					return _afdg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "custShow"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "custShow"}:
				_gcgadb.CustShow = NewCT_CustomShowId()
				if _dedde := d.DecodeElement(_gcgadb.CustShow, &_edbec); _dedde != nil {
					return _dedde
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020EG_SlideListChoice\u0020\u0025v", _edbec.Name)
				if _gbfae := d.Skip(); _gbfae != nil {
					return _gbfae
				}
			}
		case _e.EndElement:
			break _acedb
		case _e.CharData:
		}
	}
	return nil
}
func (_gbcgb ST_TransitionSideDirectionType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_gbcgb.String(), start)
}

// Validate validates the NotesMaster and its children
func (_cfagg *NotesMaster) Validate() error { return _cfagg.ValidateWithPath("NotesMaster") }
func (_bgef *CT_PrintProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _dcdc := range start.Attr {
		if _dcdc.Name.Local == "prnWhat" {
			_bgef.PrnWhatAttr.UnmarshalXMLAttr(_dcdc)
			continue
		}
		if _dcdc.Name.Local == "clrMode" {
			_bgef.ClrModeAttr.UnmarshalXMLAttr(_dcdc)
			continue
		}
		if _dcdc.Name.Local == "hiddenSlides" {
			_fagb, _bcbf := _b.ParseBool(_dcdc.Value)
			if _bcbf != nil {
				return _bcbf
			}
			_bgef.HiddenSlidesAttr = &_fagb
			continue
		}
		if _dcdc.Name.Local == "scaleToFitPaper" {
			_dfggd, _bedc := _b.ParseBool(_dcdc.Value)
			if _bedc != nil {
				return _bedc
			}
			_bgef.ScaleToFitPaperAttr = &_dfggd
			continue
		}
		if _dcdc.Name.Local == "frameSlides" {
			_egbec, _ccff := _b.ParseBool(_dcdc.Value)
			if _ccff != nil {
				return _ccff
			}
			_bgef.FrameSlidesAttr = &_egbec
			continue
		}
	}
_fbeb:
	for {
		_bgdbg, _beeb := d.Token()
		if _beeb != nil {
			return _beeb
		}
		switch _cgbe := _bgdbg.(type) {
		case _e.StartElement:
			switch _cgbe.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_bgef.ExtLst = NewCT_ExtensionList()
				if _ceab := d.DecodeElement(_bgef.ExtLst, &_cgbe); _ceab != nil {
					return _ceab
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_PrintProperties\u0020\u0025v", _cgbe.Name)
				if _aaabg := d.Skip(); _aaabg != nil {
					return _aaabg
				}
			}
		case _e.EndElement:
			break _fbeb
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_OrientationTransition and its children
func (_ccab *CT_OrientationTransition) Validate() error {
	return _ccab.ValidateWithPath("CT_OrientationTransition")
}
func (_adacd ST_TLAnimateBehaviorValueType) ValidateWithPath(path string) error {
	switch _adacd {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_adacd))
	}
	return nil
}

type CT_OutlineViewSlideList struct {

	// Presentation Slide
	Sld []*CT_OutlineViewSlideEntry
}

func (_ecdg *CT_StringTag) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "name"}, Value: _c.Sprintf("\u0025v", _ecdg.NameAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "val"}, Value: _c.Sprintf("\u0025v", _ecdg.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_afc *CT_BackgroundProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _afc.ShadeToTitleAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "shadeToTitle"}, Value: _c.Sprintf("\u0025d", _fdeab(*_afc.ShadeToTitleAttr))})
	}
	e.EncodeToken(start)
	if _afc.NoFill != nil {
		_acc := _e.StartElement{Name: _e.Name{Local: "p:noFill"}}
		e.EncodeElement(_afc.NoFill, _acc)
	}
	if _afc.SolidFill != nil {
		_cbg := _e.StartElement{Name: _e.Name{Local: "p:solidFill"}}
		e.EncodeElement(_afc.SolidFill, _cbg)
	}
	if _afc.GradFill != nil {
		_geg := _e.StartElement{Name: _e.Name{Local: "p:gradFill"}}
		e.EncodeElement(_afc.GradFill, _geg)
	}
	if _afc.BlipFill != nil {
		_eeg := _e.StartElement{Name: _e.Name{Local: "p:blipFill"}}
		e.EncodeElement(_afc.BlipFill, _eeg)
	}
	if _afc.PattFill != nil {
		_bcgb := _e.StartElement{Name: _e.Name{Local: "p:pattFill"}}
		e.EncodeElement(_afc.PattFill, _bcgb)
	}
	if _afc.GrpFill != nil {
		_gf := _e.StartElement{Name: _e.Name{Local: "p:grpFill"}}
		e.EncodeElement(_afc.GrpFill, _gf)
	}
	if _afc.EffectLst != nil {
		_dcg := _e.StartElement{Name: _e.Name{Local: "p:effectLst"}}
		e.EncodeElement(_afc.EffectLst, _dcg)
	}
	if _afc.EffectDag != nil {
		_beg := _e.StartElement{Name: _e.Name{Local: "p:effectDag"}}
		e.EncodeElement(_afc.EffectDag, _beg)
	}
	if _afc.ExtLst != nil {
		_baff := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_afc.ExtLst, _baff)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type AG_Ole struct {
	SpidAttr       *string
	NameAttr       *string
	ShowAsIconAttr *bool
	IdAttr         *string
	ImgWAttr       *int32
	ImgHAttr       *int32
}

func NewEG_TopLevelSlide() *EG_TopLevelSlide {
	_abbfbg := &EG_TopLevelSlide{}
	_abbfbg.ClrMap = _cb.NewCT_ColorMapping()
	return _abbfbg
}

// ValidateWithPath validates the CT_SlideMasterIdListEntry and its children, prefixing error messages with path
func (_cfefb *CT_SlideMasterIdListEntry) ValidateWithPath(path string) error {
	if _cfefb.IdAttr != nil {
		if *_cfefb.IdAttr < 2147483648 {
			return _c.Errorf("\u0025s\u002fm\u002eIdAttr must be\u0020\u003e\u003d\u00202147483648\u0020\u0028have\u0020\u0025v\u0029", path, *_cfefb.IdAttr)
		}
	}
	if _cfefb.ExtLst != nil {
		if _ffdd := _cfefb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ffdd != nil {
			return _ffdd
		}
	}
	return nil
}

type ST_TLAnimateMotionPathEditMode byte

func (_dccfb ST_TLTimeNodeType) ValidateWithPath(path string) error {
	switch _dccfb {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dccfb))
	}
	return nil
}
func (_cccc ST_PhotoAlbumLayout) Validate() error { return _cccc.ValidateWithPath("") }
func NewCT_CommonViewProperties() *CT_CommonViewProperties {
	_fdf := &CT_CommonViewProperties{}
	_fdf.Scale = _cb.NewCT_Scale2D()
	_fdf.Origin = _cb.NewCT_Point2D()
	return _fdf
}

// Validate validates the CT_TLAnimVariantFloatVal and its children
func (_egabc *CT_TLAnimVariantFloatVal) Validate() error {
	return _egabc.ValidateWithPath("CT_TLAnimVariantFloatVal")
}

type CT_SlideTiming struct {
	TnLst *CT_TimeNodeList

	// Build List
	BldLst *CT_BuildList
	ExtLst *CT_ExtensionListModify
}

// Validate validates the CT_SlideLayoutIdListEntry and its children
func (_agfad *CT_SlideLayoutIdListEntry) Validate() error {
	return _agfad.ValidateWithPath("CT_SlideLayoutIdListEntry")
}
func (_abdebe *ST_TLTimeNodeRestartType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dcdda, _acadff := d.Token()
	if _acadff != nil {
		return _acadff
	}
	if _ccfga, _bcgbfg := _dcdda.(_e.EndElement); _bcgbfg && _ccfga.Name == start.Name {
		*_abdebe = 1
		return nil
	}
	if _fagfa, _gefgb := _dcdda.(_e.CharData); !_gefgb {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dcdda)
	} else {
		switch string(_fagfa) {
		case "":
			*_abdebe = 0
		case "always":
			*_abdebe = 1
		case "whenNotActive":
			*_abdebe = 2
		case "never":
			*_abdebe = 3
		}
	}
	_dcdda, _acadff = d.Token()
	if _acadff != nil {
		return _acadff
	}
	if _adccd, _cdgbg := _dcdda.(_e.EndElement); _cdgbg && _adccd.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dcdda)
}

// ValidateWithPath validates the CT_TagsData and its children, prefixing error messages with path
func (_eaagd *CT_TagsData) ValidateWithPath(path string) error { return nil }

type SldSyncPr struct{ CT_SlideSyncProperties }

// Validate validates the CT_SlideMasterIdListEntry and its children
func (_aceba *CT_SlideMasterIdListEntry) Validate() error {
	return _aceba.ValidateWithPath("CT_SlideMasterIdListEntry")
}

type CT_TLPoint struct {

	// X coordinate
	XAttr _cb.ST_Percentage

	// Y coordinate
	YAttr _cb.ST_Percentage
}
type ST_TLCommandType byte

func (_bcfdc *PresentationPr) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_bcfdc.CT_PresentationProperties = *NewCT_PresentationProperties()
_bdbdc:
	for {
		_egdg, _cgaad := d.Token()
		if _cgaad != nil {
			return _cgaad
		}
		switch _afgcc := _egdg.(type) {
		case _e.StartElement:
			switch _afgcc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "htmlPubPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "htmlPubPr"}:
				_bcfdc.HtmlPubPr = NewCT_HtmlPublishProperties()
				if _bbbaa := d.DecodeElement(_bcfdc.HtmlPubPr, &_afgcc); _bbbaa != nil {
					return _bbbaa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "webPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "webPr"}:
				_bcfdc.WebPr = NewCT_WebProperties()
				if _ebgebf := d.DecodeElement(_bcfdc.WebPr, &_afgcc); _ebgebf != nil {
					return _ebgebf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "prnPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "prnPr"}:
				_bcfdc.PrnPr = NewCT_PrintProperties()
				if _ebacc := d.DecodeElement(_bcfdc.PrnPr, &_afgcc); _ebacc != nil {
					return _ebacc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "showPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "showPr"}:
				_bcfdc.ShowPr = NewCT_ShowProperties()
				if _cgbae := d.DecodeElement(_bcfdc.ShowPr, &_afgcc); _cgbae != nil {
					return _cgbae
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMru"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMru"}:
				_bcfdc.ClrMru = _cb.NewCT_ColorMRU()
				if _bggfg := d.DecodeElement(_bcfdc.ClrMru, &_afgcc); _bggfg != nil {
					return _bggfg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_bcfdc.ExtLst = NewCT_ExtensionList()
				if _edbbf := d.DecodeElement(_bcfdc.ExtLst, &_afgcc); _edbbf != nil {
					return _edbbf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020PresentationPr\u0020\u0025v", _afgcc.Name)
				if _ebfd := d.Skip(); _ebfd != nil {
					return _ebfd
				}
			}
		case _e.EndElement:
			break _bdbdc
		case _e.CharData:
		}
	}
	return nil
}
func (_bbgba ST_TLBehaviorOverrideType) Validate() error { return _bbgba.ValidateWithPath("") }

// ValidateWithPath validates the CT_Connector and its children, prefixing error messages with path
func (_fgf *CT_Connector) ValidateWithPath(path string) error {
	if _edc := _fgf.NvCxnSpPr.ValidateWithPath(path + "\u002fNvCxnSpPr"); _edc != nil {
		return _edc
	}
	if _gec := _fgf.SpPr.ValidateWithPath(path + "\u002fSpPr"); _gec != nil {
		return _gec
	}
	if _fgf.Style != nil {
		if _bafe := _fgf.Style.ValidateWithPath(path + "\u002fStyle"); _bafe != nil {
			return _bafe
		}
	}
	if _fgf.ExtLst != nil {
		if _cga := _fgf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cga != nil {
			return _cga
		}
	}
	return nil
}
func NewCT_OutlineViewSlideList() *CT_OutlineViewSlideList {
	_fbcf := &CT_OutlineViewSlideList{}
	return _fbcf
}
func (_dbdaff *ST_PhotoAlbumFrameShape) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_dbdaff = 0
	case "frameStyle1":
		*_dbdaff = 1
	case "frameStyle2":
		*_dbdaff = 2
	case "frameStyle3":
		*_dbdaff = 3
	case "frameStyle4":
		*_dbdaff = 4
	case "frameStyle5":
		*_dbdaff = 5
	case "frameStyle6":
		*_dbdaff = 6
	case "frameStyle7":
		*_dbdaff = 7
	}
	return nil
}
func (_cbae *CT_OleObjectLink) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _cbae.UpdateAutomaticAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "updateAutomatic"}, Value: _c.Sprintf("\u0025d", _fdeab(*_cbae.UpdateAutomaticAttr))})
	}
	e.EncodeToken(start)
	if _cbae.ExtLst != nil {
		_abad := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_cbae.ExtLst, _abad)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

const (
	ST_PhotoAlbumLayoutUnset      ST_PhotoAlbumLayout = 0
	ST_PhotoAlbumLayoutFitToSlide ST_PhotoAlbumLayout = 1
	ST_PhotoAlbumLayout1pic       ST_PhotoAlbumLayout = 2
	ST_PhotoAlbumLayout2pic       ST_PhotoAlbumLayout = 3
	ST_PhotoAlbumLayout4pic       ST_PhotoAlbumLayout = 4
	ST_PhotoAlbumLayout1picTitle  ST_PhotoAlbumLayout = 5
	ST_PhotoAlbumLayout2picTitle  ST_PhotoAlbumLayout = 6
	ST_PhotoAlbumLayout4picTitle  ST_PhotoAlbumLayout = 7
)

func (_adfg *ST_PrintColorMode) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gaceg, _egdf := d.Token()
	if _egdf != nil {
		return _egdf
	}
	if _bagab, _dbfc := _gaceg.(_e.EndElement); _dbfc && _bagab.Name == start.Name {
		*_adfg = 1
		return nil
	}
	if _feafg, _cbcfa := _gaceg.(_e.CharData); !_cbcfa {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gaceg)
	} else {
		switch string(_feafg) {
		case "":
			*_adfg = 0
		case "bw":
			*_adfg = 1
		case "gray":
			*_adfg = 2
		case "clr":
			*_adfg = 3
		}
	}
	_gaceg, _egdf = d.Token()
	if _egdf != nil {
		return _egdf
	}
	if _ggdcc, _fefa := _gaceg.(_e.EndElement); _fefa && _ggdcc.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gaceg)
}
func (_facgg *HandoutMaster) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_facgg.CT_HandoutMaster = *NewCT_HandoutMaster()
_eebb:
	for {
		_ebdf, _bfegg := d.Token()
		if _bfegg != nil {
			return _bfegg
		}
		switch _edacb := _ebdf.(type) {
		case _e.StartElement:
			switch _edacb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _dfdf := d.DecodeElement(_facgg.CSld, &_edacb); _dfdf != nil {
					return _dfdf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMap"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMap"}:
				if _cebged := d.DecodeElement(_facgg.ClrMap, &_edacb); _cebged != nil {
					return _cebged
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "hf"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "hf"}:
				_facgg.Hf = NewCT_HeaderFooter()
				if _fdfbef := d.DecodeElement(_facgg.Hf, &_edacb); _fdfbef != nil {
					return _fdfbef
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_facgg.ExtLst = NewCT_ExtensionListModify()
				if _cafd := d.DecodeElement(_facgg.ExtLst, &_edacb); _cafd != nil {
					return _cafd
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020HandoutMaster \u0025v", _edacb.Name)
				if _ggfbd := d.Skip(); _ggfbd != nil {
					return _ggfbd
				}
			}
		case _e.EndElement:
			break _eebb
		case _e.CharData:
		}
	}
	return nil
}
func (_daag *ST_TransitionInOutDirectionType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dbcea, _debgg := d.Token()
	if _debgg != nil {
		return _debgg
	}
	if _gbece, _edebac := _dbcea.(_e.EndElement); _edebac && _gbece.Name == start.Name {
		*_daag = 1
		return nil
	}
	if _cbge, _dfaec := _dbcea.(_e.CharData); !_dfaec {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dbcea)
	} else {
		switch string(_cbge) {
		case "":
			*_daag = 0
		case "out":
			*_daag = 1
		case "in":
			*_daag = 2
		}
	}
	_dbcea, _debgg = d.Token()
	if _debgg != nil {
		return _debgg
	}
	if _dgdae, _baebcg := _dbcea.(_e.EndElement); _baebcg && _dgdae.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dbcea)
}

// Validate validates the CT_ControlList and its children
func (_fddc *CT_ControlList) Validate() error { return _fddc.ValidateWithPath("CT_ControlList") }

type CT_HandoutMasterIdList struct {

	// Handout Master ID
	HandoutMasterId *CT_HandoutMasterIdListEntry
}

func NewCT_HandoutMasterIdList() *CT_HandoutMasterIdList {
	_aecf := &CT_HandoutMasterIdList{}
	return _aecf
}

type CT_TLBehaviorAttributeNameList struct {

	// Attribute Name
	AttrName []string
}

func (_gecag *CT_TLAnimateRotationBehavior) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gecag.CBhvr = NewCT_TLCommonBehaviorData()
	for _, _eacg := range start.Attr {
		if _eacg.Name.Local == "by" {
			_gecdd, _cccf := _b.ParseInt(_eacg.Value, 10, 32)
			if _cccf != nil {
				return _cccf
			}
			_abfb := int32(_gecdd)
			_gecag.ByAttr = &_abfb
			continue
		}
		if _eacg.Name.Local == "from" {
			_dbdbg, _bccb := _b.ParseInt(_eacg.Value, 10, 32)
			if _bccb != nil {
				return _bccb
			}
			_bggab := int32(_dbdbg)
			_gecag.FromAttr = &_bggab
			continue
		}
		if _eacg.Name.Local == "to" {
			_abgb, _daed := _b.ParseInt(_eacg.Value, 10, 32)
			if _daed != nil {
				return _daed
			}
			_bgaa := int32(_abgb)
			_gecag.ToAttr = &_bgaa
			continue
		}
	}
_edea:
	for {
		_caaag, _bdeca := d.Token()
		if _bdeca != nil {
			return _bdeca
		}
		switch _caac := _caaag.(type) {
		case _e.StartElement:
			switch _caac.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cBhvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cBhvr"}:
				if _eaga := d.DecodeElement(_gecag.CBhvr, &_caac); _eaga != nil {
					return _eaga
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_TLAnimateRotationBehavior\u0020\u0025v", _caac.Name)
				if _gfedg := d.Skip(); _gfedg != nil {
					return _gfedg
				}
			}
		case _e.EndElement:
			break _edea
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TLCommonTimeNodeData and its children, prefixing error messages with path
func (_bgcfa *CT_TLCommonTimeNodeData) ValidateWithPath(path string) error {
	if _dbgdd := _bgcfa.PresetClassAttr.ValidateWithPath(path + "\u002fPresetClassAttr"); _dbgdd != nil {
		return _dbgdd
	}
	if _bgcfa.DurAttr != nil {
		if _fafe := _bgcfa.DurAttr.ValidateWithPath(path + "\u002fDurAttr"); _fafe != nil {
			return _fafe
		}
	}
	if _bgcfa.RepeatCountAttr != nil {
		if _accaae := _bgcfa.RepeatCountAttr.ValidateWithPath(path + "\u002fRepeatCountAttr"); _accaae != nil {
			return _accaae
		}
	}
	if _bgcfa.RepeatDurAttr != nil {
		if _cafc := _bgcfa.RepeatDurAttr.ValidateWithPath(path + "\u002fRepeatDurAttr"); _cafc != nil {
			return _cafc
		}
	}
	if _bgcfa.SpdAttr != nil {
		if _cgeea := _bgcfa.SpdAttr.ValidateWithPath(path + "\u002fSpdAttr"); _cgeea != nil {
			return _cgeea
		}
	}
	if _bgcfa.AccelAttr != nil {
		if _dbabg := _bgcfa.AccelAttr.ValidateWithPath(path + "\u002fAccelAttr"); _dbabg != nil {
			return _dbabg
		}
	}
	if _bgcfa.DecelAttr != nil {
		if _aadcf := _bgcfa.DecelAttr.ValidateWithPath(path + "\u002fDecelAttr"); _aadcf != nil {
			return _aadcf
		}
	}
	if _ebecg := _bgcfa.RestartAttr.ValidateWithPath(path + "\u002fRestartAttr"); _ebecg != nil {
		return _ebecg
	}
	if _ccgag := _bgcfa.FillAttr.ValidateWithPath(path + "\u002fFillAttr"); _ccgag != nil {
		return _ccgag
	}
	if _agdeb := _bgcfa.SyncBehaviorAttr.ValidateWithPath(path + "\u002fSyncBehaviorAttr"); _agdeb != nil {
		return _agdeb
	}
	if _ggcgg := _bgcfa.MasterRelAttr.ValidateWithPath(path + "\u002fMasterRelAttr"); _ggcgg != nil {
		return _ggcgg
	}
	if _aega := _bgcfa.NodeTypeAttr.ValidateWithPath(path + "\u002fNodeTypeAttr"); _aega != nil {
		return _aega
	}
	if _bgcfa.StCondLst != nil {
		if _egbfa := _bgcfa.StCondLst.ValidateWithPath(path + "\u002fStCondLst"); _egbfa != nil {
			return _egbfa
		}
	}
	if _bgcfa.EndCondLst != nil {
		if _bcgfec := _bgcfa.EndCondLst.ValidateWithPath(path + "/EndCondLst"); _bcgfec != nil {
			return _bcgfec
		}
	}
	if _bgcfa.EndSync != nil {
		if _dbdc := _bgcfa.EndSync.ValidateWithPath(path + "\u002fEndSync"); _dbdc != nil {
			return _dbdc
		}
	}
	if _bgcfa.Iterate != nil {
		if _gddb := _bgcfa.Iterate.ValidateWithPath(path + "\u002fIterate"); _gddb != nil {
			return _gddb
		}
	}
	if _bgcfa.ChildTnLst != nil {
		if _gefe := _bgcfa.ChildTnLst.ValidateWithPath(path + "/ChildTnLst"); _gefe != nil {
			return _gefe
		}
	}
	if _bgcfa.SubTnLst != nil {
		if _dgbe := _bgcfa.SubTnLst.ValidateWithPath(path + "\u002fSubTnLst"); _dgbe != nil {
			return _dgbe
		}
	}
	return nil
}

type CT_OleObjectLink struct {

	// Update Linked Embedded Objects Automatically
	UpdateAutomaticAttr *bool
	ExtLst              *CT_ExtensionList
}

// ValidateWithPath validates the CT_TLAnimVariant and its children, prefixing error messages with path
func (_fgad *CT_TLAnimVariant) ValidateWithPath(path string) error {
	if _fgad.BoolVal != nil {
		if _aaga := _fgad.BoolVal.ValidateWithPath(path + "\u002fBoolVal"); _aaga != nil {
			return _aaga
		}
	}
	if _fgad.IntVal != nil {
		if _becdd := _fgad.IntVal.ValidateWithPath(path + "\u002fIntVal"); _becdd != nil {
			return _becdd
		}
	}
	if _fgad.FltVal != nil {
		if _gbdfa := _fgad.FltVal.ValidateWithPath(path + "\u002fFltVal"); _gbdfa != nil {
			return _gbdfa
		}
	}
	if _fgad.StrVal != nil {
		if _abbbe := _fgad.StrVal.ValidateWithPath(path + "\u002fStrVal"); _abbbe != nil {
			return _abbbe
		}
	}
	if _fgad.ClrVal != nil {
		if _acad := _fgad.ClrVal.ValidateWithPath(path + "\u002fClrVal"); _acad != nil {
			return _acad
		}
	}
	return nil
}

// Validate validates the CT_ShowInfoKiosk and its children
func (_ccefd *CT_ShowInfoKiosk) Validate() error { return _ccefd.ValidateWithPath("CT_ShowInfoKiosk") }
func (_dfagg ST_TransitionSpeed) ValidateWithPath(path string) error {
	switch _dfagg {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dfagg))
	}
	return nil
}

const (
	ST_TLAnimateMotionPathEditModeUnset    ST_TLAnimateMotionPathEditMode = 0
	ST_TLAnimateMotionPathEditModeRelative ST_TLAnimateMotionPathEditMode = 1
	ST_TLAnimateMotionPathEditModeFixed    ST_TLAnimateMotionPathEditMode = 2
)

// Validate validates the CT_TLByAnimateColorTransform and its children
func (_ebccg *CT_TLByAnimateColorTransform) Validate() error {
	return _ebccg.ValidateWithPath("CT_TLByAnimateColorTransform")
}
func (_dgeab *EG_Background) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _dgeab.BgPr != nil {
		_befb := _e.StartElement{Name: _e.Name{Local: "p:bgPr"}}
		e.EncodeElement(_dgeab.BgPr, _befb)
	}
	if _dgeab.BgRef != nil {
		_dagac := _e.StartElement{Name: _e.Name{Local: "p:bgRef"}}
		e.EncodeElement(_dgeab.BgRef, _dagac)
	}
	return nil
}

const (
	ST_TLDiagramBuildTypeUnset         ST_TLDiagramBuildType = 0
	ST_TLDiagramBuildTypeWhole         ST_TLDiagramBuildType = 1
	ST_TLDiagramBuildTypeDepthByNode   ST_TLDiagramBuildType = 2
	ST_TLDiagramBuildTypeDepthByBranch ST_TLDiagramBuildType = 3
	ST_TLDiagramBuildTypeBreadthByNode ST_TLDiagramBuildType = 4
	ST_TLDiagramBuildTypeBreadthByLvl  ST_TLDiagramBuildType = 5
	ST_TLDiagramBuildTypeCw            ST_TLDiagramBuildType = 6
	ST_TLDiagramBuildTypeCwIn          ST_TLDiagramBuildType = 7
	ST_TLDiagramBuildTypeCwOut         ST_TLDiagramBuildType = 8
	ST_TLDiagramBuildTypeCcw           ST_TLDiagramBuildType = 9
	ST_TLDiagramBuildTypeCcwIn         ST_TLDiagramBuildType = 10
	ST_TLDiagramBuildTypeCcwOut        ST_TLDiagramBuildType = 11
	ST_TLDiagramBuildTypeInByRing      ST_TLDiagramBuildType = 12
	ST_TLDiagramBuildTypeOutByRing     ST_TLDiagramBuildType = 13
	ST_TLDiagramBuildTypeUp            ST_TLDiagramBuildType = 14
	ST_TLDiagramBuildTypeDown          ST_TLDiagramBuildType = 15
	ST_TLDiagramBuildTypeAllAtOnce     ST_TLDiagramBuildType = 16
	ST_TLDiagramBuildTypeCust          ST_TLDiagramBuildType = 17
)

type CT_WheelTransition struct {

	// Spokes
	SpokesAttr *uint32
}

// Validate validates the CT_TLTimeConditionList and its children
func (_bgced *CT_TLTimeConditionList) Validate() error {
	return _bgced.ValidateWithPath("CT_TLTimeConditionList")
}

// ValidateWithPath validates the CT_TLTimeAnimateValue and its children, prefixing error messages with path
func (_bdgdf *CT_TLTimeAnimateValue) ValidateWithPath(path string) error {
	if _bdgdf.TmAttr != nil {
		if _ceffe := _bdgdf.TmAttr.ValidateWithPath(path + "\u002fTmAttr"); _ceffe != nil {
			return _ceffe
		}
	}
	if _bdgdf.Val != nil {
		if _fdbbe := _bdgdf.Val.ValidateWithPath(path + "\u002fVal"); _fdbbe != nil {
			return _fdbbe
		}
	}
	return nil
}
func (_defd ST_TLTriggerEvent) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_dbbff := _e.Attr{}
	_dbbff.Name = name
	switch _defd {
	case ST_TLTriggerEventUnset:
		_dbbff.Value = ""
	case ST_TLTriggerEventOnBegin:
		_dbbff.Value = "onBegin"
	case ST_TLTriggerEventOnEnd:
		_dbbff.Value = "onEnd"
	case ST_TLTriggerEventBegin:
		_dbbff.Value = "begin"
	case ST_TLTriggerEventEnd:
		_dbbff.Value = "end"
	case ST_TLTriggerEventOnClick:
		_dbbff.Value = "onClick"
	case ST_TLTriggerEventOnDblClick:
		_dbbff.Value = "onDblClick"
	case ST_TLTriggerEventOnMouseOver:
		_dbbff.Value = "onMouseOver"
	case ST_TLTriggerEventOnMouseOut:
		_dbbff.Value = "onMouseOut"
	case ST_TLTriggerEventOnNext:
		_dbbff.Value = "onNext"
	case ST_TLTriggerEventOnPrev:
		_dbbff.Value = "onPrev"
	case ST_TLTriggerEventOnStopAudio:
		_dbbff.Value = "onStopAudio"
	}
	return _dbbff, nil
}

// ValidateWithPath validates the CT_Background and its children, prefixing error messages with path
func (_gcg *CT_Background) ValidateWithPath(path string) error {
	if _cgg := _gcg.BwModeAttr.ValidateWithPath(path + "/BwModeAttr"); _cgg != nil {
		return _cgg
	}
	if _gcg.BgPr != nil {
		if _bfc := _gcg.BgPr.ValidateWithPath(path + "\u002fBgPr"); _bfc != nil {
			return _bfc
		}
	}
	if _gcg.BgRef != nil {
		if _ece := _gcg.BgRef.ValidateWithPath(path + "\u002fBgRef"); _ece != nil {
			return _ece
		}
	}
	return nil
}
func (_gbd *CT_CommentList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _gbd.Cm != nil {
		_dcgg := _e.StartElement{Name: _e.Name{Local: "p:cm"}}
		for _, _dbffb := range _gbd.Cm {
			e.EncodeElement(_dbffb, _dcgg)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_ggfed *CT_TLAnimVariantIntegerVal) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _agcaf := range start.Attr {
		if _agcaf.Name.Local == "val" {
			_daced, _bgec := _b.ParseInt(_agcaf.Value, 10, 32)
			if _bgec != nil {
				return _bgec
			}
			_ggfed.ValAttr = int32(_daced)
			continue
		}
	}
	for {
		_ffbfd, _bdebe := d.Token()
		if _bdebe != nil {
			return _c.Errorf("parsing\u0020CT_TLAnimVariantIntegerVal:\u0020\u0025s", _bdebe)
		}
		if _cegg, _caea := _ffbfd.(_e.EndElement); _caea && _cegg.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_TLAnimVariantFloatVal() *CT_TLAnimVariantFloatVal {
	_dbfaa := &CT_TLAnimVariantFloatVal{}
	return _dbfaa
}
func (_fbbd *CT_TLAnimateScaleBehavior) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _fbbd.ZoomContentsAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "zoomContents"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fbbd.ZoomContentsAttr))})
	}
	e.EncodeToken(start)
	_gfgag := _e.StartElement{Name: _e.Name{Local: "p:cBhvr"}}
	e.EncodeElement(_fbbd.CBhvr, _gfgag)
	if _fbbd.By != nil {
		_fbga := _e.StartElement{Name: _e.Name{Local: "p:by"}}
		e.EncodeElement(_fbbd.By, _fbga)
	}
	if _fbbd.From != nil {
		_aegb := _e.StartElement{Name: _e.Name{Local: "p:from"}}
		e.EncodeElement(_fbbd.From, _aegb)
	}
	if _fbbd.To != nil {
		_fbdb := _e.StartElement{Name: _e.Name{Local: "p:to"}}
		e.EncodeElement(_fbbd.To, _fbdb)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_gefbb *SldSyncPr) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:sldSyncPr"
	return _gefbb.CT_SlideSyncProperties.MarshalXML(e, start)
}
func (_gdfdb ST_TLTriggerEvent) String() string {
	switch _gdfdb {
	case 0:
		return ""
	case 1:
		return "onBegin"
	case 2:
		return "onEnd"
	case 3:
		return "begin"
	case 4:
		return "end"
	case 5:
		return "onClick"
	case 6:
		return "onDblClick"
	case 7:
		return "onMouseOver"
	case 8:
		return "onMouseOut"
	case 9:
		return "onNext"
	case 10:
		return "onPrev"
	case 11:
		return "onStopAudio"
	}
	return ""
}

// ValidateWithPath validates the CT_TLCommandBehavior and its children, prefixing error messages with path
func (_cddb *CT_TLCommandBehavior) ValidateWithPath(path string) error {
	if _bfdb := _cddb.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _bfdb != nil {
		return _bfdb
	}
	if _edgbc := _cddb.CBhvr.ValidateWithPath(path + "\u002fCBhvr"); _edgbc != nil {
		return _edgbc
	}
	return nil
}

// ValidateWithPath validates the CT_SlideTransition and its children, prefixing error messages with path
func (_bcbce *CT_SlideTransition) ValidateWithPath(path string) error {
	if _adgcc := _bcbce.SpdAttr.ValidateWithPath(path + "\u002fSpdAttr"); _adgcc != nil {
		return _adgcc
	}
	if _bcbce.Choice != nil {
		if _beddc := _bcbce.Choice.ValidateWithPath(path + "\u002fChoice"); _beddc != nil {
			return _beddc
		}
	}
	if _bcbce.SndAc != nil {
		if _defe := _bcbce.SndAc.ValidateWithPath(path + "\u002fSndAc"); _defe != nil {
			return _defe
		}
	}
	if _bcbce.ExtLst != nil {
		if _baag := _bcbce.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _baag != nil {
			return _baag
		}
	}
	return nil
}
func NewCT_TLTimeNodeSequence() *CT_TLTimeNodeSequence {
	_fafff := &CT_TLTimeNodeSequence{}
	_fafff.CTn = NewCT_TLCommonTimeNodeData()
	return _fafff
}
func NewSldMaster() *SldMaster {
	_adfc := &SldMaster{}
	_adfc.CT_SlideMaster = *NewCT_SlideMaster()
	return _adfc
}
func (_gaaa *CT_NormalViewProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gaaa.ShowOutlineIconsAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showOutlineIcons"}, Value: _c.Sprintf("\u0025d", _fdeab(*_gaaa.ShowOutlineIconsAttr))})
	}
	if _gaaa.SnapVertSplitterAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "snapVertSplitter"}, Value: _c.Sprintf("\u0025d", _fdeab(*_gaaa.SnapVertSplitterAttr))})
	}
	if _gaaa.VertBarStateAttr != ST_SplitterBarStateUnset {
		_ggbf, _fcgc := _gaaa.VertBarStateAttr.MarshalXMLAttr(_e.Name{Local: "vertBarState"})
		if _fcgc != nil {
			return _fcgc
		}
		start.Attr = append(start.Attr, _ggbf)
	}
	if _gaaa.HorzBarStateAttr != ST_SplitterBarStateUnset {
		_eegac, _edbg := _gaaa.HorzBarStateAttr.MarshalXMLAttr(_e.Name{Local: "horzBarState"})
		if _edbg != nil {
			return _edbg
		}
		start.Attr = append(start.Attr, _eegac)
	}
	if _gaaa.PreferSingleViewAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "preferSingleView"}, Value: _c.Sprintf("\u0025d", _fdeab(*_gaaa.PreferSingleViewAttr))})
	}
	e.EncodeToken(start)
	_cdgc := _e.StartElement{Name: _e.Name{Local: "p:restoredLeft"}}
	e.EncodeElement(_gaaa.RestoredLeft, _cdgc)
	_gcbdg := _e.StartElement{Name: _e.Name{Local: "p:restoredTop"}}
	e.EncodeElement(_gaaa.RestoredTop, _gcbdg)
	if _gaaa.ExtLst != nil {
		_dbbg := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_gaaa.ExtLst, _dbbg)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_fgbcb ST_TransitionInOutDirectionType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_accagc := _e.Attr{}
	_accagc.Name = name
	switch _fgbcb {
	case ST_TransitionInOutDirectionTypeUnset:
		_accagc.Value = ""
	case ST_TransitionInOutDirectionTypeOut:
		_accagc.Value = "out"
	case ST_TransitionInOutDirectionTypeIn:
		_accagc.Value = "in"
	}
	return _accagc, nil
}

type CT_CommentList struct {

	// Comment
	Cm []*CT_Comment
}

func (_eegag *ST_SplitterBarState) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dbdbf, _bbbaac := d.Token()
	if _bbbaac != nil {
		return _bbbaac
	}
	if _adeedc, _abaac := _dbdbf.(_e.EndElement); _abaac && _adeedc.Name == start.Name {
		*_eegag = 1
		return nil
	}
	if _fdeae, _gedce := _dbdbf.(_e.CharData); !_gedce {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dbdbf)
	} else {
		switch string(_fdeae) {
		case "":
			*_eegag = 0
		case "minimized":
			*_eegag = 1
		case "restored":
			*_eegag = 2
		case "maximized":
			*_eegag = 3
		}
	}
	_dbdbf, _bbbaac = d.Token()
	if _bbbaac != nil {
		return _bbbaac
	}
	if _dgedd, _bfgbf := _dbdbf.(_e.EndElement); _bfgbf && _dgedd.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dbdbf)
}

// Validate validates the CT_PresentationProperties and its children
func (_cebbg *CT_PresentationProperties) Validate() error {
	return _cebbg.ValidateWithPath("CT_PresentationProperties")
}
func (_ddfac *CT_OutlineViewSlideList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_bcgbe:
	for {
		_fgbf, _afee := d.Token()
		if _afee != nil {
			return _afee
		}
		switch _gbdad := _fgbf.(type) {
		case _e.StartElement:
			switch _gbdad.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sld"}:
				_cfef := NewCT_OutlineViewSlideEntry()
				if _fgbdf := d.DecodeElement(_cfef, &_gbdad); _fgbdf != nil {
					return _fgbdf
				}
				_ddfac.Sld = append(_ddfac.Sld, _cfef)
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_OutlineViewSlideList \u0025v", _gbdad.Name)
				if _bfee := d.Skip(); _bfee != nil {
					return _bfee
				}
			}
		case _e.EndElement:
			break _bcgbe
		case _e.CharData:
		}
	}
	return nil
}
func (_gbaf *CT_TLBehaviorAttributeNameList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_gafa:
	for {
		_bcdge, _cddda := d.Token()
		if _cddda != nil {
			return _cddda
		}
		switch _beab := _bcdge.(type) {
		case _e.StartElement:
			switch _beab.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "attrName"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "attrName"}:
				var _abgfb string
				if _gffee := d.DecodeElement(&_abgfb, &_beab); _gffee != nil {
					return _gffee
				}
				_gbaf.AttrName = append(_gbaf.AttrName, _abgfb)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLBehaviorAttributeNameList\u0020\u0025v", _beab.Name)
				if _bcbdg := d.Skip(); _bcbdg != nil {
					return _bcbdg
				}
			}
		case _e.EndElement:
			break _gafa
		case _e.CharData:
		}
	}
	return nil
}
func (_edgf ST_IterateType) ValidateWithPath(path string) error {
	switch _edgf {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_edgf))
	}
	return nil
}

type CT_TLTimeNodeSequence struct {

	// Concurrent
	ConcurrentAttr *bool

	// Previous Action
	PrevAcAttr ST_TLPreviousActionType

	// Next Action
	NextAcAttr ST_TLNextActionType

	// Common TimeNode Properties
	CTn *CT_TLCommonTimeNodeData

	// Previous Conditions List
	PrevCondLst *CT_TLTimeConditionList

	// Next Conditions List
	NextCondLst *CT_TLTimeConditionList
}

func (_eged *CT_Guide) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _gdbd := range start.Attr {
		if _gdbd.Name.Local == "orient" {
			_eged.OrientAttr.UnmarshalXMLAttr(_gdbd)
			continue
		}
		if _gdbd.Name.Local == "pos" {
			_cgdc, _fdac := ParseUnionST_Coordinate32(_gdbd.Value)
			if _fdac != nil {
				return _fdac
			}
			_eged.PosAttr = &_cgdc
			continue
		}
	}
	for {
		_edce, _bddd := d.Token()
		if _bddd != nil {
			return _c.Errorf("parsing\u0020CT_Guide: \u0025s", _bddd)
		}
		if _fefb, _gega := _edce.(_e.EndElement); _gega && _fefb.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_TransitionStartSoundAction struct {

	// Loop Sound
	LoopAttr *bool

	// Sound
	Snd *_cb.CT_EmbeddedWAVAudioFile
}

func (_fbaff *ST_TLTimeNodeFillType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_fbaff = 0
	case "remove":
		*_fbaff = 1
	case "freeze":
		*_fbaff = 2
	case "hold":
		*_fbaff = 3
	case "transition":
		*_fbaff = 4
	}
	return nil
}
func NewCT_PictureNonVisual() *CT_PictureNonVisual {
	_dbda := &CT_PictureNonVisual{}
	_dbda.CNvPr = _cb.NewCT_NonVisualDrawingProps()
	_dbda.CNvPicPr = _cb.NewCT_NonVisualPictureProperties()
	_dbda.NvPr = NewCT_ApplicationNonVisualDrawingProps()
	return _dbda
}

type OleObj struct{ CT_OleObject }

func (_dgab ST_TLTimeIndefinite) Validate() error { return _dgab.ValidateWithPath("") }
func (_fadfg ST_PrintWhat) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_acccd := _e.Attr{}
	_acccd.Name = name
	switch _fadfg {
	case ST_PrintWhatUnset:
		_acccd.Value = ""
	case ST_PrintWhatSlides:
		_acccd.Value = "slides"
	case ST_PrintWhatHandouts1:
		_acccd.Value = "handouts1"
	case ST_PrintWhatHandouts2:
		_acccd.Value = "handouts2"
	case ST_PrintWhatHandouts3:
		_acccd.Value = "handouts3"
	case ST_PrintWhatHandouts4:
		_acccd.Value = "handouts4"
	case ST_PrintWhatHandouts6:
		_acccd.Value = "handouts6"
	case ST_PrintWhatHandouts9:
		_acccd.Value = "handouts9"
	case ST_PrintWhatNotes:
		_acccd.Value = "notes"
	case ST_PrintWhatOutline:
		_acccd.Value = "outline"
	}
	return _acccd, nil
}

type CT_TLTextTargetElement struct {

	// Character Range
	CharRg *CT_IndexRange

	// Paragraph Text Range
	PRg *CT_IndexRange
}

func NewOleObj() *OleObj {
	_ceecd := &OleObj{}
	_ceecd.CT_OleObject = *NewCT_OleObject()
	return _ceecd
}
func (_aeeff *CT_TLIterateIntervalPercentage) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "val"}, Value: _c.Sprintf("\u0025v", _aeeff.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TLShapeTargetElement and its children, prefixing error messages with path
func (_adfda *CT_TLShapeTargetElement) ValidateWithPath(path string) error {
	if _adfda.Bg != nil {
		if _daca := _adfda.Bg.ValidateWithPath(path + "\u002fBg"); _daca != nil {
			return _daca
		}
	}
	if _adfda.SubSp != nil {
		if _cffba := _adfda.SubSp.ValidateWithPath(path + "\u002fSubSp"); _cffba != nil {
			return _cffba
		}
	}
	if _adfda.OleChartEl != nil {
		if _bdegg := _adfda.OleChartEl.ValidateWithPath(path + "/OleChartEl"); _bdegg != nil {
			return _bdegg
		}
	}
	if _adfda.TxEl != nil {
		if _cebff := _adfda.TxEl.ValidateWithPath(path + "\u002fTxEl"); _cebff != nil {
			return _cebff
		}
	}
	if _adfda.GraphicEl != nil {
		if _gffff := _adfda.GraphicEl.ValidateWithPath(path + "\u002fGraphicEl"); _gffff != nil {
			return _gffff
		}
	}
	return nil
}
func (_dggdd ST_TransitionCornerDirectionType) String() string {
	switch _dggdd {
	case 0:
		return ""
	case 1:
		return "lu"
	case 2:
		return "ru"
	case 3:
		return "ld"
	case 4:
		return "rd"
	}
	return ""
}

// Validate validates the Notes and its children
func (_acefd *Notes) Validate() error { return _acefd.ValidateWithPath("Notes") }
func NewCT_TransitionSoundAction() *CT_TransitionSoundAction {
	_cbfcg := &CT_TransitionSoundAction{}
	return _cbfcg
}

// ValidateWithPath validates the ViewPr and its children, prefixing error messages with path
func (_daba *ViewPr) ValidateWithPath(path string) error {
	if _aggde := _daba.CT_ViewProperties.ValidateWithPath(path); _aggde != nil {
		return _aggde
	}
	return nil
}
func (_dagda *CT_TLTemplateList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _dagda.Tmpl != nil {
		_fabe := _e.StartElement{Name: _e.Name{Local: "p:tmpl"}}
		for _, _ggbgg := range _dagda.Tmpl {
			e.EncodeElement(_ggbgg, _fabe)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TLMediaNodeVideo and its children, prefixing error messages with path
func (_dagaf *CT_TLMediaNodeVideo) ValidateWithPath(path string) error {
	if _bgccf := _dagaf.CMediaNode.ValidateWithPath(path + "/CMediaNode"); _bgccf != nil {
		return _bgccf
	}
	return nil
}
func (_bagca *CT_SlideTiming) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_ecebb:
	for {
		_dfdd, _dfggf := d.Token()
		if _dfggf != nil {
			return _dfggf
		}
		switch _dddg := _dfdd.(type) {
		case _e.StartElement:
			switch _dddg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tnLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tnLst"}:
				_bagca.TnLst = NewCT_TimeNodeList()
				if _eacd := d.DecodeElement(_bagca.TnLst, &_dddg); _eacd != nil {
					return _eacd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bldLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bldLst"}:
				_bagca.BldLst = NewCT_BuildList()
				if _cegaf := d.DecodeElement(_bagca.BldLst, &_dddg); _cegaf != nil {
					return _cegaf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_bagca.ExtLst = NewCT_ExtensionListModify()
				if _gdbg := d.DecodeElement(_bagca.ExtLst, &_dddg); _gdbg != nil {
					return _gdbg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SlideTiming\u0020\u0025v", _dddg.Name)
				if _befaf := d.Skip(); _befaf != nil {
					return _befaf
				}
			}
		case _e.EndElement:
			break _ecebb
		case _e.CharData:
		}
	}
	return nil
}
func (_gedee *CT_SlideRelationshipList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_fgde:
	for {
		_ccgf, _cebc := d.Token()
		if _cebc != nil {
			return _cebc
		}
		switch _bdce := _ccgf.(type) {
		case _e.StartElement:
			switch _bdce.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sld"}:
				_abeef := NewCT_SlideRelationshipListEntry()
				if _cffaf := d.DecodeElement(_abeef, &_bdce); _cffaf != nil {
					return _cffaf
				}
				_gedee.Sld = append(_gedee.Sld, _abeef)
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_SlideRelationshipList\u0020%v", _bdce.Name)
				if _ddfc := d.Skip(); _ddfc != nil {
					return _ddfc
				}
			}
		case _e.EndElement:
			break _fgde
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Kinsoku and its children
func (_begf *CT_Kinsoku) Validate() error { return _begf.ValidateWithPath("CT_Kinsoku") }
func NewCT_SlideSyncProperties() *CT_SlideSyncProperties {
	_dfab := &CT_SlideSyncProperties{}
	return _dfab
}

type CT_ControlList struct {

	// Embedded Control
	Control []*CT_Control
}

// ValidateWithPath validates the CT_WebProperties and its children, prefixing error messages with path
func (_bggac *CT_WebProperties) ValidateWithPath(path string) error {
	if _dfcgg := _bggac.ImgSzAttr.ValidateWithPath(path + "\u002fImgSzAttr"); _dfcgg != nil {
		return _dfcgg
	}
	if _dfed := _bggac.ClrAttr.ValidateWithPath(path + "\u002fClrAttr"); _dfed != nil {
		return _dfed
	}
	if _bggac.ExtLst != nil {
		if _eaaebd := _bggac.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eaaebd != nil {
			return _eaaebd
		}
	}
	return nil
}
func (_eeade ST_TLBehaviorOverrideType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_eeade.String(), start)
}
func (_fcdd *OleObj) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:oleObj"
	return _fcdd.CT_OleObject.MarshalXML(e, start)
}

type CT_Rel struct{ IdAttr string }

func (_cbgfb ST_TLAnimateBehaviorCalcMode) String() string {
	switch _cbgfb {
	case 0:
		return ""
	case 1:
		return "discrete"
	case 2:
		return "lin"
	case 3:
		return "fmla"
	}
	return ""
}
func (_abggg *ST_TLTimeIndefinite) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_abggg = 0
	case "indefinite":
		*_abggg = 1
	}
	return nil
}
func (_bgege *CT_TLByAnimateColorTransform) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _bgege.Rgb != nil {
		_bcfd := _e.StartElement{Name: _e.Name{Local: "p:rgb"}}
		e.EncodeElement(_bgege.Rgb, _bcfd)
	}
	if _bgege.Hsl != nil {
		_bged := _e.StartElement{Name: _e.Name{Local: "p:hsl"}}
		e.EncodeElement(_bgege.Hsl, _bged)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TLTimeNodeSequence and its children
func (_bdcff *CT_TLTimeNodeSequence) Validate() error {
	return _bdcff.ValidateWithPath("CT_TLTimeNodeSequence")
}

type CT_TLTriggerRuntimeNode struct {

	// Value
	ValAttr ST_TLTriggerRuntimeNode
}
type CT_Presentation struct {

	// Server Zoom
	ServerZoomAttr *_cb.ST_Percentage

	// First Slide Number
	FirstSlideNumAttr *int32

	// Show Header and Footer Placeholders on Titles
	ShowSpecialPlsOnTitleSldAttr *bool

	// Right-To-Left Views
	RtlAttr *bool

	// Remove Personal Information on Save
	RemovePersonalInfoOnSaveAttr *bool

	// Compatibility Mode
	CompatModeAttr *bool

	// Strict First and Last Characters
	StrictFirstAndLastCharsAttr *bool

	// Embed True Type Fonts
	EmbedTrueTypeFontsAttr *bool

	// Save Subset Fonts
	SaveSubsetFontsAttr *bool

	// Automatically Compress Pictures
	AutoCompressPicturesAttr *bool

	// Bookmark ID Seed
	BookmarkIdSeedAttr *uint32

	// Document Conformance Class
	ConformanceAttr _d.ST_ConformanceClass

	// List of Slide Master IDs
	SldMasterIdLst *CT_SlideMasterIdList

	// List of Notes Master IDs
	NotesMasterIdLst *CT_NotesMasterIdList

	// List of Handout Master IDs
	HandoutMasterIdLst *CT_HandoutMasterIdList

	// List of Slide IDs
	SldIdLst *CT_SlideIdList

	// Presentation Slide Size
	SldSz *CT_SlideSize

	// Notes Slide Size
	NotesSz *_cb.CT_PositiveSize2D

	// Smart Tags
	SmartTags *CT_SmartTags

	// Embedded Font List
	EmbeddedFontLst *CT_EmbeddedFontList

	// List of Custom Shows
	CustShowLst *CT_CustomShowList

	// Photo Album Information
	PhotoAlbum *CT_PhotoAlbum

	// List of Customer Data Buckets
	CustDataLst *CT_CustomerDataList

	// Kinsoku Settings
	Kinsoku *CT_Kinsoku

	// Presentation Default Text Style
	DefaultTextStyle *_cb.CT_TextListStyle

	// Modification Verifier
	ModifyVerifier *CT_ModifyVerifier

	// Extension List
	ExtLst *CT_ExtensionList
}

func NewCT_SlideTiming() *CT_SlideTiming { _cgcb := &CT_SlideTiming{}; return _cgcb }

type CT_OutlineViewProperties struct {

	// Common View Properties
	CViewPr *CT_CommonViewProperties

	// List of Presentation Slides
	SldLst *CT_OutlineViewSlideList
	ExtLst *CT_ExtensionList
}

func (_fgce ST_TransitionCornerDirectionType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_acdfe := _e.Attr{}
	_acdfe.Name = name
	switch _fgce {
	case ST_TransitionCornerDirectionTypeUnset:
		_acdfe.Value = ""
	case ST_TransitionCornerDirectionTypeLu:
		_acdfe.Value = "lu"
	case ST_TransitionCornerDirectionTypeRu:
		_acdfe.Value = "ru"
	case ST_TransitionCornerDirectionTypeLd:
		_acdfe.Value = "ld"
	case ST_TransitionCornerDirectionTypeRd:
		_acdfe.Value = "rd"
	}
	return _acdfe, nil
}
func NewAG_Ole() *AG_Ole { _gca := &AG_Ole{}; return _gca }
func (_eaaaad ST_WebColorType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_eaaaad.String(), start)
}
func (_ggcf *CT_CommonViewProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ggcf.VarScaleAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "varScale"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ggcf.VarScaleAttr))})
	}
	e.EncodeToken(start)
	_bgac := _e.StartElement{Name: _e.Name{Local: "p:scale"}}
	e.EncodeElement(_ggcf.Scale, _bgac)
	_fgb := _e.StartElement{Name: _e.Name{Local: "p:origin"}}
	e.EncodeElement(_ggcf.Origin, _fgb)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_TLAnimateScaleBehavior() *CT_TLAnimateScaleBehavior {
	_fdcde := &CT_TLAnimateScaleBehavior{}
	_fdcde.CBhvr = NewCT_TLCommonBehaviorData()
	return _fdcde
}
func (_gacgc ST_TLAnimateColorDirection) ValidateWithPath(path string) error {
	switch _gacgc {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gacgc))
	}
	return nil
}

// ValidateWithPath validates the CT_TLAnimVariantBooleanVal and its children, prefixing error messages with path
func (_gceaa *CT_TLAnimVariantBooleanVal) ValidateWithPath(path string) error { return nil }
func (_bfcc *CT_PictureNonVisual) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_bfcc.CNvPr = _cb.NewCT_NonVisualDrawingProps()
	_bfcc.CNvPicPr = _cb.NewCT_NonVisualPictureProperties()
	_bfcc.NvPr = NewCT_ApplicationNonVisualDrawingProps()
_facac:
	for {
		_eefa, _acf := d.Token()
		if _acf != nil {
			return _acf
		}
		switch _afbf := _eefa.(type) {
		case _e.StartElement:
			switch _afbf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cNvPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cNvPr"}:
				if _cab := d.DecodeElement(_bfcc.CNvPr, &_afbf); _cab != nil {
					return _cab
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cNvPicPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cNvPicPr"}:
				if _acgb := d.DecodeElement(_bfcc.CNvPicPr, &_afbf); _acgb != nil {
					return _acgb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "nvPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "nvPr"}:
				if _gbbg := d.DecodeElement(_bfcc.NvPr, &_afbf); _gbbg != nil {
					return _gbbg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PictureNonVisual\u0020\u0025v", _afbf.Name)
				if _eegf := d.Skip(); _eegf != nil {
					return _eegf
				}
			}
		case _e.EndElement:
			break _facac
		case _e.CharData:
		}
	}
	return nil
}
func (_dcaf ST_TLTimeNodeRestartType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_efefc := _e.Attr{}
	_efefc.Name = name
	switch _dcaf {
	case ST_TLTimeNodeRestartTypeUnset:
		_efefc.Value = ""
	case ST_TLTimeNodeRestartTypeAlways:
		_efefc.Value = "always"
	case ST_TLTimeNodeRestartTypeWhenNotActive:
		_efefc.Value = "whenNotActive"
	case ST_TLTimeNodeRestartTypeNever:
		_efefc.Value = "never"
	}
	return _efefc, nil
}

type CT_SlideMasterIdList struct {

	// Slide Master ID
	SldMasterId []*CT_SlideMasterIdListEntry
}

func NewCT_TLTimeAnimateValue() *CT_TLTimeAnimateValue {
	_dfgdgg := &CT_TLTimeAnimateValue{}
	return _dfgdgg
}
func (_daadbc *ST_TLParaBuildType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_daadbc = 0
	case "allAtOnce":
		*_daadbc = 1
	case "p":
		*_daadbc = 2
	case "cust":
		*_daadbc = 3
	case "whole":
		*_daadbc = 4
	}
	return nil
}
func (_bede *CT_ShowInfoKiosk) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _feeef := range start.Attr {
		if _feeef.Name.Local == "restart" {
			_ddcd, _ccfc := _b.ParseUint(_feeef.Value, 10, 32)
			if _ccfc != nil {
				return _ccfc
			}
			_gceg := uint32(_ddcd)
			_bede.RestartAttr = &_gceg
			continue
		}
	}
	for {
		_fafc, _ebgec := d.Token()
		if _ebgec != nil {
			return _c.Errorf("parsing\u0020CT_ShowInfoKiosk: \u0025s", _ebgec)
		}
		if _ededd, _dfac := _fafc.(_e.EndElement); _dfac && _ededd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_decab ST_SplitterBarState) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_ebbae := _e.Attr{}
	_ebbae.Name = name
	switch _decab {
	case ST_SplitterBarStateUnset:
		_ebbae.Value = ""
	case ST_SplitterBarStateMinimized:
		_ebbae.Value = "minimized"
	case ST_SplitterBarStateRestored:
		_ebbae.Value = "restored"
	case ST_SplitterBarStateMaximized:
		_ebbae.Value = "maximized"
	}
	return _ebbae, nil
}

type CT_SlideMasterTextStyles struct {

	// Slide Master Title Text Style
	TitleStyle *_cb.CT_TextListStyle

	// Slide Master Body Text Style
	BodyStyle *_cb.CT_TextListStyle

	// Slide Master Other Text Style
	OtherStyle *_cb.CT_TextListStyle
	ExtLst     *CT_ExtensionList
}

// Validate validates the CT_NotesMaster and its children
func (_afef *CT_NotesMaster) Validate() error { return _afef.ValidateWithPath("CT_NotesMaster") }
func (_ggbgaa ST_TLBehaviorTransformType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_afbfa := _e.Attr{}
	_afbfa.Name = name
	switch _ggbgaa {
	case ST_TLBehaviorTransformTypeUnset:
		_afbfa.Value = ""
	case ST_TLBehaviorTransformTypePt:
		_afbfa.Value = "pt"
	case ST_TLBehaviorTransformTypeImg:
		_afbfa.Value = "img"
	}
	return _afbfa, nil
}

// ValidateWithPath validates the CT_TLGraphicalObjectBuild and its children, prefixing error messages with path
func (_agfec *CT_TLGraphicalObjectBuild) ValidateWithPath(path string) error {
	if _agfec.BldAsOne != nil {
		if _abge := _agfec.BldAsOne.ValidateWithPath(path + "\u002fBldAsOne"); _abge != nil {
			return _abge
		}
	}
	if _agfec.BldSub != nil {
		if _daec := _agfec.BldSub.ValidateWithPath(path + "\u002fBldSub"); _daec != nil {
			return _daec
		}
	}
	return nil
}
func (_gcafc *CT_TimeNodeList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _gcafc.Par != nil {
		_dcdcb := _e.StartElement{Name: _e.Name{Local: "p:par"}}
		for _, _dceag := range _gcafc.Par {
			e.EncodeElement(_dceag, _dcdcb)
		}
	}
	if _gcafc.Seq != nil {
		_dcacb := _e.StartElement{Name: _e.Name{Local: "p:seq"}}
		for _, _bggd := range _gcafc.Seq {
			e.EncodeElement(_bggd, _dcacb)
		}
	}
	if _gcafc.Excl != nil {
		_agffb := _e.StartElement{Name: _e.Name{Local: "p:excl"}}
		for _, _efee := range _gcafc.Excl {
			e.EncodeElement(_efee, _agffb)
		}
	}
	if _gcafc.Anim != nil {
		_bdcb := _e.StartElement{Name: _e.Name{Local: "p:anim"}}
		for _, _acabae := range _gcafc.Anim {
			e.EncodeElement(_acabae, _bdcb)
		}
	}
	if _gcafc.AnimClr != nil {
		_cgfef := _e.StartElement{Name: _e.Name{Local: "p:animClr"}}
		for _, _aebgg := range _gcafc.AnimClr {
			e.EncodeElement(_aebgg, _cgfef)
		}
	}
	if _gcafc.AnimEffect != nil {
		_bdfd := _e.StartElement{Name: _e.Name{Local: "p:animEffect"}}
		for _, _accca := range _gcafc.AnimEffect {
			e.EncodeElement(_accca, _bdfd)
		}
	}
	if _gcafc.AnimMotion != nil {
		_bafbe := _e.StartElement{Name: _e.Name{Local: "p:animMotion"}}
		for _, _bgdga := range _gcafc.AnimMotion {
			e.EncodeElement(_bgdga, _bafbe)
		}
	}
	if _gcafc.AnimRot != nil {
		_edge := _e.StartElement{Name: _e.Name{Local: "p:animRot"}}
		for _, _edfb := range _gcafc.AnimRot {
			e.EncodeElement(_edfb, _edge)
		}
	}
	if _gcafc.AnimScale != nil {
		_gcdce := _e.StartElement{Name: _e.Name{Local: "p:animScale"}}
		for _, _agced := range _gcafc.AnimScale {
			e.EncodeElement(_agced, _gcdce)
		}
	}
	if _gcafc.Cmd != nil {
		_dggb := _e.StartElement{Name: _e.Name{Local: "p:cmd"}}
		for _, _ebaab := range _gcafc.Cmd {
			e.EncodeElement(_ebaab, _dggb)
		}
	}
	if _gcafc.Set != nil {
		_accbb := _e.StartElement{Name: _e.Name{Local: "p:set"}}
		for _, _gcaab := range _gcafc.Set {
			e.EncodeElement(_gcaab, _accbb)
		}
	}
	if _gcafc.Audio != nil {
		_cded := _e.StartElement{Name: _e.Name{Local: "p:audio"}}
		for _, _dbeee := range _gcafc.Audio {
			e.EncodeElement(_dbeee, _cded)
		}
	}
	if _gcafc.Video != nil {
		_cecdg := _e.StartElement{Name: _e.Name{Local: "p:video"}}
		for _, _abefe := range _gcafc.Video {
			e.EncodeElement(_abefe, _cecdg)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_TLTimeAnimateValueList() *CT_TLTimeAnimateValueList {
	_afcfe := &CT_TLTimeAnimateValueList{}
	return _afcfe
}
func (_fe *AG_ChildSlide) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _a := range start.Attr {
		if _a.Name.Local == "showMasterSp" {
			_bc, _dc := _b.ParseBool(_a.Value)
			if _dc != nil {
				return _dc
			}
			_fe.ShowMasterSpAttr = &_bc
			continue
		}
		if _a.Name.Local == "showMasterPhAnim" {
			_gg, _ce := _b.ParseBool(_a.Value)
			if _ce != nil {
				return _ce
			}
			_fe.ShowMasterPhAnimAttr = &_gg
			continue
		}
	}
	for {
		_ab, _af := d.Token()
		if _af != nil {
			return _c.Errorf("parsing\u0020AG_ChildSlide:\u0020\u0025s", _af)
		}
		if _gc, _bcf := _ab.(_e.EndElement); _bcf && _gc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_beedd ST_TLParaBuildType) ValidateWithPath(path string) error {
	switch _beedd {
	case 0, 1, 2, 3, 4:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_beedd))
	}
	return nil
}
func (_edceb ST_TLBehaviorOverrideType) ValidateWithPath(path string) error {
	switch _edceb {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_edceb))
	}
	return nil
}

// ValidateWithPath validates the CT_TLSubShapeId and its children, prefixing error messages with path
func (_cebgf *CT_TLSubShapeId) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_CustomShowList and its children, prefixing error messages with path
func (_gbb *CT_CustomShowList) ValidateWithPath(path string) error {
	for _cece, _gfcf := range _gbb.CustShow {
		if _gece := _gfcf.ValidateWithPath(_c.Sprintf("\u0025s\u002fCustShow\u005b\u0025d\u005d", path, _cece)); _gece != nil {
			return _gece
		}
	}
	return nil
}

// Validate validates the CT_TLCommonMediaNodeData and its children
func (_efccf *CT_TLCommonMediaNodeData) Validate() error {
	return _efccf.ValidateWithPath("CT_TLCommonMediaNodeData")
}

// Validate validates the CT_TLAnimateColorBehavior and its children
func (_ebbef *CT_TLAnimateColorBehavior) Validate() error {
	return _ebbef.ValidateWithPath("CT_TLAnimateColorBehavior")
}

// Validate validates the CT_TLIterateIntervalTime and its children
func (_gggdd *CT_TLIterateIntervalTime) Validate() error {
	return _gggdd.ValidateWithPath("CT_TLIterateIntervalTime")
}
func (_dadbf *CT_ShowInfoBrowse) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _dadbf.ShowScrollbarAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showScrollbar"}, Value: _c.Sprintf("\u0025d", _fdeab(*_dadbf.ShowScrollbarAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type ST_TLParaBuildType byte

// Validate validates the CT_NotesViewProperties and its children
func (_dgbd *CT_NotesViewProperties) Validate() error {
	return _dgbd.ValidateWithPath("CT_NotesViewProperties")
}

// Validate validates the CT_ExtensionListModify and its children
func (_fdfb *CT_ExtensionListModify) Validate() error {
	return _fdfb.ValidateWithPath("CT_ExtensionListModify")
}
func (_dbcf *CT_NormalViewPortion) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "sz"}, Value: _c.Sprintf("\u0025v", _dbcf.SzAttr)})
	if _dbcf.AutoAdjustAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "autoAdjust"}, Value: _c.Sprintf("\u0025d", _fdeab(*_dbcf.AutoAdjustAttr))})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_agegba ST_TLTimeNodeRestartType) ValidateWithPath(path string) error {
	switch _agegba {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_agegba))
	}
	return nil
}

// Validate validates the CT_ShowInfoBrowse and its children
func (_cebga *CT_ShowInfoBrowse) Validate() error {
	return _cebga.ValidateWithPath("CT_ShowInfoBrowse")
}
func (_fafea ST_SlideLayoutType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_fafea.String(), start)
}
func NewCT_OrientationTransition() *CT_OrientationTransition {
	_facf := &CT_OrientationTransition{}
	return _facf
}
func (_aegff ST_TLOleChartBuildType) String() string {
	switch _aegff {
	case 0:
		return ""
	case 1:
		return "allAtOnce"
	case 2:
		return "series"
	case 3:
		return "category"
	case 4:
		return "seriesEl"
	case 5:
		return "categoryEl"
	}
	return ""
}
func (_ecgdd ST_TLTimeNodePresetClassType) ValidateWithPath(path string) error {
	switch _ecgdd {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ecgdd))
	}
	return nil
}

const (
	ST_TLPreviousActionTypeUnset     ST_TLPreviousActionType = 0
	ST_TLPreviousActionTypeNone      ST_TLPreviousActionType = 1
	ST_TLPreviousActionTypeSkipTimed ST_TLPreviousActionType = 2
)

// Validate validates the CT_NotesTextViewProperties and its children
func (_cggb *CT_NotesTextViewProperties) Validate() error {
	return _cggb.ValidateWithPath("CT_NotesTextViewProperties")
}

type CT_Slide struct {

	// Show Slide in Slide Show
	ShowAttr *bool

	// Common slide data for slides
	CSld *CT_CommonSlideData

	// Color Scheme Map Override
	ClrMapOvr *_cb.CT_ColorMappingOverride

	// Slide Transition
	Transition *CT_SlideTransition

	// Slide Timing Information for a Slide
	Timing               *CT_SlideTiming
	ExtLst               *CT_ExtensionListModify
	ShowMasterSpAttr     *bool
	ShowMasterPhAnimAttr *bool
}

func (_cbdage ST_TransitionEightDirectionType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _cbdage.ST_TransitionSideDirectionType != ST_TransitionSideDirectionTypeUnset {
		e.EncodeToken(_e.CharData(_cbdage.ST_TransitionSideDirectionType.String()))
	}
	if _cbdage.ST_TransitionCornerDirectionType != ST_TransitionCornerDirectionTypeUnset {
		e.EncodeToken(_e.CharData(_cbdage.ST_TransitionCornerDirectionType.String()))
	}
	return e.EncodeToken(_e.EndElement{Name: start.Name})
}

// Validate validates the CT_TLAnimVariantStringVal and its children
func (_aeffe *CT_TLAnimVariantStringVal) Validate() error {
	return _aeffe.ValidateWithPath("CT_TLAnimVariantStringVal")
}
func NewCT_CustomShowList() *CT_CustomShowList { _ggbeg := &CT_CustomShowList{}; return _ggbeg }

// ValidateWithPath validates the EG_Background and its children, prefixing error messages with path
func (_cdcdba *EG_Background) ValidateWithPath(path string) error {
	if _cdcdba.BgPr != nil {
		if _fdca := _cdcdba.BgPr.ValidateWithPath(path + "\u002fBgPr"); _fdca != nil {
			return _fdca
		}
	}
	if _cdcdba.BgRef != nil {
		if _gfeba := _cdcdba.BgRef.ValidateWithPath(path + "\u002fBgRef"); _gfeba != nil {
			return _gfeba
		}
	}
	return nil
}

type CT_IndexRange struct {

	// Start
	StAttr uint32

	// End
	EndAttr uint32
}

func NewCT_NotesTextViewProperties() *CT_NotesTextViewProperties {
	_eeabf := &CT_NotesTextViewProperties{}
	_eeabf.CViewPr = NewCT_CommonViewProperties()
	return _eeabf
}

type CT_TLOleBuildChart struct {

	// Build
	BldAttr ST_TLOleChartBuildType

	// Animate Background
	AnimBgAttr   *bool
	SpidAttr     *uint32
	GrpIdAttr    *uint32
	UiExpandAttr *bool
}

func (_bagc *CT_SideDirectionTransition) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _bagc.DirAttr != ST_TransitionSideDirectionTypeUnset {
		_adbe, _eedg := _bagc.DirAttr.MarshalXMLAttr(_e.Name{Local: "dir"})
		if _eedg != nil {
			return _eedg
		}
		start.Attr = append(start.Attr, _adbe)
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type ST_TLPreviousActionType byte
type EG_TopLevelSlide struct {

	// Color Scheme Map
	ClrMap *_cb.CT_ColorMapping
}

func (_gcgca *CT_TLTemplate) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gcgca.LvlAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "lvl"}, Value: _c.Sprintf("\u0025v", *_gcgca.LvlAttr)})
	}
	e.EncodeToken(start)
	_fccef := _e.StartElement{Name: _e.Name{Local: "p:tnLst"}}
	e.EncodeElement(_gcgca.TnLst, _fccef)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_ceffg *CT_TLShapeTargetElement) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spid"}, Value: _c.Sprintf("\u0025v", _ceffg.SpidAttr)})
	e.EncodeToken(start)
	if _ceffg.Bg != nil {
		_adag := _e.StartElement{Name: _e.Name{Local: "p:bg"}}
		e.EncodeElement(_ceffg.Bg, _adag)
	}
	if _ceffg.SubSp != nil {
		_acaba := _e.StartElement{Name: _e.Name{Local: "p:subSp"}}
		e.EncodeElement(_ceffg.SubSp, _acaba)
	}
	if _ceffg.OleChartEl != nil {
		_bdde := _e.StartElement{Name: _e.Name{Local: "p:oleChartEl"}}
		e.EncodeElement(_ceffg.OleChartEl, _bdde)
	}
	if _ceffg.TxEl != nil {
		_agcdb := _e.StartElement{Name: _e.Name{Local: "p:txEl"}}
		e.EncodeElement(_ceffg.TxEl, _agcdb)
	}
	if _ceffg.GraphicEl != nil {
		_cgefc := _e.StartElement{Name: _e.Name{Local: "p:graphicEl"}}
		e.EncodeElement(_ceffg.GraphicEl, _cgefc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_bfce *EG_Background) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_bgcce:
	for {
		_agffa, _adcbd := d.Token()
		if _adcbd != nil {
			return _adcbd
		}
		switch _acadf := _agffa.(type) {
		case _e.StartElement:
			switch _acadf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bgPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bgPr"}:
				_bfce.BgPr = NewCT_BackgroundProperties()
				if _eeaee := d.DecodeElement(_bfce.BgPr, &_acadf); _eeaee != nil {
					return _eeaee
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bgRef"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bgRef"}:
				_bfce.BgRef = _cb.NewCT_StyleMatrixReference()
				if _fabfe := d.DecodeElement(_bfce.BgRef, &_acadf); _fabfe != nil {
					return _fabfe
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020EG_Background \u0025v", _acadf.Name)
				if _ffgdf := d.Skip(); _ffgdf != nil {
					return _ffgdf
				}
			}
		case _e.EndElement:
			break _bgcce
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TLIterateIntervalTime and its children, prefixing error messages with path
func (_fbdae *CT_TLIterateIntervalTime) ValidateWithPath(path string) error {
	if _dffab := _fbdae.ValAttr.ValidateWithPath(path + "\u002fValAttr"); _dffab != nil {
		return _dffab
	}
	return nil
}

// Validate validates the CT_CommentAuthor and its children
func (_afcc *CT_CommentAuthor) Validate() error { return _afcc.ValidateWithPath("CT_CommentAuthor") }

type CT_ShowInfoBrowse struct {

	// Show Scroll Bar in Window
	ShowScrollbarAttr *bool
}

func (_agfag ST_TLBehaviorAccumulateType) Validate() error { return _agfag.ValidateWithPath("") }

type ST_PlaceholderType byte
type CT_TLTimeConditionList struct {

	// Condition
	Cond []*CT_TLTimeCondition
}

const (
	ST_SlideLayoutTypeUnset                   ST_SlideLayoutType = 0
	ST_SlideLayoutTypeTitle                   ST_SlideLayoutType = 1
	ST_SlideLayoutTypeTx                      ST_SlideLayoutType = 2
	ST_SlideLayoutTypeTwoColTx                ST_SlideLayoutType = 3
	ST_SlideLayoutTypeTbl                     ST_SlideLayoutType = 4
	ST_SlideLayoutTypeTxAndChart              ST_SlideLayoutType = 5
	ST_SlideLayoutTypeChartAndTx              ST_SlideLayoutType = 6
	ST_SlideLayoutTypeDgm                     ST_SlideLayoutType = 7
	ST_SlideLayoutTypeChart                   ST_SlideLayoutType = 8
	ST_SlideLayoutTypeTxAndClipArt            ST_SlideLayoutType = 9
	ST_SlideLayoutTypeClipArtAndTx            ST_SlideLayoutType = 10
	ST_SlideLayoutTypeTitleOnly               ST_SlideLayoutType = 11
	ST_SlideLayoutTypeBlank                   ST_SlideLayoutType = 12
	ST_SlideLayoutTypeTxAndObj                ST_SlideLayoutType = 13
	ST_SlideLayoutTypeObjAndTx                ST_SlideLayoutType = 14
	ST_SlideLayoutTypeObjOnly                 ST_SlideLayoutType = 15
	ST_SlideLayoutTypeObj                     ST_SlideLayoutType = 16
	ST_SlideLayoutTypeTxAndMedia              ST_SlideLayoutType = 17
	ST_SlideLayoutTypeMediaAndTx              ST_SlideLayoutType = 18
	ST_SlideLayoutTypeObjOverTx               ST_SlideLayoutType = 19
	ST_SlideLayoutTypeTxOverObj               ST_SlideLayoutType = 20
	ST_SlideLayoutTypeTxAndTwoObj             ST_SlideLayoutType = 21
	ST_SlideLayoutTypeTwoObjAndTx             ST_SlideLayoutType = 22
	ST_SlideLayoutTypeTwoObjOverTx            ST_SlideLayoutType = 23
	ST_SlideLayoutTypeFourObj                 ST_SlideLayoutType = 24
	ST_SlideLayoutTypeVertTx                  ST_SlideLayoutType = 25
	ST_SlideLayoutTypeClipArtAndVertTx        ST_SlideLayoutType = 26
	ST_SlideLayoutTypeVertTitleAndTx          ST_SlideLayoutType = 27
	ST_SlideLayoutTypeVertTitleAndTxOverChart ST_SlideLayoutType = 28
	ST_SlideLayoutTypeTwoObj                  ST_SlideLayoutType = 29
	ST_SlideLayoutTypeObjAndTwoObj            ST_SlideLayoutType = 30
	ST_SlideLayoutTypeTwoObjAndObj            ST_SlideLayoutType = 31
	ST_SlideLayoutTypeCust                    ST_SlideLayoutType = 32
	ST_SlideLayoutTypeSecHead                 ST_SlideLayoutType = 33
	ST_SlideLayoutTypeTwoTxTwoObj             ST_SlideLayoutType = 34
	ST_SlideLayoutTypeObjTx                   ST_SlideLayoutType = 35
	ST_SlideLayoutTypePicTx                   ST_SlideLayoutType = 36
)

// Validate validates the CT_HandoutMasterIdList and its children
func (_ecga *CT_HandoutMasterIdList) Validate() error {
	return _ecga.ValidateWithPath("CT_HandoutMasterIdList")
}

const (
	ST_TLTimeNodeRestartTypeUnset         ST_TLTimeNodeRestartType = 0
	ST_TLTimeNodeRestartTypeAlways        ST_TLTimeNodeRestartType = 1
	ST_TLTimeNodeRestartTypeWhenNotActive ST_TLTimeNodeRestartType = 2
	ST_TLTimeNodeRestartTypeNever         ST_TLTimeNodeRestartType = 3
)

// ValidateWithPath validates the CT_SlideTiming and its children, prefixing error messages with path
func (_dgda *CT_SlideTiming) ValidateWithPath(path string) error {
	if _dgda.TnLst != nil {
		if _beade := _dgda.TnLst.ValidateWithPath(path + "\u002fTnLst"); _beade != nil {
			return _beade
		}
	}
	if _dgda.BldLst != nil {
		if _ddfdc := _dgda.BldLst.ValidateWithPath(path + "\u002fBldLst"); _ddfdc != nil {
			return _ddfdc
		}
	}
	if _dgda.ExtLst != nil {
		if _faece := _dgda.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _faece != nil {
			return _faece
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SlideSize and its children, prefixing error messages with path
func (_geced *CT_SlideSize) ValidateWithPath(path string) error {
	if _geced.CxAttr < 914400 {
		return _c.Errorf("\u0025s\u002fm\u002eCxAttr\u0020must\u0020be\u0020>\u003d\u0020914400\u0020\u0028have\u0020\u0025v\u0029", path, _geced.CxAttr)
	}
	if _geced.CxAttr > 51206400 {
		return _c.Errorf("\u0025s\u002fm\u002eCxAttr\u0020must\u0020be \u003c\u003d\u002051206400\u0020\u0028have\u0020\u0025v\u0029", path, _geced.CxAttr)
	}
	if _geced.CxAttr < 0 {
		return _c.Errorf("\u0025s\u002fm.CxAttr\u0020must be\u0020>\u003d\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _geced.CxAttr)
	}
	if _geced.CyAttr < 914400 {
		return _c.Errorf("\u0025s\u002fm\u002eCyAttr\u0020must\u0020be\u0020>\u003d\u0020914400\u0020\u0028have\u0020\u0025v\u0029", path, _geced.CyAttr)
	}
	if _geced.CyAttr > 51206400 {
		return _c.Errorf("\u0025s\u002fm\u002eCyAttr\u0020must\u0020be \u003c\u003d\u002051206400\u0020\u0028have\u0020\u0025v\u0029", path, _geced.CyAttr)
	}
	if _geced.CyAttr < 0 {
		return _c.Errorf("\u0025s\u002fm.CyAttr\u0020must be\u0020>\u003d\u00200\u0020\u0028have\u0020\u0025v\u0029", path, _geced.CyAttr)
	}
	if _eaefc := _geced.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _eaefc != nil {
		return _eaefc
	}
	return nil
}

type SldMaster struct{ CT_SlideMaster }
type CT_ShowProperties struct {

	// Loop Slide Show
	LoopAttr *bool

	// Show Narration in Slide Show
	ShowNarrationAttr *bool

	// Show Animation in Slide Show
	ShowAnimationAttr *bool

	// Use Timings in Slide Show
	UseTimingsAttr *bool

	// Presenter Slide Show Mode
	Present *CT_Empty

	// Browse Slide Show Mode
	Browse *CT_ShowInfoBrowse

	// Kiosk Slide Show Mode
	Kiosk *CT_ShowInfoKiosk

	// All Slides
	SldAll *CT_Empty

	// Slide Range
	SldRg *CT_IndexRange

	// Custom Show
	CustShow *CT_CustomShowId

	// Pen Color for Slide Show
	PenClr *_cb.CT_Color
	ExtLst *CT_ExtensionList
}

func (_bgeea ST_TLCommandType) ValidateWithPath(path string) error {
	switch _bgeea {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bgeea))
	}
	return nil
}
func (_ccga *CT_SlideSorterViewProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ccga.ShowFormattingAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showFormatting"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ccga.ShowFormattingAttr))})
	}
	e.EncodeToken(start)
	_dadgf := _e.StartElement{Name: _e.Name{Local: "p:cViewPr"}}
	e.EncodeElement(_ccga.CViewPr, _dadgf)
	if _ccga.ExtLst != nil {
		_ebfc := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ccga.ExtLst, _ebfc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_abaaa ST_TLAnimateMotionBehaviorOrigin) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_abaaa.String(), start)
}
func (_eecgd ST_TLTimeNodeRestartType) Validate() error { return _eecgd.ValidateWithPath("") }
func (_ccge *CT_TLTimeNodeParallel) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_bcef := _e.StartElement{Name: _e.Name{Local: "p:cTn"}}
	e.EncodeElement(_ccge.CTn, _bcef)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_deef *ST_TransitionSpeed) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_deef = 0
	case "slow":
		*_deef = 1
	case "med":
		*_deef = 2
	case "fast":
		*_deef = 3
	}
	return nil
}

type CT_TLBuildParagraph struct {

	// Build Types
	BuildAttr ST_TLParaBuildType

	// Build Level
	BldLvlAttr *uint32

	// Animate Background
	AnimBgAttr *bool

	// Auto Update Animation Background
	AutoUpdateAnimBgAttr *bool

	// Reverse
	RevAttr *bool

	// Auto Advance Time
	AdvAutoAttr *ST_TLTime

	// Template effects
	TmplLst      *CT_TLTemplateList
	SpidAttr     *uint32
	GrpIdAttr    *uint32
	UiExpandAttr *bool
}

func (_gaf *CT_Background) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gaf.BwModeAttr != _cb.ST_BlackWhiteModeUnset {
		_gda, _dac := _gaf.BwModeAttr.MarshalXMLAttr(_e.Name{Local: "a:bwMode"})
		if _dac != nil {
			return _dac
		}
		start.Attr = append(start.Attr, _gda)
	}
	e.EncodeToken(start)
	if _gaf.BgPr != nil {
		_bcg := _e.StartElement{Name: _e.Name{Local: "p:bgPr"}}
		e.EncodeElement(_gaf.BgPr, _bcg)
	}
	if _gaf.BgRef != nil {
		_cbb := _e.StartElement{Name: _e.Name{Local: "p:bgRef"}}
		e.EncodeElement(_gaf.BgRef, _cbb)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type ST_PrintWhat byte

func (_bfaeg *ST_TLAnimateMotionPathEditMode) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dacaf, _agedec := d.Token()
	if _agedec != nil {
		return _agedec
	}
	if _ecfce, _cfedcg := _dacaf.(_e.EndElement); _cfedcg && _ecfce.Name == start.Name {
		*_bfaeg = 1
		return nil
	}
	if _cffe, _bagfd := _dacaf.(_e.CharData); !_bagfd {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dacaf)
	} else {
		switch string(_cffe) {
		case "":
			*_bfaeg = 0
		case "relative":
			*_bfaeg = 1
		case "fixed":
			*_bfaeg = 2
		}
	}
	_dacaf, _agedec = d.Token()
	if _agedec != nil {
		return _agedec
	}
	if _bgcge, _cgdbc := _dacaf.(_e.EndElement); _cgdbc && _bgcge.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dacaf)
}
func (_adcddg ST_TLTimeNodeRestartType) String() string {
	switch _adcddg {
	case 0:
		return ""
	case 1:
		return "always"
	case 2:
		return "whenNotActive"
	case 3:
		return "never"
	}
	return ""
}

const (
	ST_TLTimeNodeFillTypeUnset      ST_TLTimeNodeFillType = 0
	ST_TLTimeNodeFillTypeRemove     ST_TLTimeNodeFillType = 1
	ST_TLTimeNodeFillTypeFreeze     ST_TLTimeNodeFillType = 2
	ST_TLTimeNodeFillTypeHold       ST_TLTimeNodeFillType = 3
	ST_TLTimeNodeFillTypeTransition ST_TLTimeNodeFillType = 4
)

func (_aagcgc ST_WebScreenSize) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_eacddd := _e.Attr{}
	_eacddd.Name = name
	switch _aagcgc {
	case ST_WebScreenSizeUnset:
		_eacddd.Value = ""
	case ST_WebScreenSize544x376:
		_eacddd.Value = "544x376"
	case ST_WebScreenSize640x480:
		_eacddd.Value = "640x480"
	case ST_WebScreenSize720x512:
		_eacddd.Value = "720x512"
	case ST_WebScreenSize800x600:
		_eacddd.Value = "800x600"
	case ST_WebScreenSize1024x768:
		_eacddd.Value = "1024x768"
	case ST_WebScreenSize1152x882:
		_eacddd.Value = "1152x882"
	case ST_WebScreenSize1152x900:
		_eacddd.Value = "1152x900"
	case ST_WebScreenSize1280x1024:
		_eacddd.Value = "1280x1024"
	case ST_WebScreenSize1600x1200:
		_eacddd.Value = "1600x1200"
	case ST_WebScreenSize1800x1400:
		_eacddd.Value = "1800x1400"
	case ST_WebScreenSize1920x1200:
		_eacddd.Value = "1920x1200"
	}
	return _eacddd, nil
}
func (_cfdc *CT_ShowInfoKiosk) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _cfdc.RestartAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "restart"}, Value: _c.Sprintf("\u0025v", *_cfdc.RestartAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_egcce ST_IterateType) Validate() error { return _egcce.ValidateWithPath("") }

type CT_SlideViewProperties struct {
	CSldViewPr *CT_CommonSlideViewProperties
	ExtLst     *CT_ExtensionList
}

func NewTagLst() *TagLst { _deea := &TagLst{}; _deea.CT_TagList = *NewCT_TagList(); return _deea }
func (_cecb *ST_TLTimeNodePresetClassType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dcaa, _fegd := d.Token()
	if _fegd != nil {
		return _fegd
	}
	if _bcfeg, _ebegg := _dcaa.(_e.EndElement); _ebegg && _bcfeg.Name == start.Name {
		*_cecb = 1
		return nil
	}
	if _fccgd, _eeegf := _dcaa.(_e.CharData); !_eeegf {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dcaa)
	} else {
		switch string(_fccgd) {
		case "":
			*_cecb = 0
		case "entr":
			*_cecb = 1
		case "exit":
			*_cecb = 2
		case "emph":
			*_cecb = 3
		case "path":
			*_cecb = 4
		case "verb":
			*_cecb = 5
		case "mediacall":
			*_cecb = 6
		}
	}
	_dcaa, _fegd = d.Token()
	if _fegd != nil {
		return _fegd
	}
	if _dceeb, _fdaec := _dcaa.(_e.EndElement); _fdaec && _dceeb.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dcaa)
}

// ValidateWithPath validates the CT_TLAnimateRotationBehavior and its children, prefixing error messages with path
func (_aggee *CT_TLAnimateRotationBehavior) ValidateWithPath(path string) error {
	if _eccae := _aggee.CBhvr.ValidateWithPath(path + "\u002fCBhvr"); _eccae != nil {
		return _eccae
	}
	return nil
}
func (_cdddc *CT_TLSubShapeId) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _abedg := range start.Attr {
		if _abedg.Name.Local == "spid" {
			_gbec, _eeefdd := _abedg.Value, error(nil)
			if _eeefdd != nil {
				return _eeefdd
			}
			_cdddc.SpidAttr = _gbec
			continue
		}
	}
	for {
		_daacc, _cdfga := d.Token()
		if _cdfga != nil {
			return _c.Errorf("parsing CT_TLSubShapeId:\u0020\u0025s", _cdfga)
		}
		if _eeaca, _bgggf := _daacc.(_e.EndElement); _bgggf && _eeaca.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_SlideLayoutIdListEntry struct {

	// ID Tag
	IdAttr  *uint32
	RIdAttr string
	ExtLst  *CT_ExtensionList
}

func (_dabgg *CT_SlideTiming) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _dabgg.TnLst != nil {
		_fdgce := _e.StartElement{Name: _e.Name{Local: "p:tnLst"}}
		e.EncodeElement(_dabgg.TnLst, _fdgce)
	}
	if _dabgg.BldLst != nil {
		_agbeb := _e.StartElement{Name: _e.Name{Local: "p:bldLst"}}
		e.EncodeElement(_dabgg.BldLst, _agbeb)
	}
	if _dabgg.ExtLst != nil {
		_bcgba := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_dabgg.ExtLst, _bcgba)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_dfae *CT_TLTriggerRuntimeNode) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dfae.ValAttr = ST_TLTriggerRuntimeNode(1)
	for _, _affdaa := range start.Attr {
		if _affdaa.Name.Local == "val" {
			_dfae.ValAttr.UnmarshalXMLAttr(_affdaa)
			continue
		}
	}
	for {
		_dagde, _fdfbf := d.Token()
		if _fdfbf != nil {
			return _c.Errorf("parsing CT_TLTriggerRuntimeNode:\u0020%s", _fdfbf)
		}
		if _gfgfg, _dgefg := _dagde.(_e.EndElement); _dgefg && _gfgfg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_deag *CT_CustomShowId) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "id"}, Value: _c.Sprintf("\u0025v", _deag.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_OutlineViewProperties and its children
func (_ddacb *CT_OutlineViewProperties) Validate() error {
	return _ddacb.ValidateWithPath("CT_OutlineViewProperties")
}
func ParseStdlibTime(s string) (_fb.Time, error) { return _cb.ParseStdlibTime(s) }
func NewCT_HtmlPublishProperties() *CT_HtmlPublishProperties {
	_gefd := &CT_HtmlPublishProperties{}
	return _gefd
}
func (_dbce *CT_Picture) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dbce.NvPicPr = NewCT_PictureNonVisual()
	_dbce.BlipFill = _cb.NewCT_BlipFillProperties()
	_dbce.SpPr = _cb.NewCT_ShapeProperties()
_ceceg:
	for {
		_baaf, _cbaa := d.Token()
		if _cbaa != nil {
			return _cbaa
		}
		switch _cbcb := _baaf.(type) {
		case _e.StartElement:
			switch _cbcb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "nvPicPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "nvPicPr"}:
				if _fccg := d.DecodeElement(_dbce.NvPicPr, &_cbcb); _fccg != nil {
					return _fccg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "blipFill"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "blipFill"}:
				if _aadf := d.DecodeElement(_dbce.BlipFill, &_cbcb); _aadf != nil {
					return _aadf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "spPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "spPr"}:
				if _fdaba := d.DecodeElement(_dbce.SpPr, &_cbcb); _fdaba != nil {
					return _fdaba
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "style"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "style"}:
				_dbce.Style = _cb.NewCT_ShapeStyle()
				if _cbfe := d.DecodeElement(_dbce.Style, &_cbcb); _cbfe != nil {
					return _cbfe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_dbce.ExtLst = NewCT_ExtensionListModify()
				if _cgcd := d.DecodeElement(_dbce.ExtLst, &_cbcb); _cgcd != nil {
					return _cgcd
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_Picture\u0020\u0025v", _cbcb.Name)
				if _afbc := d.Skip(); _afbc != nil {
					return _afbc
				}
			}
		case _e.EndElement:
			break _ceceg
		case _e.CharData:
		}
	}
	return nil
}

type CT_Background struct {

	// Black and White Mode
	BwModeAttr _cb.ST_BlackWhiteMode

	// Background Properties
	BgPr *CT_BackgroundProperties

	// Background Style Reference
	BgRef *_cb.CT_StyleMatrixReference
}

func (_efdc *CT_Presentation) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_efdc.NotesSz = _cb.NewCT_PositiveSize2D()
	for _, _fgac := range start.Attr {
		if _fgac.Name.Local == "firstSlideNum" {
			_beag, _accaf := _b.ParseInt(_fgac.Value, 10, 32)
			if _accaf != nil {
				return _accaf
			}
			_fbbf := int32(_beag)
			_efdc.FirstSlideNumAttr = &_fbbf
			continue
		}
		if _fgac.Name.Local == "rtl" {
			_efdfd, _bdedf := _b.ParseBool(_fgac.Value)
			if _bdedf != nil {
				return _bdedf
			}
			_efdc.RtlAttr = &_efdfd
			continue
		}
		if _fgac.Name.Local == "compatMode" {
			_caafd, _fdfg := _b.ParseBool(_fgac.Value)
			if _fdfg != nil {
				return _fdfg
			}
			_efdc.CompatModeAttr = &_caafd
			continue
		}
		if _fgac.Name.Local == "embedTrueTypeFonts" {
			_bbcgd, _adaf := _b.ParseBool(_fgac.Value)
			if _adaf != nil {
				return _adaf
			}
			_efdc.EmbedTrueTypeFontsAttr = &_bbcgd
			continue
		}
		if _fgac.Name.Local == "autoCompressPictures" {
			_cgdf, _ggcff := _b.ParseBool(_fgac.Value)
			if _ggcff != nil {
				return _ggcff
			}
			_efdc.AutoCompressPicturesAttr = &_cgdf
			continue
		}
		if _fgac.Name.Local == "showSpecialPlsOnTitleSld" {
			_ecgd, _ebbe := _b.ParseBool(_fgac.Value)
			if _ebbe != nil {
				return _ebbe
			}
			_efdc.ShowSpecialPlsOnTitleSldAttr = &_ecgd
			continue
		}
		if _fgac.Name.Local == "serverZoom" {
			_bgcga, _ceee := ParseUnionST_Percentage(_fgac.Value)
			if _ceee != nil {
				return _ceee
			}
			_efdc.ServerZoomAttr = &_bgcga
			continue
		}
		if _fgac.Name.Local == "conformance" {
			_efdc.ConformanceAttr.UnmarshalXMLAttr(_fgac)
			continue
		}
		if _fgac.Name.Local == "removePersonalInfoOnSave" {
			_fbafc, _dbfd := _b.ParseBool(_fgac.Value)
			if _dbfd != nil {
				return _dbfd
			}
			_efdc.RemovePersonalInfoOnSaveAttr = &_fbafc
			continue
		}
		if _fgac.Name.Local == "saveSubsetFonts" {
			_abaa, _bacd := _b.ParseBool(_fgac.Value)
			if _bacd != nil {
				return _bacd
			}
			_efdc.SaveSubsetFontsAttr = &_abaa
			continue
		}
		if _fgac.Name.Local == "bookmarkIdSeed" {
			_dagc, _cfebb := _b.ParseUint(_fgac.Value, 10, 32)
			if _cfebb != nil {
				return _cfebb
			}
			_bgbe := uint32(_dagc)
			_efdc.BookmarkIdSeedAttr = &_bgbe
			continue
		}
		if _fgac.Name.Local == "strictFirstAndLastChars" {
			_bba, _dedf := _b.ParseBool(_fgac.Value)
			if _dedf != nil {
				return _dedf
			}
			_efdc.StrictFirstAndLastCharsAttr = &_bba
			continue
		}
	}
_egfa:
	for {
		_ceaad, _fgea := d.Token()
		if _fgea != nil {
			return _fgea
		}
		switch _cbbad := _ceaad.(type) {
		case _e.StartElement:
			switch _cbbad.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldMasterIdLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldMasterIdLst"}:
				_efdc.SldMasterIdLst = NewCT_SlideMasterIdList()
				if _fbaee := d.DecodeElement(_efdc.SldMasterIdLst, &_cbbad); _fbaee != nil {
					return _fbaee
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "notesMasterIdLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "notesMasterIdLst"}:
				_efdc.NotesMasterIdLst = NewCT_NotesMasterIdList()
				if _bcgfb := d.DecodeElement(_efdc.NotesMasterIdLst, &_cbbad); _bcgfb != nil {
					return _bcgfb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "handoutMasterIdLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "handoutMasterIdLst"}:
				_efdc.HandoutMasterIdLst = NewCT_HandoutMasterIdList()
				if _cbcf := d.DecodeElement(_efdc.HandoutMasterIdLst, &_cbbad); _cbcf != nil {
					return _cbcf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldIdLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldIdLst"}:
				_efdc.SldIdLst = NewCT_SlideIdList()
				if _gdee := d.DecodeElement(_efdc.SldIdLst, &_cbbad); _gdee != nil {
					return _gdee
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldSz"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldSz"}:
				_efdc.SldSz = NewCT_SlideSize()
				if _cgcf := d.DecodeElement(_efdc.SldSz, &_cbbad); _cgcf != nil {
					return _cgcf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "notesSz"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "notesSz"}:
				if _gdaa := d.DecodeElement(_efdc.NotesSz, &_cbbad); _gdaa != nil {
					return _gdaa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "smartTags"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "smartTags"}:
				_efdc.SmartTags = NewCT_SmartTags()
				if _ecgae := d.DecodeElement(_efdc.SmartTags, &_cbbad); _ecgae != nil {
					return _ecgae
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "embeddedFontLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "embeddedFontLst"}:
				_efdc.EmbeddedFontLst = NewCT_EmbeddedFontList()
				if _fgee := d.DecodeElement(_efdc.EmbeddedFontLst, &_cbbad); _fgee != nil {
					return _fgee
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "custShowLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "custShowLst"}:
				_efdc.CustShowLst = NewCT_CustomShowList()
				if _adcd := d.DecodeElement(_efdc.CustShowLst, &_cbbad); _adcd != nil {
					return _adcd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "photoAlbum"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "photoAlbum"}:
				_efdc.PhotoAlbum = NewCT_PhotoAlbum()
				if _ffdc := d.DecodeElement(_efdc.PhotoAlbum, &_cbbad); _ffdc != nil {
					return _ffdc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "custDataLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "custDataLst"}:
				_efdc.CustDataLst = NewCT_CustomerDataList()
				if _ccefe := d.DecodeElement(_efdc.CustDataLst, &_cbbad); _ccefe != nil {
					return _ccefe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "kinsoku"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "kinsoku"}:
				_efdc.Kinsoku = NewCT_Kinsoku()
				if _adcde := d.DecodeElement(_efdc.Kinsoku, &_cbbad); _adcde != nil {
					return _adcde
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "defaultTextStyle"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "defaultTextStyle"}:
				_efdc.DefaultTextStyle = _cb.NewCT_TextListStyle()
				if _eeff := d.DecodeElement(_efdc.DefaultTextStyle, &_cbbad); _eeff != nil {
					return _eeff
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "modifyVerifier"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "modifyVerifier"}:
				_efdc.ModifyVerifier = NewCT_ModifyVerifier()
				if _bed := d.DecodeElement(_efdc.ModifyVerifier, &_cbbad); _bed != nil {
					return _bed
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_efdc.ExtLst = NewCT_ExtensionList()
				if _bdbf := d.DecodeElement(_efdc.ExtLst, &_cbbad); _bdbf != nil {
					return _bdbf
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Presentation\u0020\u0025v", _cbbad.Name)
				if _dfgg := d.Skip(); _dfgg != nil {
					return _dfgg
				}
			}
		case _e.EndElement:
			break _egfa
		case _e.CharData:
		}
	}
	return nil
}
func NewHandoutMaster() *HandoutMaster {
	_ffeba := &HandoutMaster{}
	_ffeba.CT_HandoutMaster = *NewCT_HandoutMaster()
	return _ffeba
}

type ST_PhotoAlbumLayout byte

// Validate validates the CT_TLTemplate and its children
func (_ccfg *CT_TLTemplate) Validate() error { return _ccfg.ValidateWithPath("CT_TLTemplate") }
func (_ebee *CT_TLAnimVariantStringVal) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "val"}, Value: _c.Sprintf("\u0025v", _ebee.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_OleObjectEmbed and its children
func (_gdac *CT_OleObjectEmbed) Validate() error { return _gdac.ValidateWithPath("CT_OleObjectEmbed") }
func (_edfdag ST_TLBehaviorTransformType) String() string {
	switch _edfdag {
	case 0:
		return ""
	case 1:
		return "pt"
	case 2:
		return "img"
	}
	return ""
}

type CT_SlideIdListEntry struct {

	// Slide Identifier
	IdAttr  uint32
	RIdAttr string
	ExtLst  *CT_ExtensionList
}

func (_ecdfe ST_TLBehaviorAdditiveType) String() string {
	switch _ecdfe {
	case 0:
		return ""
	case 1:
		return "base"
	case 2:
		return "sum"
	case 3:
		return "repl"
	case 4:
		return "mult"
	case 5:
		return "none"
	}
	return ""
}
func (_cgddg *CT_NotesMasterIdList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _cgddg.NotesMasterId != nil {
		_dcce := _e.StartElement{Name: _e.Name{Local: "p:notesMasterId"}}
		e.EncodeElement(_cgddg.NotesMasterId, _dcce)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_aacc *CT_SlideMasterIdList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_gbace:
	for {
		_fage, _eeefd := d.Token()
		if _eeefd != nil {
			return _eeefd
		}
		switch _afgdd := _fage.(type) {
		case _e.StartElement:
			switch _afgdd.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldMasterId"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldMasterId"}:
				_caae := NewCT_SlideMasterIdListEntry()
				if _becae := d.DecodeElement(_caae, &_afgdd); _becae != nil {
					return _becae
				}
				_aacc.SldMasterId = append(_aacc.SldMasterId, _caae)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_SlideMasterIdList\u0020\u0025v", _afgdd.Name)
				if _gaaf := d.Skip(); _gaaf != nil {
					return _gaaf
				}
			}
		case _e.EndElement:
			break _gbace
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the HandoutMaster and its children, prefixing error messages with path
func (_cdfaf *HandoutMaster) ValidateWithPath(path string) error {
	if _gadc := _cdfaf.CT_HandoutMaster.ValidateWithPath(path); _gadc != nil {
		return _gadc
	}
	return nil
}

// Validate validates the EG_ExtensionList and its children
func (_aabbc *EG_ExtensionList) Validate() error { return _aabbc.ValidateWithPath("EG_ExtensionList") }
func (_cfce *CT_HandoutMaster) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_dagd := _e.StartElement{Name: _e.Name{Local: "p:cSld"}}
	e.EncodeElement(_cfce.CSld, _dagd)
	_gag := _e.StartElement{Name: _e.Name{Local: "p:clrMap"}}
	e.EncodeElement(_cfce.ClrMap, _gag)
	if _cfce.Hf != nil {
		_gbfe := _e.StartElement{Name: _e.Name{Local: "p:hf"}}
		e.EncodeElement(_cfce.Hf, _gbfe)
	}
	if _cfce.ExtLst != nil {
		_abca := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_cfce.ExtLst, _abca)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_Kinsoku struct {

	// Language
	LangAttr *string

	// Invalid Kinsoku Start Characters
	InvalStCharsAttr string

	// Invalid Kinsoku End Characters
	InvalEndCharsAttr string
}
type CT_TLIterateIntervalTime struct {

	// Time
	ValAttr ST_TLTime
}

func (_gebfc ST_TLTimeNodePresetClassType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_ddbefe := _e.Attr{}
	_ddbefe.Name = name
	switch _gebfc {
	case ST_TLTimeNodePresetClassTypeUnset:
		_ddbefe.Value = ""
	case ST_TLTimeNodePresetClassTypeEntr:
		_ddbefe.Value = "entr"
	case ST_TLTimeNodePresetClassTypeExit:
		_ddbefe.Value = "exit"
	case ST_TLTimeNodePresetClassTypeEmph:
		_ddbefe.Value = "emph"
	case ST_TLTimeNodePresetClassTypePath:
		_ddbefe.Value = "path"
	case ST_TLTimeNodePresetClassTypeVerb:
		_ddbefe.Value = "verb"
	case ST_TLTimeNodePresetClassTypeMediacall:
		_ddbefe.Value = "mediacall"
	}
	return _ddbefe, nil
}
func (_fcg *CT_BuildList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_acg:
	for {
		_aec, _beb := d.Token()
		if _beb != nil {
			return _beb
		}
		switch _cff := _aec.(type) {
		case _e.StartElement:
			switch _cff.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bldP"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bldP"}:
				_abde := NewCT_TLBuildParagraph()
				if _ccd := d.DecodeElement(_abde, &_cff); _ccd != nil {
					return _ccd
				}
				_fcg.BldP = append(_fcg.BldP, _abde)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bldDgm"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bldDgm"}:
				_cce := NewCT_TLBuildDiagram()
				if _egg := d.DecodeElement(_cce, &_cff); _egg != nil {
					return _egg
				}
				_fcg.BldDgm = append(_fcg.BldDgm, _cce)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bldOleChart"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bldOleChart"}:
				_ged := NewCT_TLOleBuildChart()
				if _fagd := d.DecodeElement(_ged, &_cff); _fagd != nil {
					return _fagd
				}
				_fcg.BldOleChart = append(_fcg.BldOleChart, _ged)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bldGraphic"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bldGraphic"}:
				_cgd := NewCT_TLGraphicalObjectBuild()
				if _bec := d.DecodeElement(_cgd, &_cff); _bec != nil {
					return _bec
				}
				_fcg.BldGraphic = append(_fcg.BldGraphic, _cgd)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_BuildList\u0020\u0025v", _cff.Name)
				if _fbc := d.Skip(); _fbc != nil {
					return _fbc
				}
			}
		case _e.EndElement:
			break _acg
		case _e.CharData:
		}
	}
	return nil
}
func (_bfag *CT_TagsData) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _bfag.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TLTextTargetElement and its children, prefixing error messages with path
func (_bfgcg *CT_TLTextTargetElement) ValidateWithPath(path string) error {
	if _bfgcg.CharRg != nil {
		if _cebgeg := _bfgcg.CharRg.ValidateWithPath(path + "\u002fCharRg"); _cebgeg != nil {
			return _cebgeg
		}
	}
	if _bfgcg.PRg != nil {
		if _fddce := _bfgcg.PRg.ValidateWithPath(path + "\u002fPRg"); _fddce != nil {
			return _fddce
		}
	}
	return nil
}
func (_begc ST_PlaceholderType) ValidateWithPath(path string) error {
	switch _begc {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_begc))
	}
	return nil
}
func (_efbff ST_SlideSizeType) String() string {
	switch _efbff {
	case 0:
		return ""
	case 1:
		return "screen4x3"
	case 2:
		return "letter"
	case 3:
		return "A4"
	case 4:
		return "35mm"
	case 5:
		return "overhead"
	case 6:
		return "banner"
	case 7:
		return "custom"
	case 8:
		return "ledger"
	case 9:
		return "A3"
	case 10:
		return "B4ISO"
	case 11:
		return "B5ISO"
	case 12:
		return "B4JIS"
	case 13:
		return "B5JIS"
	case 14:
		return "hagakiCard"
	case 15:
		return "screen16x9"
	case 16:
		return "screen16x10"
	}
	return ""
}

type CT_SlideTransitionChoice struct {
	Blinds    *CT_OrientationTransition
	Checker   *CT_OrientationTransition
	Circle    *CT_Empty
	Dissolve  *CT_Empty
	Comb      *CT_OrientationTransition
	Cover     *CT_EightDirectionTransition
	Cut       *CT_OptionalBlackTransition
	Diamond   *CT_Empty
	Fade      *CT_OptionalBlackTransition
	Newsflash *CT_Empty
	Plus      *CT_Empty
	Pull      *CT_EightDirectionTransition
	Push      *CT_SideDirectionTransition
	Random    *CT_Empty
	RandomBar *CT_OrientationTransition
	Split     *CT_SplitTransition
	Strips    *CT_CornerDirectionTransition
	Wedge     *CT_Empty
	Wheel     *CT_WheelTransition
	Wipe      *CT_SideDirectionTransition
	Zoom      *CT_InOutTransition
}

// ValidateWithPath validates the CT_TLTimeNodeSequence and its children, prefixing error messages with path
func (_beegb *CT_TLTimeNodeSequence) ValidateWithPath(path string) error {
	if _edcfa := _beegb.PrevAcAttr.ValidateWithPath(path + "/PrevAcAttr"); _edcfa != nil {
		return _edcfa
	}
	if _bgdag := _beegb.NextAcAttr.ValidateWithPath(path + "/NextAcAttr"); _bgdag != nil {
		return _bgdag
	}
	if _cbgbb := _beegb.CTn.ValidateWithPath(path + "\u002fCTn"); _cbgbb != nil {
		return _cbgbb
	}
	if _beegb.PrevCondLst != nil {
		if _decd := _beegb.PrevCondLst.ValidateWithPath(path + "\u002fPrevCondLst"); _decd != nil {
			return _decd
		}
	}
	if _beegb.NextCondLst != nil {
		if _ebadgd := _beegb.NextCondLst.ValidateWithPath(path + "\u002fNextCondLst"); _ebadgd != nil {
			return _ebadgd
		}
	}
	return nil
}
func (_bgbab *ST_IterateType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_babdb, _ccecc := d.Token()
	if _ccecc != nil {
		return _ccecc
	}
	if _cbebg, _dddeb := _babdb.(_e.EndElement); _dddeb && _cbebg.Name == start.Name {
		*_bgbab = 1
		return nil
	}
	if _eacac, _cbeef := _babdb.(_e.CharData); !_cbeef {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _babdb)
	} else {
		switch string(_eacac) {
		case "":
			*_bgbab = 0
		case "el":
			*_bgbab = 1
		case "wd":
			*_bgbab = 2
		case "lt":
			*_bgbab = 3
		}
	}
	_babdb, _ccecc = d.Token()
	if _ccecc != nil {
		return _ccecc
	}
	if _cacc, _bgbde := _babdb.(_e.EndElement); _bgbde && _cacc.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _babdb)
}
func (_fccec ST_TLBehaviorAccumulateType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_gaage := _e.Attr{}
	_gaage.Name = name
	switch _fccec {
	case ST_TLBehaviorAccumulateTypeUnset:
		_gaage.Value = ""
	case ST_TLBehaviorAccumulateTypeNone:
		_gaage.Value = "none"
	case ST_TLBehaviorAccumulateTypeAlways:
		_gaage.Value = "always"
	}
	return _gaage, nil
}
func NewCT_SlideIdListEntry() *CT_SlideIdListEntry {
	_egag := &CT_SlideIdListEntry{}
	_egag.IdAttr = 256
	return _egag
}
func (_gccae ST_PhotoAlbumLayout) ValidateWithPath(path string) error {
	switch _gccae {
	case 0, 1, 2, 3, 4, 5, 6, 7:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gccae))
	}
	return nil
}
func (_bceg ST_SplitterBarState) ValidateWithPath(path string) error {
	switch _bceg {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bceg))
	}
	return nil
}

type CT_TLAnimVariantStringVal struct {

	// Value
	ValAttr string
}

// ValidateWithPath validates the CT_ControlList and its children, prefixing error messages with path
func (_fgdg *CT_ControlList) ValidateWithPath(path string) error {
	for _dcda, _gef := range _fgdg.Control {
		if _cag := _gef.ValidateWithPath(_c.Sprintf("\u0025s\u002fControl\u005b\u0025d\u005d", path, _dcda)); _cag != nil {
			return _cag
		}
	}
	return nil
}
func (_fafbf *CT_NotesMasterIdListEntry) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _dfbff := range start.Attr {
		if _dfbff.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _dfbff.Name.Local == "id" || _dfbff.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _dfbff.Name.Local == "id" {
			_fcfeb, _afabd := _dfbff.Value, error(nil)
			if _afabd != nil {
				return _afabd
			}
			_fafbf.IdAttr = _fcfeb
			continue
		}
	}
_aegg:
	for {
		_cdcf, _ddad := d.Token()
		if _ddad != nil {
			return _ddad
		}
		switch _eeb := _cdcf.(type) {
		case _e.StartElement:
			switch _eeb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_fafbf.ExtLst = NewCT_ExtensionList()
				if _baeda := d.DecodeElement(_fafbf.ExtLst, &_eeb); _baeda != nil {
					return _baeda
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_NotesMasterIdListEntry\u0020\u0025v", _eeb.Name)
				if _ccbc := d.Skip(); _ccbc != nil {
					return _ccbc
				}
			}
		case _e.EndElement:
			break _aegg
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_SideDirectionTransition and its children
func (_dgadf *CT_SideDirectionTransition) Validate() error {
	return _dgadf.ValidateWithPath("CT_SideDirectionTransition")
}

// ValidateWithPath validates the CT_NotesTextViewProperties and its children, prefixing error messages with path
func (_fbdab *CT_NotesTextViewProperties) ValidateWithPath(path string) error {
	if _fgge := _fbdab.CViewPr.ValidateWithPath(path + "\u002fCViewPr"); _fgge != nil {
		return _fgge
	}
	if _fbdab.ExtLst != nil {
		if _dfgf := _fbdab.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dfgf != nil {
			return _dfgf
		}
	}
	return nil
}
func NewCT_CommentAuthorList() *CT_CommentAuthorList { _abbe := &CT_CommentAuthorList{}; return _abbe }
func (_cdgdb *CT_TagsData) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _fgaaa := range start.Attr {
		if _fgaaa.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _fgaaa.Name.Local == "id" || _fgaaa.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _fgaaa.Name.Local == "id" {
			_gdfa, _afgfff := _fgaaa.Value, error(nil)
			if _afgfff != nil {
				return _afgfff
			}
			_cdgdb.IdAttr = _gdfa
			continue
		}
	}
	for {
		_adaac, _fgbg := d.Token()
		if _fgbg != nil {
			return _c.Errorf("parsing\u0020CT_TagsData:\u0020\u0025s", _fgbg)
		}
		if _effc, _gcdfa := _adaac.(_e.EndElement); _gcdfa && _effc.Name == start.Name {
			break
		}
	}
	return nil
}

type ST_TransitionSpeed byte

func (_acdcf ST_TLTimeNodePresetClassType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_acdcf.String(), start)
}

// Validate validates the CT_SlideLayoutIdList and its children
func (_degc *CT_SlideLayoutIdList) Validate() error {
	return _degc.ValidateWithPath("CT_SlideLayoutIdList")
}
func (_dfc *CT_EightDirectionTransition) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _ceg := range start.Attr {
		if _ceg.Name.Local == "dir" {
			_agfd, _edgg := ParseUnionST_TransitionEightDirectionType(_ceg.Value)
			if _edgg != nil {
				return _edgg
			}
			_dfc.DirAttr = &_agfd
			continue
		}
	}
	for {
		_bcd, _fdef := d.Token()
		if _fdef != nil {
			return _c.Errorf("parsing\u0020CT_EightDirectionTransition:\u0020\u0025s", _fdef)
		}
		if _ecd, _bad := _bcd.(_e.EndElement); _bad && _ecd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dcdcf ST_TLAnimateColorSpace) String() string {
	switch _dcdcf {
	case 0:
		return ""
	case 1:
		return "rgb"
	case 2:
		return "hsl"
	}
	return ""
}

// ValidateWithPath validates the CT_HandoutMasterIdList and its children, prefixing error messages with path
func (_daeed *CT_HandoutMasterIdList) ValidateWithPath(path string) error {
	if _daeed.HandoutMasterId != nil {
		if _baed := _daeed.HandoutMasterId.ValidateWithPath(path + "\u002fHandoutMasterId"); _baed != nil {
			return _baed
		}
	}
	return nil
}
func (_fgfa *CT_Placeholder) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _fgfa.TypeAttr != ST_PlaceholderTypeUnset {
		_bcdag, _abef := _fgfa.TypeAttr.MarshalXMLAttr(_e.Name{Local: "type"})
		if _abef != nil {
			return _abef
		}
		start.Attr = append(start.Attr, _bcdag)
	}
	if _fgfa.OrientAttr != ST_DirectionUnset {
		_eabg, _ebdd := _fgfa.OrientAttr.MarshalXMLAttr(_e.Name{Local: "orient"})
		if _ebdd != nil {
			return _ebdd
		}
		start.Attr = append(start.Attr, _eabg)
	}
	if _fgfa.SzAttr != ST_PlaceholderSizeUnset {
		_ccfag, _caeba := _fgfa.SzAttr.MarshalXMLAttr(_e.Name{Local: "sz"})
		if _caeba != nil {
			return _caeba
		}
		start.Attr = append(start.Attr, _ccfag)
	}
	if _fgfa.IdxAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "idx"}, Value: _c.Sprintf("\u0025v", *_fgfa.IdxAttr)})
	}
	if _fgfa.HasCustomPromptAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "hasCustomPrompt"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fgfa.HasCustomPromptAttr))})
	}
	e.EncodeToken(start)
	if _fgfa.ExtLst != nil {
		_gcdc := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_fgfa.ExtLst, _gcdc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_adad ST_SlideLayoutType) Validate() error { return _adad.ValidateWithPath("") }

type CT_TLShapeTargetElement struct {

	// Shape ID
	SpidAttr uint32

	// Background
	Bg *CT_Empty

	// Subshape
	SubSp *CT_TLSubShapeId

	// Embedded Chart Element
	OleChartEl *CT_TLOleChartTargetElement

	// Text Element
	TxEl *CT_TLTextTargetElement

	// Graphic Element
	GraphicEl *_cb.CT_AnimationElementChoice
}

func (_aafba ST_TLOleChartBuildType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_fgeec := _e.Attr{}
	_fgeec.Name = name
	switch _aafba {
	case ST_TLOleChartBuildTypeUnset:
		_fgeec.Value = ""
	case ST_TLOleChartBuildTypeAllAtOnce:
		_fgeec.Value = "allAtOnce"
	case ST_TLOleChartBuildTypeSeries:
		_fgeec.Value = "series"
	case ST_TLOleChartBuildTypeCategory:
		_fgeec.Value = "category"
	case ST_TLOleChartBuildTypeSeriesEl:
		_fgeec.Value = "seriesEl"
	case ST_TLOleChartBuildTypeCategoryEl:
		_fgeec.Value = "categoryEl"
	}
	return _fgeec, nil
}
func NewPresentation() *Presentation {
	_cecebd := &Presentation{}
	_cecebd.CT_Presentation = *NewCT_Presentation()
	return _cecebd
}

type CT_Comment struct {

	// Comment Author ID
	AuthorIdAttr uint32

	// Comment Date/Time
	DtAttr *_fb.Time

	// Comment Index
	IdxAttr uint32

	// Comment Position
	Pos *_cb.CT_Point2D

	// Comment's Text Content
	Text   string
	ExtLst *CT_ExtensionListModify
}

// Validate validates the CT_Placeholder and its children
func (_ageef *CT_Placeholder) Validate() error { return _ageef.ValidateWithPath("CT_Placeholder") }
func (_fffeg ST_TLAnimateEffectTransition) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_fgef := _e.Attr{}
	_fgef.Name = name
	switch _fffeg {
	case ST_TLAnimateEffectTransitionUnset:
		_fgef.Value = ""
	case ST_TLAnimateEffectTransitionIn:
		_fgef.Value = "in"
	case ST_TLAnimateEffectTransitionOut:
		_fgef.Value = "out"
	case ST_TLAnimateEffectTransitionNone:
		_fgef.Value = "none"
	}
	return _fgef, nil
}
func (_befab *CT_TLOleChartTargetElement) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_befab.TypeAttr = ST_TLChartSubelementType(1)
	for _, _fcfcf := range start.Attr {
		if _fcfcf.Name.Local == "type" {
			_befab.TypeAttr.UnmarshalXMLAttr(_fcfcf)
			continue
		}
		if _fcfcf.Name.Local == "lvl" {
			_ebde, _egbfb := _b.ParseUint(_fcfcf.Value, 10, 32)
			if _egbfb != nil {
				return _egbfb
			}
			_acfc := uint32(_ebde)
			_befab.LvlAttr = &_acfc
			continue
		}
	}
	for {
		_gdbe, _bcfca := d.Token()
		if _bcfca != nil {
			return _c.Errorf("parsing\u0020CT_TLOleChartTargetElement:\u0020\u0025s", _bcfca)
		}
		if _bcded, _fbdd := _gdbe.(_e.EndElement); _fbdd && _bcded.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_ViewProperties and its children
func (_becbe *CT_ViewProperties) Validate() error {
	return _becbe.ValidateWithPath("CT_ViewProperties")
}
func (_dagdf *CT_PresentationProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _dagdf.HtmlPubPr != nil {
		_edgd := _e.StartElement{Name: _e.Name{Local: "p:htmlPubPr"}}
		e.EncodeElement(_dagdf.HtmlPubPr, _edgd)
	}
	if _dagdf.WebPr != nil {
		_fcaec := _e.StartElement{Name: _e.Name{Local: "p:webPr"}}
		e.EncodeElement(_dagdf.WebPr, _fcaec)
	}
	if _dagdf.PrnPr != nil {
		_bfda := _e.StartElement{Name: _e.Name{Local: "p:prnPr"}}
		e.EncodeElement(_dagdf.PrnPr, _bfda)
	}
	if _dagdf.ShowPr != nil {
		_cfca := _e.StartElement{Name: _e.Name{Local: "p:showPr"}}
		e.EncodeElement(_dagdf.ShowPr, _cfca)
	}
	if _dagdf.ClrMru != nil {
		_dbaf := _e.StartElement{Name: _e.Name{Local: "p:clrMru"}}
		e.EncodeElement(_dagdf.ClrMru, _dbaf)
	}
	if _dagdf.ExtLst != nil {
		_efgf := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_dagdf.ExtLst, _efgf)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_GraphicalObjectFrame and its children
func (_eaeb *CT_GraphicalObjectFrame) Validate() error {
	return _eaeb.ValidateWithPath("CT_GraphicalObjectFrame")
}

// Validate validates the CT_OleObjectChoice and its children
func (_bgba *CT_OleObjectChoice) Validate() error {
	return _bgba.ValidateWithPath("CT_OleObjectChoice")
}

type CT_EmbeddedFontListEntry struct {

	// Embedded Font Name
	Font *_cb.CT_TextFont

	// Regular Embedded Font
	Regular *CT_EmbeddedFontDataId

	// Bold Embedded Font
	Bold *CT_EmbeddedFontDataId

	// Italic Embedded Font
	Italic *CT_EmbeddedFontDataId

	// Bold Italic Embedded Font
	BoldItalic *CT_EmbeddedFontDataId
}

// Validate validates the CT_TLBuildDiagram and its children
func (_gegfc *CT_TLBuildDiagram) Validate() error {
	return _gegfc.ValidateWithPath("CT_TLBuildDiagram")
}

type CT_InOutTransition struct {

	// Direction
	DirAttr ST_TransitionInOutDirectionType
}

// ValidateWithPath validates the CT_TLBuildParagraph and its children, prefixing error messages with path
func (_dgcd *CT_TLBuildParagraph) ValidateWithPath(path string) error {
	if _ggec := _dgcd.BuildAttr.ValidateWithPath(path + "\u002fBuildAttr"); _ggec != nil {
		return _ggec
	}
	if _dgcd.AdvAutoAttr != nil {
		if _ffca := _dgcd.AdvAutoAttr.ValidateWithPath(path + "\u002fAdvAutoAttr"); _ffca != nil {
			return _ffca
		}
	}
	if _dgcd.TmplLst != nil {
		if _aaeaa := _dgcd.TmplLst.ValidateWithPath(path + "\u002fTmplLst"); _aaeaa != nil {
			return _aaeaa
		}
	}
	return nil
}

// Validate validates the OleObj and its children
func (_abdcd *OleObj) Validate() error { return _abdcd.ValidateWithPath("OleObj") }
func (_dabfb ST_OleObjectFollowColorScheme) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_dabfb.String(), start)
}
func NewNotes() *Notes { _ccbe := &Notes{}; _ccbe.CT_NotesSlide = *NewCT_NotesSlide(); return _ccbe }
func (_dcad *CT_BackgroundProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _gff := range start.Attr {
		if _gff.Name.Local == "shadeToTitle" {
			_gcef, _feeg := _b.ParseBool(_gff.Value)
			if _feeg != nil {
				return _feeg
			}
			_dcad.ShadeToTitleAttr = &_gcef
			continue
		}
	}
_dbg:
	for {
		_dbfa, _dgad := d.Token()
		if _dgad != nil {
			return _dgad
		}
		switch _fdbf := _dbfa.(type) {
		case _e.StartElement:
			switch _fdbf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "noFill"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "noFill"}:
				_dcad.NoFill = _cb.NewCT_NoFillProperties()
				if _gfc := d.DecodeElement(_dcad.NoFill, &_fdbf); _gfc != nil {
					return _gfc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "solidFill"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "solidFill"}:
				_dcad.SolidFill = _cb.NewCT_SolidColorFillProperties()
				if _ega := d.DecodeElement(_dcad.SolidFill, &_fdbf); _ega != nil {
					return _ega
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "gradFill"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "gradFill"}:
				_dcad.GradFill = _cb.NewCT_GradientFillProperties()
				if _dbgf := d.DecodeElement(_dcad.GradFill, &_fdbf); _dbgf != nil {
					return _dbgf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "blipFill"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "blipFill"}:
				_dcad.BlipFill = _cb.NewCT_BlipFillProperties()
				if _aeb := d.DecodeElement(_dcad.BlipFill, &_fdbf); _aeb != nil {
					return _aeb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "pattFill"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "pattFill"}:
				_dcad.PattFill = _cb.NewCT_PatternFillProperties()
				if _bcea := d.DecodeElement(_dcad.PattFill, &_fdbf); _bcea != nil {
					return _bcea
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "grpFill"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "grpFill"}:
				_dcad.GrpFill = _cb.NewCT_GroupFillProperties()
				if _cfa := d.DecodeElement(_dcad.GrpFill, &_fdbf); _cfa != nil {
					return _cfa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectLst"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectLst"}:
				_dcad.EffectLst = _cb.NewCT_EffectList()
				if _feg := d.DecodeElement(_dcad.EffectLst, &_fdbf); _feg != nil {
					return _feg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "effectDag"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "effectDag"}:
				_dcad.EffectDag = _cb.NewCT_EffectContainer()
				if _cgf := d.DecodeElement(_dcad.EffectDag, &_fdbf); _cgf != nil {
					return _cgf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_dcad.ExtLst = NewCT_ExtensionList()
				if _ca := d.DecodeElement(_dcad.ExtLst, &_fdbf); _ca != nil {
					return _ca
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_BackgroundProperties \u0025v", _fdbf.Name)
				if _bbc := d.Skip(); _bbc != nil {
					return _bbc
				}
			}
		case _e.EndElement:
			break _dbg
		case _e.CharData:
		}
	}
	return nil
}
func (_gbe *CT_CustomerDataList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _gbe.CustData != nil {
		_ccfa := _e.StartElement{Name: _e.Name{Local: "p:custData"}}
		for _, _daac := range _gbe.CustData {
			e.EncodeElement(_daac, _ccfa)
		}
	}
	if _gbe.Tags != nil {
		_ccdb := _e.StartElement{Name: _e.Name{Local: "p:tags"}}
		e.EncodeElement(_gbe.Tags, _ccdb)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_gdfcg *CT_SlideIdListEntry) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gdfcg.IdAttr = 256
	for _, _edfec := range start.Attr {
		if _edfec.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _edfec.Name.Local == "id" || _edfec.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _edfec.Name.Local == "id" {
			_decac, _gfga := _edfec.Value, error(nil)
			if _gfga != nil {
				return _gfga
			}
			_gdfcg.RIdAttr = _decac
			continue
		}
		if _edfec.Name.Local == "id" {
			_gffafa, _beaaa := _b.ParseUint(_edfec.Value, 10, 32)
			if _beaaa != nil {
				return _beaaa
			}
			_gdfcg.IdAttr = uint32(_gffafa)
			continue
		}
	}
_dcbc:
	for {
		_cfcaf, _ecgeb := d.Token()
		if _ecgeb != nil {
			return _ecgeb
		}
		switch _abeg := _cfcaf.(type) {
		case _e.StartElement:
			switch _abeg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_gdfcg.ExtLst = NewCT_ExtensionList()
				if _cbede := d.DecodeElement(_gdfcg.ExtLst, &_abeg); _cbede != nil {
					return _cbede
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SlideIdListEntry\u0020\u0025v", _abeg.Name)
				if _ddedc := d.Skip(); _ddedc != nil {
					return _ddedc
				}
			}
		case _e.EndElement:
			break _dcbc
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TLAnimVariantFloatVal and its children, prefixing error messages with path
func (_fcbdf *CT_TLAnimVariantFloatVal) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_Kinsoku and its children, prefixing error messages with path
func (_dbggd *CT_Kinsoku) ValidateWithPath(path string) error { return nil }
func (_fddac *ST_TLAnimateColorSpace) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_ddgce, _fgaaac := d.Token()
	if _fgaaac != nil {
		return _fgaaac
	}
	if _fgceg, _efcge := _ddgce.(_e.EndElement); _efcge && _fgceg.Name == start.Name {
		*_fddac = 1
		return nil
	}
	if _cgffbc, _gfcfd := _ddgce.(_e.CharData); !_gfcfd {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ddgce)
	} else {
		switch string(_cgffbc) {
		case "":
			*_fddac = 0
		case "rgb":
			*_fddac = 1
		case "hsl":
			*_fddac = 2
		}
	}
	_ddgce, _fgaaac = d.Token()
	if _fgaaac != nil {
		return _fgaaac
	}
	if _eebce, _deaba := _ddgce.(_e.EndElement); _deaba && _eebce.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ddgce)
}
func NewCT_ControlList() *CT_ControlList { _aef := &CT_ControlList{}; return _aef }
func ParseUnionST_FixedPercentage(s string) (_cb.ST_FixedPercentage, error) {
	return _cb.ParseUnionST_FixedPercentage(s)
}
func (_fbfg *ST_TLTime) ValidateWithPath(path string) error {
	_fgegb := []string{}
	if _fbfg.Uint32 != nil {
		_fgegb = append(_fgegb, "Uint32")
	}
	if _fbfg.ST_TLTimeIndefinite != ST_TLTimeIndefiniteUnset {
		_fgegb = append(_fgegb, "ST_TLTimeIndefinite")
	}
	if len(_fgegb) > 1 {
		return _c.Errorf("%s\u0020too\u0020many\u0020members\u0020set:\u0020\u0025v", path, _fgegb)
	}
	return nil
}

type ST_TLDiagramBuildType byte

// Validate validates the CT_TimeNodeList and its children
func (_eadce *CT_TimeNodeList) Validate() error { return _eadce.ValidateWithPath("CT_TimeNodeList") }
func (_adb *CT_Connector) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_adb.NvCxnSpPr = NewCT_ConnectorNonVisual()
	_adb.SpPr = _cb.NewCT_ShapeProperties()
_ebgc:
	for {
		_eage, _ggfa := d.Token()
		if _ggfa != nil {
			return _ggfa
		}
		switch _fadd := _eage.(type) {
		case _e.StartElement:
			switch _fadd.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "nvCxnSpPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "nvCxnSpPr"}:
				if _adbd := d.DecodeElement(_adb.NvCxnSpPr, &_fadd); _adbd != nil {
					return _adbd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "spPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "spPr"}:
				if _gfd := d.DecodeElement(_adb.SpPr, &_fadd); _gfd != nil {
					return _gfd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "style"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "style"}:
				_adb.Style = _cb.NewCT_ShapeStyle()
				if _acbca := d.DecodeElement(_adb.Style, &_fadd); _acbca != nil {
					return _acbca
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_adb.ExtLst = NewCT_ExtensionListModify()
				if _agg := d.DecodeElement(_adb.ExtLst, &_fadd); _agg != nil {
					return _agg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Connector\u0020\u0025v", _fadd.Name)
				if _dgfb := d.Skip(); _dgfb != nil {
					return _dgfb
				}
			}
		case _e.EndElement:
			break _ebgc
		case _e.CharData:
		}
	}
	return nil
}
func (_fgecc ST_TLBehaviorTransformType) Validate() error { return _fgecc.ValidateWithPath("") }

// ValidateWithPath validates the CT_CommentAuthorList and its children, prefixing error messages with path
func (_gggd *CT_CommentAuthorList) ValidateWithPath(path string) error {
	for _ceb, _gge := range _gggd.CmAuthor {
		if _ffa := _gge.ValidateWithPath(_c.Sprintf("\u0025s\u002fCmAuthor\u005b\u0025d\u005d", path, _ceb)); _ffa != nil {
			return _ffa
		}
	}
	return nil
}
func NewCT_SlideSorterViewProperties() *CT_SlideSorterViewProperties {
	_cdcdd := &CT_SlideSorterViewProperties{}
	_cdcdd.CViewPr = NewCT_CommonViewProperties()
	return _cdcdd
}
func (_fdcc *CT_TLByHslColorTransform) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "h"}, Value: _c.Sprintf("\u0025v", _fdcc.HAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "s"}, Value: _c.Sprintf("\u0025v", _fdcc.SAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "l"}, Value: _c.Sprintf("\u0025v", _fdcc.LAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_cbagd ST_TransitionCornerDirectionType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_cbagd.String(), start)
}
func (_adeba *CT_WebProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _adeba.ShowAnimationAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showAnimation"}, Value: _c.Sprintf("\u0025d", _fdeab(*_adeba.ShowAnimationAttr))})
	}
	if _adeba.ResizeGraphicsAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "resizeGraphics"}, Value: _c.Sprintf("\u0025d", _fdeab(*_adeba.ResizeGraphicsAttr))})
	}
	if _adeba.AllowPngAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "allowPng"}, Value: _c.Sprintf("\u0025d", _fdeab(*_adeba.AllowPngAttr))})
	}
	if _adeba.RelyOnVmlAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "relyOnVml"}, Value: _c.Sprintf("\u0025d", _fdeab(*_adeba.RelyOnVmlAttr))})
	}
	if _adeba.OrganizeInFoldersAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "organizeInFolders"}, Value: _c.Sprintf("\u0025d", _fdeab(*_adeba.OrganizeInFoldersAttr))})
	}
	if _adeba.UseLongFilenamesAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "useLongFilenames"}, Value: _c.Sprintf("\u0025d", _fdeab(*_adeba.UseLongFilenamesAttr))})
	}
	if _adeba.ImgSzAttr != ST_WebScreenSizeUnset {
		_agdc, _bbec := _adeba.ImgSzAttr.MarshalXMLAttr(_e.Name{Local: "imgSz"})
		if _bbec != nil {
			return _bbec
		}
		start.Attr = append(start.Attr, _agdc)
	}
	if _adeba.EncodingAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "encoding"}, Value: _c.Sprintf("\u0025v", *_adeba.EncodingAttr)})
	}
	if _adeba.ClrAttr != ST_WebColorTypeUnset {
		_gfdc, _cbgfc := _adeba.ClrAttr.MarshalXMLAttr(_e.Name{Local: "clr"})
		if _cbgfc != nil {
			return _cbgfc
		}
		start.Attr = append(start.Attr, _gfdc)
	}
	e.EncodeToken(start)
	if _adeba.ExtLst != nil {
		_deddg := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_adeba.ExtLst, _deddg)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Picture and its children, prefixing error messages with path
func (_cagb *CT_Picture) ValidateWithPath(path string) error {
	if _efbfd := _cagb.NvPicPr.ValidateWithPath(path + "\u002fNvPicPr"); _efbfd != nil {
		return _efbfd
	}
	if _bfae := _cagb.BlipFill.ValidateWithPath(path + "\u002fBlipFill"); _bfae != nil {
		return _bfae
	}
	if _gefdb := _cagb.SpPr.ValidateWithPath(path + "\u002fSpPr"); _gefdb != nil {
		return _gefdb
	}
	if _cagb.Style != nil {
		if _cefc := _cagb.Style.ValidateWithPath(path + "\u002fStyle"); _cefc != nil {
			return _cefc
		}
	}
	if _cagb.ExtLst != nil {
		if _bgbg := _cagb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bgbg != nil {
			return _bgbg
		}
	}
	return nil
}
func (_fbcde ST_WebColorType) Validate() error { return _fbcde.ValidateWithPath("") }
func (_baab *HandoutMaster) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:handoutMaster"
	return _baab.CT_HandoutMaster.MarshalXML(e, start)
}
func NewCT_TLAnimateEffectBehavior() *CT_TLAnimateEffectBehavior {
	_adccf := &CT_TLAnimateEffectBehavior{}
	_adccf.CBhvr = NewCT_TLCommonBehaviorData()
	return _adccf
}
func (_fdffc *ST_TransitionSideDirectionType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_fdffc = 0
	case "l":
		*_fdffc = 1
	case "u":
		*_fdffc = 2
	case "r":
		*_fdffc = 3
	case "d":
		*_fdffc = 4
	}
	return nil
}
func (_dbgbd *CT_TransitionSoundAction) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_fbcfc:
	for {
		_gfcaa, _faaaf := d.Token()
		if _faaaf != nil {
			return _faaaf
		}
		switch _edbe := _gfcaa.(type) {
		case _e.StartElement:
			switch _edbe.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "stSnd"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "stSnd"}:
				_dbgbd.StSnd = NewCT_TransitionStartSoundAction()
				if _ggcbe := d.DecodeElement(_dbgbd.StSnd, &_edbe); _ggcbe != nil {
					return _ggcbe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "endSnd"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "endSnd"}:
				_dbgbd.EndSnd = NewCT_Empty()
				if _ggbee := d.DecodeElement(_dbgbd.EndSnd, &_edbe); _ggbee != nil {
					return _ggbee
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_TransitionSoundAction\u0020%v", _edbe.Name)
				if _cadg := d.Skip(); _cadg != nil {
					return _cadg
				}
			}
		case _e.EndElement:
			break _fbcfc
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CommonSlideData and its children, prefixing error messages with path
func (_dgadd *CT_CommonSlideData) ValidateWithPath(path string) error {
	if _dgadd.Bg != nil {
		if _dea := _dgadd.Bg.ValidateWithPath(path + "\u002fBg"); _dea != nil {
			return _dea
		}
	}
	if _ffag := _dgadd.SpTree.ValidateWithPath(path + "\u002fSpTree"); _ffag != nil {
		return _ffag
	}
	if _dgadd.CustDataLst != nil {
		if _abdeb := _dgadd.CustDataLst.ValidateWithPath(path + "\u002fCustDataLst"); _abdeb != nil {
			return _abdeb
		}
	}
	if _dgadd.Controls != nil {
		if _bge := _dgadd.Controls.ValidateWithPath(path + "\u002fControls"); _bge != nil {
			return _bge
		}
	}
	if _dgadd.ExtLst != nil {
		if _cdc := _dgadd.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cdc != nil {
			return _cdc
		}
	}
	return nil
}
func (_cgad *CT_Empty) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type ST_TLTimeNodeType byte

func (_gcdf *CT_ShowInfoBrowse) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _acfa := range start.Attr {
		if _acfa.Name.Local == "showScrollbar" {
			_egda, _gafg := _b.ParseBool(_acfa.Value)
			if _gafg != nil {
				return _gafg
			}
			_gcdf.ShowScrollbarAttr = &_egda
			continue
		}
	}
	for {
		_fbgg, _ecede := d.Token()
		if _ecede != nil {
			return _c.Errorf("parsing\u0020CT_ShowInfoBrowse: \u0025s", _ecede)
		}
		if _aaeg, _ebdc := _fbgg.(_e.EndElement); _ebdc && _aaeg.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_WebProperties() *CT_WebProperties { _agfeaf := &CT_WebProperties{}; return _agfeaf }
func (_egcbc *ST_TLTriggerEvent) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_egcbc = 0
	case "onBegin":
		*_egcbc = 1
	case "onEnd":
		*_egcbc = 2
	case "begin":
		*_egcbc = 3
	case "end":
		*_egcbc = 4
	case "onClick":
		*_egcbc = 5
	case "onDblClick":
		*_egcbc = 6
	case "onMouseOver":
		*_egcbc = 7
	case "onMouseOut":
		*_egcbc = 8
	case "onNext":
		*_egcbc = 9
	case "onPrev":
		*_egcbc = 10
	case "onStopAudio":
		*_egcbc = 11
	}
	return nil
}

type CT_OleObjectEmbed struct {

	// Color Scheme Properties for Embedded object
	FollowColorSchemeAttr ST_OleObjectFollowColorScheme
	ExtLst                *CT_ExtensionList
}

// ValidateWithPath validates the PresentationPr and its children, prefixing error messages with path
func (_gfdbb *PresentationPr) ValidateWithPath(path string) error {
	if _gbef := _gfdbb.CT_PresentationProperties.ValidateWithPath(path); _gbef != nil {
		return _gbef
	}
	return nil
}

// Validate validates the CT_GuideList and its children
func (_agea *CT_GuideList) Validate() error { return _agea.ValidateWithPath("CT_GuideList") }

type CT_NotesViewProperties struct {

	// Common Slide View Properties
	CSldViewPr *CT_CommonSlideViewProperties
	ExtLst     *CT_ExtensionList
}

// ValidateWithPath validates the CT_SplitTransition and its children, prefixing error messages with path
func (_bfafe *CT_SplitTransition) ValidateWithPath(path string) error {
	if _gfabb := _bfafe.OrientAttr.ValidateWithPath(path + "/OrientAttr"); _gfabb != nil {
		return _gfabb
	}
	if _aefef := _bfafe.DirAttr.ValidateWithPath(path + "\u002fDirAttr"); _aefef != nil {
		return _aefef
	}
	return nil
}

type CT_OutlineViewSlideEntry struct {
	IdAttr string

	// Collapsed
	CollapseAttr *bool
}

func (_fdgfbb *ST_TLNextActionType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_fdgfbb = 0
	case "none":
		*_fdgfbb = 1
	case "seek":
		*_fdgfbb = 2
	}
	return nil
}

type NotesMaster struct{ CT_NotesMaster }

func (_gded *CT_WebProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _dfaff := range start.Attr {
		if _dfaff.Name.Local == "showAnimation" {
			_decdc, _aeegd := _b.ParseBool(_dfaff.Value)
			if _aeegd != nil {
				return _aeegd
			}
			_gded.ShowAnimationAttr = &_decdc
			continue
		}
		if _dfaff.Name.Local == "resizeGraphics" {
			_badff, _bbbc := _b.ParseBool(_dfaff.Value)
			if _bbbc != nil {
				return _bbbc
			}
			_gded.ResizeGraphicsAttr = &_badff
			continue
		}
		if _dfaff.Name.Local == "allowPng" {
			_cbgfdf, _dagdd := _b.ParseBool(_dfaff.Value)
			if _dagdd != nil {
				return _dagdd
			}
			_gded.AllowPngAttr = &_cbgfdf
			continue
		}
		if _dfaff.Name.Local == "relyOnVml" {
			_effb, _fcdfe := _b.ParseBool(_dfaff.Value)
			if _fcdfe != nil {
				return _fcdfe
			}
			_gded.RelyOnVmlAttr = &_effb
			continue
		}
		if _dfaff.Name.Local == "organizeInFolders" {
			_ffad, _efabg := _b.ParseBool(_dfaff.Value)
			if _efabg != nil {
				return _efabg
			}
			_gded.OrganizeInFoldersAttr = &_ffad
			continue
		}
		if _dfaff.Name.Local == "useLongFilenames" {
			_eaeac, _deda := _b.ParseBool(_dfaff.Value)
			if _deda != nil {
				return _deda
			}
			_gded.UseLongFilenamesAttr = &_eaeac
			continue
		}
		if _dfaff.Name.Local == "imgSz" {
			_gded.ImgSzAttr.UnmarshalXMLAttr(_dfaff)
			continue
		}
		if _dfaff.Name.Local == "encoding" {
			_cacf, _abebd := _dfaff.Value, error(nil)
			if _abebd != nil {
				return _abebd
			}
			_gded.EncodingAttr = &_cacf
			continue
		}
		if _dfaff.Name.Local == "clr" {
			_gded.ClrAttr.UnmarshalXMLAttr(_dfaff)
			continue
		}
	}
_gffeb:
	for {
		_babc, _gggg := d.Token()
		if _gggg != nil {
			return _gggg
		}
		switch _efef := _babc.(type) {
		case _e.StartElement:
			switch _efef.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_gded.ExtLst = NewCT_ExtensionList()
				if _eebee := d.DecodeElement(_gded.ExtLst, &_efef); _eebee != nil {
					return _eebee
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_WebProperties\u0020\u0025v", _efef.Name)
				if _ebbd := d.Skip(); _ebbd != nil {
					return _ebbd
				}
			}
		case _e.EndElement:
			break _gffeb
		case _e.CharData:
		}
	}
	return nil
}

type EG_ShowType struct {

	// Presenter Slide Show Mode
	Present *CT_Empty

	// Browse Slide Show Mode
	Browse *CT_ShowInfoBrowse

	// Kiosk Slide Show Mode
	Kiosk *CT_ShowInfoKiosk
}

func NewCT_Connector() *CT_Connector {
	_efb := &CT_Connector{}
	_efb.NvCxnSpPr = NewCT_ConnectorNonVisual()
	_efb.SpPr = _cb.NewCT_ShapeProperties()
	return _efb
}
func NewCT_TLAnimVariantStringVal() *CT_TLAnimVariantStringVal {
	_ffeec := &CT_TLAnimVariantStringVal{}
	return _ffeec
}

// Validate validates the CT_CommonSlideViewProperties and its children
func (_cccd *CT_CommonSlideViewProperties) Validate() error {
	return _cccd.ValidateWithPath("CT_CommonSlideViewProperties")
}
func (_ecgaeb *ST_TLDiagramBuildType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_ecgaeb = 0
	case "whole":
		*_ecgaeb = 1
	case "depthByNode":
		*_ecgaeb = 2
	case "depthByBranch":
		*_ecgaeb = 3
	case "breadthByNode":
		*_ecgaeb = 4
	case "breadthByLvl":
		*_ecgaeb = 5
	case "cw":
		*_ecgaeb = 6
	case "cwIn":
		*_ecgaeb = 7
	case "cwOut":
		*_ecgaeb = 8
	case "ccw":
		*_ecgaeb = 9
	case "ccwIn":
		*_ecgaeb = 10
	case "ccwOut":
		*_ecgaeb = 11
	case "inByRing":
		*_ecgaeb = 12
	case "outByRing":
		*_ecgaeb = 13
	case "up":
		*_ecgaeb = 14
	case "down":
		*_ecgaeb = 15
	case "allAtOnce":
		*_ecgaeb = 16
	case "cust":
		*_ecgaeb = 17
	}
	return nil
}

// Validate validates the CT_ConnectorNonVisual and its children
func (_cdaa *CT_ConnectorNonVisual) Validate() error {
	return _cdaa.ValidateWithPath("CT_ConnectorNonVisual")
}
func (_cbece ST_TLChartSubelementType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_gfgcg := _e.Attr{}
	_gfgcg.Name = name
	switch _cbece {
	case ST_TLChartSubelementTypeUnset:
		_gfgcg.Value = ""
	case ST_TLChartSubelementTypeGridLegend:
		_gfgcg.Value = "gridLegend"
	case ST_TLChartSubelementTypeSeries:
		_gfgcg.Value = "series"
	case ST_TLChartSubelementTypeCategory:
		_gfgcg.Value = "category"
	case ST_TLChartSubelementTypePtInSeries:
		_gfgcg.Value = "ptInSeries"
	case ST_TLChartSubelementTypePtInCategory:
		_gfgcg.Value = "ptInCategory"
	}
	return _gfgcg, nil
}

// ValidateWithPath validates the CT_CommonViewProperties and its children, prefixing error messages with path
func (_dgd *CT_CommonViewProperties) ValidateWithPath(path string) error {
	if _gdafg := _dgd.Scale.ValidateWithPath(path + "\u002fScale"); _gdafg != nil {
		return _gdafg
	}
	if _edga := _dgd.Origin.ValidateWithPath(path + "\u002fOrigin"); _edga != nil {
		return _edga
	}
	return nil
}
func (_fffcea *CT_TLSetBehavior) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fffcea.CBhvr = NewCT_TLCommonBehaviorData()
_becaa:
	for {
		_fcfgg, _adce := d.Token()
		if _adce != nil {
			return _adce
		}
		switch _ebagg := _fcfgg.(type) {
		case _e.StartElement:
			switch _ebagg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cBhvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cBhvr"}:
				if _gcdcf := d.DecodeElement(_fffcea.CBhvr, &_ebagg); _gcdcf != nil {
					return _gcdcf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "to"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "to"}:
				_fffcea.To = NewCT_TLAnimVariant()
				if _cfdd := d.DecodeElement(_fffcea.To, &_ebagg); _cfdd != nil {
					return _cfdd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLSetBehavior\u0020\u0025v", _ebagg.Name)
				if _gbga := d.Skip(); _gbga != nil {
					return _gbga
				}
			}
		case _e.EndElement:
			break _becaa
		case _e.CharData:
		}
	}
	return nil
}
func (_cacb ST_TLTriggerEvent) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_cacb.String(), start)
}
func (_egecg ST_PlaceholderSize) ValidateWithPath(path string) error {
	switch _egecg {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_egecg))
	}
	return nil
}
func (_eceaa ST_TLChartSubelementType) Validate() error { return _eceaa.ValidateWithPath("") }
func (_cefd *CT_OutlineViewProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cefd.CViewPr = NewCT_CommonViewProperties()
_eebd:
	for {
		_bbfg, _gdab := d.Token()
		if _gdab != nil {
			return _gdab
		}
		switch _dcga := _bbfg.(type) {
		case _e.StartElement:
			switch _dcga.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cViewPr"}:
				if _egbf := d.DecodeElement(_cefd.CViewPr, &_dcga); _egbf != nil {
					return _egbf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldLst"}:
				_cefd.SldLst = NewCT_OutlineViewSlideList()
				if _caabf := d.DecodeElement(_cefd.SldLst, &_dcga); _caabf != nil {
					return _caabf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_cefd.ExtLst = NewCT_ExtensionList()
				if _ccbb := d.DecodeElement(_cefd.ExtLst, &_dcga); _ccbb != nil {
					return _ccbb
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_OutlineViewProperties\u0020%v", _dcga.Name)
				if _bfffb := d.Skip(); _bfffb != nil {
					return _bfffb
				}
			}
		case _e.EndElement:
			break _eebd
		case _e.CharData:
		}
	}
	return nil
}
func (_fdgdb *ST_TLCommandType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fdffcf, _eaccd := d.Token()
	if _eaccd != nil {
		return _eaccd
	}
	if _cddag, _bcbced := _fdffcf.(_e.EndElement); _bcbced && _cddag.Name == start.Name {
		*_fdgdb = 1
		return nil
	}
	if _cdage, _dfggg := _fdffcf.(_e.CharData); !_dfggg {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fdffcf)
	} else {
		switch string(_cdage) {
		case "":
			*_fdgdb = 0
		case "evt":
			*_fdgdb = 1
		case "call":
			*_fdgdb = 2
		case "verb":
			*_fdgdb = 3
		}
	}
	_fdffcf, _eaccd = d.Token()
	if _eaccd != nil {
		return _eaccd
	}
	if _eceae, _cfgeef := _fdffcf.(_e.EndElement); _cfgeef && _eceae.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fdffcf)
}

// ValidateWithPath validates the CT_SlideIdListEntry and its children, prefixing error messages with path
func (_fffg *CT_SlideIdListEntry) ValidateWithPath(path string) error {
	if _fffg.IdAttr < 256 {
		return _c.Errorf("\u0025s/m\u002eIdAttr\u0020must be\u0020\u003e\u003d\u0020256 \u0028have\u0020\u0025v\u0029", path, _fffg.IdAttr)
	}
	if _fffg.IdAttr >= 2147483648 {
		return _c.Errorf("\u0025s\u002fm\u002eIdAttr\u0020must\u0020be\u0020\u003c\u00202147483648\u0020(have\u0020\u0025v\u0029", path, _fffg.IdAttr)
	}
	if _fffg.ExtLst != nil {
		if _fbgb := _fffg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fbgb != nil {
			return _fbgb
		}
	}
	return nil
}
func (_fcffd ST_TLAnimateColorSpace) Validate() error { return _fcffd.ValidateWithPath("") }
func (_beda ST_TLAnimateEffectTransition) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_beda.String(), start)
}
func (_degca ST_PlaceholderSize) String() string {
	switch _degca {
	case 0:
		return ""
	case 1:
		return "full"
	case 2:
		return "half"
	case 3:
		return "quarter"
	}
	return ""
}
func (_gcbb *CT_TLTimeAnimateValueList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _gcbb.Tav != nil {
		_fbcff := _e.StartElement{Name: _e.Name{Local: "p:tav"}}
		for _, _ecffg := range _gcbb.Tav {
			e.EncodeElement(_ecffg, _fbcff)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_eggb *ST_TransitionEightDirectionType) Validate() error { return _eggb.ValidateWithPath("") }

// Validate validates the CmAuthorLst and its children
func (_dgec *CmAuthorLst) Validate() error { return _dgec.ValidateWithPath("CmAuthorLst") }
func (_gfgeb ST_TransitionCornerDirectionType) ValidateWithPath(path string) error {
	switch _gfgeb {
	case 0, 1, 2, 3, 4:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gfgeb))
	}
	return nil
}
func NewCT_GraphicalObjectFrameNonVisual() *CT_GraphicalObjectFrameNonVisual {
	_bcgbf := &CT_GraphicalObjectFrameNonVisual{}
	_bcgbf.CNvPr = _cb.NewCT_NonVisualDrawingProps()
	_bcgbf.CNvGraphicFramePr = _cb.NewCT_NonVisualGraphicFrameProperties()
	_bcgbf.NvPr = NewCT_ApplicationNonVisualDrawingProps()
	return _bcgbf
}

type CT_TLByHslColorTransform struct {

	// Hue
	HAttr int32

	// Saturation
	SAttr _cb.ST_FixedPercentage

	// Lightness
	LAttr _cb.ST_FixedPercentage
}

func (_fdgf *CT_ControlList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_bfb:
	for {
		_dag, _ggdg := d.Token()
		if _ggdg != nil {
			return _ggdg
		}
		switch _dfg := _dag.(type) {
		case _e.StartElement:
			switch _dfg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "control"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "control"}:
				_fgbd := NewCT_Control()
				if _baae := d.DecodeElement(_fgbd, &_dfg); _baae != nil {
					return _baae
				}
				_fdgf.Control = append(_fdgf.Control, _fgbd)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ControlList\u0020\u0025v", _dfg.Name)
				if _eee := d.Skip(); _eee != nil {
					return _eee
				}
			}
		case _e.EndElement:
			break _bfb
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the EG_SlideListChoice and its children, prefixing error messages with path
func (_egbce *EG_SlideListChoice) ValidateWithPath(path string) error {
	if _egbce.SldAll != nil {
		if _bgfca := _egbce.SldAll.ValidateWithPath(path + "\u002fSldAll"); _bgfca != nil {
			return _bgfca
		}
	}
	if _egbce.SldRg != nil {
		if _fgab := _egbce.SldRg.ValidateWithPath(path + "\u002fSldRg"); _fgab != nil {
			return _fgab
		}
	}
	if _egbce.CustShow != nil {
		if _cfeg := _egbce.CustShow.ValidateWithPath(path + "\u002fCustShow"); _cfeg != nil {
			return _cfeg
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SlideMasterIdList and its children, prefixing error messages with path
func (_gdea *CT_SlideMasterIdList) ValidateWithPath(path string) error {
	for _gcage, _edec := range _gdea.SldMasterId {
		if _eeaaa := _edec.ValidateWithPath(_c.Sprintf("\u0025s\u002fSldMasterId\u005b\u0025d\u005d", path, _gcage)); _eeaaa != nil {
			return _eeaaa
		}
	}
	return nil
}

// Validate validates the CT_EightDirectionTransition and its children
func (_bbdg *CT_EightDirectionTransition) Validate() error {
	return _bbdg.ValidateWithPath("CT_EightDirectionTransition")
}
func (_afad ST_WebScreenSize) Validate() error { return _afad.ValidateWithPath("") }

type CT_EmbeddedFontList struct {

	// Embedded Font
	EmbeddedFont []*CT_EmbeddedFontListEntry
}
type ST_TLOleChartBuildType byte

func (_adbfe *ST_TLTimeNodeSyncType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_eeed, _fbddg := d.Token()
	if _fbddg != nil {
		return _fbddg
	}
	if _ddfdf, _cebd := _eeed.(_e.EndElement); _cebd && _ddfdf.Name == start.Name {
		*_adbfe = 1
		return nil
	}
	if _gbacec, _aefbe := _eeed.(_e.CharData); !_aefbe {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eeed)
	} else {
		switch string(_gbacec) {
		case "":
			*_adbfe = 0
		case "canSlip":
			*_adbfe = 1
		case "locked":
			*_adbfe = 2
		}
	}
	_eeed, _fbddg = d.Token()
	if _fbddg != nil {
		return _fbddg
	}
	if _ecefa, _feegc := _eeed.(_e.EndElement); _feegc && _ecefa.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eeed)
}
func (_fdccg ST_TLTriggerRuntimeNode) ValidateWithPath(path string) error {
	switch _fdccg {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fdccg))
	}
	return nil
}

type ST_TLAnimateBehaviorValueType byte

// ValidateWithPath validates the CT_SlideViewProperties and its children, prefixing error messages with path
func (_gagbc *CT_SlideViewProperties) ValidateWithPath(path string) error {
	if _efbea := _gagbc.CSldViewPr.ValidateWithPath(path + "/CSldViewPr"); _efbea != nil {
		return _efbea
	}
	if _gagbc.ExtLst != nil {
		if _aggc := _gagbc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _aggc != nil {
			return _aggc
		}
	}
	return nil
}

// Validate validates the CT_SlideTransitionChoice and its children
func (_bebbe *CT_SlideTransitionChoice) Validate() error {
	return _bebbe.ValidateWithPath("CT_SlideTransitionChoice")
}
func (_bbgca *CT_TLOleChartTargetElement) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	_ccbfdg, _gdegd := _bbgca.TypeAttr.MarshalXMLAttr(_e.Name{Local: "type"})
	if _gdegd != nil {
		return _gdegd
	}
	start.Attr = append(start.Attr, _ccbfdg)
	if _bbgca.LvlAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "lvl"}, Value: _c.Sprintf("\u0025v", *_bbgca.LvlAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_NotesMasterIdList() *CT_NotesMasterIdList { _fded := &CT_NotesMasterIdList{}; return _fded }

// ValidateWithPath validates the CT_CustomShow and its children, prefixing error messages with path
func (_agad *CT_CustomShow) ValidateWithPath(path string) error {
	if _aff := _agad.SldLst.ValidateWithPath(path + "\u002fSldLst"); _aff != nil {
		return _aff
	}
	if _agad.ExtLst != nil {
		if _gfgc := _agad.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gfgc != nil {
			return _gfgc
		}
	}
	return nil
}
func NewEG_ExtensionList() *EG_ExtensionList { _fbaec := &EG_ExtensionList{}; return _fbaec }

const (
	ST_TransitionInOutDirectionTypeUnset ST_TransitionInOutDirectionType = 0
	ST_TransitionInOutDirectionTypeOut   ST_TransitionInOutDirectionType = 1
	ST_TransitionInOutDirectionTypeIn    ST_TransitionInOutDirectionType = 2
)

func (_gacg *Sld) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:sld"
	return _gacg.CT_Slide.MarshalXML(e, start)
}
func NewCT_ShowInfoKiosk() *CT_ShowInfoKiosk { _fcgag := &CT_ShowInfoKiosk{}; return _fcgag }
func (_bddb *CT_PresentationProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_ddde:
	for {
		_gdceg, _fabag := d.Token()
		if _fabag != nil {
			return _fabag
		}
		switch _dagb := _gdceg.(type) {
		case _e.StartElement:
			switch _dagb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "htmlPubPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "htmlPubPr"}:
				_bddb.HtmlPubPr = NewCT_HtmlPublishProperties()
				if _eedd := d.DecodeElement(_bddb.HtmlPubPr, &_dagb); _eedd != nil {
					return _eedd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "webPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "webPr"}:
				_bddb.WebPr = NewCT_WebProperties()
				if _dgbdg := d.DecodeElement(_bddb.WebPr, &_dagb); _dgbdg != nil {
					return _dgbdg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "prnPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "prnPr"}:
				_bddb.PrnPr = NewCT_PrintProperties()
				if _acead := d.DecodeElement(_bddb.PrnPr, &_dagb); _acead != nil {
					return _acead
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "showPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "showPr"}:
				_bddb.ShowPr = NewCT_ShowProperties()
				if _babb := d.DecodeElement(_bddb.ShowPr, &_dagb); _babb != nil {
					return _babb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMru"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMru"}:
				_bddb.ClrMru = _cb.NewCT_ColorMRU()
				if _bffc := d.DecodeElement(_bddb.ClrMru, &_dagb); _bffc != nil {
					return _bffc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_bddb.ExtLst = NewCT_ExtensionList()
				if _adac := d.DecodeElement(_bddb.ExtLst, &_dagb); _adac != nil {
					return _adac
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PresentationProperties\u0020\u0025v", _dagb.Name)
				if _cfda := d.Skip(); _cfda != nil {
					return _cfda
				}
			}
		case _e.EndElement:
			break _ddde
		case _e.CharData:
		}
	}
	return nil
}
func (_dadaed ST_TLTimeAnimateValueTime) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _dadaed.ST_PositiveFixedPercentage != nil {
		e.Encode(_dadaed.ST_PositiveFixedPercentage)
	}
	if _dadaed.ST_TLTimeIndefinite != ST_TLTimeIndefiniteUnset {
		e.EncodeToken(_e.CharData(_dadaed.ST_TLTimeIndefinite.String()))
	}
	return e.EncodeToken(_e.EndElement{Name: start.Name})
}
func NewCT_TLGraphicalObjectBuild() *CT_TLGraphicalObjectBuild {
	_gbcg := &CT_TLGraphicalObjectBuild{}
	return _gbcg
}
func (_gbfgb ST_TLDiagramBuildType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_gbfgb.String(), start)
}
func (_bgaca *CT_OutlineViewSlideEntry) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cdgcf := range start.Attr {
		if _cdgcf.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _cdgcf.Name.Local == "id" || _cdgcf.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _cdgcf.Name.Local == "id" {
			_dbfaf, _ceaa := _cdgcf.Value, error(nil)
			if _ceaa != nil {
				return _ceaa
			}
			_bgaca.IdAttr = _dbfaf
			continue
		}
		if _cdgcf.Name.Local == "collapse" {
			_cfee, _fgaa := _b.ParseBool(_cdgcf.Value)
			if _fgaa != nil {
				return _fgaa
			}
			_bgaca.CollapseAttr = &_cfee
			continue
		}
	}
	for {
		_eccg, _eeeed := d.Token()
		if _eeeed != nil {
			return _c.Errorf("parsing CT_OutlineViewSlideEntry:\u0020%s", _eeeed)
		}
		if _fddb, _bbfa := _eccg.(_e.EndElement); _bbfa && _fddb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ffbf *CT_ExtensionListModify) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _ebba := range start.Attr {
		if _ebba.Name.Local == "mod" {
			_bgbd, _bbcae := _b.ParseBool(_ebba.Value)
			if _bbcae != nil {
				return _bbcae
			}
			_ffbf.ModAttr = &_bgbd
			continue
		}
	}
_aagc:
	for {
		_afb, _afd := d.Token()
		if _afd != nil {
			return _afd
		}
		switch _abdc := _afb.(type) {
		case _e.StartElement:
			switch _abdc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "ext"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "ext"}:
				_fabf := NewCT_Extension()
				if _ebc := d.DecodeElement(_fabf, &_abdc); _ebc != nil {
					return _ebc
				}
				_ffbf.Ext = append(_ffbf.Ext, _fabf)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ExtensionListModify\u0020\u0025v", _abdc.Name)
				if _gfee := d.Skip(); _gfee != nil {
					return _gfee
				}
			}
		case _e.EndElement:
			break _aagc
		case _e.CharData:
		}
	}
	return nil
}
func (_aaec ST_TLPreviousActionType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_aaec.String(), start)
}
func (_eg *AG_Ole) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cba := range start.Attr {
		if _cba.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _cba.Name.Local == "id" {
			_ed, _gcc := _cba.Value, error(nil)
			if _gcc != nil {
				return _gcc
			}
			_eg.IdAttr = &_ed
			continue
		}
		if _cba.Name.Local == "spid" {
			_fbb, _ag := _cba.Value, error(nil)
			if _ag != nil {
				return _ag
			}
			_eg.SpidAttr = &_fbb
			continue
		}
		if _cba.Name.Local == "name" {
			_aa, _efe := _cba.Value, error(nil)
			if _efe != nil {
				return _efe
			}
			_eg.NameAttr = &_aa
			continue
		}
		if _cba.Name.Local == "showAsIcon" {
			_cc, _ea := _b.ParseBool(_cba.Value)
			if _ea != nil {
				return _ea
			}
			_eg.ShowAsIconAttr = &_cc
			continue
		}
		if _cba.Name.Local == "imgW" {
			_fbbc, _abg := _b.ParseInt(_cba.Value, 10, 32)
			if _abg != nil {
				return _abg
			}
			_ge := int32(_fbbc)
			_eg.ImgWAttr = &_ge
			continue
		}
		if _cba.Name.Local == "imgH" {
			_cg, _bb := _b.ParseInt(_cba.Value, 10, 32)
			if _bb != nil {
				return _bb
			}
			_efg := int32(_cg)
			_eg.ImgHAttr = &_efg
			continue
		}
	}
	for {
		_edg, _fd := d.Token()
		if _fd != nil {
			return _c.Errorf("parsing\u0020AG_Ole:\u0020\u0025s", _fd)
		}
		if _de, _dcb := _edg.(_e.EndElement); _dcb && _de.Name == start.Name {
			break
		}
	}
	return nil
}
func (_egfab *EG_SlideListChoice) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _egfab.SldAll != nil {
		_afbfe := _e.StartElement{Name: _e.Name{Local: "p:sldAll"}}
		e.EncodeElement(_egfab.SldAll, _afbfe)
	}
	if _egfab.SldRg != nil {
		_bacbc := _e.StartElement{Name: _e.Name{Local: "p:sldRg"}}
		e.EncodeElement(_egfab.SldRg, _bacbc)
	}
	if _egfab.CustShow != nil {
		_gffd := _e.StartElement{Name: _e.Name{Local: "p:custShow"}}
		e.EncodeElement(_egfab.CustShow, _gffd)
	}
	return nil
}

// Validate validates the CT_TLAnimateBehavior and its children
func (_agcc *CT_TLAnimateBehavior) Validate() error {
	return _agcc.ValidateWithPath("CT_TLAnimateBehavior")
}

type CT_Placeholder struct {

	// Placeholder Type
	TypeAttr ST_PlaceholderType

	// Placeholder Orientation
	OrientAttr ST_Direction

	// Placeholder Size
	SzAttr ST_PlaceholderSize

	// Placeholder Index
	IdxAttr *uint32

	// Placeholder has custom prompt
	HasCustomPromptAttr *bool
	ExtLst              *CT_ExtensionListModify
}

// ValidateWithPath validates the CmAuthorLst and its children, prefixing error messages with path
func (_dgggb *CmAuthorLst) ValidateWithPath(path string) error {
	if _cgaeb := _dgggb.CT_CommentAuthorList.ValidateWithPath(path); _cgaeb != nil {
		return _cgaeb
	}
	return nil
}

// Validate validates the CT_Presentation and its children
func (_fbbg *CT_Presentation) Validate() error { return _fbbg.ValidateWithPath("CT_Presentation") }
func (_ccgfa *CT_TLCommonTimeNodeData) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ccgfa.IdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "id"}, Value: _c.Sprintf("\u0025v", *_ccgfa.IdAttr)})
	}
	if _ccgfa.PresetIDAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "presetID"}, Value: _c.Sprintf("\u0025v", *_ccgfa.PresetIDAttr)})
	}
	if _ccgfa.PresetClassAttr != ST_TLTimeNodePresetClassTypeUnset {
		_ebcdg, _bfcd := _ccgfa.PresetClassAttr.MarshalXMLAttr(_e.Name{Local: "presetClass"})
		if _bfcd != nil {
			return _bfcd
		}
		start.Attr = append(start.Attr, _ebcdg)
	}
	if _ccgfa.PresetSubtypeAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "presetSubtype"}, Value: _c.Sprintf("\u0025v", *_ccgfa.PresetSubtypeAttr)})
	}
	if _ccgfa.DurAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "dur"}, Value: _c.Sprintf("\u0025v", *_ccgfa.DurAttr)})
	}
	if _ccgfa.RepeatCountAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "repeatCount"}, Value: _c.Sprintf("\u0025v", *_ccgfa.RepeatCountAttr)})
	}
	if _ccgfa.RepeatDurAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "repeatDur"}, Value: _c.Sprintf("\u0025v", *_ccgfa.RepeatDurAttr)})
	}
	if _ccgfa.SpdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spd"}, Value: _c.Sprintf("\u0025v", *_ccgfa.SpdAttr)})
	}
	if _ccgfa.AccelAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "accel"}, Value: _c.Sprintf("\u0025v", *_ccgfa.AccelAttr)})
	}
	if _ccgfa.DecelAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "decel"}, Value: _c.Sprintf("\u0025v", *_ccgfa.DecelAttr)})
	}
	if _ccgfa.AutoRevAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "autoRev"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ccgfa.AutoRevAttr))})
	}
	if _ccgfa.RestartAttr != ST_TLTimeNodeRestartTypeUnset {
		_efdb, _dccgb := _ccgfa.RestartAttr.MarshalXMLAttr(_e.Name{Local: "restart"})
		if _dccgb != nil {
			return _dccgb
		}
		start.Attr = append(start.Attr, _efdb)
	}
	if _ccgfa.FillAttr != ST_TLTimeNodeFillTypeUnset {
		_fcbe, _bffa := _ccgfa.FillAttr.MarshalXMLAttr(_e.Name{Local: "fill"})
		if _bffa != nil {
			return _bffa
		}
		start.Attr = append(start.Attr, _fcbe)
	}
	if _ccgfa.SyncBehaviorAttr != ST_TLTimeNodeSyncTypeUnset {
		_eagf, _ebed := _ccgfa.SyncBehaviorAttr.MarshalXMLAttr(_e.Name{Local: "syncBehavior"})
		if _ebed != nil {
			return _ebed
		}
		start.Attr = append(start.Attr, _eagf)
	}
	if _ccgfa.TmFilterAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "tmFilter"}, Value: _c.Sprintf("\u0025v", *_ccgfa.TmFilterAttr)})
	}
	if _ccgfa.EvtFilterAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "evtFilter"}, Value: _c.Sprintf("\u0025v", *_ccgfa.EvtFilterAttr)})
	}
	if _ccgfa.DisplayAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "display"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ccgfa.DisplayAttr))})
	}
	if _ccgfa.MasterRelAttr != ST_TLTimeNodeMasterRelationUnset {
		_dbab, _ccbda := _ccgfa.MasterRelAttr.MarshalXMLAttr(_e.Name{Local: "masterRel"})
		if _ccbda != nil {
			return _ccbda
		}
		start.Attr = append(start.Attr, _dbab)
	}
	if _ccgfa.BldLvlAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "bldLvl"}, Value: _c.Sprintf("\u0025v", *_ccgfa.BldLvlAttr)})
	}
	if _ccgfa.GrpIdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "grpId"}, Value: _c.Sprintf("\u0025v", *_ccgfa.GrpIdAttr)})
	}
	if _ccgfa.AfterEffectAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "afterEffect"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ccgfa.AfterEffectAttr))})
	}
	if _ccgfa.NodeTypeAttr != ST_TLTimeNodeTypeUnset {
		_ggfab, _baga := _ccgfa.NodeTypeAttr.MarshalXMLAttr(_e.Name{Local: "nodeType"})
		if _baga != nil {
			return _baga
		}
		start.Attr = append(start.Attr, _ggfab)
	}
	if _ccgfa.NodePhAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "nodePh"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ccgfa.NodePhAttr))})
	}
	e.EncodeToken(start)
	if _ccgfa.StCondLst != nil {
		_cged := _e.StartElement{Name: _e.Name{Local: "p:stCondLst"}}
		e.EncodeElement(_ccgfa.StCondLst, _cged)
	}
	if _ccgfa.EndCondLst != nil {
		_fcba := _e.StartElement{Name: _e.Name{Local: "p:endCondLst"}}
		e.EncodeElement(_ccgfa.EndCondLst, _fcba)
	}
	if _ccgfa.EndSync != nil {
		_bcdde := _e.StartElement{Name: _e.Name{Local: "p:endSync"}}
		e.EncodeElement(_ccgfa.EndSync, _bcdde)
	}
	if _ccgfa.Iterate != nil {
		_cace := _e.StartElement{Name: _e.Name{Local: "p:iterate"}}
		e.EncodeElement(_ccgfa.Iterate, _cace)
	}
	if _ccgfa.ChildTnLst != nil {
		_ccbfd := _e.StartElement{Name: _e.Name{Local: "p:childTnLst"}}
		e.EncodeElement(_ccgfa.ChildTnLst, _ccbfd)
	}
	if _ccgfa.SubTnLst != nil {
		_bggf := _e.StartElement{Name: _e.Name{Local: "p:subTnLst"}}
		e.EncodeElement(_ccgfa.SubTnLst, _bggf)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_gdbab ST_TLAnimateBehaviorCalcMode) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_gdbab.String(), start)
}
func (_ddd *CT_CommonSlideViewProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ddd.SnapToGridAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "snapToGrid"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ddd.SnapToGridAttr))})
	}
	if _ddd.SnapToObjectsAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "snapToObjects"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ddd.SnapToObjectsAttr))})
	}
	if _ddd.ShowGuidesAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showGuides"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ddd.ShowGuidesAttr))})
	}
	e.EncodeToken(start)
	_becag := _e.StartElement{Name: _e.Name{Local: "p:cViewPr"}}
	e.EncodeElement(_ddd.CViewPr, _becag)
	if _ddd.GuideLst != nil {
		_cda := _e.StartElement{Name: _e.Name{Local: "p:guideLst"}}
		e.EncodeElement(_ddd.GuideLst, _cda)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CmLst and its children
func (_gcff *CmLst) Validate() error { return _gcff.ValidateWithPath("CmLst") }

// ValidateWithPath validates the CT_SlideRelationshipList and its children, prefixing error messages with path
func (_cfbeb *CT_SlideRelationshipList) ValidateWithPath(path string) error {
	for _bafg, _ffdbe := range _cfbeb.Sld {
		if _dbfbe := _ffdbe.ValidateWithPath(_c.Sprintf("\u0025s\u002fSld\u005b\u0025d\u005d", path, _bafg)); _dbfbe != nil {
			return _dbfbe
		}
	}
	return nil
}

const (
	ST_TLOleChartBuildTypeUnset      ST_TLOleChartBuildType = 0
	ST_TLOleChartBuildTypeAllAtOnce  ST_TLOleChartBuildType = 1
	ST_TLOleChartBuildTypeSeries     ST_TLOleChartBuildType = 2
	ST_TLOleChartBuildTypeCategory   ST_TLOleChartBuildType = 3
	ST_TLOleChartBuildTypeSeriesEl   ST_TLOleChartBuildType = 4
	ST_TLOleChartBuildTypeCategoryEl ST_TLOleChartBuildType = 5
)

func (_ffabf *CT_OleObjectEmbed) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ffabf.FollowColorSchemeAttr != ST_OleObjectFollowColorSchemeUnset {
		_ddbg, _bcad := _ffabf.FollowColorSchemeAttr.MarshalXMLAttr(_e.Name{Local: "followColorScheme"})
		if _bcad != nil {
			return _bcad
		}
		start.Attr = append(start.Attr, _ddbg)
	}
	e.EncodeToken(start)
	if _ffabf.ExtLst != nil {
		_abdeg := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ffabf.ExtLst, _abdeg)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_EightDirectionTransition and its children, prefixing error messages with path
func (_efgc *CT_EightDirectionTransition) ValidateWithPath(path string) error {
	if _efgc.DirAttr != nil {
		if _dbbb := _efgc.DirAttr.ValidateWithPath(path + "\u002fDirAttr"); _dbbb != nil {
			return _dbbb
		}
	}
	return nil
}
func (_bffgd *ST_WebColorType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_aafcb, _ffbed := d.Token()
	if _ffbed != nil {
		return _ffbed
	}
	if _cbcba, _deaef := _aafcb.(_e.EndElement); _deaef && _cbcba.Name == start.Name {
		*_bffgd = 1
		return nil
	}
	if _dbef, _defb := _aafcb.(_e.CharData); !_defb {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _aafcb)
	} else {
		switch string(_dbef) {
		case "":
			*_bffgd = 0
		case "none":
			*_bffgd = 1
		case "browser":
			*_bffgd = 2
		case "presentationText":
			*_bffgd = 3
		case "presentationAccent":
			*_bffgd = 4
		case "whiteTextOnBlack":
			*_bffgd = 5
		case "blackTextOnWhite":
			*_bffgd = 6
		}
	}
	_aafcb, _ffbed = d.Token()
	if _ffbed != nil {
		return _ffbed
	}
	if _efgbf, _deffe := _aafcb.(_e.EndElement); _deffe && _efgbf.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _aafcb)
}
func (_aagce *CT_TimeNodeList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_gceff:
	for {
		_cffbe, _ebeee := d.Token()
		if _ebeee != nil {
			return _ebeee
		}
		switch _ecfa := _cffbe.(type) {
		case _e.StartElement:
			switch _ecfa.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "par"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "par"}:
				_agded := NewCT_TLTimeNodeParallel()
				if _cgdbg := d.DecodeElement(_agded, &_ecfa); _cgdbg != nil {
					return _cgdbg
				}
				_aagce.Par = append(_aagce.Par, _agded)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "seq"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "seq"}:
				_eefe := NewCT_TLTimeNodeSequence()
				if _ccacd := d.DecodeElement(_eefe, &_ecfa); _ccacd != nil {
					return _ccacd
				}
				_aagce.Seq = append(_aagce.Seq, _eefe)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "excl"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "excl"}:
				_eeefa := NewCT_TLTimeNodeExclusive()
				if _fceg := d.DecodeElement(_eeefa, &_ecfa); _fceg != nil {
					return _fceg
				}
				_aagce.Excl = append(_aagce.Excl, _eeefa)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "anim"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "anim"}:
				_edgbb := NewCT_TLAnimateBehavior()
				if _fbacf := d.DecodeElement(_edgbb, &_ecfa); _fbacf != nil {
					return _fbacf
				}
				_aagce.Anim = append(_aagce.Anim, _edgbb)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "animClr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "animClr"}:
				_cdcdb := NewCT_TLAnimateColorBehavior()
				if _edfg := d.DecodeElement(_cdcdb, &_ecfa); _edfg != nil {
					return _edfg
				}
				_aagce.AnimClr = append(_aagce.AnimClr, _cdcdb)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "animEffect"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "animEffect"}:
				_edgdd := NewCT_TLAnimateEffectBehavior()
				if _cdag := d.DecodeElement(_edgdd, &_ecfa); _cdag != nil {
					return _cdag
				}
				_aagce.AnimEffect = append(_aagce.AnimEffect, _edgdd)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "animMotion"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "animMotion"}:
				_gaecf := NewCT_TLAnimateMotionBehavior()
				if _gfad := d.DecodeElement(_gaecf, &_ecfa); _gfad != nil {
					return _gfad
				}
				_aagce.AnimMotion = append(_aagce.AnimMotion, _gaecf)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "animRot"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "animRot"}:
				_gfbe := NewCT_TLAnimateRotationBehavior()
				if _ccgbe := d.DecodeElement(_gfbe, &_ecfa); _ccgbe != nil {
					return _ccgbe
				}
				_aagce.AnimRot = append(_aagce.AnimRot, _gfbe)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "animScale"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "animScale"}:
				_gcccf := NewCT_TLAnimateScaleBehavior()
				if _bbcb := d.DecodeElement(_gcccf, &_ecfa); _bbcb != nil {
					return _bbcb
				}
				_aagce.AnimScale = append(_aagce.AnimScale, _gcccf)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cmd"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cmd"}:
				_ddgdbc := NewCT_TLCommandBehavior()
				if _efadba := d.DecodeElement(_ddgdbc, &_ecfa); _efadba != nil {
					return _efadba
				}
				_aagce.Cmd = append(_aagce.Cmd, _ddgdbc)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "set"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "set"}:
				_eace := NewCT_TLSetBehavior()
				if _aaef := d.DecodeElement(_eace, &_ecfa); _aaef != nil {
					return _aaef
				}
				_aagce.Set = append(_aagce.Set, _eace)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "audio"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "audio"}:
				_bdbab := NewCT_TLMediaNodeAudio()
				if _dgeef := d.DecodeElement(_bdbab, &_ecfa); _dgeef != nil {
					return _dgeef
				}
				_aagce.Audio = append(_aagce.Audio, _bdbab)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "video"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "video"}:
				_babede := NewCT_TLMediaNodeVideo()
				if _abbff := d.DecodeElement(_babede, &_ecfa); _abbff != nil {
					return _abbff
				}
				_aagce.Video = append(_aagce.Video, _babede)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TimeNodeList\u0020\u0025v", _ecfa.Name)
				if _bfca := d.Skip(); _bfca != nil {
					return _bfca
				}
			}
		case _e.EndElement:
			break _gceff
		case _e.CharData:
		}
	}
	return nil
}
func (_dggecd *ST_TransitionSpeed) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dfcfb, _cafdg := d.Token()
	if _cafdg != nil {
		return _cafdg
	}
	if _cbadg, _gfba := _dfcfb.(_e.EndElement); _gfba && _cbadg.Name == start.Name {
		*_dggecd = 1
		return nil
	}
	if _gbcad, _aeafc := _dfcfb.(_e.CharData); !_aeafc {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dfcfb)
	} else {
		switch string(_gbcad) {
		case "":
			*_dggecd = 0
		case "slow":
			*_dggecd = 1
		case "med":
			*_dggecd = 2
		case "fast":
			*_dggecd = 3
		}
	}
	_dfcfb, _cafdg = d.Token()
	if _cafdg != nil {
		return _cafdg
	}
	if _afeea, _bbdfd := _dfcfb.(_e.EndElement); _bbdfd && _afeea.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dfcfb)
}
func (_fefgg *EG_ShowType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _fefgg.Present != nil {
		_debg := _e.StartElement{Name: _e.Name{Local: "p:present"}}
		e.EncodeElement(_fefgg.Present, _debg)
	}
	if _fefgg.Browse != nil {
		_ecbgd := _e.StartElement{Name: _e.Name{Local: "p:browse"}}
		e.EncodeElement(_fefgg.Browse, _ecbgd)
	}
	if _fefgg.Kiosk != nil {
		_dcddb := _e.StartElement{Name: _e.Name{Local: "p:kiosk"}}
		e.EncodeElement(_fefgg.Kiosk, _dcddb)
	}
	return nil
}
func (_dfdda *CT_TLAnimateEffectBehavior) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dfdda.CBhvr = NewCT_TLCommonBehaviorData()
	for _, _dfbfg := range start.Attr {
		if _dfbfg.Name.Local == "transition" {
			_dfdda.TransitionAttr.UnmarshalXMLAttr(_dfbfg)
			continue
		}
		if _dfbfg.Name.Local == "filter" {
			_bfeac, _egefe := _dfbfg.Value, error(nil)
			if _egefe != nil {
				return _egefe
			}
			_dfdda.FilterAttr = &_bfeac
			continue
		}
		if _dfbfg.Name.Local == "prLst" {
			_bdgdec, _ebfb := _dfbfg.Value, error(nil)
			if _ebfb != nil {
				return _ebfb
			}
			_dfdda.PrLstAttr = &_bdgdec
			continue
		}
	}
_geca:
	for {
		_cdfff, _cefg := d.Token()
		if _cefg != nil {
			return _cefg
		}
		switch _degdd := _cdfff.(type) {
		case _e.StartElement:
			switch _degdd.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cBhvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cBhvr"}:
				if _dffgb := d.DecodeElement(_dfdda.CBhvr, &_degdd); _dffgb != nil {
					return _dffgb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "progress"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "progress"}:
				_dfdda.Progress = NewCT_TLAnimVariant()
				if _fcafb := d.DecodeElement(_dfdda.Progress, &_degdd); _fcafb != nil {
					return _fcafb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLAnimateEffectBehavior\u0020\u0025v", _degdd.Name)
				if _ecdf := d.Skip(); _ecdf != nil {
					return _ecdf
				}
			}
		case _e.EndElement:
			break _geca
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_CommonViewProperties and its children
func (_fbd *CT_CommonViewProperties) Validate() error {
	return _fbd.ValidateWithPath("CT_CommonViewProperties")
}
func (_abda *CT_CustomerData) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _abda.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the SldMaster and its children, prefixing error messages with path
func (_ffcac *SldMaster) ValidateWithPath(path string) error {
	if _beaf := _ffcac.CT_SlideMaster.ValidateWithPath(path); _beaf != nil {
		return _beaf
	}
	return nil
}

// Validate validates the CT_ShapeNonVisual and its children
func (_baebc *CT_ShapeNonVisual) Validate() error {
	return _baebc.ValidateWithPath("CT_ShapeNonVisual")
}
func NewCmLst() *CmLst { _cbec := &CmLst{}; _cbec.CT_CommentList = *NewCT_CommentList(); return _cbec }

// Validate validates the CT_SlideMasterTextStyles and its children
func (_eaea *CT_SlideMasterTextStyles) Validate() error {
	return _eaea.ValidateWithPath("CT_SlideMasterTextStyles")
}

// ValidateWithPath validates the CT_TransitionStartSoundAction and its children, prefixing error messages with path
func (_cagdd *CT_TransitionStartSoundAction) ValidateWithPath(path string) error {
	if _daff := _cagdd.Snd.ValidateWithPath(path + "\u002fSnd"); _daff != nil {
		return _daff
	}
	return nil
}
func (_bded *CT_OleObjectChoice) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _bded.Embed != nil {
		_eded := _e.StartElement{Name: _e.Name{Local: "p:embed"}}
		e.EncodeElement(_bded.Embed, _eded)
	}
	if _bded.Link != nil {
		_gdcbd := _e.StartElement{Name: _e.Name{Local: "p:link"}}
		e.EncodeElement(_bded.Link, _gdcbd)
	}
	return nil
}
func ParseUnionST_Percentage(s string) (_cb.ST_Percentage, error) {
	return _cb.ParseUnionST_Percentage(s)
}
func (_cfdg *CT_SlideTransitionChoice) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _cfdg.Blinds != nil {
		_aeba := _e.StartElement{Name: _e.Name{Local: "p:blinds"}}
		e.EncodeElement(_cfdg.Blinds, _aeba)
	}
	if _cfdg.Checker != nil {
		_gegbc := _e.StartElement{Name: _e.Name{Local: "p:checker"}}
		e.EncodeElement(_cfdg.Checker, _gegbc)
	}
	if _cfdg.Circle != nil {
		_geddb := _e.StartElement{Name: _e.Name{Local: "p:circle"}}
		e.EncodeElement(_cfdg.Circle, _geddb)
	}
	if _cfdg.Dissolve != nil {
		_bgacg := _e.StartElement{Name: _e.Name{Local: "p:dissolve"}}
		e.EncodeElement(_cfdg.Dissolve, _bgacg)
	}
	if _cfdg.Comb != nil {
		_bdgfd := _e.StartElement{Name: _e.Name{Local: "p:comb"}}
		e.EncodeElement(_cfdg.Comb, _bdgfd)
	}
	if _cfdg.Cover != nil {
		_afefc := _e.StartElement{Name: _e.Name{Local: "p:cover"}}
		e.EncodeElement(_cfdg.Cover, _afefc)
	}
	if _cfdg.Cut != nil {
		_bbdc := _e.StartElement{Name: _e.Name{Local: "p:cut"}}
		e.EncodeElement(_cfdg.Cut, _bbdc)
	}
	if _cfdg.Diamond != nil {
		_gafbd := _e.StartElement{Name: _e.Name{Local: "p:diamond"}}
		e.EncodeElement(_cfdg.Diamond, _gafbd)
	}
	if _cfdg.Fade != nil {
		_dadc := _e.StartElement{Name: _e.Name{Local: "p:fade"}}
		e.EncodeElement(_cfdg.Fade, _dadc)
	}
	if _cfdg.Newsflash != nil {
		_fefeb := _e.StartElement{Name: _e.Name{Local: "p:newsflash"}}
		e.EncodeElement(_cfdg.Newsflash, _fefeb)
	}
	if _cfdg.Plus != nil {
		_bgefg := _e.StartElement{Name: _e.Name{Local: "p:plus"}}
		e.EncodeElement(_cfdg.Plus, _bgefg)
	}
	if _cfdg.Pull != nil {
		_dcbfc := _e.StartElement{Name: _e.Name{Local: "p:pull"}}
		e.EncodeElement(_cfdg.Pull, _dcbfc)
	}
	if _cfdg.Push != nil {
		_gddc := _e.StartElement{Name: _e.Name{Local: "p:push"}}
		e.EncodeElement(_cfdg.Push, _gddc)
	}
	if _cfdg.Random != nil {
		_cfgg := _e.StartElement{Name: _e.Name{Local: "p:random"}}
		e.EncodeElement(_cfdg.Random, _cfgg)
	}
	if _cfdg.RandomBar != nil {
		_cadb := _e.StartElement{Name: _e.Name{Local: "p:randomBar"}}
		e.EncodeElement(_cfdg.RandomBar, _cadb)
	}
	if _cfdg.Split != nil {
		_cgffb := _e.StartElement{Name: _e.Name{Local: "p:split"}}
		e.EncodeElement(_cfdg.Split, _cgffb)
	}
	if _cfdg.Strips != nil {
		_bcfaf := _e.StartElement{Name: _e.Name{Local: "p:strips"}}
		e.EncodeElement(_cfdg.Strips, _bcfaf)
	}
	if _cfdg.Wedge != nil {
		_dbcfe := _e.StartElement{Name: _e.Name{Local: "p:wedge"}}
		e.EncodeElement(_cfdg.Wedge, _dbcfe)
	}
	if _cfdg.Wheel != nil {
		_bcdaa := _e.StartElement{Name: _e.Name{Local: "p:wheel"}}
		e.EncodeElement(_cfdg.Wheel, _bcdaa)
	}
	if _cfdg.Wipe != nil {
		_addf := _e.StartElement{Name: _e.Name{Local: "p:wipe"}}
		e.EncodeElement(_cfdg.Wipe, _addf)
	}
	if _cfdg.Zoom != nil {
		_adfd := _e.StartElement{Name: _e.Name{Local: "p:zoom"}}
		e.EncodeElement(_cfdg.Zoom, _adfd)
	}
	return nil
}

// Validate validates the CT_TLIterateData and its children
func (_dgbaf *CT_TLIterateData) Validate() error { return _dgbaf.ValidateWithPath("CT_TLIterateData") }
func (_adae ST_TransitionSideDirectionType) String() string {
	switch _adae {
	case 0:
		return ""
	case 1:
		return "l"
	case 2:
		return "u"
	case 3:
		return "r"
	case 4:
		return "d"
	}
	return ""
}
func (_bddbc *EG_ExtensionList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_dfge:
	for {
		_cffgc, _ecgf := d.Token()
		if _ecgf != nil {
			return _ecgf
		}
		switch _deaab := _cffgc.(type) {
		case _e.StartElement:
			switch _deaab.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "ext"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "ext"}:
				_cafec := NewCT_Extension()
				if _cgfgb := d.DecodeElement(_cafec, &_deaab); _cgfgb != nil {
					return _cgfgb
				}
				_bddbc.Ext = append(_bddbc.Ext, _cafec)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_ExtensionList\u0020\u0025v", _deaab.Name)
				if _cfebf := d.Skip(); _cfebf != nil {
					return _cfebf
				}
			}
		case _e.EndElement:
			break _dfge
		case _e.CharData:
		}
	}
	return nil
}
func NewCT_GroupShape() *CT_GroupShape {
	_cebg := &CT_GroupShape{}
	_cebg.NvGrpSpPr = NewCT_GroupShapeNonVisual()
	_cebg.GrpSpPr = _cb.NewCT_GroupShapeProperties()
	return _cebg
}
func NewCT_Extension() *CT_Extension { _geggf := &CT_Extension{}; return _geggf }
func (_dffb ST_TLChartSubelementType) String() string {
	switch _dffb {
	case 0:
		return ""
	case 1:
		return "gridLegend"
	case 2:
		return "series"
	case 3:
		return "category"
	case 4:
		return "ptInSeries"
	case 5:
		return "ptInCategory"
	}
	return ""
}
func (_fgbeb *CT_SlideMasterTextStyles) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _fgbeb.TitleStyle != nil {
		_ecfe := _e.StartElement{Name: _e.Name{Local: "p:titleStyle"}}
		e.EncodeElement(_fgbeb.TitleStyle, _ecfe)
	}
	if _fgbeb.BodyStyle != nil {
		_gdecc := _e.StartElement{Name: _e.Name{Local: "p:bodyStyle"}}
		e.EncodeElement(_fgbeb.BodyStyle, _gdecc)
	}
	if _fgbeb.OtherStyle != nil {
		_bdac := _e.StartElement{Name: _e.Name{Local: "p:otherStyle"}}
		e.EncodeElement(_fgbeb.OtherStyle, _bdac)
	}
	if _fgbeb.ExtLst != nil {
		_egcb := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_fgbeb.ExtLst, _egcb)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_cfgec ST_TLTimeNodeType) Validate() error { return _cfgec.ValidateWithPath("") }

const (
	ST_TransitionSideDirectionTypeUnset ST_TransitionSideDirectionType = 0
	ST_TransitionSideDirectionTypeL     ST_TransitionSideDirectionType = 1
	ST_TransitionSideDirectionTypeU     ST_TransitionSideDirectionType = 2
	ST_TransitionSideDirectionTypeR     ST_TransitionSideDirectionType = 3
	ST_TransitionSideDirectionTypeD     ST_TransitionSideDirectionType = 4
)

func (_gbeb *CT_NotesMasterIdList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_fdddf:
	for {
		_faae, _feeee := d.Token()
		if _feeee != nil {
			return _feeee
		}
		switch _eddg := _faae.(type) {
		case _e.StartElement:
			switch _eddg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "notesMasterId"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "notesMasterId"}:
				_gbeb.NotesMasterId = NewCT_NotesMasterIdListEntry()
				if _afcb := d.DecodeElement(_gbeb.NotesMasterId, &_eddg); _afcb != nil {
					return _afcb
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_NotesMasterIdList\u0020\u0025v", _eddg.Name)
				if _abdg := d.Skip(); _abdg != nil {
					return _abdg
				}
			}
		case _e.EndElement:
			break _fdddf
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SlideRelationshipListEntry and its children, prefixing error messages with path
func (_ddebg *CT_SlideRelationshipListEntry) ValidateWithPath(path string) error { return nil }
func (_bbag ST_ViewType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_bbag.String(), start)
}

// Validate validates the CT_Picture and its children
func (_cdge *CT_Picture) Validate() error { return _cdge.ValidateWithPath("CT_Picture") }

const (
	ST_TLTimeNodeSyncTypeUnset   ST_TLTimeNodeSyncType = 0
	ST_TLTimeNodeSyncTypeCanSlip ST_TLTimeNodeSyncType = 1
	ST_TLTimeNodeSyncTypeLocked  ST_TLTimeNodeSyncType = 2
)

func (_befad ST_TLTriggerRuntimeNode) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_befad.String(), start)
}
func (_aged *CT_HeaderFooter) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cddd := range start.Attr {
		if _cddd.Name.Local == "sldNum" {
			_fcge, _bcac := _b.ParseBool(_cddd.Value)
			if _bcac != nil {
				return _bcac
			}
			_aged.SldNumAttr = &_fcge
			continue
		}
		if _cddd.Name.Local == "hdr" {
			_bfdg, _gfag := _b.ParseBool(_cddd.Value)
			if _gfag != nil {
				return _gfag
			}
			_aged.HdrAttr = &_bfdg
			continue
		}
		if _cddd.Name.Local == "ftr" {
			_ggae, _gcag := _b.ParseBool(_cddd.Value)
			if _gcag != nil {
				return _gcag
			}
			_aged.FtrAttr = &_ggae
			continue
		}
		if _cddd.Name.Local == "dt" {
			_adfe, _ggga := _b.ParseBool(_cddd.Value)
			if _ggga != nil {
				return _ggga
			}
			_aged.DtAttr = &_adfe
			continue
		}
	}
_bcce:
	for {
		_fdab, _cadc := d.Token()
		if _cadc != nil {
			return _cadc
		}
		switch _dffa := _fdab.(type) {
		case _e.StartElement:
			switch _dffa.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_aged.ExtLst = NewCT_ExtensionListModify()
				if _cdab := d.DecodeElement(_aged.ExtLst, &_dffa); _cdab != nil {
					return _cdab
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_HeaderFooter\u0020\u0025v", _dffa.Name)
				if _aafc := d.Skip(); _aafc != nil {
					return _aafc
				}
			}
		case _e.EndElement:
			break _bcce
		case _e.CharData:
		}
	}
	return nil
}

type ST_SlideSizeType byte

func NewCT_TLMediaNodeVideo() *CT_TLMediaNodeVideo {
	_fdeb := &CT_TLMediaNodeVideo{}
	_fdeb.CMediaNode = NewCT_TLCommonMediaNodeData()
	return _fdeb
}

// ValidateWithPath validates the CmLst and its children, prefixing error messages with path
func (_gebbg *CmLst) ValidateWithPath(path string) error {
	if _dcfb := _gebbg.CT_CommentList.ValidateWithPath(path); _dcfb != nil {
		return _dcfb
	}
	return nil
}

// Validate validates the CT_CustomShowList and its children
func (_agd *CT_CustomShowList) Validate() error { return _agd.ValidateWithPath("CT_CustomShowList") }
func (_dbcce ST_TLAnimateMotionBehaviorOrigin) String() string {
	switch _dbcce {
	case 0:
		return ""
	case 1:
		return "parent"
	case 2:
		return "layout"
	}
	return ""
}

// ValidateWithPath validates the CT_PrintProperties and its children, prefixing error messages with path
func (_fbdee *CT_PrintProperties) ValidateWithPath(path string) error {
	if _ddfad := _fbdee.PrnWhatAttr.ValidateWithPath(path + "\u002fPrnWhatAttr"); _ddfad != nil {
		return _ddfad
	}
	if _fcebe := _fbdee.ClrModeAttr.ValidateWithPath(path + "\u002fClrModeAttr"); _fcebe != nil {
		return _fcebe
	}
	if _fbdee.ExtLst != nil {
		if _eebc := _fbdee.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eebc != nil {
			return _eebc
		}
	}
	return nil
}

type ST_PhotoAlbumFrameShape byte
type ST_TLTimeNodeSyncType byte
type CT_StringTag struct {

	// Name
	NameAttr string

	// Value
	ValAttr string
}
type CT_ShapeNonVisual struct {

	// Non-Visual Drawing Properties
	CNvPr *_cb.CT_NonVisualDrawingProps

	// Non-Visual Drawing Properties for a Shape
	CNvSpPr *_cb.CT_NonVisualDrawingShapeProps

	// Application Non-Visual Drawing Properties
	NvPr *CT_ApplicationNonVisualDrawingProps
}

func NewCT_HandoutMaster() *CT_HandoutMaster {
	_dfbe := &CT_HandoutMaster{}
	_dfbe.CSld = NewCT_CommonSlideData()
	_dfbe.ClrMap = _cb.NewCT_ColorMapping()
	return _dfbe
}
func (_cdafc *CT_NotesSlide) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cdafc.CSld = NewCT_CommonSlideData()
	for _, _efcbc := range start.Attr {
		if _efcbc.Name.Local == "showMasterSp" {
			_dgbfd, _daafe := _b.ParseBool(_efcbc.Value)
			if _daafe != nil {
				return _daafe
			}
			_cdafc.ShowMasterSpAttr = &_dgbfd
			continue
		}
		if _efcbc.Name.Local == "showMasterPhAnim" {
			_gaad, _fabc := _b.ParseBool(_efcbc.Value)
			if _fabc != nil {
				return _fabc
			}
			_cdafc.ShowMasterPhAnimAttr = &_gaad
			continue
		}
	}
_eafd:
	for {
		_ebac, _fbda := d.Token()
		if _fbda != nil {
			return _fbda
		}
		switch _egaf := _ebac.(type) {
		case _e.StartElement:
			switch _egaf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _abeeb := d.DecodeElement(_cdafc.CSld, &_egaf); _abeeb != nil {
					return _abeeb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMapOvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMapOvr"}:
				_cdafc.ClrMapOvr = _cb.NewCT_ColorMappingOverride()
				if _decf := d.DecodeElement(_cdafc.ClrMapOvr, &_egaf); _decf != nil {
					return _decf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_cdafc.ExtLst = NewCT_ExtensionListModify()
				if _fafd := d.DecodeElement(_cdafc.ExtLst, &_egaf); _fafd != nil {
					return _fafd
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_NotesSlide \u0025v", _egaf.Name)
				if _fcedf := d.Skip(); _fcedf != nil {
					return _fcedf
				}
			}
		case _e.EndElement:
			break _eafd
		case _e.CharData:
		}
	}
	return nil
}

type ST_TLTimeNodeRestartType byte

func (_bgfd *ST_SplitterBarState) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_bgfd = 0
	case "minimized":
		*_bgfd = 1
	case "restored":
		*_bgfd = 2
	case "maximized":
		*_bgfd = 3
	}
	return nil
}

// ValidateWithPath validates the CT_IndexRange and its children, prefixing error messages with path
func (_fcdf *CT_IndexRange) ValidateWithPath(path string) error { return nil }
func NewCT_TLBuildParagraph() *CT_TLBuildParagraph              { _ebebf := &CT_TLBuildParagraph{}; return _ebebf }
func (_acbef *ST_TLTimeNodeFillType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_eeaeb, _abccb := d.Token()
	if _abccb != nil {
		return _abccb
	}
	if _abccf, _dfede := _eeaeb.(_e.EndElement); _dfede && _abccf.Name == start.Name {
		*_acbef = 1
		return nil
	}
	if _gdefa, _agbga := _eeaeb.(_e.CharData); !_agbga {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eeaeb)
	} else {
		switch string(_gdefa) {
		case "":
			*_acbef = 0
		case "remove":
			*_acbef = 1
		case "freeze":
			*_acbef = 2
		case "hold":
			*_acbef = 3
		case "transition":
			*_acbef = 4
		}
	}
	_eeaeb, _abccb = d.Token()
	if _abccb != nil {
		return _abccb
	}
	if _acedg, _bgacb := _eeaeb.(_e.EndElement); _bgacb && _acedg.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eeaeb)
}

type CT_PictureNonVisual struct {
	CNvPr *_cb.CT_NonVisualDrawingProps

	// Non-Visual Picture Drawing Properties
	CNvPicPr *_cb.CT_NonVisualPictureProperties
	NvPr     *CT_ApplicationNonVisualDrawingProps
}

func (_aaaba *ST_Direction) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_aaaba = 0
	case "horz":
		*_aaaba = 1
	case "vert":
		*_aaaba = 2
	}
	return nil
}

// Validate validates the CT_PictureNonVisual and its children
func (_bfdec *CT_PictureNonVisual) Validate() error {
	return _bfdec.ValidateWithPath("CT_PictureNonVisual")
}
func (_bfgb ST_IterateType) String() string {
	switch _bfgb {
	case 0:
		return ""
	case 1:
		return "el"
	case 2:
		return "wd"
	case 3:
		return "lt"
	}
	return ""
}
func (_addfd ST_TLAnimateMotionBehaviorOrigin) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_fdgcd := _e.Attr{}
	_fdgcd.Name = name
	switch _addfd {
	case ST_TLAnimateMotionBehaviorOriginUnset:
		_fdgcd.Value = ""
	case ST_TLAnimateMotionBehaviorOriginParent:
		_fdgcd.Value = "parent"
	case ST_TLAnimateMotionBehaviorOriginLayout:
		_fdgcd.Value = "layout"
	}
	return _fdgcd, nil
}
func (_cefffa *CT_GuideList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_aebd:
	for {
		_bee, _fcfe := d.Token()
		if _fcfe != nil {
			return _fcfe
		}
		switch _edff := _bee.(type) {
		case _e.StartElement:
			switch _edff.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "guide"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "guide"}:
				_bbe := NewCT_Guide()
				if _fede := d.DecodeElement(_bbe, &_edff); _fede != nil {
					return _fede
				}
				_cefffa.Guide = append(_cefffa.Guide, _bbe)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GuideList\u0020\u0025v", _edff.Name)
				if _edfea := d.Skip(); _edfea != nil {
					return _edfea
				}
			}
		case _e.EndElement:
			break _aebd
		case _e.CharData:
		}
	}
	return nil
}

type ST_ViewType byte

func (_gadaa ST_TLTime) String() string {
	if _gadaa.Uint32 != nil {
		return _c.Sprintf("\u0025v", *_gadaa.Uint32)
	}
	if _gadaa.ST_TLTimeIndefinite != ST_TLTimeIndefiniteUnset {
		return _gadaa.ST_TLTimeIndefinite.String()
	}
	return ""
}

// ValidateWithPath validates the CT_TLBuildDiagram and its children, prefixing error messages with path
func (_gddff *CT_TLBuildDiagram) ValidateWithPath(path string) error {
	if _abgg := _gddff.BldAttr.ValidateWithPath(path + "\u002fBldAttr"); _abgg != nil {
		return _abgg
	}
	return nil
}
func (_abedb *CT_TLTimeAnimateValue) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _abedb.TmAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "tm"}, Value: _c.Sprintf("\u0025v", *_abedb.TmAttr)})
	}
	if _abedb.FmlaAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "fmla"}, Value: _c.Sprintf("\u0025v", *_abedb.FmlaAttr)})
	}
	e.EncodeToken(start)
	if _abedb.Val != nil {
		_ceeced := _e.StartElement{Name: _e.Name{Local: "p:val"}}
		e.EncodeElement(_abedb.Val, _ceeced)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_SlideSyncProperties struct {

	// Server's Slide File ID
	ServerSldIdAttr string

	// Server's Slide File's modification date/time
	ServerSldModifiedTimeAttr _fb.Time

	// Client Slide Insertion date/time
	ClientInsertedTimeAttr _fb.Time
	ExtLst                 *CT_ExtensionList
}

func (_dcca *ST_TLAnimateBehaviorCalcMode) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_dcca = 0
	case "discrete":
		*_dcca = 1
	case "lin":
		*_dcca = 2
	case "fmla":
		*_dcca = 3
	}
	return nil
}
func (_abfdg ST_PlaceholderType) Validate() error { return _abfdg.ValidateWithPath("") }
func (_gafed *CT_NotesMaster) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gafed.CSld = NewCT_CommonSlideData()
	_gafed.ClrMap = _cb.NewCT_ColorMapping()
_bced:
	for {
		_fgga, _bcdb := d.Token()
		if _bcdb != nil {
			return _bcdb
		}
		switch _becb := _fgga.(type) {
		case _e.StartElement:
			switch _becb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _afcg := d.DecodeElement(_gafed.CSld, &_becb); _afcg != nil {
					return _afcg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMap"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMap"}:
				if _bbfd := d.DecodeElement(_gafed.ClrMap, &_becb); _bbfd != nil {
					return _bbfd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "hf"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "hf"}:
				_gafed.Hf = NewCT_HeaderFooter()
				if _ebec := d.DecodeElement(_gafed.Hf, &_becb); _ebec != nil {
					return _ebec
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "notesStyle"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "notesStyle"}:
				_gafed.NotesStyle = _cb.NewCT_TextListStyle()
				if _dfaf := d.DecodeElement(_gafed.NotesStyle, &_becb); _dfaf != nil {
					return _dfaf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_gafed.ExtLst = NewCT_ExtensionListModify()
				if _bcead := d.DecodeElement(_gafed.ExtLst, &_becb); _bcead != nil {
					return _bcead
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_NotesMaster\u0020\u0025v", _becb.Name)
				if _afbge := d.Skip(); _afbge != nil {
					return _afbge
				}
			}
		case _e.EndElement:
			break _bced
		case _e.CharData:
		}
	}
	return nil
}
func (_fecf *CT_TLAnimateColorBehavior) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fecf.CBhvr = NewCT_TLCommonBehaviorData()
	for _, _dggfb := range start.Attr {
		if _dggfb.Name.Local == "clrSpc" {
			_fecf.ClrSpcAttr.UnmarshalXMLAttr(_dggfb)
			continue
		}
		if _dggfb.Name.Local == "dir" {
			_fecf.DirAttr.UnmarshalXMLAttr(_dggfb)
			continue
		}
	}
_dcgd:
	for {
		_agcd, _bace := d.Token()
		if _bace != nil {
			return _bace
		}
		switch _afga := _agcd.(type) {
		case _e.StartElement:
			switch _afga.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cBhvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cBhvr"}:
				if _dfgff := d.DecodeElement(_fecf.CBhvr, &_afga); _dfgff != nil {
					return _dfgff
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "by"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "by"}:
				_fecf.By = NewCT_TLByAnimateColorTransform()
				if _bage := d.DecodeElement(_fecf.By, &_afga); _bage != nil {
					return _bage
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "from"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "from"}:
				_fecf.From = _cb.NewCT_Color()
				if _eaaeb := d.DecodeElement(_fecf.From, &_afga); _eaaeb != nil {
					return _eaaeb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "to"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "to"}:
				_fecf.To = _cb.NewCT_Color()
				if _daaba := d.DecodeElement(_fecf.To, &_afga); _daaba != nil {
					return _daaba
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLAnimateColorBehavior\u0020\u0025v", _afga.Name)
				if _edbb := d.Skip(); _edbb != nil {
					return _edbb
				}
			}
		case _e.EndElement:
			break _dcgd
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_OleObjectLink and its children, prefixing error messages with path
func (_caad *CT_OleObjectLink) ValidateWithPath(path string) error {
	if _caad.ExtLst != nil {
		if _cbfa := _caad.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cbfa != nil {
			return _cbfa
		}
	}
	return nil
}

// ValidateWithPath validates the CT_GuideList and its children, prefixing error messages with path
func (_bggc *CT_GuideList) ValidateWithPath(path string) error {
	for _gdc, _gfeb := range _bggc.Guide {
		if _gcdgb := _gfeb.ValidateWithPath(_c.Sprintf("\u0025s\u002fGuide\u005b\u0025d\u005d", path, _gdc)); _gcdgb != nil {
			return _gcdgb
		}
	}
	return nil
}
func NewCT_HandoutMasterIdListEntry() *CT_HandoutMasterIdListEntry {
	_cad := &CT_HandoutMasterIdListEntry{}
	return _cad
}
func (_daadcd ST_Direction) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_edbaga := _e.Attr{}
	_edbaga.Name = name
	switch _daadcd {
	case ST_DirectionUnset:
		_edbaga.Value = ""
	case ST_DirectionHorz:
		_edbaga.Value = "horz"
	case ST_DirectionVert:
		_edbaga.Value = "vert"
	}
	return _edbaga, nil
}
func NewCT_OleObjectLink() *CT_OleObjectLink { _bbdac := &CT_OleObjectLink{}; return _bbdac }
func (_bggaa *ST_TLAnimateEffectTransition) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fdeg, _gcbbe := d.Token()
	if _gcbbe != nil {
		return _gcbbe
	}
	if _dedb, _ecbdc := _fdeg.(_e.EndElement); _ecbdc && _dedb.Name == start.Name {
		*_bggaa = 1
		return nil
	}
	if _fafbb, _cabae := _fdeg.(_e.CharData); !_cabae {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fdeg)
	} else {
		switch string(_fafbb) {
		case "":
			*_bggaa = 0
		case "in":
			*_bggaa = 1
		case "out":
			*_bggaa = 2
		case "none":
			*_bggaa = 3
		}
	}
	_fdeg, _gcbbe = d.Token()
	if _gcbbe != nil {
		return _gcbbe
	}
	if _dafagd, _dbcfc := _fdeg.(_e.EndElement); _dbcfc && _dafagd.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fdeg)
}
func (_bgde *CT_TLTimeNodeExclusive) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_ebeec := _e.StartElement{Name: _e.Name{Local: "p:cTn"}}
	e.EncodeElement(_bgde.CTn, _ebeec)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

const (
	ST_TLTimeIndefiniteUnset      ST_TLTimeIndefinite = 0
	ST_TLTimeIndefiniteIndefinite ST_TLTimeIndefinite = 1
)

// ValidateWithPath validates the TagLst and its children, prefixing error messages with path
func (_bacgb *TagLst) ValidateWithPath(path string) error {
	if _eecggb := _bacgb.CT_TagList.ValidateWithPath(path); _eecggb != nil {
		return _eecggb
	}
	return nil
}

// ValidateWithPath validates the CT_TLByHslColorTransform and its children, prefixing error messages with path
func (_becbc *CT_TLByHslColorTransform) ValidateWithPath(path string) error {
	if _dcbfg := _becbc.SAttr.ValidateWithPath(path + "\u002fSAttr"); _dcbfg != nil {
		return _dcbfg
	}
	if _gdecf := _becbc.LAttr.ValidateWithPath(path + "\u002fLAttr"); _gdecf != nil {
		return _gdecf
	}
	return nil
}
func NewCT_TLAnimateMotionBehavior() *CT_TLAnimateMotionBehavior {
	_ddfff := &CT_TLAnimateMotionBehavior{}
	_ddfff.CBhvr = NewCT_TLCommonBehaviorData()
	return _ddfff
}
func (_gefca ST_TLTimeNodeMasterRelation) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_gefca.String(), start)
}

// ValidateWithPath validates the CT_TLTemplate and its children, prefixing error messages with path
func (_eaage *CT_TLTemplate) ValidateWithPath(path string) error {
	if _dacf := _eaage.TnLst.ValidateWithPath(path + "\u002fTnLst"); _dacf != nil {
		return _dacf
	}
	return nil
}

// Validate validates the CT_CustomerDataList and its children
func (_ffg *CT_CustomerDataList) Validate() error {
	return _ffg.ValidateWithPath("CT_CustomerDataList")
}
func (_edd *CT_CommentAuthor) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "id"}, Value: _c.Sprintf("\u0025v", _edd.IdAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "name"}, Value: _c.Sprintf("\u0025v", _edd.NameAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "initials"}, Value: _c.Sprintf("\u0025v", _edd.InitialsAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "lastIdx"}, Value: _c.Sprintf("\u0025v", _edd.LastIdxAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "clrIdx"}, Value: _c.Sprintf("\u0025v", _edd.ClrIdxAttr)})
	e.EncodeToken(start)
	if _edd.ExtLst != nil {
		_cfg := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_edd.ExtLst, _cfg)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_TLByAnimateColorTransform struct {

	// RGB
	Rgb *CT_TLByRgbColorTransform

	// HSL
	Hsl *CT_TLByHslColorTransform
}
type CT_TLAnimVariant struct {

	// Boolean Variant
	BoolVal *CT_TLAnimVariantBooleanVal

	// Integer
	IntVal *CT_TLAnimVariantIntegerVal

	// Float Value
	FltVal *CT_TLAnimVariantFloatVal

	// String Value
	StrVal *CT_TLAnimVariantStringVal

	// Color Value
	ClrVal *_cb.CT_Color
}

func (_gegd ST_TLBehaviorAdditiveType) Validate() error { return _gegd.ValidateWithPath("") }

// ValidateWithPath validates the CT_TLAnimVariantIntegerVal and its children, prefixing error messages with path
func (_dfffd *CT_TLAnimVariantIntegerVal) ValidateWithPath(path string) error { return nil }
func (_dbgae ST_OleObjectFollowColorScheme) Validate() error                  { return _dbgae.ValidateWithPath("") }

// ValidateWithPath validates the CT_TLTimeTargetElement and its children, prefixing error messages with path
func (_bbfgd *CT_TLTimeTargetElement) ValidateWithPath(path string) error {
	if _bbfgd.SldTgt != nil {
		if _ebdb := _bbfgd.SldTgt.ValidateWithPath(path + "\u002fSldTgt"); _ebdb != nil {
			return _ebdb
		}
	}
	if _bbfgd.SndTgt != nil {
		if _bbgeb := _bbfgd.SndTgt.ValidateWithPath(path + "\u002fSndTgt"); _bbgeb != nil {
			return _bbgeb
		}
	}
	if _bbfgd.SpTgt != nil {
		if _adebd := _bbfgd.SpTgt.ValidateWithPath(path + "\u002fSpTgt"); _adebd != nil {
			return _adebd
		}
	}
	if _bbfgd.InkTgt != nil {
		if _dfeec := _bbfgd.InkTgt.ValidateWithPath(path + "\u002fInkTgt"); _dfeec != nil {
			return _dfeec
		}
	}
	return nil
}

type ST_TLTimeIndefinite byte

// ValidateWithPath validates the CT_TLAnimateScaleBehavior and its children, prefixing error messages with path
func (_gbcbg *CT_TLAnimateScaleBehavior) ValidateWithPath(path string) error {
	if _cgfaf := _gbcbg.CBhvr.ValidateWithPath(path + "\u002fCBhvr"); _cgfaf != nil {
		return _cgfaf
	}
	if _gbcbg.By != nil {
		if _dafc := _gbcbg.By.ValidateWithPath(path + "\u002fBy"); _dafc != nil {
			return _dafc
		}
	}
	if _gbcbg.From != nil {
		if _accc := _gbcbg.From.ValidateWithPath(path + "\u002fFrom"); _accc != nil {
			return _accc
		}
	}
	if _gbcbg.To != nil {
		if _deeef := _gbcbg.To.ValidateWithPath(path + "\u002fTo"); _deeef != nil {
			return _deeef
		}
	}
	return nil
}
func NewCT_TLIterateData() *CT_TLIterateData { _gcbf := &CT_TLIterateData{}; return _gcbf }
func (_dgfad ST_OleObjectFollowColorScheme) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_gdfee := _e.Attr{}
	_gdfee.Name = name
	switch _dgfad {
	case ST_OleObjectFollowColorSchemeUnset:
		_gdfee.Value = ""
	case ST_OleObjectFollowColorSchemeNone:
		_gdfee.Value = "none"
	case ST_OleObjectFollowColorSchemeFull:
		_gdfee.Value = "full"
	case ST_OleObjectFollowColorSchemeTextAndBackground:
		_gdfee.Value = "textAndBackground"
	}
	return _gdfee, nil
}
func (_bdaab ST_TLTimeNodeType) String() string {
	switch _bdaab {
	case 0:
		return ""
	case 1:
		return "clickEffect"
	case 2:
		return "withEffect"
	case 3:
		return "afterEffect"
	case 4:
		return "mainSeq"
	case 5:
		return "interactiveSeq"
	case 6:
		return "clickPar"
	case 7:
		return "withGroup"
	case 8:
		return "afterGroup"
	case 9:
		return "tmRoot"
	}
	return ""
}
func NewCT_Slide() *CT_Slide {
	_addee := &CT_Slide{}
	_addee.CSld = NewCT_CommonSlideData()
	return _addee
}

// ValidateWithPath validates the CT_Shape and its children, prefixing error messages with path
func (_cdff *CT_Shape) ValidateWithPath(path string) error {
	if _dcgb := _cdff.NvSpPr.ValidateWithPath(path + "\u002fNvSpPr"); _dcgb != nil {
		return _dcgb
	}
	if _dfgfg := _cdff.SpPr.ValidateWithPath(path + "\u002fSpPr"); _dfgfg != nil {
		return _dfgfg
	}
	if _cdff.Style != nil {
		if _aabd := _cdff.Style.ValidateWithPath(path + "\u002fStyle"); _aabd != nil {
			return _aabd
		}
	}
	if _cdff.TxBody != nil {
		if _caeef := _cdff.TxBody.ValidateWithPath(path + "\u002fTxBody"); _caeef != nil {
			return _caeef
		}
	}
	if _cdff.ExtLst != nil {
		if _gaag := _cdff.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gaag != nil {
			return _gaag
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SlideLayoutIdListEntry and its children, prefixing error messages with path
func (_gafef *CT_SlideLayoutIdListEntry) ValidateWithPath(path string) error {
	if _gafef.IdAttr != nil {
		if *_gafef.IdAttr < 2147483648 {
			return _c.Errorf("\u0025s\u002fm\u002eIdAttr must be\u0020\u003e\u003d\u00202147483648\u0020\u0028have\u0020\u0025v\u0029", path, *_gafef.IdAttr)
		}
	}
	if _gafef.ExtLst != nil {
		if _eggge := _gafef.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eggge != nil {
			return _eggge
		}
	}
	return nil
}
func (_gbce *CT_WheelTransition) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gbce.SpokesAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spokes"}, Value: _c.Sprintf("\u0025v", *_gbce.SpokesAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type ST_TLTimeNodeFillType byte

func (_ecadd ST_PrintColorMode) String() string {
	switch _ecadd {
	case 0:
		return ""
	case 1:
		return "bw"
	case 2:
		return "gray"
	case 3:
		return "clr"
	}
	return ""
}
func NewCT_TLTimeCondition() *CT_TLTimeCondition { _dccee := &CT_TLTimeCondition{}; return _dccee }

// Validate validates the CT_Control and its children
func (_cdce *CT_Control) Validate() error { return _cdce.ValidateWithPath("CT_Control") }
func (_bbceb *CT_TLShapeTargetElement) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _efeaf := range start.Attr {
		if _efeaf.Name.Local == "spid" {
			_fbgd, _bcbff := _b.ParseUint(_efeaf.Value, 10, 32)
			if _bcbff != nil {
				return _bcbff
			}
			_bbceb.SpidAttr = uint32(_fbgd)
			continue
		}
	}
_dceeg:
	for {
		_fade, _fbge := d.Token()
		if _fbge != nil {
			return _fbge
		}
		switch _ccdfbb := _fade.(type) {
		case _e.StartElement:
			switch _ccdfbb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bg"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bg"}:
				_bbceb.Bg = NewCT_Empty()
				if _bgadc := d.DecodeElement(_bbceb.Bg, &_ccdfbb); _bgadc != nil {
					return _bgadc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "subSp"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "subSp"}:
				_bbceb.SubSp = NewCT_TLSubShapeId()
				if _agcdbg := d.DecodeElement(_bbceb.SubSp, &_ccdfbb); _agcdbg != nil {
					return _agcdbg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "oleChartEl"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "oleChartEl"}:
				_bbceb.OleChartEl = NewCT_TLOleChartTargetElement()
				if _bgdf := d.DecodeElement(_bbceb.OleChartEl, &_ccdfbb); _bgdf != nil {
					return _bgdf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "txEl"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "txEl"}:
				_bbceb.TxEl = NewCT_TLTextTargetElement()
				if _cggfd := d.DecodeElement(_bbceb.TxEl, &_ccdfbb); _cggfd != nil {
					return _cggfd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "graphicEl"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "graphicEl"}:
				_bbceb.GraphicEl = _cb.NewCT_AnimationElementChoice()
				if _faadb := d.DecodeElement(_bbceb.GraphicEl, &_ccdfbb); _faadb != nil {
					return _faadb
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_TLShapeTargetElement \u0025v", _ccdfbb.Name)
				if _bfga := d.Skip(); _bfga != nil {
					return _bfga
				}
			}
		case _e.EndElement:
			break _dceeg
		case _e.CharData:
		}
	}
	return nil
}
func (_aeeea *CT_OrientationTransition) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _aeeea.DirAttr != ST_DirectionUnset {
		_fcgcf, _gbfa := _aeeea.DirAttr.MarshalXMLAttr(_e.Name{Local: "dir"})
		if _gbfa != nil {
			return _gbfa
		}
		start.Attr = append(start.Attr, _fcgcf)
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_fdgg ST_PhotoAlbumFrameShape) ValidateWithPath(path string) error {
	switch _fdgg {
	case 0, 1, 2, 3, 4, 5, 6, 7:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fdgg))
	}
	return nil
}

const (
	ST_OleObjectFollowColorSchemeUnset             ST_OleObjectFollowColorScheme = 0
	ST_OleObjectFollowColorSchemeNone              ST_OleObjectFollowColorScheme = 1
	ST_OleObjectFollowColorSchemeFull              ST_OleObjectFollowColorScheme = 2
	ST_OleObjectFollowColorSchemeTextAndBackground ST_OleObjectFollowColorScheme = 3
)

func NewCT_TLShapeTargetElement() *CT_TLShapeTargetElement {
	_ebfe := &CT_TLShapeTargetElement{}
	return _ebfe
}
func (_agcaff *CT_TLMediaNodeVideo) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _agcaff.FullScrnAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "fullScrn"}, Value: _c.Sprintf("\u0025d", _fdeab(*_agcaff.FullScrnAttr))})
	}
	e.EncodeToken(start)
	_bggcd := _e.StartElement{Name: _e.Name{Local: "p:cMediaNode"}}
	e.EncodeElement(_agcaff.CMediaNode, _bggcd)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

const (
	ST_TLTimeNodeTypeUnset          ST_TLTimeNodeType = 0
	ST_TLTimeNodeTypeClickEffect    ST_TLTimeNodeType = 1
	ST_TLTimeNodeTypeWithEffect     ST_TLTimeNodeType = 2
	ST_TLTimeNodeTypeAfterEffect    ST_TLTimeNodeType = 3
	ST_TLTimeNodeTypeMainSeq        ST_TLTimeNodeType = 4
	ST_TLTimeNodeTypeInteractiveSeq ST_TLTimeNodeType = 5
	ST_TLTimeNodeTypeClickPar       ST_TLTimeNodeType = 6
	ST_TLTimeNodeTypeWithGroup      ST_TLTimeNodeType = 7
	ST_TLTimeNodeTypeAfterGroup     ST_TLTimeNodeType = 8
	ST_TLTimeNodeTypeTmRoot         ST_TLTimeNodeType = 9
)

func (_gfcdg *EG_ChildSlide) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gfcdg.ClrMapOvr != nil {
		_fbgcf := _e.StartElement{Name: _e.Name{Local: "p:clrMapOvr"}}
		e.EncodeElement(_gfcdg.ClrMapOvr, _fbgcf)
	}
	return nil
}

// Validate validates the CT_TLShapeTargetElement and its children
func (_bagcg *CT_TLShapeTargetElement) Validate() error {
	return _bagcg.ValidateWithPath("CT_TLShapeTargetElement")
}
func (_edadb ST_TLTriggerRuntimeNode) String() string {
	switch _edadb {
	case 0:
		return ""
	case 1:
		return "first"
	case 2:
		return "last"
	case 3:
		return "all"
	}
	return ""
}
func (_fegb *CT_Presentation) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _fegb.ServerZoomAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "serverZoom"}, Value: _c.Sprintf("\u0025v", *_fegb.ServerZoomAttr)})
	}
	if _fegb.FirstSlideNumAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "firstSlideNum"}, Value: _c.Sprintf("\u0025v", *_fegb.FirstSlideNumAttr)})
	}
	if _fegb.ShowSpecialPlsOnTitleSldAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showSpecialPlsOnTitleSld"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fegb.ShowSpecialPlsOnTitleSldAttr))})
	}
	if _fegb.RtlAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "rtl"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fegb.RtlAttr))})
	}
	if _fegb.RemovePersonalInfoOnSaveAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "removePersonalInfoOnSave"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fegb.RemovePersonalInfoOnSaveAttr))})
	}
	if _fegb.CompatModeAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "compatMode"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fegb.CompatModeAttr))})
	}
	if _fegb.StrictFirstAndLastCharsAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "strictFirstAndLastChars"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fegb.StrictFirstAndLastCharsAttr))})
	}
	if _fegb.EmbedTrueTypeFontsAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "embedTrueTypeFonts"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fegb.EmbedTrueTypeFontsAttr))})
	}
	if _fegb.SaveSubsetFontsAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "saveSubsetFonts"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fegb.SaveSubsetFontsAttr))})
	}
	if _fegb.AutoCompressPicturesAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "autoCompressPictures"}, Value: _c.Sprintf("\u0025d", _fdeab(*_fegb.AutoCompressPicturesAttr))})
	}
	if _fegb.BookmarkIdSeedAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "bookmarkIdSeed"}, Value: _c.Sprintf("\u0025v", *_fegb.BookmarkIdSeedAttr)})
	}
	if _fegb.ConformanceAttr != _d.ST_ConformanceClassUnset {
		_bgea, _eeebd := _fegb.ConformanceAttr.MarshalXMLAttr(_e.Name{Local: "conformance"})
		if _eeebd != nil {
			return _eeebd
		}
		start.Attr = append(start.Attr, _bgea)
	}
	e.EncodeToken(start)
	if _fegb.SldMasterIdLst != nil {
		_deeea := _e.StartElement{Name: _e.Name{Local: "p:sldMasterIdLst"}}
		e.EncodeElement(_fegb.SldMasterIdLst, _deeea)
	}
	if _fegb.NotesMasterIdLst != nil {
		_gdabc := _e.StartElement{Name: _e.Name{Local: "p:notesMasterIdLst"}}
		e.EncodeElement(_fegb.NotesMasterIdLst, _gdabc)
	}
	if _fegb.HandoutMasterIdLst != nil {
		_cdafe := _e.StartElement{Name: _e.Name{Local: "p:handoutMasterIdLst"}}
		e.EncodeElement(_fegb.HandoutMasterIdLst, _cdafe)
	}
	if _fegb.SldIdLst != nil {
		_gcgba := _e.StartElement{Name: _e.Name{Local: "p:sldIdLst"}}
		e.EncodeElement(_fegb.SldIdLst, _gcgba)
	}
	if _fegb.SldSz != nil {
		_gcfd := _e.StartElement{Name: _e.Name{Local: "p:sldSz"}}
		e.EncodeElement(_fegb.SldSz, _gcfd)
	}
	_ebccf := _e.StartElement{Name: _e.Name{Local: "p:notesSz"}}
	e.EncodeElement(_fegb.NotesSz, _ebccf)
	if _fegb.SmartTags != nil {
		_ddeb := _e.StartElement{Name: _e.Name{Local: "p:smartTags"}}
		e.EncodeElement(_fegb.SmartTags, _ddeb)
	}
	if _fegb.EmbeddedFontLst != nil {
		_eabf := _e.StartElement{Name: _e.Name{Local: "p:embeddedFontLst"}}
		e.EncodeElement(_fegb.EmbeddedFontLst, _eabf)
	}
	if _fegb.CustShowLst != nil {
		_bgfc := _e.StartElement{Name: _e.Name{Local: "p:custShowLst"}}
		e.EncodeElement(_fegb.CustShowLst, _bgfc)
	}
	if _fegb.PhotoAlbum != nil {
		_cedc := _e.StartElement{Name: _e.Name{Local: "p:photoAlbum"}}
		e.EncodeElement(_fegb.PhotoAlbum, _cedc)
	}
	if _fegb.CustDataLst != nil {
		_aeff := _e.StartElement{Name: _e.Name{Local: "p:custDataLst"}}
		e.EncodeElement(_fegb.CustDataLst, _aeff)
	}
	if _fegb.Kinsoku != nil {
		_bcde := _e.StartElement{Name: _e.Name{Local: "p:kinsoku"}}
		e.EncodeElement(_fegb.Kinsoku, _bcde)
	}
	if _fegb.DefaultTextStyle != nil {
		_gfff := _e.StartElement{Name: _e.Name{Local: "p:defaultTextStyle"}}
		e.EncodeElement(_fegb.DefaultTextStyle, _gfff)
	}
	if _fegb.ModifyVerifier != nil {
		_cffbd := _e.StartElement{Name: _e.Name{Local: "p:modifyVerifier"}}
		e.EncodeElement(_fegb.ModifyVerifier, _cffbd)
	}
	if _fegb.ExtLst != nil {
		_fefba := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_fegb.ExtLst, _fefba)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_acdcfc ST_TLParaBuildType) Validate() error { return _acdcfc.ValidateWithPath("") }
func NewCT_Comment() *CT_Comment {
	_gede := &CT_Comment{}
	_gede.Pos = _cb.NewCT_Point2D()
	return _gede
}
func (_bbfbd ST_SplitterBarState) Validate() error { return _bbfbd.ValidateWithPath("") }
func NewCT_CornerDirectionTransition() *CT_CornerDirectionTransition {
	_gab := &CT_CornerDirectionTransition{}
	return _gab
}
func NewCT_TLCommonTimeNodeData() *CT_TLCommonTimeNodeData {
	_geedc := &CT_TLCommonTimeNodeData{}
	return _geedc
}
func (_babcb ST_TLBehaviorTransformType) ValidateWithPath(path string) error {
	switch _babcb {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_babcb))
	}
	return nil
}
func NewCT_ViewProperties() *CT_ViewProperties { _gbcba := &CT_ViewProperties{}; return _gbcba }
func (_ggb *AG_TLBuild) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _dg := range start.Attr {
		if _dg.Name.Local == "spid" {
			_cgb, _bce := _b.ParseUint(_dg.Value, 10, 32)
			if _bce != nil {
				return _bce
			}
			_ac := uint32(_cgb)
			_ggb.SpidAttr = &_ac
			continue
		}
		if _dg.Name.Local == "grpId" {
			_bbg, _dgb := _b.ParseUint(_dg.Value, 10, 32)
			if _dgb != nil {
				return _dgb
			}
			_abd := uint32(_bbg)
			_ggb.GrpIdAttr = &_abd
			continue
		}
		if _dg.Name.Local == "uiExpand" {
			_eba, _egb := _b.ParseBool(_dg.Value)
			if _egb != nil {
				return _egb
			}
			_ggb.UiExpandAttr = &_eba
			continue
		}
	}
	for {
		_gcd, _fee := d.Token()
		if _fee != nil {
			return _c.Errorf("parsing\u0020AG_TLBuild:\u0020%s", _fee)
		}
		if _dce, _be := _gcd.(_e.EndElement); _be && _dce.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_HeaderFooter() *CT_HeaderFooter { _cgdb := &CT_HeaderFooter{}; return _cgdb }
func (_ccgfag ST_SlideSizeType) ValidateWithPath(path string) error {
	switch _ccgfag {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ccgfag))
	}
	return nil
}

// ValidateWithPath validates the EG_ChildSlide and its children, prefixing error messages with path
func (_eebdb *EG_ChildSlide) ValidateWithPath(path string) error {
	if _eebdb.ClrMapOvr != nil {
		if _gbcd := _eebdb.ClrMapOvr.ValidateWithPath(path + "\u002fClrMapOvr"); _gbcd != nil {
			return _gbcd
		}
	}
	return nil
}

// Validate validates the TagLst and its children
func (_dcbd *TagLst) Validate() error { return _dcbd.ValidateWithPath("TagLst") }
func (_bdgba ST_TLTimeNodeFillType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_bdgba.String(), start)
}

// Validate validates the CT_CustomerData and its children
func (_acabf *CT_CustomerData) Validate() error { return _acabf.ValidateWithPath("CT_CustomerData") }

type CT_GraphicalObjectFrameNonVisual struct {

	// Non-Visual Drawing Properties
	CNvPr *_cb.CT_NonVisualDrawingProps

	// Non-Visual Graphic Frame Drawing Properties
	CNvGraphicFramePr *_cb.CT_NonVisualGraphicFrameProperties

	// Application Non-Visual Drawing Properties
	NvPr *CT_ApplicationNonVisualDrawingProps
}

// ValidateWithPath validates the CT_GroupShapeChoice and its children, prefixing error messages with path
func (_ebcc *CT_GroupShapeChoice) ValidateWithPath(path string) error {
	for _cbda, _cdf := range _ebcc.Sp {
		if _deac := _cdf.ValidateWithPath(_c.Sprintf("\u0025s\u002fSp\u005b\u0025d]", path, _cbda)); _deac != nil {
			return _deac
		}
	}
	for _fbbcg, _daee := range _ebcc.GrpSp {
		if _cfged := _daee.ValidateWithPath(_c.Sprintf("\u0025s\u002fGrpSp\u005b\u0025d\u005d", path, _fbbcg)); _cfged != nil {
			return _cfged
		}
	}
	for _fbbe, _cdaf := range _ebcc.GraphicFrame {
		if _agef := _cdaf.ValidateWithPath(_c.Sprintf("\u0025s\u002fGraphicFrame\u005b\u0025d\u005d", path, _fbbe)); _agef != nil {
			return _agef
		}
	}
	for _caee, _beaa := range _ebcc.CxnSp {
		if _egcd := _beaa.ValidateWithPath(_c.Sprintf("\u0025s\u002fCxnSp\u005b\u0025d\u005d", path, _caee)); _egcd != nil {
			return _egcd
		}
	}
	for _bdcd, _fege := range _ebcc.Pic {
		if _bdcdd := _fege.ValidateWithPath(_c.Sprintf("\u0025s\u002fPic\u005b\u0025d\u005d", path, _bdcd)); _bdcdd != nil {
			return _bdcdd
		}
	}
	for _fefd, _gdga := range _ebcc.ContentPart {
		if _cbdcf := _gdga.ValidateWithPath(_c.Sprintf("\u0025s\u002fContentPart\u005b\u0025d\u005d", path, _fefd)); _cbdcf != nil {
			return _cbdcf
		}
	}
	return nil
}
func (_gdgad *ST_TLBehaviorAdditiveType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_gdgad = 0
	case "base":
		*_gdgad = 1
	case "sum":
		*_gdgad = 2
	case "repl":
		*_gdgad = 3
	case "mult":
		*_gdgad = 4
	case "none":
		*_gdgad = 5
	}
	return nil
}
func (_ccadc ST_TLBehaviorAdditiveType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_ccadc.String(), start)
}
func (_effa *ST_SlideSizeType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fdabb, _afeg := d.Token()
	if _afeg != nil {
		return _afeg
	}
	if _ffgaf, _gdaag := _fdabb.(_e.EndElement); _gdaag && _ffgaf.Name == start.Name {
		*_effa = 1
		return nil
	}
	if _cabe, _efbcb := _fdabb.(_e.CharData); !_efbcb {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fdabb)
	} else {
		switch string(_cabe) {
		case "":
			*_effa = 0
		case "screen4x3":
			*_effa = 1
		case "letter":
			*_effa = 2
		case "A4":
			*_effa = 3
		case "35mm":
			*_effa = 4
		case "overhead":
			*_effa = 5
		case "banner":
			*_effa = 6
		case "custom":
			*_effa = 7
		case "ledger":
			*_effa = 8
		case "A3":
			*_effa = 9
		case "B4ISO":
			*_effa = 10
		case "B5ISO":
			*_effa = 11
		case "B4JIS":
			*_effa = 12
		case "B5JIS":
			*_effa = 13
		case "hagakiCard":
			*_effa = 14
		case "screen16x9":
			*_effa = 15
		case "screen16x10":
			*_effa = 16
		}
	}
	_fdabb, _afeg = d.Token()
	if _afeg != nil {
		return _afeg
	}
	if _ddgab, _edaeb := _fdabb.(_e.EndElement); _edaeb && _ddgab.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fdabb)
}
func (_dcge ST_TLTimeNodeFillType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_acdgd := _e.Attr{}
	_acdgd.Name = name
	switch _dcge {
	case ST_TLTimeNodeFillTypeUnset:
		_acdgd.Value = ""
	case ST_TLTimeNodeFillTypeRemove:
		_acdgd.Value = "remove"
	case ST_TLTimeNodeFillTypeFreeze:
		_acdgd.Value = "freeze"
	case ST_TLTimeNodeFillTypeHold:
		_acdgd.Value = "hold"
	case ST_TLTimeNodeFillTypeTransition:
		_acdgd.Value = "transition"
	}
	return _acdgd, nil
}
func NewCT_TLCommonMediaNodeData() *CT_TLCommonMediaNodeData {
	_dfcec := &CT_TLCommonMediaNodeData{}
	_dfcec.CTn = NewCT_TLCommonTimeNodeData()
	_dfcec.TgtEl = NewCT_TLTimeTargetElement()
	return _dfcec
}

type CT_TLIterateIntervalPercentage struct {

	// Value
	ValAttr _cb.ST_PositivePercentage
}

func (_dabfe ST_TLNextActionType) Validate() error { return _dabfe.ValidateWithPath("") }

// ValidateWithPath validates the CT_SlideMaster and its children, prefixing error messages with path
func (_faeab *CT_SlideMaster) ValidateWithPath(path string) error {
	if _fcfa := _faeab.CSld.ValidateWithPath(path + "\u002fCSld"); _fcfa != nil {
		return _fcfa
	}
	if _dfad := _faeab.ClrMap.ValidateWithPath(path + "\u002fClrMap"); _dfad != nil {
		return _dfad
	}
	if _faeab.SldLayoutIdLst != nil {
		if _degdg := _faeab.SldLayoutIdLst.ValidateWithPath(path + "\u002fSldLayoutIdLst"); _degdg != nil {
			return _degdg
		}
	}
	if _faeab.Transition != nil {
		if _fcbfb := _faeab.Transition.ValidateWithPath(path + "/Transition"); _fcbfb != nil {
			return _fcbfb
		}
	}
	if _faeab.Timing != nil {
		if _fbdf := _faeab.Timing.ValidateWithPath(path + "\u002fTiming"); _fbdf != nil {
			return _fbdf
		}
	}
	if _faeab.Hf != nil {
		if _dbdd := _faeab.Hf.ValidateWithPath(path + "\u002fHf"); _dbdd != nil {
			return _dbdd
		}
	}
	if _faeab.TxStyles != nil {
		if _aagdc := _faeab.TxStyles.ValidateWithPath(path + "\u002fTxStyles"); _aagdc != nil {
			return _aagdc
		}
	}
	if _faeab.ExtLst != nil {
		if _gcgcb := _faeab.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _gcgcb != nil {
			return _gcgcb
		}
	}
	return nil
}
func (_fegdb ST_TLBehaviorOverrideType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_cgffag := _e.Attr{}
	_cgffag.Name = name
	switch _fegdb {
	case ST_TLBehaviorOverrideTypeUnset:
		_cgffag.Value = ""
	case ST_TLBehaviorOverrideTypeNormal:
		_cgffag.Value = "normal"
	case ST_TLBehaviorOverrideTypeChildStyle:
		_cgffag.Value = "childStyle"
	}
	return _cgffag, nil
}
func (_gbfcc *ST_SlideLayoutType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_accagg, _ggaef := d.Token()
	if _ggaef != nil {
		return _ggaef
	}
	if _afdac, _cdgff := _accagg.(_e.EndElement); _cdgff && _afdac.Name == start.Name {
		*_gbfcc = 1
		return nil
	}
	if _adgab, _gbcgd := _accagg.(_e.CharData); !_gbcgd {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _accagg)
	} else {
		switch string(_adgab) {
		case "":
			*_gbfcc = 0
		case "title":
			*_gbfcc = 1
		case "tx":
			*_gbfcc = 2
		case "twoColTx":
			*_gbfcc = 3
		case "tbl":
			*_gbfcc = 4
		case "txAndChart":
			*_gbfcc = 5
		case "chartAndTx":
			*_gbfcc = 6
		case "dgm":
			*_gbfcc = 7
		case "chart":
			*_gbfcc = 8
		case "txAndClipArt":
			*_gbfcc = 9
		case "clipArtAndTx":
			*_gbfcc = 10
		case "titleOnly":
			*_gbfcc = 11
		case "blank":
			*_gbfcc = 12
		case "txAndObj":
			*_gbfcc = 13
		case "objAndTx":
			*_gbfcc = 14
		case "objOnly":
			*_gbfcc = 15
		case "obj":
			*_gbfcc = 16
		case "txAndMedia":
			*_gbfcc = 17
		case "mediaAndTx":
			*_gbfcc = 18
		case "objOverTx":
			*_gbfcc = 19
		case "txOverObj":
			*_gbfcc = 20
		case "txAndTwoObj":
			*_gbfcc = 21
		case "twoObjAndTx":
			*_gbfcc = 22
		case "twoObjOverTx":
			*_gbfcc = 23
		case "fourObj":
			*_gbfcc = 24
		case "vertTx":
			*_gbfcc = 25
		case "clipArtAndVertTx":
			*_gbfcc = 26
		case "vertTitleAndTx":
			*_gbfcc = 27
		case "vertTitleAndTxOverChart":
			*_gbfcc = 28
		case "twoObj":
			*_gbfcc = 29
		case "objAndTwoObj":
			*_gbfcc = 30
		case "twoObjAndObj":
			*_gbfcc = 31
		case "cust":
			*_gbfcc = 32
		case "secHead":
			*_gbfcc = 33
		case "twoTxTwoObj":
			*_gbfcc = 34
		case "objTx":
			*_gbfcc = 35
		case "picTx":
			*_gbfcc = 36
		}
	}
	_accagg, _ggaef = d.Token()
	if _ggaef != nil {
		return _ggaef
	}
	if _efdde, _efgdd := _accagg.(_e.EndElement); _efgdd && _efdde.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _accagg)
}

// ValidateWithPath validates the CT_NormalViewPortion and its children, prefixing error messages with path
func (_ddbf *CT_NormalViewPortion) ValidateWithPath(path string) error {
	if _abgda := _ddbf.SzAttr.ValidateWithPath(path + "\u002fSzAttr"); _abgda != nil {
		return _abgda
	}
	return nil
}
func (_eebg *CT_TLCommonMediaNodeData) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_eebg.CTn = NewCT_TLCommonTimeNodeData()
	_eebg.TgtEl = NewCT_TLTimeTargetElement()
	for _, _cdee := range start.Attr {
		if _cdee.Name.Local == "vol" {
			_agac, _ffaaf := ParseUnionST_PositiveFixedPercentage(_cdee.Value)
			if _ffaaf != nil {
				return _ffaaf
			}
			_eebg.VolAttr = &_agac
			continue
		}
		if _cdee.Name.Local == "mute" {
			_faad, _addgc := _b.ParseBool(_cdee.Value)
			if _addgc != nil {
				return _addgc
			}
			_eebg.MuteAttr = &_faad
			continue
		}
		if _cdee.Name.Local == "numSld" {
			_dfegc, _cbadf := _b.ParseUint(_cdee.Value, 10, 32)
			if _cbadf != nil {
				return _cbadf
			}
			_ffgd := uint32(_dfegc)
			_eebg.NumSldAttr = &_ffgd
			continue
		}
		if _cdee.Name.Local == "showWhenStopped" {
			_gcaad, _gefce := _b.ParseBool(_cdee.Value)
			if _gefce != nil {
				return _gefce
			}
			_eebg.ShowWhenStoppedAttr = &_gcaad
			continue
		}
	}
_bdefc:
	for {
		_aeaf, _cagaa := d.Token()
		if _cagaa != nil {
			return _cagaa
		}
		switch _agedb := _aeaf.(type) {
		case _e.StartElement:
			switch _agedb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cTn"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cTn"}:
				if _fbac := d.DecodeElement(_eebg.CTn, &_agedb); _fbac != nil {
					return _fbac
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tgtEl"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tgtEl"}:
				if _gdcd := d.DecodeElement(_eebg.TgtEl, &_agedb); _gdcd != nil {
					return _gdcd
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_TLCommonMediaNodeData\u0020%v", _agedb.Name)
				if _bfefa := d.Skip(); _bfefa != nil {
					return _bfefa
				}
			}
		case _e.EndElement:
			break _bdefc
		case _e.CharData:
		}
	}
	return nil
}
func (_eafdc *SldMaster) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:sldMaster"
	return _eafdc.CT_SlideMaster.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_SlideMasterTextStyles and its children, prefixing error messages with path
func (_acbce *CT_SlideMasterTextStyles) ValidateWithPath(path string) error {
	if _acbce.TitleStyle != nil {
		if _fgffa := _acbce.TitleStyle.ValidateWithPath(path + "/TitleStyle"); _fgffa != nil {
			return _fgffa
		}
	}
	if _acbce.BodyStyle != nil {
		if _cbfg := _acbce.BodyStyle.ValidateWithPath(path + "\u002fBodyStyle"); _cbfg != nil {
			return _cbfg
		}
	}
	if _acbce.OtherStyle != nil {
		if _afce := _acbce.OtherStyle.ValidateWithPath(path + "/OtherStyle"); _afce != nil {
			return _afce
		}
	}
	if _acbce.ExtLst != nil {
		if _cbcg := _acbce.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cbcg != nil {
			return _cbcg
		}
	}
	return nil
}
func (_ebfca ST_TLAnimateBehaviorValueType) String() string {
	switch _ebfca {
	case 0:
		return ""
	case 1:
		return "str"
	case 2:
		return "num"
	case 3:
		return "clr"
	}
	return ""
}

type ST_TLAnimateBehaviorCalcMode byte

func NewCT_EmbeddedFontList() *CT_EmbeddedFontList { _ebb := &CT_EmbeddedFontList{}; return _ebb }
func (_fefg *CT_Control) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _gccaa := range start.Attr {
		if _gccaa.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _gccaa.Name.Local == "id" {
			_afcce, _ffc := _gccaa.Value, error(nil)
			if _ffc != nil {
				return _ffc
			}
			_fefg.IdAttr = &_afcce
			continue
		}
		if _gccaa.Name.Local == "spid" {
			_daad, _fdbg := _gccaa.Value, error(nil)
			if _fdbg != nil {
				return _fdbg
			}
			_fefg.SpidAttr = &_daad
			continue
		}
		if _gccaa.Name.Local == "name" {
			_faed, _fce := _gccaa.Value, error(nil)
			if _fce != nil {
				return _fce
			}
			_fefg.NameAttr = &_faed
			continue
		}
		if _gccaa.Name.Local == "showAsIcon" {
			_dgee, _bebd := _b.ParseBool(_gccaa.Value)
			if _bebd != nil {
				return _bebd
			}
			_fefg.ShowAsIconAttr = &_dgee
			continue
		}
		if _gccaa.Name.Local == "imgW" {
			_bcee, _bgg := _b.ParseInt(_gccaa.Value, 10, 32)
			if _bgg != nil {
				return _bgg
			}
			_gadb := int32(_bcee)
			_fefg.ImgWAttr = &_gadb
			continue
		}
		if _gccaa.Name.Local == "imgH" {
			_cac, _addd := _b.ParseInt(_gccaa.Value, 10, 32)
			if _addd != nil {
				return _addd
			}
			_adbb := int32(_cac)
			_fefg.ImgHAttr = &_adbb
			continue
		}
	}
_eec:
	for {
		_efgg, _fde := d.Token()
		if _fde != nil {
			return _fde
		}
		switch _ccgd := _efgg.(type) {
		case _e.StartElement:
			switch _ccgd.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_fefg.ExtLst = NewCT_ExtensionList()
				if _cdd := d.DecodeElement(_fefg.ExtLst, &_ccgd); _cdd != nil {
					return _cdd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "pic"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "pic"}:
				_fefg.Pic = NewCT_Picture()
				if _dace := d.DecodeElement(_fefg.Pic, &_ccgd); _dace != nil {
					return _dace
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_Control\u0020\u0025v", _ccgd.Name)
				if _cgag := d.Skip(); _cgag != nil {
					return _cgag
				}
			}
		case _e.EndElement:
			break _eec
		case _e.CharData:
		}
	}
	return nil
}

type ST_PlaceholderSize byte

func (_dbddf *CT_TLBuildParagraph) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cfdca := range start.Attr {
		if _cfdca.Name.Local == "build" {
			_dbddf.BuildAttr.UnmarshalXMLAttr(_cfdca)
			continue
		}
		if _cfdca.Name.Local == "bldLvl" {
			_eebe, _cbea := _b.ParseUint(_cfdca.Value, 10, 32)
			if _cbea != nil {
				return _cbea
			}
			_beabg := uint32(_eebe)
			_dbddf.BldLvlAttr = &_beabg
			continue
		}
		if _cfdca.Name.Local == "animBg" {
			_fccbe, _beef := _b.ParseBool(_cfdca.Value)
			if _beef != nil {
				return _beef
			}
			_dbddf.AnimBgAttr = &_fccbe
			continue
		}
		if _cfdca.Name.Local == "autoUpdateAnimBg" {
			_aegbd, _cdef := _b.ParseBool(_cfdca.Value)
			if _cdef != nil {
				return _cdef
			}
			_dbddf.AutoUpdateAnimBgAttr = &_aegbd
			continue
		}
		if _cfdca.Name.Local == "rev" {
			_bcdf, _cdead := _b.ParseBool(_cfdca.Value)
			if _cdead != nil {
				return _cdead
			}
			_dbddf.RevAttr = &_bcdf
			continue
		}
		if _cfdca.Name.Local == "advAuto" {
			_ebgfc, _gfbf := ParseUnionST_TLTime(_cfdca.Value)
			if _gfbf != nil {
				return _gfbf
			}
			_dbddf.AdvAutoAttr = &_ebgfc
			continue
		}
		if _cfdca.Name.Local == "spid" {
			_beggd, _ddeg := _b.ParseUint(_cfdca.Value, 10, 32)
			if _ddeg != nil {
				return _ddeg
			}
			_agefe := uint32(_beggd)
			_dbddf.SpidAttr = &_agefe
			continue
		}
		if _cfdca.Name.Local == "grpId" {
			_ffef, _begbc := _b.ParseUint(_cfdca.Value, 10, 32)
			if _begbc != nil {
				return _begbc
			}
			_ecgdc := uint32(_ffef)
			_dbddf.GrpIdAttr = &_ecgdc
			continue
		}
		if _cfdca.Name.Local == "uiExpand" {
			_cdfc, _defc := _b.ParseBool(_cfdca.Value)
			if _defc != nil {
				return _defc
			}
			_dbddf.UiExpandAttr = &_cdfc
			continue
		}
	}
_bbb:
	for {
		_decg, _addfg := d.Token()
		if _addfg != nil {
			return _addfg
		}
		switch _egagc := _decg.(type) {
		case _e.StartElement:
			switch _egagc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tmplLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tmplLst"}:
				_dbddf.TmplLst = NewCT_TLTemplateList()
				if _cgfaa := d.DecodeElement(_dbddf.TmplLst, &_egagc); _cgfaa != nil {
					return _cgfaa
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLBuildParagraph\u0020\u0025v", _egagc.Name)
				if _geab := d.Skip(); _geab != nil {
					return _geab
				}
			}
		case _e.EndElement:
			break _bbb
		case _e.CharData:
		}
	}
	return nil
}

type CT_BackgroundProperties struct {

	// Shade to Title
	ShadeToTitleAttr *bool
	NoFill           *_cb.CT_NoFillProperties
	SolidFill        *_cb.CT_SolidColorFillProperties
	GradFill         *_cb.CT_GradientFillProperties
	BlipFill         *_cb.CT_BlipFillProperties
	PattFill         *_cb.CT_PatternFillProperties
	GrpFill          *_cb.CT_GroupFillProperties
	EffectLst        *_cb.CT_EffectList
	EffectDag        *_cb.CT_EffectContainer
	ExtLst           *CT_ExtensionList
}

func (_ggaf *ST_TLAnimateMotionPathEditMode) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_ggaf = 0
	case "relative":
		*_ggaf = 1
	case "fixed":
		*_ggaf = 2
	}
	return nil
}
func (_egcgd ST_TLTimeIndefinite) String() string {
	switch _egcgd {
	case 0:
		return ""
	case 1:
		return "indefinite"
	}
	return ""
}

// ValidateWithPath validates the CT_SlideTransitionChoice and its children, prefixing error messages with path
func (_gabg *CT_SlideTransitionChoice) ValidateWithPath(path string) error {
	if _gabg.Blinds != nil {
		if _cgfff := _gabg.Blinds.ValidateWithPath(path + "\u002fBlinds"); _cgfff != nil {
			return _cgfff
		}
	}
	if _gabg.Checker != nil {
		if _afff := _gabg.Checker.ValidateWithPath(path + "\u002fChecker"); _afff != nil {
			return _afff
		}
	}
	if _gabg.Circle != nil {
		if _fcda := _gabg.Circle.ValidateWithPath(path + "\u002fCircle"); _fcda != nil {
			return _fcda
		}
	}
	if _gabg.Dissolve != nil {
		if _bcdg := _gabg.Dissolve.ValidateWithPath(path + "\u002fDissolve"); _bcdg != nil {
			return _bcdg
		}
	}
	if _gabg.Comb != nil {
		if _fagf := _gabg.Comb.ValidateWithPath(path + "\u002fComb"); _fagf != nil {
			return _fagf
		}
	}
	if _gabg.Cover != nil {
		if _ggbga := _gabg.Cover.ValidateWithPath(path + "\u002fCover"); _ggbga != nil {
			return _ggbga
		}
	}
	if _gabg.Cut != nil {
		if _agag := _gabg.Cut.ValidateWithPath(path + "\u002fCut"); _agag != nil {
			return _agag
		}
	}
	if _gabg.Diamond != nil {
		if _ceddg := _gabg.Diamond.ValidateWithPath(path + "\u002fDiamond"); _ceddg != nil {
			return _ceddg
		}
	}
	if _gabg.Fade != nil {
		if _dgdeg := _gabg.Fade.ValidateWithPath(path + "\u002fFade"); _dgdeg != nil {
			return _dgdeg
		}
	}
	if _gabg.Newsflash != nil {
		if _ddede := _gabg.Newsflash.ValidateWithPath(path + "\u002fNewsflash"); _ddede != nil {
			return _ddede
		}
	}
	if _gabg.Plus != nil {
		if _gdadb := _gabg.Plus.ValidateWithPath(path + "\u002fPlus"); _gdadb != nil {
			return _gdadb
		}
	}
	if _gabg.Pull != nil {
		if _ccbd := _gabg.Pull.ValidateWithPath(path + "\u002fPull"); _ccbd != nil {
			return _ccbd
		}
	}
	if _gabg.Push != nil {
		if _cebf := _gabg.Push.ValidateWithPath(path + "\u002fPush"); _cebf != nil {
			return _cebf
		}
	}
	if _gabg.Random != nil {
		if _faaed := _gabg.Random.ValidateWithPath(path + "\u002fRandom"); _faaed != nil {
			return _faaed
		}
	}
	if _gabg.RandomBar != nil {
		if _ddcce := _gabg.RandomBar.ValidateWithPath(path + "\u002fRandomBar"); _ddcce != nil {
			return _ddcce
		}
	}
	if _gabg.Split != nil {
		if _gccbd := _gabg.Split.ValidateWithPath(path + "\u002fSplit"); _gccbd != nil {
			return _gccbd
		}
	}
	if _gabg.Strips != nil {
		if _accaa := _gabg.Strips.ValidateWithPath(path + "\u002fStrips"); _accaa != nil {
			return _accaa
		}
	}
	if _gabg.Wedge != nil {
		if _fdfbe := _gabg.Wedge.ValidateWithPath(path + "\u002fWedge"); _fdfbe != nil {
			return _fdfbe
		}
	}
	if _gabg.Wheel != nil {
		if _dcef := _gabg.Wheel.ValidateWithPath(path + "\u002fWheel"); _dcef != nil {
			return _dcef
		}
	}
	if _gabg.Wipe != nil {
		if _bddg := _gabg.Wipe.ValidateWithPath(path + "\u002fWipe"); _bddg != nil {
			return _bddg
		}
	}
	if _gabg.Zoom != nil {
		if _fgacb := _gabg.Zoom.ValidateWithPath(path + "\u002fZoom"); _fgacb != nil {
			return _fgacb
		}
	}
	return nil
}

type CT_NotesSlide struct {

	// Common slide data for notes slides
	CSld *CT_CommonSlideData

	// Color Scheme Map Override
	ClrMapOvr            *_cb.CT_ColorMappingOverride
	ExtLst               *CT_ExtensionListModify
	ShowMasterSpAttr     *bool
	ShowMasterPhAnimAttr *bool
}

// ValidateWithPath validates the CT_TLTimeNodeExclusive and its children, prefixing error messages with path
func (_ebga *CT_TLTimeNodeExclusive) ValidateWithPath(path string) error {
	if _ebefc := _ebga.CTn.ValidateWithPath(path + "\u002fCTn"); _ebefc != nil {
		return _ebefc
	}
	return nil
}
func (_efa *CT_Background) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _add := range start.Attr {
		if _add.Name.Local == "bwMode" {
			_efa.BwModeAttr.UnmarshalXMLAttr(_add)
			continue
		}
	}
_fff:
	for {
		_ddc, _gce := d.Token()
		if _gce != nil {
			return _gce
		}
		switch _adgg := _ddc.(type) {
		case _e.StartElement:
			switch _adgg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bgPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bgPr"}:
				_efa.BgPr = NewCT_BackgroundProperties()
				if _bf := d.DecodeElement(_efa.BgPr, &_adgg); _bf != nil {
					return _bf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bgRef"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bgRef"}:
				_efa.BgRef = _cb.NewCT_StyleMatrixReference()
				if _ada := d.DecodeElement(_efa.BgRef, &_adgg); _ada != nil {
					return _ada
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_Background \u0025v", _adgg.Name)
				if _cd := d.Skip(); _cd != nil {
					return _cd
				}
			}
		case _e.EndElement:
			break _fff
		case _e.CharData:
		}
	}
	return nil
}

const (
	ST_PlaceholderSizeUnset   ST_PlaceholderSize = 0
	ST_PlaceholderSizeFull    ST_PlaceholderSize = 1
	ST_PlaceholderSizeHalf    ST_PlaceholderSize = 2
	ST_PlaceholderSizeQuarter ST_PlaceholderSize = 3
)

func (_agbebc ST_PrintColorMode) ValidateWithPath(path string) error {
	switch _agbebc {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_agbebc))
	}
	return nil
}
func (_fdacb *CT_HtmlPublishProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _dgfc := range start.Attr {
		if _dgfc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _dgfc.Name.Local == "id" || _dgfc.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _dgfc.Name.Local == "id" {
			_cdcd, _aabcb := _dgfc.Value, error(nil)
			if _aabcb != nil {
				return _aabcb
			}
			_fdacb.IdAttr = _cdcd
			continue
		}
		if _dgfc.Name.Local == "showSpeakerNotes" {
			_bgaf, _bccee := _b.ParseBool(_dgfc.Value)
			if _bccee != nil {
				return _bccee
			}
			_fdacb.ShowSpeakerNotesAttr = &_bgaf
			continue
		}
		if _dgfc.Name.Local == "target" {
			_egaac, _caeec := _dgfc.Value, error(nil)
			if _caeec != nil {
				return _caeec
			}
			_fdacb.TargetAttr = &_egaac
			continue
		}
		if _dgfc.Name.Local == "title" {
			_abbd, _egbg := _dgfc.Value, error(nil)
			if _egbg != nil {
				return _egbg
			}
			_fdacb.TitleAttr = &_abbd
			continue
		}
	}
_fgbdc:
	for {
		_abeae, _fddd := d.Token()
		if _fddd != nil {
			return _fddd
		}
		switch _bdga := _abeae.(type) {
		case _e.StartElement:
			switch _bdga.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldAll"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldAll"}:
				_fdacb.SldAll = NewCT_Empty()
				if _cccbb := d.DecodeElement(_fdacb.SldAll, &_bdga); _cccbb != nil {
					return _cccbb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldRg"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldRg"}:
				_fdacb.SldRg = NewCT_IndexRange()
				if _adeed := d.DecodeElement(_fdacb.SldRg, &_bdga); _adeed != nil {
					return _adeed
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "custShow"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "custShow"}:
				_fdacb.CustShow = NewCT_CustomShowId()
				if _dbbc := d.DecodeElement(_fdacb.CustShow, &_bdga); _dbbc != nil {
					return _dbbc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_fdacb.ExtLst = NewCT_ExtensionList()
				if _ebfg := d.DecodeElement(_fdacb.ExtLst, &_bdga); _ebfg != nil {
					return _ebfg
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_HtmlPublishProperties\u0020%v", _bdga.Name)
				if _caab := d.Skip(); _caab != nil {
					return _caab
				}
			}
		case _e.EndElement:
			break _fgbdc
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the SldSyncPr and its children
func (_beegg *SldSyncPr) Validate() error { return _beegg.ValidateWithPath("SldSyncPr") }
func (_ebfa *ST_TLBehaviorAccumulateType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dfddb, _cfgd := d.Token()
	if _cfgd != nil {
		return _cfgd
	}
	if _dcgf, _aebba := _dfddb.(_e.EndElement); _aebba && _dcgf.Name == start.Name {
		*_ebfa = 1
		return nil
	}
	if _acbd, _bgcgb := _dfddb.(_e.CharData); !_bgcgb {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dfddb)
	} else {
		switch string(_acbd) {
		case "":
			*_ebfa = 0
		case "none":
			*_ebfa = 1
		case "always":
			*_ebfa = 2
		}
	}
	_dfddb, _cfgd = d.Token()
	if _cfgd != nil {
		return _cfgd
	}
	if _bcfdb, _fbbfd := _dfddb.(_e.EndElement); _fbbfd && _bcfdb.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dfddb)
}

const (
	ST_WebScreenSizeUnset     ST_WebScreenSize = 0
	ST_WebScreenSize544x376   ST_WebScreenSize = 1
	ST_WebScreenSize640x480   ST_WebScreenSize = 2
	ST_WebScreenSize720x512   ST_WebScreenSize = 3
	ST_WebScreenSize800x600   ST_WebScreenSize = 4
	ST_WebScreenSize1024x768  ST_WebScreenSize = 5
	ST_WebScreenSize1152x882  ST_WebScreenSize = 6
	ST_WebScreenSize1152x900  ST_WebScreenSize = 7
	ST_WebScreenSize1280x1024 ST_WebScreenSize = 8
	ST_WebScreenSize1600x1200 ST_WebScreenSize = 9
	ST_WebScreenSize1800x1400 ST_WebScreenSize = 10
	ST_WebScreenSize1920x1200 ST_WebScreenSize = 11
)

func NewCT_TLTimeTargetElement() *CT_TLTimeTargetElement {
	_cebbc := &CT_TLTimeTargetElement{}
	return _cebbc
}
func (_bffb *CT_SlideSorterViewProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_bffb.CViewPr = NewCT_CommonViewProperties()
	for _, _gbcc := range start.Attr {
		if _gbcc.Name.Local == "showFormatting" {
			_dffg, _ecegb := _b.ParseBool(_gbcc.Value)
			if _ecegb != nil {
				return _ecegb
			}
			_bffb.ShowFormattingAttr = &_dffg
			continue
		}
	}
_ceeca:
	for {
		_dcbcg, _badf := d.Token()
		if _badf != nil {
			return _badf
		}
		switch _ebafa := _dcbcg.(type) {
		case _e.StartElement:
			switch _ebafa.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cViewPr"}:
				if _bdggf := d.DecodeElement(_bffb.CViewPr, &_ebafa); _bdggf != nil {
					return _bdggf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_bffb.ExtLst = NewCT_ExtensionList()
				if _ceeec := d.DecodeElement(_bffb.ExtLst, &_ebafa); _ceeec != nil {
					return _ceeec
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_SlideSorterViewProperties\u0020\u0025v", _ebafa.Name)
				if _acgbf := d.Skip(); _acgbf != nil {
					return _acgbf
				}
			}
		case _e.EndElement:
			break _ceeca
		case _e.CharData:
		}
	}
	return nil
}

const (
	ST_PrintColorModeUnset ST_PrintColorMode = 0
	ST_PrintColorModeBw    ST_PrintColorMode = 1
	ST_PrintColorModeGray  ST_PrintColorMode = 2
	ST_PrintColorModeClr   ST_PrintColorMode = 3
)

func NewEG_ShowType() *EG_ShowType { _ggdac := &EG_ShowType{}; return _ggdac }
func NewCT_TLByRgbColorTransform() *CT_TLByRgbColorTransform {
	_eede := &CT_TLByRgbColorTransform{}
	return _eede
}
func (_ecagc ST_TLTimeIndefinite) ValidateWithPath(path string) error {
	switch _ecagc {
	case 0, 1:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ecagc))
	}
	return nil
}

// Validate validates the CT_TLAnimateScaleBehavior and its children
func (_gdgb *CT_TLAnimateScaleBehavior) Validate() error {
	return _gdgb.ValidateWithPath("CT_TLAnimateScaleBehavior")
}
func (_dfgc *CT_GraphicalObjectFrameNonVisual) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dfgc.CNvPr = _cb.NewCT_NonVisualDrawingProps()
	_dfgc.CNvGraphicFramePr = _cb.NewCT_NonVisualGraphicFrameProperties()
	_dfgc.NvPr = NewCT_ApplicationNonVisualDrawingProps()
_cca:
	for {
		_bcbd, _gdfd := d.Token()
		if _gdfd != nil {
			return _gdfd
		}
		switch _dafb := _bcbd.(type) {
		case _e.StartElement:
			switch _dafb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cNvPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cNvPr"}:
				if _cgff := d.DecodeElement(_dfgc.CNvPr, &_dafb); _cgff != nil {
					return _cgff
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cNvGraphicFramePr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cNvGraphicFramePr"}:
				if _egba := d.DecodeElement(_dfgc.CNvGraphicFramePr, &_dafb); _egba != nil {
					return _egba
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "nvPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "nvPr"}:
				if _faea := d.DecodeElement(_dfgc.NvPr, &_dafb); _faea != nil {
					return _faea
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GraphicalObjectFrameNonVisual\u0020\u0025v", _dafb.Name)
				if _fccb := d.Skip(); _fccb != nil {
					return _fccb
				}
			}
		case _e.EndElement:
			break _cca
		case _e.CharData:
		}
	}
	return nil
}
func (_cebge *CT_TLAnimVariantStringVal) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _dbbcd := range start.Attr {
		if _dbbcd.Name.Local == "val" {
			_efcgb, _bbef := _dbbcd.Value, error(nil)
			if _bbef != nil {
				return _bbef
			}
			_cebge.ValAttr = _efcgb
			continue
		}
	}
	for {
		_eabb, _eadfd := d.Token()
		if _eadfd != nil {
			return _c.Errorf("parsing CT_TLAnimVariantStringVal:\u0020\u0025s", _eadfd)
		}
		if _agbc, _dbadg := _eabb.(_e.EndElement); _dbadg && _agbc.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_ModifyVerifier and its children
func (_aea *CT_ModifyVerifier) Validate() error { return _aea.ValidateWithPath("CT_ModifyVerifier") }
func (_deeg ST_TLAnimateColorDirection) String() string {
	switch _deeg {
	case 0:
		return ""
	case 1:
		return "cw"
	case 2:
		return "ccw"
	}
	return ""
}

type CT_SplitTransition struct {

	// Orientation
	OrientAttr ST_Direction

	// Direction
	DirAttr ST_TransitionInOutDirectionType
}
type CT_ApplicationNonVisualDrawingProps struct {

	// Is a Photo Album
	IsPhotoAttr *bool

	// Is User Drawn
	UserDrawnAttr *bool

	// Placeholder Shape
	Ph            *CT_Placeholder
	AudioCd       *_cb.CT_AudioCD
	WavAudioFile  *_cb.CT_EmbeddedWAVAudioFile
	AudioFile     *_cb.CT_AudioFile
	VideoFile     *_cb.CT_VideoFile
	QuickTimeFile *_cb.CT_QuickTimeFile

	// Customer Data List
	CustDataLst *CT_CustomerDataList
	ExtLst      *CT_ExtensionList
}
type CT_TLTimeCondition struct {

	// Trigger Event
	EvtAttr ST_TLTriggerEvent

	// Trigger Delay
	DelayAttr *ST_TLTime

	// Target Element Trigger Choice
	TgtEl *CT_TLTimeTargetElement

	// Time Node
	Tn *CT_TLTriggerTimeNodeID

	// Runtime Node Trigger Choice
	Rtn *CT_TLTriggerRuntimeNode
}

func ParseUnionST_TLTimeAnimateValueTime(s string) (ST_TLTimeAnimateValueTime, error) {
	return ST_TLTimeAnimateValueTime{}, nil
}

type CT_ConnectorNonVisual struct {

	// Non-Visual Drawing Properties
	CNvPr *_cb.CT_NonVisualDrawingProps

	// Non-Visual Connector Shape Drawing Properties
	CNvCxnSpPr *_cb.CT_NonVisualConnectorProperties

	// Application Non-Visual Drawing Properties
	NvPr *CT_ApplicationNonVisualDrawingProps
}
type ST_Direction byte

func (_ceec *CT_NotesTextViewProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_dbgee := _e.StartElement{Name: _e.Name{Local: "p:cViewPr"}}
	e.EncodeElement(_ceec.CViewPr, _dbgee)
	if _ceec.ExtLst != nil {
		_gbda := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ceec.ExtLst, _gbda)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_TLAnimVariantBooleanVal() *CT_TLAnimVariantBooleanVal {
	_gdegf := &CT_TLAnimVariantBooleanVal{}
	return _gdegf
}
func (_ebbba ST_TLTimeNodePresetClassType) Validate() error { return _ebbba.ValidateWithPath("") }

// ValidateWithPath validates the CT_GraphicalObjectFrame and its children, prefixing error messages with path
func (_aaf *CT_GraphicalObjectFrame) ValidateWithPath(path string) error {
	if _adcc := _aaf.BwModeAttr.ValidateWithPath(path + "/BwModeAttr"); _adcc != nil {
		return _adcc
	}
	if _ccda := _aaf.NvGraphicFramePr.ValidateWithPath(path + "\u002fNvGraphicFramePr"); _ccda != nil {
		return _ccda
	}
	if _fbaa := _aaf.Xfrm.ValidateWithPath(path + "\u002fXfrm"); _fbaa != nil {
		return _fbaa
	}
	if _ccb := _aaf.Graphic.ValidateWithPath(path + "\u002fGraphic"); _ccb != nil {
		return _ccb
	}
	if _aaf.ExtLst != nil {
		if _fbfe := _aaf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fbfe != nil {
			return _fbfe
		}
	}
	return nil
}
func (_eaad *CT_GroupShapeNonVisual) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_gcabb := _e.StartElement{Name: _e.Name{Local: "p:cNvPr"}}
	e.EncodeElement(_eaad.CNvPr, _gcabb)
	_ecab := _e.StartElement{Name: _e.Name{Local: "p:cNvGrpSpPr"}}
	e.EncodeElement(_eaad.CNvGrpSpPr, _ecab)
	_afac := _e.StartElement{Name: _e.Name{Local: "p:nvPr"}}
	e.EncodeElement(_eaad.NvPr, _afac)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type ST_TransitionCornerDirectionType byte

// Validate validates the CT_NotesSlide and its children
func (_fdgdd *CT_NotesSlide) Validate() error { return _fdgdd.ValidateWithPath("CT_NotesSlide") }

// Validate validates the CT_SlideSyncProperties and its children
func (_egfce *CT_SlideSyncProperties) Validate() error {
	return _egfce.ValidateWithPath("CT_SlideSyncProperties")
}
func (_ddcdec ST_WebScreenSize) ValidateWithPath(path string) error {
	switch _ddcdec {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ddcdec))
	}
	return nil
}
func (_edage *ST_TLTime) Validate() error { return _edage.ValidateWithPath("") }

// Validate validates the CT_CustomShow and its children
func (_eaef *CT_CustomShow) Validate() error { return _eaef.ValidateWithPath("CT_CustomShow") }
func NewAG_ChildSlide() *AG_ChildSlide       { _g := &AG_ChildSlide{}; return _g }
func (_bbeeed *ST_TLAnimateMotionBehaviorOrigin) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fgfee, _ffcag := d.Token()
	if _ffcag != nil {
		return _ffcag
	}
	if _dfec, _bcdce := _fgfee.(_e.EndElement); _bcdce && _dfec.Name == start.Name {
		*_bbeeed = 1
		return nil
	}
	if _agdad, _gaeee := _fgfee.(_e.CharData); !_gaeee {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fgfee)
	} else {
		switch string(_agdad) {
		case "":
			*_bbeeed = 0
		case "parent":
			*_bbeeed = 1
		case "layout":
			*_bbeeed = 2
		}
	}
	_fgfee, _ffcag = d.Token()
	if _ffcag != nil {
		return _ffcag
	}
	if _cedba, _egfbc := _fgfee.(_e.EndElement); _egfbc && _cedba.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fgfee)
}
func (_eceef *CT_SlideMaster) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_eceef.CSld = NewCT_CommonSlideData()
	_eceef.ClrMap = _cb.NewCT_ColorMapping()
	for _, _aceb := range start.Attr {
		if _aceb.Name.Local == "preserve" {
			_bcgc, _dfeg := _b.ParseBool(_aceb.Value)
			if _dfeg != nil {
				return _dfeg
			}
			_eceef.PreserveAttr = &_bcgc
			continue
		}
	}
_dcee:
	for {
		_cgab, _gabab := d.Token()
		if _gabab != nil {
			return _gabab
		}
		switch _abeac := _cgab.(type) {
		case _e.StartElement:
			switch _abeac.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _cbddd := d.DecodeElement(_eceef.CSld, &_abeac); _cbddd != nil {
					return _cbddd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMap"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMap"}:
				if _aeabg := d.DecodeElement(_eceef.ClrMap, &_abeac); _aeabg != nil {
					return _aeabg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldLayoutIdLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldLayoutIdLst"}:
				_eceef.SldLayoutIdLst = NewCT_SlideLayoutIdList()
				if _dffdc := d.DecodeElement(_eceef.SldLayoutIdLst, &_abeac); _dffdc != nil {
					return _dffdc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "transition"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "transition"}:
				_eceef.Transition = NewCT_SlideTransition()
				if _cfgbf := d.DecodeElement(_eceef.Transition, &_abeac); _cfgbf != nil {
					return _cfgbf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "timing"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "timing"}:
				_eceef.Timing = NewCT_SlideTiming()
				if _bgcb := d.DecodeElement(_eceef.Timing, &_abeac); _bgcb != nil {
					return _bgcb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "hf"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "hf"}:
				_eceef.Hf = NewCT_HeaderFooter()
				if _ecde := d.DecodeElement(_eceef.Hf, &_abeac); _ecde != nil {
					return _ecde
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "txStyles"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "txStyles"}:
				_eceef.TxStyles = NewCT_SlideMasterTextStyles()
				if _acfe := d.DecodeElement(_eceef.TxStyles, &_abeac); _acfe != nil {
					return _acfe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_eceef.ExtLst = NewCT_ExtensionListModify()
				if _ggbegc := d.DecodeElement(_eceef.ExtLst, &_abeac); _ggbegc != nil {
					return _ggbegc
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_SlideMaster\u0020\u0025v", _abeac.Name)
				if _cdbc := d.Skip(); _cdbc != nil {
					return _cdbc
				}
			}
		case _e.EndElement:
			break _dcee
		case _e.CharData:
		}
	}
	return nil
}
func (_cfedf *CT_OleObjectChoice) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_cbag:
	for {
		_fcgf, _bcda := d.Token()
		if _bcda != nil {
			return _bcda
		}
		switch _deed := _fcgf.(type) {
		case _e.StartElement:
			switch _deed.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "embed"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "embed"}:
				_cfedf.Embed = NewCT_OleObjectEmbed()
				if _feeff := d.DecodeElement(_cfedf.Embed, &_deed); _feeff != nil {
					return _feeff
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "link"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "link"}:
				_cfedf.Link = NewCT_OleObjectLink()
				if _cgge := d.DecodeElement(_cfedf.Link, &_deed); _cgge != nil {
					return _cgge
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_OleObjectChoice\u0020\u0025v", _deed.Name)
				if _cbagb := d.Skip(); _cbagb != nil {
					return _cbagb
				}
			}
		case _e.EndElement:
			break _cbag
		case _e.CharData:
		}
	}
	return nil
}
func (_eccaee ST_TLTimeNodeMasterRelation) Validate() error { return _eccaee.ValidateWithPath("") }
func ParseUnionST_TLTime(s string) (ST_TLTime, error)       { return ST_TLTime{}, nil }
func (_gcbdgc *ST_TransitionCornerDirectionType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fbgbg, _ddfcb := d.Token()
	if _ddfcb != nil {
		return _ddfcb
	}
	if _ddgbf, _cbggf := _fbgbg.(_e.EndElement); _cbggf && _ddgbf.Name == start.Name {
		*_gcbdgc = 1
		return nil
	}
	if _eadcec, _gdae := _fbgbg.(_e.CharData); !_gdae {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fbgbg)
	} else {
		switch string(_eadcec) {
		case "":
			*_gcbdgc = 0
		case "lu":
			*_gcbdgc = 1
		case "ru":
			*_gcbdgc = 2
		case "ld":
			*_gcbdgc = 3
		case "rd":
			*_gcbdgc = 4
		}
	}
	_fbgbg, _ddfcb = d.Token()
	if _ddfcb != nil {
		return _ddfcb
	}
	if _bfgce, _bbgbg := _fbgbg.(_e.EndElement); _bbgbg && _bfgce.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fbgbg)
}
func (_bdeb *CT_InOutTransition) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _bdeb.DirAttr != ST_TransitionInOutDirectionTypeUnset {
		_dbag, _bfgd := _bdeb.DirAttr.MarshalXMLAttr(_e.Name{Local: "dir"})
		if _bfgd != nil {
			return _bfgd
		}
		start.Attr = append(start.Attr, _dbag)
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Slide and its children
func (_ccefb *CT_Slide) Validate() error { return _ccefb.ValidateWithPath("CT_Slide") }

// Validate validates the CT_HtmlPublishProperties and its children
func (_gafb *CT_HtmlPublishProperties) Validate() error {
	return _gafb.ValidateWithPath("CT_HtmlPublishProperties")
}
func (_cbbe ST_TLTimeNodeSyncType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_cbbe.String(), start)
}

type CT_TLByRgbColorTransform struct {

	// Red
	RAttr _cb.ST_FixedPercentage

	// Green
	GAttr _cb.ST_FixedPercentage

	// Blue
	BAttr _cb.ST_FixedPercentage
}
type CT_TLOleChartTargetElement struct {

	// Type
	TypeAttr ST_TLChartSubelementType

	// Level
	LvlAttr *uint32
}

// ValidateWithPath validates the CT_PhotoAlbum and its children, prefixing error messages with path
func (_fgbdcc *CT_PhotoAlbum) ValidateWithPath(path string) error {
	if _gbgdc := _fgbdcc.LayoutAttr.ValidateWithPath(path + "/LayoutAttr"); _gbgdc != nil {
		return _gbgdc
	}
	if _cceeb := _fgbdcc.FrameAttr.ValidateWithPath(path + "\u002fFrameAttr"); _cceeb != nil {
		return _cceeb
	}
	if _fgbdcc.ExtLst != nil {
		if _fadg := _fgbdcc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fadg != nil {
			return _fadg
		}
	}
	return nil
}
func (_acbda ST_TLBehaviorOverrideType) String() string {
	switch _acbda {
	case 0:
		return ""
	case 1:
		return "normal"
	case 2:
		return "childStyle"
	}
	return ""
}
func (_ecefaf ST_TLTimeNodeMasterRelation) ValidateWithPath(path string) error {
	switch _ecefaf {
	case 0, 1, 2, 3:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ecefaf))
	}
	return nil
}
func (_bafef *CT_ExtensionList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_dcadb:
	for {
		_fcc, _dage := d.Token()
		if _dage != nil {
			return _dage
		}
		switch _gac := _fcc.(type) {
		case _e.StartElement:
			switch _gac.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "ext"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "ext"}:
				_gfgg := NewCT_Extension()
				if _cbaf := d.DecodeElement(_gfgg, &_gac); _cbaf != nil {
					return _cbaf
				}
				_bafef.Ext = append(_bafef.Ext, _gfgg)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ExtensionList\u0020\u0025v", _gac.Name)
				if _gdgf := d.Skip(); _gdgf != nil {
					return _gdgf
				}
			}
		case _e.EndElement:
			break _dcadb
		case _e.CharData:
		}
	}
	return nil
}
func (_egaag *EG_TopLevelSlide) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	_bcaf := _e.StartElement{Name: _e.Name{Local: "p:clrMap"}}
	e.EncodeElement(_egaag.ClrMap, _bcaf)
	return nil
}

const (
	ST_TLCommandTypeUnset ST_TLCommandType = 0
	ST_TLCommandTypeEvt   ST_TLCommandType = 1
	ST_TLCommandTypeCall  ST_TLCommandType = 2
	ST_TLCommandTypeVerb  ST_TLCommandType = 3
)

// ValidateWithPath validates the CT_StringTag and its children, prefixing error messages with path
func (_afabg *CT_StringTag) ValidateWithPath(path string) error { return nil }
func (_fdaca ST_TLTimeNodeRestartType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_fdaca.String(), start)
}
func (_bbfgc *ST_TLTriggerEvent) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_addb, _becfg := d.Token()
	if _becfg != nil {
		return _becfg
	}
	if _abcb, _befag := _addb.(_e.EndElement); _befag && _abcb.Name == start.Name {
		*_bbfgc = 1
		return nil
	}
	if _deead, _aagbgfd := _addb.(_e.CharData); !_aagbgfd {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _addb)
	} else {
		switch string(_deead) {
		case "":
			*_bbfgc = 0
		case "onBegin":
			*_bbfgc = 1
		case "onEnd":
			*_bbfgc = 2
		case "begin":
			*_bbfgc = 3
		case "end":
			*_bbfgc = 4
		case "onClick":
			*_bbfgc = 5
		case "onDblClick":
			*_bbfgc = 6
		case "onMouseOver":
			*_bbfgc = 7
		case "onMouseOut":
			*_bbfgc = 8
		case "onNext":
			*_bbfgc = 9
		case "onPrev":
			*_bbfgc = 10
		case "onStopAudio":
			*_bbfgc = 11
		}
	}
	_addb, _becfg = d.Token()
	if _becfg != nil {
		return _becfg
	}
	if _dadee, _feec := _addb.(_e.EndElement); _feec && _dadee.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _addb)
}

// ValidateWithPath validates the CT_EmbeddedFontDataId and its children, prefixing error messages with path
func (_cffa *CT_EmbeddedFontDataId) ValidateWithPath(path string) error { return nil }
func (_cbcgg ST_TransitionSideDirectionType) Validate() error           { return _cbcgg.ValidateWithPath("") }

type CT_TLMediaNodeVideo struct {

	// Full Screen
	FullScrnAttr *bool

	// Common Media Node Properties
	CMediaNode *CT_TLCommonMediaNodeData
}

// Validate validates the CT_SlideIdList and its children
func (_dcde *CT_SlideIdList) Validate() error { return _dcde.ValidateWithPath("CT_SlideIdList") }
func NewCT_TLTemplate() *CT_TLTemplate {
	_agffg := &CT_TLTemplate{}
	_agffg.TnLst = NewCT_TimeNodeList()
	return _agffg
}
func (_efdd *CT_SlideMaster) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _efdd.PreserveAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "preserve"}, Value: _c.Sprintf("\u0025d", _fdeab(*_efdd.PreserveAttr))})
	}
	e.EncodeToken(start)
	_aeggb := _e.StartElement{Name: _e.Name{Local: "p:cSld"}}
	e.EncodeElement(_efdd.CSld, _aeggb)
	_dcceg := _e.StartElement{Name: _e.Name{Local: "p:clrMap"}}
	e.EncodeElement(_efdd.ClrMap, _dcceg)
	if _efdd.SldLayoutIdLst != nil {
		_feefg := _e.StartElement{Name: _e.Name{Local: "p:sldLayoutIdLst"}}
		e.EncodeElement(_efdd.SldLayoutIdLst, _feefg)
	}
	if _efdd.Transition != nil {
		_fbfb := _e.StartElement{Name: _e.Name{Local: "p:transition"}}
		e.EncodeElement(_efdd.Transition, _fbfb)
	}
	if _efdd.Timing != nil {
		_cdace := _e.StartElement{Name: _e.Name{Local: "p:timing"}}
		e.EncodeElement(_efdd.Timing, _cdace)
	}
	if _efdd.Hf != nil {
		_egad := _e.StartElement{Name: _e.Name{Local: "p:hf"}}
		e.EncodeElement(_efdd.Hf, _egad)
	}
	if _efdd.TxStyles != nil {
		_gebf := _e.StartElement{Name: _e.Name{Local: "p:txStyles"}}
		e.EncodeElement(_efdd.TxStyles, _gebf)
	}
	if _efdd.ExtLst != nil {
		_cfedc := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_efdd.ExtLst, _cfedc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_ccde ST_SlideLayoutType) ValidateWithPath(path string) error {
	switch _ccde {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ccde))
	}
	return nil
}

// Validate validates the SldMaster and its children
func (_abdfd *SldMaster) Validate() error { return _abdfd.ValidateWithPath("SldMaster") }

// Validate validates the CT_OutlineViewSlideList and its children
func (_cfeaa *CT_OutlineViewSlideList) Validate() error {
	return _cfeaa.ValidateWithPath("CT_OutlineViewSlideList")
}

type TagLst struct{ CT_TagList }

func (_acec *CT_InOutTransition) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cagd := range start.Attr {
		if _cagd.Name.Local == "dir" {
			_acec.DirAttr.UnmarshalXMLAttr(_cagd)
			continue
		}
	}
	for {
		_agfa, _ecbc := d.Token()
		if _ecbc != nil {
			return _c.Errorf("parsing\u0020CT_InOutTransition:\u0020\u0025s", _ecbc)
		}
		if _afbg, _bbed := _agfa.(_e.EndElement); _bbed && _afbg.Name == start.Name {
			break
		}
	}
	return nil
}

type HandoutMaster struct{ CT_HandoutMaster }

func (_gcaaa ST_TLBehaviorAccumulateType) ValidateWithPath(path string) error {
	switch _gcaaa {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gcaaa))
	}
	return nil
}

// Validate validates the CT_Background and its children
func (_cfc *CT_Background) Validate() error { return _cfc.ValidateWithPath("CT_Background") }

const (
	ST_ViewTypeUnset            ST_ViewType = 0
	ST_ViewTypeSldView          ST_ViewType = 1
	ST_ViewTypeSldMasterView    ST_ViewType = 2
	ST_ViewTypeNotesView        ST_ViewType = 3
	ST_ViewTypeHandoutView      ST_ViewType = 4
	ST_ViewTypeNotesMasterView  ST_ViewType = 5
	ST_ViewTypeOutlineView      ST_ViewType = 6
	ST_ViewTypeSldSorterView    ST_ViewType = 7
	ST_ViewTypeSldThumbnailView ST_ViewType = 8
)

func (_edagf *CT_TLBuildDiagram) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _bedf := range start.Attr {
		if _bedf.Name.Local == "bld" {
			_edagf.BldAttr.UnmarshalXMLAttr(_bedf)
			continue
		}
		if _bedf.Name.Local == "spid" {
			_gaff, _gbcce := _b.ParseUint(_bedf.Value, 10, 32)
			if _gbcce != nil {
				return _gbcce
			}
			_egac := uint32(_gaff)
			_edagf.SpidAttr = &_egac
			continue
		}
		if _bedf.Name.Local == "grpId" {
			_ccegd, _aadcc := _b.ParseUint(_bedf.Value, 10, 32)
			if _aadcc != nil {
				return _aadcc
			}
			_afea := uint32(_ccegd)
			_edagf.GrpIdAttr = &_afea
			continue
		}
		if _bedf.Name.Local == "uiExpand" {
			_cbade, _cgfb := _b.ParseBool(_bedf.Value)
			if _cgfb != nil {
				return _cgfb
			}
			_edagf.UiExpandAttr = &_cbade
			continue
		}
	}
	for {
		_afcfb, _gbgge := d.Token()
		if _gbgge != nil {
			return _c.Errorf("parsing\u0020CT_TLBuildDiagram: \u0025s", _gbgge)
		}
		if _dfgdd, _bdebc := _afcfb.(_e.EndElement); _bdebc && _dfgdd.Name == start.Name {
			break
		}
	}
	return nil
}
func NewSldSyncPr() *SldSyncPr {
	_gfgga := &SldSyncPr{}
	_gfgga.CT_SlideSyncProperties = *NewCT_SlideSyncProperties()
	return _gfgga
}
func NewCT_TLTimeConditionList() *CT_TLTimeConditionList {
	_bbged := &CT_TLTimeConditionList{}
	return _bbged
}
func (_cdcac ST_TLPreviousActionType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_aebce := _e.Attr{}
	_aebce.Name = name
	switch _cdcac {
	case ST_TLPreviousActionTypeUnset:
		_aebce.Value = ""
	case ST_TLPreviousActionTypeNone:
		_aebce.Value = "none"
	case ST_TLPreviousActionTypeSkipTimed:
		_aebce.Value = "skipTimed"
	}
	return _aebce, nil
}
func (_gcdcfb ST_PlaceholderSize) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_gcdcfb.String(), start)
}
func NewCT_SlideMasterIdListEntry() *CT_SlideMasterIdListEntry {
	_egab := &CT_SlideMasterIdListEntry{}
	return _egab
}

// ValidateWithPath validates the CT_CommonSlideViewProperties and its children, prefixing error messages with path
func (_cfcf *CT_CommonSlideViewProperties) ValidateWithPath(path string) error {
	if _cgcg := _cfcf.CViewPr.ValidateWithPath(path + "\u002fCViewPr"); _cgcg != nil {
		return _cgcg
	}
	if _cfcf.GuideLst != nil {
		if _acee := _cfcf.GuideLst.ValidateWithPath(path + "\u002fGuideLst"); _acee != nil {
			return _acee
		}
	}
	return nil
}

// Validate validates the CT_EmbeddedFontListEntry and its children
func (_fbf *CT_EmbeddedFontListEntry) Validate() error {
	return _fbf.ValidateWithPath("CT_EmbeddedFontListEntry")
}
func (_egbcg *CT_GroupShapeChoice) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_ddfa:
	for {
		_gfed, _efggf := d.Token()
		if _efggf != nil {
			return _efggf
		}
		switch _ffba := _gfed.(type) {
		case _e.StartElement:
			switch _ffba.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sp"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sp"}:
				_gggc := NewCT_Shape()
				if _afgd := d.DecodeElement(_gggc, &_ffba); _afgd != nil {
					return _afgd
				}
				_egbcg.Sp = append(_egbcg.Sp, _gggc)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "grpSp"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "grpSp"}:
				_eaaa := NewCT_GroupShape()
				if _cdbd := d.DecodeElement(_eaaa, &_ffba); _cdbd != nil {
					return _cdbd
				}
				_egbcg.GrpSp = append(_egbcg.GrpSp, _eaaa)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "graphicFrame"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "graphicFrame"}:
				_egfg := NewCT_GraphicalObjectFrame()
				if _agda := d.DecodeElement(_egfg, &_ffba); _agda != nil {
					return _agda
				}
				_egbcg.GraphicFrame = append(_egbcg.GraphicFrame, _egfg)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cxnSp"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cxnSp"}:
				_bdgf := NewCT_Connector()
				if _ggcfg := d.DecodeElement(_bdgf, &_ffba); _ggcfg != nil {
					return _ggcfg
				}
				_egbcg.CxnSp = append(_egbcg.CxnSp, _bdgf)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "pic"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "pic"}:
				_gffb := NewCT_Picture()
				if _bafb := d.DecodeElement(_gffb, &_ffba); _bafb != nil {
					return _bafb
				}
				_egbcg.Pic = append(_egbcg.Pic, _gffb)
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "contentPart"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "contentPart"}:
				_bffd := NewCT_Rel()
				if _eeac := d.DecodeElement(_bffd, &_ffba); _eeac != nil {
					return _eeac
				}
				_egbcg.ContentPart = append(_egbcg.ContentPart, _bffd)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GroupShapeChoice\u0020\u0025v", _ffba.Name)
				if _deg := d.Skip(); _deg != nil {
					return _deg
				}
			}
		case _e.EndElement:
			break _ddfa
		case _e.CharData:
		}
	}
	return nil
}
func (_dcae *CT_TLTimeNodeParallel) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dcae.CTn = NewCT_TLCommonTimeNodeData()
_ebbaf:
	for {
		_aebaf, _cbeae := d.Token()
		if _cbeae != nil {
			return _cbeae
		}
		switch _abebb := _aebaf.(type) {
		case _e.StartElement:
			switch _abebb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cTn"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cTn"}:
				if _fbec := d.DecodeElement(_dcae.CTn, &_abebb); _fbec != nil {
					return _fbec
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CT_TLTimeNodeParallel\u0020\u0025v", _abebb.Name)
				if _gegbf := d.Skip(); _gegbf != nil {
					return _gegbf
				}
			}
		case _e.EndElement:
			break _ebbaf
		case _e.CharData:
		}
	}
	return nil
}
func (_eddgb ST_TLTimeNodeFillType) ValidateWithPath(path string) error {
	switch _eddgb {
	case 0, 1, 2, 3, 4:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eddgb))
	}
	return nil
}
func (_gffeg *CT_TLIterateData) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gffeg.TypeAttr != ST_IterateTypeUnset {
		_bfeacd, _eagcf := _gffeg.TypeAttr.MarshalXMLAttr(_e.Name{Local: "type"})
		if _eagcf != nil {
			return _eagcf
		}
		start.Attr = append(start.Attr, _bfeacd)
	}
	if _gffeg.BackwardsAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "backwards"}, Value: _c.Sprintf("\u0025d", _fdeab(*_gffeg.BackwardsAttr))})
	}
	e.EncodeToken(start)
	if _gffeg.TmAbs != nil {
		_dfadeg := _e.StartElement{Name: _e.Name{Local: "p:tmAbs"}}
		e.EncodeElement(_gffeg.TmAbs, _dfadeg)
	}
	if _gffeg.TmPct != nil {
		_cbdbf := _e.StartElement{Name: _e.Name{Local: "p:tmPct"}}
		e.EncodeElement(_gffeg.TmPct, _cbdbf)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_cdae *CT_OrientationTransition) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _agdgf := range start.Attr {
		if _agdgf.Name.Local == "dir" {
			_cdae.DirAttr.UnmarshalXMLAttr(_agdgf)
			continue
		}
	}
	for {
		_gcaeb, _ddgdb := d.Token()
		if _ddgdb != nil {
			return _c.Errorf("parsing CT_OrientationTransition:\u0020%s", _ddgdb)
		}
		if _efdg, _gadab := _gcaeb.(_e.EndElement); _gadab && _efdg.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_WheelTransition and its children, prefixing error messages with path
func (_fgcbb *CT_WheelTransition) ValidateWithPath(path string) error { return nil }

type CT_TLSubShapeId struct {

	// Shape ID
	SpidAttr string
}

func (_dfada ST_PlaceholderType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_fdgab := _e.Attr{}
	_fdgab.Name = name
	switch _dfada {
	case ST_PlaceholderTypeUnset:
		_fdgab.Value = ""
	case ST_PlaceholderTypeTitle:
		_fdgab.Value = "title"
	case ST_PlaceholderTypeBody:
		_fdgab.Value = "body"
	case ST_PlaceholderTypeCtrTitle:
		_fdgab.Value = "ctrTitle"
	case ST_PlaceholderTypeSubTitle:
		_fdgab.Value = "subTitle"
	case ST_PlaceholderTypeDt:
		_fdgab.Value = "dt"
	case ST_PlaceholderTypeSldNum:
		_fdgab.Value = "sldNum"
	case ST_PlaceholderTypeFtr:
		_fdgab.Value = "ftr"
	case ST_PlaceholderTypeHdr:
		_fdgab.Value = "hdr"
	case ST_PlaceholderTypeObj:
		_fdgab.Value = "obj"
	case ST_PlaceholderTypeChart:
		_fdgab.Value = "chart"
	case ST_PlaceholderTypeTbl:
		_fdgab.Value = "tbl"
	case ST_PlaceholderTypeClipArt:
		_fdgab.Value = "clipArt"
	case ST_PlaceholderTypeDgm:
		_fdgab.Value = "dgm"
	case ST_PlaceholderTypeMedia:
		_fdgab.Value = "media"
	case ST_PlaceholderTypeSldImg:
		_fdgab.Value = "sldImg"
	case ST_PlaceholderTypePic:
		_fdgab.Value = "pic"
	}
	return _fdgab, nil
}
func (_gbad *CT_CornerDirectionTransition) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gbad.DirAttr != ST_TransitionCornerDirectionTypeUnset {
		_eae, _gbg := _gbad.DirAttr.MarshalXMLAttr(_e.Name{Local: "dir"})
		if _gbg != nil {
			return _gbg
		}
		start.Attr = append(start.Attr, _eae)
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_eade *CT_TLAnimVariantBooleanVal) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "val"}, Value: _c.Sprintf("\u0025d", _fdeab(_eade.ValAttr))})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_GroupShapeChoice() *CT_GroupShapeChoice { _eab := &CT_GroupShapeChoice{}; return _eab }
func (_ggff *CT_SplitTransition) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ggff.OrientAttr != ST_DirectionUnset {
		_abgf, _bfcb := _ggff.OrientAttr.MarshalXMLAttr(_e.Name{Local: "orient"})
		if _bfcb != nil {
			return _bfcb
		}
		start.Attr = append(start.Attr, _abgf)
	}
	if _ggff.DirAttr != ST_TransitionInOutDirectionTypeUnset {
		_dfff, _bdgb := _ggff.DirAttr.MarshalXMLAttr(_e.Name{Local: "dir"})
		if _bdgb != nil {
			return _bdgb
		}
		start.Attr = append(start.Attr, _dfff)
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TLTimeNodeExclusive and its children
func (_aacf *CT_TLTimeNodeExclusive) Validate() error {
	return _aacf.ValidateWithPath("CT_TLTimeNodeExclusive")
}
func (_eagba *CT_PhotoAlbum) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _eeeea := range start.Attr {
		if _eeeea.Name.Local == "bw" {
			_bgag, _bfef := _b.ParseBool(_eeeea.Value)
			if _bfef != nil {
				return _bfef
			}
			_eagba.BwAttr = &_bgag
			continue
		}
		if _eeeea.Name.Local == "showCaptions" {
			_cdfg, _gbdc := _b.ParseBool(_eeeea.Value)
			if _gbdc != nil {
				return _gbdc
			}
			_eagba.ShowCaptionsAttr = &_cdfg
			continue
		}
		if _eeeea.Name.Local == "layout" {
			_eagba.LayoutAttr.UnmarshalXMLAttr(_eeeea)
			continue
		}
		if _eeeea.Name.Local == "frame" {
			_eagba.FrameAttr.UnmarshalXMLAttr(_eeeea)
			continue
		}
	}
_gbgd:
	for {
		_baad, _gedf := d.Token()
		if _gedf != nil {
			return _gedf
		}
		switch _caca := _baad.(type) {
		case _e.StartElement:
			switch _caca.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_eagba.ExtLst = NewCT_ExtensionList()
				if _ddcf := d.DecodeElement(_eagba.ExtLst, &_caca); _ddcf != nil {
					return _ddcf
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_PhotoAlbum \u0025v", _caca.Name)
				if _dead := d.Skip(); _dead != nil {
					return _dead
				}
			}
		case _e.EndElement:
			break _gbgd
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the EG_ShowType and its children
func (_aefdd *EG_ShowType) Validate() error { return _aefdd.ValidateWithPath("EG_ShowType") }
func (_acca *CT_CommentAuthorList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _acca.CmAuthor != nil {
		_edb := _e.StartElement{Name: _e.Name{Local: "p:cmAuthor"}}
		for _, _afg := range _acca.CmAuthor {
			e.EncodeElement(_afg, _edb)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_cdcaf ST_PrintColorMode) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_cdcaf.String(), start)
}
func (_bcbb ST_TLAnimateMotionPathEditMode) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_bcbb.String(), start)
}
func NewCT_Kinsoku() *CT_Kinsoku           { _dbffg := &CT_Kinsoku{}; return _dbffg }
func NewCT_CustomShowId() *CT_CustomShowId { _fcgb := &CT_CustomShowId{}; return _fcgb }
func (_bccddd *CT_TLTemplate) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_bccddd.TnLst = NewCT_TimeNodeList()
	for _, _bcebc := range start.Attr {
		if _bcebc.Name.Local == "lvl" {
			_aebaa, _cdgd := _b.ParseUint(_bcebc.Value, 10, 32)
			if _cdgd != nil {
				return _cdgd
			}
			_adace := uint32(_aebaa)
			_bccddd.LvlAttr = &_adace
			continue
		}
	}
_fagc:
	for {
		_cgaff, _afbgde := d.Token()
		if _afbgde != nil {
			return _afbgde
		}
		switch _ffccf := _cgaff.(type) {
		case _e.StartElement:
			switch _ffccf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tnLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tnLst"}:
				if _adeg := d.DecodeElement(_bccddd.TnLst, &_ffccf); _adeg != nil {
					return _adeg
				}
			default:
				_ee.Log("skipping unsupported element\u0020on\u0020CT_TLTemplate \u0025v", _ffccf.Name)
				if _cgbg := d.Skip(); _cgbg != nil {
					return _cgbg
				}
			}
		case _e.EndElement:
			break _fagc
		case _e.CharData:
		}
	}
	return nil
}
func (_cdfa *CT_GroupShapeNonVisual) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cdfa.CNvPr = _cb.NewCT_NonVisualDrawingProps()
	_cdfa.CNvGrpSpPr = _cb.NewCT_NonVisualGroupDrawingShapeProps()
	_cdfa.NvPr = NewCT_ApplicationNonVisualDrawingProps()
_dgbf:
	for {
		_egef, _adee := d.Token()
		if _adee != nil {
			return _adee
		}
		switch _affc := _egef.(type) {
		case _e.StartElement:
			switch _affc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cNvPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cNvPr"}:
				if _afcf := d.DecodeElement(_cdfa.CNvPr, &_affc); _afcf != nil {
					return _afcf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cNvGrpSpPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cNvGrpSpPr"}:
				if _daaf := d.DecodeElement(_cdfa.CNvGrpSpPr, &_affc); _daaf != nil {
					return _daaf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "nvPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "nvPr"}:
				if _beba := d.DecodeElement(_cdfa.NvPr, &_affc); _beba != nil {
					return _beba
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_GroupShapeNonVisual\u0020\u0025v", _affc.Name)
				if _adeec := d.Skip(); _adeec != nil {
					return _adeec
				}
			}
		case _e.EndElement:
			break _dgbf
		case _e.CharData:
		}
	}
	return nil
}
func (_dadg *CT_Kinsoku) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _aedd := range start.Attr {
		if _aedd.Name.Local == "lang" {
			_aefb, _baec := _aedd.Value, error(nil)
			if _baec != nil {
				return _baec
			}
			_dadg.LangAttr = &_aefb
			continue
		}
		if _aedd.Name.Local == "invalStChars" {
			_bfeg, _dbge := _aedd.Value, error(nil)
			if _dbge != nil {
				return _dbge
			}
			_dadg.InvalStCharsAttr = _bfeg
			continue
		}
		if _aedd.Name.Local == "invalEndChars" {
			_cgfeb, _deca := _aedd.Value, error(nil)
			if _deca != nil {
				return _deca
			}
			_dadg.InvalEndCharsAttr = _cgfeb
			continue
		}
	}
	for {
		_aggd, _fbdc := d.Token()
		if _fbdc != nil {
			return _c.Errorf("parsing\u0020CT_Kinsoku:\u0020%s", _fbdc)
		}
		if _dgfe, _aabg := _aggd.(_e.EndElement); _aabg && _dgfe.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ecbacd ST_WebColorType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_fccee := _e.Attr{}
	_fccee.Name = name
	switch _ecbacd {
	case ST_WebColorTypeUnset:
		_fccee.Value = ""
	case ST_WebColorTypeNone:
		_fccee.Value = "none"
	case ST_WebColorTypeBrowser:
		_fccee.Value = "browser"
	case ST_WebColorTypePresentationText:
		_fccee.Value = "presentationText"
	case ST_WebColorTypePresentationAccent:
		_fccee.Value = "presentationAccent"
	case ST_WebColorTypeWhiteTextOnBlack:
		_fccee.Value = "whiteTextOnBlack"
	case ST_WebColorTypeBlackTextOnWhite:
		_fccee.Value = "blackTextOnWhite"
	}
	return _fccee, nil
}
func NewCT_Shape() *CT_Shape {
	_eeef := &CT_Shape{}
	_eeef.NvSpPr = NewCT_ShapeNonVisual()
	_eeef.SpPr = _cb.NewCT_ShapeProperties()
	return _eeef
}
func (_gafgg *CT_TransitionSoundAction) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _gafgg.StSnd != nil {
		_adceg := _e.StartElement{Name: _e.Name{Local: "p:stSnd"}}
		e.EncodeElement(_gafgg.StSnd, _adceg)
	}
	if _gafgg.EndSnd != nil {
		_ggef := _e.StartElement{Name: _e.Name{Local: "p:endSnd"}}
		e.EncodeElement(_gafgg.EndSnd, _ggef)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_GuideList() *CT_GuideList { _gecc := &CT_GuideList{}; return _gecc }

// Validate validates the EG_Background and its children
func (_fbcg *EG_Background) Validate() error { return _fbcg.ValidateWithPath("EG_Background") }

type ST_TLTimeNodeMasterRelation byte

func (_efgcb *CT_ShowProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _efgcb.LoopAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "loop"}, Value: _c.Sprintf("\u0025d", _fdeab(*_efgcb.LoopAttr))})
	}
	if _efgcb.ShowNarrationAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showNarration"}, Value: _c.Sprintf("\u0025d", _fdeab(*_efgcb.ShowNarrationAttr))})
	}
	if _efgcb.ShowAnimationAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showAnimation"}, Value: _c.Sprintf("\u0025d", _fdeab(*_efgcb.ShowAnimationAttr))})
	}
	if _efgcb.UseTimingsAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "useTimings"}, Value: _c.Sprintf("\u0025d", _fdeab(*_efgcb.UseTimingsAttr))})
	}
	e.EncodeToken(start)
	if _efgcb.Present != nil {
		_caba := _e.StartElement{Name: _e.Name{Local: "p:present"}}
		e.EncodeElement(_efgcb.Present, _caba)
	}
	if _efgcb.Browse != nil {
		_abbgf := _e.StartElement{Name: _e.Name{Local: "p:browse"}}
		e.EncodeElement(_efgcb.Browse, _abbgf)
	}
	if _efgcb.Kiosk != nil {
		_eddd := _e.StartElement{Name: _e.Name{Local: "p:kiosk"}}
		e.EncodeElement(_efgcb.Kiosk, _eddd)
	}
	if _efgcb.SldAll != nil {
		_bfbb := _e.StartElement{Name: _e.Name{Local: "p:sldAll"}}
		e.EncodeElement(_efgcb.SldAll, _bfbb)
	}
	if _efgcb.SldRg != nil {
		_bdcda := _e.StartElement{Name: _e.Name{Local: "p:sldRg"}}
		e.EncodeElement(_efgcb.SldRg, _bdcda)
	}
	if _efgcb.CustShow != nil {
		_gfcac := _e.StartElement{Name: _e.Name{Local: "p:custShow"}}
		e.EncodeElement(_efgcb.CustShow, _gfcac)
	}
	if _efgcb.PenClr != nil {
		_ggde := _e.StartElement{Name: _e.Name{Local: "p:penClr"}}
		e.EncodeElement(_efgcb.PenClr, _ggde)
	}
	if _efgcb.ExtLst != nil {
		_defa := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_efgcb.ExtLst, _defa)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_TLTimeNodeParallel() *CT_TLTimeNodeParallel {
	_fbgfff := &CT_TLTimeNodeParallel{}
	_fbgfff.CTn = NewCT_TLCommonTimeNodeData()
	return _fbgfff
}
func (_gfeed *NotesMaster) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gfeed.CT_NotesMaster = *NewCT_NotesMaster()
_aefca:
	for {
		_ggeg, _dgaca := d.Token()
		if _dgaca != nil {
			return _dgaca
		}
		switch _cfgcg := _ggeg.(type) {
		case _e.StartElement:
			switch _cfgcg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _daadae := d.DecodeElement(_gfeed.CSld, &_cfgcg); _daadae != nil {
					return _daadae
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMap"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMap"}:
				if _cdbb := d.DecodeElement(_gfeed.ClrMap, &_cfgcg); _cdbb != nil {
					return _cdbb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "hf"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "hf"}:
				_gfeed.Hf = NewCT_HeaderFooter()
				if _baac := d.DecodeElement(_gfeed.Hf, &_cfgcg); _baac != nil {
					return _baac
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "notesStyle"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "notesStyle"}:
				_gfeed.NotesStyle = _cb.NewCT_TextListStyle()
				if _eafe := d.DecodeElement(_gfeed.NotesStyle, &_cfgcg); _eafe != nil {
					return _eafe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_gfeed.ExtLst = NewCT_ExtensionListModify()
				if _abaga := d.DecodeElement(_gfeed.ExtLst, &_cfgcg); _abaga != nil {
					return _abaga
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020NotesMaster\u0020\u0025v", _cfgcg.Name)
				if _fggce := d.Skip(); _fggce != nil {
					return _fggce
				}
			}
		case _e.EndElement:
			break _aefca
		case _e.CharData:
		}
	}
	return nil
}
func (_cagafg *CT_TLAnimVariantFloatVal) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _bdbfa := range start.Attr {
		if _bdbfa.Name.Local == "val" {
			_ffcdd, _gddaf := _b.ParseFloat(_bdbfa.Value, 64)
			if _gddaf != nil {
				return _gddaf
			}
			_cagafg.ValAttr = float32(_ffcdd)
			continue
		}
	}
	for {
		_gcdff, _degcg := d.Token()
		if _degcg != nil {
			return _c.Errorf("parsing CT_TLAnimVariantFloatVal:\u0020%s", _degcg)
		}
		if _ecdcb, _fcdeb := _gcdff.(_e.EndElement); _fcdeb && _ecdcb.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_CommentAuthor() *CT_CommentAuthor { _cgdd := &CT_CommentAuthor{}; return _cgdd }
func (_gcab *CT_EmbeddedFontList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _gcab.EmbeddedFont != nil {
		_efcg := _e.StartElement{Name: _e.Name{Local: "p:embeddedFont"}}
		for _, _ebd := range _gcab.EmbeddedFont {
			e.EncodeElement(_ebd, _efcg)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_TLAnimateRotationBehavior struct {

	// By
	ByAttr *int32

	// From
	FromAttr *int32

	// To
	ToAttr *int32
	CBhvr  *CT_TLCommonBehaviorData
}

func NewCT_ConnectorNonVisual() *CT_ConnectorNonVisual {
	_bda := &CT_ConnectorNonVisual{}
	_bda.CNvPr = _cb.NewCT_NonVisualDrawingProps()
	_bda.CNvCxnSpPr = _cb.NewCT_NonVisualConnectorProperties()
	_bda.NvPr = NewCT_ApplicationNonVisualDrawingProps()
	return _bda
}

// ValidateWithPath validates the CT_NotesViewProperties and its children, prefixing error messages with path
func (_bebbb *CT_NotesViewProperties) ValidateWithPath(path string) error {
	if _gefb := _bebbb.CSldViewPr.ValidateWithPath(path + "/CSldViewPr"); _gefb != nil {
		return _gefb
	}
	if _bebbb.ExtLst != nil {
		if _fcee := _bebbb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _fcee != nil {
			return _fcee
		}
	}
	return nil
}
func (_geadb *CT_TLCommonBehaviorData) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _geadb.AdditiveAttr != ST_TLBehaviorAdditiveTypeUnset {
		_gaecc, _adcdd := _geadb.AdditiveAttr.MarshalXMLAttr(_e.Name{Local: "additive"})
		if _adcdd != nil {
			return _adcdd
		}
		start.Attr = append(start.Attr, _gaecc)
	}
	if _geadb.AccumulateAttr != ST_TLBehaviorAccumulateTypeUnset {
		_adda, _dadae := _geadb.AccumulateAttr.MarshalXMLAttr(_e.Name{Local: "accumulate"})
		if _dadae != nil {
			return _dadae
		}
		start.Attr = append(start.Attr, _adda)
	}
	if _geadb.XfrmTypeAttr != ST_TLBehaviorTransformTypeUnset {
		_fefbcc, _cagc := _geadb.XfrmTypeAttr.MarshalXMLAttr(_e.Name{Local: "xfrmType"})
		if _cagc != nil {
			return _cagc
		}
		start.Attr = append(start.Attr, _fefbcc)
	}
	if _geadb.FromAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "from"}, Value: _c.Sprintf("\u0025v", *_geadb.FromAttr)})
	}
	if _geadb.ToAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "to"}, Value: _c.Sprintf("\u0025v", *_geadb.ToAttr)})
	}
	if _geadb.ByAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "by"}, Value: _c.Sprintf("\u0025v", *_geadb.ByAttr)})
	}
	if _geadb.RctxAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "rctx"}, Value: _c.Sprintf("\u0025v", *_geadb.RctxAttr)})
	}
	if _geadb.OverrideAttr != ST_TLBehaviorOverrideTypeUnset {
		_ffeb, _cdbcb := _geadb.OverrideAttr.MarshalXMLAttr(_e.Name{Local: "override"})
		if _cdbcb != nil {
			return _cdbcb
		}
		start.Attr = append(start.Attr, _ffeb)
	}
	e.EncodeToken(start)
	_baeed := _e.StartElement{Name: _e.Name{Local: "p:cTn"}}
	e.EncodeElement(_geadb.CTn, _baeed)
	_bfcbg := _e.StartElement{Name: _e.Name{Local: "p:tgtEl"}}
	e.EncodeElement(_geadb.TgtEl, _bfcbg)
	if _geadb.AttrNameLst != nil {
		_cbdde := _e.StartElement{Name: _e.Name{Local: "p:attrNameLst"}}
		e.EncodeElement(_geadb.AttrNameLst, _cbdde)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_gadbc *CT_Kinsoku) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gadbc.LangAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "lang"}, Value: _c.Sprintf("\u0025v", *_gadbc.LangAttr)})
	}
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "invalStChars"}, Value: _c.Sprintf("\u0025v", _gadbc.InvalStCharsAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "invalEndChars"}, Value: _c.Sprintf("\u0025v", _gadbc.InvalEndCharsAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_NotesSlide() *CT_NotesSlide {
	_aeee := &CT_NotesSlide{}
	_aeee.CSld = NewCT_CommonSlideData()
	return _aeee
}
func (_ebcaa *CT_SlideLayoutIdListEntry) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ebcaa.IdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "id"}, Value: _c.Sprintf("\u0025v", *_ebcaa.IdAttr)})
	}
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _ebcaa.RIdAttr)})
	e.EncodeToken(start)
	if _ebcaa.ExtLst != nil {
		_eaaba := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ebcaa.ExtLst, _eaaba)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_EmbeddedFontDataId() *CT_EmbeddedFontDataId {
	_ffae := &CT_EmbeddedFontDataId{}
	return _ffae
}
func (_gae *CT_NotesViewProperties) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_gcbg := _e.StartElement{Name: _e.Name{Local: "p:cSldViewPr"}}
	e.EncodeElement(_gae.CSldViewPr, _gcbg)
	if _gae.ExtLst != nil {
		_ecac := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_gae.ExtLst, _ecac)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SlideViewProperties and its children
func (_cedda *CT_SlideViewProperties) Validate() error {
	return _cedda.ValidateWithPath("CT_SlideViewProperties")
}
func (_ebgfg *ST_PlaceholderSize) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_ebgfg = 0
	case "full":
		*_ebgfg = 1
	case "half":
		*_ebgfg = 2
	case "quarter":
		*_ebgfg = 3
	}
	return nil
}

// ValidateWithPath validates the CT_SideDirectionTransition and its children, prefixing error messages with path
func (_cacd *CT_SideDirectionTransition) ValidateWithPath(path string) error {
	if _cedg := _cacd.DirAttr.ValidateWithPath(path + "\u002fDirAttr"); _cedg != nil {
		return _cedg
	}
	return nil
}
func (_gbebc *CmAuthorLst) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gbebc.CT_CommentAuthorList = *NewCT_CommentAuthorList()
_dfcc:
	for {
		_bfcaca, _gdff := d.Token()
		if _gdff != nil {
			return _gdff
		}
		switch _fbcc := _bfcaca.(type) {
		case _e.StartElement:
			switch _fbcc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cmAuthor"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cmAuthor"}:
				_fgdea := NewCT_CommentAuthor()
				if _acbf := d.DecodeElement(_fgdea, &_fbcc); _acbf != nil {
					return _acbf
				}
				_gbebc.CmAuthor = append(_gbebc.CmAuthor, _fgdea)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CmAuthorLst\u0020\u0025v", _fbcc.Name)
				if _egcge := d.Skip(); _egcge != nil {
					return _egcge
				}
			}
		case _e.EndElement:
			break _dfcc
		case _e.CharData:
		}
	}
	return nil
}

type ST_TransitionInOutDirectionType byte
type CT_SlideRelationshipList struct {

	// Presentation Slide
	Sld []*CT_SlideRelationshipListEntry
}

func (_aegffe *ST_PrintWhat) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_ffbbdd, _bcgcc := d.Token()
	if _bcgcc != nil {
		return _bcgcc
	}
	if _fcafa, _bfbcg := _ffbbdd.(_e.EndElement); _bfbcg && _fcafa.Name == start.Name {
		*_aegffe = 1
		return nil
	}
	if _abdfg, _cbcab := _ffbbdd.(_e.CharData); !_cbcab {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ffbbdd)
	} else {
		switch string(_abdfg) {
		case "":
			*_aegffe = 0
		case "slides":
			*_aegffe = 1
		case "handouts1":
			*_aegffe = 2
		case "handouts2":
			*_aegffe = 3
		case "handouts3":
			*_aegffe = 4
		case "handouts4":
			*_aegffe = 5
		case "handouts6":
			*_aegffe = 6
		case "handouts9":
			*_aegffe = 7
		case "notes":
			*_aegffe = 8
		case "outline":
			*_aegffe = 9
		}
	}
	_ffbbdd, _bcgcc = d.Token()
	if _bcgcc != nil {
		return _bcgcc
	}
	if _eabgf, _gaagb := _ffbbdd.(_e.EndElement); _gaagb && _eabgf.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ffbbdd)
}
func NewCT_TLTemplateList() *CT_TLTemplateList { _bacb := &CT_TLTemplateList{}; return _bacb }

type PresentationPr struct{ CT_PresentationProperties }
type CT_CustomerData struct{ IdAttr string }

func (_aagb *CT_TLAnimVariantBooleanVal) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _dggfd := range start.Attr {
		if _dggfd.Name.Local == "val" {
			_befaff, _ecfbd := _b.ParseBool(_dggfd.Value)
			if _ecfbd != nil {
				return _ecfbd
			}
			_aagb.ValAttr = _befaff
			continue
		}
	}
	for {
		_gddg, _dgcc := d.Token()
		if _dgcc != nil {
			return _c.Errorf("parsing\u0020CT_TLAnimVariantBooleanVal:\u0020\u0025s", _dgcc)
		}
		if _cgcde, _befda := _gddg.(_e.EndElement); _befda && _cgcde.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dde *CT_EmbeddedFontList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_dad:
	for {
		_gfa, _dced := d.Token()
		if _dced != nil {
			return _dced
		}
		switch _ebae := _gfa.(type) {
		case _e.StartElement:
			switch _ebae.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "embeddedFont"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "embeddedFont"}:
				_dccg := NewCT_EmbeddedFontListEntry()
				if _cgeb := d.DecodeElement(_dccg, &_ebae); _cgeb != nil {
					return _cgeb
				}
				_dde.EmbeddedFont = append(_dde.EmbeddedFont, _dccg)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_EmbeddedFontList\u0020\u0025v", _ebae.Name)
				if _badd := d.Skip(); _badd != nil {
					return _badd
				}
			}
		case _e.EndElement:
			break _dad
		case _e.CharData:
		}
	}
	return nil
}
func (_afgf *CT_HandoutMaster) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_afgf.CSld = NewCT_CommonSlideData()
	_afgf.ClrMap = _cb.NewCT_ColorMapping()
_ceced:
	for {
		_becd, _ffabe := d.Token()
		if _ffabe != nil {
			return _ffabe
		}
		switch _dfbef := _becd.(type) {
		case _e.StartElement:
			switch _dfbef.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _gafdb := d.DecodeElement(_afgf.CSld, &_dfbef); _gafdb != nil {
					return _gafdb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMap"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMap"}:
				if _gefg := d.DecodeElement(_afgf.ClrMap, &_dfbef); _gefg != nil {
					return _gefg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "hf"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "hf"}:
				_afgf.Hf = NewCT_HeaderFooter()
				if _bdcf := d.DecodeElement(_afgf.Hf, &_dfbef); _bdcf != nil {
					return _bdcf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_afgf.ExtLst = NewCT_ExtensionListModify()
				if _abdda := d.DecodeElement(_afgf.ExtLst, &_dfbef); _abdda != nil {
					return _abdda
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_HandoutMaster\u0020\u0025v", _dfbef.Name)
				if _ccdcc := d.Skip(); _ccdcc != nil {
					return _ccdcc
				}
			}
		case _e.EndElement:
			break _ceced
		case _e.CharData:
		}
	}
	return nil
}
func (_dafg ST_TLPreviousActionType) Validate() error { return _dafg.ValidateWithPath("") }

type ST_TransitionSideDirectionType byte

func (_dfcgd *CT_TLTimeConditionList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_bdcc:
	for {
		_ffaf, _gege := d.Token()
		if _gege != nil {
			return _gege
		}
		switch _bcdbf := _ffaf.(type) {
		case _e.StartElement:
			switch _bcdbf.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cond"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cond"}:
				_ebaed := NewCT_TLTimeCondition()
				if _ebce := d.DecodeElement(_ebaed, &_bcdbf); _ebce != nil {
					return _ebce
				}
				_dfcgd.Cond = append(_dfcgd.Cond, _ebaed)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLTimeConditionList\u0020\u0025v", _bcdbf.Name)
				if _abbbg := d.Skip(); _abbbg != nil {
					return _abbbg
				}
			}
		case _e.EndElement:
			break _bdcc
		case _e.CharData:
		}
	}
	return nil
}
func (_cdfgc *CT_SlideIdListEntry) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "id"}, Value: _c.Sprintf("\u0025v", _cdfgc.IdAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _cdfgc.RIdAttr)})
	e.EncodeToken(start)
	if _cdfgc.ExtLst != nil {
		_baedc := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_cdfgc.ExtLst, _baedc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SlideIdListEntry and its children
func (_egge *CT_SlideIdListEntry) Validate() error {
	return _egge.ValidateWithPath("CT_SlideIdListEntry")
}
func (_afda *CT_SlideRelationshipList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _afda.Sld != nil {
		_agbba := _e.StartElement{Name: _e.Name{Local: "p:sld"}}
		for _, _fbdada := range _afda.Sld {
			e.EncodeElement(_fbdada, _agbba)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_ddgd *CT_ExtensionListModify) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ddgd.ModAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "mod"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ddgd.ModAttr))})
	}
	e.EncodeToken(start)
	if _ddgd.Ext != nil {
		_efbe := _e.StartElement{Name: _e.Name{Local: "p:ext"}}
		for _, _dcbf := range _ddgd.Ext {
			e.EncodeElement(_dcbf, _efbe)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TLCommonBehaviorData and its children
func (_eacdd *CT_TLCommonBehaviorData) Validate() error {
	return _eacdd.ValidateWithPath("CT_TLCommonBehaviorData")
}
func (_cddfe ST_PhotoAlbumLayout) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_cddfe.String(), start)
}

// Validate validates the CT_TLSubShapeId and its children
func (_abccd *CT_TLSubShapeId) Validate() error { return _abccd.ValidateWithPath("CT_TLSubShapeId") }

type Notes struct{ CT_NotesSlide }

func (_afffe *ST_TLPreviousActionType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_afffe = 0
	case "none":
		*_afffe = 1
	case "skipTimed":
		*_afffe = 2
	}
	return nil
}

// ValidateWithPath validates the CT_TLTimeConditionList and its children, prefixing error messages with path
func (_aacd *CT_TLTimeConditionList) ValidateWithPath(path string) error {
	for _fgegg, _gfggg := range _aacd.Cond {
		if _egeg := _gfggg.ValidateWithPath(_c.Sprintf("%s\u002fCond\u005b\u0025d\u005d", path, _fgegg)); _egeg != nil {
			return _egeg
		}
	}
	return nil
}

type CT_Empty struct{}

func (_ebggg ST_TLNextActionType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_ebggg.String(), start)
}
func NewSld() *Sld { _cabfd := &Sld{}; _cabfd.CT_Slide = *NewCT_Slide(); return _cabfd }

// Validate validates the CT_TLTimeCondition and its children
func (_ebdcc *CT_TLTimeCondition) Validate() error {
	return _ebdcc.ValidateWithPath("CT_TLTimeCondition")
}

// ValidateWithPath validates the CT_ViewProperties and its children, prefixing error messages with path
func (_dcff *CT_ViewProperties) ValidateWithPath(path string) error {
	if _cgaag := _dcff.LastViewAttr.ValidateWithPath(path + "\u002fLastViewAttr"); _cgaag != nil {
		return _cgaag
	}
	if _dcff.NormalViewPr != nil {
		if _aeeca := _dcff.NormalViewPr.ValidateWithPath(path + "\u002fNormalViewPr"); _aeeca != nil {
			return _aeeca
		}
	}
	if _dcff.SlideViewPr != nil {
		if _bgecf := _dcff.SlideViewPr.ValidateWithPath(path + "\u002fSlideViewPr"); _bgecf != nil {
			return _bgecf
		}
	}
	if _dcff.OutlineViewPr != nil {
		if _eaeg := _dcff.OutlineViewPr.ValidateWithPath(path + "\u002fOutlineViewPr"); _eaeg != nil {
			return _eaeg
		}
	}
	if _dcff.NotesTextViewPr != nil {
		if _ceedc := _dcff.NotesTextViewPr.ValidateWithPath(path + "\u002fNotesTextViewPr"); _ceedc != nil {
			return _ceedc
		}
	}
	if _dcff.SorterViewPr != nil {
		if _gabgg := _dcff.SorterViewPr.ValidateWithPath(path + "\u002fSorterViewPr"); _gabgg != nil {
			return _gabgg
		}
	}
	if _dcff.NotesViewPr != nil {
		if _efcee := _dcff.NotesViewPr.ValidateWithPath(path + "\u002fNotesViewPr"); _efcee != nil {
			return _efcee
		}
	}
	if _dcff.GridSpacing != nil {
		if _fbgc := _dcff.GridSpacing.ValidateWithPath(path + "\u002fGridSpacing"); _fbgc != nil {
			return _fbgc
		}
	}
	if _dcff.ExtLst != nil {
		if _acdg := _dcff.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _acdg != nil {
			return _acdg
		}
	}
	return nil
}
func (_gddcf ST_TLAnimateMotionBehaviorOrigin) ValidateWithPath(path string) error {
	switch _gddcf {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gddcf))
	}
	return nil
}
func (_gccf *CT_ShowProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _bgda := range start.Attr {
		if _bgda.Name.Local == "loop" {
			_gccaf, _gacf := _b.ParseBool(_bgda.Value)
			if _gacf != nil {
				return _gacf
			}
			_gccf.LoopAttr = &_gccaf
			continue
		}
		if _bgda.Name.Local == "showNarration" {
			_aeab, _eebcf := _b.ParseBool(_bgda.Value)
			if _eebcf != nil {
				return _eebcf
			}
			_gccf.ShowNarrationAttr = &_aeab
			continue
		}
		if _bgda.Name.Local == "showAnimation" {
			_gffed, _ebeg := _b.ParseBool(_bgda.Value)
			if _ebeg != nil {
				return _ebeg
			}
			_gccf.ShowAnimationAttr = &_gffed
			continue
		}
		if _bgda.Name.Local == "useTimings" {
			_dbac, _ffcd := _b.ParseBool(_bgda.Value)
			if _ffcd != nil {
				return _ffcd
			}
			_gccf.UseTimingsAttr = &_dbac
			continue
		}
	}
_ebgf:
	for {
		_cdea, _fcgbd := d.Token()
		if _fcgbd != nil {
			return _fcgbd
		}
		switch _bdgg := _cdea.(type) {
		case _e.StartElement:
			switch _bdgg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "present"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "present"}:
				_gccf.Present = NewCT_Empty()
				if _egbge := d.DecodeElement(_gccf.Present, &_bdgg); _egbge != nil {
					return _egbge
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "browse"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "browse"}:
				_gccf.Browse = NewCT_ShowInfoBrowse()
				if _bcdd := d.DecodeElement(_gccf.Browse, &_bdgg); _bcdd != nil {
					return _bcdd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "kiosk"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "kiosk"}:
				_gccf.Kiosk = NewCT_ShowInfoKiosk()
				if _bbgb := d.DecodeElement(_gccf.Kiosk, &_bdgg); _bbgb != nil {
					return _bbgb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldAll"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldAll"}:
				_gccf.SldAll = NewCT_Empty()
				if _ecbg := d.DecodeElement(_gccf.SldAll, &_bdgg); _ecbg != nil {
					return _ecbg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldRg"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldRg"}:
				_gccf.SldRg = NewCT_IndexRange()
				if _aefbf := d.DecodeElement(_gccf.SldRg, &_bdgg); _aefbf != nil {
					return _aefbf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "custShow"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "custShow"}:
				_gccf.CustShow = NewCT_CustomShowId()
				if _fgcg := d.DecodeElement(_gccf.CustShow, &_bdgg); _fgcg != nil {
					return _fgcg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "penClr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "penClr"}:
				_gccf.PenClr = _cb.NewCT_Color()
				if _ecdc := d.DecodeElement(_gccf.PenClr, &_bdgg); _ecdc != nil {
					return _ecdc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_gccf.ExtLst = NewCT_ExtensionList()
				if _cdcg := d.DecodeElement(_gccf.ExtLst, &_bdgg); _cdcg != nil {
					return _cdcg
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_ShowProperties\u0020\u0025v", _bdgg.Name)
				if _adbf := d.Skip(); _adbf != nil {
					return _adbf
				}
			}
		case _e.EndElement:
			break _ebgf
		case _e.CharData:
		}
	}
	return nil
}

type CT_TLTimeTargetElement struct {

	// Slide Target
	SldTgt *CT_Empty

	// Sound Target
	SndTgt *_cb.CT_EmbeddedWAVAudioFile

	// Shape Target
	SpTgt *CT_TLShapeTargetElement

	// Ink Target
	InkTgt *CT_TLSubShapeId
}

func (_eaegc *CmLst) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:cmLst"
	return _eaegc.CT_CommentList.MarshalXML(e, start)
}
func (_gagga *ViewPr) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:viewPr"
	return _gagga.CT_ViewProperties.MarshalXML(e, start)
}

// Validate validates the AG_Ole and its children
func (_df *AG_Ole) Validate() error { return _df.ValidateWithPath("AG_Ole") }

type CT_CustomShow struct {

	// Custom Show Name
	NameAttr string

	// Custom Show ID
	IdAttr uint32

	// List of Presentation Slides
	SldLst *CT_SlideRelationshipList
	ExtLst *CT_ExtensionList
}

func NewCT_NormalViewProperties() *CT_NormalViewProperties {
	_bbgg := &CT_NormalViewProperties{}
	_bbgg.RestoredLeft = NewCT_NormalViewPortion()
	_bbgg.RestoredTop = NewCT_NormalViewPortion()
	return _bbgg
}
func (_gbcdd ST_Direction) ValidateWithPath(path string) error {
	switch _gbcdd {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gbcdd))
	}
	return nil
}
func (_gagag ST_TLAnimateColorDirection) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_gagag.String(), start)
}
func (_cabd *CT_TLTextTargetElement) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _cabd.CharRg != nil {
		_bfdfc := _e.StartElement{Name: _e.Name{Local: "p:charRg"}}
		e.EncodeElement(_cabd.CharRg, _bfdfc)
	}
	if _cabd.PRg != nil {
		_gaefg := _e.StartElement{Name: _e.Name{Local: "p:pRg"}}
		e.EncodeElement(_cabd.PRg, _gaefg)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type AG_TLBuild struct {
	SpidAttr     *uint32
	GrpIdAttr    *uint32
	UiExpandAttr *bool
}

// ValidateWithPath validates the CT_PictureNonVisual and its children, prefixing error messages with path
func (_eeda *CT_PictureNonVisual) ValidateWithPath(path string) error {
	if _dabea := _eeda.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _dabea != nil {
		return _dabea
	}
	if _dcbb := _eeda.CNvPicPr.ValidateWithPath(path + "\u002fCNvPicPr"); _dcbb != nil {
		return _dcbb
	}
	if _abbf := _eeda.NvPr.ValidateWithPath(path + "\u002fNvPr"); _abbf != nil {
		return _abbf
	}
	return nil
}
func (_abdad *CT_PictureNonVisual) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_gaeg := _e.StartElement{Name: _e.Name{Local: "p:cNvPr"}}
	e.EncodeElement(_abdad.CNvPr, _gaeg)
	_afccf := _e.StartElement{Name: _e.Name{Local: "p:cNvPicPr"}}
	e.EncodeElement(_abdad.CNvPicPr, _afccf)
	_egfe := _e.StartElement{Name: _e.Name{Local: "p:nvPr"}}
	e.EncodeElement(_abdad.NvPr, _egfe)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

const (
	ST_TransitionCornerDirectionTypeUnset ST_TransitionCornerDirectionType = 0
	ST_TransitionCornerDirectionTypeLu    ST_TransitionCornerDirectionType = 1
	ST_TransitionCornerDirectionTypeRu    ST_TransitionCornerDirectionType = 2
	ST_TransitionCornerDirectionTypeLd    ST_TransitionCornerDirectionType = 3
	ST_TransitionCornerDirectionTypeRd    ST_TransitionCornerDirectionType = 4
)
const (
	ST_TLBehaviorAdditiveTypeUnset ST_TLBehaviorAdditiveType = 0
	ST_TLBehaviorAdditiveTypeBase  ST_TLBehaviorAdditiveType = 1
	ST_TLBehaviorAdditiveTypeSum   ST_TLBehaviorAdditiveType = 2
	ST_TLBehaviorAdditiveTypeRepl  ST_TLBehaviorAdditiveType = 3
	ST_TLBehaviorAdditiveTypeMult  ST_TLBehaviorAdditiveType = 4
	ST_TLBehaviorAdditiveTypeNone  ST_TLBehaviorAdditiveType = 5
)

// ValidateWithPath validates the CT_OleObjectEmbed and its children, prefixing error messages with path
func (_agce *CT_OleObjectEmbed) ValidateWithPath(path string) error {
	if _afccc := _agce.FollowColorSchemeAttr.ValidateWithPath(path + "\u002fFollowColorSchemeAttr"); _afccc != nil {
		return _afccc
	}
	if _agce.ExtLst != nil {
		if _efab := _agce.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _efab != nil {
			return _efab
		}
	}
	return nil
}
func (_gbee *CT_GraphicalObjectFrame) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gbee.NvGraphicFramePr = NewCT_GraphicalObjectFrameNonVisual()
	_gbee.Xfrm = _cb.NewCT_Transform2D()
	_gbee.Graphic = _cb.NewGraphic()
	for _, _efda := range start.Attr {
		if _efda.Name.Local == "bwMode" {
			_gbee.BwModeAttr.UnmarshalXMLAttr(_efda)
			continue
		}
	}
_beac:
	for {
		_bbda, _bfde := d.Token()
		if _bfde != nil {
			return _bfde
		}
		switch _acbg := _bbda.(type) {
		case _e.StartElement:
			switch _acbg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "nvGraphicFramePr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "nvGraphicFramePr"}:
				if _cgac := d.DecodeElement(_gbee.NvGraphicFramePr, &_acbg); _cgac != nil {
					return _cgac
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "xfrm"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "xfrm"}:
				if _ddgc := d.DecodeElement(_gbee.Xfrm, &_acbg); _ddgc != nil {
					return _ddgc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "graphic"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "graphic"}:
				if _ecg := d.DecodeElement(_gbee.Graphic, &_acbg); _ecg != nil {
					return _ecg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_gbee.ExtLst = NewCT_ExtensionListModify()
				if _fda := d.DecodeElement(_gbee.ExtLst, &_acbg); _fda != nil {
					return _fda
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_GraphicalObjectFrame \u0025v", _acbg.Name)
				if _cdaaf := d.Skip(); _cdaaf != nil {
					return _cdaaf
				}
			}
		case _e.EndElement:
			break _beac
		case _e.CharData:
		}
	}
	return nil
}
func NewCT_CommonSlideViewProperties() *CT_CommonSlideViewProperties {
	_dfaac := &CT_CommonSlideViewProperties{}
	_dfaac.CViewPr = NewCT_CommonViewProperties()
	return _dfaac
}

type CT_ModifyVerifier struct {

	// Cryptographic Algorithm Name
	AlgorithmNameAttr *string

	// Password Hash Value
	HashValueAttr *string

	// Salt Value for Password Verifier
	SaltValueAttr *string

	// Iterations to Run Hashing Algorithm
	SpinValueAttr *uint32

	// Cryptographic Provider Type
	CryptProviderTypeAttr _d.ST_CryptProv

	// Cryptographic Algorithm Class
	CryptAlgorithmClassAttr _d.ST_AlgClass

	// Cryptographic Algorithm Type
	CryptAlgorithmTypeAttr _d.ST_AlgType

	// Cryptographic Hashing Algorithm
	CryptAlgorithmSidAttr *uint32

	// Iterations to Run Hashing Algorithm
	SpinCountAttr *uint32

	// Salt for Password Verifier
	SaltDataAttr *string

	// Password Hash
	HashDataAttr *string

	// Cryptographic Provider
	CryptProviderAttr *string

	// Cryptographic Algorithm Extensibility
	AlgIdExtAttr *uint32

	// Algorithm Extensibility Source
	AlgIdExtSourceAttr *string

	// Cryptographic Provider Type Extensibility
	CryptProviderTypeExtAttr *uint32

	// Provider Type Extensibility Source
	CryptProviderTypeExtSourceAttr *string
}
type CT_Connector struct {

	// Non-Visual Properties for a Connection Shape
	NvCxnSpPr *CT_ConnectorNonVisual

	// Shape Properties
	SpPr *_cb.CT_ShapeProperties

	// Connector Shape Style
	Style  *_cb.CT_ShapeStyle
	ExtLst *CT_ExtensionListModify
}

func (_ebdaf *ST_PhotoAlbumLayout) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fddde, _cadac := d.Token()
	if _cadac != nil {
		return _cadac
	}
	if _afbbb, _cdfcd := _fddde.(_e.EndElement); _cdfcd && _afbbb.Name == start.Name {
		*_ebdaf = 1
		return nil
	}
	if _eafb, _ceagg := _fddde.(_e.CharData); !_ceagg {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fddde)
	} else {
		switch string(_eafb) {
		case "":
			*_ebdaf = 0
		case "fitToSlide":
			*_ebdaf = 1
		case "1pic":
			*_ebdaf = 2
		case "2pic":
			*_ebdaf = 3
		case "4pic":
			*_ebdaf = 4
		case "1picTitle":
			*_ebdaf = 5
		case "2picTitle":
			*_ebdaf = 6
		case "4picTitle":
			*_ebdaf = 7
		}
	}
	_fddde, _cadac = d.Token()
	if _cadac != nil {
		return _cadac
	}
	if _cebde, _adgad := _fddde.(_e.EndElement); _adgad && _cebde.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fddde)
}
func NewEG_SlideListChoice() *EG_SlideListChoice { _cggdc := &EG_SlideListChoice{}; return _cggdc }
func (_bdcab ST_TLTimeNodeType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_bdcab.String(), start)
}
func (_adfac ST_WebColorType) String() string {
	switch _adfac {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "browser"
	case 3:
		return "presentationText"
	case 4:
		return "presentationAccent"
	case 5:
		return "whiteTextOnBlack"
	case 6:
		return "blackTextOnWhite"
	}
	return ""
}
func NewCT_NotesViewProperties() *CT_NotesViewProperties {
	_agc := &CT_NotesViewProperties{}
	_agc.CSldViewPr = NewCT_CommonSlideViewProperties()
	return _agc
}
func NewCT_SlideLayoutIdList() *CT_SlideLayoutIdList { _dbgd := &CT_SlideLayoutIdList{}; return _dbgd }
func (_dfcbd *CT_TLCommonMediaNodeData) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _dfcbd.VolAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "vol"}, Value: _c.Sprintf("\u0025v", *_dfcbd.VolAttr)})
	}
	if _dfcbd.MuteAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "mute"}, Value: _c.Sprintf("\u0025d", _fdeab(*_dfcbd.MuteAttr))})
	}
	if _dfcbd.NumSldAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "numSld"}, Value: _c.Sprintf("\u0025v", *_dfcbd.NumSldAttr)})
	}
	if _dfcbd.ShowWhenStoppedAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showWhenStopped"}, Value: _c.Sprintf("\u0025d", _fdeab(*_dfcbd.ShowWhenStoppedAttr))})
	}
	e.EncodeToken(start)
	_gadbe := _e.StartElement{Name: _e.Name{Local: "p:cTn"}}
	e.EncodeElement(_dfcbd.CTn, _gadbe)
	_affce := _e.StartElement{Name: _e.Name{Local: "p:tgtEl"}}
	e.EncodeElement(_dfcbd.TgtEl, _affce)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_gcgg ST_TLCommandType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_adge := _e.Attr{}
	_adge.Name = name
	switch _gcgg {
	case ST_TLCommandTypeUnset:
		_adge.Value = ""
	case ST_TLCommandTypeEvt:
		_adge.Value = "evt"
	case ST_TLCommandTypeCall:
		_adge.Value = "call"
	case ST_TLCommandTypeVerb:
		_adge.Value = "verb"
	}
	return _adge, nil
}

type ViewPr struct{ CT_ViewProperties }

func (_egbfd *CT_TLTimeCondition) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _egbfd.EvtAttr != ST_TLTriggerEventUnset {
		_ageeg, _fadaf := _egbfd.EvtAttr.MarshalXMLAttr(_e.Name{Local: "evt"})
		if _fadaf != nil {
			return _fadaf
		}
		start.Attr = append(start.Attr, _ageeg)
	}
	if _egbfd.DelayAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "delay"}, Value: _c.Sprintf("\u0025v", *_egbfd.DelayAttr)})
	}
	e.EncodeToken(start)
	if _egbfd.TgtEl != nil {
		_bebea := _e.StartElement{Name: _e.Name{Local: "p:tgtEl"}}
		e.EncodeElement(_egbfd.TgtEl, _bebea)
	}
	if _egbfd.Tn != nil {
		_dgfge := _e.StartElement{Name: _e.Name{Local: "p:tn"}}
		e.EncodeElement(_egbfd.Tn, _dgfge)
	}
	if _egbfd.Rtn != nil {
		_dddc := _e.StartElement{Name: _e.Name{Local: "p:rtn"}}
		e.EncodeElement(_egbfd.Rtn, _dddc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_TLBuildDiagram struct {

	// Diagram Build Types
	BldAttr      ST_TLDiagramBuildType
	SpidAttr     *uint32
	GrpIdAttr    *uint32
	UiExpandAttr *bool
}

func (_egfae *CT_StringTag) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _ffdab := range start.Attr {
		if _ffdab.Name.Local == "name" {
			_dgfec, _geade := _ffdab.Value, error(nil)
			if _geade != nil {
				return _geade
			}
			_egfae.NameAttr = _dgfec
			continue
		}
		if _ffdab.Name.Local == "val" {
			_bbea, _ccdcf := _ffdab.Value, error(nil)
			if _ccdcf != nil {
				return _ccdcf
			}
			_egfae.ValAttr = _bbea
			continue
		}
	}
	for {
		_efaa, _adcbg := d.Token()
		if _adcbg != nil {
			return _c.Errorf("parsing\u0020CT_StringTag:\u0020\u0025s", _adcbg)
		}
		if _aefag, _gggce := _efaa.(_e.EndElement); _gggce && _aefag.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dbgbe *CT_TLIterateData) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cbgg := range start.Attr {
		if _cbgg.Name.Local == "type" {
			_dbgbe.TypeAttr.UnmarshalXMLAttr(_cbgg)
			continue
		}
		if _cbgg.Name.Local == "backwards" {
			_cbbadb, _egcae := _b.ParseBool(_cbgg.Value)
			if _egcae != nil {
				return _egcae
			}
			_dbgbe.BackwardsAttr = &_cbbadb
			continue
		}
	}
_aedg:
	for {
		_gcbfe, _baccg := d.Token()
		if _baccg != nil {
			return _baccg
		}
		switch _abcca := _gcbfe.(type) {
		case _e.StartElement:
			switch _abcca.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tmAbs"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tmAbs"}:
				_dbgbe.TmAbs = NewCT_TLIterateIntervalTime()
				if _bcbg := d.DecodeElement(_dbgbe.TmAbs, &_abcca); _bcbg != nil {
					return _bcbg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tmPct"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tmPct"}:
				_dbgbe.TmPct = NewCT_TLIterateIntervalPercentage()
				if _ddfg := d.DecodeElement(_dbgbe.TmPct, &_abcca); _ddfg != nil {
					return _ddfg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLIterateData\u0020\u0025v", _abcca.Name)
				if _bfaee := d.Skip(); _bfaee != nil {
					return _bfaee
				}
			}
		case _e.EndElement:
			break _aedg
		case _e.CharData:
		}
	}
	return nil
}

type CT_NotesMaster struct {

	// Common Slide Data
	CSld *CT_CommonSlideData

	// Color Scheme Map
	ClrMap *_cb.CT_ColorMapping

	// Header/Footer Information for a Notes Master
	Hf *CT_HeaderFooter

	// Notes Text Style
	NotesStyle *_cb.CT_TextListStyle
	ExtLst     *CT_ExtensionListModify
}

// Validate validates the CT_GroupShapeChoice and its children
func (_eceg *CT_GroupShapeChoice) Validate() error {
	return _eceg.ValidateWithPath("CT_GroupShapeChoice")
}
func NewCT_BuildList() *CT_BuildList { _bdb := &CT_BuildList{}; return _bdb }

const (
	ST_SplitterBarStateUnset     ST_SplitterBarState = 0
	ST_SplitterBarStateMinimized ST_SplitterBarState = 1
	ST_SplitterBarStateRestored  ST_SplitterBarState = 2
	ST_SplitterBarStateMaximized ST_SplitterBarState = 3
)

func (_efae *CT_NotesTextViewProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_efae.CViewPr = NewCT_CommonViewProperties()
_gdd:
	for {
		_ggcd, _bgdd := d.Token()
		if _bgdd != nil {
			return _bgdd
		}
		switch _acbb := _ggcd.(type) {
		case _e.StartElement:
			switch _acbb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cViewPr"}:
				if _ecaa := d.DecodeElement(_efae.CViewPr, &_acbb); _ecaa != nil {
					return _ecaa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_efae.ExtLst = NewCT_ExtensionList()
				if _ebgca := d.DecodeElement(_efae.ExtLst, &_acbb); _ebgca != nil {
					return _ebgca
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_NotesTextViewProperties\u0020\u0025v", _acbb.Name)
				if _dacd := d.Skip(); _dacd != nil {
					return _dacd
				}
			}
		case _e.EndElement:
			break _gdd
		case _e.CharData:
		}
	}
	return nil
}
func (_cdfb ST_TLAnimateMotionPathEditMode) ValidateWithPath(path string) error {
	switch _cdfb {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cdfb))
	}
	return nil
}
func (_dbca *CT_OleObject) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _dbca.ProgIdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "progId"}, Value: _c.Sprintf("\u0025v", *_dbca.ProgIdAttr)})
	}
	if _dbca.SpidAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spid"}, Value: _c.Sprintf("\u0025v", *_dbca.SpidAttr)})
	}
	if _dbca.NameAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "name"}, Value: _c.Sprintf("\u0025v", *_dbca.NameAttr)})
	}
	if _dbca.ShowAsIconAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showAsIcon"}, Value: _c.Sprintf("\u0025d", _fdeab(*_dbca.ShowAsIconAttr))})
	}
	if _dbca.IdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", *_dbca.IdAttr)})
	}
	if _dbca.ImgWAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "imgW"}, Value: _c.Sprintf("\u0025v", *_dbca.ImgWAttr)})
	}
	if _dbca.ImgHAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "imgH"}, Value: _c.Sprintf("\u0025v", *_dbca.ImgHAttr)})
	}
	e.EncodeToken(start)
	_dbca.Choice.MarshalXML(e, _e.StartElement{})
	if _dbca.Pic != nil {
		_gccc := _e.StartElement{Name: _e.Name{Local: "p:pic"}}
		e.EncodeElement(_dbca.Pic, _gccc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_geaaa ST_TLParaBuildType) String() string {
	switch _geaaa {
	case 0:
		return ""
	case 1:
		return "allAtOnce"
	case 2:
		return "p"
	case 3:
		return "cust"
	case 4:
		return "whole"
	}
	return ""
}
func NewCT_OutlineViewProperties() *CT_OutlineViewProperties {
	_fdfc := &CT_OutlineViewProperties{}
	_fdfc.CViewPr = NewCT_CommonViewProperties()
	return _fdfc
}

// Validate validates the CT_SlideRelationshipListEntry and its children
func (_cafb *CT_SlideRelationshipListEntry) Validate() error {
	return _cafb.ValidateWithPath("CT_SlideRelationshipListEntry")
}
func (_dfa *CT_ApplicationNonVisualDrawingProps) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _bdg := range start.Attr {
		if _bdg.Name.Local == "isPhoto" {
			_dca, _fag := _b.ParseBool(_bdg.Value)
			if _fag != nil {
				return _fag
			}
			_dfa.IsPhotoAttr = &_dca
			continue
		}
		if _bdg.Name.Local == "userDrawn" {
			_eaa, _gga := _b.ParseBool(_bdg.Value)
			if _gga != nil {
				return _gga
			}
			_dfa.UserDrawnAttr = &_eaa
			continue
		}
	}
_dfaa:
	for {
		_db, _cge := d.Token()
		if _cge != nil {
			return _cge
		}
		switch _ggd := _db.(type) {
		case _e.StartElement:
			switch _ggd.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "ph"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "ph"}:
				_dfa.Ph = NewCT_Placeholder()
				if _ff := d.DecodeElement(_dfa.Ph, &_ggd); _ff != nil {
					return _ff
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "audioCd"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "audioCd"}:
				_dfa.AudioCd = _cb.NewCT_AudioCD()
				if _fdb := d.DecodeElement(_dfa.AudioCd, &_ggd); _fdb != nil {
					return _fdb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "wavAudioFile"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "wavAudioFile"}:
				_dfa.WavAudioFile = _cb.NewCT_EmbeddedWAVAudioFile()
				if _ae := d.DecodeElement(_dfa.WavAudioFile, &_ggd); _ae != nil {
					return _ae
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "audioFile"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "audioFile"}:
				_dfa.AudioFile = _cb.NewCT_AudioFile()
				if _fc := d.DecodeElement(_dfa.AudioFile, &_ggd); _fc != nil {
					return _fc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "videoFile"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "videoFile"}:
				_dfa.VideoFile = _cb.NewCT_VideoFile()
				if _afa := d.DecodeElement(_dfa.VideoFile, &_ggd); _afa != nil {
					return _afa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain", Local: "quickTimeFile"}, _e.Name{Space: "http:/\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fdrawingml\u002fmain", Local: "quickTimeFile"}:
				_dfa.QuickTimeFile = _cb.NewCT_QuickTimeFile()
				if _cbc := d.DecodeElement(_dfa.QuickTimeFile, &_ggd); _cbc != nil {
					return _cbc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "custDataLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "custDataLst"}:
				_dfa.CustDataLst = NewCT_CustomerDataList()
				if _gaa := d.DecodeElement(_dfa.CustDataLst, &_ggd); _gaa != nil {
					return _gaa
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_dfa.ExtLst = NewCT_ExtensionList()
				if _bbga := d.DecodeElement(_dfa.ExtLst, &_ggd); _bbga != nil {
					return _bbga
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_ApplicationNonVisualDrawingProps \u0025v", _ggd.Name)
				if _fac := d.Skip(); _fac != nil {
					return _fac
				}
			}
		case _e.EndElement:
			break _dfaa
		case _e.CharData:
		}
	}
	return nil
}
func NewCT_TimeNodeList() *CT_TimeNodeList { _fdbbbg := &CT_TimeNodeList{}; return _fdbbbg }

type CT_GroupShape struct {

	// Non-Visual Properties for a Group Shape
	NvGrpSpPr *CT_GroupShapeNonVisual

	// Group Shape Properties
	GrpSpPr *_cb.CT_GroupShapeProperties
	Choice  []*CT_GroupShapeChoice
	ExtLst  *CT_ExtensionListModify
}

// ValidateWithPath validates the CT_HtmlPublishProperties and its children, prefixing error messages with path
func (_ddaa *CT_HtmlPublishProperties) ValidateWithPath(path string) error {
	if _ddaa.SldAll != nil {
		if _dgge := _ddaa.SldAll.ValidateWithPath(path + "\u002fSldAll"); _dgge != nil {
			return _dgge
		}
	}
	if _ddaa.SldRg != nil {
		if _fefe := _ddaa.SldRg.ValidateWithPath(path + "\u002fSldRg"); _fefe != nil {
			return _fefe
		}
	}
	if _ddaa.CustShow != nil {
		if _daeg := _ddaa.CustShow.ValidateWithPath(path + "\u002fCustShow"); _daeg != nil {
			return _daeg
		}
	}
	if _ddaa.ExtLst != nil {
		if _egca := _ddaa.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _egca != nil {
			return _egca
		}
	}
	return nil
}
func (_egeag ST_TLAnimateEffectTransition) String() string {
	switch _egeag {
	case 0:
		return ""
	case 1:
		return "in"
	case 2:
		return "out"
	case 3:
		return "none"
	}
	return ""
}

// Validate validates the EG_TopLevelSlide and its children
func (_ebgcg *EG_TopLevelSlide) Validate() error { return _ebgcg.ValidateWithPath("EG_TopLevelSlide") }

// Validate validates the CT_NormalViewPortion and its children
func (_gecb *CT_NormalViewPortion) Validate() error {
	return _gecb.ValidateWithPath("CT_NormalViewPortion")
}
func (_aggdg *CT_TLMediaNodeAudio) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_aggdg.CMediaNode = NewCT_TLCommonMediaNodeData()
	for _, _eebeg := range start.Attr {
		if _eebeg.Name.Local == "isNarration" {
			_ebcb, _fbffe := _b.ParseBool(_eebeg.Value)
			if _fbffe != nil {
				return _fbffe
			}
			_aggdg.IsNarrationAttr = &_ebcb
			continue
		}
	}
_adca:
	for {
		_dafa, _bedcg := d.Token()
		if _bedcg != nil {
			return _bedcg
		}
		switch _beed := _dafa.(type) {
		case _e.StartElement:
			switch _beed.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cMediaNode"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cMediaNode"}:
				if _ggabg := d.DecodeElement(_aggdg.CMediaNode, &_beed); _ggabg != nil {
					return _ggabg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLMediaNodeAudio\u0020\u0025v", _beed.Name)
				if _eecg := d.Skip(); _eecg != nil {
					return _eecg
				}
			}
		case _e.EndElement:
			break _adca
		case _e.CharData:
		}
	}
	return nil
}
func (_aege ST_TLAnimateColorSpace) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_aege.String(), start)
}
func (_fdaa ST_TLBehaviorAdditiveType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_cebfc := _e.Attr{}
	_cebfc.Name = name
	switch _fdaa {
	case ST_TLBehaviorAdditiveTypeUnset:
		_cebfc.Value = ""
	case ST_TLBehaviorAdditiveTypeBase:
		_cebfc.Value = "base"
	case ST_TLBehaviorAdditiveTypeSum:
		_cebfc.Value = "sum"
	case ST_TLBehaviorAdditiveTypeRepl:
		_cebfc.Value = "repl"
	case ST_TLBehaviorAdditiveTypeMult:
		_cebfc.Value = "mult"
	case ST_TLBehaviorAdditiveTypeNone:
		_cebfc.Value = "none"
	}
	return _cebfc, nil
}
func (_gggae *CT_WheelTransition) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _gfcg := range start.Attr {
		if _gfcg.Name.Local == "spokes" {
			_cgafcg, _cadcd := _b.ParseUint(_gfcg.Value, 10, 32)
			if _cadcd != nil {
				return _cadcd
			}
			_bdfde := uint32(_cgafcg)
			_gggae.SpokesAttr = &_bdfde
			continue
		}
	}
	for {
		_ffade, _gabfg := d.Token()
		if _gabfg != nil {
			return _c.Errorf("parsing\u0020CT_WheelTransition:\u0020\u0025s", _gabfg)
		}
		if _eggee, _feaa := _ffade.(_e.EndElement); _feaa && _eggee.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dbgddg *CT_TLPoint) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _fbcfe := range start.Attr {
		if _fbcfe.Name.Local == "x" {
			_acagg, _bgbgf := ParseUnionST_Percentage(_fbcfe.Value)
			if _bgbgf != nil {
				return _bgbgf
			}
			_dbgddg.XAttr = _acagg
			continue
		}
		if _fbcfe.Name.Local == "y" {
			_abdf, _bbeg := ParseUnionST_Percentage(_fbcfe.Value)
			if _bbeg != nil {
				return _bbeg
			}
			_dbgddg.YAttr = _abdf
			continue
		}
	}
	for {
		_fgec, _ecbaa := d.Token()
		if _ecbaa != nil {
			return _c.Errorf("parsing\u0020CT_TLPoint:\u0020%s", _ecbaa)
		}
		if _cdafea, _gcgad := _fgec.(_e.EndElement); _gcgad && _cdafea.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_EmbeddedFontListEntry() *CT_EmbeddedFontListEntry {
	_abeb := &CT_EmbeddedFontListEntry{}
	_abeb.Font = _cb.NewCT_TextFont()
	return _abeb
}
func (_bcade *ST_OleObjectFollowColorScheme) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_ffggg, _faecg := d.Token()
	if _faecg != nil {
		return _faecg
	}
	if _acfg, _cafcga := _ffggg.(_e.EndElement); _cafcga && _acfg.Name == start.Name {
		*_bcade = 1
		return nil
	}
	if _bacdc, _gdgd := _ffggg.(_e.CharData); !_gdgd {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ffggg)
	} else {
		switch string(_bacdc) {
		case "":
			*_bcade = 0
		case "none":
			*_bcade = 1
		case "full":
			*_bcade = 2
		case "textAndBackground":
			*_bcade = 3
		}
	}
	_ffggg, _faecg = d.Token()
	if _faecg != nil {
		return _faecg
	}
	if _bedfd, _abaf := _ffggg.(_e.EndElement); _abaf && _bedfd.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ffggg)
}

// Validate validates the CT_Comment and its children
func (_ggf *CT_Comment) Validate() error { return _ggf.ValidateWithPath("CT_Comment") }

type ST_TLBehaviorAdditiveType byte
type CT_OptionalBlackTransition struct {

	// Transition Through Black
	ThruBlkAttr *bool
}

func NewCT_OleObject() *CT_OleObject {
	_ccfb := &CT_OleObject{}
	_ccfb.Choice = NewCT_OleObjectChoice()
	return _ccfb
}

const (
	ST_TLBehaviorAccumulateTypeUnset  ST_TLBehaviorAccumulateType = 0
	ST_TLBehaviorAccumulateTypeNone   ST_TLBehaviorAccumulateType = 1
	ST_TLBehaviorAccumulateTypeAlways ST_TLBehaviorAccumulateType = 2
)

// Validate validates the CT_NotesMasterIdList and its children
func (_bdea *CT_NotesMasterIdList) Validate() error {
	return _bdea.ValidateWithPath("CT_NotesMasterIdList")
}

// ValidateWithPath validates the CT_ShowInfoBrowse and its children, prefixing error messages with path
func (_adaaa *CT_ShowInfoBrowse) ValidateWithPath(path string) error { return nil }

const (
	ST_PlaceholderTypeUnset    ST_PlaceholderType = 0
	ST_PlaceholderTypeTitle    ST_PlaceholderType = 1
	ST_PlaceholderTypeBody     ST_PlaceholderType = 2
	ST_PlaceholderTypeCtrTitle ST_PlaceholderType = 3
	ST_PlaceholderTypeSubTitle ST_PlaceholderType = 4
	ST_PlaceholderTypeDt       ST_PlaceholderType = 5
	ST_PlaceholderTypeSldNum   ST_PlaceholderType = 6
	ST_PlaceholderTypeFtr      ST_PlaceholderType = 7
	ST_PlaceholderTypeHdr      ST_PlaceholderType = 8
	ST_PlaceholderTypeObj      ST_PlaceholderType = 9
	ST_PlaceholderTypeChart    ST_PlaceholderType = 10
	ST_PlaceholderTypeTbl      ST_PlaceholderType = 11
	ST_PlaceholderTypeClipArt  ST_PlaceholderType = 12
	ST_PlaceholderTypeDgm      ST_PlaceholderType = 13
	ST_PlaceholderTypeMedia    ST_PlaceholderType = 14
	ST_PlaceholderTypeSldImg   ST_PlaceholderType = 15
	ST_PlaceholderTypePic      ST_PlaceholderType = 16
)

func NewCT_SlideRelationshipList() *CT_SlideRelationshipList {
	_daga := &CT_SlideRelationshipList{}
	return _daga
}

// Validate validates the CT_TagList and its children
func (_gbff *CT_TagList) Validate() error { return _gbff.ValidateWithPath("CT_TagList") }
func (_cffeg ST_TLCommandType) String() string {
	switch _cffeg {
	case 0:
		return ""
	case 1:
		return "evt"
	case 2:
		return "call"
	case 3:
		return "verb"
	}
	return ""
}
func (_gggf *CT_ShapeNonVisual) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gggf.CNvPr = _cb.NewCT_NonVisualDrawingProps()
	_gggf.CNvSpPr = _cb.NewCT_NonVisualDrawingShapeProps()
	_gggf.NvPr = NewCT_ApplicationNonVisualDrawingProps()
_abab:
	for {
		_deddc, _baaaa := d.Token()
		if _baaaa != nil {
			return _baaaa
		}
		switch _dbfde := _deddc.(type) {
		case _e.StartElement:
			switch _dbfde.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cNvPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cNvPr"}:
				if _fedbb := d.DecodeElement(_gggf.CNvPr, &_dbfde); _fedbb != nil {
					return _fedbb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cNvSpPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cNvSpPr"}:
				if _dfcf := d.DecodeElement(_gggf.CNvSpPr, &_dbfde); _dfcf != nil {
					return _dfcf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "nvPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "nvPr"}:
				if _decc := d.DecodeElement(_gggf.NvPr, &_dbfde); _decc != nil {
					return _decc
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_ShapeNonVisual\u0020\u0025v", _dbfde.Name)
				if _fgeed := d.Skip(); _fgeed != nil {
					return _fgeed
				}
			}
		case _e.EndElement:
			break _abab
		case _e.CharData:
		}
	}
	return nil
}
func (_fddfe *ST_Direction) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_deeca, _dcdeb := d.Token()
	if _dcdeb != nil {
		return _dcdeb
	}
	if _efbc, _gdedg := _deeca.(_e.EndElement); _gdedg && _efbc.Name == start.Name {
		*_fddfe = 1
		return nil
	}
	if _ebged, _gebce := _deeca.(_e.CharData); !_gebce {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _deeca)
	} else {
		switch string(_ebged) {
		case "":
			*_fddfe = 0
		case "horz":
			*_fddfe = 1
		case "vert":
			*_fddfe = 2
		}
	}
	_deeca, _dcdeb = d.Token()
	if _dcdeb != nil {
		return _dcdeb
	}
	if _dbgdc, _beceb := _deeca.(_e.EndElement); _beceb && _dbgdc.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _deeca)
}
func (_gdcba ST_TLTimeNodeSyncType) ValidateWithPath(path string) error {
	switch _gdcba {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gdcba))
	}
	return nil
}
func (_badc *CT_SlideLayoutIdList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_dcdeg:
	for {
		_beaebg, _bega := d.Token()
		if _bega != nil {
			return _bega
		}
		switch _gfdg := _beaebg.(type) {
		case _e.StartElement:
			switch _gfdg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldLayoutId"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldLayoutId"}:
				_egeb := NewCT_SlideLayoutIdListEntry()
				if _gaba := d.DecodeElement(_egeb, &_gfdg); _gaba != nil {
					return _gaba
				}
				_badc.SldLayoutId = append(_badc.SldLayoutId, _egeb)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_SlideLayoutIdList\u0020\u0025v", _gfdg.Name)
				if _cbeec := d.Skip(); _cbeec != nil {
					return _cbeec
				}
			}
		case _e.EndElement:
			break _dcdeg
		case _e.CharData:
		}
	}
	return nil
}
func (_gebab ST_SlideSizeType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_gdfgeg := _e.Attr{}
	_gdfgeg.Name = name
	switch _gebab {
	case ST_SlideSizeTypeUnset:
		_gdfgeg.Value = ""
	case ST_SlideSizeTypeScreen4x3:
		_gdfgeg.Value = "screen4x3"
	case ST_SlideSizeTypeLetter:
		_gdfgeg.Value = "letter"
	case ST_SlideSizeTypeA4:
		_gdfgeg.Value = "A4"
	case ST_SlideSizeType35mm:
		_gdfgeg.Value = "35mm"
	case ST_SlideSizeTypeOverhead:
		_gdfgeg.Value = "overhead"
	case ST_SlideSizeTypeBanner:
		_gdfgeg.Value = "banner"
	case ST_SlideSizeTypeCustom:
		_gdfgeg.Value = "custom"
	case ST_SlideSizeTypeLedger:
		_gdfgeg.Value = "ledger"
	case ST_SlideSizeTypeA3:
		_gdfgeg.Value = "A3"
	case ST_SlideSizeTypeB4ISO:
		_gdfgeg.Value = "B4ISO"
	case ST_SlideSizeTypeB5ISO:
		_gdfgeg.Value = "B5ISO"
	case ST_SlideSizeTypeB4JIS:
		_gdfgeg.Value = "B4JIS"
	case ST_SlideSizeTypeB5JIS:
		_gdfgeg.Value = "B5JIS"
	case ST_SlideSizeTypeHagakiCard:
		_gdfgeg.Value = "hagakiCard"
	case ST_SlideSizeTypeScreen16x9:
		_gdfgeg.Value = "screen16x9"
	case ST_SlideSizeTypeScreen16x10:
		_gdfgeg.Value = "screen16x10"
	}
	return _gdfgeg, nil
}
func (_agfdb *ST_OleObjectFollowColorScheme) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_agfdb = 0
	case "none":
		*_agfdb = 1
	case "full":
		*_agfdb = 2
	case "textAndBackground":
		*_agfdb = 3
	}
	return nil
}
func (_agab *CT_CornerDirectionTransition) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _aadb := range start.Attr {
		if _aadb.Name.Local == "dir" {
			_agab.DirAttr.UnmarshalXMLAttr(_aadb)
			continue
		}
	}
	for {
		_gffc, _bfff := d.Token()
		if _bfff != nil {
			return _c.Errorf("parsing\u0020CT_CornerDirectionTransition: \u0025s", _bfff)
		}
		if _efggb, _ecc := _gffc.(_e.EndElement); _ecc && _efggb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_adec ST_TLTimeNodeFillType) Validate() error { return _adec.ValidateWithPath("") }
func (_facaf *CT_SlideLayoutIdList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _facaf.SldLayoutId != nil {
		_ebef := _e.StartElement{Name: _e.Name{Local: "p:sldLayoutId"}}
		for _, _gddag := range _facaf.SldLayoutId {
			e.EncodeElement(_gddag, _ebef)
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_deae ST_TLAnimateColorDirection) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_fbcggf := _e.Attr{}
	_fbcggf.Name = name
	switch _deae {
	case ST_TLAnimateColorDirectionUnset:
		_fbcggf.Value = ""
	case ST_TLAnimateColorDirectionCw:
		_fbcggf.Value = "cw"
	case ST_TLAnimateColorDirectionCcw:
		_fbcggf.Value = "ccw"
	}
	return _fbcggf, nil
}
func (_cfga *CT_TLMediaNodeAudio) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _cfga.IsNarrationAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "isNarration"}, Value: _c.Sprintf("\u0025d", _fdeab(*_cfga.IsNarrationAttr))})
	}
	e.EncodeToken(start)
	_fagbg := _e.StartElement{Name: _e.Name{Local: "p:cMediaNode"}}
	e.EncodeElement(_cfga.CMediaNode, _fagbg)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SlideMaster and its children
func (_aefd *CT_SlideMaster) Validate() error { return _aefd.ValidateWithPath("CT_SlideMaster") }

type ST_OleObjectFollowColorScheme byte

// Validate validates the CT_Extension and its children
func (_bef *CT_Extension) Validate() error { return _bef.ValidateWithPath("CT_Extension") }
func (_fab *CT_CommonSlideViewProperties) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fab.CViewPr = NewCT_CommonViewProperties()
	for _, _gdg := range start.Attr {
		if _gdg.Name.Local == "snapToGrid" {
			_fdg, _bgc := _b.ParseBool(_gdg.Value)
			if _bgc != nil {
				return _bgc
			}
			_fab.SnapToGridAttr = &_fdg
			continue
		}
		if _gdg.Name.Local == "snapToObjects" {
			_cgfe, _deb := _b.ParseBool(_gdg.Value)
			if _deb != nil {
				return _deb
			}
			_fab.SnapToObjectsAttr = &_cgfe
			continue
		}
		if _gdg.Name.Local == "showGuides" {
			_agfe, _ede := _b.ParseBool(_gdg.Value)
			if _ede != nil {
				return _ede
			}
			_fab.ShowGuidesAttr = &_agfe
			continue
		}
	}
_edad:
	for {
		_gcca, _bgd := d.Token()
		if _bgd != nil {
			return _bgd
		}
		switch _eac := _gcca.(type) {
		case _e.StartElement:
			switch _eac.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cViewPr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cViewPr"}:
				if _fdga := d.DecodeElement(_fab.CViewPr, &_eac); _fdga != nil {
					return _fdga
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "guideLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "guideLst"}:
				_fab.GuideLst = NewCT_GuideList()
				if _ffd := d.DecodeElement(_fab.GuideLst, &_eac); _ffd != nil {
					return _ffd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_CommonSlideViewProperties\u0020\u0025v", _eac.Name)
				if _aaa := d.Skip(); _aaa != nil {
					return _aaa
				}
			}
		case _e.EndElement:
			break _edad
		case _e.CharData:
		}
	}
	return nil
}
func (_bcgbeb ST_OleObjectFollowColorScheme) String() string {
	switch _bcgbeb {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "full"
	case 3:
		return "textAndBackground"
	}
	return ""
}

const (
	ST_TLAnimateColorDirectionUnset ST_TLAnimateColorDirection = 0
	ST_TLAnimateColorDirectionCw    ST_TLAnimateColorDirection = 1
	ST_TLAnimateColorDirectionCcw   ST_TLAnimateColorDirection = 2
)

func NewCT_TLBehaviorAttributeNameList() *CT_TLBehaviorAttributeNameList {
	_faee := &CT_TLBehaviorAttributeNameList{}
	return _faee
}

type CT_EmbeddedFontDataId struct{ IdAttr string }

// ValidateWithPath validates the EG_ShowType and its children, prefixing error messages with path
func (_cdabg *EG_ShowType) ValidateWithPath(path string) error {
	if _cdabg.Present != nil {
		if _dbeb := _cdabg.Present.ValidateWithPath(path + "\u002fPresent"); _dbeb != nil {
			return _dbeb
		}
	}
	if _cdabg.Browse != nil {
		if _cabdb := _cdabg.Browse.ValidateWithPath(path + "\u002fBrowse"); _cabdb != nil {
			return _cabdb
		}
	}
	if _cdabg.Kiosk != nil {
		if _febe := _cdabg.Kiosk.ValidateWithPath(path + "\u002fKiosk"); _febe != nil {
			return _febe
		}
	}
	return nil
}

// ValidateWithPath validates the CT_TransitionSoundAction and its children, prefixing error messages with path
func (_cdeff *CT_TransitionSoundAction) ValidateWithPath(path string) error {
	if _cdeff.StSnd != nil {
		if _deff := _cdeff.StSnd.ValidateWithPath(path + "\u002fStSnd"); _deff != nil {
			return _deff
		}
	}
	if _cdeff.EndSnd != nil {
		if _gabd := _cdeff.EndSnd.ValidateWithPath(path + "\u002fEndSnd"); _gabd != nil {
			return _gabd
		}
	}
	return nil
}

type CT_GraphicalObjectFrame struct {
	BwModeAttr _cb.ST_BlackWhiteMode

	// Non-Visual Properties for a Graphic Frame
	NvGraphicFramePr *CT_GraphicalObjectFrameNonVisual

	// 2D Transform for Graphic Frame
	Xfrm    *_cb.CT_Transform2D
	Graphic *_cb.Graphic

	// Extension List with Modification Flag
	ExtLst *CT_ExtensionListModify
}

func (_bfdba *ST_TLAnimateEffectTransition) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_bfdba = 0
	case "in":
		*_bfdba = 1
	case "out":
		*_bfdba = 2
	case "none":
		*_bfdba = 3
	}
	return nil
}

type CT_NotesMasterIdList struct {

	// Notes Master ID
	NotesMasterId *CT_NotesMasterIdListEntry
}
type CT_CommonSlideViewProperties struct {

	// Snap Objects to Grid
	SnapToGridAttr *bool

	// Snap Objects to Objects
	SnapToObjectsAttr *bool

	// Show Guides in View
	ShowGuidesAttr *bool

	// Base properties for Slide View
	CViewPr *CT_CommonViewProperties

	// List of Guides
	GuideLst *CT_GuideList
}

func (_gegg *CT_EmbeddedFontDataId) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _gegg.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_HandoutMaster struct {

	// Common slide data for handout master
	CSld *CT_CommonSlideData

	// Color Scheme Map
	ClrMap *_cb.CT_ColorMapping

	// Header/Footer information for a handout master
	Hf     *CT_HeaderFooter
	ExtLst *CT_ExtensionListModify
}

func (_gabfd *ST_TLDiagramBuildType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cfffb, _aecb := d.Token()
	if _aecb != nil {
		return _aecb
	}
	if _ggbgae, _dcfad := _cfffb.(_e.EndElement); _dcfad && _ggbgae.Name == start.Name {
		*_gabfd = 1
		return nil
	}
	if _gcadc, _aacge := _cfffb.(_e.CharData); !_aacge {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cfffb)
	} else {
		switch string(_gcadc) {
		case "":
			*_gabfd = 0
		case "whole":
			*_gabfd = 1
		case "depthByNode":
			*_gabfd = 2
		case "depthByBranch":
			*_gabfd = 3
		case "breadthByNode":
			*_gabfd = 4
		case "breadthByLvl":
			*_gabfd = 5
		case "cw":
			*_gabfd = 6
		case "cwIn":
			*_gabfd = 7
		case "cwOut":
			*_gabfd = 8
		case "ccw":
			*_gabfd = 9
		case "ccwIn":
			*_gabfd = 10
		case "ccwOut":
			*_gabfd = 11
		case "inByRing":
			*_gabfd = 12
		case "outByRing":
			*_gabfd = 13
		case "up":
			*_gabfd = 14
		case "down":
			*_gabfd = 15
		case "allAtOnce":
			*_gabfd = 16
		case "cust":
			*_gabfd = 17
		}
	}
	_cfffb, _aecb = d.Token()
	if _aecb != nil {
		return _aecb
	}
	if _gdggf, _fbcggc := _cfffb.(_e.EndElement); _fbcggc && _gdggf.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cfffb)
}
func (_facge *TagLst) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_facge.CT_TagList = *NewCT_TagList()
_bbggd:
	for {
		_gebc, _dbbd := d.Token()
		if _dbbd != nil {
			return _dbbd
		}
		switch _fefbb := _gebc.(type) {
		case _e.StartElement:
			switch _fefbb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tag"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tag"}:
				_ggcfc := NewCT_StringTag()
				if _egcfc := d.DecodeElement(_ggcfc, &_fefbb); _egcfc != nil {
					return _egcfc
				}
				_facge.Tag = append(_facge.Tag, _ggcfc)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020TagLst\u0020\u0025v", _fefbb.Name)
				if _aadcb := d.Skip(); _aadcb != nil {
					return _aadcb
				}
			}
		case _e.EndElement:
			break _bbggd
		case _e.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_SlideSyncProperties and its children, prefixing error messages with path
func (_ddgbc *CT_SlideSyncProperties) ValidateWithPath(path string) error {
	if _ddgbc.ExtLst != nil {
		if _cccgg := _ddgbc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cccgg != nil {
			return _cccgg
		}
	}
	return nil
}
func (_gggaa *CT_Slide) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gggaa.ShowAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "show"}, Value: _c.Sprintf("\u0025d", _fdeab(*_gggaa.ShowAttr))})
	}
	if _gggaa.ShowMasterSpAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showMasterSp"}, Value: _c.Sprintf("\u0025d", _fdeab(*_gggaa.ShowMasterSpAttr))})
	}
	if _gggaa.ShowMasterPhAnimAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showMasterPhAnim"}, Value: _c.Sprintf("\u0025d", _fdeab(*_gggaa.ShowMasterPhAnimAttr))})
	}
	e.EncodeToken(start)
	_dbcd := _e.StartElement{Name: _e.Name{Local: "p:cSld"}}
	e.EncodeElement(_gggaa.CSld, _dbcd)
	if _gggaa.ClrMapOvr != nil {
		_cbffa := _e.StartElement{Name: _e.Name{Local: "p:clrMapOvr"}}
		e.EncodeElement(_gggaa.ClrMapOvr, _cbffa)
	}
	if _gggaa.Transition != nil {
		_cdeac := _e.StartElement{Name: _e.Name{Local: "p:transition"}}
		e.EncodeElement(_gggaa.Transition, _cdeac)
	}
	if _gggaa.Timing != nil {
		_dgae := _e.StartElement{Name: _e.Name{Local: "p:timing"}}
		e.EncodeElement(_gggaa.Timing, _dgae)
	}
	if _gggaa.ExtLst != nil {
		_bbaa := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_gggaa.ExtLst, _bbaa)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_ExtensionListModify struct {

	// Modify
	ModAttr *bool

	// Extension
	Ext []*CT_Extension
}

func (_daded ST_PrintColorMode) Validate() error { return _daded.ValidateWithPath("") }
func (_dacg *Presentation) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_dacg.CT_Presentation = *NewCT_Presentation()
	for _, _abfc := range start.Attr {
		if _abfc.Name.Local == "firstSlideNum" {
			_gdeab, _beebc := _b.ParseInt(_abfc.Value, 10, 32)
			if _beebc != nil {
				return _beebc
			}
			_dffae := int32(_gdeab)
			_dacg.FirstSlideNumAttr = &_dffae
			continue
		}
		if _abfc.Name.Local == "rtl" {
			_ggcdb, _cfcge := _b.ParseBool(_abfc.Value)
			if _cfcge != nil {
				return _cfcge
			}
			_dacg.RtlAttr = &_ggcdb
			continue
		}
		if _abfc.Name.Local == "compatMode" {
			_cbbd, _dgaad := _b.ParseBool(_abfc.Value)
			if _dgaad != nil {
				return _dgaad
			}
			_dacg.CompatModeAttr = &_cbbd
			continue
		}
		if _abfc.Name.Local == "embedTrueTypeFonts" {
			_abgea, _dedgcg := _b.ParseBool(_abfc.Value)
			if _dedgcg != nil {
				return _dedgcg
			}
			_dacg.EmbedTrueTypeFontsAttr = &_abgea
			continue
		}
		if _abfc.Name.Local == "autoCompressPictures" {
			_eecag, _fcec := _b.ParseBool(_abfc.Value)
			if _fcec != nil {
				return _fcec
			}
			_dacg.AutoCompressPicturesAttr = &_eecag
			continue
		}
		if _abfc.Name.Local == "showSpecialPlsOnTitleSld" {
			_dccd, _caadb := _b.ParseBool(_abfc.Value)
			if _caadb != nil {
				return _caadb
			}
			_dacg.ShowSpecialPlsOnTitleSldAttr = &_dccd
			continue
		}
		if _abfc.Name.Local == "serverZoom" {
			_cdeea, _bebgf := ParseUnionST_Percentage(_abfc.Value)
			if _bebgf != nil {
				return _bebgf
			}
			_dacg.ServerZoomAttr = &_cdeea
			continue
		}
		if _abfc.Name.Local == "conformance" {
			_dacg.ConformanceAttr.UnmarshalXMLAttr(_abfc)
			continue
		}
		if _abfc.Name.Local == "removePersonalInfoOnSave" {
			_bfbfb, _adafb := _b.ParseBool(_abfc.Value)
			if _adafb != nil {
				return _adafb
			}
			_dacg.RemovePersonalInfoOnSaveAttr = &_bfbfb
			continue
		}
		if _abfc.Name.Local == "saveSubsetFonts" {
			_bgee, _ebggf := _b.ParseBool(_abfc.Value)
			if _ebggf != nil {
				return _ebggf
			}
			_dacg.SaveSubsetFontsAttr = &_bgee
			continue
		}
		if _abfc.Name.Local == "bookmarkIdSeed" {
			_fgcgd, _gaeac := _b.ParseUint(_abfc.Value, 10, 32)
			if _gaeac != nil {
				return _gaeac
			}
			_ceegf := uint32(_fgcgd)
			_dacg.BookmarkIdSeedAttr = &_ceegf
			continue
		}
		if _abfc.Name.Local == "strictFirstAndLastChars" {
			_dfca, _ebbfa := _b.ParseBool(_abfc.Value)
			if _ebbfa != nil {
				return _ebbfa
			}
			_dacg.StrictFirstAndLastCharsAttr = &_dfca
			continue
		}
	}
_gadef:
	for {
		_bbfge, _fcaaf := d.Token()
		if _fcaaf != nil {
			return _fcaaf
		}
		switch _bdgfe := _bbfge.(type) {
		case _e.StartElement:
			switch _bdgfe.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldMasterIdLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldMasterIdLst"}:
				_dacg.SldMasterIdLst = NewCT_SlideMasterIdList()
				if _ddbff := d.DecodeElement(_dacg.SldMasterIdLst, &_bdgfe); _ddbff != nil {
					return _ddbff
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "notesMasterIdLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "notesMasterIdLst"}:
				_dacg.NotesMasterIdLst = NewCT_NotesMasterIdList()
				if _fdacg := d.DecodeElement(_dacg.NotesMasterIdLst, &_bdgfe); _fdacg != nil {
					return _fdacg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "handoutMasterIdLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "handoutMasterIdLst"}:
				_dacg.HandoutMasterIdLst = NewCT_HandoutMasterIdList()
				if _bdca := d.DecodeElement(_dacg.HandoutMasterIdLst, &_bdgfe); _bdca != nil {
					return _bdca
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldIdLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldIdLst"}:
				_dacg.SldIdLst = NewCT_SlideIdList()
				if _agede := d.DecodeElement(_dacg.SldIdLst, &_bdgfe); _agede != nil {
					return _agede
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "sldSz"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "sldSz"}:
				_dacg.SldSz = NewCT_SlideSize()
				if _ggcc := d.DecodeElement(_dacg.SldSz, &_bdgfe); _ggcc != nil {
					return _ggcc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "notesSz"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "notesSz"}:
				if _fafdg := d.DecodeElement(_dacg.NotesSz, &_bdgfe); _fafdg != nil {
					return _fafdg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "smartTags"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "smartTags"}:
				_dacg.SmartTags = NewCT_SmartTags()
				if _ddef := d.DecodeElement(_dacg.SmartTags, &_bdgfe); _ddef != nil {
					return _ddef
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "embeddedFontLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "embeddedFontLst"}:
				_dacg.EmbeddedFontLst = NewCT_EmbeddedFontList()
				if _aeea := d.DecodeElement(_dacg.EmbeddedFontLst, &_bdgfe); _aeea != nil {
					return _aeea
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "custShowLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "custShowLst"}:
				_dacg.CustShowLst = NewCT_CustomShowList()
				if _dbdaf := d.DecodeElement(_dacg.CustShowLst, &_bdgfe); _dbdaf != nil {
					return _dbdaf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "photoAlbum"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "photoAlbum"}:
				_dacg.PhotoAlbum = NewCT_PhotoAlbum()
				if _feeefg := d.DecodeElement(_dacg.PhotoAlbum, &_bdgfe); _feeefg != nil {
					return _feeefg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "custDataLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "custDataLst"}:
				_dacg.CustDataLst = NewCT_CustomerDataList()
				if _bcdfe := d.DecodeElement(_dacg.CustDataLst, &_bdgfe); _bcdfe != nil {
					return _bcdfe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "kinsoku"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "kinsoku"}:
				_dacg.Kinsoku = NewCT_Kinsoku()
				if _eagbca := d.DecodeElement(_dacg.Kinsoku, &_bdgfe); _eagbca != nil {
					return _eagbca
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "defaultTextStyle"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "defaultTextStyle"}:
				_dacg.DefaultTextStyle = _cb.NewCT_TextListStyle()
				if _bgbea := d.DecodeElement(_dacg.DefaultTextStyle, &_bdgfe); _bgbea != nil {
					return _bgbea
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "modifyVerifier"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "modifyVerifier"}:
				_dacg.ModifyVerifier = NewCT_ModifyVerifier()
				if _cdbf := d.DecodeElement(_dacg.ModifyVerifier, &_bdgfe); _cdbf != nil {
					return _cdbf
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_dacg.ExtLst = NewCT_ExtensionList()
				if _geebbe := d.DecodeElement(_dacg.ExtLst, &_bdgfe); _geebbe != nil {
					return _geebbe
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Presentation\u0020\u0025v", _bdgfe.Name)
				if _dbedg := d.Skip(); _dbedg != nil {
					return _dbedg
				}
			}
		case _e.EndElement:
			break _gadef
		case _e.CharData:
		}
	}
	return nil
}
func NewCT_SlideTransition() *CT_SlideTransition { _aegf := &CT_SlideTransition{}; return _aegf }

// Validate validates the CT_WebProperties and its children
func (_agae *CT_WebProperties) Validate() error { return _agae.ValidateWithPath("CT_WebProperties") }
func (_bfecb *ST_TLAnimateBehaviorValueType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gadae, _dgdac := d.Token()
	if _dgdac != nil {
		return _dgdac
	}
	if _ffdaf, _bbgbgd := _gadae.(_e.EndElement); _bbgbgd && _ffdaf.Name == start.Name {
		*_bfecb = 1
		return nil
	}
	if _agfdg, _effdc := _gadae.(_e.CharData); !_effdc {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gadae)
	} else {
		switch string(_agfdg) {
		case "":
			*_bfecb = 0
		case "str":
			*_bfecb = 1
		case "num":
			*_bfecb = 2
		case "clr":
			*_bfecb = 3
		}
	}
	_gadae, _dgdac = d.Token()
	if _dgdac != nil {
		return _dgdac
	}
	if _cdcb, _fdbfa := _gadae.(_e.EndElement); _fdbfa && _cdcb.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gadae)
}
func (_cfcbda ST_TLBehaviorAccumulateType) String() string {
	switch _cfcbda {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "always"
	}
	return ""
}
func NewCT_TLAnimVariantIntegerVal() *CT_TLAnimVariantIntegerVal {
	_geede := &CT_TLAnimVariantIntegerVal{}
	return _geede
}

type ST_TLAnimateColorSpace byte

// ValidateWithPath validates the CT_GroupShape and its children, prefixing error messages with path
func (_bbfb *CT_GroupShape) ValidateWithPath(path string) error {
	if _ddce := _bbfb.NvGrpSpPr.ValidateWithPath(path + "\u002fNvGrpSpPr"); _ddce != nil {
		return _ddce
	}
	if _caaf := _bbfb.GrpSpPr.ValidateWithPath(path + "\u002fGrpSpPr"); _caaf != nil {
		return _caaf
	}
	for _fada, _cffcc := range _bbfb.Choice {
		if _abbg := _cffcc.ValidateWithPath(_c.Sprintf("\u0025s\u002fChoice\u005b\u0025d\u005d", path, _fada)); _abbg != nil {
			return _abbg
		}
	}
	if _bbfb.ExtLst != nil {
		if _cbcc := _bbfb.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _cbcc != nil {
			return _cbcc
		}
	}
	return nil
}
func (_ggge *CT_Guide) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ggge.OrientAttr != ST_DirectionUnset {
		_adaa, _geeg := _ggge.OrientAttr.MarshalXMLAttr(_e.Name{Local: "orient"})
		if _geeg != nil {
			return _geeg
		}
		start.Attr = append(start.Attr, _adaa)
	}
	if _ggge.PosAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "pos"}, Value: _c.Sprintf("\u0025v", *_ggge.PosAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_efaeb ST_TLDiagramBuildType) ValidateWithPath(path string) error {
	switch _efaeb {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_efaeb))
	}
	return nil
}
func (_bdbeb *ST_TLNextActionType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fgfe, _egbag := d.Token()
	if _egbag != nil {
		return _egbag
	}
	if _beeff, _cbggd := _fgfe.(_e.EndElement); _cbggd && _beeff.Name == start.Name {
		*_bdbeb = 1
		return nil
	}
	if _bgfb, _cgfed := _fgfe.(_e.CharData); !_cgfed {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fgfe)
	} else {
		switch string(_bgfb) {
		case "":
			*_bdbeb = 0
		case "none":
			*_bdbeb = 1
		case "seek":
			*_bdbeb = 2
		}
	}
	_fgfe, _egbag = d.Token()
	if _egbag != nil {
		return _egbag
	}
	if _deagd, _cadgg := _fgfe.(_e.EndElement); _cadgg && _deagd.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fgfe)
}
func (_fbaf *CT_GroupShapeChoice) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _fbaf.Sp != nil {
		_cgffg := _e.StartElement{Name: _e.Name{Local: "p:sp"}}
		for _, _fega := range _fbaf.Sp {
			e.EncodeElement(_fega, _cgffg)
		}
	}
	if _fbaf.GrpSp != nil {
		_dafbf := _e.StartElement{Name: _e.Name{Local: "p:grpSp"}}
		for _, _afdd := range _fbaf.GrpSp {
			e.EncodeElement(_afdd, _dafbf)
		}
	}
	if _fbaf.GraphicFrame != nil {
		_geag := _e.StartElement{Name: _e.Name{Local: "p:graphicFrame"}}
		for _, _dgbb := range _fbaf.GraphicFrame {
			e.EncodeElement(_dgbb, _geag)
		}
	}
	if _fbaf.CxnSp != nil {
		_fecea := _e.StartElement{Name: _e.Name{Local: "p:cxnSp"}}
		for _, _dbfg := range _fbaf.CxnSp {
			e.EncodeElement(_dbfg, _fecea)
		}
	}
	if _fbaf.Pic != nil {
		_ffeab := _e.StartElement{Name: _e.Name{Local: "p:pic"}}
		for _, _dbd := range _fbaf.Pic {
			e.EncodeElement(_dbd, _ffeab)
		}
	}
	if _fbaf.ContentPart != nil {
		_becg := _e.StartElement{Name: _e.Name{Local: "p:contentPart"}}
		for _, _eaaf := range _fbaf.ContentPart {
			e.EncodeElement(_eaaf, _becg)
		}
	}
	return nil
}
func (_cfeca ST_TLPreviousActionType) ValidateWithPath(path string) error {
	switch _cfeca {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cfeca))
	}
	return nil
}
func (_gfdbd *CT_TLByHslColorTransform) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _eagab := range start.Attr {
		if _eagab.Name.Local == "h" {
			_dfade, _bdfc := _b.ParseInt(_eagab.Value, 10, 32)
			if _bdfc != nil {
				return _bdfc
			}
			_gfdbd.HAttr = int32(_dfade)
			continue
		}
		if _eagab.Name.Local == "s" {
			_cbgbc, _gfcab := ParseUnionST_FixedPercentage(_eagab.Value)
			if _gfcab != nil {
				return _gfcab
			}
			_gfdbd.SAttr = _cbgbc
			continue
		}
		if _eagab.Name.Local == "l" {
			_ccad, _aagba := ParseUnionST_FixedPercentage(_eagab.Value)
			if _aagba != nil {
				return _aagba
			}
			_gfdbd.LAttr = _ccad
			continue
		}
	}
	for {
		_fdcdf, _ebcd := d.Token()
		if _ebcd != nil {
			return _c.Errorf("parsing CT_TLByHslColorTransform:\u0020%s", _ebcd)
		}
		if _deab, _ecegg := _fdcdf.(_e.EndElement); _ecegg && _deab.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dgeg ST_PlaceholderType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_dgeg.String(), start)
}
func (_abedbg ST_PlaceholderType) String() string {
	switch _abedbg {
	case 0:
		return ""
	case 1:
		return "title"
	case 2:
		return "body"
	case 3:
		return "ctrTitle"
	case 4:
		return "subTitle"
	case 5:
		return "dt"
	case 6:
		return "sldNum"
	case 7:
		return "ftr"
	case 8:
		return "hdr"
	case 9:
		return "obj"
	case 10:
		return "chart"
	case 11:
		return "tbl"
	case 12:
		return "clipArt"
	case 13:
		return "dgm"
	case 14:
		return "media"
	case 15:
		return "sldImg"
	case 16:
		return "pic"
	}
	return ""
}
func (_eabga ST_PhotoAlbumLayout) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_adbga := _e.Attr{}
	_adbga.Name = name
	switch _eabga {
	case ST_PhotoAlbumLayoutUnset:
		_adbga.Value = ""
	case ST_PhotoAlbumLayoutFitToSlide:
		_adbga.Value = "fitToSlide"
	case ST_PhotoAlbumLayout1pic:
		_adbga.Value = "1pic"
	case ST_PhotoAlbumLayout2pic:
		_adbga.Value = "2pic"
	case ST_PhotoAlbumLayout4pic:
		_adbga.Value = "4pic"
	case ST_PhotoAlbumLayout1picTitle:
		_adbga.Value = "1picTitle"
	case ST_PhotoAlbumLayout2picTitle:
		_adbga.Value = "2picTitle"
	case ST_PhotoAlbumLayout4picTitle:
		_adbga.Value = "4picTitle"
	}
	return _adbga, nil
}

// ValidateWithPath validates the CT_Presentation and its children, prefixing error messages with path
func (_ddfde *CT_Presentation) ValidateWithPath(path string) error {
	if _ddfde.ServerZoomAttr != nil {
		if _edda := _ddfde.ServerZoomAttr.ValidateWithPath(path + "\u002fServerZoomAttr"); _edda != nil {
			return _edda
		}
	}
	if _ddfde.BookmarkIdSeedAttr != nil {
		if *_ddfde.BookmarkIdSeedAttr < 1 {
			return _c.Errorf("\u0025s/m\u002eBookmarkIdSeedAttr\u0020must\u0020be\u0020\u003e\u003d\u00201\u0020\u0028have\u0020\u0025v\u0029", path, *_ddfde.BookmarkIdSeedAttr)
		}
		if *_ddfde.BookmarkIdSeedAttr >= 2147483648 {
			return _c.Errorf("\u0025s\u002fm\u002eBookmarkIdSeedAttr\u0020must\u0020be\u0020\u003c\u00202147483648\u0020\u0028have\u0020\u0025v\u0029", path, *_ddfde.BookmarkIdSeedAttr)
		}
	}
	if _bdbd := _ddfde.ConformanceAttr.ValidateWithPath(path + "\u002fConformanceAttr"); _bdbd != nil {
		return _bdbd
	}
	if _ddfde.SldMasterIdLst != nil {
		if _bbgga := _ddfde.SldMasterIdLst.ValidateWithPath(path + "\u002fSldMasterIdLst"); _bbgga != nil {
			return _bbgga
		}
	}
	if _ddfde.NotesMasterIdLst != nil {
		if _ddff := _ddfde.NotesMasterIdLst.ValidateWithPath(path + "\u002fNotesMasterIdLst"); _ddff != nil {
			return _ddff
		}
	}
	if _ddfde.HandoutMasterIdLst != nil {
		if _eefc := _ddfde.HandoutMasterIdLst.ValidateWithPath(path + "\u002fHandoutMasterIdLst"); _eefc != nil {
			return _eefc
		}
	}
	if _ddfde.SldIdLst != nil {
		if _fafde := _ddfde.SldIdLst.ValidateWithPath(path + "\u002fSldIdLst"); _fafde != nil {
			return _fafde
		}
	}
	if _ddfde.SldSz != nil {
		if _ggfdb := _ddfde.SldSz.ValidateWithPath(path + "\u002fSldSz"); _ggfdb != nil {
			return _ggfdb
		}
	}
	if _dgaa := _ddfde.NotesSz.ValidateWithPath(path + "\u002fNotesSz"); _dgaa != nil {
		return _dgaa
	}
	if _ddfde.SmartTags != nil {
		if _dbegf := _ddfde.SmartTags.ValidateWithPath(path + "\u002fSmartTags"); _dbegf != nil {
			return _dbegf
		}
	}
	if _ddfde.EmbeddedFontLst != nil {
		if _edggc := _ddfde.EmbeddedFontLst.ValidateWithPath(path + "\u002fEmbeddedFontLst"); _edggc != nil {
			return _edggc
		}
	}
	if _ddfde.CustShowLst != nil {
		if _ecfb := _ddfde.CustShowLst.ValidateWithPath(path + "\u002fCustShowLst"); _ecfb != nil {
			return _ecfb
		}
	}
	if _ddfde.PhotoAlbum != nil {
		if _eadc := _ddfde.PhotoAlbum.ValidateWithPath(path + "/PhotoAlbum"); _eadc != nil {
			return _eadc
		}
	}
	if _ddfde.CustDataLst != nil {
		if _fbde := _ddfde.CustDataLst.ValidateWithPath(path + "\u002fCustDataLst"); _fbde != nil {
			return _fbde
		}
	}
	if _ddfde.Kinsoku != nil {
		if _cbed := _ddfde.Kinsoku.ValidateWithPath(path + "\u002fKinsoku"); _cbed != nil {
			return _cbed
		}
	}
	if _ddfde.DefaultTextStyle != nil {
		if _aefa := _ddfde.DefaultTextStyle.ValidateWithPath(path + "\u002fDefaultTextStyle"); _aefa != nil {
			return _aefa
		}
	}
	if _ddfde.ModifyVerifier != nil {
		if _eafg := _ddfde.ModifyVerifier.ValidateWithPath(path + "\u002fModifyVerifier"); _eafg != nil {
			return _eafg
		}
	}
	if _ddfde.ExtLst != nil {
		if _bebe := _ddfde.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _bebe != nil {
			return _bebe
		}
	}
	return nil
}
func (_facg *CT_SlideTransition) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _facg.SpdAttr != ST_TransitionSpeedUnset {
		_caebe, _beacg := _facg.SpdAttr.MarshalXMLAttr(_e.Name{Local: "spd"})
		if _beacg != nil {
			return _beacg
		}
		start.Attr = append(start.Attr, _caebe)
	}
	if _facg.AdvClickAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "advClick"}, Value: _c.Sprintf("\u0025d", _fdeab(*_facg.AdvClickAttr))})
	}
	if _facg.AdvTmAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "advTm"}, Value: _c.Sprintf("\u0025v", *_facg.AdvTmAttr)})
	}
	e.EncodeToken(start)
	if _facg.Choice != nil {
		_facg.Choice.MarshalXML(e, _e.StartElement{})
	}
	if _facg.SndAc != nil {
		_bdeef := _e.StartElement{Name: _e.Name{Local: "p:sndAc"}}
		e.EncodeElement(_facg.SndAc, _bdeef)
	}
	if _facg.ExtLst != nil {
		_eafga := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_facg.ExtLst, _eafga)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TLTimeTargetElement and its children
func (_gbdgc *CT_TLTimeTargetElement) Validate() error {
	return _gbdgc.ValidateWithPath("CT_TLTimeTargetElement")
}

// ValidateWithPath validates the CT_TLAnimVariantStringVal and its children, prefixing error messages with path
func (_ceca *CT_TLAnimVariantStringVal) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_CustomShowId and its children, prefixing error messages with path
func (_debf *CT_CustomShowId) ValidateWithPath(path string) error { return nil }

// Validate validates the ViewPr and its children
func (_dcege *ViewPr) Validate() error      { return _dcege.ValidateWithPath("ViewPr") }
func (_bffdg ST_PrintWhat) Validate() error { return _bffdg.ValidateWithPath("") }
func (_ffde *CT_HandoutMasterIdListEntry) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _ffde.IdAttr)})
	e.EncodeToken(start)
	if _ffde.ExtLst != nil {
		_acdc := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ffde.ExtLst, _acdc)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_afdb *CT_HandoutMasterIdList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_gcfa:
	for {
		_ddfdg, _aggf := d.Token()
		if _aggf != nil {
			return _aggf
		}
		switch _ggfce := _ddfdg.(type) {
		case _e.StartElement:
			switch _ggfce.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "handoutMasterId"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "handoutMasterId"}:
				_afdb.HandoutMasterId = NewCT_HandoutMasterIdListEntry()
				if _afbd := d.DecodeElement(_afdb.HandoutMasterId, &_ggfce); _afbd != nil {
					return _afbd
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_HandoutMasterIdList\u0020\u0025v", _ggfce.Name)
				if _gace := d.Skip(); _gace != nil {
					return _gace
				}
			}
		case _e.EndElement:
			break _gcfa
		case _e.CharData:
		}
	}
	return nil
}
func (_bbee *CT_SlideMasterTextStyles) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_dgbfg:
	for {
		_bdbb, _aaac := d.Token()
		if _aaac != nil {
			return _aaac
		}
		switch _edgda := _bdbb.(type) {
		case _e.StartElement:
			switch _edgda.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "titleStyle"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "titleStyle"}:
				_bbee.TitleStyle = _cb.NewCT_TextListStyle()
				if _accbe := d.DecodeElement(_bbee.TitleStyle, &_edgda); _accbe != nil {
					return _accbe
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bodyStyle"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bodyStyle"}:
				_bbee.BodyStyle = _cb.NewCT_TextListStyle()
				if _fdae := d.DecodeElement(_bbee.BodyStyle, &_edgda); _fdae != nil {
					return _fdae
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "otherStyle"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "otherStyle"}:
				_bbee.OtherStyle = _cb.NewCT_TextListStyle()
				if _efcc := d.DecodeElement(_bbee.OtherStyle, &_edgda); _efcc != nil {
					return _efcc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_bbee.ExtLst = NewCT_ExtensionList()
				if _eedad := d.DecodeElement(_bbee.ExtLst, &_edgda); _eedad != nil {
					return _eedad
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_SlideMasterTextStyles\u0020%v", _edgda.Name)
				if _aadbd := d.Skip(); _aadbd != nil {
					return _aadbd
				}
			}
		case _e.EndElement:
			break _dgbfg
		case _e.CharData:
		}
	}
	return nil
}
func (_egefde *ST_WebColorType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_egefde = 0
	case "none":
		*_egefde = 1
	case "browser":
		*_egefde = 2
	case "presentationText":
		*_egefde = 3
	case "presentationAccent":
		*_egefde = 4
	case "whiteTextOnBlack":
		*_egefde = 5
	case "blackTextOnWhite":
		*_egefde = 6
	}
	return nil
}

// ValidateWithPath validates the CT_TagList and its children, prefixing error messages with path
func (_dfege *CT_TagList) ValidateWithPath(path string) error {
	for _ceedd, _dggaf := range _dfege.Tag {
		if _abfff := _dggaf.ValidateWithPath(_c.Sprintf("\u0025s\u002fTag\u005b\u0025d\u005d", path, _ceedd)); _abfff != nil {
			return _abfff
		}
	}
	return nil
}

type ST_WebScreenSize byte

// Validate validates the CT_Empty and its children
func (_gdad *CT_Empty) Validate() error { return _gdad.ValidateWithPath("CT_Empty") }
func (_bcadd *ST_TLBehaviorOverrideType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fadfd, _gcfcc := d.Token()
	if _gcfcc != nil {
		return _gcfcc
	}
	if _eeefc, _cafca := _fadfd.(_e.EndElement); _cafca && _eeefc.Name == start.Name {
		*_bcadd = 1
		return nil
	}
	if _ebdcce, _adggb := _fadfd.(_e.CharData); !_adggb {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fadfd)
	} else {
		switch string(_ebdcce) {
		case "":
			*_bcadd = 0
		case "normal":
			*_bcadd = 1
		case "childStyle":
			*_bcadd = 2
		}
	}
	_fadfd, _gcfcc = d.Token()
	if _gcfcc != nil {
		return _gcfcc
	}
	if _deace, _efdag := _fadfd.(_e.EndElement); _efdag && _deace.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fadfd)
}
func (_ba *AG_TLBuild) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ba.SpidAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spid"}, Value: _c.Sprintf("\u0025v", *_ba.SpidAttr)})
	}
	if _ba.GrpIdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "grpId"}, Value: _c.Sprintf("\u0025v", *_ba.GrpIdAttr)})
	}
	if _ba.UiExpandAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "uiExpand"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ba.UiExpandAttr))})
	}
	return nil
}

type CT_NotesMasterIdListEntry struct {
	IdAttr string
	ExtLst *CT_ExtensionList
}

func NewCT_SlideIdList() *CT_SlideIdList { _ggfbg := &CT_SlideIdList{}; return _ggfbg }
func NewCT_TransitionStartSoundAction() *CT_TransitionStartSoundAction {
	_fdccc := &CT_TransitionStartSoundAction{}
	_fdccc.Snd = _cb.NewCT_EmbeddedWAVAudioFile()
	return _fdccc
}

// ValidateWithPath validates the CT_TLTriggerTimeNodeID and its children, prefixing error messages with path
func (_ebffb *CT_TLTriggerTimeNodeID) ValidateWithPath(path string) error { return nil }

type CT_TLCommonTimeNodeData struct {

	// ID
	IdAttr *uint32

	// Preset ID
	PresetIDAttr *int32

	// Preset Types
	PresetClassAttr ST_TLTimeNodePresetClassType

	// Preset SubType
	PresetSubtypeAttr *int32

	// Duration
	DurAttr *ST_TLTime

	// Repeat Count
	RepeatCountAttr *ST_TLTime

	// Repeat Duration
	RepeatDurAttr *ST_TLTime

	// Speed
	SpdAttr *_cb.ST_Percentage

	// Acceleration
	AccelAttr *_cb.ST_PositiveFixedPercentage

	// Deceleration
	DecelAttr *_cb.ST_PositiveFixedPercentage

	// Auto Reverse
	AutoRevAttr *bool

	// Restart
	RestartAttr ST_TLTimeNodeRestartType

	// Fill
	FillAttr ST_TLTimeNodeFillType

	// Synchronization Behavior
	SyncBehaviorAttr ST_TLTimeNodeSyncType

	// Time Filter
	TmFilterAttr *string

	// Event Filter
	EvtFilterAttr *string

	// Display
	DisplayAttr *bool

	// Master Relation
	MasterRelAttr ST_TLTimeNodeMasterRelation

	// Build level
	BldLvlAttr *int32

	// Group ID
	GrpIdAttr *uint32

	// After Effect
	AfterEffectAttr *bool

	// Node Type
	NodeTypeAttr ST_TLTimeNodeType

	// Node Placeholder
	NodePhAttr *bool

	// Start Conditions List
	StCondLst *CT_TLTimeConditionList

	// End Conditions List
	EndCondLst *CT_TLTimeConditionList

	// EndSync
	EndSync *CT_TLTimeCondition

	// Iterate
	Iterate *CT_TLIterateData

	// Children Time Node List
	ChildTnLst *CT_TimeNodeList

	// Sub-TimeNodes List
	SubTnLst *CT_TimeNodeList
}

// ValidateWithPath validates the CT_TLIterateData and its children, prefixing error messages with path
func (_fdbaf *CT_TLIterateData) ValidateWithPath(path string) error {
	if _cbfc := _fdbaf.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _cbfc != nil {
		return _cbfc
	}
	if _fdbaf.TmAbs != nil {
		if _fcgbb := _fdbaf.TmAbs.ValidateWithPath(path + "\u002fTmAbs"); _fcgbb != nil {
			return _fcgbb
		}
	}
	if _fdbaf.TmPct != nil {
		if _bggg := _fdbaf.TmPct.ValidateWithPath(path + "\u002fTmPct"); _bggg != nil {
			return _bggg
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CommentAuthor and its children, prefixing error messages with path
func (_cbf *CT_CommentAuthor) ValidateWithPath(path string) error {
	if _cbf.ExtLst != nil {
		if _dcc := _cbf.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _dcc != nil {
			return _dcc
		}
	}
	return nil
}

// Validate validates the CT_Guide and its children
func (_dgde *CT_Guide) Validate() error { return _dgde.ValidateWithPath("CT_Guide") }

// Validate validates the CT_TLAnimVariantBooleanVal and its children
func (_ecdeg *CT_TLAnimVariantBooleanVal) Validate() error {
	return _ecdeg.ValidateWithPath("CT_TLAnimVariantBooleanVal")
}
func (_dbabd *CT_TLIterateIntervalTime) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "val"}, Value: _c.Sprintf("\u0025v", _dbabd.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_EmbeddedFontList and its children, prefixing error messages with path
func (_cgafc *CT_EmbeddedFontList) ValidateWithPath(path string) error {
	for _cefb, _ddcc := range _cgafc.EmbeddedFont {
		if _abc := _ddcc.ValidateWithPath(_c.Sprintf("\u0025s\u002fEmbeddedFont\u005b\u0025d\u005d", path, _cefb)); _abc != nil {
			return _abc
		}
	}
	return nil
}
func NewCT_TLSetBehavior() *CT_TLSetBehavior {
	_gfcaf := &CT_TLSetBehavior{}
	_gfcaf.CBhvr = NewCT_TLCommonBehaviorData()
	return _gfcaf
}
func (_ddeed ST_TLTimeNodeSyncType) Validate() error { return _ddeed.ValidateWithPath("") }
func (_aabgcd *ST_TLOleChartBuildType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_aabgcd = 0
	case "allAtOnce":
		*_aabgcd = 1
	case "series":
		*_aabgcd = 2
	case "category":
		*_aabgcd = 3
	case "seriesEl":
		*_aabgcd = 4
	case "categoryEl":
		*_aabgcd = 5
	}
	return nil
}
func (_cedfb *ST_PhotoAlbumLayout) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_cedfb = 0
	case "fitToSlide":
		*_cedfb = 1
	case "1pic":
		*_cedfb = 2
	case "2pic":
		*_cedfb = 3
	case "4pic":
		*_cedfb = 4
	case "1picTitle":
		*_cedfb = 5
	case "2picTitle":
		*_cedfb = 6
	case "4picTitle":
		*_cedfb = 7
	}
	return nil
}

type CT_PhotoAlbum struct {

	// Black and White
	BwAttr *bool

	// Show/Hide Captions
	ShowCaptionsAttr *bool

	// Photo Album Layout
	LayoutAttr ST_PhotoAlbumLayout

	// Frame Type
	FrameAttr ST_PhotoAlbumFrameShape
	ExtLst    *CT_ExtensionList
}

func NewCT_CustomerDataList() *CT_CustomerDataList { _acabe := &CT_CustomerDataList{}; return _acabe }

// Validate validates the CT_IndexRange and its children
func (_fdc *CT_IndexRange) Validate() error { return _fdc.ValidateWithPath("CT_IndexRange") }
func (_cbdad *ST_TLBehaviorAccumulateType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_cbdad = 0
	case "none":
		*_cbdad = 1
	case "always":
		*_cbdad = 2
	}
	return nil
}
func NewCT_CommentList() *CT_CommentList { _egbe := &CT_CommentList{}; return _egbe }
func (_fbaed *CmLst) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fbaed.CT_CommentList = *NewCT_CommentList()
_eefgg:
	for {
		_ebgdg, _addc := d.Token()
		if _addc != nil {
			return _addc
		}
		switch _afaga := _ebgdg.(type) {
		case _e.StartElement:
			switch _afaga.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cm"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cm"}:
				_ffdbc := NewCT_Comment()
				if _ddda := d.DecodeElement(_ffdbc, &_afaga); _ddda != nil {
					return _ddda
				}
				_fbaed.Cm = append(_fbaed.Cm, _ffdbc)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on CmLst \u0025v", _afaga.Name)
				if _gggfc := d.Skip(); _gggfc != nil {
					return _gggfc
				}
			}
		case _e.EndElement:
			break _eefgg
		case _e.CharData:
		}
	}
	return nil
}
func (_afgddc *CT_TLTriggerRuntimeNode) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	_face, _eaec := _afgddc.ValAttr.MarshalXMLAttr(_e.Name{Local: "val"})
	if _eaec != nil {
		return _eaec
	}
	start.Attr = append(start.Attr, _face)
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type ST_TLAnimateEffectTransition byte

// Validate validates the CT_OleObject and its children
func (_cbee *CT_OleObject) Validate() error { return _cbee.ValidateWithPath("CT_OleObject") }
func (_bafdg *CT_OleObjectEmbed) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _edced := range start.Attr {
		if _edced.Name.Local == "followColorScheme" {
			_bafdg.FollowColorSchemeAttr.UnmarshalXMLAttr(_edced)
			continue
		}
	}
_bbdb:
	for {
		_caeed, _deeb := d.Token()
		if _deeb != nil {
			return _deeb
		}
		switch _ccee := _caeed.(type) {
		case _e.StartElement:
			switch _ccee.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_bafdg.ExtLst = NewCT_ExtensionList()
				if _daged := d.DecodeElement(_bafdg.ExtLst, &_ccee); _daged != nil {
					return _daged
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_OleObjectEmbed\u0020\u0025v", _ccee.Name)
				if _eedb := d.Skip(); _eedb != nil {
					return _eedb
				}
			}
		case _e.EndElement:
			break _bbdb
		case _e.CharData:
		}
	}
	return nil
}

// Validate validates the CT_SlideRelationshipList and its children
func (_fecd *CT_SlideRelationshipList) Validate() error {
	return _fecd.ValidateWithPath("CT_SlideRelationshipList")
}

const (
	ST_WebColorTypeUnset              ST_WebColorType = 0
	ST_WebColorTypeNone               ST_WebColorType = 1
	ST_WebColorTypeBrowser            ST_WebColorType = 2
	ST_WebColorTypePresentationText   ST_WebColorType = 3
	ST_WebColorTypePresentationAccent ST_WebColorType = 4
	ST_WebColorTypeWhiteTextOnBlack   ST_WebColorType = 5
	ST_WebColorTypeBlackTextOnWhite   ST_WebColorType = 6
)

func NewCT_IndexRange() *CT_IndexRange { _ebfga := &CT_IndexRange{}; return _ebfga }
func (_ecbf ST_PrintColorMode) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_efaed := _e.Attr{}
	_efaed.Name = name
	switch _ecbf {
	case ST_PrintColorModeUnset:
		_efaed.Value = ""
	case ST_PrintColorModeBw:
		_efaed.Value = "bw"
	case ST_PrintColorModeGray:
		_efaed.Value = "gray"
	case ST_PrintColorModeClr:
		_efaed.Value = "clr"
	}
	return _efaed, nil
}
func (_bfea *CT_EmbeddedFontDataId) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cgagf := range start.Attr {
		if _cgagf.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _cgagf.Name.Local == "id" || _cgagf.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _cgagf.Name.Local == "id" {
			_ccdc, _bcfa := _cgagf.Value, error(nil)
			if _bcfa != nil {
				return _bcfa
			}
			_bfea.IdAttr = _ccdc
			continue
		}
	}
	for {
		_fgfb, _fea := d.Token()
		if _fea != nil {
			return _c.Errorf("parsing\u0020CT_EmbeddedFontDataId:\u0020\u0025s", _fea)
		}
		if _fgcf, _fedf := _fgfb.(_e.EndElement); _fedf && _fgcf.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_TLBehaviorTransformTypeUnset ST_TLBehaviorTransformType = 0
	ST_TLBehaviorTransformTypePt    ST_TLBehaviorTransformType = 1
	ST_TLBehaviorTransformTypeImg   ST_TLBehaviorTransformType = 2
)

// ValidateWithPath validates the CT_SlideSorterViewProperties and its children, prefixing error messages with path
func (_dffgc *CT_SlideSorterViewProperties) ValidateWithPath(path string) error {
	if _bgff := _dffgc.CViewPr.ValidateWithPath(path + "\u002fCViewPr"); _bgff != nil {
		return _bgff
	}
	if _dffgc.ExtLst != nil {
		if _eagbc := _dffgc.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _eagbc != nil {
			return _eagbc
		}
	}
	return nil
}
func (_ddbd *CT_CustomerData) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _gedg := range start.Attr {
		if _gedg.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _gedg.Name.Local == "id" || _gedg.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _gedg.Name.Local == "id" {
			_acaf, _dec := _gedg.Value, error(nil)
			if _dec != nil {
				return _dec
			}
			_ddbd.IdAttr = _acaf
			continue
		}
	}
	for {
		_egdd, _dcac := d.Token()
		if _dcac != nil {
			return _c.Errorf("parsing CT_CustomerData:\u0020\u0025s", _dcac)
		}
		if _acab, _dff := _egdd.(_e.EndElement); _dff && _acab.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ccgbd *CT_NotesSlide) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _ccgbd.ShowMasterSpAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showMasterSp"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ccgbd.ShowMasterSpAttr))})
	}
	if _ccgbd.ShowMasterPhAnimAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showMasterPhAnim"}, Value: _c.Sprintf("\u0025d", _fdeab(*_ccgbd.ShowMasterPhAnimAttr))})
	}
	e.EncodeToken(start)
	_ebbf := _e.StartElement{Name: _e.Name{Local: "p:cSld"}}
	e.EncodeElement(_ccgbd.CSld, _ebbf)
	if _ccgbd.ClrMapOvr != nil {
		_dadb := _e.StartElement{Name: _e.Name{Local: "p:clrMapOvr"}}
		e.EncodeElement(_ccgbd.ClrMapOvr, _dadb)
	}
	if _ccgbd.ExtLst != nil {
		_effd := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ccgbd.ExtLst, _effd)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_GroupShapeNonVisual() *CT_GroupShapeNonVisual {
	_eefg := &CT_GroupShapeNonVisual{}
	_eefg.CNvPr = _cb.NewCT_NonVisualDrawingProps()
	_eefg.CNvGrpSpPr = _cb.NewCT_NonVisualGroupDrawingShapeProps()
	_eefg.NvPr = NewCT_ApplicationNonVisualDrawingProps()
	return _eefg
}

// ValidateWithPath validates the CT_Empty and its children, prefixing error messages with path
func (_adf *CT_Empty) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the CT_TLTimeCondition and its children, prefixing error messages with path
func (_gggb *CT_TLTimeCondition) ValidateWithPath(path string) error {
	if _edeb := _gggb.EvtAttr.ValidateWithPath(path + "\u002fEvtAttr"); _edeb != nil {
		return _edeb
	}
	if _gggb.DelayAttr != nil {
		if _cfbb := _gggb.DelayAttr.ValidateWithPath(path + "\u002fDelayAttr"); _cfbb != nil {
			return _cfbb
		}
	}
	if _gggb.TgtEl != nil {
		if _ffebf := _gggb.TgtEl.ValidateWithPath(path + "\u002fTgtEl"); _ffebf != nil {
			return _ffebf
		}
	}
	if _gggb.Tn != nil {
		if _ceffa := _gggb.Tn.ValidateWithPath(path + "\u002fTn"); _ceffa != nil {
			return _ceffa
		}
	}
	if _gggb.Rtn != nil {
		if _aegbdc := _gggb.Rtn.ValidateWithPath(path + "\u002fRtn"); _aegbdc != nil {
			return _aegbdc
		}
	}
	return nil
}

type CT_SlideSize struct {

	// Extent Length
	CxAttr int32

	// Extent Width
	CyAttr int32

	// Type of Size
	TypeAttr ST_SlideSizeType
}

// ValidateWithPath validates the Presentation and its children, prefixing error messages with path
func (_cbeag *Presentation) ValidateWithPath(path string) error {
	if _bcdff := _cbeag.CT_Presentation.ValidateWithPath(path); _bcdff != nil {
		return _bcdff
	}
	return nil
}
func (_fgbbd *CT_EmbeddedFontListEntry) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fgbbd.Font = _cb.NewCT_TextFont()
_bgdc:
	for {
		_ddf, _eagb := d.Token()
		if _eagb != nil {
			return _eagb
		}
		switch _dbgg := _ddf.(type) {
		case _e.StartElement:
			switch _dbgg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "font"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "font"}:
				if _aed := d.DecodeElement(_fgbbd.Font, &_dbgg); _aed != nil {
					return _aed
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "regular"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "regular"}:
				_fgbbd.Regular = NewCT_EmbeddedFontDataId()
				if _cbce := d.DecodeElement(_fgbbd.Regular, &_dbgg); _cbce != nil {
					return _cbce
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "bold"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "bold"}:
				_fgbbd.Bold = NewCT_EmbeddedFontDataId()
				if _eaged := d.DecodeElement(_fgbbd.Bold, &_dbgg); _eaged != nil {
					return _eaged
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "italic"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "italic"}:
				_fgbbd.Italic = NewCT_EmbeddedFontDataId()
				if _ddfd := d.DecodeElement(_fgbbd.Italic, &_dbgg); _ddfd != nil {
					return _ddfd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "boldItalic"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "boldItalic"}:
				_fgbbd.BoldItalic = NewCT_EmbeddedFontDataId()
				if _aabc := d.DecodeElement(_fgbbd.BoldItalic, &_dbgg); _aabc != nil {
					return _aabc
				}
			default:
				_ee.Log("skipping\u0020unsupported element\u0020on\u0020CT_EmbeddedFontListEntry\u0020%v", _dbgg.Name)
				if _feb := d.Skip(); _feb != nil {
					return _feb
				}
			}
		case _e.EndElement:
			break _bgdc
		case _e.CharData:
		}
	}
	return nil
}
func (_acagf *CT_SideDirectionTransition) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _eeafa := range start.Attr {
		if _eeafa.Name.Local == "dir" {
			_acagf.DirAttr.UnmarshalXMLAttr(_eeafa)
			continue
		}
	}
	for {
		_bfbf, _ddbge := d.Token()
		if _ddbge != nil {
			return _c.Errorf("parsing\u0020CT_SideDirectionTransition:\u0020\u0025s", _ddbge)
		}
		if _cggdd, _fcag := _bfbf.(_e.EndElement); _fcag && _cggdd.Name == start.Name {
			break
		}
	}
	return nil
}

type ST_TLNextActionType byte

// Validate validates the CT_PhotoAlbum and its children
func (_agecf *CT_PhotoAlbum) Validate() error { return _agecf.ValidateWithPath("CT_PhotoAlbum") }
func (_afbga *CT_SplitTransition) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _ccac := range start.Attr {
		if _ccac.Name.Local == "orient" {
			_afbga.OrientAttr.UnmarshalXMLAttr(_ccac)
			continue
		}
		if _ccac.Name.Local == "dir" {
			_afbga.DirAttr.UnmarshalXMLAttr(_ccac)
			continue
		}
	}
	for {
		_gfged, _gbbgd := d.Token()
		if _gbbgd != nil {
			return _c.Errorf("parsing\u0020CT_SplitTransition:\u0020\u0025s", _gbbgd)
		}
		if _bdgde, _gdfe := _gfged.(_e.EndElement); _gdfe && _bdgde.Name == start.Name {
			break
		}
	}
	return nil
}
func (_decfd ST_WebScreenSize) String() string {
	switch _decfd {
	case 0:
		return ""
	case 1:
		return "544x376"
	case 2:
		return "640x480"
	case 3:
		return "720x512"
	case 4:
		return "800x600"
	case 5:
		return "1024x768"
	case 6:
		return "1152x882"
	case 7:
		return "1152x900"
	case 8:
		return "1280x1024"
	case 9:
		return "1600x1200"
	case 10:
		return "1800x1400"
	case 11:
		return "1920x1200"
	}
	return ""
}
func (_fdbc ST_TransitionInOutDirectionType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_fdbc.String(), start)
}
func (_cbdg *CT_IndexRange) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "st"}, Value: _c.Sprintf("\u0025v", _cbdg.StAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "end"}, Value: _c.Sprintf("\u0025v", _cbdg.EndAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Slide and its children, prefixing error messages with path
func (_dffdg *CT_Slide) ValidateWithPath(path string) error {
	if _bfbg := _dffdg.CSld.ValidateWithPath(path + "\u002fCSld"); _bfbg != nil {
		return _bfbg
	}
	if _dffdg.ClrMapOvr != nil {
		if _fabab := _dffdg.ClrMapOvr.ValidateWithPath(path + "\u002fClrMapOvr"); _fabab != nil {
			return _fabab
		}
	}
	if _dffdg.Transition != nil {
		if _bgfe := _dffdg.Transition.ValidateWithPath(path + "/Transition"); _bgfe != nil {
			return _bgfe
		}
	}
	if _dffdg.Timing != nil {
		if _bgdg := _dffdg.Timing.ValidateWithPath(path + "\u002fTiming"); _bgdg != nil {
			return _bgdg
		}
	}
	if _dffdg.ExtLst != nil {
		if _ddccf := _dffdg.ExtLst.ValidateWithPath(path + "\u002fExtLst"); _ddccf != nil {
			return _ddccf
		}
	}
	return nil
}

const (
	ST_TLAnimateEffectTransitionUnset ST_TLAnimateEffectTransition = 0
	ST_TLAnimateEffectTransitionIn    ST_TLAnimateEffectTransition = 1
	ST_TLAnimateEffectTransitionOut   ST_TLAnimateEffectTransition = 2
	ST_TLAnimateEffectTransitionNone  ST_TLAnimateEffectTransition = 3
)

func (_cfefbg ST_TransitionSpeed) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_cfefbg.String(), start)
}
func (_cfada *ST_TLBehaviorOverrideType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_cfada = 0
	case "normal":
		*_cfada = 1
	case "childStyle":
		*_cfada = 2
	}
	return nil
}

type CT_OleObject struct {

	// Embedded Object ProgID
	ProgIdAttr     *string
	Choice         *CT_OleObjectChoice
	Pic            *CT_Picture
	SpidAttr       *string
	NameAttr       *string
	ShowAsIconAttr *bool
	IdAttr         *string
	ImgWAttr       *int32
	ImgHAttr       *int32
}

func (_gacae *ST_WebScreenSize) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_gacae = 0
	case "544x376":
		*_gacae = 1
	case "640x480":
		*_gacae = 2
	case "720x512":
		*_gacae = 3
	case "800x600":
		*_gacae = 4
	case "1024x768":
		*_gacae = 5
	case "1152x882":
		*_gacae = 6
	case "1152x900":
		*_gacae = 7
	case "1280x1024":
		*_gacae = 8
	case "1600x1200":
		*_gacae = 9
	case "1800x1400":
		*_gacae = 10
	case "1920x1200":
		*_gacae = 11
	}
	return nil
}
func (_fgcbg *ST_PhotoAlbumFrameShape) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cffea, _afgdc := d.Token()
	if _afgdc != nil {
		return _afgdc
	}
	if _cdgag, _efegd := _cffea.(_e.EndElement); _efegd && _cdgag.Name == start.Name {
		*_fgcbg = 1
		return nil
	}
	if _aafac, _aagca := _cffea.(_e.CharData); !_aagca {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cffea)
	} else {
		switch string(_aafac) {
		case "":
			*_fgcbg = 0
		case "frameStyle1":
			*_fgcbg = 1
		case "frameStyle2":
			*_fgcbg = 2
		case "frameStyle3":
			*_fgcbg = 3
		case "frameStyle4":
			*_fgcbg = 4
		case "frameStyle5":
			*_fgcbg = 5
		case "frameStyle6":
			*_fgcbg = 6
		case "frameStyle7":
			*_fgcbg = 7
		}
	}
	_cffea, _afgdc = d.Token()
	if _afgdc != nil {
		return _afgdc
	}
	if _gbed, _fcadc := _cffea.(_e.EndElement); _fcadc && _gbed.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cffea)
}
func NewCT_TagList() *CT_TagList { _aaade := &CT_TagList{}; return _aaade }

// ValidateWithPath validates the CT_TLPoint and its children, prefixing error messages with path
func (_afbdg *CT_TLPoint) ValidateWithPath(path string) error {
	if _gcfba := _afbdg.XAttr.ValidateWithPath(path + "\u002fXAttr"); _gcfba != nil {
		return _gcfba
	}
	if _cgacfd := _afbdg.YAttr.ValidateWithPath(path + "\u002fYAttr"); _cgacfd != nil {
		return _cgacfd
	}
	return nil
}

type CT_TLAnimVariantBooleanVal struct {

	// Value
	ValAttr bool
}

func (_gdbf *SldLayout) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_gdbf.CT_SlideLayout = *NewCT_SlideLayout()
	for _, _bebba := range start.Attr {
		if _bebba.Name.Local == "matchingName" {
			_ebgegb, _gedfg := _bebba.Value, error(nil)
			if _gedfg != nil {
				return _gedfg
			}
			_gdbf.MatchingNameAttr = &_ebgegb
			continue
		}
		if _bebba.Name.Local == "type" {
			_gdbf.TypeAttr.UnmarshalXMLAttr(_bebba)
			continue
		}
		if _bebba.Name.Local == "preserve" {
			_acfcd, _egagd := _b.ParseBool(_bebba.Value)
			if _egagd != nil {
				return _egagd
			}
			_gdbf.PreserveAttr = &_acfcd
			continue
		}
		if _bebba.Name.Local == "userDrawn" {
			_bafbg, _ebeff := _b.ParseBool(_bebba.Value)
			if _ebeff != nil {
				return _ebeff
			}
			_gdbf.UserDrawnAttr = &_bafbg
			continue
		}
		if _bebba.Name.Local == "showMasterSp" {
			_bdddb, _cdfceb := _b.ParseBool(_bebba.Value)
			if _cdfceb != nil {
				return _cdfceb
			}
			_gdbf.ShowMasterSpAttr = &_bdddb
			continue
		}
		if _bebba.Name.Local == "showMasterPhAnim" {
			_eagfa, _eeacaf := _b.ParseBool(_bebba.Value)
			if _eeacaf != nil {
				return _eeacaf
			}
			_gdbf.ShowMasterPhAnimAttr = &_eagfa
			continue
		}
	}
_agbgf:
	for {
		_gdceb, _abgee := d.Token()
		if _abgee != nil {
			return _abgee
		}
		switch _cafa := _gdceb.(type) {
		case _e.StartElement:
			switch _cafa.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cSld"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cSld"}:
				if _fagfdg := d.DecodeElement(_gdbf.CSld, &_cafa); _fagfdg != nil {
					return _fagfdg
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "clrMapOvr"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "clrMapOvr"}:
				_gdbf.ClrMapOvr = _cb.NewCT_ColorMappingOverride()
				if _dbfec := d.DecodeElement(_gdbf.ClrMapOvr, &_cafa); _dbfec != nil {
					return _dbfec
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "transition"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "transition"}:
				_gdbf.Transition = NewCT_SlideTransition()
				if _ebafb := d.DecodeElement(_gdbf.Transition, &_cafa); _ebafb != nil {
					return _ebafb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "timing"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "timing"}:
				_gdbf.Timing = NewCT_SlideTiming()
				if _dacgb := d.DecodeElement(_gdbf.Timing, &_cafa); _dacgb != nil {
					return _dacgb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "hf"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "hf"}:
				_gdbf.Hf = NewCT_HeaderFooter()
				if _adaae := d.DecodeElement(_gdbf.Hf, &_cafa); _adaae != nil {
					return _adaae
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_gdbf.ExtLst = NewCT_ExtensionListModify()
				if _accbg := d.DecodeElement(_gdbf.ExtLst, &_cafa); _accbg != nil {
					return _accbg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on SldLayout \u0025v", _cafa.Name)
				if _ffdf := d.Skip(); _ffdf != nil {
					return _ffdf
				}
			}
		case _e.EndElement:
			break _agbgf
		case _e.CharData:
		}
	}
	return nil
}
func (_dafae *EG_ExtensionList) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _dafae.Ext != nil {
		_befba := _e.StartElement{Name: _e.Name{Local: "p:ext"}}
		for _, _cdccd := range _dafae.Ext {
			e.EncodeElement(_cdccd, _befba)
		}
	}
	return nil
}
func (_ggba *CT_Connector) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_aeec := _e.StartElement{Name: _e.Name{Local: "p:nvCxnSpPr"}}
	e.EncodeElement(_ggba.NvCxnSpPr, _aeec)
	_caf := _e.StartElement{Name: _e.Name{Local: "p:spPr"}}
	e.EncodeElement(_ggba.SpPr, _caf)
	if _ggba.Style != nil {
		_cgef := _e.StartElement{Name: _e.Name{Local: "p:style"}}
		e.EncodeElement(_ggba.Style, _cgef)
	}
	if _ggba.ExtLst != nil {
		_faaf := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_ggba.ExtLst, _faaf)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Connector and its children
func (_ebad *CT_Connector) Validate() error { return _ebad.ValidateWithPath("CT_Connector") }

type EG_SlideListChoice struct {

	// All Slides
	SldAll *CT_Empty

	// Slide Range
	SldRg *CT_IndexRange

	// Custom Show
	CustShow *CT_CustomShowId
}

func (_edae *CT_TLByRgbColorTransform) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r"}, Value: _c.Sprintf("\u0025v", _edae.RAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "g"}, Value: _c.Sprintf("\u0025v", _edae.GAttr)})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "b"}, Value: _c.Sprintf("\u0025v", _edae.BAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_PrintProperties() *CT_PrintProperties { _dgeec := &CT_PrintProperties{}; return _dgeec }
func NewCT_WheelTransition() *CT_WheelTransition { _fdcdec := &CT_WheelTransition{}; return _fdcdec }
func (_baef *CT_Comment) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_baef.Pos = _cb.NewCT_Point2D()
	for _, _cgda := range start.Attr {
		if _cgda.Name.Local == "authorId" {
			_dbbf, _bab := _b.ParseUint(_cgda.Value, 10, 32)
			if _bab != nil {
				return _bab
			}
			_baef.AuthorIdAttr = uint32(_dbbf)
			continue
		}
		if _cgda.Name.Local == "dt" {
			_fdd, _dae := ParseStdlibTime(_cgda.Value)
			if _dae != nil {
				return _dae
			}
			_baef.DtAttr = &_fdd
			continue
		}
		if _cgda.Name.Local == "idx" {
			_gdaf, _adgd := _b.ParseUint(_cgda.Value, 10, 32)
			if _adgd != nil {
				return _adgd
			}
			_baef.IdxAttr = uint32(_gdaf)
			continue
		}
	}
_bddf:
	for {
		_cbdc, _bebb := d.Token()
		if _bebb != nil {
			return _bebb
		}
		switch _cbbg := _cbdc.(type) {
		case _e.StartElement:
			switch _cbbg.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "pos"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "pos"}:
				if _bdc := d.DecodeElement(_baef.Pos, &_cbbg); _bdc != nil {
					return _bdc
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "text"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "text"}:
				if _ace := d.DecodeElement(&_baef.Text, &_cbbg); _ace != nil {
					return _ace
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_baef.ExtLst = NewCT_ExtensionListModify()
				if _afe := d.DecodeElement(_baef.ExtLst, &_cbbg); _afe != nil {
					return _afe
				}
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_Comment\u0020\u0025v", _cbbg.Name)
				if _dgada := d.Skip(); _dgada != nil {
					return _dgada
				}
			}
		case _e.EndElement:
			break _bddf
		case _e.CharData:
		}
	}
	return nil
}
func NewCT_StringTag() *CT_StringTag { _adbcga := &CT_StringTag{}; return _adbcga }
func (_ddeee *CT_OptionalBlackTransition) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _eafc := range start.Attr {
		if _eafc.Name.Local == "thruBlk" {
			_daea, _efgd := _b.ParseBool(_eafc.Value)
			if _efgd != nil {
				return _efgd
			}
			_ddeee.ThruBlkAttr = &_daea
			continue
		}
	}
	for {
		_ffce, _feaf := d.Token()
		if _feaf != nil {
			return _c.Errorf("parsing\u0020CT_OptionalBlackTransition:\u0020\u0025s", _feaf)
		}
		if _caeb, _deaa := _ffce.(_e.EndElement); _deaa && _caeb.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_CustomerDataList struct {

	// Customer Data
	CustData []*CT_CustomerData

	// Customer Data Tags
	Tags *CT_TagsData
}

// ValidateWithPath validates the AG_Ole and its children, prefixing error messages with path
func (_ad *AG_Ole) ValidateWithPath(path string) error {
	if _ad.ImgWAttr != nil {
		if *_ad.ImgWAttr < 0 {
			return _c.Errorf("\u0025s/m\u002eImgWAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_ad.ImgWAttr)
		}
	}
	if _ad.ImgHAttr != nil {
		if *_ad.ImgHAttr < 0 {
			return _c.Errorf("\u0025s/m\u002eImgHAttr must\u0020be\u0020\u003e\u003d\u00200 \u0028have\u0020\u0025v\u0029", path, *_ad.ImgHAttr)
		}
	}
	return nil
}

type Presentation struct{ CT_Presentation }

func (_eceb *CT_ModifyVerifier) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _eceb.AlgorithmNameAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "algorithmName"}, Value: _c.Sprintf("\u0025v", *_eceb.AlgorithmNameAttr)})
	}
	if _eceb.HashValueAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "hashValue"}, Value: _c.Sprintf("\u0025v", *_eceb.HashValueAttr)})
	}
	if _eceb.SaltValueAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "saltValue"}, Value: _c.Sprintf("\u0025v", *_eceb.SaltValueAttr)})
	}
	if _eceb.SpinValueAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spinValue"}, Value: _c.Sprintf("\u0025v", *_eceb.SpinValueAttr)})
	}
	if _eceb.CryptProviderTypeAttr != _d.ST_CryptProvUnset {
		_dded, _aefe := _eceb.CryptProviderTypeAttr.MarshalXMLAttr(_e.Name{Local: "cryptProviderType"})
		if _aefe != nil {
			return _aefe
		}
		start.Attr = append(start.Attr, _dded)
	}
	if _eceb.CryptAlgorithmClassAttr != _d.ST_AlgClassUnset {
		_cbba, _ggfe := _eceb.CryptAlgorithmClassAttr.MarshalXMLAttr(_e.Name{Local: "cryptAlgorithmClass"})
		if _ggfe != nil {
			return _ggfe
		}
		start.Attr = append(start.Attr, _cbba)
	}
	if _eceb.CryptAlgorithmTypeAttr != _d.ST_AlgTypeUnset {
		_cgddc, _fdbb := _eceb.CryptAlgorithmTypeAttr.MarshalXMLAttr(_e.Name{Local: "cryptAlgorithmType"})
		if _fdbb != nil {
			return _fdbb
		}
		start.Attr = append(start.Attr, _cgddc)
	}
	if _eceb.CryptAlgorithmSidAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "cryptAlgorithmSid"}, Value: _c.Sprintf("\u0025v", *_eceb.CryptAlgorithmSidAttr)})
	}
	if _eceb.SpinCountAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "spinCount"}, Value: _c.Sprintf("\u0025v", *_eceb.SpinCountAttr)})
	}
	if _eceb.SaltDataAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "saltData"}, Value: _c.Sprintf("\u0025v", *_eceb.SaltDataAttr)})
	}
	if _eceb.HashDataAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "hashData"}, Value: _c.Sprintf("\u0025v", *_eceb.HashDataAttr)})
	}
	if _eceb.CryptProviderAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "cryptProvider"}, Value: _c.Sprintf("\u0025v", *_eceb.CryptProviderAttr)})
	}
	if _eceb.AlgIdExtAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "algIdExt"}, Value: _c.Sprintf("\u0025v", *_eceb.AlgIdExtAttr)})
	}
	if _eceb.AlgIdExtSourceAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "algIdExtSource"}, Value: _c.Sprintf("\u0025v", *_eceb.AlgIdExtSourceAttr)})
	}
	if _eceb.CryptProviderTypeExtAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "cryptProviderTypeExt"}, Value: _c.Sprintf("\u0025v", *_eceb.CryptProviderTypeExtAttr)})
	}
	if _eceb.CryptProviderTypeExtSourceAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "cryptProviderTypeExtSource"}, Value: _c.Sprintf("\u0025v", *_eceb.CryptProviderTypeExtSourceAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func NewCT_ExtensionListModify() *CT_ExtensionListModify {
	_aede := &CT_ExtensionListModify{}
	return _aede
}
func (_eacbe ST_PrintWhat) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_eacbe.String(), start)
}
func NewCT_ShowInfoBrowse() *CT_ShowInfoBrowse { _ddgf := &CT_ShowInfoBrowse{}; return _ddgf }
func (_bgaec *ST_TransitionSideDirectionType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_edfba, _dccdd := d.Token()
	if _dccdd != nil {
		return _dccdd
	}
	if _edeba, _cgfge := _edfba.(_e.EndElement); _cgfge && _edeba.Name == start.Name {
		*_bgaec = 1
		return nil
	}
	if _bgfg, _gdbgg := _edfba.(_e.CharData); !_gdbgg {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _edfba)
	} else {
		switch string(_bgfg) {
		case "":
			*_bgaec = 0
		case "l":
			*_bgaec = 1
		case "u":
			*_bgaec = 2
		case "r":
			*_bgaec = 3
		case "d":
			*_bgaec = 4
		}
	}
	_edfba, _dccdd = d.Token()
	if _dccdd != nil {
		return _dccdd
	}
	if _aadcbc, _cbac := _edfba.(_e.EndElement); _cbac && _aadcbc.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _edfba)
}
func (_agfg ST_PhotoAlbumLayout) String() string {
	switch _agfg {
	case 0:
		return ""
	case 1:
		return "fitToSlide"
	case 2:
		return "1pic"
	case 3:
		return "2pic"
	case 4:
		return "4pic"
	case 5:
		return "1picTitle"
	case 6:
		return "2picTitle"
	case 7:
		return "4picTitle"
	}
	return ""
}
func (_cccdd *CT_TLSetBehavior) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_bcgcd := _e.StartElement{Name: _e.Name{Local: "p:cBhvr"}}
	e.EncodeElement(_cccdd.CBhvr, _bcgcd)
	if _cccdd.To != nil {
		_fecg := _e.StartElement{Name: _e.Name{Local: "p:to"}}
		e.EncodeElement(_cccdd.To, _fecg)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_TLTemplateList struct {

	// Template Effects
	Tmpl []*CT_TLTemplate
}

// ValidateWithPath validates the CT_GraphicalObjectFrameNonVisual and its children, prefixing error messages with path
func (_eef *CT_GraphicalObjectFrameNonVisual) ValidateWithPath(path string) error {
	if _dbee := _eef.CNvPr.ValidateWithPath(path + "\u002fCNvPr"); _dbee != nil {
		return _dbee
	}
	if _agfea := _eef.CNvGraphicFramePr.ValidateWithPath(path + "\u002fCNvGraphicFramePr"); _agfea != nil {
		return _agfea
	}
	if _beae := _eef.NvPr.ValidateWithPath(path + "\u002fNvPr"); _beae != nil {
		return _beae
	}
	return nil
}

// Validate validates the CT_TagsData and its children
func (_ebadd *CT_TagsData) Validate() error { return _ebadd.ValidateWithPath("CT_TagsData") }
func (_adbeg *SldSyncPr) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_adbeg.CT_SlideSyncProperties = *NewCT_SlideSyncProperties()
	for _, _bfdd := range start.Attr {
		if _bfdd.Name.Local == "serverSldId" {
			_gadefc, _efgef := _bfdd.Value, error(nil)
			if _efgef != nil {
				return _efgef
			}
			_adbeg.ServerSldIdAttr = _gadefc
			continue
		}
		if _bfdd.Name.Local == "serverSldModifiedTime" {
			_becde, _afbcf := ParseStdlibTime(_bfdd.Value)
			if _afbcf != nil {
				return _afbcf
			}
			_adbeg.ServerSldModifiedTimeAttr = _becde
			continue
		}
		if _bfdd.Name.Local == "clientInsertedTime" {
			_defgb, _bddbd := ParseStdlibTime(_bfdd.Value)
			if _bddbd != nil {
				return _bddbd
			}
			_adbeg.ClientInsertedTimeAttr = _defgb
			continue
		}
	}
_baecb:
	for {
		_gbdca, _abgbb := d.Token()
		if _abgbb != nil {
			return _abgbb
		}
		switch _ddfdgb := _gbdca.(type) {
		case _e.StartElement:
			switch _ddfdgb.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "extLst"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "extLst"}:
				_adbeg.ExtLst = NewCT_ExtensionList()
				if _gafac := d.DecodeElement(_adbeg.ExtLst, &_ddfdgb); _gafac != nil {
					return _gafac
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on SldSyncPr \u0025v", _ddfdgb.Name)
				if _ffed := d.Skip(); _ffed != nil {
					return _ffed
				}
			}
		case _e.EndElement:
			break _baecb
		case _e.CharData:
		}
	}
	return nil
}

type CT_TLTriggerTimeNodeID struct {

	// Value
	ValAttr uint32
}

func NewCT_TLIterateIntervalTime() *CT_TLIterateIntervalTime {
	_eeddg := &CT_TLIterateIntervalTime{}
	return _eeddg
}
func (_dbaeb ST_TLOleChartBuildType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_dbaeb.String(), start)
}

type CT_CustomShowList struct {

	// Custom Show
	CustShow []*CT_CustomShow
}

// ValidateWithPath validates the CT_TLSetBehavior and its children, prefixing error messages with path
func (_cege *CT_TLSetBehavior) ValidateWithPath(path string) error {
	if _dadgde := _cege.CBhvr.ValidateWithPath(path + "\u002fCBhvr"); _dadgde != nil {
		return _dadgde
	}
	if _cege.To != nil {
		if _addab := _cege.To.ValidateWithPath(path + "\u002fTo"); _addab != nil {
			return _addab
		}
	}
	return nil
}
func (_fcga *CT_Extension) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "uri"}, Value: _c.Sprintf("\u0025v", _fcga.UriAttr)})
	e.EncodeToken(start)
	if _fcga.Any != nil {
		for _, _bgeg := range _fcga.Any {
			_bgeg.MarshalXML(e, _e.StartElement{})
		}
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_OrientationTransition and its children, prefixing error messages with path
func (_ddba *CT_OrientationTransition) ValidateWithPath(path string) error {
	if _eaee := _ddba.DirAttr.ValidateWithPath(path + "\u002fDirAttr"); _eaee != nil {
		return _eaee
	}
	return nil
}

// Validate validates the Presentation and its children
func (_dadaa *Presentation) Validate() error { return _dadaa.ValidateWithPath("Presentation") }

// ValidateWithPath validates the CT_BuildList and its children, prefixing error messages with path
func (_ggg *CT_BuildList) ValidateWithPath(path string) error {
	for _fef, _afcd := range _ggg.BldP {
		if _cef := _afcd.ValidateWithPath(_c.Sprintf("%s\u002fBldP\u005b\u0025d\u005d", path, _fef)); _cef != nil {
			return _cef
		}
	}
	for _bcgf, _bbca := range _ggg.BldDgm {
		if _gcgf := _bbca.ValidateWithPath(_c.Sprintf("\u0025s\u002fBldDgm\u005b\u0025d\u005d", path, _bcgf)); _gcgf != nil {
			return _gcgf
		}
	}
	for _bbf, _dbb := range _ggg.BldOleChart {
		if _bea := _dbb.ValidateWithPath(_c.Sprintf("\u0025s\u002fBldOleChart\u005b\u0025d\u005d", path, _bbf)); _bea != nil {
			return _bea
		}
	}
	for _eag, _abb := range _ggg.BldGraphic {
		if _egf := _abb.ValidateWithPath(_c.Sprintf("\u0025s\u002fBldGraphic\u005b\u0025d\u005d", path, _eag)); _egf != nil {
			return _egf
		}
	}
	return nil
}

// Validate validates the CT_SplitTransition and its children
func (_cfgee *CT_SplitTransition) Validate() error {
	return _cfgee.ValidateWithPath("CT_SplitTransition")
}
func (_dggcb *ST_TLTimeNodeMasterRelation) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_dggcb = 0
	case "sameClick":
		*_dggcb = 1
	case "lastClick":
		*_dggcb = 2
	case "nextClick":
		*_dggcb = 3
	}
	return nil
}
func (_fgdaa ST_TLOleChartBuildType) ValidateWithPath(path string) error {
	switch _fgdaa {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fgdaa))
	}
	return nil
}
func (_gcffb ST_TransitionEightDirectionType) String() string {
	if _gcffb.ST_TransitionSideDirectionType != ST_TransitionSideDirectionTypeUnset {
		return _gcffb.ST_TransitionSideDirectionType.String()
	}
	if _gcffb.ST_TransitionCornerDirectionType != ST_TransitionCornerDirectionTypeUnset {
		return _gcffb.ST_TransitionCornerDirectionType.String()
	}
	return ""
}
func NewCT_SlideLayout() *CT_SlideLayout {
	_ffaee := &CT_SlideLayout{}
	_ffaee.CSld = NewCT_CommonSlideData()
	return _ffaee
}
func (_fcbc ST_TLTriggerEvent) Validate() error { return _fcbc.ValidateWithPath("") }
func (_baaeg *CT_CustomShowId) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _cdgf := range start.Attr {
		if _cdgf.Name.Local == "id" {
			_gceb, _gcgc := _b.ParseUint(_cdgf.Value, 10, 32)
			if _gcgc != nil {
				return _gcgc
			}
			_baaeg.IdAttr = uint32(_gceb)
			continue
		}
	}
	for {
		_baaa, _aagd := d.Token()
		if _aagd != nil {
			return _c.Errorf("parsing CT_CustomShowId:\u0020\u0025s", _aagd)
		}
		if _age, _ccec := _baaa.(_e.EndElement); _ccec && _age.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_CornerDirectionTransition struct {

	// Direction
	DirAttr ST_TransitionCornerDirectionType
}

// ValidateWithPath validates the CT_TLAnimateMotionBehavior and its children, prefixing error messages with path
func (_dfbaa *CT_TLAnimateMotionBehavior) ValidateWithPath(path string) error {
	if _fdcd := _dfbaa.OriginAttr.ValidateWithPath(path + "/OriginAttr"); _fdcd != nil {
		return _fdcd
	}
	if _adedg := _dfbaa.PathEditModeAttr.ValidateWithPath(path + "\u002fPathEditModeAttr"); _adedg != nil {
		return _adedg
	}
	if _eegg := _dfbaa.CBhvr.ValidateWithPath(path + "\u002fCBhvr"); _eegg != nil {
		return _eegg
	}
	if _dfbaa.By != nil {
		if _bdead := _dfbaa.By.ValidateWithPath(path + "\u002fBy"); _bdead != nil {
			return _bdead
		}
	}
	if _dfbaa.From != nil {
		if _aead := _dfbaa.From.ValidateWithPath(path + "\u002fFrom"); _aead != nil {
			return _aead
		}
	}
	if _dfbaa.To != nil {
		if _cecd := _dfbaa.To.ValidateWithPath(path + "\u002fTo"); _cecd != nil {
			return _cecd
		}
	}
	if _dfbaa.RCtr != nil {
		if _feafbc := _dfbaa.RCtr.ValidateWithPath(path + "\u002fRCtr"); _feafbc != nil {
			return _feafbc
		}
	}
	return nil
}
func (_dccde ST_TLAnimateMotionBehaviorOrigin) Validate() error { return _dccde.ValidateWithPath("") }
func NewCT_Rel() *CT_Rel                                        { _ddeec := &CT_Rel{}; return _ddeec }
func (_daeabg ST_SplitterBarState) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_daeabg.String(), start)
}
func NewCT_Presentation() *CT_Presentation {
	_gfcd := &CT_Presentation{}
	_gfcd.NotesSz = _cb.NewCT_PositiveSize2D()
	return _gfcd
}

// ValidateWithPath validates the CT_ShowInfoKiosk and its children, prefixing error messages with path
func (_bafc *CT_ShowInfoKiosk) ValidateWithPath(path string) error { return nil }

type ST_SplitterBarState byte

func NewCT_TLTriggerRuntimeNode() *CT_TLTriggerRuntimeNode {
	_geda := &CT_TLTriggerRuntimeNode{}
	_geda.ValAttr = ST_TLTriggerRuntimeNode(1)
	return _geda
}
func (_gcbcb *ST_PlaceholderType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_agdcf, _ebfeb := d.Token()
	if _ebfeb != nil {
		return _ebfeb
	}
	if _ggcbf, _egedb := _agdcf.(_e.EndElement); _egedb && _ggcbf.Name == start.Name {
		*_gcbcb = 1
		return nil
	}
	if _dfda, _fefebd := _agdcf.(_e.CharData); !_fefebd {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _agdcf)
	} else {
		switch string(_dfda) {
		case "":
			*_gcbcb = 0
		case "title":
			*_gcbcb = 1
		case "body":
			*_gcbcb = 2
		case "ctrTitle":
			*_gcbcb = 3
		case "subTitle":
			*_gcbcb = 4
		case "dt":
			*_gcbcb = 5
		case "sldNum":
			*_gcbcb = 6
		case "ftr":
			*_gcbcb = 7
		case "hdr":
			*_gcbcb = 8
		case "obj":
			*_gcbcb = 9
		case "chart":
			*_gcbcb = 10
		case "tbl":
			*_gcbcb = 11
		case "clipArt":
			*_gcbcb = 12
		case "dgm":
			*_gcbcb = 13
		case "media":
			*_gcbcb = 14
		case "sldImg":
			*_gcbcb = 15
		case "pic":
			*_gcbcb = 16
		}
	}
	_agdcf, _ebfeb = d.Token()
	if _ebfeb != nil {
		return _ebfeb
	}
	if _eacf, _bfedfc := _agdcf.(_e.EndElement); _bfedfc && _eacf.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _agdcf)
}

type CT_BuildList struct {

	// Build Paragraph
	BldP []*CT_TLBuildParagraph

	// Build Diagram
	BldDgm []*CT_TLBuildDiagram

	// Build Embedded Chart
	BldOleChart []*CT_TLOleBuildChart

	// Build Graphics
	BldGraphic []*CT_TLGraphicalObjectBuild
}

// Validate validates the PresentationPr and its children
func (_cdafca *PresentationPr) Validate() error { return _cdafca.ValidateWithPath("PresentationPr") }
func NewNotesMaster() *NotesMaster {
	_aada := &NotesMaster{}
	_aada.CT_NotesMaster = *NewCT_NotesMaster()
	return _aada
}

// Validate validates the CT_TLByRgbColorTransform and its children
func (_acdcc *CT_TLByRgbColorTransform) Validate() error {
	return _acdcc.ValidateWithPath("CT_TLByRgbColorTransform")
}
func (_dacfb ST_TLAnimateMotionPathEditMode) String() string {
	switch _dacfb {
	case 0:
		return ""
	case 1:
		return "relative"
	case 2:
		return "fixed"
	}
	return ""
}
func (_geagd *ST_SlideSizeType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_geagd = 0
	case "screen4x3":
		*_geagd = 1
	case "letter":
		*_geagd = 2
	case "A4":
		*_geagd = 3
	case "35mm":
		*_geagd = 4
	case "overhead":
		*_geagd = 5
	case "banner":
		*_geagd = 6
	case "custom":
		*_geagd = 7
	case "ledger":
		*_geagd = 8
	case "A3":
		*_geagd = 9
	case "B4ISO":
		*_geagd = 10
	case "B5ISO":
		*_geagd = 11
	case "B4JIS":
		*_geagd = 12
	case "B5JIS":
		*_geagd = 13
	case "hagakiCard":
		*_geagd = 14
	case "screen16x9":
		*_geagd = 15
	case "screen16x10":
		*_geagd = 16
	}
	return nil
}
func (_cgdee ST_TransitionSideDirectionType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_faef := _e.Attr{}
	_faef.Name = name
	switch _cgdee {
	case ST_TransitionSideDirectionTypeUnset:
		_faef.Value = ""
	case ST_TransitionSideDirectionTypeL:
		_faef.Value = "l"
	case ST_TransitionSideDirectionTypeU:
		_faef.Value = "u"
	case ST_TransitionSideDirectionTypeR:
		_faef.Value = "r"
	case ST_TransitionSideDirectionTypeD:
		_faef.Value = "d"
	}
	return _faef, nil
}
func (_aad *CT_CommentAuthorList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_efgb:
	for {
		_bac, _abdd := d.Token()
		if _abdd != nil {
			return _abdd
		}
		switch _baa := _bac.(type) {
		case _e.StartElement:
			switch _baa.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "cmAuthor"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "cmAuthor"}:
				_fgc := NewCT_CommentAuthor()
				if _dcf := d.DecodeElement(_fgc, &_baa); _dcf != nil {
					return _dcf
				}
				_aad.CmAuthor = append(_aad.CmAuthor, _fgc)
			default:
				_ee.Log("skipping\u0020unsupported\u0020element on\u0020CT_CommentAuthorList\u0020\u0025v", _baa.Name)
				if _cfdf := d.Skip(); _cfdf != nil {
					return _cfdf
				}
			}
		case _e.EndElement:
			break _efgb
		case _e.CharData:
		}
	}
	return nil
}
func (_eaddb *ST_TLTimeAnimateValueTime) Validate() error { return _eaddb.ValidateWithPath("") }

// Validate validates the CT_NotesMasterIdListEntry and its children
func (_fge *CT_NotesMasterIdListEntry) Validate() error {
	return _fge.ValidateWithPath("CT_NotesMasterIdListEntry")
}
func (_effbc ST_TransitionCornerDirectionType) Validate() error { return _effbc.ValidateWithPath("") }
func NewCT_InOutTransition() *CT_InOutTransition                { _gdcbf := &CT_InOutTransition{}; return _gdcbf }

// ValidateWithPath validates the NotesMaster and its children, prefixing error messages with path
func (_gedc *NotesMaster) ValidateWithPath(path string) error {
	if _bdbff := _gedc.CT_NotesMaster.ValidateWithPath(path); _bdbff != nil {
		return _bdbff
	}
	return nil
}
func (_ecedee *CT_SmartTags) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _ecedee.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_eaac ST_TLAnimateBehaviorValueType) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	return e.EncodeElement(_eaac.String(), start)
}
func (_bccg *CT_TLAnimVariant) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	if _bccg.BoolVal != nil {
		_cbad := _e.StartElement{Name: _e.Name{Local: "p:boolVal"}}
		e.EncodeElement(_bccg.BoolVal, _cbad)
	}
	if _bccg.IntVal != nil {
		_ddeab := _e.StartElement{Name: _e.Name{Local: "p:intVal"}}
		e.EncodeElement(_bccg.IntVal, _ddeab)
	}
	if _bccg.FltVal != nil {
		_daggg := _e.StartElement{Name: _e.Name{Local: "p:fltVal"}}
		e.EncodeElement(_bccg.FltVal, _daggg)
	}
	if _bccg.StrVal != nil {
		_eccf := _e.StartElement{Name: _e.Name{Local: "p:strVal"}}
		e.EncodeElement(_bccg.StrVal, _eccf)
	}
	if _bccg.ClrVal != nil {
		_cfcb := _e.StartElement{Name: _e.Name{Local: "p:clrVal"}}
		e.EncodeElement(_bccg.ClrVal, _cfcb)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

const (
	ST_TLTimeNodePresetClassTypeUnset     ST_TLTimeNodePresetClassType = 0
	ST_TLTimeNodePresetClassTypeEntr      ST_TLTimeNodePresetClassType = 1
	ST_TLTimeNodePresetClassTypeExit      ST_TLTimeNodePresetClassType = 2
	ST_TLTimeNodePresetClassTypeEmph      ST_TLTimeNodePresetClassType = 3
	ST_TLTimeNodePresetClassTypePath      ST_TLTimeNodePresetClassType = 4
	ST_TLTimeNodePresetClassTypeVerb      ST_TLTimeNodePresetClassType = 5
	ST_TLTimeNodePresetClassTypeMediacall ST_TLTimeNodePresetClassType = 6
)

func NewCT_TLOleBuildChart() *CT_TLOleBuildChart { _bfec := &CT_TLOleBuildChart{}; return _bfec }

type AG_ChildSlide struct {
	ShowMasterSpAttr     *bool
	ShowMasterPhAnimAttr *bool
}

const (
	ST_PrintWhatUnset     ST_PrintWhat = 0
	ST_PrintWhatSlides    ST_PrintWhat = 1
	ST_PrintWhatHandouts1 ST_PrintWhat = 2
	ST_PrintWhatHandouts2 ST_PrintWhat = 3
	ST_PrintWhatHandouts3 ST_PrintWhat = 4
	ST_PrintWhatHandouts4 ST_PrintWhat = 5
	ST_PrintWhatHandouts6 ST_PrintWhat = 6
	ST_PrintWhatHandouts9 ST_PrintWhat = 7
	ST_PrintWhatNotes     ST_PrintWhat = 8
	ST_PrintWhatOutline   ST_PrintWhat = 9
)

func (_bagf *CT_PhotoAlbum) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _bagf.BwAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "bw"}, Value: _c.Sprintf("\u0025d", _fdeab(*_bagf.BwAttr))})
	}
	if _bagf.ShowCaptionsAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "showCaptions"}, Value: _c.Sprintf("\u0025d", _fdeab(*_bagf.ShowCaptionsAttr))})
	}
	if _bagf.LayoutAttr != ST_PhotoAlbumLayoutUnset {
		_fbca, _affda := _bagf.LayoutAttr.MarshalXMLAttr(_e.Name{Local: "layout"})
		if _affda != nil {
			return _affda
		}
		start.Attr = append(start.Attr, _fbca)
	}
	if _bagf.FrameAttr != ST_PhotoAlbumFrameShapeUnset {
		_ggfd, _bebff := _bagf.FrameAttr.MarshalXMLAttr(_e.Name{Local: "frame"})
		if _bebff != nil {
			return _bebff
		}
		start.Attr = append(start.Attr, _ggfd)
	}
	e.EncodeToken(start)
	if _bagf.ExtLst != nil {
		_aceg := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_bagf.ExtLst, _aceg)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_TLAnimateEffectBehavior struct {

	// Transition
	TransitionAttr ST_TLAnimateEffectTransition

	// Filter
	FilterAttr *string

	// Property List
	PrLstAttr *string
	CBhvr     *CT_TLCommonBehaviorData

	// Progress
	Progress *CT_TLAnimVariant
}
type CT_ExtensionList struct {

	// Extension
	Ext []*CT_Extension
}

func NewCT_TLTimeNodeExclusive() *CT_TLTimeNodeExclusive {
	_dbfag := &CT_TLTimeNodeExclusive{}
	_dbfag.CTn = NewCT_TLCommonTimeNodeData()
	return _dbfag
}
func NewCT_EightDirectionTransition() *CT_EightDirectionTransition {
	_bcge := &CT_EightDirectionTransition{}
	return _bcge
}
func (_aefec *CT_SlideRelationshipListEntry) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	for _, _geebb := range start.Attr {
		if _geebb.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _geebb.Name.Local == "id" || _geebb.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _geebb.Name.Local == "id" {
			_cfcea, _bcff := _geebb.Value, error(nil)
			if _bcff != nil {
				return _bcff
			}
			_aefec.IdAttr = _cfcea
			continue
		}
	}
	for {
		_eeffe, _bcfeb := d.Token()
		if _bcfeb != nil {
			return _c.Errorf("parsing\u0020CT_SlideRelationshipListEntry:\u0020\u0025s", _bcfeb)
		}
		if _ccbf, _fgffc := _eeffe.(_e.EndElement); _fgffc && _ccbf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cccbe *CT_TagList) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_daadb:
	for {
		_aced, _ddffc := d.Token()
		if _ddffc != nil {
			return _ddffc
		}
		switch _faaee := _aced.(type) {
		case _e.StartElement:
			switch _faaee.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "tag"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "tag"}:
				_bfbab := NewCT_StringTag()
				if _ggbae := d.DecodeElement(_bfbab, &_faaee); _ggbae != nil {
					return _ggbae
				}
				_cccbe.Tag = append(_cccbe.Tag, _bfbab)
			default:
				_ee.Log("skipping unsupported\u0020element\u0020on\u0020CT_TagList\u0020\u0025v", _faaee.Name)
				if _cgbgg := d.Skip(); _cgbgg != nil {
					return _cgbgg
				}
			}
		case _e.EndElement:
			break _daadb
		case _e.CharData:
		}
	}
	return nil
}
func (_cbe *CT_OleObject) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_cbe.Choice = NewCT_OleObjectChoice()
	for _, _ecbd := range start.Attr {
		if _ecbd.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _ecbd.Name.Local == "id" {
			_bag, _edffc := _ecbd.Value, error(nil)
			if _edffc != nil {
				return _edffc
			}
			_cbe.IdAttr = &_bag
			continue
		}
		if _ecbd.Name.Local == "spid" {
			_bead, _bbcgf := _ecbd.Value, error(nil)
			if _bbcgf != nil {
				return _bbcgf
			}
			_cbe.SpidAttr = &_bead
			continue
		}
		if _ecbd.Name.Local == "name" {
			_fcbf, _edeef := _ecbd.Value, error(nil)
			if _edeef != nil {
				return _edeef
			}
			_cbe.NameAttr = &_fcbf
			continue
		}
		if _ecbd.Name.Local == "showAsIcon" {
			_fbdad, _agee := _b.ParseBool(_ecbd.Value)
			if _agee != nil {
				return _agee
			}
			_cbe.ShowAsIconAttr = &_fbdad
			continue
		}
		if _ecbd.Name.Local == "progId" {
			_fcfea, _bggcb := _ecbd.Value, error(nil)
			if _bggcb != nil {
				return _bggcb
			}
			_cbe.ProgIdAttr = &_fcfea
			continue
		}
		if _ecbd.Name.Local == "imgW" {
			_cbdag, _edcc := _b.ParseInt(_ecbd.Value, 10, 32)
			if _edcc != nil {
				return _edcc
			}
			_deee := int32(_cbdag)
			_cbe.ImgWAttr = &_deee
			continue
		}
		if _ecbd.Name.Local == "imgH" {
			_dbgb, _aebg := _b.ParseInt(_ecbd.Value, 10, 32)
			if _aebg != nil {
				return _aebg
			}
			_ddbe := int32(_dbgb)
			_cbe.ImgHAttr = &_ddbe
			continue
		}
	}
_aadc:
	for {
		_cggd, _eddf := d.Token()
		if _eddf != nil {
			return _eddf
		}
		switch _ecgc := _cggd.(type) {
		case _e.StartElement:
			switch _ecgc.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "embed"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "embed"}:
				_cbe.Choice = NewCT_OleObjectChoice()
				if _fedd := d.DecodeElement(&_cbe.Choice.Embed, &_ecgc); _fedd != nil {
					return _fedd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "link"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "link"}:
				_cbe.Choice = NewCT_OleObjectChoice()
				if _dbegd := d.DecodeElement(&_cbe.Choice.Link, &_ecgc); _dbegd != nil {
					return _dbegd
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "pic"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "pic"}:
				_cbe.Pic = NewCT_Picture()
				if _acbad := d.DecodeElement(_cbe.Pic, &_ecgc); _acbad != nil {
					return _acbad
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_OleObject\u0020\u0025v", _ecgc.Name)
				if _acdd := d.Skip(); _acdd != nil {
					return _acdd
				}
			}
		case _e.EndElement:
			break _aadc
		case _e.CharData:
		}
	}
	return nil
}
func (_ccgg *CT_SlideRelationshipListEntry) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _ccgg.IdAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_eaae *CT_TLAnimVariantFloatVal) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "val"}, Value: _c.Sprintf("\u0025v", _eaae.ValAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

type CT_SlideSorterViewProperties struct {

	// Show Formatting
	ShowFormattingAttr *bool

	// Base properties for Slide Sorter View
	CViewPr *CT_CommonViewProperties
	ExtLst  *CT_ExtensionList
}

func (_gcfb *CT_SlideMasterIdListEntry) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gcfb.IdAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "id"}, Value: _c.Sprintf("\u0025v", *_gcfb.IdAttr)})
	}
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "r:id"}, Value: _c.Sprintf("\u0025v", _gcfb.RIdAttr)})
	e.EncodeToken(start)
	if _gcfb.ExtLst != nil {
		_gdec := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_gcfb.ExtLst, _gdec)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_fecb ST_TransitionInOutDirectionType) ValidateWithPath(path string) error {
	switch _fecb {
	case 0, 1, 2:
	default:
		return _c.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fecb))
	}
	return nil
}
func (_ffdbd *ST_TransitionInOutDirectionType) UnmarshalXMLAttr(attr _e.Attr) error {
	switch attr.Value {
	case "":
		*_ffdbd = 0
	case "out":
		*_ffdbd = 1
	case "in":
		*_ffdbd = 2
	}
	return nil
}

type CT_SlideRelationshipListEntry struct{ IdAttr string }

func (_fba *CT_ConnectorNonVisual) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	e.EncodeToken(start)
	_ddcg := _e.StartElement{Name: _e.Name{Local: "p:cNvPr"}}
	e.EncodeElement(_fba.CNvPr, _ddcg)
	_egcc := _e.StartElement{Name: _e.Name{Local: "p:cNvCxnSpPr"}}
	e.EncodeElement(_fba.CNvCxnSpPr, _egcc)
	_eggd := _e.StartElement{Name: _e.Name{Local: "p:nvPr"}}
	e.EncodeElement(_fba.NvPr, _eggd)
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_ecedd ST_TLAnimateBehaviorCalcMode) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_cade := _e.Attr{}
	_cade.Name = name
	switch _ecedd {
	case ST_TLAnimateBehaviorCalcModeUnset:
		_cade.Value = ""
	case ST_TLAnimateBehaviorCalcModeDiscrete:
		_cade.Value = "discrete"
	case ST_TLAnimateBehaviorCalcModeLin:
		_cade.Value = "lin"
	case ST_TLAnimateBehaviorCalcModeFmla:
		_cade.Value = "fmla"
	}
	return _cade, nil
}
func NewCT_NotesMasterIdListEntry() *CT_NotesMasterIdListEntry {
	_befg := &CT_NotesMasterIdListEntry{}
	return _befg
}
func (_eacff ST_ViewType) MarshalXMLAttr(name _e.Name) (_e.Attr, error) {
	_ccadf := _e.Attr{}
	_ccadf.Name = name
	switch _eacff {
	case ST_ViewTypeUnset:
		_ccadf.Value = ""
	case ST_ViewTypeSldView:
		_ccadf.Value = "sldView"
	case ST_ViewTypeSldMasterView:
		_ccadf.Value = "sldMasterView"
	case ST_ViewTypeNotesView:
		_ccadf.Value = "notesView"
	case ST_ViewTypeHandoutView:
		_ccadf.Value = "handoutView"
	case ST_ViewTypeNotesMasterView:
		_ccadf.Value = "notesMasterView"
	case ST_ViewTypeOutlineView:
		_ccadf.Value = "outlineView"
	case ST_ViewTypeSldSorterView:
		_ccadf.Value = "sldSorterView"
	case ST_ViewTypeSldThumbnailView:
		_ccadf.Value = "sldThumbnailView"
	}
	return _ccadf, nil
}
func NewCT_TLMediaNodeAudio() *CT_TLMediaNodeAudio {
	_afgcf := &CT_TLMediaNodeAudio{}
	_afgcf.CMediaNode = NewCT_TLCommonMediaNodeData()
	return _afgcf
}

type CT_Guide struct {

	// Guide Orientation
	OrientAttr ST_Direction

	// Guide Position
	PosAttr *_cb.ST_Coordinate32
}

// ST_TLTime is a union type
type ST_TLTime struct {
	Uint32              *uint32
	ST_TLTimeIndefinite ST_TLTimeIndefinite
}

// ValidateWithPath validates the CT_TLByAnimateColorTransform and its children, prefixing error messages with path
func (_agbg *CT_TLByAnimateColorTransform) ValidateWithPath(path string) error {
	if _agbg.Rgb != nil {
		if _egdef := _agbg.Rgb.ValidateWithPath(path + "\u002fRgb"); _egdef != nil {
			return _egdef
		}
	}
	if _agbg.Hsl != nil {
		if _faged := _agbg.Hsl.ValidateWithPath(path + "\u002fHsl"); _faged != nil {
			return _faged
		}
	}
	return nil
}
func (_abfce *ST_TLChartSubelementType) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_fgaac, _gface := d.Token()
	if _gface != nil {
		return _gface
	}
	if _bfebc, _deacd := _fgaac.(_e.EndElement); _deacd && _bfebc.Name == start.Name {
		*_abfce = 1
		return nil
	}
	if _dbgfe, _fffaf := _fgaac.(_e.CharData); !_fffaf {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fgaac)
	} else {
		switch string(_dbgfe) {
		case "":
			*_abfce = 0
		case "gridLegend":
			*_abfce = 1
		case "series":
			*_abfce = 2
		case "category":
			*_abfce = 3
		case "ptInSeries":
			*_abfce = 4
		case "ptInCategory":
			*_abfce = 5
		}
	}
	_fgaac, _gface = d.Token()
	if _gface != nil {
		return _gface
	}
	if _gafeg, _fcdfb := _fgaac.(_e.EndElement); _fcdfb && _gafeg.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fgaac)
}
func (_fdcf ST_SplitterBarState) String() string {
	switch _fdcf {
	case 0:
		return ""
	case 1:
		return "minimized"
	case 2:
		return "restored"
	case 3:
		return "maximized"
	}
	return ""
}
func (_acbec *CT_TLAnimateBehavior) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _acbec.ByAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "by"}, Value: _c.Sprintf("\u0025v", *_acbec.ByAttr)})
	}
	if _acbec.FromAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "from"}, Value: _c.Sprintf("\u0025v", *_acbec.FromAttr)})
	}
	if _acbec.ToAttr != nil {
		start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "to"}, Value: _c.Sprintf("\u0025v", *_acbec.ToAttr)})
	}
	if _acbec.CalcmodeAttr != ST_TLAnimateBehaviorCalcModeUnset {
		_cfcg, _fbfebfe := _acbec.CalcmodeAttr.MarshalXMLAttr(_e.Name{Local: "calcmode"})
		if _fbfebfe != nil {
			return _fbfebfe
		}
		start.Attr = append(start.Attr, _cfcg)
	}
	if _acbec.ValueTypeAttr != ST_TLAnimateBehaviorValueTypeUnset {
		_cfad, _fegf := _acbec.ValueTypeAttr.MarshalXMLAttr(_e.Name{Local: "valueType"})
		if _fegf != nil {
			return _fegf
		}
		start.Attr = append(start.Attr, _cfad)
	}
	e.EncodeToken(start)
	_cgcc := _e.StartElement{Name: _e.Name{Local: "p:cBhvr"}}
	e.EncodeElement(_acbec.CBhvr, _cgcc)
	if _acbec.TavLst != nil {
		_adbdf := _e.StartElement{Name: _e.Name{Local: "p:tavLst"}}
		e.EncodeElement(_acbec.TavLst, _adbdf)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}
func (_agbab *CT_TLTextTargetElement) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
_bbba:
	for {
		_eecaa, _acdb := d.Token()
		if _acdb != nil {
			return _acdb
		}
		switch _dacag := _eecaa.(type) {
		case _e.StartElement:
			switch _dacag.Name {
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "charRg"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "charRg"}:
				_agbab.CharRg = NewCT_IndexRange()
				if _fdfbb := d.DecodeElement(_agbab.CharRg, &_dacag); _fdfbb != nil {
					return _fdfbb
				}
			case _e.Name{Space: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", Local: "pRg"}, _e.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg\u002fooxml\u002fpresentationml\u002fmain", Local: "pRg"}:
				_agbab.PRg = NewCT_IndexRange()
				if _bgceg := d.DecodeElement(_agbab.PRg, &_dacag); _bgceg != nil {
					return _bgceg
				}
			default:
				_ee.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_TLTextTargetElement\u0020\u0025v", _dacag.Name)
				if _gdcc := d.Skip(); _gdcc != nil {
					return _gdcc
				}
			}
		case _e.EndElement:
			break _bbba
		case _e.CharData:
		}
	}
	return nil
}
func ParseUnionST_Coordinate32(s string) (_cb.ST_Coordinate32, error) {
	return _cb.ParseUnionST_Coordinate32(s)
}

type CT_TagList struct {

	// Programmable Extensibility Tag
	Tag []*CT_StringTag
}

func (_cbddb *Notes) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:p"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:sh"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
//	start.Attr = append(start.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "p:notes"
	return _cbddb.CT_NotesSlide.MarshalXML(e, start)
}
func (_dbdab ST_Direction) Validate() error { return _dbdab.ValidateWithPath("") }
func (_gbac *CT_GraphicalObjectFrame) MarshalXML(e *_e.Encoder, start _e.StartElement) error {
	if _gbac.BwModeAttr != _cb.ST_BlackWhiteModeUnset {
		_dccc, _gffaf := _gbac.BwModeAttr.MarshalXMLAttr(_e.Name{Local: "a:bwMode"})
		if _gffaf != nil {
			return _gffaf
		}
		start.Attr = append(start.Attr, _dccc)
	}
	e.EncodeToken(start)
	_ffea := _e.StartElement{Name: _e.Name{Local: "p:nvGraphicFramePr"}}
	e.EncodeElement(_gbac.NvGraphicFramePr, _ffea)
	_cfea := _e.StartElement{Name: _e.Name{Local: "p:xfrm"}}
	e.EncodeElement(_gbac.Xfrm, _cfea)
	_dbae := _e.StartElement{Name: _e.Name{Local: "a:graphic"}}
	_dbae.Attr = append(_dbae.Attr, _e.Attr{Name: _e.Name{Local: "xmlns:a"}, Value: "http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fdrawingml\u002f2006\u002fmain"})
	e.EncodeElement(_gbac.Graphic, _dbae)
	if _gbac.ExtLst != nil {
		_fga := _e.StartElement{Name: _e.Name{Local: "p:extLst"}}
		e.EncodeElement(_gbac.ExtLst, _fga)
	}
	e.EncodeToken(_e.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_TLTriggerRuntimeNode and its children
func (_eeecd *CT_TLTriggerRuntimeNode) Validate() error {
	return _eeecd.ValidateWithPath("CT_TLTriggerRuntimeNode")
}

// ValidateWithPath validates the CT_TLMediaNodeAudio and its children, prefixing error messages with path
func (_gddd *CT_TLMediaNodeAudio) ValidateWithPath(path string) error {
	if _fgbdg := _gddd.CMediaNode.ValidateWithPath(path + "/CMediaNode"); _fgbdg != nil {
		return _fgbdg
	}
	return nil
}
func (_daafc *ST_PlaceholderSize) UnmarshalXML(d *_e.Decoder, start _e.StartElement) error {
	_ddbffe, _eaeff := d.Token()
	if _eaeff != nil {
		return _eaeff
	}
	if _abfcb, _cfggc := _ddbffe.(_e.EndElement); _cfggc && _abfcb.Name == start.Name {
		*_daafc = 1
		return nil
	}
	if _ecgb, _bgge := _ddbffe.(_e.CharData); !_bgge {
		return _c.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ddbffe)
	} else {
		switch string(_ecgb) {
		case "":
			*_daafc = 0
		case "full":
			*_daafc = 1
		case "half":
			*_daafc = 2
		case "quarter":
			*_daafc = 3
		}
	}
	_ddbffe, _eaeff = d.Token()
	if _eaeff != nil {
		return _eaeff
	}
	if _fgaaaa, _fabg := _ddbffe.(_e.EndElement); _fabg && _fgaaaa.Name == start.Name {
		return nil
	}
	return _c.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ddbffe)
}
func init() {
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SideDirectionTransition", NewCT_SideDirectionTransition)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CornerDirectionTransition", NewCT_CornerDirectionTransition)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_EightDirectionTransition", NewCT_EightDirectionTransition)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_OrientationTransition", NewCT_OrientationTransition)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_InOutTransition", NewCT_InOutTransition)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_OptionalBlackTransition", NewCT_OptionalBlackTransition)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SplitTransition", NewCT_SplitTransition)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_WheelTransition", NewCT_WheelTransition)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TransitionStartSoundAction", NewCT_TransitionStartSoundAction)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TransitionSoundAction", NewCT_TransitionSoundAction)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideTransition", NewCT_SlideTransition)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLIterateIntervalTime", NewCT_TLIterateIntervalTime)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLIterateIntervalPercentage", NewCT_TLIterateIntervalPercentage)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLIterateData", NewCT_TLIterateData)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLSubShapeId", NewCT_TLSubShapeId)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTextTargetElement", NewCT_TLTextTargetElement)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLOleChartTargetElement", NewCT_TLOleChartTargetElement)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLShapeTargetElement", NewCT_TLShapeTargetElement)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTimeTargetElement", NewCT_TLTimeTargetElement)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTriggerTimeNodeID", NewCT_TLTriggerTimeNodeID)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTriggerRuntimeNode", NewCT_TLTriggerRuntimeNode)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTimeCondition", NewCT_TLTimeCondition)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTimeConditionList", NewCT_TLTimeConditionList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TimeNodeList", NewCT_TimeNodeList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLCommonTimeNodeData", NewCT_TLCommonTimeNodeData)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTimeNodeParallel", NewCT_TLTimeNodeParallel)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTimeNodeSequence", NewCT_TLTimeNodeSequence)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTimeNodeExclusive", NewCT_TLTimeNodeExclusive)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLBehaviorAttributeNameList", NewCT_TLBehaviorAttributeNameList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLCommonBehaviorData", NewCT_TLCommonBehaviorData)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLAnimVariantBooleanVal", NewCT_TLAnimVariantBooleanVal)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLAnimVariantIntegerVal", NewCT_TLAnimVariantIntegerVal)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLAnimVariantFloatVal", NewCT_TLAnimVariantFloatVal)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLAnimVariantStringVal", NewCT_TLAnimVariantStringVal)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLAnimVariant", NewCT_TLAnimVariant)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTimeAnimateValue", NewCT_TLTimeAnimateValue)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTimeAnimateValueList", NewCT_TLTimeAnimateValueList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLAnimateBehavior", NewCT_TLAnimateBehavior)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLByRgbColorTransform", NewCT_TLByRgbColorTransform)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLByHslColorTransform", NewCT_TLByHslColorTransform)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLByAnimateColorTransform", NewCT_TLByAnimateColorTransform)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLAnimateColorBehavior", NewCT_TLAnimateColorBehavior)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLAnimateEffectBehavior", NewCT_TLAnimateEffectBehavior)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLPoint", NewCT_TLPoint)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLAnimateMotionBehavior", NewCT_TLAnimateMotionBehavior)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLAnimateRotationBehavior", NewCT_TLAnimateRotationBehavior)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLAnimateScaleBehavior", NewCT_TLAnimateScaleBehavior)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLCommandBehavior", NewCT_TLCommandBehavior)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLSetBehavior", NewCT_TLSetBehavior)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLCommonMediaNodeData", NewCT_TLCommonMediaNodeData)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLMediaNodeAudio", NewCT_TLMediaNodeAudio)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLMediaNodeVideo", NewCT_TLMediaNodeVideo)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTemplate", NewCT_TLTemplate)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLTemplateList", NewCT_TLTemplateList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLBuildParagraph", NewCT_TLBuildParagraph)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLBuildDiagram", NewCT_TLBuildDiagram)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLOleBuildChart", NewCT_TLOleBuildChart)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TLGraphicalObjectBuild", NewCT_TLGraphicalObjectBuild)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_BuildList", NewCT_BuildList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideTiming", NewCT_SlideTiming)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Empty", NewCT_Empty)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_IndexRange", NewCT_IndexRange)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideRelationshipListEntry", NewCT_SlideRelationshipListEntry)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideRelationshipList", NewCT_SlideRelationshipList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CustomShowId", NewCT_CustomShowId)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CustomerData", NewCT_CustomerData)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TagsData", NewCT_TagsData)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CustomerDataList", NewCT_CustomerDataList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Extension", NewCT_Extension)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_ExtensionList", NewCT_ExtensionList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_ExtensionListModify", NewCT_ExtensionListModify)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CommentAuthor", NewCT_CommentAuthor)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CommentAuthorList", NewCT_CommentAuthorList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Comment", NewCT_Comment)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CommentList", NewCT_CommentList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_OleObjectEmbed", NewCT_OleObjectEmbed)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_OleObjectLink", NewCT_OleObjectLink)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_OleObject", NewCT_OleObject)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Control", NewCT_Control)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_ControlList", NewCT_ControlList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideIdListEntry", NewCT_SlideIdListEntry)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideIdList", NewCT_SlideIdList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideMasterIdListEntry", NewCT_SlideMasterIdListEntry)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideMasterIdList", NewCT_SlideMasterIdList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_NotesMasterIdListEntry", NewCT_NotesMasterIdListEntry)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_NotesMasterIdList", NewCT_NotesMasterIdList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_HandoutMasterIdListEntry", NewCT_HandoutMasterIdListEntry)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_HandoutMasterIdList", NewCT_HandoutMasterIdList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_EmbeddedFontDataId", NewCT_EmbeddedFontDataId)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_EmbeddedFontListEntry", NewCT_EmbeddedFontListEntry)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_EmbeddedFontList", NewCT_EmbeddedFontList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SmartTags", NewCT_SmartTags)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CustomShow", NewCT_CustomShow)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CustomShowList", NewCT_CustomShowList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_PhotoAlbum", NewCT_PhotoAlbum)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideSize", NewCT_SlideSize)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Kinsoku", NewCT_Kinsoku)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_ModifyVerifier", NewCT_ModifyVerifier)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Presentation", NewCT_Presentation)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_HtmlPublishProperties", NewCT_HtmlPublishProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_WebProperties", NewCT_WebProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_PrintProperties", NewCT_PrintProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_ShowInfoBrowse", NewCT_ShowInfoBrowse)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_ShowInfoKiosk", NewCT_ShowInfoKiosk)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_ShowProperties", NewCT_ShowProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_PresentationProperties", NewCT_PresentationProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_HeaderFooter", NewCT_HeaderFooter)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Placeholder", NewCT_Placeholder)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_ApplicationNonVisualDrawingProps", NewCT_ApplicationNonVisualDrawingProps)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_ShapeNonVisual", NewCT_ShapeNonVisual)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Shape", NewCT_Shape)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_ConnectorNonVisual", NewCT_ConnectorNonVisual)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Connector", NewCT_Connector)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_PictureNonVisual", NewCT_PictureNonVisual)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Picture", NewCT_Picture)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_GraphicalObjectFrameNonVisual", NewCT_GraphicalObjectFrameNonVisual)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_GraphicalObjectFrame", NewCT_GraphicalObjectFrame)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_GroupShapeNonVisual", NewCT_GroupShapeNonVisual)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_GroupShape", NewCT_GroupShape)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Rel", NewCT_Rel)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_BackgroundProperties", NewCT_BackgroundProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Background", NewCT_Background)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CommonSlideData", NewCT_CommonSlideData)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Slide", NewCT_Slide)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideLayout", NewCT_SlideLayout)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideMasterTextStyles", NewCT_SlideMasterTextStyles)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideLayoutIdListEntry", NewCT_SlideLayoutIdListEntry)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideLayoutIdList", NewCT_SlideLayoutIdList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideMaster", NewCT_SlideMaster)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_HandoutMaster", NewCT_HandoutMaster)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_NotesMaster", NewCT_NotesMaster)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_NotesSlide", NewCT_NotesSlide)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideSyncProperties", NewCT_SlideSyncProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_StringTag", NewCT_StringTag)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_TagList", NewCT_TagList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_NormalViewPortion", NewCT_NormalViewPortion)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_NormalViewProperties", NewCT_NormalViewProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CommonViewProperties", NewCT_CommonViewProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_NotesTextViewProperties", NewCT_NotesTextViewProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_OutlineViewSlideEntry", NewCT_OutlineViewSlideEntry)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_OutlineViewSlideList", NewCT_OutlineViewSlideList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_OutlineViewProperties", NewCT_OutlineViewProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideSorterViewProperties", NewCT_SlideSorterViewProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_Guide", NewCT_Guide)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_GuideList", NewCT_GuideList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_CommonSlideViewProperties", NewCT_CommonSlideViewProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_SlideViewProperties", NewCT_SlideViewProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_NotesViewProperties", NewCT_NotesViewProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "CT_ViewProperties", NewCT_ViewProperties)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "cmAuthorLst", NewCmAuthorLst)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "cmLst", NewCmLst)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "oleObj", NewOleObj)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "presentation", NewPresentation)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "presentationPr", NewPresentationPr)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "sld", NewSld)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "sldLayout", NewSldLayout)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "sldMaster", NewSldMaster)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "handoutMaster", NewHandoutMaster)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "notesMaster", NewNotesMaster)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "notes", NewNotes)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "sldSyncPr", NewSldSyncPr)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "tagLst", NewTagLst)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "viewPr", NewViewPr)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "EG_SlideListChoice", NewEG_SlideListChoice)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "EG_ExtensionList", NewEG_ExtensionList)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "EG_ShowType", NewEG_ShowType)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "EG_TopLevelSlide", NewEG_TopLevelSlide)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "EG_ChildSlide", NewEG_ChildSlide)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "EG_Background", NewEG_Background)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "AG_TLBuild", NewAG_TLBuild)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "AG_Ole", NewAG_Ole)
	_ee.RegisterConstructor("http:\u002f\u002fschemas\u002eopenxmlformats\u002eorg\u002fpresentationml\u002f2006\u002fmain", "AG_ChildSlide", NewAG_ChildSlide)
}
