//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package relationships

import (
	_g "encoding/xml"
	_d "fmt"
	_gd "gitee.com/greatmusicians/unioffice"
)

func (_a *CT_Relationship) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	for _, _ga := range start.Attr {
		if _ga.Name.Local == "TargetMode" {
			_a.TargetModeAttr.UnmarshalXMLAttr(_ga)
			continue
		}
		if _ga.Name.Local == "Target" {
			_ed, _dd := _ga.Value, error(nil)
			if _dd != nil {
				return _dd
			}
			_a.TargetAttr = _ed
			continue
		}
		if _ga.Name.Local == "Type" {
			_bd, _df := _ga.Value, error(nil)
			if _df != nil {
				return _df
			}
			_a.TypeAttr = _bd
			continue
		}
		if _ga.Name.Local == "Id" {
			_ee, _bc := _ga.Value, error(nil)
			if _bc != nil {
				return _bc
			}
			_a.IdAttr = _ee
			continue
		}
	}
	for {
		_ca, _f := d.Token()
		if _f != nil {
			return _d.Errorf("parsing CT_Relationship:\u0020\u0025s", _f)
		}
		if _ef, _ad := _ca.(_g.CharData); _ad {
			_a.Content = string(_ef)
		}
		if _ge, _gf := _ca.(_g.EndElement); _gf && _ge.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ea *CT_Relationship) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	if _ea.TargetModeAttr != ST_TargetModeUnset {
		_c, _cg := _ea.TargetModeAttr.MarshalXMLAttr(_g.Name{Local: "TargetMode"})
		if _cg != nil {
			return _cg
		}
		start.Attr = append(start.Attr, _c)
	}
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "Target"}, Value: _d.Sprintf("\u0025v", _ea.TargetAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "Type"}, Value: _d.Sprintf("\u0025v", _ea.TypeAttr)})
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "Id"}, Value: _d.Sprintf("\u0025v", _ea.IdAttr)})
	e.EncodeElement(_ea.Content, start)
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_Relationship and its children
func (_ce *CT_Relationship) Validate() error {
	return _ce.ValidateWithPath("CT_Relationship")
}

const (
	ST_TargetModeUnset    ST_TargetMode = 0
	ST_TargetModeExternal ST_TargetMode = 1
	ST_TargetModeInternal ST_TargetMode = 2
)

// Validate validates the CT_Relationships and its children
func (_eb *CT_Relationships) Validate() error {
	return _eb.ValidateWithPath("CT_Relationships")
}
func (_bad ST_TargetMode) Validate() error   { return _bad.ValidateWithPath("") }
func NewCT_Relationships() *CT_Relationships { _gdf := &CT_Relationships{}; return _gdf }
func (_dca *ST_TargetMode) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_dca = 0
	case "External":
		*_dca = 1
	case "Internal":
		*_dca = 2
	}
	return nil
}
func (_cad *Relationship) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return _cad.CT_Relationship.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_Relationship and its children, prefixing error messages with path
func (_cc *CT_Relationship) ValidateWithPath(path string) error {
	if _ba := _cc.TargetModeAttr.ValidateWithPath(path + "\u002fTargetModeAttr"); _ba != nil {
		return _ba
	}
	return nil
}
func NewRelationship() *Relationship {
	_cf := &Relationship{}
	_cf.CT_Relationship = *NewCT_Relationship()
	return _cf
}

// Validate validates the Relationship and its children
func (_ff *Relationship) Validate() error {
	return _ff.ValidateWithPath("Relationship")
}
func (_ege *ST_TargetMode) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_feg, _gefb := d.Token()
	if _gefb != nil {
		return _gefb
	}
	if _adf, _aaa := _feg.(_g.EndElement); _aaa && _adf.Name == start.Name {
		*_ege = 1
		return nil
	}
	if _acd, _egc := _feg.(_g.CharData); !_egc {
		return _d.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _feg)
	} else {
		switch string(_acd) {
		case "":
			*_ege = 0
		case "External":
			*_ege = 1
		case "Internal":
			*_ege = 2
		}
	}
	_feg, _gefb = d.Token()
	if _gefb != nil {
		return _gefb
	}
	if _cab, _egg := _feg.(_g.EndElement); _egg && _cab.Name == start.Name {
		return nil
	}
	return _d.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _feg)
}

type ST_TargetMode byte

func NewRelationships() *Relationships {
	_faf := &Relationships{}
	_faf.CT_Relationships = *NewCT_Relationships()
	return _faf
}
func (_bgcf *Relationships) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002frelationships"})
//	start.Attr = append(start.Attr, _g.Attr{Name: _g.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "Relationships"
	return _bgcf.CT_Relationships.MarshalXML(e, start)
}
func (_db ST_TargetMode) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_db.String(), start)
}
func (_ac *CT_Relationships) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
_fe:
	for {
		_ega, _bcg := d.Token()
		if _bcg != nil {
			return _bcg
		}
		switch _bb := _ega.(type) {
		case _g.StartElement:
			switch _bb.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002frelationships", Local: "Relationship"}:
				_ab := NewRelationship()
				if _bg := d.DecodeElement(_ab, &_bb); _bg != nil {
					return _bg
				}
				_ac.Relationship = append(_ac.Relationship, _ab)
			default:
				_gd.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Relationships\u0020\u0025v", _bb.Name)
				if _fc := d.Skip(); _fc != nil {
					return _fc
				}
			}
		case _g.EndElement:
			break _fe
		case _g.CharData:
		}
	}
	return nil
}
func (_ae *CT_Relationships) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _ae.Relationship != nil {
		_eab := _g.StartElement{Name: _g.Name{Local: "Relationship"}}
		for _, _eg := range _ae.Relationship {
			e.EncodeElement(_eg, _eab)
		}
	}
	e.EncodeToken(_g.EndElement{Name: start.Name})
	return nil
}
func (_dcd ST_TargetMode) ValidateWithPath(path string) error {
	switch _dcd {
	case 0, 1, 2:
	default:
		return _d.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dcd))
	}
	return nil
}

// ValidateWithPath validates the CT_Relationships and its children, prefixing error messages with path
func (_fd *CT_Relationships) ValidateWithPath(path string) error {
	for _fg, _gdg := range _fd.Relationship {
		if _ccf := _gdg.ValidateWithPath(_d.Sprintf("\u0025s\u002fRelationship\u005b\u0025d\u005d", path, _fg)); _ccf != nil {
			return _ccf
		}
	}
	return nil
}

// ValidateWithPath validates the Relationships and its children, prefixing error messages with path
func (_dc *Relationships) ValidateWithPath(path string) error {
	if _fef := _dc.CT_Relationships.ValidateWithPath(path); _fef != nil {
		return _fef
	}
	return nil
}
func (_gef ST_TargetMode) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ddac := _g.Attr{}
	_ddac.Name = name
	switch _gef {
	case ST_TargetModeUnset:
		_ddac.Value = ""
	case ST_TargetModeExternal:
		_ddac.Value = "External"
	case ST_TargetModeInternal:
		_ddac.Value = "Internal"
	}
	return _ddac, nil
}

type Relationship struct{ CT_Relationship }

func (_fa *Relationship) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fa.CT_Relationship = *NewCT_Relationship()
	for _, _bgg := range start.Attr {
		if _bgg.Name.Local == "TargetMode" {
			_fa.TargetModeAttr.UnmarshalXMLAttr(_bgg)
			continue
		}
		if _bgg.Name.Local == "Target" {
			_cfe, _bbc := _bgg.Value, error(nil)
			if _bbc != nil {
				return _bbc
			}
			_fa.TargetAttr = _cfe
			continue
		}
		if _bgg.Name.Local == "Type" {
			_cbg, _aa := _bgg.Value, error(nil)
			if _aa != nil {
				return _aa
			}
			_fa.TypeAttr = _cbg
			continue
		}
		if _bgg.Name.Local == "Id" {
			_geb, _bce := _bgg.Value, error(nil)
			if _bce != nil {
				return _bce
			}
			_fa.IdAttr = _geb
			continue
		}
	}
	for {
		_fb, _bgc := d.Token()
		if _bgc != nil {
			return _d.Errorf("parsing\u0020Relationship:\u0020\u0025s", _bgc)
		}
		if _fee, _cd := _fb.(_g.EndElement); _cd && _fee.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Relationship struct {
	TargetModeAttr ST_TargetMode
	TargetAttr     string
	TypeAttr       string
	IdAttr         string
	Content        string
}
type Relationships struct{ CT_Relationships }
type CT_Relationships struct{ Relationship []*Relationship }

// ValidateWithPath validates the Relationship and its children, prefixing error messages with path
func (_bdg *Relationship) ValidateWithPath(path string) error {
	if _bf := _bdg.CT_Relationship.ValidateWithPath(path); _bf != nil {
		return _bf
	}
	return nil
}
func (_fafg ST_TargetMode) String() string {
	switch _fafg {
	case 0:
		return ""
	case 1:
		return "External"
	case 2:
		return "Internal"
	}
	return ""
}
func (_bbb *Relationships) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bbb.CT_Relationships = *NewCT_Relationships()
_fec:
	for {
		_eff, _bfd := d.Token()
		if _bfd != nil {
			return _bfd
		}
		switch _ced := _eff.(type) {
		case _g.StartElement:
			switch _ced.Name {
			case _g.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002frelationships", Local: "Relationship"}:
				_gdfc := NewRelationship()
				if _dda := d.DecodeElement(_gdfc, &_ced); _dda != nil {
					return _dda
				}
				_bbb.Relationship = append(_bbb.Relationship, _gdfc)
			default:
				_gd.Log("skipping unsupported element\u0020on\u0020Relationships \u0025v", _ced.Name)
				if _bda := d.Skip(); _bda != nil {
					return _bda
				}
			}
		case _g.EndElement:
			break _fec
		case _g.CharData:
		}
	}
	return nil
}

// Validate validates the Relationships and its children
func (_bfg *Relationships) Validate() error {
	return _bfg.ValidateWithPath("Relationships")
}
func NewCT_Relationship() *CT_Relationship { _e := &CT_Relationship{}; return _e }
func init() {
	_gd.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002frelationships", "CT_Relationships", NewCT_Relationships)
	_gd.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002frelationships", "CT_Relationship", NewCT_Relationship)
	_gd.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002frelationships", "Relationships", NewRelationships)
	_gd.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002frelationships", "Relationship", NewRelationship)
}
