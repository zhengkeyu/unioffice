//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package content_types

import (
	_b "encoding/xml"
	_f "fmt"
	_bf "gitee.com/greatmusicians/unioffice"
	_ea "regexp"
)

func (_g *CT_Default) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "Extension"}, Value: _f.Sprintf("\u0025v", _g.ExtensionAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "ContentType"}, Value: _f.Sprintf("\u0025v", _g.ContentTypeAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Default and its children, prefixing error messages with path
func (_cg *CT_Default) ValidateWithPath(path string) error {
	if !ST_ExtensionPatternRe.MatchString(_cg.ExtensionAttr) {
		return _f.Errorf("\u0025s\u002fm.ExtensionAttr\u0020must match\u0020\u0027%s\u0027\u0020\u0028have\u0020%v\u0029", path, ST_ExtensionPatternRe, _cg.ExtensionAttr)
	}
	if !ST_ContentTypePatternRe.MatchString(_cg.ContentTypeAttr) {
		return _f.Errorf("\u0025s/m\u002eContentTypeAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, ST_ContentTypePatternRe, _cg.ContentTypeAttr)
	}
	return nil
}
func NewDefault() *Default { _fef := &Default{}; _fef.CT_Default = *NewCT_Default(); return _fef }

// Validate validates the CT_Default and its children
func (_gb *CT_Default) Validate() error { return _gb.ValidateWithPath("CT_Default") }

// ValidateWithPath validates the Default and its children, prefixing error messages with path
func (_bfg *Default) ValidateWithPath(path string) error {
	if _de := _bfg.CT_Default.ValidateWithPath(path); _de != nil {
		return _de
	}
	return nil
}

// Validate validates the Override and its children
func (_eca *Override) Validate() error { return _eca.ValidateWithPath("Override") }

type CT_Types struct {
	Default  []*Default
	Override []*Override
}

func (_fbd *CT_Types) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _fbd.Default != nil {
		_ced := _b.StartElement{Name: _b.Name{Local: "Default"}}
		for _, _dd := range _fbd.Default {
			e.EncodeElement(_dd, _ced)
		}
	}
	if _fbd.Override != nil {
		_dgf := _b.StartElement{Name: _b.Name{Local: "Override"}}
		for _, _ffa := range _fbd.Override {
			e.EncodeElement(_ffa, _dgf)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewCT_Types() *CT_Types { _ef := &CT_Types{}; return _ef }

type CT_Override struct {
	ContentTypeAttr string
	PartNameAttr    string
}

func (_bag *Override) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _bag.CT_Override.MarshalXML(e, start)
}
func NewCT_Override() *CT_Override {
	_fa := &CT_Override{}
	_fa.ContentTypeAttr = "application\u002fxml"
	return _fa
}

// Validate validates the Default and its children
func (_gccf *Default) Validate() error { return _gccf.ValidateWithPath("Default") }
func (_bg *Types) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bg.CT_Types = *NewCT_Types()
_ffdd:
	for {
		_def, _be := d.Token()
		if _be != nil {
			return _be
		}
		switch _bbg := _def.(type) {
		case _b.StartElement:
			switch _bbg.Name {
			case _b.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002fcontent-types", Local: "Default"}:
				_gdf := NewDefault()
				if _cbg := d.DecodeElement(_gdf, &_bbg); _cbg != nil {
					return _cbg
				}
				_bg.Default = append(_bg.Default, _gdf)
			case _b.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002fcontent-types", Local: "Override"}:
				_cedb := NewOverride()
				if _abb := d.DecodeElement(_cedb, &_bbg); _abb != nil {
					return _abb
				}
				_bg.Override = append(_bg.Override, _cedb)
			default:
				_bf.Log("skipping\u0020unsupported\u0020element\u0020on Types \u0025v", _bbg.Name)
				if _fcb := d.Skip(); _fcb != nil {
					return _fcb
				}
			}
		case _b.EndElement:
			break _ffdd
		case _b.CharData:
		}
	}
	return nil
}
func (_ffg *Override) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ffg.CT_Override = *NewCT_Override()
	for _, _dga := range start.Attr {
		if _dga.Name.Local == "ContentType" {
			_ed, _fefg := _dga.Value, error(nil)
			if _fefg != nil {
				return _fefg
			}
			_ffg.ContentTypeAttr = _ed
			continue
		}
		if _dga.Name.Local == "PartName" {
			_eed, _ag := _dga.Value, error(nil)
			if _ag != nil {
				return _ag
			}
			_ffg.PartNameAttr = _eed
			continue
		}
	}
	for {
		_eb, _gdd := d.Token()
		if _gdd != nil {
			return _f.Errorf("parsing\u0020Override: \u0025s", _gdd)
		}
		if _fee, _bbd := _eb.(_b.EndElement); _bbd && _fee.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Types and its children, prefixing error messages with path
func (_fcd *CT_Types) ValidateWithPath(path string) error {
	for _cfg, _fdg := range _fcd.Default {
		if _cgf := _fdg.ValidateWithPath(_f.Sprintf("\u0025s\u002fDefault\u005b\u0025d\u005d", path, _cfg)); _cgf != nil {
			return _cgf
		}
	}
	for _ac, _fbf := range _fcd.Override {
		if _ffd := _fbf.ValidateWithPath(_f.Sprintf("\u0025s\u002fOverride\u005b\u0025d\u005d", path, _ac)); _ffd != nil {
			return _ffd
		}
	}
	return nil
}
func NewTypes() *Types { _cfe := &Types{}; _cfe.CT_Types = *NewCT_Types(); return _cfe }

type Types struct{ CT_Types }

const ST_ExtensionPattern = "\u0028\u005b\u0021\u0024\u0026\u0027\\\u0028\u005c\u0029\u005c\u002a\\\u002b\u002c:\u003d\u005d\u007c(\u0025\u005b0\u002d9a\u002dfA\u002dF\u005d\u005b0\u002d9a\u002dfA\u002dF\u005d\u0029\u007c\u005b:\u0040\u005d\u007c\u005ba\u002dzA\u002dZ0\u002d9\u005c\u002d_~\u005d\u0029\u002b"

func (_bb *CT_Types) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_ab:
	for {
		_ca, _fbg := d.Token()
		if _fbg != nil {
			return _fbg
		}
		switch _fg := _ca.(type) {
		case _b.StartElement:
			switch _fg.Name {
			case _b.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002fcontent-types", Local: "Default"}:
				_dbc := NewDefault()
				if _ege := d.DecodeElement(_dbc, &_fg); _ege != nil {
					return _ege
				}
				_bb.Default = append(_bb.Default, _dbc)
			case _b.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002fcontent-types", Local: "Override"}:
				_gd := NewOverride()
				if _gg := d.DecodeElement(_gd, &_fg); _gg != nil {
					return _gg
				}
				_bb.Override = append(_bb.Override, _gd)
			default:
				_bf.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Types\u0020\u0025v", _fg.Name)
				if _bfab := d.Skip(); _bfab != nil {
					return _bfab
				}
			}
		case _b.EndElement:
			break _ab
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Override and its children, prefixing error messages with path
func (_ff *CT_Override) ValidateWithPath(path string) error {
	if !ST_ContentTypePatternRe.MatchString(_ff.ContentTypeAttr) {
		return _f.Errorf("\u0025s/m\u002eContentTypeAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, ST_ContentTypePatternRe, _ff.ContentTypeAttr)
	}
	return nil
}

var ST_ContentTypePatternRe = _ea.MustCompile(ST_ContentTypePattern)

type Default struct{ CT_Default }

const ST_ContentTypePattern = "\u005e\\p{Latin\u007d\u002b\u002f\u002e\u002a\u0024"

func (_cgb *Types) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002fcontent-types"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "Types"
	return _cgb.CT_Types.MarshalXML(e, start)
}
func (_bfa *CT_Default) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bfa.ExtensionAttr = "xml"
	_bfa.ContentTypeAttr = "application\u002fxml"
	for _, _d := range start.Attr {
		if _d.Name.Local == "Extension" {
			_c, _fd := _d.Value, error(nil)
			if _fd != nil {
				return _fd
			}
			_bfa.ExtensionAttr = _c
			continue
		}
		if _d.Name.Local == "ContentType" {
			_dg, _ee := _d.Value, error(nil)
			if _ee != nil {
				return _ee
			}
			_bfa.ContentTypeAttr = _dg
			continue
		}
	}
	for {
		_df, _ba := d.Token()
		if _ba != nil {
			return _f.Errorf("parsing\u0020CT_Default:\u0020%s", _ba)
		}
		if _cc, _db := _df.(_b.EndElement); _db && _cc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gf *Default) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gf.CT_Default = *NewCT_Default()
	for _, _cgc := range start.Attr {
		if _cgc.Name.Local == "Extension" {
			_abd, _gfa := _cgc.Value, error(nil)
			if _gfa != nil {
				return _gfa
			}
			_gf.ExtensionAttr = _abd
			continue
		}
		if _cgc.Name.Local == "ContentType" {
			_dbe, _bbe := _cgc.Value, error(nil)
			if _bbe != nil {
				return _bbe
			}
			_gf.ContentTypeAttr = _dbe
			continue
		}
	}
	for {
		_fgc, _egc := d.Token()
		if _egc != nil {
			return _f.Errorf("parsing\u0020Default:\u0020\u0025s", _egc)
		}
		if _aa, _bbef := _fgc.(_b.EndElement); _bbef && _aa.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the Override and its children, prefixing error messages with path
func (_efc *Override) ValidateWithPath(path string) error {
	if _agf := _efc.CT_Override.ValidateWithPath(path); _agf != nil {
		return _agf
	}
	return nil
}
func (_bd *CT_Override) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bd.ContentTypeAttr = "application\u002fxml"
	for _, _cb := range start.Attr {
		if _cb.Name.Local == "ContentType" {
			_eg, _fc := _cb.Value, error(nil)
			if _fc != nil {
				return _fc
			}
			_bd.ContentTypeAttr = _eg
			continue
		}
		if _cb.Name.Local == "PartName" {
			_ce, _ec := _cb.Value, error(nil)
			if _ec != nil {
				return _ec
			}
			_bd.PartNameAttr = _ce
			continue
		}
	}
	for {
		_egf, _bdg := d.Token()
		if _bdg != nil {
			return _f.Errorf("parsing\u0020CT_Override:\u0020\u0025s", _bdg)
		}
		if _a, _feg := _egf.(_b.EndElement); _feg && _a.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_Override and its children
func (_da *CT_Override) Validate() error { return _da.ValidateWithPath("CT_Override") }
func NewOverride() *Override             { _cgd := &Override{}; _cgd.CT_Override = *NewCT_Override(); return _cgd }

// Validate validates the CT_Types and its children
func (_cf *CT_Types) Validate() error { return _cf.ValidateWithPath("CT_Types") }

var ST_ExtensionPatternRe = _ea.MustCompile(ST_ExtensionPattern)

// Validate validates the Types and its children
func (_beb *Types) Validate() error { return _beb.ValidateWithPath("Types") }
func (_dbg *Default) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _dbg.CT_Default.MarshalXML(e, start)
}
func NewCT_Default() *CT_Default {
	_fe := &CT_Default{}
	_fe.ExtensionAttr = "xml"
	_fe.ContentTypeAttr = "application\u002fxml"
	return _fe
}
func (_eeb *CT_Override) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "ContentType"}, Value: _f.Sprintf("\u0025v", _eeb.ContentTypeAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "PartName"}, Value: _f.Sprintf("\u0025v", _eeb.PartNameAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Types and its children, prefixing error messages with path
func (_bebd *Types) ValidateWithPath(path string) error {
	if _gce := _bebd.CT_Types.ValidateWithPath(path); _gce != nil {
		return _gce
	}
	return nil
}

type Override struct{ CT_Override }
type CT_Default struct {
	ExtensionAttr   string
	ContentTypeAttr string
}

func init() {
	_bf.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002fcontent-types", "CT_Types", NewCT_Types)
	_bf.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002fcontent-types", "CT_Default", NewCT_Default)
	_bf.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002fcontent-types", "CT_Override", NewCT_Override)
	_bf.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002fcontent-types", "Types", NewTypes)
	_bf.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002fcontent-types", "Default", NewDefault)
	_bf.RegisterConstructor("http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fpackage\u002f2006\u002fcontent-types", "Override", NewOverride)
}
