//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package elements

import (
	_ef "encoding/xml"
	_a "fmt"
	_g "gitee.com/greatmusicians/unioffice"
)

func (_fe *Any) UnmarshalXML(d *_ef.Decoder, start _ef.StartElement) error {
	_fe.SimpleLiteral = *NewSimpleLiteral()
	for {
		_d, _db := d.Token()
		if _db != nil {
			return _a.Errorf("parsing\u0020Any:\u0020\u0025s", _db)
		}
		if _ga, _b := _d.(_ef.EndElement); _b && _ga.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the SimpleLiteral and its children, prefixing error messages with path
func (_gaee *SimpleLiteral) ValidateWithPath(path string) error { return nil }
func NewElementsGroupChoice() *ElementsGroupChoice              { _ac := &ElementsGroupChoice{}; return _ac }

type SimpleLiteral struct{}

func NewElementContainer() *ElementContainer { _eg := &ElementContainer{}; return _eg }

// Validate validates the Any and its children
func (_dbe *Any) Validate() error { return _dbe.ValidateWithPath("Any") }

// ValidateWithPath validates the Any and its children, prefixing error messages with path
func (_fc *Any) ValidateWithPath(path string) error {
	if _ee := _fc.SimpleLiteral.ValidateWithPath(path); _ee != nil {
		return _ee
	}
	return nil
}

// ValidateWithPath validates the ElementContainer and its children, prefixing error messages with path
func (_fcc *ElementContainer) ValidateWithPath(path string) error {
	for _c, _df := range _fcc.Choice {
		if _cf := _df.ValidateWithPath(_a.Sprintf("\u0025s\u002fChoice\u005b\u0025d\u005d", path, _c)); _cf != nil {
			return _cf
		}
	}
	return nil
}
func (_fef *ElementsGroupChoice) MarshalXML(e *_ef.Encoder, start _ef.StartElement) error {
	if _fef.Any != nil {
		_cb := _ef.StartElement{Name: _ef.Name{Local: "dc:any"}}
		for _, _gaec := range _fef.Any {
			e.EncodeElement(_gaec, _cb)
		}
	}
	return nil
}
func (_af *ElementsGroup) MarshalXML(e *_ef.Encoder, start _ef.StartElement) error {
	if _af.Choice != nil {
		for _, _fab := range _af.Choice {
			_fab.MarshalXML(e, _ef.StartElement{})
		}
	}
	return nil
}
func (_f *Any) MarshalXML(e *_ef.Encoder, start _ef.StartElement) error {
	return _f.SimpleLiteral.MarshalXML(e, start)
}

// Validate validates the ElementContainer and its children
func (_fag *ElementContainer) Validate() error { return _fag.ValidateWithPath("ElementContainer") }
func (_ba *ElementContainer) UnmarshalXML(d *_ef.Decoder, start _ef.StartElement) error {
_ab:
	for {
		_eb, _gae := d.Token()
		if _gae != nil {
			return _gae
		}
		switch _de := _eb.(type) {
		case _ef.StartElement:
			switch _de.Name {
			case _ef.Name{Space: "http:\u002f\u002fpurl\u002eorg/dc\u002felements\u002f1\u002e1\u002f", Local: "any"}:
				_fa := NewElementsGroupChoice()
				if _gc := d.DecodeElement(&_fa.Any, &_de); _gc != nil {
					return _gc
				}
				_ba.Choice = append(_ba.Choice, _fa)
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020ElementContainer\u0020\u0025v", _de.Name)
				if _dg := d.Skip(); _dg != nil {
					return _dg
				}
			}
		case _ef.EndElement:
			break _ab
		case _ef.CharData:
		}
	}
	return nil
}

type ElementContainer struct{ Choice []*ElementsGroupChoice }

// Validate validates the ElementsGroup and its children
func (_aa *ElementsGroup) Validate() error { return _aa.ValidateWithPath("ElementsGroup") }

// ValidateWithPath validates the ElementsGroup and its children, prefixing error messages with path
func (_bbb *ElementsGroup) ValidateWithPath(path string) error {
	for _cfg, _da := range _bbb.Choice {
		if _cff := _da.ValidateWithPath(_a.Sprintf("\u0025s\u002fChoice\u005b\u0025d\u005d", path, _cfg)); _cff != nil {
			return _cff
		}
	}
	return nil
}
func (_cg *ElementsGroupChoice) UnmarshalXML(d *_ef.Decoder, start _ef.StartElement) error {
_bd:
	for {
		_gba, _aad := d.Token()
		if _aad != nil {
			return _aad
		}
		switch _cgd := _gba.(type) {
		case _ef.StartElement:
			switch _cgd.Name {
			case _ef.Name{Space: "http:\u002f\u002fpurl\u002eorg/dc\u002felements\u002f1\u002e1\u002f", Local: "any"}:
				_gbb := NewAny()
				if _dfd := d.DecodeElement(_gbb, &_cgd); _dfd != nil {
					return _dfd
				}
				_cg.Any = append(_cg.Any, _gbb)
			default:
				_g.Log("skipping\u0020unsupported\u0020element\u0020on\u0020ElementsGroupChoice\u0020\u0025v", _cgd.Name)
				if _bfe := d.Skip(); _bfe != nil {
					return _bfe
				}
			}
		case _ef.EndElement:
			break _bd
		case _ef.CharData:
		}
	}
	return nil
}
func (_gf *ElementContainer) MarshalXML(e *_ef.Encoder, start _ef.StartElement) error {
	start.Name.Local = "elementContainer"
	e.EncodeToken(start)
	if _gf.Choice != nil {
		for _, _bb := range _gf.Choice {
			_bb.MarshalXML(e, _ef.StartElement{})
		}
	}
	e.EncodeToken(_ef.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the ElementsGroupChoice and its children, prefixing error messages with path
func (_deg *ElementsGroupChoice) ValidateWithPath(path string) error {
	for _dfde, _fcg := range _deg.Any {
		if _dc := _fcg.ValidateWithPath(_a.Sprintf("\u0025s\u002fAny\u005b\u0025d\u005d", path, _dfde)); _dc != nil {
			return _dc
		}
	}
	return nil
}

type ElementsGroupChoice struct{ Any []*Any }
type ElementsGroup struct{ Choice []*ElementsGroupChoice }

func NewSimpleLiteral() *SimpleLiteral { _gcc := &SimpleLiteral{}; return _gcc }
func NewElementsGroup() *ElementsGroup { _ag := &ElementsGroup{}; return _ag }
func NewAny() *Any                     { _ec := &Any{}; _ec.SimpleLiteral = *NewSimpleLiteral(); return _ec }
func (_ecd *SimpleLiteral) MarshalXML(e *_ef.Encoder, start _ef.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_ef.EndElement{Name: start.Name})
	return nil
}
func (_ea *SimpleLiteral) UnmarshalXML(d *_ef.Decoder, start _ef.StartElement) error {
	for {
		_fea, _fcgf := d.Token()
		if _fcgf != nil {
			return _a.Errorf("parsing\u0020SimpleLiteral:\u0020\u0025s", _fcgf)
		}
		if _dca, _eca := _fea.(_ef.EndElement); _eca && _dca.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ca *ElementsGroup) UnmarshalXML(d *_ef.Decoder, start _ef.StartElement) error {
_gb:
	for {
		_ad, _feb := d.Token()
		if _feb != nil {
			return _feb
		}
		switch _be := _ad.(type) {
		case _ef.StartElement:
			switch _be.Name {
			case _ef.Name{Space: "http:\u002f\u002fpurl\u002eorg/dc\u002felements\u002f1\u002e1\u002f", Local: "any"}:
				_bf := NewElementsGroupChoice()
				if _bef := d.DecodeElement(&_bf.Any, &_be); _bef != nil {
					return _bef
				}
				_ca.Choice = append(_ca.Choice, _bf)
			default:
				_g.Log("skipping unsupported element\u0020on\u0020ElementsGroup \u0025v", _be.Name)
				if _dde := d.Skip(); _dde != nil {
					return _dde
				}
			}
		case _ef.EndElement:
			break _gb
		case _ef.CharData:
		}
	}
	return nil
}

type Any struct{ SimpleLiteral }

// Validate validates the SimpleLiteral and its children
func (_def *SimpleLiteral) Validate() error { return _def.ValidateWithPath("SimpleLiteral") }

// Validate validates the ElementsGroupChoice and its children
func (_gfe *ElementsGroupChoice) Validate() error {
	return _gfe.ValidateWithPath("ElementsGroupChoice")
}
func init() {
	_g.RegisterConstructor("http:\u002f\u002fpurl\u002eorg/dc\u002felements\u002f1\u002e1\u002f", "SimpleLiteral", NewSimpleLiteral)
	_g.RegisterConstructor("http:\u002f\u002fpurl\u002eorg/dc\u002felements\u002f1\u002e1\u002f", "elementContainer", NewElementContainer)
	_g.RegisterConstructor("http:\u002f\u002fpurl\u002eorg/dc\u002felements\u002f1\u002e1\u002f", "any", NewAny)
	_g.RegisterConstructor("http:\u002f\u002fpurl\u002eorg/dc\u002felements\u002f1\u002e1\u002f", "elementsGroup", NewElementsGroup)
}
