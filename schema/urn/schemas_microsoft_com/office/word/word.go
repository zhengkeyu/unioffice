//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package word

import (
	_b "encoding/xml"
	_f "fmt"
	_bd "gitee.com/greatmusicians/unioffice"
	_e "strconv"
)

func (_ggfga ST_VerticalAnchor) String() string {
	switch _ggfga {
	case 0:
		return ""
	case 1:
		return "margin"
	case 2:
		return "page"
	case 3:
		return "text"
	case 4:
		return "line"
	}
	return ""
}

// ValidateWithPath validates the Borderleft and its children, prefixing error messages with path
func (_fe *Borderleft) ValidateWithPath(path string) error {
	if _ebb := _fe.CT_Border.ValidateWithPath(path); _ebb != nil {
		return _ebb
	}
	return nil
}
func (_ecg *Borderbottom) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:word"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "borderbottom"
	return _ecg.CT_Border.MarshalXML(e, start)
}
func NewAnchorlock() *Anchorlock {
	_bc := &Anchorlock{}
	_bc.CT_AnchorLock = *NewCT_AnchorLock()
	return _bc
}
func (_edg ST_BorderType) Validate() error { return _edg.ValidateWithPath("") }
func (_efe ST_BorderShadow) ValidateWithPath(path string) error {
	switch _efe {
	case 0, 1, 2, 3, 4:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_efe))
	}
	return nil
}
func NewBorderright() *Borderright {
	_bdc := &Borderright{}
	_bdc.CT_Border = *NewCT_Border()
	return _bdc
}
func NewCT_Wrap() *CT_Wrap { _ggba := &CT_Wrap{}; return _ggba }
func (_ad *Borderleft) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ad.CT_Border = *NewCT_Border()
	for _, _ge := range start.Attr {
		if _ge.Name.Local == "type" {
			_ad.TypeAttr.UnmarshalXMLAttr(_ge)
			continue
		}
		if _ge.Name.Local == "width" {
			_ag, _deb := _e.ParseUint(_ge.Value, 10, 32)
			if _deb != nil {
				return _deb
			}
			_eg := uint32(_ag)
			_ad.WidthAttr = &_eg
			continue
		}
		if _ge.Name.Local == "shadow" {
			_ad.ShadowAttr.UnmarshalXMLAttr(_ge)
			continue
		}
	}
	for {
		_ff, _ce := d.Token()
		if _ce != nil {
			return _f.Errorf("parsing\u0020Borderleft:\u0020%s", _ce)
		}
		if _db, _ggb := _ff.(_b.EndElement); _ggb && _db.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the Borderbottom and its children, prefixing error messages with path
func (_gf *Borderbottom) ValidateWithPath(path string) error {
	if _cb := _gf.CT_Border.ValidateWithPath(path); _cb != nil {
		return _cb
	}
	return nil
}
func (_febc ST_WrapSide) String() string {
	switch _febc {
	case 0:
		return ""
	case 1:
		return "both"
	case 2:
		return "left"
	case 3:
		return "right"
	case 4:
		return "largest"
	}
	return ""
}

// ValidateWithPath validates the Wrap and its children, prefixing error messages with path
func (_fgd *Wrap) ValidateWithPath(path string) error {
	if _aga := _fgd.CT_Wrap.ValidateWithPath(path); _aga != nil {
		return _aga
	}
	return nil
}
func NewBorderbottom() *Borderbottom {
	_cd := &Borderbottom{}
	_cd.CT_Border = *NewCT_Border()
	return _cd
}
func (_df *CT_AnchorLock) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for {
		_cbf, _gec := d.Token()
		if _gec != nil {
			return _f.Errorf("parsing\u0020CT_AnchorLock:\u0020\u0025s", _gec)
		}
		if _bbe, _aa := _cbf.(_b.EndElement); _aa && _bbe.Name == start.Name {
			break
		}
	}
	return nil
}

type Bordertop struct{ CT_Border }
type ST_WrapSide byte

// Validate validates the CT_Wrap and its children
func (_gda *CT_Wrap) Validate() error { return _gda.ValidateWithPath("CT_Wrap") }
func (_bae ST_WrapType) String() string {
	switch _bae {
	case 0:
		return ""
	case 1:
		return "topAndBottom"
	case 2:
		return "square"
	case 3:
		return "none"
	case 4:
		return "tight"
	case 5:
		return "through"
	}
	return ""
}
func NewBorderleft() *Borderleft { _bf := &Borderleft{}; _bf.CT_Border = *NewCT_Border(); return _bf }

// Validate validates the Wrap and its children
func (_egc *Wrap) Validate() error { return _egc.ValidateWithPath("Wrap") }

type Borderright struct{ CT_Border }
type CT_AnchorLock struct{}

func (_eef *ST_HorizontalAnchor) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_eef = 0
	case "margin":
		*_eef = 1
	case "page":
		*_eef = 2
	case "text":
		*_eef = 3
	case "char":
		*_eef = 4
	}
	return nil
}
func (_gge ST_WrapSide) Validate() error { return _gge.ValidateWithPath("") }

const (
	ST_WrapSideUnset   ST_WrapSide = 0
	ST_WrapSideBoth    ST_WrapSide = 1
	ST_WrapSideLeft    ST_WrapSide = 2
	ST_WrapSideRight   ST_WrapSide = 3
	ST_WrapSideLargest ST_WrapSide = 4
)

func (_cbb *Borderright) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cbb.CT_Border = *NewCT_Border()
	for _, _ae := range start.Attr {
		if _ae.Name.Local == "type" {
			_cbb.TypeAttr.UnmarshalXMLAttr(_ae)
			continue
		}
		if _ae.Name.Local == "width" {
			_ee, _ab := _e.ParseUint(_ae.Value, 10, 32)
			if _ab != nil {
				return _ab
			}
			_gff := uint32(_ee)
			_cbb.WidthAttr = &_gff
			continue
		}
		if _ae.Name.Local == "shadow" {
			_cbb.ShadowAttr.UnmarshalXMLAttr(_ae)
			continue
		}
	}
	for {
		_dd, _fd := d.Token()
		if _fd != nil {
			return _f.Errorf("parsing\u0020Borderright:\u0020\u0025s", _fd)
		}
		if _bda, _egf := _dd.(_b.EndElement); _egf && _bda.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gdg ST_HorizontalAnchor) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_gdg.String(), start)
}
func (_fc *Borderbottom) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fc.CT_Border = *NewCT_Border()
	for _, _bb := range start.Attr {
		if _bb.Name.Local == "type" {
			_fc.TypeAttr.UnmarshalXMLAttr(_bb)
			continue
		}
		if _bb.Name.Local == "width" {
			_cdd, _be := _e.ParseUint(_bb.Value, 10, 32)
			if _be != nil {
				return _be
			}
			_de := uint32(_cdd)
			_fc.WidthAttr = &_de
			continue
		}
		if _bb.Name.Local == "shadow" {
			_fc.ShadowAttr.UnmarshalXMLAttr(_bb)
			continue
		}
	}
	for {
		_af, _cc := d.Token()
		if _cc != nil {
			return _f.Errorf("parsing\u0020Borderbottom:\u0020\u0025s", _cc)
		}
		if _afb, _ed := _af.(_b.EndElement); _ed && _afb.Name == start.Name {
			break
		}
	}
	return nil
}

type ST_BorderShadow byte

func (_fbc ST_BorderType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_ebbf := _b.Attr{}
	_ebbf.Name = name
	switch _fbc {
	case ST_BorderTypeUnset:
		_ebbf.Value = ""
	case ST_BorderTypeNone:
		_ebbf.Value = "none"
	case ST_BorderTypeSingle:
		_ebbf.Value = "single"
	case ST_BorderTypeThick:
		_ebbf.Value = "thick"
	case ST_BorderTypeDouble:
		_ebbf.Value = "double"
	case ST_BorderTypeHairline:
		_ebbf.Value = "hairline"
	case ST_BorderTypeDot:
		_ebbf.Value = "dot"
	case ST_BorderTypeDash:
		_ebbf.Value = "dash"
	case ST_BorderTypeDotDash:
		_ebbf.Value = "dotDash"
	case ST_BorderTypeDashDotDot:
		_ebbf.Value = "dashDotDot"
	case ST_BorderTypeTriple:
		_ebbf.Value = "triple"
	case ST_BorderTypeThinThickSmall:
		_ebbf.Value = "thinThickSmall"
	case ST_BorderTypeThickThinSmall:
		_ebbf.Value = "thickThinSmall"
	case ST_BorderTypeThickBetweenThinSmall:
		_ebbf.Value = "thickBetweenThinSmall"
	case ST_BorderTypeThinThick:
		_ebbf.Value = "thinThick"
	case ST_BorderTypeThickThin:
		_ebbf.Value = "thickThin"
	case ST_BorderTypeThickBetweenThin:
		_ebbf.Value = "thickBetweenThin"
	case ST_BorderTypeThinThickLarge:
		_ebbf.Value = "thinThickLarge"
	case ST_BorderTypeThickThinLarge:
		_ebbf.Value = "thickThinLarge"
	case ST_BorderTypeThickBetweenThinLarge:
		_ebbf.Value = "thickBetweenThinLarge"
	case ST_BorderTypeWave:
		_ebbf.Value = "wave"
	case ST_BorderTypeDoubleWave:
		_ebbf.Value = "doubleWave"
	case ST_BorderTypeDashedSmall:
		_ebbf.Value = "dashedSmall"
	case ST_BorderTypeDashDotStroked:
		_ebbf.Value = "dashDotStroked"
	case ST_BorderTypeThreeDEmboss:
		_ebbf.Value = "threeDEmboss"
	case ST_BorderTypeThreeDEngrave:
		_ebbf.Value = "threeDEngrave"
	case ST_BorderTypeHTMLOutset:
		_ebbf.Value = "HTMLOutset"
	case ST_BorderTypeHTMLInset:
		_ebbf.Value = "HTMLInset"
	}
	return _ebbf, nil
}
func (_agc ST_WrapSide) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_feb := _b.Attr{}
	_feb.Name = name
	switch _agc {
	case ST_WrapSideUnset:
		_feb.Value = ""
	case ST_WrapSideBoth:
		_feb.Value = "both"
	case ST_WrapSideLeft:
		_feb.Value = "left"
	case ST_WrapSideRight:
		_feb.Value = "right"
	case ST_WrapSideLargest:
		_feb.Value = "largest"
	}
	return _feb, nil
}
func (_aeb *ST_BorderShadow) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_aeb = 0
	case "t":
		*_aeb = 1
	case "true":
		*_aeb = 2
	case "f":
		*_aeb = 3
	case "false":
		*_aeb = 4
	}
	return nil
}

type ST_HorizontalAnchor byte

func (_fbg ST_VerticalAnchor) Validate() error { return _fbg.ValidateWithPath("") }

// Validate validates the CT_AnchorLock and its children
func (_edc *CT_AnchorLock) Validate() error { return _edc.ValidateWithPath("CT_AnchorLock") }
func (_cef *ST_BorderType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_cef = 0
	case "none":
		*_cef = 1
	case "single":
		*_cef = 2
	case "thick":
		*_cef = 3
	case "double":
		*_cef = 4
	case "hairline":
		*_cef = 5
	case "dot":
		*_cef = 6
	case "dash":
		*_cef = 7
	case "dotDash":
		*_cef = 8
	case "dashDotDot":
		*_cef = 9
	case "triple":
		*_cef = 10
	case "thinThickSmall":
		*_cef = 11
	case "thickThinSmall":
		*_cef = 12
	case "thickBetweenThinSmall":
		*_cef = 13
	case "thinThick":
		*_cef = 14
	case "thickThin":
		*_cef = 15
	case "thickBetweenThin":
		*_cef = 16
	case "thinThickLarge":
		*_cef = 17
	case "thickThinLarge":
		*_cef = 18
	case "thickBetweenThinLarge":
		*_cef = 19
	case "wave":
		*_cef = 20
	case "doubleWave":
		*_cef = 21
	case "dashedSmall":
		*_cef = 22
	case "dashDotStroked":
		*_cef = 23
	case "threeDEmboss":
		*_cef = 24
	case "threeDEngrave":
		*_cef = 25
	case "HTMLOutset":
		*_cef = 26
	case "HTMLInset":
		*_cef = 27
	}
	return nil
}

const (
	ST_BorderTypeUnset                 ST_BorderType = 0
	ST_BorderTypeNone                  ST_BorderType = 1
	ST_BorderTypeSingle                ST_BorderType = 2
	ST_BorderTypeThick                 ST_BorderType = 3
	ST_BorderTypeDouble                ST_BorderType = 4
	ST_BorderTypeHairline              ST_BorderType = 5
	ST_BorderTypeDot                   ST_BorderType = 6
	ST_BorderTypeDash                  ST_BorderType = 7
	ST_BorderTypeDotDash               ST_BorderType = 8
	ST_BorderTypeDashDotDot            ST_BorderType = 9
	ST_BorderTypeTriple                ST_BorderType = 10
	ST_BorderTypeThinThickSmall        ST_BorderType = 11
	ST_BorderTypeThickThinSmall        ST_BorderType = 12
	ST_BorderTypeThickBetweenThinSmall ST_BorderType = 13
	ST_BorderTypeThinThick             ST_BorderType = 14
	ST_BorderTypeThickThin             ST_BorderType = 15
	ST_BorderTypeThickBetweenThin      ST_BorderType = 16
	ST_BorderTypeThinThickLarge        ST_BorderType = 17
	ST_BorderTypeThickThinLarge        ST_BorderType = 18
	ST_BorderTypeThickBetweenThinLarge ST_BorderType = 19
	ST_BorderTypeWave                  ST_BorderType = 20
	ST_BorderTypeDoubleWave            ST_BorderType = 21
	ST_BorderTypeDashedSmall           ST_BorderType = 22
	ST_BorderTypeDashDotStroked        ST_BorderType = 23
	ST_BorderTypeThreeDEmboss          ST_BorderType = 24
	ST_BorderTypeThreeDEngrave         ST_BorderType = 25
	ST_BorderTypeHTMLOutset            ST_BorderType = 26
	ST_BorderTypeHTMLInset             ST_BorderType = 27
)

// ValidateWithPath validates the CT_Border and its children, prefixing error messages with path
func (_dcc *CT_Border) ValidateWithPath(path string) error {
	if _bg := _dcc.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _bg != nil {
		return _bg
	}
	if _dgf := _dcc.ShadowAttr.ValidateWithPath(path + "/ShadowAttr"); _dgf != nil {
		return _dgf
	}
	return nil
}

const (
	ST_HorizontalAnchorUnset  ST_HorizontalAnchor = 0
	ST_HorizontalAnchorMargin ST_HorizontalAnchor = 1
	ST_HorizontalAnchorPage   ST_HorizontalAnchor = 2
	ST_HorizontalAnchorText   ST_HorizontalAnchor = 3
	ST_HorizontalAnchorChar   ST_HorizontalAnchor = 4
)

func (_age *ST_BorderShadow) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fcgg, _dcg := d.Token()
	if _dcg != nil {
		return _dcg
	}
	if _dffg, _eac := _fcgg.(_b.EndElement); _eac && _dffg.Name == start.Name {
		*_age = 1
		return nil
	}
	if _gb, _bfec := _fcgg.(_b.CharData); !_bfec {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fcgg)
	} else {
		switch string(_gb) {
		case "":
			*_age = 0
		case "t":
			*_age = 1
		case "true":
			*_age = 2
		case "f":
			*_age = 3
		case "false":
			*_age = 4
		}
	}
	_fcgg, _dcg = d.Token()
	if _dcg != nil {
		return _dcg
	}
	if _gbc, _efc := _fcgg.(_b.EndElement); _efc && _gbc.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fcgg)
}
func (_feec *ST_WrapType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gba, _dece := d.Token()
	if _dece != nil {
		return _dece
	}
	if _bdg, _ggfge := _gba.(_b.EndElement); _ggfge && _bdg.Name == start.Name {
		*_feec = 1
		return nil
	}
	if _feeb, _geeg := _gba.(_b.CharData); !_geeg {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gba)
	} else {
		switch string(_feeb) {
		case "":
			*_feec = 0
		case "topAndBottom":
			*_feec = 1
		case "square":
			*_feec = 2
		case "none":
			*_feec = 3
		case "tight":
			*_feec = 4
		case "through":
			*_feec = 5
		}
	}
	_gba, _dece = d.Token()
	if _dece != nil {
		return _dece
	}
	if _afd, _bed := _gba.(_b.EndElement); _bed && _afd.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gba)
}

// Validate validates the Borderright and its children
func (_eafg *Borderright) Validate() error { return _eafg.ValidateWithPath("Borderright") }
func (_cba *ST_WrapSide) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_cba = 0
	case "both":
		*_cba = 1
	case "left":
		*_cba = 2
	case "right":
		*_cba = 3
	case "largest":
		*_cba = 4
	}
	return nil
}
func (_cbgg ST_BorderType) ValidateWithPath(path string) error {
	switch _cbgg {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cbgg))
	}
	return nil
}

// Validate validates the Borderbottom and its children
func (_cg *Borderbottom) Validate() error { return _cg.ValidateWithPath("Borderbottom") }
func (_ffc *CT_Border) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ffc.TypeAttr != ST_BorderTypeUnset {
		_ddc, _cf := _ffc.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _cf != nil {
			return _cf
		}
		start.Attr = append(start.Attr, _ddc)
	}
	if _ffc.WidthAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "width"}, Value: _f.Sprintf("\u0025v", *_ffc.WidthAttr)})
	}
	if _ffc.ShadowAttr != ST_BorderShadowUnset {
		_gd, _ege := _ffc.ShadowAttr.MarshalXMLAttr(_b.Name{Local: "shadow"})
		if _ege != nil {
			return _ege
		}
		start.Attr = append(start.Attr, _gd)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_bfd ST_BorderShadow) Validate() error { return _bfd.ValidateWithPath("") }

type Borderbottom struct{ CT_Border }

func (_eae ST_WrapType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_eae.String(), start)
}
func (_ea *Anchorlock) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ea.CT_AnchorLock = *NewCT_AnchorLock()
	for {
		_g, _a := d.Token()
		if _a != nil {
			return _f.Errorf("parsing\u0020Anchorlock:\u0020%s", _a)
		}
		if _ec, _ga := _g.(_b.EndElement); _ga && _ec.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ggfg ST_BorderShadow) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_ggfg.String(), start)
}

type CT_Border struct {
	TypeAttr   ST_BorderType
	WidthAttr  *uint32
	ShadowAttr ST_BorderShadow
}

func (_da *ST_BorderType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ecf, _fae := d.Token()
	if _fae != nil {
		return _fae
	}
	if _cgd, _cge := _ecf.(_b.EndElement); _cge && _cgd.Name == start.Name {
		*_da = 1
		return nil
	}
	if _fdg, _decf := _ecf.(_b.CharData); !_decf {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ecf)
	} else {
		switch string(_fdg) {
		case "":
			*_da = 0
		case "none":
			*_da = 1
		case "single":
			*_da = 2
		case "thick":
			*_da = 3
		case "double":
			*_da = 4
		case "hairline":
			*_da = 5
		case "dot":
			*_da = 6
		case "dash":
			*_da = 7
		case "dotDash":
			*_da = 8
		case "dashDotDot":
			*_da = 9
		case "triple":
			*_da = 10
		case "thinThickSmall":
			*_da = 11
		case "thickThinSmall":
			*_da = 12
		case "thickBetweenThinSmall":
			*_da = 13
		case "thinThick":
			*_da = 14
		case "thickThin":
			*_da = 15
		case "thickBetweenThin":
			*_da = 16
		case "thinThickLarge":
			*_da = 17
		case "thickThinLarge":
			*_da = 18
		case "thickBetweenThinLarge":
			*_da = 19
		case "wave":
			*_da = 20
		case "doubleWave":
			*_da = 21
		case "dashedSmall":
			*_da = 22
		case "dashDotStroked":
			*_da = 23
		case "threeDEmboss":
			*_da = 24
		case "threeDEngrave":
			*_da = 25
		case "HTMLOutset":
			*_da = 26
		case "HTMLInset":
			*_da = 27
		}
	}
	_ecf, _fae = d.Token()
	if _fae != nil {
		return _fae
	}
	if _baa, _dff := _ecf.(_b.EndElement); _dff && _baa.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ecf)
}
func NewCT_Border() *CT_Border { _dca := &CT_Border{}; return _dca }
func (_dce *CT_AnchorLock) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_aad *CT_Wrap) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _abe := range start.Attr {
		if _abe.Name.Local == "type" {
			_aad.TypeAttr.UnmarshalXMLAttr(_abe)
			continue
		}
		if _abe.Name.Local == "side" {
			_aad.SideAttr.UnmarshalXMLAttr(_abe)
			continue
		}
		if _abe.Name.Local == "anchorx" {
			_aad.AnchorxAttr.UnmarshalXMLAttr(_abe)
			continue
		}
		if _abe.Name.Local == "anchory" {
			_aad.AnchoryAttr.UnmarshalXMLAttr(_abe)
			continue
		}
	}
	for {
		_ace, _gdc := d.Token()
		if _gdc != nil {
			return _f.Errorf("parsing\u0020CT_Wrap:\u0020\u0025s", _gdc)
		}
		if _ggf, _gdb := _ace.(_b.EndElement); _gdb && _ggf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cff ST_WrapSide) ValidateWithPath(path string) error {
	switch _cff {
	case 0, 1, 2, 3, 4:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cff))
	}
	return nil
}
func (_eeb *ST_WrapSide) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gcd, _dad := d.Token()
	if _dad != nil {
		return _dad
	}
	if _aced, _aff := _gcd.(_b.EndElement); _aff && _aced.Name == start.Name {
		*_eeb = 1
		return nil
	}
	if _fdc, _dcca := _gcd.(_b.CharData); !_dcca {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gcd)
	} else {
		switch string(_fdc) {
		case "":
			*_eeb = 0
		case "both":
			*_eeb = 1
		case "left":
			*_eeb = 2
		case "right":
			*_eeb = 3
		case "largest":
			*_eeb = 4
		}
	}
	_gcd, _dad = d.Token()
	if _dad != nil {
		return _dad
	}
	if _bdgc, _gce := _gcd.(_b.EndElement); _gce && _bdgc.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gcd)
}
func (_c *Anchorlock) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:word"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "anchorlock"
	return _c.CT_AnchorLock.MarshalXML(e, start)
}
func (_bcb ST_BorderType) String() string {
	switch _bcb {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "single"
	case 3:
		return "thick"
	case 4:
		return "double"
	case 5:
		return "hairline"
	case 6:
		return "dot"
	case 7:
		return "dash"
	case 8:
		return "dotDash"
	case 9:
		return "dashDotDot"
	case 10:
		return "triple"
	case 11:
		return "thinThickSmall"
	case 12:
		return "thickThinSmall"
	case 13:
		return "thickBetweenThinSmall"
	case 14:
		return "thinThick"
	case 15:
		return "thickThin"
	case 16:
		return "thickBetweenThin"
	case 17:
		return "thinThickLarge"
	case 18:
		return "thickThinLarge"
	case 19:
		return "thickBetweenThinLarge"
	case 20:
		return "wave"
	case 21:
		return "doubleWave"
	case 22:
		return "dashedSmall"
	case 23:
		return "dashDotStroked"
	case 24:
		return "threeDEmboss"
	case 25:
		return "threeDEngrave"
	case 26:
		return "HTMLOutset"
	case 27:
		return "HTMLInset"
	}
	return ""
}

type ST_WrapType byte

func (_gcc ST_HorizontalAnchor) Validate() error { return _gcc.ValidateWithPath("") }
func (_ac *Borderright) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:word"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "borderright"
	return _ac.CT_Border.MarshalXML(e, start)
}

type Wrap struct{ CT_Wrap }

func (_dccb ST_BorderType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dccb.String(), start)
}
func (_cbfb ST_HorizontalAnchor) String() string {
	switch _cbfb {
	case 0:
		return ""
	case 1:
		return "margin"
	case 2:
		return "page"
	case 3:
		return "text"
	case 4:
		return "char"
	}
	return ""
}
func (_ggeb ST_HorizontalAnchor) ValidateWithPath(path string) error {
	switch _ggeb {
	case 0, 1, 2, 3, 4:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ggeb))
	}
	return nil
}

const (
	ST_WrapTypeUnset        ST_WrapType = 0
	ST_WrapTypeTopAndBottom ST_WrapType = 1
	ST_WrapTypeSquare       ST_WrapType = 2
	ST_WrapTypeNone         ST_WrapType = 3
	ST_WrapTypeTight        ST_WrapType = 4
	ST_WrapTypeThrough      ST_WrapType = 5
)

func NewBordertop() *Bordertop { _dbf := &Bordertop{}; _dbf.CT_Border = *NewCT_Border(); return _dbf }
func (_aee ST_VerticalAnchor) ValidateWithPath(path string) error {
	switch _aee {
	case 0, 1, 2, 3, 4:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_aee))
	}
	return nil
}
func (_gab *Bordertop) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gab.CT_Border = *NewCT_Border()
	for _, _bdad := range start.Attr {
		if _bdad.Name.Local == "type" {
			_gab.TypeAttr.UnmarshalXMLAttr(_bdad)
			continue
		}
		if _bdad.Name.Local == "width" {
			_dec, _ba := _e.ParseUint(_bdad.Value, 10, 32)
			if _ba != nil {
				return _ba
			}
			_cbg := uint32(_dec)
			_gab.WidthAttr = &_cbg
			continue
		}
		if _bdad.Name.Local == "shadow" {
			_gab.ShadowAttr.UnmarshalXMLAttr(_bdad)
			continue
		}
	}
	for {
		_fee, _feaf := d.Token()
		if _feaf != nil {
			return _f.Errorf("parsing\u0020Bordertop:\u0020\u0025s", _feaf)
		}
		if _feeg, _dc := _fee.(_b.EndElement); _dc && _feeg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fca ST_BorderShadow) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_aag := _b.Attr{}
	_aag.Name = name
	switch _fca {
	case ST_BorderShadowUnset:
		_aag.Value = ""
	case ST_BorderShadowT:
		_aag.Value = "t"
	case ST_BorderShadowTrue:
		_aag.Value = "true"
	case ST_BorderShadowF:
		_aag.Value = "f"
	case ST_BorderShadowFalse:
		_aag.Value = "false"
	}
	return _aag, nil
}
func (_ca ST_WrapType) ValidateWithPath(path string) error {
	switch _ca {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ca))
	}
	return nil
}

// ValidateWithPath validates the Borderright and its children, prefixing error messages with path
func (_bfe *Borderright) ValidateWithPath(path string) error {
	if _abc := _bfe.CT_Border.ValidateWithPath(path); _abc != nil {
		return _abc
	}
	return nil
}
func (_gfb ST_WrapType) Validate() error { return _gfb.ValidateWithPath("") }
func (_ecab *CT_Wrap) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ecab.TypeAttr != ST_WrapTypeUnset {
		_ceg, _cdf := _ecab.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _cdf != nil {
			return _cdf
		}
		start.Attr = append(start.Attr, _ceg)
	}
	if _ecab.SideAttr != ST_WrapSideUnset {
		_fa, _fcd := _ecab.SideAttr.MarshalXMLAttr(_b.Name{Local: "side"})
		if _fcd != nil {
			return _fcd
		}
		start.Attr = append(start.Attr, _fa)
	}
	if _ecab.AnchorxAttr != ST_HorizontalAnchorUnset {
		_egfb, _fef := _ecab.AnchorxAttr.MarshalXMLAttr(_b.Name{Local: "anchorx"})
		if _fef != nil {
			return _fef
		}
		start.Attr = append(start.Attr, _egfb)
	}
	if _ecab.AnchoryAttr != ST_VerticalAnchorUnset {
		_bfed, _ece := _ecab.AnchoryAttr.MarshalXMLAttr(_b.Name{Local: "anchory"})
		if _ece != nil {
			return _ece
		}
		start.Attr = append(start.Attr, _bfed)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_egfgf ST_VerticalAnchor) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_ffg := _b.Attr{}
	_ffg.Name = name
	switch _egfgf {
	case ST_VerticalAnchorUnset:
		_ffg.Value = ""
	case ST_VerticalAnchorMargin:
		_ffg.Value = "margin"
	case ST_VerticalAnchorPage:
		_ffg.Value = "page"
	case ST_VerticalAnchorText:
		_ffg.Value = "text"
	case ST_VerticalAnchorLine:
		_ffg.Value = "line"
	}
	return _ffg, nil
}

// Validate validates the CT_Border and its children
func (_cfc *CT_Border) Validate() error { return _cfc.ValidateWithPath("CT_Border") }
func (_eag ST_BorderShadow) String() string {
	switch _eag {
	case 0:
		return ""
	case 1:
		return "t"
	case 2:
		return "true"
	case 3:
		return "f"
	case 4:
		return "false"
	}
	return ""
}

const (
	ST_BorderShadowUnset ST_BorderShadow = 0
	ST_BorderShadowT     ST_BorderShadow = 1
	ST_BorderShadowTrue  ST_BorderShadow = 2
	ST_BorderShadowF     ST_BorderShadow = 3
	ST_BorderShadowFalse ST_BorderShadow = 4
)
const (
	ST_VerticalAnchorUnset  ST_VerticalAnchor = 0
	ST_VerticalAnchorMargin ST_VerticalAnchor = 1
	ST_VerticalAnchorPage   ST_VerticalAnchor = 2
	ST_VerticalAnchorText   ST_VerticalAnchor = 3
	ST_VerticalAnchorLine   ST_VerticalAnchor = 4
)

type Anchorlock struct{ CT_AnchorLock }

func (_dgb ST_WrapSide) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dgb.String(), start)
}
func (_adg *Wrap) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:word"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "wrap"
	return _adg.CT_Wrap.MarshalXML(e, start)
}

type CT_Wrap struct {
	TypeAttr    ST_WrapType
	SideAttr    ST_WrapSide
	AnchorxAttr ST_HorizontalAnchor
	AnchoryAttr ST_VerticalAnchor
}

func (_fba *ST_VerticalAnchor) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fge, _fbe := d.Token()
	if _fbe != nil {
		return _fbe
	}
	if _ggc, _dadf := _fge.(_b.EndElement); _dadf && _ggc.Name == start.Name {
		*_fba = 1
		return nil
	}
	if _fedb, _egd := _fge.(_b.CharData); !_egd {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fge)
	} else {
		switch string(_fedb) {
		case "":
			*_fba = 0
		case "margin":
			*_fba = 1
		case "page":
			*_fba = 2
		case "text":
			*_fba = 3
		case "line":
			*_fba = 4
		}
	}
	_fge, _fbe = d.Token()
	if _fbe != nil {
		return _fbe
	}
	if _dgbf, _fgc := _fge.(_b.EndElement); _fgc && _dgbf.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fge)
}

// ValidateWithPath validates the CT_AnchorLock and its children, prefixing error messages with path
func (_eec *CT_AnchorLock) ValidateWithPath(path string) error { return nil }
func (_decg *Wrap) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_decg.CT_Wrap = *NewCT_Wrap()
	for _, _ada := range start.Attr {
		if _ada.Name.Local == "type" {
			_decg.TypeAttr.UnmarshalXMLAttr(_ada)
			continue
		}
		if _ada.Name.Local == "side" {
			_decg.SideAttr.UnmarshalXMLAttr(_ada)
			continue
		}
		if _ada.Name.Local == "anchorx" {
			_decg.AnchorxAttr.UnmarshalXMLAttr(_ada)
			continue
		}
		if _ada.Name.Local == "anchory" {
			_decg.AnchoryAttr.UnmarshalXMLAttr(_ada)
			continue
		}
	}
	for {
		_egfg, _faf := d.Token()
		if _faf != nil {
			return _f.Errorf("parsing\u0020Wrap:\u0020\u0025s", _faf)
		}
		if _geec, _egb := _egfg.(_b.EndElement); _egb && _geec.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bad *ST_HorizontalAnchor) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fdcf, _ecd := d.Token()
	if _ecd != nil {
		return _ecd
	}
	if _agcg, _eed := _fdcf.(_b.EndElement); _eed && _agcg.Name == start.Name {
		*_bad = 1
		return nil
	}
	if _dag, _add := _fdcf.(_b.CharData); !_add {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fdcf)
	} else {
		switch string(_dag) {
		case "":
			*_bad = 0
		case "margin":
			*_bad = 1
		case "page":
			*_bad = 2
		case "text":
			*_bad = 3
		case "char":
			*_bad = 4
		}
	}
	_fdcf, _ecd = d.Token()
	if _ecd != nil {
		return _ecd
	}
	if _gae, _abb := _fdcf.(_b.EndElement); _abb && _gae.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fdcf)
}

// Validate validates the Borderleft and its children
func (_eaf *Borderleft) Validate() error { return _eaf.ValidateWithPath("Borderleft") }

// Validate validates the Anchorlock and its children
func (_eb *Anchorlock) Validate() error { return _eb.ValidateWithPath("Anchorlock") }
func (_bdgf ST_VerticalAnchor) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bdgf.String(), start)
}
func (_fed *ST_VerticalAnchor) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fed = 0
	case "margin":
		*_fed = 1
	case "page":
		*_fed = 2
	case "text":
		*_fed = 3
	case "line":
		*_fed = 4
	}
	return nil
}
func (_geca ST_WrapType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_cdc := _b.Attr{}
	_cdc.Name = name
	switch _geca {
	case ST_WrapTypeUnset:
		_cdc.Value = ""
	case ST_WrapTypeTopAndBottom:
		_cdc.Value = "topAndBottom"
	case ST_WrapTypeSquare:
		_cdc.Value = "square"
	case ST_WrapTypeNone:
		_cdc.Value = "none"
	case ST_WrapTypeTight:
		_cdc.Value = "tight"
	case ST_WrapTypeThrough:
		_cdc.Value = "through"
	}
	return _cdc, nil
}
func (_bfg *ST_WrapType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_bfg = 0
	case "topAndBottom":
		*_bfg = 1
	case "square":
		*_bfg = 2
	case "none":
		*_bfg = 3
	case "tight":
		*_bfg = 4
	case "through":
		*_bfg = 5
	}
	return nil
}

// Validate validates the Bordertop and its children
func (_fcg *Bordertop) Validate() error { return _fcg.ValidateWithPath("Bordertop") }
func NewWrap() *Wrap                    { _ddb := &Wrap{}; _ddb.CT_Wrap = *NewCT_Wrap(); return _ddb }
func (_fcge *CT_Border) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _def := range start.Attr {
		if _def.Name.Local == "type" {
			_fcge.TypeAttr.UnmarshalXMLAttr(_def)
			continue
		}
		if _def.Name.Local == "width" {
			_bca, _gfe := _e.ParseUint(_def.Value, 10, 32)
			if _gfe != nil {
				return _gfe
			}
			_ceb := uint32(_bca)
			_fcge.WidthAttr = &_ceb
			continue
		}
		if _def.Name.Local == "shadow" {
			_fcge.ShadowAttr.UnmarshalXMLAttr(_def)
			continue
		}
	}
	for {
		_fcgc, _gcf := d.Token()
		if _gcf != nil {
			return _f.Errorf("parsing\u0020CT_Border:\u0020\u0025s", _gcf)
		}
		if _dgc, _gde := _fcgc.(_b.EndElement); _gde && _dgc.Name == start.Name {
			break
		}
	}
	return nil
}

type ST_BorderType byte

// ValidateWithPath validates the CT_Wrap and its children, prefixing error messages with path
func (_feee *CT_Wrap) ValidateWithPath(path string) error {
	if _egg := _feee.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _egg != nil {
		return _egg
	}
	if _fg := _feee.SideAttr.ValidateWithPath(path + "\u002fSideAttr"); _fg != nil {
		return _fg
	}
	if _cgad := _feee.AnchorxAttr.ValidateWithPath(path + "\u002fAnchorxAttr"); _cgad != nil {
		return _cgad
	}
	if _ggg := _feee.AnchoryAttr.ValidateWithPath(path + "\u002fAnchoryAttr"); _ggg != nil {
		return _ggg
	}
	return nil
}
func (_fea *Bordertop) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:word"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "bordertop"
	return _fea.CT_Border.MarshalXML(e, start)
}
func (_eca *Borderleft) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:word"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "borderleft"
	return _eca.CT_Border.MarshalXML(e, start)
}

type Borderleft struct{ CT_Border }
type ST_VerticalAnchor byte

// ValidateWithPath validates the Bordertop and its children, prefixing error messages with path
func (_gee *Bordertop) ValidateWithPath(path string) error {
	if _bbc := _gee.CT_Border.ValidateWithPath(path); _bbc != nil {
		return _bbc
	}
	return nil
}
func (_gdd ST_HorizontalAnchor) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gea := _b.Attr{}
	_gea.Name = name
	switch _gdd {
	case ST_HorizontalAnchorUnset:
		_gea.Value = ""
	case ST_HorizontalAnchorMargin:
		_gea.Value = "margin"
	case ST_HorizontalAnchorPage:
		_gea.Value = "page"
	case ST_HorizontalAnchorText:
		_gea.Value = "text"
	case ST_HorizontalAnchorChar:
		_gea.Value = "char"
	}
	return _gea, nil
}

// ValidateWithPath validates the Anchorlock and its children, prefixing error messages with path
func (_gc *Anchorlock) ValidateWithPath(path string) error {
	if _dg := _gc.CT_AnchorLock.ValidateWithPath(path); _dg != nil {
		return _dg
	}
	return nil
}
func NewCT_AnchorLock() *CT_AnchorLock { _dga := &CT_AnchorLock{}; return _dga }
func init() {
	_bd.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:word", "CT_Border", NewCT_Border)
	_bd.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:word", "CT_Wrap", NewCT_Wrap)
	_bd.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:word", "CT_AnchorLock", NewCT_AnchorLock)
	_bd.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:word", "bordertop", NewBordertop)
	_bd.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:word", "borderleft", NewBorderleft)
	_bd.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:word", "borderright", NewBorderright)
	_bd.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:word", "borderbottom", NewBorderbottom)
	_bd.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:word", "wrap", NewWrap)
	_bd.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:word", "anchorlock", NewAnchorlock)
}
