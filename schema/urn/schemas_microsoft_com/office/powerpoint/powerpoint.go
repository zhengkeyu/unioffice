//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package powerpoint

import (
	_d "encoding/xml"
	_a "fmt"
	_f "gitee.com/greatmusicians/unioffice"
)

// ValidateWithPath validates the CT_Empty and its children, prefixing error messages with path
func (_ef *CT_Empty) ValidateWithPath(path string) error { return nil }

type Iscomment struct{ CT_Empty }

func (_bf *Iscomment) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns"}, Value: "urn:schemas-microsoft\u002dcom:office:powerpoint"})
//	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "iscomment"
	return _bf.CT_Empty.MarshalXML(e, start)
}
func NewCT_Empty() *CT_Empty { _ag := &CT_Empty{}; return _ag }
func (_efc *CT_Rel) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _efc.IdAttr != nil {
		start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "id"}, Value: _a.Sprintf("\u0025v", *_efc.IdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Iscomment and its children, prefixing error messages with path
func (_bfa *Iscomment) ValidateWithPath(path string) error {
	if _bbc := _bfa.CT_Empty.ValidateWithPath(path); _bbc != nil {
		return _bbc
	}
	return nil
}

// ValidateWithPath validates the Textdata and its children, prefixing error messages with path
func (_def *Textdata) ValidateWithPath(path string) error {
	if _fc := _def.CT_Rel.ValidateWithPath(path); _fc != nil {
		return _fc
	}
	return nil
}

type Textdata struct{ CT_Rel }
type CT_Empty struct{}

func (_db *Iscomment) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_db.CT_Empty = *NewCT_Empty()
	for {
		_fb, _ce := d.Token()
		if _ce != nil {
			return _a.Errorf("parsing\u0020Iscomment:\u0020\u0025s", _ce)
		}
		if _agg, _de := _fb.(_d.EndElement); _de && _agg.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the Iscomment and its children
func (_df *Iscomment) Validate() error { return _df.ValidateWithPath("Iscomment") }

type CT_Rel struct{ IdAttr *string }

func (_ad *CT_Empty) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_c *CT_Empty) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for {
		_b, _cb := d.Token()
		if _cb != nil {
			return _a.Errorf("parsing\u0020CT_Empty: \u0025s", _cb)
		}
		if _e, _eg := _b.(_d.EndElement); _eg && _e.Name == start.Name {
			break
		}
	}
	return nil
}
func NewTextdata() *Textdata { _ccb := &Textdata{}; _ccb.CT_Rel = *NewCT_Rel(); return _ccb }
func (_ec *CT_Rel) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _gf := range start.Attr {
		if _gf.Name.Local == "id" {
			_ae, _ca := _gf.Value, error(nil)
			if _ca != nil {
				return _ca
			}
			_ec.IdAttr = &_ae
			continue
		}
	}
	for {
		_dc, _cf := d.Token()
		if _cf != nil {
			return _a.Errorf("parsing\u0020CT_Rel:\u0020\u0025s", _cf)
		}
		if _cc, _bg := _dc.(_d.EndElement); _bg && _cc.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Rel() *CT_Rel { _eb := &CT_Rel{}; return _eb }
func (_bbg *Textdata) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns"}, Value: "urn:schemas-microsoft\u002dcom:office:powerpoint"})
//	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "textdata"
	return _bbg.CT_Rel.MarshalXML(e, start)
}
func NewIscomment() *Iscomment { _dg := &Iscomment{}; _dg.CT_Empty = *NewCT_Empty(); return _dg }

// ValidateWithPath validates the CT_Rel and its children, prefixing error messages with path
func (_efcg *CT_Rel) ValidateWithPath(path string) error { return nil }
func (_ea *Textdata) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ea.CT_Rel = *NewCT_Rel()
	for _, _fgf := range start.Attr {
		if _fgf.Name.Local == "id" {
			_ba, _ge := _fgf.Value, error(nil)
			if _ge != nil {
				return _ge
			}
			_ea.IdAttr = &_ba
			continue
		}
	}
	for {
		_fe, _be := d.Token()
		if _be != nil {
			return _a.Errorf("parsing\u0020Textdata: \u0025s", _be)
		}
		if _dfc, _fa := _fe.(_d.EndElement); _fa && _dfc.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the Textdata and its children
func (_geb *Textdata) Validate() error { return _geb.ValidateWithPath("Textdata") }

// Validate validates the CT_Rel and its children
func (_fg *CT_Rel) Validate() error { return _fg.ValidateWithPath("CT_Rel") }

// Validate validates the CT_Empty and its children
func (_bc *CT_Empty) Validate() error { return _bc.ValidateWithPath("CT_Empty") }
func init() {
	_f.RegisterConstructor("urn:schemas-microsoft\u002dcom:office:powerpoint", "CT_Empty", NewCT_Empty)
	_f.RegisterConstructor("urn:schemas-microsoft\u002dcom:office:powerpoint", "CT_Rel", NewCT_Rel)
	_f.RegisterConstructor("urn:schemas-microsoft\u002dcom:office:powerpoint", "iscomment", NewIscomment)
	_f.RegisterConstructor("urn:schemas-microsoft\u002dcom:office:powerpoint", "textdata", NewTextdata)
}
