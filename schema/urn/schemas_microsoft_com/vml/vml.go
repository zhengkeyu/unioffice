//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package vml

import (
	_b "encoding/xml"
	_f "fmt"
	_ba "gitee.com/greatmusicians/unioffice"
	_eb "gitee.com/greatmusicians/unioffice/schema/soo/ofc/sharedTypes"
	_ebg "gitee.com/greatmusicians/unioffice/schema/soo/wml"
	_c "gitee.com/greatmusicians/unioffice/schema/urn/schemas_microsoft_com/office/excel"
	_bf "gitee.com/greatmusicians/unioffice/schema/urn/schemas_microsoft_com/office/powerpoint"
	_a "gitee.com/greatmusicians/unioffice/schema/urn/schemas_microsoft_com/office/word"
	_e "strconv"
)

func (_aeccb ST_StrokeArrowWidth) String() string {
	switch _aeccb {
	case 0:
		return ""
	case 1:
		return "narrow"
	case 2:
		return "medium"
	case 3:
		return "wide"
	}
	return ""
}

// ValidateWithPath validates the AG_AllCoreAttributes and its children, prefixing error messages with path
func (_cdg *AG_AllCoreAttributes) ValidateWithPath(path string) error {
	if _acd := _cdg.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _acd != nil {
		return _acd
	}
	if _de := _cdg.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _de != nil {
		return _de
	}
	if _gbd := _cdg.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _gbd != nil {
		return _gbd
	}
	if _gad := _cdg.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _gad != nil {
		return _gad
	}
	if _aee := _cdg.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _aee != nil {
		return _aee
	}
	if _adc := _cdg.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _adc != nil {
		return _adc
	}
	if _ggb := _cdg.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _ggb != nil {
		return _ggb
	}
	if _ggc := _cdg.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _ggc != nil {
		return _ggc
	}
	if _gbf := _cdg.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _gbf != nil {
		return _gbf
	}
	if _ccaf := _cdg.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _ccaf != nil {
		return _ccaf
	}
	if _eba := _cdg.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _eba != nil {
		return _eba
	}
	if _dga := _cdg.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _dga != nil {
		return _dga
	}
	if _bdg := _cdg.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _bdg != nil {
		return _bdg
	}
	if _gfa := _cdg.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _gfa != nil {
		return _gfa
	}
	if _dbd := _cdg.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _dbd != nil {
		return _dbd
	}
	if _dea := _cdg.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _dea != nil {
		return _dea
	}
	return nil
}
func (_accge ST_StrokeJoinStyle) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bacd := _b.Attr{}
	_bacd.Name = name
	switch _accge {
	case ST_StrokeJoinStyleUnset:
		_bacd.Value = ""
	case ST_StrokeJoinStyleRound:
		_bacd.Value = "round"
	case ST_StrokeJoinStyleBevel:
		_bacd.Value = "bevel"
	case ST_StrokeJoinStyleMiter:
		_bacd.Value = "miter"
	}
	return _bacd, nil
}

// ValidateWithPath validates the Background and its children, prefixing error messages with path
func (_eeggc *Background) ValidateWithPath(path string) error {
	if _ggdf := _eeggc.CT_Background.ValidateWithPath(path); _ggdf != nil {
		return _ggdf
	}
	return nil
}
func (_gdggb *OfcCT_OLEObject) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _gdggb.TypeAttr != OfcST_OLETypeUnset {
		_egga, _ebee := _gdggb.TypeAttr.MarshalXMLAttr(_b.Name{Local: "Type"})
		if _ebee != nil {
			return _ebee
		}
		start.Attr = append(start.Attr, _egga)
	}
	if _gdggb.ProgIDAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "ProgID"}, Value: _f.Sprintf("\u0025v", *_gdggb.ProgIDAttr)})
	}
	if _gdggb.ShapeIDAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "ShapeID"}, Value: _f.Sprintf("\u0025v", *_gdggb.ShapeIDAttr)})
	}
	if _gdggb.DrawAspectAttr != OfcST_OLEDrawAspectUnset {
		_eaegd, _dedge := _gdggb.DrawAspectAttr.MarshalXMLAttr(_b.Name{Local: "DrawAspect"})
		if _dedge != nil {
			return _dedge
		}
		start.Attr = append(start.Attr, _eaegd)
	}
	if _gdggb.ObjectIDAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "ObjectID"}, Value: _f.Sprintf("\u0025v", *_gdggb.ObjectIDAttr)})
	}
	if _gdggb.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:id"}, Value: _f.Sprintf("\u0025v", *_gdggb.IdAttr)})
	}
	if _gdggb.UpdateModeAttr != OfcST_OLEUpdateModeUnset {
		_aeed, _ecebd := _gdggb.UpdateModeAttr.MarshalXMLAttr(_b.Name{Local: "UpdateMode"})
		if _ecebd != nil {
			return _ecebd
		}
		start.Attr = append(start.Attr, _aeed)
	}
	e.EncodeToken(start)
	if _gdggb.LinkType != nil {
		_efbcb := _b.StartElement{Name: _b.Name{Local: "o:LinkType"}}
		_ba.AddPreserveSpaceAttr(&_efbcb, *_gdggb.LinkType)
		e.EncodeElement(_gdggb.LinkType, _efbcb)
	}
	if _gdggb.LockedField != _eb.ST_TrueFalseBlankUnset {
		_cdacb := _b.StartElement{Name: _b.Name{Local: "o:LockedField"}}
		e.EncodeElement(_gdggb.LockedField, _cdacb)
	}
	if _gdggb.FieldCodes != nil {
		_decfa := _b.StartElement{Name: _b.Name{Local: "o:FieldCodes"}}
		_ba.AddPreserveSpaceAttr(&_decfa, *_gdggb.FieldCodes)
		e.EncodeElement(_gdggb.FieldCodes, _decfa)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type OfcCT_SignatureLine struct {
	IssignaturelineAttr        _eb.ST_TrueFalse
	IdAttr                     *string
	ProvidAttr                 *string
	SigninginstructionssetAttr _eb.ST_TrueFalse
	AllowcommentsAttr          _eb.ST_TrueFalse
	ShowsigndateAttr           _eb.ST_TrueFalse
	SuggestedsignerAttr        *string
	Suggestedsigner2Attr       *string
	SuggestedsigneremailAttr   *string
	SigninginstructionsAttr    *string
	AddlxmlAttr                *string
	SigprovurlAttr             *string
	ExtAttr                    ST_Ext
}

// ValidateWithPath validates the Line and its children, prefixing error messages with path
func (_ggcbd *Line) ValidateWithPath(path string) error {
	if _fegdg := _ggcbd.CT_Line.ValidateWithPath(path); _fegdg != nil {
		return _fegdg
	}
	return nil
}

type OfcCT_Callout struct {
	OnAttr              _eb.ST_TrueFalse
	TypeAttr            *string
	GapAttr             *string
	AngleAttr           OfcST_Angle
	DropautoAttr        _eb.ST_TrueFalse
	DropAttr            *string
	DistanceAttr        *string
	LengthspecifiedAttr _eb.ST_TrueFalse
	LengthAttr          *string
	AccentbarAttr       _eb.ST_TrueFalse
	TextborderAttr      _eb.ST_TrueFalse
	MinusxAttr          _eb.ST_TrueFalse
	MinusyAttr          _eb.ST_TrueFalse
	ExtAttr             ST_Ext
}

func (_afa *AG_Style) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _fbaga := range start.Attr {
		if _fbaga.Name.Local == "style" {
			_bbg, _fdgf := _fbaga.Value, error(nil)
			if _fdgf != nil {
				return _fdgf
			}
			_afa.StyleAttr = &_bbg
			continue
		}
	}
	for {
		_aaba, _faddd := d.Token()
		if _faddd != nil {
			return _f.Errorf("parsing\u0020AG_Style: \u0025s", _faddd)
		}
		if _ggdd, _acdfg := _aaba.(_b.EndElement); _acdfg && _ggdd.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bgbbe ST_Ext) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bgbbe.String(), start)
}

// ValidateWithPath validates the Textpath and its children, prefixing error messages with path
func (_fcdbg *Textpath) ValidateWithPath(path string) error {
	if _ffff := _fcdbg.CT_TextPath.ValidateWithPath(path); _ffff != nil {
		return _ffff
	}
	return nil
}

// Validate validates the OfcCT_Callout and its children
func (_baaadgf *OfcCT_Callout) Validate() error { return _baaadgf.ValidateWithPath("OfcCT_Callout") }
func (_aga *AG_Ext) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	_gga, _dgd := _aga.ExtAttr.MarshalXMLAttr(_b.Name{Local: "ext"})
	if _dgd != nil {
		return _dgd
	}
	start.Attr = append(start.Attr, _gga)
	start.Name.Local = "v:AG_Ext"
	return nil
}

type Roundrect struct{ CT_RoundRect }
type CT_Shape struct {
	GfxdataAttr           *string
	EquationxmlAttr       *string
	Ink                   []*OfcInk
	Iscomment             []*_bf.Iscomment
	Equationxml           []*OfcEquationxml
	EG_ShapeElements      []*EG_ShapeElements
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
	OpacityAttr           *string
	StrokedAttr           _eb.ST_TrueFalse
	StrokecolorAttr       *string
	StrokeweightAttr      *string
	InsetpenAttr          _eb.ST_TrueFalse
	ChromakeyAttr         *string
	FilledAttr            _eb.ST_TrueFalse
	FillcolorAttr         *string
	SptAttr               *float32
	ConnectortypeAttr     OfcST_ConnectorType
	BwmodeAttr            OfcST_BWMode
	BwpureAttr            OfcST_BWMode
	BwnormalAttr          OfcST_BWMode
	ForcedashAttr         _eb.ST_TrueFalse
	OleiconAttr           _eb.ST_TrueFalse
	OleAttr               _eb.ST_TrueFalseBlank
	PreferrelativeAttr    _eb.ST_TrueFalse
	CliptowrapAttr        _eb.ST_TrueFalse
	ClipAttr              _eb.ST_TrueFalse
	TypeAttr              *string
	AdjAttr               *string
	PathAttr              *string
}

// ValidateWithPath validates the OfcCT_ShapeLayout and its children, prefixing error messages with path
func (_ebccb *OfcCT_ShapeLayout) ValidateWithPath(path string) error {
	if _ebccb.Idmap != nil {
		if _fgacg := _ebccb.Idmap.ValidateWithPath(path + "\u002fIdmap"); _fgacg != nil {
			return _fgacg
		}
	}
	if _ebccb.Regrouptable != nil {
		if _dbbbc := _ebccb.Regrouptable.ValidateWithPath(path + "\u002fRegrouptable"); _dbbbc != nil {
			return _dbbbc
		}
	}
	if _ebccb.Rules != nil {
		if _ddaff := _ebccb.Rules.ValidateWithPath(path + "\u002fRules"); _ddaff != nil {
			return _ddaff
		}
	}
	if _cffdd := _ebccb.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _cffdd != nil {
		return _cffdd
	}
	return nil
}

// ValidateWithPath validates the OfcCT_ColorMru and its children, prefixing error messages with path
func (_fefff *OfcCT_ColorMru) ValidateWithPath(path string) error {
	if _ebadd := _fefff.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _ebadd != nil {
		return _ebadd
	}
	return nil
}

// ValidateWithPath validates the OfcOLEObject and its children, prefixing error messages with path
func (_ecbbc *OfcOLEObject) ValidateWithPath(path string) error {
	if _edddaa := _ecbbc.OfcCT_OLEObject.ValidateWithPath(path); _edddaa != nil {
		return _edddaa
	}
	return nil
}

type ST_Ext byte

func (_acaeg *OfcCT_Proxy) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _acaeg.StartAttr != _eb.ST_TrueFalseBlankUnset {
		_gfdcab, _ceacd := _acaeg.StartAttr.MarshalXMLAttr(_b.Name{Local: "start"})
		if _ceacd != nil {
			return _ceacd
		}
		start.Attr = append(start.Attr, _gfdcab)
	}
	if _acaeg.EndAttr != _eb.ST_TrueFalseBlankUnset {
		_cdbde, _ageca := _acaeg.EndAttr.MarshalXMLAttr(_b.Name{Local: "end"})
		if _ageca != nil {
			return _ageca
		}
		start.Attr = append(start.Attr, _cdbde)
	}
	if _acaeg.IdrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "idref"}, Value: _f.Sprintf("\u0025v", *_acaeg.IdrefAttr)})
	}
	if _acaeg.ConnectlocAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "connectloc"}, Value: _f.Sprintf("\u0025v", *_acaeg.ConnectlocAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_bege *CT_Background) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bege.BwmodeAttr != OfcST_BWModeUnset {
		_bgff, _eggc := _bege.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _eggc != nil {
			return _eggc
		}
		start.Attr = append(start.Attr, _bgff)
	}
	if _bege.BwpureAttr != OfcST_BWModeUnset {
		_ebeg, _fcf := _bege.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _fcf != nil {
			return _fcf
		}
		start.Attr = append(start.Attr, _ebeg)
	}
	if _bege.BwnormalAttr != OfcST_BWModeUnset {
		_faagg, _geba := _bege.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _geba != nil {
			return _geba
		}
		start.Attr = append(start.Attr, _faagg)
	}
	if _bege.TargetscreensizeAttr != OfcST_ScreenSizeUnset {
		_bgdf, _gbdf := _bege.TargetscreensizeAttr.MarshalXMLAttr(_b.Name{Local: "o:targetscreensize"})
		if _gbdf != nil {
			return _gbdf
		}
		start.Attr = append(start.Attr, _bgdf)
	}
	if _bege.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_bege.IdAttr)})
	}
	if _bege.FilledAttr != _eb.ST_TrueFalseUnset {
		_cede, _dgb := _bege.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _dgb != nil {
			return _dgb
		}
		start.Attr = append(start.Attr, _cede)
	}
	if _bege.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_bege.FillcolorAttr)})
	}
	e.EncodeToken(start)
	if _bege.Fill != nil {
		_beeg := _b.StartElement{Name: _b.Name{Local: "v:fill"}}
		e.EncodeElement(_bege.Fill, _beeg)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_bacgc OfcST_How) String() string {
	switch _bacgc {
	case 0:
		return ""
	case 1:
		return "top"
	case 2:
		return "middle"
	case 3:
		return "bottom"
	case 4:
		return "left"
	case 5:
		return "center"
	case 6:
		return "right"
	}
	return ""
}

type CT_Path struct {
	VAttr               *string
	LimoAttr            *string
	TextboxrectAttr     *string
	FillokAttr          _eb.ST_TrueFalse
	StrokeokAttr        _eb.ST_TrueFalse
	ShadowokAttr        _eb.ST_TrueFalse
	ArrowokAttr         _eb.ST_TrueFalse
	GradientshapeokAttr _eb.ST_TrueFalse
	TextpathokAttr      _eb.ST_TrueFalse
	InsetpenokAttr      _eb.ST_TrueFalse
	ConnecttypeAttr     OfcST_ConnectType
	ConnectlocsAttr     *string
	ConnectanglesAttr   *string
	ExtrusionokAttr     _eb.ST_TrueFalse
	IdAttr              *string
}

func NewOfcLock() *OfcLock { _caega := &OfcLock{}; _caega.OfcCT_Lock = *NewOfcCT_Lock(); return _caega }
func (_fdbgg *Formulas) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fdbgg.CT_Formulas = *NewCT_Formulas()
_dggff:
	for {
		_gdcab, _eaccg := d.Token()
		if _eaccg != nil {
			return _eaccg
		}
		switch _eafe := _gdcab.(type) {
		case _b.StartElement:
			switch _eafe.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "f"}:
				_fagge := NewCT_F()
				if _bacac := d.DecodeElement(_fagge, &_eafe); _bacac != nil {
					return _bacac
				}
				_fdbgg.F = append(_fdbgg.F, _fagge)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Formulas\u0020\u0025v", _eafe.Name)
				if _dcgaa := d.Skip(); _dcgaa != nil {
					return _dcgaa
				}
			}
		case _b.EndElement:
			break _dggff
		case _b.CharData:
		}
	}
	return nil
}
func (_ggabf *OfcST_How) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ccfbbb, _eafgg := d.Token()
	if _eafgg != nil {
		return _eafgg
	}
	if _fggbb, _gddae := _ccfbbb.(_b.EndElement); _gddae && _fggbb.Name == start.Name {
		*_ggabf = 1
		return nil
	}
	if _dgbcc, _ebedb := _ccfbbb.(_b.CharData); !_ebedb {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ccfbbb)
	} else {
		switch string(_dgbcc) {
		case "":
			*_ggabf = 0
		case "top":
			*_ggabf = 1
		case "middle":
			*_ggabf = 2
		case "bottom":
			*_ggabf = 3
		case "left":
			*_ggabf = 4
		case "center":
			*_ggabf = 5
		case "right":
			*_ggabf = 6
		}
	}
	_ccfbbb, _eafgg = d.Token()
	if _eafgg != nil {
		return _eafgg
	}
	if _dfdec, _faccfe := _ccfbbb.(_b.EndElement); _faccfe && _dfdec.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ccfbbb)
}
func (_fgcg *AG_Path) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dda := range start.Attr {
		if _dda.Name.Local == "path" {
			_gbaa, _fda := _dda.Value, error(nil)
			if _fda != nil {
				return _fda
			}
			_fgcg.PathAttr = &_gbaa
			continue
		}
	}
	for {
		_ddag, _fge := d.Token()
		if _fge != nil {
			return _f.Errorf("parsing\u0020AG_Path:\u0020\u0025s", _fge)
		}
		if _abb, _gfbab := _ddag.(_b.EndElement); _gfbab && _abb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gddfg *OfcCT_ClipPath) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bcdaf := range start.Attr {
		if _bcdaf.Name.Local == "v" {
			_aecbf, _dfdac := _bcdaf.Value, error(nil)
			if _dfdac != nil {
				return _dfdac
			}
			_gddfg.VAttr = _aecbf
			continue
		}
	}
	for {
		_ggdg, _bgafeb := d.Token()
		if _bgafeb != nil {
			return _f.Errorf("parsing\u0020OfcCT_ClipPath:\u0020\u0025s", _bgafeb)
		}
		if _acacb, _deged := _ggdg.(_b.EndElement); _deged && _acacb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_aaag *AG_Style) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _aaag.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_aaag.StyleAttr)})
	}
	return nil
}
func (_fgbad OfcST_OLEUpdateMode) String() string {
	switch _fgbad {
	case 0:
		return ""
	case 1:
		return "Always"
	case 2:
		return "OnCall"
	}
	return ""
}

// Validate validates the CT_ImageData and its children
func (_ggbce *CT_ImageData) Validate() error { return _ggbce.ValidateWithPath("CT_ImageData") }
func NewAG_OfficeShapeAttributes() *AG_OfficeShapeAttributes {
	_cedd := &AG_OfficeShapeAttributes{}
	return _cedd
}
func (_gfbae ST_Ext) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bacbc := _b.Attr{}
	_bacbc.Name = name
	switch _gfbae {
	case ST_ExtUnset:
		_bacbc.Value = ""
	case ST_ExtView:
		_bacbc.Value = "view"
	case ST_ExtEdit:
		_bacbc.Value = "edit"
	case ST_ExtBackwardCompatible:
		_bacbc.Value = "backwardCompatible"
	}
	return _bacbc, nil
}
func (_fdbdb *CT_Curve) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ggge := range start.Attr {
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "allowoverlap" {
			_fdbdb.AllowoverlapAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "regroupid" {
			_fgcga, _aede := _e.ParseInt(_ggge.Value, 10, 64)
			if _aede != nil {
				return _aede
			}
			_fdbdb.RegroupidAttr = &_fgcga
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "dgmlayout" {
			_fdbdb.DgmlayoutAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "doubleclicknotify" {
			_fdbdb.DoubleclicknotifyAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "preferrelative" {
			_fdbdb.PreferrelativeAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "button" {
			_fdbdb.ButtonAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "ole" {
			_fdbdb.OleAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "userhidden" {
			_fdbdb.UserhiddenAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "forcedash" {
			_fdbdb.ForcedashAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "bullet" {
			_fdbdb.BulletAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "bwpure" {
			_fdbdb.BwpureAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "clip" {
			_fdbdb.ClipAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "borderbottomcolor" {
			_fefa, _ebgg := _ggge.Value, error(nil)
			if _ebgg != nil {
				return _ebgg
			}
			_fdbdb.BorderbottomcolorAttr = &_fefa
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "bwnormal" {
			_fdbdb.BwnormalAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "hralign" {
			_fdbdb.HralignAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "hr" {
			_fdbdb.HrAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "bordertopcolor" {
			_abgea, _dbbbf := _ggge.Value, error(nil)
			if _dbbbf != nil {
				return _dbbbf
			}
			_fdbdb.BordertopcolorAttr = &_abgea
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "dgmnodekind" {
			_ecggg, _gded := _e.ParseInt(_ggge.Value, 10, 64)
			if _gded != nil {
				return _gded
			}
			_fdbdb.DgmnodekindAttr = &_ecggg
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "borderrightcolor" {
			_dbae, _ecebb := _ggge.Value, error(nil)
			if _ecebb != nil {
				return _ecebb
			}
			_fdbdb.BorderrightcolorAttr = &_dbae
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "spid" {
			_edgf, _gced := _ggge.Value, error(nil)
			if _gced != nil {
				return _gced
			}
			_fdbdb.SpidAttr = &_edgf
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "hrpct" {
			_ecga, _ecff := _e.ParseFloat(_ggge.Value, 64)
			if _ecff != nil {
				return _ecff
			}
			_bcag := float32(_ecga)
			_fdbdb.HrpctAttr = &_bcag
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "hrstd" {
			_fdbdb.HrstdAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "cliptowrap" {
			_fdbdb.CliptowrapAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "allowincell" {
			_fdbdb.AllowincellAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "dgmlayoutmru" {
			_fdbdb.DgmlayoutmruAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "userdrawn" {
			_fdbdb.UserdrawnAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "oleicon" {
			_fdbdb.OleiconAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "borderleftcolor" {
			_gecg, _ddgd := _ggge.Value, error(nil)
			if _ddgd != nil {
				return _ddgd
			}
			_fdbdb.BorderleftcolorAttr = &_gecg
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "spt" {
			_ccea, _agag := _e.ParseFloat(_ggge.Value, 64)
			if _agag != nil {
				return _agag
			}
			_aeca := float32(_ccea)
			_fdbdb.SptAttr = &_aeca
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "bwmode" {
			_fdbdb.BwmodeAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "connectortype" {
			_fdbdb.ConnectortypeAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "insetmode" {
			_fdbdb.InsetmodeAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "oned" {
			_fdbdb.OnedAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggge.Name.Local == "hrnoshade" {
			_fdbdb.HrnoshadeAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Local == "title" {
			_dddb, _gdaf := _ggge.Value, error(nil)
			if _gdaf != nil {
				return _gdaf
			}
			_fdbdb.TitleAttr = &_dddb
			continue
		}
		if _ggge.Name.Local == "wrapcoords" {
			_gfgac, _cedeg := _ggge.Value, error(nil)
			if _cedeg != nil {
				return _cedeg
			}
			_fdbdb.WrapcoordsAttr = &_gfgac
			continue
		}
		if _ggge.Name.Local == "style" {
			_cdaf, _feff := _ggge.Value, error(nil)
			if _feff != nil {
				return _feff
			}
			_fdbdb.StyleAttr = &_cdaf
			continue
		}
		if _ggge.Name.Local == "coordorigin" {
			_edgeb, _aecc := _ggge.Value, error(nil)
			if _aecc != nil {
				return _aecc
			}
			_fdbdb.CoordoriginAttr = &_edgeb
			continue
		}
		if _ggge.Name.Local == "print" {
			_fdbdb.PrintAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Local == "coordsize" {
			_cbdc, _fcad := _ggge.Value, error(nil)
			if _fcad != nil {
				return _fcad
			}
			_fdbdb.CoordsizeAttr = &_cbdc
			continue
		}
		if _ggge.Name.Local == "stroked" {
			_fdbdb.StrokedAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Local == "alt" {
			_cadaf, _aeef := _ggge.Value, error(nil)
			if _aeef != nil {
				return _aeef
			}
			_fdbdb.AltAttr = &_cadaf
			continue
		}
		if _ggge.Name.Local == "strokeweight" {
			_dcce, _dfcd := _ggge.Value, error(nil)
			if _dfcd != nil {
				return _dfcd
			}
			_fdbdb.StrokeweightAttr = &_dcce
			continue
		}
		if _ggge.Name.Local == "control1" {
			_addaa, _daaa := _ggge.Value, error(nil)
			if _daaa != nil {
				return _daaa
			}
			_fdbdb.Control1Attr = &_addaa
			continue
		}
		if _ggge.Name.Local == "chromakey" {
			_bgbb, _dafa := _ggge.Value, error(nil)
			if _dafa != nil {
				return _dafa
			}
			_fdbdb.ChromakeyAttr = &_bgbb
			continue
		}
		if _ggge.Name.Local == "fillcolor" {
			_gadbe, _eaef := _ggge.Value, error(nil)
			if _eaef != nil {
				return _eaef
			}
			_fdbdb.FillcolorAttr = &_gadbe
			continue
		}
		if _ggge.Name.Local == "id" {
			_ceedg, _abbb := _ggge.Value, error(nil)
			if _abbb != nil {
				return _abbb
			}
			_fdbdb.IdAttr = &_ceedg
			continue
		}
		if _ggge.Name.Local == "opacity" {
			_gdgc, _cfb := _ggge.Value, error(nil)
			if _cfb != nil {
				return _cfb
			}
			_fdbdb.OpacityAttr = &_gdgc
			continue
		}
		if _ggge.Name.Local == "strokecolor" {
			_deab, _ddf := _ggge.Value, error(nil)
			if _ddf != nil {
				return _ddf
			}
			_fdbdb.StrokecolorAttr = &_deab
			continue
		}
		if _ggge.Name.Local == "class" {
			_ggaae, _bcgg := _ggge.Value, error(nil)
			if _bcgg != nil {
				return _bcgg
			}
			_fdbdb.ClassAttr = &_ggaae
			continue
		}
		if _ggge.Name.Local == "filled" {
			_fdbdb.FilledAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
		if _ggge.Name.Local == "from" {
			_fdfad, _fbcf := _ggge.Value, error(nil)
			if _fbcf != nil {
				return _fbcf
			}
			_fdbdb.FromAttr = &_fdfad
			continue
		}
		if _ggge.Name.Local == "target" {
			_dffa, _caegb := _ggge.Value, error(nil)
			if _caegb != nil {
				return _caegb
			}
			_fdbdb.TargetAttr = &_dffa
			continue
		}
		if _ggge.Name.Local == "href" {
			_dcbf, _bdcfd := _ggge.Value, error(nil)
			if _bdcfd != nil {
				return _bdcfd
			}
			_fdbdb.HrefAttr = &_dcbf
			continue
		}
		if _ggge.Name.Local == "to" {
			_ebdd, _aafd := _ggge.Value, error(nil)
			if _aafd != nil {
				return _aafd
			}
			_fdbdb.ToAttr = &_ebdd
			continue
		}
		if _ggge.Name.Local == "control2" {
			_dceb, _aegeg := _ggge.Value, error(nil)
			if _aegeg != nil {
				return _aegeg
			}
			_fdbdb.Control2Attr = &_dceb
			continue
		}
		if _ggge.Name.Local == "insetpen" {
			_fdbdb.InsetpenAttr.UnmarshalXMLAttr(_ggge)
			continue
		}
	}
_febf:
	for {
		_fdee, _daea := d.Token()
		if _daea != nil {
			return _daea
		}
		switch _faff := _fdee.(type) {
		case _b.StartElement:
			switch _faff.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_acbb := NewEG_ShapeElements()
				_acbb.Path = NewPath()
				if _befa := d.DecodeElement(_acbb.Path, &_faff); _befa != nil {
					return _befa
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _acbb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_gfaa := NewEG_ShapeElements()
				_gfaa.Formulas = NewFormulas()
				if _gdfc := d.DecodeElement(_gfaa.Formulas, &_faff); _gdfc != nil {
					return _gdfc
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _gfaa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_dacf := NewEG_ShapeElements()
				_dacf.Handles = NewHandles()
				if _adecf := d.DecodeElement(_dacf.Handles, &_faff); _adecf != nil {
					return _adecf
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _dacf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_ecca := NewEG_ShapeElements()
				_ecca.Fill = NewFill()
				if _dcgce := d.DecodeElement(_ecca.Fill, &_faff); _dcgce != nil {
					return _dcgce
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _ecca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_aedf := NewEG_ShapeElements()
				_aedf.Stroke = NewStroke()
				if _ggaf := d.DecodeElement(_aedf.Stroke, &_faff); _ggaf != nil {
					return _ggaf
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _aedf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_gacg := NewEG_ShapeElements()
				_gacg.Shadow = NewShadow()
				if _caca := d.DecodeElement(_gacg.Shadow, &_faff); _caca != nil {
					return _caca
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _gacg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_dge := NewEG_ShapeElements()
				_dge.Textbox = NewTextbox()
				if _bfgaa := d.DecodeElement(_dge.Textbox, &_faff); _bfgaa != nil {
					return _bfgaa
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _dge)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_caee := NewEG_ShapeElements()
				_caee.Textpath = NewTextpath()
				if _cbde := d.DecodeElement(_caee.Textpath, &_faff); _cbde != nil {
					return _cbde
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _caee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_efcc := NewEG_ShapeElements()
				_efcc.Imagedata = NewImagedata()
				if _cfgg := d.DecodeElement(_efcc.Imagedata, &_faff); _cfgg != nil {
					return _cfgg
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _efcc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_ebdgd := NewEG_ShapeElements()
				_ebdgd.Skew = NewOfcSkew()
				if _egce := d.DecodeElement(_ebdgd.Skew, &_faff); _egce != nil {
					return _egce
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _ebdgd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_ccafe := NewEG_ShapeElements()
				_ccafe.Extrusion = NewOfcExtrusion()
				if _adae := d.DecodeElement(_ccafe.Extrusion, &_faff); _adae != nil {
					return _adae
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _ccafe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_cbcddg := NewEG_ShapeElements()
				_cbcddg.Callout = NewOfcCallout()
				if _deccd := d.DecodeElement(_cbcddg.Callout, &_faff); _deccd != nil {
					return _deccd
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _cbcddg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_eefg := NewEG_ShapeElements()
				_eefg.Lock = NewOfcLock()
				if _begb := d.DecodeElement(_eefg.Lock, &_faff); _begb != nil {
					return _begb
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _eefg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_dcae := NewEG_ShapeElements()
				_dcae.Clippath = NewOfcClippath()
				if _ecacfe := d.DecodeElement(_dcae.Clippath, &_faff); _ecacfe != nil {
					return _ecacfe
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _dcae)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_adea := NewEG_ShapeElements()
				_adea.Signatureline = NewOfcSignatureline()
				if _fcbg := d.DecodeElement(_adea.Signatureline, &_faff); _fcbg != nil {
					return _fcbg
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _adea)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_fedg := NewEG_ShapeElements()
				_fedg.Wrap = _a.NewWrap()
				if _gacag := d.DecodeElement(_fedg.Wrap, &_faff); _gacag != nil {
					return _gacag
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _fedg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_cfc := NewEG_ShapeElements()
				_cfc.Anchorlock = _a.NewAnchorlock()
				if _efcg := d.DecodeElement(_cfc.Anchorlock, &_faff); _efcg != nil {
					return _efcg
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _cfc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_gbbae := NewEG_ShapeElements()
				_gbbae.Bordertop = _a.NewBordertop()
				if _daee := d.DecodeElement(_gbbae.Bordertop, &_faff); _daee != nil {
					return _daee
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _gbbae)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_fgbg := NewEG_ShapeElements()
				_fgbg.Borderbottom = _a.NewBorderbottom()
				if _cabg := d.DecodeElement(_fgbg.Borderbottom, &_faff); _cabg != nil {
					return _cabg
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _fgbg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_fgbcf := NewEG_ShapeElements()
				_fgbcf.Borderleft = _a.NewBorderleft()
				if _affb := d.DecodeElement(_fgbcf.Borderleft, &_faff); _affb != nil {
					return _affb
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _fgbcf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_bddc := NewEG_ShapeElements()
				_bddc.Borderright = _a.NewBorderright()
				if _gbfb := d.DecodeElement(_bddc.Borderright, &_faff); _gbfb != nil {
					return _gbfb
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _bddc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_fcfb := NewEG_ShapeElements()
				_fcfb.ClientData = _c.NewClientData()
				if _egbc := d.DecodeElement(_fcfb.ClientData, &_faff); _egbc != nil {
					return _egbc
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _fcfb)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_cfgd := NewEG_ShapeElements()
				_cfgd.Textdata = _bf.NewTextdata()
				if _bgccc := d.DecodeElement(_cfgd.Textdata, &_faff); _bgccc != nil {
					return _bgccc
				}
				_fdbdb.EG_ShapeElements = append(_fdbdb.EG_ShapeElements, _cfgd)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Curve\u0020\u0025v", _faff.Name)
				if _edgfb := d.Skip(); _edgfb != nil {
					return _edgfb
				}
			}
		case _b.EndElement:
			break _febf
		case _b.CharData:
		}
	}
	return nil
}
func (_ecffb *CT_F) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ecffb.EqnAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "eqn"}, Value: _f.Sprintf("\u0025v", *_ecffb.EqnAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the AG_OfficeCoreAttributes and its children
func (_bbfd *AG_OfficeCoreAttributes) Validate() error {
	return _bbfd.ValidateWithPath("AG_OfficeCoreAttributes")
}
func (_dcgbd *OfcCT_ColorMenu) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _dcgbd.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_dcgbd.StrokecolorAttr)})
	}
	if _dcgbd.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_dcgbd.FillcolorAttr)})
	}
	if _dcgbd.ShadowcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "shadowcolor"}, Value: _f.Sprintf("\u0025v", *_dcgbd.ShadowcolorAttr)})
	}
	if _dcgbd.ExtrusioncolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "extrusioncolor"}, Value: _f.Sprintf("\u0025v", *_dcgbd.ExtrusioncolorAttr)})
	}
	if _dcgbd.ExtAttr != ST_ExtUnset {
		_abgff, _abfbc := _dcgbd.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _abfbc != nil {
			return _abfbc
		}
		start.Attr = append(start.Attr, _abgff)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewAG_Style() *AG_Style { _dfdb := &AG_Style{}; return _dfdb }
func (_gbbd *AG_ShapeAttributes) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _cdgf := range start.Attr {
		if _cdgf.Name.Local == "opacity" {
			_aged, _ccfg := _cdgf.Value, error(nil)
			if _ccfg != nil {
				return _ccfg
			}
			_gbbd.OpacityAttr = &_aged
			continue
		}
		if _cdgf.Name.Local == "stroked" {
			_gbbd.StrokedAttr.UnmarshalXMLAttr(_cdgf)
			continue
		}
		if _cdgf.Name.Local == "strokecolor" {
			_ccae, _dfc := _cdgf.Value, error(nil)
			if _dfc != nil {
				return _dfc
			}
			_gbbd.StrokecolorAttr = &_ccae
			continue
		}
		if _cdgf.Name.Local == "strokeweight" {
			_acca, _gbad := _cdgf.Value, error(nil)
			if _gbad != nil {
				return _gbad
			}
			_gbbd.StrokeweightAttr = &_acca
			continue
		}
		if _cdgf.Name.Local == "insetpen" {
			_gbbd.InsetpenAttr.UnmarshalXMLAttr(_cdgf)
			continue
		}
		if _cdgf.Name.Local == "chromakey" {
			_dgga, _adbg := _cdgf.Value, error(nil)
			if _adbg != nil {
				return _adbg
			}
			_gbbd.ChromakeyAttr = &_dgga
			continue
		}
		if _cdgf.Name.Local == "filled" {
			_gbbd.FilledAttr.UnmarshalXMLAttr(_cdgf)
			continue
		}
		if _cdgf.Name.Local == "fillcolor" {
			_ffcf, _agaa := _cdgf.Value, error(nil)
			if _agaa != nil {
				return _agaa
			}
			_gbbd.FillcolorAttr = &_ffcf
			continue
		}
	}
	for {
		_eed, _eaaf := d.Token()
		if _eaaf != nil {
			return _f.Errorf("parsing\u0020AG_ShapeAttributes:\u0020\u0025s", _eaaf)
		}
		if _cddg, _bdge := _eed.(_b.EndElement); _bdge && _cddg.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Shape() *CT_Shape                    { _fcaeg := &CT_Shape{}; return _fcaeg }
func (_fgaage OfcST_InsetMode) Validate() error { return _fgaage.ValidateWithPath("") }

// Validate validates the AG_Chromakey and its children
func (_fbe *AG_Chromakey) Validate() error { return _fbe.ValidateWithPath("AG_Chromakey") }
func (_agfda *Image) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_agfda.CT_Image = *NewCT_Image()
	for _, _cffdb := range start.Attr {
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "dgmnodekind" {
			_eace, _fdbff := _e.ParseInt(_cffdb.Value, 10, 64)
			if _fdbff != nil {
				return _fdbff
			}
			_agfda.DgmnodekindAttr = &_eace
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "bullet" {
			_agfda.BulletAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "hr" {
			_agfda.HrAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "oleicon" {
			_agfda.OleiconAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "hrstd" {
			_agfda.HrstdAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "clip" {
			_agfda.ClipAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "hrnoshade" {
			_agfda.HrnoshadeAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "preferrelative" {
			_agfda.PreferrelativeAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "hrpct" {
			_eecaa, _gdbbc := _e.ParseFloat(_cffdb.Value, 64)
			if _gdbbc != nil {
				return _gdbbc
			}
			_gabf := float32(_eecaa)
			_agfda.HrpctAttr = &_gabf
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "ole" {
			_agfda.OleAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "hralign" {
			_agfda.HralignAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "bwpure" {
			_agfda.BwpureAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "dgmlayout" {
			_agfda.DgmlayoutAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "insetmode" {
			_agfda.InsetmodeAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "spid" {
			_ceacg, _cegbg := _cffdb.Value, error(nil)
			if _cegbg != nil {
				return _cegbg
			}
			_agfda.SpidAttr = &_ceacg
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "borderbottomcolor" {
			_bdecc, _afbeae := _cffdb.Value, error(nil)
			if _afbeae != nil {
				return _afbeae
			}
			_agfda.BorderbottomcolorAttr = &_bdecc
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "allowoverlap" {
			_agfda.AllowoverlapAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "doubleclicknotify" {
			_agfda.DoubleclicknotifyAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "dgmlayoutmru" {
			_agfda.DgmlayoutmruAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "userhidden" {
			_agfda.UserhiddenAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "allowincell" {
			_agfda.AllowincellAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "spt" {
			_gfdgb, _cfccc := _e.ParseFloat(_cffdb.Value, 64)
			if _cfccc != nil {
				return _cfccc
			}
			_efdac := float32(_gfdgb)
			_agfda.SptAttr = &_efdac
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "borderleftcolor" {
			_dgdgb, _gdgaf := _cffdb.Value, error(nil)
			if _gdgaf != nil {
				return _gdgaf
			}
			_agfda.BorderleftcolorAttr = &_dgdgb
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "userdrawn" {
			_agfda.UserdrawnAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "cliptowrap" {
			_agfda.CliptowrapAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "borderrightcolor" {
			_gbefd, _dabgea := _cffdb.Value, error(nil)
			if _dabgea != nil {
				return _dabgea
			}
			_agfda.BorderrightcolorAttr = &_gbefd
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "connectortype" {
			_agfda.ConnectortypeAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "button" {
			_agfda.ButtonAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "forcedash" {
			_agfda.ForcedashAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "regroupid" {
			_bedb, _edceg := _e.ParseInt(_cffdb.Value, 10, 64)
			if _edceg != nil {
				return _edceg
			}
			_agfda.RegroupidAttr = &_bedb
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "oned" {
			_agfda.OnedAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "bwmode" {
			_agfda.BwmodeAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "bwnormal" {
			_agfda.BwnormalAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffdb.Name.Local == "bordertopcolor" {
			_egaae, _ccdea := _cffdb.Value, error(nil)
			if _ccdea != nil {
				return _ccdea
			}
			_agfda.BordertopcolorAttr = &_egaae
			continue
		}
		if _cffdb.Name.Local == "print" {
			_agfda.PrintAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Local == "target" {
			_ecafc, _cegbf := _cffdb.Value, error(nil)
			if _cegbf != nil {
				return _cegbf
			}
			_agfda.TargetAttr = &_ecafc
			continue
		}
		if _cffdb.Name.Local == "stroked" {
			_agfda.StrokedAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Local == "coordorigin" {
			_ecggeg, _ccbef := _cffdb.Value, error(nil)
			if _ccbef != nil {
				return _ccbef
			}
			_agfda.CoordoriginAttr = &_ecggeg
			continue
		}
		if _cffdb.Name.Local == "strokeweight" {
			_cbfeg, _fgae := _cffdb.Value, error(nil)
			if _fgae != nil {
				return _fgae
			}
			_agfda.StrokeweightAttr = &_cbfeg
			continue
		}
		if _cffdb.Name.Local == "coordsize" {
			_deecg, _cgfde := _cffdb.Value, error(nil)
			if _cgfde != nil {
				return _cgfde
			}
			_agfda.CoordsizeAttr = &_deecg
			continue
		}
		if _cffdb.Name.Local == "chromakey" {
			_bccgd, _aaddf := _cffdb.Value, error(nil)
			if _aaddf != nil {
				return _aaddf
			}
			_agfda.ChromakeyAttr = &_bccgd
			continue
		}
		if _cffdb.Name.Local == "alt" {
			_eeab, _baebc := _cffdb.Value, error(nil)
			if _baebc != nil {
				return _baebc
			}
			_agfda.AltAttr = &_eeab
			continue
		}
		if _cffdb.Name.Local == "fillcolor" {
			_ddgaf, _acfff := _cffdb.Value, error(nil)
			if _acfff != nil {
				return _acfff
			}
			_agfda.FillcolorAttr = &_ddgaf
			continue
		}
		if _cffdb.Name.Local == "src" {
			_gbcbf, _degcd := _cffdb.Value, error(nil)
			if _degcd != nil {
				return _degcd
			}
			_agfda.SrcAttr = &_gbcbf
			continue
		}
		if _cffdb.Name.Local == "wrapcoords" {
			_cddfcf, _ffca := _cffdb.Value, error(nil)
			if _ffca != nil {
				return _ffca
			}
			_agfda.WrapcoordsAttr = &_cddfcf
			continue
		}
		if _cffdb.Name.Local == "title" {
			_ecgc, _dbag := _cffdb.Value, error(nil)
			if _dbag != nil {
				return _dbag
			}
			_agfda.TitleAttr = &_ecgc
			continue
		}
		if _cffdb.Name.Local == "style" {
			_dagda, _ebbad := _cffdb.Value, error(nil)
			if _ebbad != nil {
				return _ebbad
			}
			_agfda.StyleAttr = &_dagda
			continue
		}
		if _cffdb.Name.Local == "cropright" {
			_bdccb, _aeeb := _cffdb.Value, error(nil)
			if _aeeb != nil {
				return _aeeb
			}
			_agfda.CroprightAttr = &_bdccb
			continue
		}
		if _cffdb.Name.Local == "insetpen" {
			_agfda.InsetpenAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Local == "cropleft" {
			_gffc, _gefbcf := _cffdb.Value, error(nil)
			if _gefbcf != nil {
				return _gefbcf
			}
			_agfda.CropleftAttr = &_gffc
			continue
		}
		if _cffdb.Name.Local == "gain" {
			_fgbfg, _ccffgd := _cffdb.Value, error(nil)
			if _ccffgd != nil {
				return _ccffgd
			}
			_agfda.GainAttr = &_fgbfg
			continue
		}
		if _cffdb.Name.Local == "strokecolor" {
			_ebdc, _fdeacg := _cffdb.Value, error(nil)
			if _fdeacg != nil {
				return _fdeacg
			}
			_agfda.StrokecolorAttr = &_ebdc
			continue
		}
		if _cffdb.Name.Local == "class" {
			_adbdd, _abgeaf := _cffdb.Value, error(nil)
			if _abgeaf != nil {
				return _abgeaf
			}
			_agfda.ClassAttr = &_adbdd
			continue
		}
		if _cffdb.Name.Local == "id" {
			_acfega, _badec := _cffdb.Value, error(nil)
			if _badec != nil {
				return _badec
			}
			_agfda.IdAttr = &_acfega
			continue
		}
		if _cffdb.Name.Local == "cropbottom" {
			_gfgcg, _aceca := _cffdb.Value, error(nil)
			if _aceca != nil {
				return _aceca
			}
			_agfda.CropbottomAttr = &_gfgcg
			continue
		}
		if _cffdb.Name.Local == "filled" {
			_agfda.FilledAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Local == "grayscale" {
			_agfda.GrayscaleAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Local == "blacklevel" {
			_fecgfb, _gebeba := _cffdb.Value, error(nil)
			if _gebeba != nil {
				return _gebeba
			}
			_agfda.BlacklevelAttr = &_fecgfb
			continue
		}
		if _cffdb.Name.Local == "href" {
			_egacb, _ddbgd := _cffdb.Value, error(nil)
			if _ddbgd != nil {
				return _ddbgd
			}
			_agfda.HrefAttr = &_egacb
			continue
		}
		if _cffdb.Name.Local == "bilevel" {
			_agfda.BilevelAttr.UnmarshalXMLAttr(_cffdb)
			continue
		}
		if _cffdb.Name.Local == "croptop" {
			_efed, _cgeadf := _cffdb.Value, error(nil)
			if _cgeadf != nil {
				return _cgeadf
			}
			_agfda.CroptopAttr = &_efed
			continue
		}
		if _cffdb.Name.Local == "opacity" {
			_eggf, _afegbe := _cffdb.Value, error(nil)
			if _afegbe != nil {
				return _afegbe
			}
			_agfda.OpacityAttr = &_eggf
			continue
		}
		if _cffdb.Name.Local == "gamma" {
			_cdgca, _bafaa := _cffdb.Value, error(nil)
			if _bafaa != nil {
				return _bafaa
			}
			_agfda.GammaAttr = &_cdgca
			continue
		}
	}
_fbcb:
	for {
		_ffdg, _dfagf := d.Token()
		if _dfagf != nil {
			return _dfagf
		}
		switch _dfddg := _ffdg.(type) {
		case _b.StartElement:
			switch _dfddg.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_ecfd := NewEG_ShapeElements()
				_ecfd.Path = NewPath()
				if _eafde := d.DecodeElement(_ecfd.Path, &_dfddg); _eafde != nil {
					return _eafde
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _ecfd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_bbee := NewEG_ShapeElements()
				_bbee.Formulas = NewFormulas()
				if _baffg := d.DecodeElement(_bbee.Formulas, &_dfddg); _baffg != nil {
					return _baffg
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _bbee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_fbdc := NewEG_ShapeElements()
				_fbdc.Handles = NewHandles()
				if _ddaa := d.DecodeElement(_fbdc.Handles, &_dfddg); _ddaa != nil {
					return _ddaa
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _fbdc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_bbgbd := NewEG_ShapeElements()
				_bbgbd.Fill = NewFill()
				if _dbecf := d.DecodeElement(_bbgbd.Fill, &_dfddg); _dbecf != nil {
					return _dbecf
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _bbgbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_gafec := NewEG_ShapeElements()
				_gafec.Stroke = NewStroke()
				if _eabfg := d.DecodeElement(_gafec.Stroke, &_dfddg); _eabfg != nil {
					return _eabfg
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _gafec)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_deag := NewEG_ShapeElements()
				_deag.Shadow = NewShadow()
				if _bgeeff := d.DecodeElement(_deag.Shadow, &_dfddg); _bgeeff != nil {
					return _bgeeff
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _deag)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_dcaa := NewEG_ShapeElements()
				_dcaa.Textbox = NewTextbox()
				if _caeca := d.DecodeElement(_dcaa.Textbox, &_dfddg); _caeca != nil {
					return _caeca
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _dcaa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_dfeff := NewEG_ShapeElements()
				_dfeff.Textpath = NewTextpath()
				if _cbad := d.DecodeElement(_dfeff.Textpath, &_dfddg); _cbad != nil {
					return _cbad
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _dfeff)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_dgfa := NewEG_ShapeElements()
				_dgfa.Imagedata = NewImagedata()
				if _eggegf := d.DecodeElement(_dgfa.Imagedata, &_dfddg); _eggegf != nil {
					return _eggegf
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _dgfa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_bdbfb := NewEG_ShapeElements()
				_bdbfb.Skew = NewOfcSkew()
				if _gfeebc := d.DecodeElement(_bdbfb.Skew, &_dfddg); _gfeebc != nil {
					return _gfeebc
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _bdbfb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_geaf := NewEG_ShapeElements()
				_geaf.Extrusion = NewOfcExtrusion()
				if _dceegg := d.DecodeElement(_geaf.Extrusion, &_dfddg); _dceegg != nil {
					return _dceegg
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _geaf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_defa := NewEG_ShapeElements()
				_defa.Callout = NewOfcCallout()
				if _cddaf := d.DecodeElement(_defa.Callout, &_dfddg); _cddaf != nil {
					return _cddaf
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _defa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_adaef := NewEG_ShapeElements()
				_adaef.Lock = NewOfcLock()
				if _defg := d.DecodeElement(_adaef.Lock, &_dfddg); _defg != nil {
					return _defg
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _adaef)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_afca := NewEG_ShapeElements()
				_afca.Clippath = NewOfcClippath()
				if _gfeg := d.DecodeElement(_afca.Clippath, &_dfddg); _gfeg != nil {
					return _gfeg
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _afca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_cbecf := NewEG_ShapeElements()
				_cbecf.Signatureline = NewOfcSignatureline()
				if _cfaga := d.DecodeElement(_cbecf.Signatureline, &_dfddg); _cfaga != nil {
					return _cfaga
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _cbecf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_ceffe := NewEG_ShapeElements()
				_ceffe.Wrap = _a.NewWrap()
				if _gbdda := d.DecodeElement(_ceffe.Wrap, &_dfddg); _gbdda != nil {
					return _gbdda
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _ceffe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_fbabb := NewEG_ShapeElements()
				_fbabb.Anchorlock = _a.NewAnchorlock()
				if _gafa := d.DecodeElement(_fbabb.Anchorlock, &_dfddg); _gafa != nil {
					return _gafa
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _fbabb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_babeb := NewEG_ShapeElements()
				_babeb.Bordertop = _a.NewBordertop()
				if _efdfd := d.DecodeElement(_babeb.Bordertop, &_dfddg); _efdfd != nil {
					return _efdfd
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _babeb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_dadda := NewEG_ShapeElements()
				_dadda.Borderbottom = _a.NewBorderbottom()
				if _ecebbe := d.DecodeElement(_dadda.Borderbottom, &_dfddg); _ecebbe != nil {
					return _ecebbe
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _dadda)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_ecdg := NewEG_ShapeElements()
				_ecdg.Borderleft = _a.NewBorderleft()
				if _beccb := d.DecodeElement(_ecdg.Borderleft, &_dfddg); _beccb != nil {
					return _beccb
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _ecdg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_bfbab := NewEG_ShapeElements()
				_bfbab.Borderright = _a.NewBorderright()
				if _fbede := d.DecodeElement(_bfbab.Borderright, &_dfddg); _fbede != nil {
					return _fbede
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _bfbab)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_gbagd := NewEG_ShapeElements()
				_gbagd.ClientData = _c.NewClientData()
				if _cefce := d.DecodeElement(_gbagd.ClientData, &_dfddg); _cefce != nil {
					return _cefce
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _gbagd)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_gfcgg := NewEG_ShapeElements()
				_gfcgg.Textdata = _bf.NewTextdata()
				if _cfeff := d.DecodeElement(_gfcgg.Textdata, &_dfddg); _cfeff != nil {
					return _cfeff
				}
				_agfda.EG_ShapeElements = append(_agfda.EG_ShapeElements, _gfcgg)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on Image \u0025v", _dfddg.Name)
				if _bdgb := d.Skip(); _bdgb != nil {
					return _bdgb
				}
			}
		case _b.EndElement:
			break _fbcb
		case _b.CharData:
		}
	}
	return nil
}

type OfcCallout struct{ OfcCT_Callout }

func (_cbbdc *OfcRight) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cbbdc.OfcCT_StrokeChild = *NewOfcCT_StrokeChild()
	for _, _gfcgd := range start.Attr {
		if _gfcgd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gfcgd.Name.Local == "href" {
			_ceddc, _bfgba := _gfcgd.Value, error(nil)
			if _bfgba != nil {
				return _bfgba
			}
			_cbbdc.HrefAttr = &_ceddc
			continue
		}
		if _gfcgd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gfcgd.Name.Local == "forcedash" {
			_cbbdc.ForcedashAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gfcgd.Name.Local == "title" {
			_dccead, _fdfeab := _gfcgd.Value, error(nil)
			if _fdfeab != nil {
				return _fdfeab
			}
			_cbbdc.TitleAttr = &_dccead
			continue
		}
		if _gfcgd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gfcgd.Name.Local == "althref" {
			_beecb, _bcaccd := _gfcgd.Value, error(nil)
			if _bcaccd != nil {
				return _bcaccd
			}
			_cbbdc.AlthrefAttr = &_beecb
			continue
		}
		if _gfcgd.Name.Local == "imageaspect" {
			_cbbdc.ImageaspectAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "startarrow" {
			_cbbdc.StartarrowAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "linestyle" {
			_cbbdc.LinestyleAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "startarrowwidth" {
			_cbbdc.StartarrowwidthAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "joinstyle" {
			_cbbdc.JoinstyleAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "startarrowlength" {
			_cbbdc.StartarrowlengthAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "dashstyle" {
			_gbbge, _aafgf := _gfcgd.Value, error(nil)
			if _aafgf != nil {
				return _aafgf
			}
			_cbbdc.DashstyleAttr = &_gbbge
			continue
		}
		if _gfcgd.Name.Local == "endarrow" {
			_cbbdc.EndarrowAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "filltype" {
			_cbbdc.FilltypeAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "endarrowwidth" {
			_cbbdc.EndarrowwidthAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "opacity" {
			_efbcd, _cecef := _gfcgd.Value, error(nil)
			if _cecef != nil {
				return _cecef
			}
			_cbbdc.OpacityAttr = &_efbcd
			continue
		}
		if _gfcgd.Name.Local == "color" {
			_agcea, _fafdf := _gfcgd.Value, error(nil)
			if _fafdf != nil {
				return _fafdf
			}
			_cbbdc.ColorAttr = &_agcea
			continue
		}
		if _gfcgd.Name.Local == "insetpen" {
			_cbbdc.InsetpenAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "endarrowlength" {
			_cbbdc.EndarrowlengthAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "ext" {
			_cbbdc.ExtAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "endcap" {
			_cbbdc.EndcapAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "color2" {
			_gcgfg, _gfdeb := _gfcgd.Value, error(nil)
			if _gfdeb != nil {
				return _gfdeb
			}
			_cbbdc.Color2Attr = &_gcgfg
			continue
		}
		if _gfcgd.Name.Local == "imagealignshape" {
			_cbbdc.ImagealignshapeAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
		if _gfcgd.Name.Local == "weight" {
			_addaeb, _ddbec := _gfcgd.Value, error(nil)
			if _ddbec != nil {
				return _ddbec
			}
			_cbbdc.WeightAttr = &_addaeb
			continue
		}
		if _gfcgd.Name.Local == "src" {
			_fefgc, _agece := _gfcgd.Value, error(nil)
			if _agece != nil {
				return _agece
			}
			_cbbdc.SrcAttr = &_fefgc
			continue
		}
		if _gfcgd.Name.Local == "imagesize" {
			_dcged, _feecg := _gfcgd.Value, error(nil)
			if _feecg != nil {
				return _feecg
			}
			_cbbdc.ImagesizeAttr = &_dcged
			continue
		}
		if _gfcgd.Name.Local == "miterlimit" {
			_eeebeb, _adgdg := _e.ParseFloat(_gfcgd.Value, 64)
			if _adgdg != nil {
				return _adgdg
			}
			_cbbdc.MiterlimitAttr = &_eeebeb
			continue
		}
		if _gfcgd.Name.Local == "on" {
			_cbbdc.OnAttr.UnmarshalXMLAttr(_gfcgd)
			continue
		}
	}
	for {
		_cgdc, _fbbdg := d.Token()
		if _fbbdg != nil {
			return _f.Errorf("parsing\u0020OfcRight: \u0025s", _fbbdg)
		}
		if _cecg, _cgcaa := _cgdc.(_b.EndElement); _cgcaa && _cecg.Name == start.Name {
			break
		}
	}
	return nil
}

type OfcST_CalloutPlacement byte

// Validate validates the Textbox and its children
func (_edad *Textbox) Validate() error { return _edad.ValidateWithPath("Textbox") }
func (_baag *CT_Fill) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _baag.TypeAttr != ST_FillTypeUnset {
		_afbe, _edbc := _baag.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _edbc != nil {
			return _edbc
		}
		start.Attr = append(start.Attr, _afbe)
	}
	if _baag.OnAttr != _eb.ST_TrueFalseUnset {
		_egbe, _abbd := _baag.OnAttr.MarshalXMLAttr(_b.Name{Local: "on"})
		if _abbd != nil {
			return _abbd
		}
		start.Attr = append(start.Attr, _egbe)
	}
	if _baag.ColorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "color"}, Value: _f.Sprintf("\u0025v", *_baag.ColorAttr)})
	}
	if _baag.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_baag.OpacityAttr)})
	}
	if _baag.Color2Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "color2"}, Value: _f.Sprintf("\u0025v", *_baag.Color2Attr)})
	}
	if _baag.SrcAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "src"}, Value: _f.Sprintf("\u0025v", *_baag.SrcAttr)})
	}
	if _baag.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:href"}, Value: _f.Sprintf("\u0025v", *_baag.HrefAttr)})
	}
	if _baag.AlthrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:althref"}, Value: _f.Sprintf("\u0025v", *_baag.AlthrefAttr)})
	}
	if _baag.SizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "size"}, Value: _f.Sprintf("\u0025v", *_baag.SizeAttr)})
	}
	if _baag.OriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "origin"}, Value: _f.Sprintf("\u0025v", *_baag.OriginAttr)})
	}
	if _baag.PositionAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "position"}, Value: _f.Sprintf("\u0025v", *_baag.PositionAttr)})
	}
	if _baag.AspectAttr != ST_ImageAspectUnset {
		_eeaa, _gfbec := _baag.AspectAttr.MarshalXMLAttr(_b.Name{Local: "aspect"})
		if _gfbec != nil {
			return _gfbec
		}
		start.Attr = append(start.Attr, _eeaa)
	}
	if _baag.ColorsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "colors"}, Value: _f.Sprintf("\u0025v", *_baag.ColorsAttr)})
	}
	if _baag.AngleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "angle"}, Value: _f.Sprintf("\u0025v", *_baag.AngleAttr)})
	}
	if _baag.AlignshapeAttr != _eb.ST_TrueFalseUnset {
		_gbdea, _gfff := _baag.AlignshapeAttr.MarshalXMLAttr(_b.Name{Local: "alignshape"})
		if _gfff != nil {
			return _gfff
		}
		start.Attr = append(start.Attr, _gbdea)
	}
	if _baag.FocusAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "focus"}, Value: _f.Sprintf("\u0025v", *_baag.FocusAttr)})
	}
	if _baag.FocussizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "focussize"}, Value: _f.Sprintf("\u0025v", *_baag.FocussizeAttr)})
	}
	if _baag.FocuspositionAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "focusposition"}, Value: _f.Sprintf("\u0025v", *_baag.FocuspositionAttr)})
	}
	if _baag.MethodAttr != ST_FillMethodUnset {
		_gdeb, _dccg := _baag.MethodAttr.MarshalXMLAttr(_b.Name{Local: "method"})
		if _dccg != nil {
			return _dccg
		}
		start.Attr = append(start.Attr, _gdeb)
	}
	if _baag.DetectmouseclickAttr != _eb.ST_TrueFalseUnset {
		_cabgb, _dggdb := _baag.DetectmouseclickAttr.MarshalXMLAttr(_b.Name{Local: "o:detectmouseclick"})
		if _dggdb != nil {
			return _dggdb
		}
		start.Attr = append(start.Attr, _cabgb)
	}
	if _baag.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:title"}, Value: _f.Sprintf("\u0025v", *_baag.TitleAttr)})
	}
	if _baag.Opacity2Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:opacity2"}, Value: _f.Sprintf("\u0025v", *_baag.Opacity2Attr)})
	}
	if _baag.RecolorAttr != _eb.ST_TrueFalseUnset {
		_aabdc, _fdcg := _baag.RecolorAttr.MarshalXMLAttr(_b.Name{Local: "recolor"})
		if _fdcg != nil {
			return _fdcg
		}
		start.Attr = append(start.Attr, _aabdc)
	}
	if _baag.RotateAttr != _eb.ST_TrueFalseUnset {
		_fedf, _ccdd := _baag.RotateAttr.MarshalXMLAttr(_b.Name{Local: "rotate"})
		if _ccdd != nil {
			return _ccdd
		}
		start.Attr = append(start.Attr, _fedf)
	}
	if _baag.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:id"}, Value: _f.Sprintf("\u0025v", *_baag.IdAttr)})
	}
	if _baag.RelidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:relid"}, Value: _f.Sprintf("\u0025v", *_baag.RelidAttr)})
	}
	if _baag.SIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_baag.SIdAttr)})
	}
	e.EncodeToken(start)
	if _baag.Fill != nil {
		_bcabg := _b.StartElement{Name: _b.Name{Local: "o:fill"}}
		e.EncodeElement(_baag.Fill, _bcabg)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_adbbe *CT_Rect) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _cffca := range start.Attr {
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "bordertopcolor" {
			_fgfgd, _acdfgf := _cffca.Value, error(nil)
			if _acdfgf != nil {
				return _acdfgf
			}
			_adbbe.BordertopcolorAttr = &_fgfgd
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "bullet" {
			_adbbe.BulletAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "hr" {
			_adbbe.HrAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "cliptowrap" {
			_adbbe.CliptowrapAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "hrstd" {
			_adbbe.HrstdAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "ole" {
			_adbbe.OleAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "hrnoshade" {
			_adbbe.HrnoshadeAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "oned" {
			_adbbe.OnedAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "hrpct" {
			_ffga, _gacb := _e.ParseFloat(_cffca.Value, 64)
			if _gacb != nil {
				return _gacb
			}
			_efea := float32(_ffga)
			_adbbe.HrpctAttr = &_efea
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "oleicon" {
			_adbbe.OleiconAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "borderbottomcolor" {
			_ebbef, _dabce := _cffca.Value, error(nil)
			if _dabce != nil {
				return _dabce
			}
			_adbbe.BorderbottomcolorAttr = &_ebbef
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "dgmlayoutmru" {
			_adbbe.DgmlayoutmruAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "regroupid" {
			_ddafa, _caad := _e.ParseInt(_cffca.Value, 10, 64)
			if _caad != nil {
				return _caad
			}
			_adbbe.RegroupidAttr = &_ddafa
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "clip" {
			_adbbe.ClipAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "hralign" {
			_adbbe.HralignAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "preferrelative" {
			_adbbe.PreferrelativeAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "dgmlayout" {
			_adbbe.DgmlayoutAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "doubleclicknotify" {
			_adbbe.DoubleclicknotifyAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "insetmode" {
			_adbbe.InsetmodeAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "button" {
			_adbbe.ButtonAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "userdrawn" {
			_adbbe.UserdrawnAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "allowincell" {
			_adbbe.AllowincellAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "spt" {
			_ggea, _aegc := _e.ParseFloat(_cffca.Value, 64)
			if _aegc != nil {
				return _aegc
			}
			_fgbdg := float32(_ggea)
			_adbbe.SptAttr = &_fgbdg
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "borderleftcolor" {
			_gcda, _gdgcf := _cffca.Value, error(nil)
			if _gdgcf != nil {
				return _gdgcf
			}
			_adbbe.BorderleftcolorAttr = &_gcda
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "connectortype" {
			_adbbe.ConnectortypeAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "borderrightcolor" {
			_gcaag, _bagf := _cffca.Value, error(nil)
			if _bagf != nil {
				return _bagf
			}
			_adbbe.BorderrightcolorAttr = &_gcaag
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "spid" {
			_efca, _cdffb := _cffca.Value, error(nil)
			if _cdffb != nil {
				return _cdffb
			}
			_adbbe.SpidAttr = &_efca
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "dgmnodekind" {
			_agbef, _dafcf := _e.ParseInt(_cffca.Value, 10, 64)
			if _dafcf != nil {
				return _dafcf
			}
			_adbbe.DgmnodekindAttr = &_agbef
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "bwpure" {
			_adbbe.BwpureAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "forcedash" {
			_adbbe.ForcedashAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "bwnormal" {
			_adbbe.BwnormalAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "bwmode" {
			_adbbe.BwmodeAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "userhidden" {
			_adbbe.UserhiddenAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cffca.Name.Local == "allowoverlap" {
			_adbbe.AllowoverlapAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Local == "target" {
			_bgcgeg, _dcfdf := _cffca.Value, error(nil)
			if _dcfdf != nil {
				return _dcfdf
			}
			_adbbe.TargetAttr = &_bgcgeg
			continue
		}
		if _cffca.Name.Local == "coordorigin" {
			_afaef, _aded := _cffca.Value, error(nil)
			if _aded != nil {
				return _aded
			}
			_adbbe.CoordoriginAttr = &_afaef
			continue
		}
		if _cffca.Name.Local == "stroked" {
			_adbbe.StrokedAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Local == "coordsize" {
			_adedf, _aedcg := _cffca.Value, error(nil)
			if _aedcg != nil {
				return _aedcg
			}
			_adbbe.CoordsizeAttr = &_adedf
			continue
		}
		if _cffca.Name.Local == "strokeweight" {
			_cfdbc, _bfbdb := _cffca.Value, error(nil)
			if _bfbdb != nil {
				return _bfbdb
			}
			_adbbe.StrokeweightAttr = &_cfdbc
			continue
		}
		if _cffca.Name.Local == "style" {
			_febef, _dggede := _cffca.Value, error(nil)
			if _dggede != nil {
				return _dggede
			}
			_adbbe.StyleAttr = &_febef
			continue
		}
		if _cffca.Name.Local == "chromakey" {
			_cgdad, _aefc := _cffca.Value, error(nil)
			if _aefc != nil {
				return _aefc
			}
			_adbbe.ChromakeyAttr = &_cgdad
			continue
		}
		if _cffca.Name.Local == "fillcolor" {
			_aedcfe, _facb := _cffca.Value, error(nil)
			if _facb != nil {
				return _facb
			}
			_adbbe.FillcolorAttr = &_aedcfe
			continue
		}
		if _cffca.Name.Local == "opacity" {
			_cbbda, _ddgg := _cffca.Value, error(nil)
			if _ddgg != nil {
				return _ddgg
			}
			_adbbe.OpacityAttr = &_cbbda
			continue
		}
		if _cffca.Name.Local == "wrapcoords" {
			_dggaf, _gagddb := _cffca.Value, error(nil)
			if _gagddb != nil {
				return _gagddb
			}
			_adbbe.WrapcoordsAttr = &_dggaf
			continue
		}
		if _cffca.Name.Local == "strokecolor" {
			_ggab, _gdga := _cffca.Value, error(nil)
			if _gdga != nil {
				return _gdga
			}
			_adbbe.StrokecolorAttr = &_ggab
			continue
		}
		if _cffca.Name.Local == "insetpen" {
			_adbbe.InsetpenAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Local == "href" {
			_fbeda, _cdge := _cffca.Value, error(nil)
			if _cdge != nil {
				return _cdge
			}
			_adbbe.HrefAttr = &_fbeda
			continue
		}
		if _cffca.Name.Local == "id" {
			_fbecg, _beegb := _cffca.Value, error(nil)
			if _beegb != nil {
				return _beegb
			}
			_adbbe.IdAttr = &_fbecg
			continue
		}
		if _cffca.Name.Local == "print" {
			_adbbe.PrintAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
		if _cffca.Name.Local == "alt" {
			_bgcgf, _fbad := _cffca.Value, error(nil)
			if _fbad != nil {
				return _fbad
			}
			_adbbe.AltAttr = &_bgcgf
			continue
		}
		if _cffca.Name.Local == "title" {
			_cbefe, _adedfc := _cffca.Value, error(nil)
			if _adedfc != nil {
				return _adedfc
			}
			_adbbe.TitleAttr = &_cbefe
			continue
		}
		if _cffca.Name.Local == "class" {
			_cbec, _feefgg := _cffca.Value, error(nil)
			if _feefgg != nil {
				return _feefgg
			}
			_adbbe.ClassAttr = &_cbec
			continue
		}
		if _cffca.Name.Local == "filled" {
			_adbbe.FilledAttr.UnmarshalXMLAttr(_cffca)
			continue
		}
	}
_edbe:
	for {
		_eddba, _badg := d.Token()
		if _badg != nil {
			return _badg
		}
		switch _ffeafe := _eddba.(type) {
		case _b.StartElement:
			switch _ffeafe.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_bdae := NewEG_ShapeElements()
				_bdae.Path = NewPath()
				if _egaec := d.DecodeElement(_bdae.Path, &_ffeafe); _egaec != nil {
					return _egaec
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _bdae)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_bdef := NewEG_ShapeElements()
				_bdef.Formulas = NewFormulas()
				if _ffdea := d.DecodeElement(_bdef.Formulas, &_ffeafe); _ffdea != nil {
					return _ffdea
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _bdef)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_ebgbd := NewEG_ShapeElements()
				_ebgbd.Handles = NewHandles()
				if _ggdbd := d.DecodeElement(_ebgbd.Handles, &_ffeafe); _ggdbd != nil {
					return _ggdbd
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _ebgbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_bfgf := NewEG_ShapeElements()
				_bfgf.Fill = NewFill()
				if _egffe := d.DecodeElement(_bfgf.Fill, &_ffeafe); _egffe != nil {
					return _egffe
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _bfgf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_dbeb := NewEG_ShapeElements()
				_dbeb.Stroke = NewStroke()
				if _gfeeb := d.DecodeElement(_dbeb.Stroke, &_ffeafe); _gfeeb != nil {
					return _gfeeb
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _dbeb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_faab := NewEG_ShapeElements()
				_faab.Shadow = NewShadow()
				if _ceag := d.DecodeElement(_faab.Shadow, &_ffeafe); _ceag != nil {
					return _ceag
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _faab)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_dcgbf := NewEG_ShapeElements()
				_dcgbf.Textbox = NewTextbox()
				if _eeebb := d.DecodeElement(_dcgbf.Textbox, &_ffeafe); _eeebb != nil {
					return _eeebb
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _dcgbf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_cgbee := NewEG_ShapeElements()
				_cgbee.Textpath = NewTextpath()
				if _cffge := d.DecodeElement(_cgbee.Textpath, &_ffeafe); _cffge != nil {
					return _cffge
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _cgbee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_gcbf := NewEG_ShapeElements()
				_gcbf.Imagedata = NewImagedata()
				if _fbabf := d.DecodeElement(_gcbf.Imagedata, &_ffeafe); _fbabf != nil {
					return _fbabf
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _gcbf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_affe := NewEG_ShapeElements()
				_affe.Skew = NewOfcSkew()
				if _daafc := d.DecodeElement(_affe.Skew, &_ffeafe); _daafc != nil {
					return _daafc
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _affe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_dfca := NewEG_ShapeElements()
				_dfca.Extrusion = NewOfcExtrusion()
				if _bdggb := d.DecodeElement(_dfca.Extrusion, &_ffeafe); _bdggb != nil {
					return _bdggb
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _dfca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_efaac := NewEG_ShapeElements()
				_efaac.Callout = NewOfcCallout()
				if _fagdd := d.DecodeElement(_efaac.Callout, &_ffeafe); _fagdd != nil {
					return _fagdd
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _efaac)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_bccaa := NewEG_ShapeElements()
				_bccaa.Lock = NewOfcLock()
				if _agbac := d.DecodeElement(_bccaa.Lock, &_ffeafe); _agbac != nil {
					return _agbac
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _bccaa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_ebdbb := NewEG_ShapeElements()
				_ebdbb.Clippath = NewOfcClippath()
				if _gcge := d.DecodeElement(_ebdbb.Clippath, &_ffeafe); _gcge != nil {
					return _gcge
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _ebdbb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_degg := NewEG_ShapeElements()
				_degg.Signatureline = NewOfcSignatureline()
				if _gggbb := d.DecodeElement(_degg.Signatureline, &_ffeafe); _gggbb != nil {
					return _gggbb
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _degg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_dfdg := NewEG_ShapeElements()
				_dfdg.Wrap = _a.NewWrap()
				if _degb := d.DecodeElement(_dfdg.Wrap, &_ffeafe); _degb != nil {
					return _degb
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _dfdg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_dbbdf := NewEG_ShapeElements()
				_dbbdf.Anchorlock = _a.NewAnchorlock()
				if _eaec := d.DecodeElement(_dbbdf.Anchorlock, &_ffeafe); _eaec != nil {
					return _eaec
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _dbbdf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_cbdg := NewEG_ShapeElements()
				_cbdg.Bordertop = _a.NewBordertop()
				if _fbaef := d.DecodeElement(_cbdg.Bordertop, &_ffeafe); _fbaef != nil {
					return _fbaef
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _cbdg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_aefa := NewEG_ShapeElements()
				_aefa.Borderbottom = _a.NewBorderbottom()
				if _dcfb := d.DecodeElement(_aefa.Borderbottom, &_ffeafe); _dcfb != nil {
					return _dcfb
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _aefa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_eabfd := NewEG_ShapeElements()
				_eabfd.Borderleft = _a.NewBorderleft()
				if _dgagd := d.DecodeElement(_eabfd.Borderleft, &_ffeafe); _dgagd != nil {
					return _dgagd
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _eabfd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_acadag := NewEG_ShapeElements()
				_acadag.Borderright = _a.NewBorderright()
				if _dgcf := d.DecodeElement(_acadag.Borderright, &_ffeafe); _dgcf != nil {
					return _dgcf
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _acadag)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_gdfa := NewEG_ShapeElements()
				_gdfa.ClientData = _c.NewClientData()
				if _bgbdb := d.DecodeElement(_gdfa.ClientData, &_ffeafe); _bgbdb != nil {
					return _bgbdb
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _gdfa)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_gfffd := NewEG_ShapeElements()
				_gfffd.Textdata = _bf.NewTextdata()
				if _gffa := d.DecodeElement(_gfffd.Textdata, &_ffeafe); _gffa != nil {
					return _gffa
				}
				_adbbe.EG_ShapeElements = append(_adbbe.EG_ShapeElements, _gfffd)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Rect\u0020\u0025v", _ffeafe.Name)
				if _dgaga := d.Skip(); _dgaga != nil {
					return _dgaga
				}
			}
		case _b.EndElement:
			break _edbe
		case _b.CharData:
		}
	}
	return nil
}

type OfcCT_Extrusion struct {
	OnAttr                 _eb.ST_TrueFalse
	TypeAttr               OfcST_ExtrusionType
	RenderAttr             OfcST_ExtrusionRender
	ViewpointoriginAttr    *string
	ViewpointAttr          *string
	PlaneAttr              OfcST_ExtrusionPlane
	SkewangleAttr          *float32
	SkewamtAttr            *string
	ForedepthAttr          *string
	BackdepthAttr          *string
	OrientationAttr        *string
	OrientationangleAttr   *float32
	LockrotationcenterAttr _eb.ST_TrueFalse
	AutorotationcenterAttr _eb.ST_TrueFalse
	RotationcenterAttr     *string
	RotationangleAttr      *string
	ColormodeAttr          OfcST_ColorMode
	ColorAttr              *string
	ShininessAttr          *float32
	SpecularityAttr        *string
	DiffusityAttr          *string
	MetalAttr              _eb.ST_TrueFalse
	EdgeAttr               *string
	FacetAttr              *string
	LightfaceAttr          _eb.ST_TrueFalse
	BrightnessAttr         *string
	LightpositionAttr      *string
	LightlevelAttr         *string
	LightharshAttr         _eb.ST_TrueFalse
	Lightposition2Attr     *string
	Lightlevel2Attr        *string
	Lightharsh2Attr        _eb.ST_TrueFalse
	ExtAttr                ST_Ext
}

func (_ffaeb *OfcCT_ColorMru) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ffaeb.ColorsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "colors"}, Value: _f.Sprintf("\u0025v", *_ffaeb.ColorsAttr)})
	}
	if _ffaeb.ExtAttr != ST_ExtUnset {
		_dcege, _fcgdc := _ffaeb.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _fcgdc != nil {
			return _fcgdc
		}
		start.Attr = append(start.Attr, _dcege)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the Handles and its children
func (_cabgag *Handles) Validate() error { return _cabgag.ValidateWithPath("Handles") }

type CT_ImageData struct {
	EmbosscolorAttr      *string
	RecolortargetAttr    *string
	HrefAttr             *string
	AlthrefAttr          *string
	TitleAttr            *string
	OleidAttr            *float32
	DetectmouseclickAttr _eb.ST_TrueFalse
	MovieAttr            *float32
	RelidAttr            *string
	IdAttr               *string
	PictAttr             *string
	RHrefAttr            *string
	SIdAttr              *string
	SrcAttr              *string
	CropleftAttr         *string
	CroptopAttr          *string
	CroprightAttr        *string
	CropbottomAttr       *string
	GainAttr             *string
	BlacklevelAttr       *string
	GammaAttr            *string
	GrayscaleAttr        _eb.ST_TrueFalse
	BilevelAttr          _eb.ST_TrueFalse
	ChromakeyAttr        *string
}

// Validate validates the Roundrect and its children
func (_dedc *Roundrect) Validate() error { return _dedc.ValidateWithPath("Roundrect") }

const (
	ST_StrokeEndCapUnset  ST_StrokeEndCap = 0
	ST_StrokeEndCapFlat   ST_StrokeEndCap = 1
	ST_StrokeEndCapSquare ST_StrokeEndCap = 2
	ST_StrokeEndCapRound  ST_StrokeEndCap = 3
)

func (_agadg *CT_TextPath) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _agadg.OnAttr != _eb.ST_TrueFalseUnset {
		_bccb, _gdbgd := _agadg.OnAttr.MarshalXMLAttr(_b.Name{Local: "on"})
		if _gdbgd != nil {
			return _gdbgd
		}
		start.Attr = append(start.Attr, _bccb)
	}
	if _agadg.FitshapeAttr != _eb.ST_TrueFalseUnset {
		_addae, _dfea := _agadg.FitshapeAttr.MarshalXMLAttr(_b.Name{Local: "fitshape"})
		if _dfea != nil {
			return _dfea
		}
		start.Attr = append(start.Attr, _addae)
	}
	if _agadg.FitpathAttr != _eb.ST_TrueFalseUnset {
		_fcbed, _fgcc := _agadg.FitpathAttr.MarshalXMLAttr(_b.Name{Local: "fitpath"})
		if _fgcc != nil {
			return _fgcc
		}
		start.Attr = append(start.Attr, _fcbed)
	}
	if _agadg.TrimAttr != _eb.ST_TrueFalseUnset {
		_effgfg, _gcbagf := _agadg.TrimAttr.MarshalXMLAttr(_b.Name{Local: "trim"})
		if _gcbagf != nil {
			return _gcbagf
		}
		start.Attr = append(start.Attr, _effgfg)
	}
	if _agadg.XscaleAttr != _eb.ST_TrueFalseUnset {
		_fdbea, _fdced := _agadg.XscaleAttr.MarshalXMLAttr(_b.Name{Local: "xscale"})
		if _fdced != nil {
			return _fdced
		}
		start.Attr = append(start.Attr, _fdbea)
	}
	if _agadg.StringAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "string"}, Value: _f.Sprintf("\u0025v", *_agadg.StringAttr)})
	}
	if _agadg.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_agadg.IdAttr)})
	}
	if _agadg.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_agadg.StyleAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type AG_Path struct{ PathAttr *string }

func (_fgbcfg ST_EditAs) String() string {
	switch _fgbcfg {
	case 0:
		return ""
	case 1:
		return "canvas"
	case 2:
		return "orgchart"
	case 3:
		return "radial"
	case 4:
		return "cycle"
	case 5:
		return "stacked"
	case 6:
		return "venn"
	case 7:
		return "bullseye"
	}
	return ""
}

// Validate validates the CT_Image and its children
func (_ccfdc *CT_Image) Validate() error { return _ccfdc.ValidateWithPath("CT_Image") }

type OfcST_OLEDrawAspect byte

func (_ccaa ST_Ext) Validate() error { return _ccaa.ValidateWithPath("") }

// Validate validates the Stroke and its children
func (_fecbg *Stroke) Validate() error { return _fecbg.ValidateWithPath("Stroke") }

type OfcComplex struct{ OfcCT_Complex }

// ValidateWithPath validates the CT_TextPath and its children, prefixing error messages with path
func (_aafc *CT_TextPath) ValidateWithPath(path string) error {
	if _gacge := _aafc.OnAttr.ValidateWithPath(path + "\u002fOnAttr"); _gacge != nil {
		return _gacge
	}
	if _accdc := _aafc.FitshapeAttr.ValidateWithPath(path + "\u002fFitshapeAttr"); _accdc != nil {
		return _accdc
	}
	if _fdbge := _aafc.FitpathAttr.ValidateWithPath(path + "\u002fFitpathAttr"); _fdbge != nil {
		return _fdbge
	}
	if _bcggb := _aafc.TrimAttr.ValidateWithPath(path + "\u002fTrimAttr"); _bcggb != nil {
		return _bcggb
	}
	if _gdgca := _aafc.XscaleAttr.ValidateWithPath(path + "/XscaleAttr"); _gdgca != nil {
		return _gdgca
	}
	return nil
}

// ValidateWithPath validates the OfcCT_Rules and its children, prefixing error messages with path
func (_bgeae *OfcCT_Rules) ValidateWithPath(path string) error {
	for _cedcd, _gagddd := range _bgeae.R {
		if _beece := _gagddd.ValidateWithPath(_f.Sprintf("\u0025s\u002fR\u005b\u0025d\u005d", path, _cedcd)); _beece != nil {
			return _beece
		}
	}
	if _cacbad := _bgeae.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _cacbad != nil {
		return _cacbad
	}
	return nil
}

// ValidateWithPath validates the CT_ImageData and its children, prefixing error messages with path
func (_gfec *CT_ImageData) ValidateWithPath(path string) error {
	if _egfg := _gfec.DetectmouseclickAttr.ValidateWithPath(path + "/DetectmouseclickAttr"); _egfg != nil {
		return _egfg
	}
	if _daffe := _gfec.GrayscaleAttr.ValidateWithPath(path + "\u002fGrayscaleAttr"); _daffe != nil {
		return _daffe
	}
	if _cfcab := _gfec.BilevelAttr.ValidateWithPath(path + "\u002fBilevelAttr"); _cfcab != nil {
		return _cfcab
	}
	return nil
}

type CT_Stroke struct {
	Left                 *OfcLeft
	Top                  *OfcTop
	Right                *OfcRight
	Bottom               *OfcBottom
	Column               *OfcColumn
	IdAttr               *string
	OnAttr               _eb.ST_TrueFalse
	WeightAttr           *string
	ColorAttr            *string
	OpacityAttr          *string
	LinestyleAttr        ST_StrokeLineStyle
	MiterlimitAttr       *float64
	JoinstyleAttr        ST_StrokeJoinStyle
	EndcapAttr           ST_StrokeEndCap
	DashstyleAttr        *string
	FilltypeAttr         ST_FillType
	SrcAttr              *string
	ImageaspectAttr      ST_ImageAspect
	ImagesizeAttr        *string
	ImagealignshapeAttr  _eb.ST_TrueFalse
	Color2Attr           *string
	StartarrowAttr       ST_StrokeArrowType
	StartarrowwidthAttr  ST_StrokeArrowWidth
	StartarrowlengthAttr ST_StrokeArrowLength
	EndarrowAttr         ST_StrokeArrowType
	EndarrowwidthAttr    ST_StrokeArrowWidth
	EndarrowlengthAttr   ST_StrokeArrowLength
	HrefAttr             *string
	AlthrefAttr          *string
	TitleAttr            *string
	ForcedashAttr        _eb.ST_TrueFalse
	RIdAttr              *string
	InsetpenAttr         _eb.ST_TrueFalse
	RelidAttr            *string
}

// Validate validates the CT_Path and its children
func (_fced *CT_Path) Validate() error { return _fced.ValidateWithPath("CT_Path") }
func (_cfcaa *OfcOLEObject) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cfcaa.OfcCT_OLEObject = *NewOfcCT_OLEObject()
	for _, _dgggb := range start.Attr {
		if _dgggb.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _dgggb.Name.Local == "id" || _dgggb.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _dgggb.Name.Local == "id" {
			_acbd, _fbcca := _dgggb.Value, error(nil)
			if _fbcca != nil {
				return _fbcca
			}
			_cfcaa.IdAttr = &_acbd
			continue
		}
		if _dgggb.Name.Local == "Type" {
			_cfcaa.TypeAttr.UnmarshalXMLAttr(_dgggb)
			continue
		}
		if _dgggb.Name.Local == "ProgID" {
			_eadbe, _acgad := _dgggb.Value, error(nil)
			if _acgad != nil {
				return _acgad
			}
			_cfcaa.ProgIDAttr = &_eadbe
			continue
		}
		if _dgggb.Name.Local == "ShapeID" {
			_edcg, _dcgga := _dgggb.Value, error(nil)
			if _dcgga != nil {
				return _dcgga
			}
			_cfcaa.ShapeIDAttr = &_edcg
			continue
		}
		if _dgggb.Name.Local == "DrawAspect" {
			_cfcaa.DrawAspectAttr.UnmarshalXMLAttr(_dgggb)
			continue
		}
		if _dgggb.Name.Local == "ObjectID" {
			_cagff, _fffaf := _dgggb.Value, error(nil)
			if _fffaf != nil {
				return _fffaf
			}
			_cfcaa.ObjectIDAttr = &_cagff
			continue
		}
		if _dgggb.Name.Local == "UpdateMode" {
			_cfcaa.UpdateModeAttr.UnmarshalXMLAttr(_dgggb)
			continue
		}
	}
_fbaf:
	for {
		_aade, _aaddaf := d.Token()
		if _aaddaf != nil {
			return _aaddaf
		}
		switch _aaeaf := _aade.(type) {
		case _b.StartElement:
			switch _aaeaf.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "LinkType"}:
				_cfcaa.LinkType = new(string)
				if _gegbc := d.DecodeElement(_cfcaa.LinkType, &_aaeaf); _gegbc != nil {
					return _gegbc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "LockedField"}:
				_cfcaa.LockedField = _eb.ST_TrueFalseBlankUnset
				if _efgaf := d.DecodeElement(&_cfcaa.LockedField, &_aaeaf); _efgaf != nil {
					return _efgaf
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "FieldCodes"}:
				_cfcaa.FieldCodes = new(string)
				if _degbg := d.DecodeElement(_cfcaa.FieldCodes, &_aaeaf); _degbg != nil {
					return _degbg
				}
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020OfcOLEObject\u0020\u0025v", _aaeaf.Name)
				if _gdabe := d.Skip(); _gdabe != nil {
					return _gdabe
				}
			}
		case _b.EndElement:
			break _fbaf
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the OfcCT_RegroupTable and its children, prefixing error messages with path
func (_befd *OfcCT_RegroupTable) ValidateWithPath(path string) error {
	for _fgcf, _afaedb := range _befd.Entry {
		if _fggeg := _afaedb.ValidateWithPath(_f.Sprintf("\u0025s\u002fEntry\u005b\u0025d\u005d", path, _fgcf)); _fggeg != nil {
			return _fggeg
		}
	}
	if _bdafg := _befd.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _bdafg != nil {
		return _bdafg
	}
	return nil
}
func (_fabfdg *OfcST_FillType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_adgac, _egaff := d.Token()
	if _egaff != nil {
		return _egaff
	}
	if _bdfbed, _ffdfca := _adgac.(_b.EndElement); _ffdfca && _bdfbed.Name == start.Name {
		*_fabfdg = 1
		return nil
	}
	if _ffba, _adgbd := _adgac.(_b.CharData); !_adgbd {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _adgac)
	} else {
		switch string(_ffba) {
		case "":
			*_fabfdg = 0
		case "gradientCenter":
			*_fabfdg = 1
		case "solid":
			*_fabfdg = 2
		case "pattern":
			*_fabfdg = 3
		case "tile":
			*_fabfdg = 4
		case "frame":
			*_fabfdg = 5
		case "gradientUnscaled":
			*_fabfdg = 6
		case "gradientRadial":
			*_fabfdg = 7
		case "gradient":
			*_fabfdg = 8
		case "background":
			*_fabfdg = 9
		}
	}
	_adgac, _egaff = d.Token()
	if _egaff != nil {
		return _egaff
	}
	if _cdfbc, _agcead := _adgac.(_b.EndElement); _agcead && _cdfbc.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _adgac)
}
func (_baeb *CT_Line) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bdbgg := range start.Attr {
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "userdrawn" {
			_baeb.UserdrawnAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "button" {
			_baeb.ButtonAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "dgmlayoutmru" {
			_baeb.DgmlayoutmruAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "userhidden" {
			_baeb.UserhiddenAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "cliptowrap" {
			_baeb.CliptowrapAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "bullet" {
			_baeb.BulletAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "ole" {
			_baeb.OleAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "hr" {
			_baeb.HrAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "spid" {
			_fbfa, _fefab := _bdbgg.Value, error(nil)
			if _fefab != nil {
				return _fefab
			}
			_baeb.SpidAttr = &_fbfa
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "hrstd" {
			_baeb.HrstdAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "bwnormal" {
			_baeb.BwnormalAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "bordertopcolor" {
			_gdff, _dbce := _bdbgg.Value, error(nil)
			if _dbce != nil {
				return _dbce
			}
			_baeb.BordertopcolorAttr = &_gdff
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "dgmlayout" {
			_baeb.DgmlayoutAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "forcedash" {
			_baeb.ForcedashAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "allowoverlap" {
			_baeb.AllowoverlapAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "hrnoshade" {
			_baeb.HrnoshadeAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "preferrelative" {
			_baeb.PreferrelativeAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "borderbottomcolor" {
			_bfdca, _gbec := _bdbgg.Value, error(nil)
			if _gbec != nil {
				return _gbec
			}
			_baeb.BorderbottomcolorAttr = &_bfdca
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "oned" {
			_baeb.OnedAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "dgmnodekind" {
			_gbaae, _gffdd := _e.ParseInt(_bdbgg.Value, 10, 64)
			if _gffdd != nil {
				return _gffdd
			}
			_baeb.DgmnodekindAttr = &_gbaae
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "regroupid" {
			_eabed, _bbade := _e.ParseInt(_bdbgg.Value, 10, 64)
			if _bbade != nil {
				return _bbade
			}
			_baeb.RegroupidAttr = &_eabed
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "allowincell" {
			_baeb.AllowincellAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "hrpct" {
			_gddag, _eddgg := _e.ParseFloat(_bdbgg.Value, 64)
			if _eddgg != nil {
				return _eddgg
			}
			_aeefa := float32(_gddag)
			_baeb.HrpctAttr = &_aeefa
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "clip" {
			_baeb.ClipAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "insetmode" {
			_baeb.InsetmodeAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "borderleftcolor" {
			_dbfgc, _baaa := _bdbgg.Value, error(nil)
			if _baaa != nil {
				return _baaa
			}
			_baeb.BorderleftcolorAttr = &_dbfgc
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "oleicon" {
			_baeb.OleiconAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "borderrightcolor" {
			_cace, _gcaee := _bdbgg.Value, error(nil)
			if _gcaee != nil {
				return _gcaee
			}
			_baeb.BorderrightcolorAttr = &_cace
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "connectortype" {
			_baeb.ConnectortypeAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "bwpure" {
			_baeb.BwpureAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "bwmode" {
			_baeb.BwmodeAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "spt" {
			_egcfb, _bbaa := _e.ParseFloat(_bdbgg.Value, 64)
			if _bbaa != nil {
				return _bbaa
			}
			_dbcfe := float32(_egcfb)
			_baeb.SptAttr = &_dbcfe
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "doubleclicknotify" {
			_baeb.DoubleclicknotifyAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdbgg.Name.Local == "hralign" {
			_baeb.HralignAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Local == "to" {
			_fdcc, _agea := _bdbgg.Value, error(nil)
			if _agea != nil {
				return _agea
			}
			_baeb.ToAttr = &_fdcc
			continue
		}
		if _bdbgg.Name.Local == "id" {
			_accaa, _bdcc := _bdbgg.Value, error(nil)
			if _bdcc != nil {
				return _bdcc
			}
			_baeb.IdAttr = &_accaa
			continue
		}
		if _bdbgg.Name.Local == "alt" {
			_ceca, _ggfdg := _bdbgg.Value, error(nil)
			if _ggfdg != nil {
				return _ggfdg
			}
			_baeb.AltAttr = &_ceca
			continue
		}
		if _bdbgg.Name.Local == "print" {
			_baeb.PrintAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Local == "stroked" {
			_baeb.StrokedAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Local == "wrapcoords" {
			_fefef, _cebg := _bdbgg.Value, error(nil)
			if _cebg != nil {
				return _cebg
			}
			_baeb.WrapcoordsAttr = &_fefef
			continue
		}
		if _bdbgg.Name.Local == "strokeweight" {
			_cefed, _abad := _bdbgg.Value, error(nil)
			if _abad != nil {
				return _abad
			}
			_baeb.StrokeweightAttr = &_cefed
			continue
		}
		if _bdbgg.Name.Local == "coordorigin" {
			_fbedc, _fgfaf := _bdbgg.Value, error(nil)
			if _fgfaf != nil {
				return _fgfaf
			}
			_baeb.CoordoriginAttr = &_fbedc
			continue
		}
		if _bdbgg.Name.Local == "chromakey" {
			_cafbd, _acbbc := _bdbgg.Value, error(nil)
			if _acbbc != nil {
				return _acbbc
			}
			_baeb.ChromakeyAttr = &_cafbd
			continue
		}
		if _bdbgg.Name.Local == "fillcolor" {
			_cfabd, _becg := _bdbgg.Value, error(nil)
			if _becg != nil {
				return _becg
			}
			_baeb.FillcolorAttr = &_cfabd
			continue
		}
		if _bdbgg.Name.Local == "style" {
			_gggf, _ecaeea := _bdbgg.Value, error(nil)
			if _ecaeea != nil {
				return _ecaeea
			}
			_baeb.StyleAttr = &_gggf
			continue
		}
		if _bdbgg.Name.Local == "opacity" {
			_gdcg, _ebeba := _bdbgg.Value, error(nil)
			if _ebeba != nil {
				return _ebeba
			}
			_baeb.OpacityAttr = &_gdcg
			continue
		}
		if _bdbgg.Name.Local == "strokecolor" {
			_dgeb, _aabb := _bdbgg.Value, error(nil)
			if _aabb != nil {
				return _aabb
			}
			_baeb.StrokecolorAttr = &_dgeb
			continue
		}
		if _bdbgg.Name.Local == "insetpen" {
			_baeb.InsetpenAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
		if _bdbgg.Name.Local == "from" {
			_gegc, _cgegb := _bdbgg.Value, error(nil)
			if _cgegb != nil {
				return _cgegb
			}
			_baeb.FromAttr = &_gegc
			continue
		}
		if _bdbgg.Name.Local == "coordsize" {
			_cgefc, _cdeg := _bdbgg.Value, error(nil)
			if _cdeg != nil {
				return _cdeg
			}
			_baeb.CoordsizeAttr = &_cgefc
			continue
		}
		if _bdbgg.Name.Local == "title" {
			_bbeb, _dbgb := _bdbgg.Value, error(nil)
			if _dbgb != nil {
				return _dbgb
			}
			_baeb.TitleAttr = &_bbeb
			continue
		}
		if _bdbgg.Name.Local == "class" {
			_eegd, _cddfc := _bdbgg.Value, error(nil)
			if _cddfc != nil {
				return _cddfc
			}
			_baeb.ClassAttr = &_eegd
			continue
		}
		if _bdbgg.Name.Local == "target" {
			_cefa, _cdfd := _bdbgg.Value, error(nil)
			if _cdfd != nil {
				return _cdfd
			}
			_baeb.TargetAttr = &_cefa
			continue
		}
		if _bdbgg.Name.Local == "href" {
			_bbagb, _dcffe := _bdbgg.Value, error(nil)
			if _dcffe != nil {
				return _dcffe
			}
			_baeb.HrefAttr = &_bbagb
			continue
		}
		if _bdbgg.Name.Local == "filled" {
			_baeb.FilledAttr.UnmarshalXMLAttr(_bdbgg)
			continue
		}
	}
_cecbe:
	for {
		_fdec, _dgbed := d.Token()
		if _dgbed != nil {
			return _dgbed
		}
		switch _agead := _fdec.(type) {
		case _b.StartElement:
			switch _agead.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_gfbee := NewEG_ShapeElements()
				_gfbee.Path = NewPath()
				if _ebeab := d.DecodeElement(_gfbee.Path, &_agead); _ebeab != nil {
					return _ebeab
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _gfbee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_cged := NewEG_ShapeElements()
				_cged.Formulas = NewFormulas()
				if _aeefd := d.DecodeElement(_cged.Formulas, &_agead); _aeefd != nil {
					return _aeefd
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _cged)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_ggeg := NewEG_ShapeElements()
				_ggeg.Handles = NewHandles()
				if _deaba := d.DecodeElement(_ggeg.Handles, &_agead); _deaba != nil {
					return _deaba
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _ggeg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_efdg := NewEG_ShapeElements()
				_efdg.Fill = NewFill()
				if _bbage := d.DecodeElement(_efdg.Fill, &_agead); _bbage != nil {
					return _bbage
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _efdg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_gcbc := NewEG_ShapeElements()
				_gcbc.Stroke = NewStroke()
				if _dbda := d.DecodeElement(_gcbc.Stroke, &_agead); _dbda != nil {
					return _dbda
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _gcbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_bfdg := NewEG_ShapeElements()
				_bfdg.Shadow = NewShadow()
				if _deabg := d.DecodeElement(_bfdg.Shadow, &_agead); _deabg != nil {
					return _deabg
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _bfdg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_aedd := NewEG_ShapeElements()
				_aedd.Textbox = NewTextbox()
				if _agbb := d.DecodeElement(_aedd.Textbox, &_agead); _agbb != nil {
					return _agbb
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _aedd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_ebgcf := NewEG_ShapeElements()
				_ebgcf.Textpath = NewTextpath()
				if _efga := d.DecodeElement(_ebgcf.Textpath, &_agead); _efga != nil {
					return _efga
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _ebgcf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_gbbe := NewEG_ShapeElements()
				_gbbe.Imagedata = NewImagedata()
				if _ecbba := d.DecodeElement(_gbbe.Imagedata, &_agead); _ecbba != nil {
					return _ecbba
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _gbbe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_fadfd := NewEG_ShapeElements()
				_fadfd.Skew = NewOfcSkew()
				if _ebgec := d.DecodeElement(_fadfd.Skew, &_agead); _ebgec != nil {
					return _ebgec
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _fadfd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_bbgd := NewEG_ShapeElements()
				_bbgd.Extrusion = NewOfcExtrusion()
				if _gfbf := d.DecodeElement(_bbgd.Extrusion, &_agead); _gfbf != nil {
					return _gfbf
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _bbgd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_bfgge := NewEG_ShapeElements()
				_bfgge.Callout = NewOfcCallout()
				if _cbgg := d.DecodeElement(_bfgge.Callout, &_agead); _cbgg != nil {
					return _cbgg
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _bfgge)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_ebba := NewEG_ShapeElements()
				_ebba.Lock = NewOfcLock()
				if _dcbe := d.DecodeElement(_ebba.Lock, &_agead); _dcbe != nil {
					return _dcbe
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _ebba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_ddagc := NewEG_ShapeElements()
				_ddagc.Clippath = NewOfcClippath()
				if _cdecc := d.DecodeElement(_ddagc.Clippath, &_agead); _cdecc != nil {
					return _cdecc
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _ddagc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_aag := NewEG_ShapeElements()
				_aag.Signatureline = NewOfcSignatureline()
				if _caabb := d.DecodeElement(_aag.Signatureline, &_agead); _caabb != nil {
					return _caabb
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _aag)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_effbc := NewEG_ShapeElements()
				_effbc.Wrap = _a.NewWrap()
				if _fbea := d.DecodeElement(_effbc.Wrap, &_agead); _fbea != nil {
					return _fbea
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _effbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_bcaa := NewEG_ShapeElements()
				_bcaa.Anchorlock = _a.NewAnchorlock()
				if _afda := d.DecodeElement(_bcaa.Anchorlock, &_agead); _afda != nil {
					return _afda
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _bcaa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_dbac := NewEG_ShapeElements()
				_dbac.Bordertop = _a.NewBordertop()
				if _bfeda := d.DecodeElement(_dbac.Bordertop, &_agead); _bfeda != nil {
					return _bfeda
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _dbac)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_bffdc := NewEG_ShapeElements()
				_bffdc.Borderbottom = _a.NewBorderbottom()
				if _gdccc := d.DecodeElement(_bffdc.Borderbottom, &_agead); _gdccc != nil {
					return _gdccc
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _bffdc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_gdcba := NewEG_ShapeElements()
				_gdcba.Borderleft = _a.NewBorderleft()
				if _ebbb := d.DecodeElement(_gdcba.Borderleft, &_agead); _ebbb != nil {
					return _ebbb
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _gdcba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_ecdf := NewEG_ShapeElements()
				_ecdf.Borderright = _a.NewBorderright()
				if _bcca := d.DecodeElement(_ecdf.Borderright, &_agead); _bcca != nil {
					return _bcca
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _ecdf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_aacf := NewEG_ShapeElements()
				_aacf.ClientData = _c.NewClientData()
				if _cfeaa := d.DecodeElement(_aacf.ClientData, &_agead); _cfeaa != nil {
					return _cfeaa
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _aacf)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_ecfae := NewEG_ShapeElements()
				_ecfae.Textdata = _bf.NewTextdata()
				if _fbbeb := d.DecodeElement(_ecfae.Textdata, &_agead); _fbbeb != nil {
					return _fbbeb
				}
				_baeb.EG_ShapeElements = append(_baeb.EG_ShapeElements, _ecfae)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Line\u0020\u0025v", _agead.Name)
				if _gagac := d.Skip(); _gagac != nil {
					return _gagac
				}
			}
		case _b.EndElement:
			break _cecbe
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the AG_Path and its children, prefixing error messages with path
func (_fca *AG_Path) ValidateWithPath(path string) error { return nil }

const (
	ST_FillMethodUnset       ST_FillMethod = 0
	ST_FillMethodNone        ST_FillMethod = 1
	ST_FillMethodLinear      ST_FillMethod = 2
	ST_FillMethodSigma       ST_FillMethod = 3
	ST_FillMethodAny         ST_FillMethod = 4
	ST_FillMethodLinearSigma ST_FillMethod = 5
)

// Validate validates the CT_Group and its children
func (_aabfd *CT_Group) Validate() error { return _aabfd.ValidateWithPath("CT_Group") }
func (_fadfdb ST_StrokeArrowWidth) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_fadfdb.String(), start)
}

// Validate validates the CT_Shape and its children
func (_fbbgf *CT_Shape) Validate() error { return _fbbgf.ValidateWithPath("CT_Shape") }
func NewPath() *Path                     { _dgebd := &Path{}; _dgebd.CT_Path = *NewCT_Path(); return _dgebd }

// Validate validates the OfcBottom and its children
func (_ggfaf *OfcBottom) Validate() error { return _ggfaf.ValidateWithPath("OfcBottom") }
func (_cc *AG_Adj) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bd := range start.Attr {
		if _bd.Name.Local == "adj" {
			_ab, _dg := _bd.Value, error(nil)
			if _dg != nil {
				return _dg
			}
			_cc.AdjAttr = &_ab
			continue
		}
	}
	for {
		_bc, _bb := d.Token()
		if _bb != nil {
			return _f.Errorf("parsing\u0020AG_Adj:\u0020\u0025s", _bb)
		}
		if _af, _ge := _bc.(_b.EndElement); _ge && _af.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cgbadb *OfcST_CalloutPlacement) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dbbfd, _ecagc := d.Token()
	if _ecagc != nil {
		return _ecagc
	}
	if _gfcbae, _ffcbg := _dbbfd.(_b.EndElement); _ffcbg && _gfcbae.Name == start.Name {
		*_cgbadb = 1
		return nil
	}
	if _gbaabe, _fgbeec := _dbbfd.(_b.CharData); !_fgbeec {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dbbfd)
	} else {
		switch string(_gbaabe) {
		case "":
			*_cgbadb = 0
		case "top":
			*_cgbadb = 1
		case "center":
			*_cgbadb = 2
		case "bottom":
			*_cgbadb = 3
		case "user":
			*_cgbadb = 4
		}
	}
	_dbbfd, _ecagc = d.Token()
	if _ecagc != nil {
		return _ecagc
	}
	if _bgcfa, _agfc := _dbbfd.(_b.EndElement); _agfc && _bgcfa.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dbbfd)
}
func (_fgfdge *OfcExtrusion) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fgfdge.OfcCT_Extrusion = *NewOfcCT_Extrusion()
	for _, _fedfb := range start.Attr {
		if _fedfb.Name.Local == "colormode" {
			_fgfdge.ColormodeAttr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "color" {
			_cbfdb, _ecag := _fedfb.Value, error(nil)
			if _ecag != nil {
				return _ecag
			}
			_fgfdge.ColorAttr = &_cbfdb
			continue
		}
		if _fedfb.Name.Local == "type" {
			_fgfdge.TypeAttr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "shininess" {
			_cffcd, _fbgcbf := _e.ParseFloat(_fedfb.Value, 64)
			if _fbgcbf != nil {
				return _fbgcbf
			}
			_fdeddg := float32(_cffcd)
			_fgfdge.ShininessAttr = &_fdeddg
			continue
		}
		if _fedfb.Name.Local == "viewpointorigin" {
			_febdd, _acdbb := _fedfb.Value, error(nil)
			if _acdbb != nil {
				return _acdbb
			}
			_fgfdge.ViewpointoriginAttr = &_febdd
			continue
		}
		if _fedfb.Name.Local == "specularity" {
			_dbcbf, _ggbe := _fedfb.Value, error(nil)
			if _ggbe != nil {
				return _ggbe
			}
			_fgfdge.SpecularityAttr = &_dbcbf
			continue
		}
		if _fedfb.Name.Local == "plane" {
			_fgfdge.PlaneAttr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "diffusity" {
			_gggcf, _bfbcd := _fedfb.Value, error(nil)
			if _bfbcd != nil {
				return _bfbcd
			}
			_fgfdge.DiffusityAttr = &_gggcf
			continue
		}
		if _fedfb.Name.Local == "skewamt" {
			_ddcac, _acffff := _fedfb.Value, error(nil)
			if _acffff != nil {
				return _acffff
			}
			_fgfdge.SkewamtAttr = &_ddcac
			continue
		}
		if _fedfb.Name.Local == "metal" {
			_fgfdge.MetalAttr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "backdepth" {
			_dgcac, _ggebab := _fedfb.Value, error(nil)
			if _ggebab != nil {
				return _ggebab
			}
			_fgfdge.BackdepthAttr = &_dgcac
			continue
		}
		if _fedfb.Name.Local == "edge" {
			_abgac, _acbbf := _fedfb.Value, error(nil)
			if _acbbf != nil {
				return _acbbf
			}
			_fgfdge.EdgeAttr = &_abgac
			continue
		}
		if _fedfb.Name.Local == "lightlevel2" {
			_eadca, _ecea := _fedfb.Value, error(nil)
			if _ecea != nil {
				return _ecea
			}
			_fgfdge.Lightlevel2Attr = &_eadca
			continue
		}
		if _fedfb.Name.Local == "orientationangle" {
			_ffafc, _afdeb := _e.ParseFloat(_fedfb.Value, 64)
			if _afdeb != nil {
				return _afdeb
			}
			_dbggb := float32(_ffafc)
			_fgfdge.OrientationangleAttr = &_dbggb
			continue
		}
		if _fedfb.Name.Local == "on" {
			_fgfdge.OnAttr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "lightharsh" {
			_fgfdge.LightharshAttr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "lightface" {
			_fgfdge.LightfaceAttr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "foredepth" {
			_fgadc, _eebdc := _fedfb.Value, error(nil)
			if _eebdc != nil {
				return _eebdc
			}
			_fgfdge.ForedepthAttr = &_fgadc
			continue
		}
		if _fedfb.Name.Local == "ext" {
			_fgfdge.ExtAttr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "autorotationcenter" {
			_fgfdge.AutorotationcenterAttr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "facet" {
			_ccbgb, _ebfab := _fedfb.Value, error(nil)
			if _ebfab != nil {
				return _ebfab
			}
			_fgfdge.FacetAttr = &_ccbgb
			continue
		}
		if _fedfb.Name.Local == "render" {
			_fgfdge.RenderAttr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "lightlevel" {
			_fcdbf, _eagde := _fedfb.Value, error(nil)
			if _eagde != nil {
				return _eagde
			}
			_fgfdge.LightlevelAttr = &_fcdbf
			continue
		}
		if _fedfb.Name.Local == "brightness" {
			_bcge, _aacfa := _fedfb.Value, error(nil)
			if _aacfa != nil {
				return _aacfa
			}
			_fgfdge.BrightnessAttr = &_bcge
			continue
		}
		if _fedfb.Name.Local == "skewangle" {
			_ebff, _cbcfb := _e.ParseFloat(_fedfb.Value, 64)
			if _cbcfb != nil {
				return _cbcfb
			}
			_fbecf := float32(_ebff)
			_fgfdge.SkewangleAttr = &_fbecf
			continue
		}
		if _fedfb.Name.Local == "lightposition2" {
			_adcbd, _cabcc := _fedfb.Value, error(nil)
			if _cabcc != nil {
				return _cabcc
			}
			_fgfdge.Lightposition2Attr = &_adcbd
			continue
		}
		if _fedfb.Name.Local == "rotationangle" {
			_bbdeb, _aeecd := _fedfb.Value, error(nil)
			if _aeecd != nil {
				return _aeecd
			}
			_fgfdge.RotationangleAttr = &_bbdeb
			continue
		}
		if _fedfb.Name.Local == "lightharsh2" {
			_fgfdge.Lightharsh2Attr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "orientation" {
			_fdefe, _bfab := _fedfb.Value, error(nil)
			if _bfab != nil {
				return _bfab
			}
			_fgfdge.OrientationAttr = &_fdefe
			continue
		}
		if _fedfb.Name.Local == "lockrotationcenter" {
			_fgfdge.LockrotationcenterAttr.UnmarshalXMLAttr(_fedfb)
			continue
		}
		if _fedfb.Name.Local == "rotationcenter" {
			_aedcd, _gefba := _fedfb.Value, error(nil)
			if _gefba != nil {
				return _gefba
			}
			_fgfdge.RotationcenterAttr = &_aedcd
			continue
		}
		if _fedfb.Name.Local == "viewpoint" {
			_gcfe, _bggde := _fedfb.Value, error(nil)
			if _bggde != nil {
				return _bggde
			}
			_fgfdge.ViewpointAttr = &_gcfe
			continue
		}
		if _fedfb.Name.Local == "lightposition" {
			_ggdcb, _bgfgf := _fedfb.Value, error(nil)
			if _bgfgf != nil {
				return _bgfgf
			}
			_fgfdge.LightpositionAttr = &_ggdcb
			continue
		}
	}
	for {
		_abgfb, _gfgga := d.Token()
		if _gfgga != nil {
			return _f.Errorf("parsing\u0020OfcExtrusion:\u0020\u0025s", _gfgga)
		}
		if _gaafa, _dcgdf := _abgfb.(_b.EndElement); _dcgdf && _gaafa.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Formulas() *CT_Formulas { _ceab := &CT_Formulas{}; return _ceab }

// ValidateWithPath validates the OfcColumn and its children, prefixing error messages with path
func (_bcbade *OfcColumn) ValidateWithPath(path string) error {
	if _gdgba := _bcbade.OfcCT_StrokeChild.ValidateWithPath(path); _gdgba != nil {
		return _gdgba
	}
	return nil
}
func (_gafb *CT_Oval) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _gafb.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_gafb.HrefAttr)})
	}
	if _gafb.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_gafb.TargetAttr)})
	}
	if _gafb.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_gafb.ClassAttr)})
	}
	if _gafb.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_gafb.TitleAttr)})
	}
	if _gafb.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_gafb.AltAttr)})
	}
	if _gafb.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_gafb.CoordsizeAttr)})
	}
	if _gafb.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_gafb.CoordoriginAttr)})
	}
	if _gafb.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_gafb.WrapcoordsAttr)})
	}
	if _gafb.PrintAttr != _eb.ST_TrueFalseUnset {
		_dbgbb, _deaf := _gafb.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _deaf != nil {
			return _deaf
		}
		start.Attr = append(start.Attr, _dbgbb)
	}
	if _gafb.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_gafb.IdAttr)})
	}
	if _gafb.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_gafb.StyleAttr)})
	}
	if _gafb.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_gafb.SpidAttr)})
	}
	if _gafb.OnedAttr != _eb.ST_TrueFalseUnset {
		_cdefe, _fgcaca := _gafb.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _fgcaca != nil {
			return _fgcaca
		}
		start.Attr = append(start.Attr, _cdefe)
	}
	if _gafb.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_gafb.RegroupidAttr)})
	}
	if _gafb.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_bgbf, _gggb := _gafb.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _gggb != nil {
			return _gggb
		}
		start.Attr = append(start.Attr, _bgbf)
	}
	if _gafb.ButtonAttr != _eb.ST_TrueFalseUnset {
		_gcfc, _ebgcb := _gafb.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _ebgcb != nil {
			return _ebgcb
		}
		start.Attr = append(start.Attr, _gcfc)
	}
	if _gafb.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_gegga, _cfefb := _gafb.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _cfefb != nil {
			return _cfefb
		}
		start.Attr = append(start.Attr, _gegga)
	}
	if _gafb.BulletAttr != _eb.ST_TrueFalseUnset {
		_dcbad, _bbege := _gafb.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _bbege != nil {
			return _bbege
		}
		start.Attr = append(start.Attr, _dcbad)
	}
	if _gafb.HrAttr != _eb.ST_TrueFalseUnset {
		_gccef, _eadd := _gafb.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _eadd != nil {
			return _eadd
		}
		start.Attr = append(start.Attr, _gccef)
	}
	if _gafb.HrstdAttr != _eb.ST_TrueFalseUnset {
		_ageae, _aafa := _gafb.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _aafa != nil {
			return _aafa
		}
		start.Attr = append(start.Attr, _ageae)
	}
	if _gafb.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_dfbae, _bfcefa := _gafb.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _bfcefa != nil {
			return _bfcefa
		}
		start.Attr = append(start.Attr, _dfbae)
	}
	if _gafb.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_gafb.HrpctAttr)})
	}
	if _gafb.HralignAttr != OfcST_HrAlignUnset {
		_bgcag, _dabbg := _gafb.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _dabbg != nil {
			return _dabbg
		}
		start.Attr = append(start.Attr, _bgcag)
	}
	if _gafb.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_bcdeg, _abec := _gafb.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _abec != nil {
			return _abec
		}
		start.Attr = append(start.Attr, _bcdeg)
	}
	if _gafb.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_cdada, _debde := _gafb.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _debde != nil {
			return _debde
		}
		start.Attr = append(start.Attr, _cdada)
	}
	if _gafb.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_gadda, _ffeb := _gafb.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _ffeb != nil {
			return _ffeb
		}
		start.Attr = append(start.Attr, _gadda)
	}
	if _gafb.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_gafb.BordertopcolorAttr)})
	}
	if _gafb.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_gafb.BorderleftcolorAttr)})
	}
	if _gafb.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_gafb.BorderbottomcolorAttr)})
	}
	if _gafb.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_gafb.BorderrightcolorAttr)})
	}
	if _gafb.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_bcda, _eeca := _gafb.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _eeca != nil {
			return _eeca
		}
		start.Attr = append(start.Attr, _bcda)
	}
	if _gafb.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_gafb.DgmnodekindAttr)})
	}
	if _gafb.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_ggdc, _efagg := _gafb.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _efagg != nil {
			return _efagg
		}
		start.Attr = append(start.Attr, _ggdc)
	}
	if _gafb.InsetmodeAttr != OfcST_InsetModeUnset {
		_dgbb, _gefdg := _gafb.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _gefdg != nil {
			return _gefdg
		}
		start.Attr = append(start.Attr, _dgbb)
	}
	if _gafb.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_gafb.OpacityAttr)})
	}
	if _gafb.StrokedAttr != _eb.ST_TrueFalseUnset {
		_bcacc, _eedb := _gafb.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _eedb != nil {
			return _eedb
		}
		start.Attr = append(start.Attr, _bcacc)
	}
	if _gafb.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_gafb.StrokecolorAttr)})
	}
	if _gafb.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_gafb.StrokeweightAttr)})
	}
	if _gafb.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_gffdg, _aacag := _gafb.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _aacag != nil {
			return _aacag
		}
		start.Attr = append(start.Attr, _gffdg)
	}
	if _gafb.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_gafb.ChromakeyAttr)})
	}
	if _gafb.FilledAttr != _eb.ST_TrueFalseUnset {
		_eacgd, _geef := _gafb.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _geef != nil {
			return _geef
		}
		start.Attr = append(start.Attr, _eacgd)
	}
	if _gafb.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_gafb.FillcolorAttr)})
	}
	if _gafb.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_gafb.SptAttr)})
	}
	if _gafb.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_cbdb, _cabga := _gafb.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _cabga != nil {
			return _cabga
		}
		start.Attr = append(start.Attr, _cbdb)
	}
	if _gafb.BwmodeAttr != OfcST_BWModeUnset {
		_gcgd, _eabd := _gafb.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _eabd != nil {
			return _eabd
		}
		start.Attr = append(start.Attr, _gcgd)
	}
	if _gafb.BwpureAttr != OfcST_BWModeUnset {
		_cdac, _gdcgc := _gafb.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _gdcgc != nil {
			return _gdcgc
		}
		start.Attr = append(start.Attr, _cdac)
	}
	if _gafb.BwnormalAttr != OfcST_BWModeUnset {
		_cebb, _gdgf := _gafb.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _gdgf != nil {
			return _gdgf
		}
		start.Attr = append(start.Attr, _cebb)
	}
	if _gafb.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_aafe, _ccffg := _gafb.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _ccffg != nil {
			return _ccffg
		}
		start.Attr = append(start.Attr, _aafe)
	}
	if _gafb.OleiconAttr != _eb.ST_TrueFalseUnset {
		_cgeed, _edfd := _gafb.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _edfd != nil {
			return _edfd
		}
		start.Attr = append(start.Attr, _cgeed)
	}
	if _gafb.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_fccac, _bcgca := _gafb.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _bcgca != nil {
			return _bcgca
		}
		start.Attr = append(start.Attr, _fccac)
	}
	if _gafb.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_eeddc, _dadb := _gafb.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _dadb != nil {
			return _dadb
		}
		start.Attr = append(start.Attr, _eeddc)
	}
	if _gafb.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_fccb, _efeg := _gafb.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _efeg != nil {
			return _efeg
		}
		start.Attr = append(start.Attr, _fccb)
	}
	if _gafb.ClipAttr != _eb.ST_TrueFalseUnset {
		_ebfc, _egec := _gafb.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _egec != nil {
			return _egec
		}
		start.Attr = append(start.Attr, _ebfc)
	}
	e.EncodeToken(start)
	if _gafb.EG_ShapeElements != nil {
		for _, _aafdc := range _gafb.EG_ShapeElements {
			_aafdc.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type OfcTop struct{ OfcCT_StrokeChild }

func (_edfc *CT_Handles) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _edfc.H != nil {
		_abbc := _b.StartElement{Name: _b.Name{Local: "v:h"}}
		for _, _ecbdg := range _edfc.H {
			e.EncodeElement(_ecbdg, _abbc)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_dcbd *OfcClippath) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dcbd.OfcCT_ClipPath = *NewOfcCT_ClipPath()
	for _, _cdfda := range start.Attr {
		if _cdfda.Name.Local == "v" {
			_caecb, _fcag := _cdfda.Value, error(nil)
			if _fcag != nil {
				return _fcag
			}
			_dcbd.VAttr = _caecb
			continue
		}
	}
	for {
		_bbceg, _fbagb := d.Token()
		if _fbagb != nil {
			return _f.Errorf("parsing\u0020OfcClippath:\u0020\u0025s", _fbagb)
		}
		if _fagag, _defeg := _bbceg.(_b.EndElement); _defeg && _fagag.Name == start.Name {
			break
		}
	}
	return nil
}

type OfcCT_EquationXml struct {
	ContentTypeAttr *string
	Any             _ba.Any
}

func (_gfggd ST_ShadowType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_gfggd.String(), start)
}
func (_eca *AG_Id) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _eca.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_eca.IdAttr)})
	}
	return nil
}

type AG_Fill struct {
	FilledAttr    _eb.ST_TrueFalse
	FillcolorAttr *string
}

func (_bedga OfcST_DiagramLayout) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_baeacd := _b.Attr{}
	_baeacd.Name = name
	switch _bedga {
	case OfcST_DiagramLayoutUnset:
		_baeacd.Value = ""
	case OfcST_DiagramLayout0:
		_baeacd.Value = "0"
	case OfcST_DiagramLayout1:
		_baeacd.Value = "1"
	case OfcST_DiagramLayout2:
		_baeacd.Value = "2"
	case OfcST_DiagramLayout3:
		_baeacd.Value = "3"
	}
	return _baeacd, nil
}
func NewOfcFill() *OfcFill { _gbgeg := &OfcFill{}; _gbgeg.OfcCT_Fill = *NewOfcCT_Fill(); return _gbgeg }
func (_cddf *CT_Arc) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _cddf.StartAngleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "startAngle"}, Value: _f.Sprintf("\u0025v", *_cddf.StartAngleAttr)})
	}
	if _cddf.EndAngleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "endAngle"}, Value: _f.Sprintf("\u0025v", *_cddf.EndAngleAttr)})
	}
	if _cddf.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_cddf.HrefAttr)})
	}
	if _cddf.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_cddf.TargetAttr)})
	}
	if _cddf.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_cddf.ClassAttr)})
	}
	if _cddf.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_cddf.TitleAttr)})
	}
	if _cddf.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_cddf.AltAttr)})
	}
	if _cddf.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_cddf.CoordsizeAttr)})
	}
	if _cddf.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_cddf.CoordoriginAttr)})
	}
	if _cddf.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_cddf.WrapcoordsAttr)})
	}
	if _cddf.PrintAttr != _eb.ST_TrueFalseUnset {
		_ecde, _ccge := _cddf.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _ccge != nil {
			return _ccge
		}
		start.Attr = append(start.Attr, _ecde)
	}
	if _cddf.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_cddf.IdAttr)})
	}
	if _cddf.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_cddf.StyleAttr)})
	}
	if _cddf.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_cddf.SpidAttr)})
	}
	if _cddf.OnedAttr != _eb.ST_TrueFalseUnset {
		_fgfb, _gebea := _cddf.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _gebea != nil {
			return _gebea
		}
		start.Attr = append(start.Attr, _fgfb)
	}
	if _cddf.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_cddf.RegroupidAttr)})
	}
	if _cddf.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_bdgeb, _dca := _cddf.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _dca != nil {
			return _dca
		}
		start.Attr = append(start.Attr, _bdgeb)
	}
	if _cddf.ButtonAttr != _eb.ST_TrueFalseUnset {
		_fafb, _dffd := _cddf.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _dffd != nil {
			return _dffd
		}
		start.Attr = append(start.Attr, _fafb)
	}
	if _cddf.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_decg, _baeee := _cddf.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _baeee != nil {
			return _baeee
		}
		start.Attr = append(start.Attr, _decg)
	}
	if _cddf.BulletAttr != _eb.ST_TrueFalseUnset {
		_fgcdc, _fcca := _cddf.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _fcca != nil {
			return _fcca
		}
		start.Attr = append(start.Attr, _fgcdc)
	}
	if _cddf.HrAttr != _eb.ST_TrueFalseUnset {
		_fadb, _abgf := _cddf.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _abgf != nil {
			return _abgf
		}
		start.Attr = append(start.Attr, _fadb)
	}
	if _cddf.HrstdAttr != _eb.ST_TrueFalseUnset {
		_gfgg, _bfb := _cddf.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _bfb != nil {
			return _bfb
		}
		start.Attr = append(start.Attr, _gfgg)
	}
	if _cddf.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_aea, _gdgg := _cddf.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _gdgg != nil {
			return _gdgg
		}
		start.Attr = append(start.Attr, _aea)
	}
	if _cddf.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_cddf.HrpctAttr)})
	}
	if _cddf.HralignAttr != OfcST_HrAlignUnset {
		_dag, _fgddd := _cddf.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _fgddd != nil {
			return _fgddd
		}
		start.Attr = append(start.Attr, _dag)
	}
	if _cddf.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_gaa, _aec := _cddf.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _aec != nil {
			return _aec
		}
		start.Attr = append(start.Attr, _gaa)
	}
	if _cddf.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_agcc, _gagc := _cddf.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _gagc != nil {
			return _gagc
		}
		start.Attr = append(start.Attr, _agcc)
	}
	if _cddf.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_bcefc, _dgf := _cddf.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _dgf != nil {
			return _dgf
		}
		start.Attr = append(start.Attr, _bcefc)
	}
	if _cddf.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_cddf.BordertopcolorAttr)})
	}
	if _cddf.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_cddf.BorderleftcolorAttr)})
	}
	if _cddf.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_cddf.BorderbottomcolorAttr)})
	}
	if _cddf.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_cddf.BorderrightcolorAttr)})
	}
	if _cddf.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_cfec, _fga := _cddf.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _fga != nil {
			return _fga
		}
		start.Attr = append(start.Attr, _cfec)
	}
	if _cddf.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_cddf.DgmnodekindAttr)})
	}
	if _cddf.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_fgaa, _gce := _cddf.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _gce != nil {
			return _gce
		}
		start.Attr = append(start.Attr, _fgaa)
	}
	if _cddf.InsetmodeAttr != OfcST_InsetModeUnset {
		_eceb, _baef := _cddf.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _baef != nil {
			return _baef
		}
		start.Attr = append(start.Attr, _eceb)
	}
	if _cddf.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_cddf.OpacityAttr)})
	}
	if _cddf.StrokedAttr != _eb.ST_TrueFalseUnset {
		_edged, _dcdef := _cddf.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _dcdef != nil {
			return _dcdef
		}
		start.Attr = append(start.Attr, _edged)
	}
	if _cddf.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_cddf.StrokecolorAttr)})
	}
	if _cddf.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_cddf.StrokeweightAttr)})
	}
	if _cddf.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_gceg, _aggbf := _cddf.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _aggbf != nil {
			return _aggbf
		}
		start.Attr = append(start.Attr, _gceg)
	}
	if _cddf.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_cddf.ChromakeyAttr)})
	}
	if _cddf.FilledAttr != _eb.ST_TrueFalseUnset {
		_fdfa, _gegg := _cddf.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _gegg != nil {
			return _gegg
		}
		start.Attr = append(start.Attr, _fdfa)
	}
	if _cddf.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_cddf.FillcolorAttr)})
	}
	if _cddf.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_cddf.SptAttr)})
	}
	if _cddf.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_edc, _febd := _cddf.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _febd != nil {
			return _febd
		}
		start.Attr = append(start.Attr, _edc)
	}
	if _cddf.BwmodeAttr != OfcST_BWModeUnset {
		_gdeeg, _eagc := _cddf.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _eagc != nil {
			return _eagc
		}
		start.Attr = append(start.Attr, _gdeeg)
	}
	if _cddf.BwpureAttr != OfcST_BWModeUnset {
		_ebgb, _gfge := _cddf.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _gfge != nil {
			return _gfge
		}
		start.Attr = append(start.Attr, _ebgb)
	}
	if _cddf.BwnormalAttr != OfcST_BWModeUnset {
		_ccfb, _dafe := _cddf.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _dafe != nil {
			return _dafe
		}
		start.Attr = append(start.Attr, _ccfb)
	}
	if _cddf.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_ecbb, _bfcef := _cddf.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _bfcef != nil {
			return _bfcef
		}
		start.Attr = append(start.Attr, _ecbb)
	}
	if _cddf.OleiconAttr != _eb.ST_TrueFalseUnset {
		_fbfc, _dfb := _cddf.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _dfb != nil {
			return _dfb
		}
		start.Attr = append(start.Attr, _fbfc)
	}
	if _cddf.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_eccg, _ccee := _cddf.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _ccee != nil {
			return _ccee
		}
		start.Attr = append(start.Attr, _eccg)
	}
	if _cddf.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_gfcg, _ceccf := _cddf.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _ceccf != nil {
			return _ceccf
		}
		start.Attr = append(start.Attr, _gfcg)
	}
	if _cddf.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_ddc, _deg := _cddf.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _deg != nil {
			return _deg
		}
		start.Attr = append(start.Attr, _ddc)
	}
	if _cddf.ClipAttr != _eb.ST_TrueFalseUnset {
		_dbde, _eedd := _cddf.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _eedd != nil {
			return _eedd
		}
		start.Attr = append(start.Attr, _dbde)
	}
	e.EncodeToken(start)
	if _cddf.EG_ShapeElements != nil {
		for _, _efag := range _cddf.EG_ShapeElements {
			_efag.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewOfcCT_ShapeLayout() *OfcCT_ShapeLayout { _egcga := &OfcCT_ShapeLayout{}; return _egcga }

const (
	ST_StrokeArrowLengthUnset  ST_StrokeArrowLength = 0
	ST_StrokeArrowLengthShort  ST_StrokeArrowLength = 1
	ST_StrokeArrowLengthMedium ST_StrokeArrowLength = 2
	ST_StrokeArrowLengthLong   ST_StrokeArrowLength = 3
)

type Oval struct{ CT_Oval }

func (_cfdbf *CT_RoundRect) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _cfdbf.ArcsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "arcsize"}, Value: _f.Sprintf("\u0025v", *_cfdbf.ArcsizeAttr)})
	}
	if _cfdbf.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_cfdbf.HrefAttr)})
	}
	if _cfdbf.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_cfdbf.TargetAttr)})
	}
	if _cfdbf.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_cfdbf.ClassAttr)})
	}
	if _cfdbf.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_cfdbf.TitleAttr)})
	}
	if _cfdbf.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_cfdbf.AltAttr)})
	}
	if _cfdbf.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_cfdbf.CoordsizeAttr)})
	}
	if _cfdbf.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_cfdbf.CoordoriginAttr)})
	}
	if _cfdbf.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_cfdbf.WrapcoordsAttr)})
	}
	if _cfdbf.PrintAttr != _eb.ST_TrueFalseUnset {
		_faad, _baacg := _cfdbf.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _baacg != nil {
			return _baacg
		}
		start.Attr = append(start.Attr, _faad)
	}
	if _cfdbf.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_cfdbf.IdAttr)})
	}
	if _cfdbf.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_cfdbf.StyleAttr)})
	}
	if _cfdbf.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_cfdbf.SpidAttr)})
	}
	if _cfdbf.OnedAttr != _eb.ST_TrueFalseUnset {
		_gfdaa, _acfg := _cfdbf.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _acfg != nil {
			return _acfg
		}
		start.Attr = append(start.Attr, _gfdaa)
	}
	if _cfdbf.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_cfdbf.RegroupidAttr)})
	}
	if _cfdbf.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_gbabb, _dgfb := _cfdbf.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _dgfb != nil {
			return _dgfb
		}
		start.Attr = append(start.Attr, _gbabb)
	}
	if _cfdbf.ButtonAttr != _eb.ST_TrueFalseUnset {
		_adceg, _fddfg := _cfdbf.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _fddfg != nil {
			return _fddfg
		}
		start.Attr = append(start.Attr, _adceg)
	}
	if _cfdbf.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_affg, _gccf := _cfdbf.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _gccf != nil {
			return _gccf
		}
		start.Attr = append(start.Attr, _affg)
	}
	if _cfdbf.BulletAttr != _eb.ST_TrueFalseUnset {
		_bacc, _fegdf := _cfdbf.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _fegdf != nil {
			return _fegdf
		}
		start.Attr = append(start.Attr, _bacc)
	}
	if _cfdbf.HrAttr != _eb.ST_TrueFalseUnset {
		_dgfeg, _ccdgb := _cfdbf.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _ccdgb != nil {
			return _ccdgb
		}
		start.Attr = append(start.Attr, _dgfeg)
	}
	if _cfdbf.HrstdAttr != _eb.ST_TrueFalseUnset {
		_dceeg, _fdea := _cfdbf.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _fdea != nil {
			return _fdea
		}
		start.Attr = append(start.Attr, _dceeg)
	}
	if _cfdbf.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_gbeg, _dgec := _cfdbf.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _dgec != nil {
			return _dgec
		}
		start.Attr = append(start.Attr, _gbeg)
	}
	if _cfdbf.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_cfdbf.HrpctAttr)})
	}
	if _cfdbf.HralignAttr != OfcST_HrAlignUnset {
		_fbggg, _dfbg := _cfdbf.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _dfbg != nil {
			return _dfbg
		}
		start.Attr = append(start.Attr, _fbggg)
	}
	if _cfdbf.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_gabgd, _egacc := _cfdbf.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _egacc != nil {
			return _egacc
		}
		start.Attr = append(start.Attr, _gabgd)
	}
	if _cfdbf.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_bfceg, _ffbcb := _cfdbf.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _ffbcb != nil {
			return _ffbcb
		}
		start.Attr = append(start.Attr, _bfceg)
	}
	if _cfdbf.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_bdbc, _dfgda := _cfdbf.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _dfgda != nil {
			return _dfgda
		}
		start.Attr = append(start.Attr, _bdbc)
	}
	if _cfdbf.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_cfdbf.BordertopcolorAttr)})
	}
	if _cfdbf.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_cfdbf.BorderleftcolorAttr)})
	}
	if _cfdbf.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_cfdbf.BorderbottomcolorAttr)})
	}
	if _cfdbf.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_cfdbf.BorderrightcolorAttr)})
	}
	if _cfdbf.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_ecfe, _gcdcb := _cfdbf.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _gcdcb != nil {
			return _gcdcb
		}
		start.Attr = append(start.Attr, _ecfe)
	}
	if _cfdbf.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_cfdbf.DgmnodekindAttr)})
	}
	if _cfdbf.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_caaf, _cedf := _cfdbf.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _cedf != nil {
			return _cedf
		}
		start.Attr = append(start.Attr, _caaf)
	}
	if _cfdbf.InsetmodeAttr != OfcST_InsetModeUnset {
		_cddd, _fgfdg := _cfdbf.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _fgfdg != nil {
			return _fgfdg
		}
		start.Attr = append(start.Attr, _cddd)
	}
	if _cfdbf.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_cfdbf.OpacityAttr)})
	}
	if _cfdbf.StrokedAttr != _eb.ST_TrueFalseUnset {
		_deacb, _gcbdb := _cfdbf.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _gcbdb != nil {
			return _gcbdb
		}
		start.Attr = append(start.Attr, _deacb)
	}
	if _cfdbf.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_cfdbf.StrokecolorAttr)})
	}
	if _cfdbf.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_cfdbf.StrokeweightAttr)})
	}
	if _cfdbf.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_cgfg, _cffcg := _cfdbf.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _cffcg != nil {
			return _cffcg
		}
		start.Attr = append(start.Attr, _cgfg)
	}
	if _cfdbf.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_cfdbf.ChromakeyAttr)})
	}
	if _cfdbf.FilledAttr != _eb.ST_TrueFalseUnset {
		_gdca, _gfdg := _cfdbf.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _gfdg != nil {
			return _gfdg
		}
		start.Attr = append(start.Attr, _gdca)
	}
	if _cfdbf.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_cfdbf.FillcolorAttr)})
	}
	if _cfdbf.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_cfdbf.SptAttr)})
	}
	if _cfdbf.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_eeged, _bead := _cfdbf.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _bead != nil {
			return _bead
		}
		start.Attr = append(start.Attr, _eeged)
	}
	if _cfdbf.BwmodeAttr != OfcST_BWModeUnset {
		_fefc, _acfbe := _cfdbf.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _acfbe != nil {
			return _acfbe
		}
		start.Attr = append(start.Attr, _fefc)
	}
	if _cfdbf.BwpureAttr != OfcST_BWModeUnset {
		_cfcd, _gcbag := _cfdbf.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _gcbag != nil {
			return _gcbag
		}
		start.Attr = append(start.Attr, _cfcd)
	}
	if _cfdbf.BwnormalAttr != OfcST_BWModeUnset {
		_ffcgg, _eeac := _cfdbf.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _eeac != nil {
			return _eeac
		}
		start.Attr = append(start.Attr, _ffcgg)
	}
	if _cfdbf.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_efgb, _eccb := _cfdbf.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _eccb != nil {
			return _eccb
		}
		start.Attr = append(start.Attr, _efgb)
	}
	if _cfdbf.OleiconAttr != _eb.ST_TrueFalseUnset {
		_ebacb, _fgddbd := _cfdbf.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _fgddbd != nil {
			return _fgddbd
		}
		start.Attr = append(start.Attr, _ebacb)
	}
	if _cfdbf.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_gbegb, _gfcba := _cfdbf.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _gfcba != nil {
			return _gfcba
		}
		start.Attr = append(start.Attr, _gbegb)
	}
	if _cfdbf.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_fgda, _cddgg := _cfdbf.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _cddgg != nil {
			return _cddgg
		}
		start.Attr = append(start.Attr, _fgda)
	}
	if _cfdbf.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_dfag, _aaecf := _cfdbf.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _aaecf != nil {
			return _aaecf
		}
		start.Attr = append(start.Attr, _dfag)
	}
	if _cfdbf.ClipAttr != _eb.ST_TrueFalseUnset {
		_adabf, _ebdff := _cfdbf.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _ebdff != nil {
			return _ebdff
		}
		start.Attr = append(start.Attr, _adabf)
	}
	e.EncodeToken(start)
	if _cfdbf.EG_ShapeElements != nil {
		for _, _fggf := range _cfdbf.EG_ShapeElements {
			_fggf.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_dddcb *OfcST_OLEUpdateMode) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_eddcaf, _eabae := d.Token()
	if _eabae != nil {
		return _eabae
	}
	if _cbddgg, _aeffd := _eddcaf.(_b.EndElement); _aeffd && _cbddgg.Name == start.Name {
		*_dddcb = 1
		return nil
	}
	if _defge, _ddfge := _eddcaf.(_b.CharData); !_ddfge {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eddcaf)
	} else {
		switch string(_defge) {
		case "":
			*_dddcb = 0
		case "Always":
			*_dddcb = 1
		case "OnCall":
			*_dddcb = 2
		}
	}
	_eddcaf, _eabae = d.Token()
	if _eabae != nil {
		return _eabae
	}
	if _aabee, _fddcfe := _eddcaf.(_b.EndElement); _fddcfe && _aabee.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eddcaf)
}

type Rect struct{ CT_Rect }

func NewOfcCallout() *OfcCallout {
	_ddedae := &OfcCallout{}
	_ddedae.OfcCT_Callout = *NewOfcCT_Callout()
	return _ddedae
}

// Validate validates the Polyline and its children
func (_fcfeg *Polyline) Validate() error { return _fcfeg.ValidateWithPath("Polyline") }

// Validate validates the OfcEquationxml and its children
func (_gadfa *OfcEquationxml) Validate() error { return _gadfa.ValidateWithPath("OfcEquationxml") }
func NewOfcInk() *OfcInk                       { _abcdg := &OfcInk{}; _abcdg.OfcCT_Ink = *NewOfcCT_Ink(); return _abcdg }
func (_eebcc OfcST_OLEDrawAspect) ValidateWithPath(path string) error {
	switch _eebcc {
	case 0, 1, 2:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eebcc))
	}
	return nil
}
func (_edcdc OfcST_RType) String() string {
	switch _edcdc {
	case 0:
		return ""
	case 1:
		return "arc"
	case 2:
		return "callout"
	case 3:
		return "connector"
	case 4:
		return "align"
	}
	return ""
}
func (_bbbc *AG_ImageAttributes) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _gdf := range start.Attr {
		if _gdf.Name.Local == "src" {
			_ecb, _eef := _gdf.Value, error(nil)
			if _eef != nil {
				return _eef
			}
			_bbbc.SrcAttr = &_ecb
			continue
		}
		if _gdf.Name.Local == "cropleft" {
			_acb, _dcfd := _gdf.Value, error(nil)
			if _dcfd != nil {
				return _dcfd
			}
			_bbbc.CropleftAttr = &_acb
			continue
		}
		if _gdf.Name.Local == "croptop" {
			_afc, _cec := _gdf.Value, error(nil)
			if _cec != nil {
				return _cec
			}
			_bbbc.CroptopAttr = &_afc
			continue
		}
		if _gdf.Name.Local == "cropright" {
			_gebd, _efb := _gdf.Value, error(nil)
			if _efb != nil {
				return _efb
			}
			_bbbc.CroprightAttr = &_gebd
			continue
		}
		if _gdf.Name.Local == "cropbottom" {
			_fdbd, _cba := _gdf.Value, error(nil)
			if _cba != nil {
				return _cba
			}
			_bbbc.CropbottomAttr = &_fdbd
			continue
		}
		if _gdf.Name.Local == "gain" {
			_cad, _ega := _gdf.Value, error(nil)
			if _ega != nil {
				return _ega
			}
			_bbbc.GainAttr = &_cad
			continue
		}
		if _gdf.Name.Local == "blacklevel" {
			_cecf, _cdd := _gdf.Value, error(nil)
			if _cdd != nil {
				return _cdd
			}
			_bbbc.BlacklevelAttr = &_cecf
			continue
		}
		if _gdf.Name.Local == "gamma" {
			_eda, _egd := _gdf.Value, error(nil)
			if _egd != nil {
				return _egd
			}
			_bbbc.GammaAttr = &_eda
			continue
		}
		if _gdf.Name.Local == "grayscale" {
			_bbbc.GrayscaleAttr.UnmarshalXMLAttr(_gdf)
			continue
		}
		if _gdf.Name.Local == "bilevel" {
			_bbbc.BilevelAttr.UnmarshalXMLAttr(_gdf)
			continue
		}
	}
	for {
		_aeg, _bcac := d.Token()
		if _bcac != nil {
			return _f.Errorf("parsing\u0020AG_ImageAttributes:\u0020\u0025s", _bcac)
		}
		if _fdf, _faa := _aeg.(_b.EndElement); _faa && _fdf.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the Image and its children, prefixing error messages with path
func (_ccfc *Image) ValidateWithPath(path string) error {
	if _bafeg := _ccfc.CT_Image.ValidateWithPath(path); _bafeg != nil {
		return _bafeg
	}
	return nil
}
func NewTextbox() *Textbox { _fefaf := &Textbox{}; _fefaf.CT_Textbox = *NewCT_Textbox(); return _fefaf }
func (_bee *AG_OfficeShapeAttributes) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bee.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_bee.SptAttr)})
	}
	if _bee.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_cfe, _dgce := _bee.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _dgce != nil {
			return _dgce
		}
		start.Attr = append(start.Attr, _cfe)
	}
	if _bee.BwmodeAttr != OfcST_BWModeUnset {
		_fgdd, _ccc := _bee.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _ccc != nil {
			return _ccc
		}
		start.Attr = append(start.Attr, _fgdd)
	}
	if _bee.BwpureAttr != OfcST_BWModeUnset {
		_fgg, _bcgc := _bee.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _bcgc != nil {
			return _bcgc
		}
		start.Attr = append(start.Attr, _fgg)
	}
	if _bee.BwnormalAttr != OfcST_BWModeUnset {
		_eae, _cbge := _bee.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _cbge != nil {
			return _cbge
		}
		start.Attr = append(start.Attr, _eae)
	}
	if _bee.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_debd, _cecc := _bee.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _cecc != nil {
			return _cecc
		}
		start.Attr = append(start.Attr, _debd)
	}
	if _bee.OleiconAttr != _eb.ST_TrueFalseUnset {
		_dggd, _ggaa := _bee.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _ggaa != nil {
			return _ggaa
		}
		start.Attr = append(start.Attr, _dggd)
	}
	if _bee.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_egb, _ffc := _bee.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _ffc != nil {
			return _ffc
		}
		start.Attr = append(start.Attr, _egb)
	}
	if _bee.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_gade, _caef := _bee.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _caef != nil {
			return _caef
		}
		start.Attr = append(start.Attr, _gade)
	}
	if _bee.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_fce, _gfad := _bee.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _gfad != nil {
			return _gfad
		}
		start.Attr = append(start.Attr, _fce)
	}
	if _bee.ClipAttr != _eb.ST_TrueFalseUnset {
		_gdcd, _afdb := _bee.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _afdb != nil {
			return _afdb
		}
		start.Attr = append(start.Attr, _gdcd)
	}
	return nil
}
func (_cagcg ST_StrokeArrowWidth) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_ccgeb := _b.Attr{}
	_ccgeb.Name = name
	switch _cagcg {
	case ST_StrokeArrowWidthUnset:
		_ccgeb.Value = ""
	case ST_StrokeArrowWidthNarrow:
		_ccgeb.Value = "narrow"
	case ST_StrokeArrowWidthMedium:
		_ccgeb.Value = "medium"
	case ST_StrokeArrowWidthWide:
		_ccgeb.Value = "wide"
	}
	return _ccgeb, nil
}
func (_gebcb OfcST_BWMode) Validate() error { return _gebcb.ValidateWithPath("") }

type OfcCT_Fill struct {
	TypeAttr OfcST_FillType
	ExtAttr  ST_Ext
}

// ValidateWithPath validates the OfcSkew and its children, prefixing error messages with path
func (_cggfd *OfcSkew) ValidateWithPath(path string) error {
	if _ffcga := _cggfd.OfcCT_Skew.ValidateWithPath(path); _ffcga != nil {
		return _ffcga
	}
	return nil
}
func NewOfcCT_R() *OfcCT_R { _beae := &OfcCT_R{}; return _beae }
func (_gfedc *Group) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gfedc.CT_Group = *NewCT_Group()
	for _, _fcdca := range start.Attr {
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "allowincell" {
			_gfedc.AllowincellAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "bullet" {
			_gfedc.BulletAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "hr" {
			_gfedc.HrAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "oned" {
			_gfedc.OnedAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "hralign" {
			_gfedc.HralignAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "tablelimits" {
			_eadcc, _abab := _fcdca.Value, error(nil)
			if _abab != nil {
				return _abab
			}
			_gfedc.TablelimitsAttr = &_eadcc
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "regroupid" {
			_bcfge, _feaca := _e.ParseInt(_fcdca.Value, 10, 64)
			if _feaca != nil {
				return _feaca
			}
			_gfedc.RegroupidAttr = &_bcfge
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "bordertopcolor" {
			_cacefe, _ccafb := _fcdca.Value, error(nil)
			if _ccafb != nil {
				return _ccafb
			}
			_gfedc.BordertopcolorAttr = &_cacefe
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "spid" {
			_agbad, _ccdbed := _fcdca.Value, error(nil)
			if _ccdbed != nil {
				return _ccdbed
			}
			_gfedc.SpidAttr = &_agbad
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "hrpct" {
			_aebfd, _fagae := _e.ParseFloat(_fcdca.Value, 64)
			if _fagae != nil {
				return _fagae
			}
			_fdgfbg := float32(_aebfd)
			_gfedc.HrpctAttr = &_fdgfbg
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "borderrightcolor" {
			_ggcdge, _cceeb := _fcdca.Value, error(nil)
			if _cceeb != nil {
				return _cceeb
			}
			_gfedc.BorderrightcolorAttr = &_ggcdge
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "button" {
			_gfedc.ButtonAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "hrstd" {
			_gfedc.HrstdAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "dgmlayout" {
			_gfedc.DgmlayoutAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "userdrawn" {
			_gfedc.UserdrawnAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "doubleclicknotify" {
			_gfedc.DoubleclicknotifyAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "userhidden" {
			_gfedc.UserhiddenAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "borderleftcolor" {
			_adffg, _egfeef := _fcdca.Value, error(nil)
			if _egfeef != nil {
				return _egfeef
			}
			_gfedc.BorderleftcolorAttr = &_adffg
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "insetmode" {
			_gfedc.InsetmodeAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "allowoverlap" {
			_gfedc.AllowoverlapAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "tableproperties" {
			_abaeee, _egacce := _fcdca.Value, error(nil)
			if _egacce != nil {
				return _egacce
			}
			_gfedc.TablepropertiesAttr = &_abaeee
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "hrnoshade" {
			_gfedc.HrnoshadeAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "dgmlayoutmru" {
			_gfedc.DgmlayoutmruAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "dgmnodekind" {
			_aecbd, _eaefb := _e.ParseInt(_fcdca.Value, 10, 64)
			if _eaefb != nil {
				return _eaefb
			}
			_gfedc.DgmnodekindAttr = &_aecbd
			continue
		}
		if _fcdca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcdca.Name.Local == "borderbottomcolor" {
			_fagf, _cffac := _fcdca.Value, error(nil)
			if _cffac != nil {
				return _cffac
			}
			_gfedc.BorderbottomcolorAttr = &_fagf
			continue
		}
		if _fcdca.Name.Local == "print" {
			_gfedc.PrintAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Local == "title" {
			_bfbba, _ggafg := _fcdca.Value, error(nil)
			if _ggafg != nil {
				return _ggafg
			}
			_gfedc.TitleAttr = &_bfbba
			continue
		}
		if _fcdca.Name.Local == "coordorigin" {
			_adca, _bdbdgf := _fcdca.Value, error(nil)
			if _bdbdgf != nil {
				return _bdbdgf
			}
			_gfedc.CoordoriginAttr = &_adca
			continue
		}
		if _fcdca.Name.Local == "wrapcoords" {
			_ggeef, _abce := _fcdca.Value, error(nil)
			if _abce != nil {
				return _abce
			}
			_gfedc.WrapcoordsAttr = &_ggeef
			continue
		}
		if _fcdca.Name.Local == "coordsize" {
			_eedad, _bcafd := _fcdca.Value, error(nil)
			if _bcafd != nil {
				return _bcafd
			}
			_gfedc.CoordsizeAttr = &_eedad
			continue
		}
		if _fcdca.Name.Local == "style" {
			_deff, _beec := _fcdca.Value, error(nil)
			if _beec != nil {
				return _beec
			}
			_gfedc.StyleAttr = &_deff
			continue
		}
		if _fcdca.Name.Local == "id" {
			_efcgb, _fecgg := _fcdca.Value, error(nil)
			if _fecgg != nil {
				return _fecgg
			}
			_gfedc.IdAttr = &_efcgb
			continue
		}
		if _fcdca.Name.Local == "fillcolor" {
			_accbe, _dafaca := _fcdca.Value, error(nil)
			if _dafaca != nil {
				return _dafaca
			}
			_gfedc.FillcolorAttr = &_accbe
			continue
		}
		if _fcdca.Name.Local == "class" {
			_aafed, _cfggc := _fcdca.Value, error(nil)
			if _cfggc != nil {
				return _cfggc
			}
			_gfedc.ClassAttr = &_aafed
			continue
		}
		if _fcdca.Name.Local == "target" {
			_bgeef, _ddbgba := _fcdca.Value, error(nil)
			if _ddbgba != nil {
				return _ddbgba
			}
			_gfedc.TargetAttr = &_bgeef
			continue
		}
		if _fcdca.Name.Local == "href" {
			_bgdbb, _fggff := _fcdca.Value, error(nil)
			if _fggff != nil {
				return _fggff
			}
			_gfedc.HrefAttr = &_bgdbb
			continue
		}
		if _fcdca.Name.Local == "editas" {
			_gfedc.EditasAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Local == "filled" {
			_gfedc.FilledAttr.UnmarshalXMLAttr(_fcdca)
			continue
		}
		if _fcdca.Name.Local == "alt" {
			_gdfd, _ecggc := _fcdca.Value, error(nil)
			if _ecggc != nil {
				return _ecggc
			}
			_gfedc.AltAttr = &_gdfd
			continue
		}
	}
_fgeag:
	for {
		_egfbf, _acbad := d.Token()
		if _acbad != nil {
			return _acbad
		}
		switch _abcbce := _egfbf.(type) {
		case _b.StartElement:
			switch _abcbce.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "group"}:
				_facca := NewGroup()
				if _cfce := d.DecodeElement(_facca, &_abcbce); _cfce != nil {
					return _cfce
				}
				_gfedc.Group = append(_gfedc.Group, _facca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shape"}:
				_bffea := NewShape()
				if _fdebd := d.DecodeElement(_bffea, &_abcbce); _fdebd != nil {
					return _fdebd
				}
				_gfedc.Shape = append(_gfedc.Shape, _bffea)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shapetype"}:
				_eagee := NewShapetype()
				if _ggdfab := d.DecodeElement(_eagee, &_abcbce); _ggdfab != nil {
					return _ggdfab
				}
				_gfedc.Shapetype = append(_gfedc.Shapetype, _eagee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "arc"}:
				_gcbg := NewArc()
				if _caggf := d.DecodeElement(_gcbg, &_abcbce); _caggf != nil {
					return _caggf
				}
				_gfedc.Arc = append(_gfedc.Arc, _gcbg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "curve"}:
				_gagab := NewCurve()
				if _accef := d.DecodeElement(_gagab, &_abcbce); _accef != nil {
					return _accef
				}
				_gfedc.Curve = append(_gfedc.Curve, _gagab)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "image"}:
				_fcbbc := NewImage()
				if _gafee := d.DecodeElement(_fcbbc, &_abcbce); _gafee != nil {
					return _gafee
				}
				_gfedc.Image = append(_gfedc.Image, _fcbbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "line"}:
				_ggffe := NewLine()
				if _decee := d.DecodeElement(_ggffe, &_abcbce); _decee != nil {
					return _decee
				}
				_gfedc.Line = append(_gfedc.Line, _ggffe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "oval"}:
				_cdccd := NewOval()
				if _bdgaf := d.DecodeElement(_cdccd, &_abcbce); _bdgaf != nil {
					return _bdgaf
				}
				_gfedc.Oval = append(_gfedc.Oval, _cdccd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "polyline"}:
				_dgfdf := NewPolyline()
				if _aebfg := d.DecodeElement(_dgfdf, &_abcbce); _aebfg != nil {
					return _aebfg
				}
				_gfedc.Polyline = append(_gfedc.Polyline, _dgfdf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "rect"}:
				_aegfb := NewRect()
				if _fgaaa := d.DecodeElement(_aegfb, &_abcbce); _fgaaa != nil {
					return _fgaaa
				}
				_gfedc.Rect = append(_gfedc.Rect, _aegfb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "roundrect"}:
				_agadc := NewRoundrect()
				if _bggd := d.DecodeElement(_agadc, &_abcbce); _bggd != nil {
					return _bggd
				}
				_gfedc.Roundrect = append(_gfedc.Roundrect, _agadc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "diagram"}:
				_faba := NewOfcDiagram()
				if _febb := d.DecodeElement(_faba, &_abcbce); _febb != nil {
					return _febb
				}
				_gfedc.Diagram = append(_gfedc.Diagram, _faba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_feedg := NewEG_ShapeElements()
				_feedg.Path = NewPath()
				if _dbedfd := d.DecodeElement(_feedg.Path, &_abcbce); _dbedfd != nil {
					return _dbedfd
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _feedg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_ffgdf := NewEG_ShapeElements()
				_ffgdf.Formulas = NewFormulas()
				if _ccbg := d.DecodeElement(_ffgdf.Formulas, &_abcbce); _ccbg != nil {
					return _ccbg
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _ffgdf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_bdbde := NewEG_ShapeElements()
				_bdbde.Handles = NewHandles()
				if _dgdd := d.DecodeElement(_bdbde.Handles, &_abcbce); _dgdd != nil {
					return _dgdd
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _bdbde)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_gfeafb := NewEG_ShapeElements()
				_gfeafb.Fill = NewFill()
				if _acgdf := d.DecodeElement(_gfeafb.Fill, &_abcbce); _acgdf != nil {
					return _acgdf
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _gfeafb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_cbead := NewEG_ShapeElements()
				_cbead.Stroke = NewStroke()
				if _cffeb := d.DecodeElement(_cbead.Stroke, &_abcbce); _cffeb != nil {
					return _cffeb
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _cbead)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_gcdda := NewEG_ShapeElements()
				_gcdda.Shadow = NewShadow()
				if _aaeeb := d.DecodeElement(_gcdda.Shadow, &_abcbce); _aaeeb != nil {
					return _aaeeb
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _gcdda)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_ebcag := NewEG_ShapeElements()
				_ebcag.Textbox = NewTextbox()
				if _aadbg := d.DecodeElement(_ebcag.Textbox, &_abcbce); _aadbg != nil {
					return _aadbg
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _ebcag)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_geeb := NewEG_ShapeElements()
				_geeb.Textpath = NewTextpath()
				if _ggebd := d.DecodeElement(_geeb.Textpath, &_abcbce); _ggebd != nil {
					return _ggebd
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _geeb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_acda := NewEG_ShapeElements()
				_acda.Imagedata = NewImagedata()
				if _dabdg := d.DecodeElement(_acda.Imagedata, &_abcbce); _dabdg != nil {
					return _dabdg
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _acda)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_ggbg := NewEG_ShapeElements()
				_ggbg.Skew = NewOfcSkew()
				if _dgfcc := d.DecodeElement(_ggbg.Skew, &_abcbce); _dgfcc != nil {
					return _dgfcc
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _ggbg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_gcffb := NewEG_ShapeElements()
				_gcffb.Extrusion = NewOfcExtrusion()
				if _aeaag := d.DecodeElement(_gcffb.Extrusion, &_abcbce); _aeaag != nil {
					return _aeaag
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _gcffb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_fbddf := NewEG_ShapeElements()
				_fbddf.Callout = NewOfcCallout()
				if _bcfga := d.DecodeElement(_fbddf.Callout, &_abcbce); _bcfga != nil {
					return _bcfga
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _fbddf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_gbaca := NewEG_ShapeElements()
				_gbaca.Lock = NewOfcLock()
				if _fbeac := d.DecodeElement(_gbaca.Lock, &_abcbce); _fbeac != nil {
					return _fbeac
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _gbaca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_dfcaa := NewEG_ShapeElements()
				_dfcaa.Clippath = NewOfcClippath()
				if _ecdfb := d.DecodeElement(_dfcaa.Clippath, &_abcbce); _ecdfb != nil {
					return _ecdfb
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _dfcaa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_dfgcf := NewEG_ShapeElements()
				_dfgcf.Signatureline = NewOfcSignatureline()
				if _cadeg := d.DecodeElement(_dfgcf.Signatureline, &_abcbce); _cadeg != nil {
					return _cadeg
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _dfgcf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_dfffb := NewEG_ShapeElements()
				_dfffb.Wrap = _a.NewWrap()
				if _bdecgg := d.DecodeElement(_dfffb.Wrap, &_abcbce); _bdecgg != nil {
					return _bdecgg
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _dfffb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_ccbgg := NewEG_ShapeElements()
				_ccbgg.Anchorlock = _a.NewAnchorlock()
				if _gbbcd := d.DecodeElement(_ccbgg.Anchorlock, &_abcbce); _gbbcd != nil {
					return _gbbcd
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _ccbgg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_fdbgeb := NewEG_ShapeElements()
				_fdbgeb.Bordertop = _a.NewBordertop()
				if _decab := d.DecodeElement(_fdbgeb.Bordertop, &_abcbce); _decab != nil {
					return _decab
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _fdbgeb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_cdfec := NewEG_ShapeElements()
				_cdfec.Borderbottom = _a.NewBorderbottom()
				if _adage := d.DecodeElement(_cdfec.Borderbottom, &_abcbce); _adage != nil {
					return _adage
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _cdfec)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_bgdee := NewEG_ShapeElements()
				_bgdee.Borderleft = _a.NewBorderleft()
				if _addef := d.DecodeElement(_bgdee.Borderleft, &_abcbce); _addef != nil {
					return _addef
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _bgdee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_effe := NewEG_ShapeElements()
				_effe.Borderright = _a.NewBorderright()
				if _deeg := d.DecodeElement(_effe.Borderright, &_abcbce); _deeg != nil {
					return _deeg
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _effe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_dcbca := NewEG_ShapeElements()
				_dcbca.ClientData = _c.NewClientData()
				if _cdbcb := d.DecodeElement(_dcbca.ClientData, &_abcbce); _cdbcb != nil {
					return _cdbcb
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _dcbca)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_bbccg := NewEG_ShapeElements()
				_bbccg.Textdata = _bf.NewTextdata()
				if _cfcc := d.DecodeElement(_bbccg.Textdata, &_abcbce); _cfcc != nil {
					return _cfcc
				}
				_gfedc.EG_ShapeElements = append(_gfedc.EG_ShapeElements, _bbccg)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on Group \u0025v", _abcbce.Name)
				if _dbgc := d.Skip(); _dbgc != nil {
					return _dbgc
				}
			}
		case _b.EndElement:
			break _fgeag
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the Group and its children, prefixing error messages with path
func (_bfgcb *Group) ValidateWithPath(path string) error {
	if _abgbb := _bfgcb.CT_Group.ValidateWithPath(path); _abgbb != nil {
		return _abgbb
	}
	return nil
}

type EG_ShapeElements struct {
	Path          *Path
	Formulas      *Formulas
	Handles       *Handles
	Fill          *Fill
	Stroke        *Stroke
	Shadow        *Shadow
	Textbox       *Textbox
	Textpath      *Textpath
	Imagedata     *Imagedata
	Skew          *OfcSkew
	Extrusion     *OfcExtrusion
	Callout       *OfcCallout
	Lock          *OfcLock
	Clippath      *OfcClippath
	Signatureline *OfcSignatureline
	Wrap          *_a.Wrap
	Anchorlock    *_a.Anchorlock
	Bordertop     *_a.Bordertop
	Borderbottom  *_a.Borderbottom
	Borderleft    *_a.Borderleft
	Borderright   *_a.Borderright
	ClientData    *_c.ClientData
	Textdata      *_bf.Textdata
}

func (_afada *Roundrect) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_afada.CT_RoundRect = *NewCT_RoundRect()
	for _, _deed := range start.Attr {
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "userdrawn" {
			_afada.UserdrawnAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "bordertopcolor" {
			_agbcf, _faegd := _deed.Value, error(nil)
			if _faegd != nil {
				return _faegd
			}
			_afada.BordertopcolorAttr = &_agbcf
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "userhidden" {
			_afada.UserhiddenAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "bullet" {
			_afada.BulletAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "cliptowrap" {
			_afada.CliptowrapAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "hr" {
			_afada.HrAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "ole" {
			_afada.OleAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "hrstd" {
			_afada.HrstdAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "spid" {
			_gdcea, _bccbe := _deed.Value, error(nil)
			if _bccbe != nil {
				return _bccbe
			}
			_afada.SpidAttr = &_gdcea
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "hrnoshade" {
			_afada.HrnoshadeAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "forcedash" {
			_afada.ForcedashAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "borderleftcolor" {
			_befda, _ddagg := _deed.Value, error(nil)
			if _ddagg != nil {
				return _ddagg
			}
			_afada.BorderleftcolorAttr = &_befda
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "dgmnodekind" {
			_faffg, _ccbff := _e.ParseInt(_deed.Value, 10, 64)
			if _ccbff != nil {
				return _ccbff
			}
			_afada.DgmnodekindAttr = &_faffg
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "oned" {
			_afada.OnedAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "clip" {
			_afada.ClipAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "hrpct" {
			_cffgeg, _gggef := _e.ParseFloat(_deed.Value, 64)
			if _gggef != nil {
				return _gggef
			}
			_cfece := float32(_cffgeg)
			_afada.HrpctAttr = &_cfece
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "preferrelative" {
			_afada.PreferrelativeAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "borderrightcolor" {
			_dfefff, _aacgd := _deed.Value, error(nil)
			if _aacgd != nil {
				return _aacgd
			}
			_afada.BorderrightcolorAttr = &_dfefff
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "regroupid" {
			_ceagc, _egfgcd := _e.ParseInt(_deed.Value, 10, 64)
			if _egfgcd != nil {
				return _egfgcd
			}
			_afada.RegroupidAttr = &_ceagc
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "dgmlayoutmru" {
			_afada.DgmlayoutmruAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "doubleclicknotify" {
			_afada.DoubleclicknotifyAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "allowoverlap" {
			_afada.AllowoverlapAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "hralign" {
			_afada.HralignAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "insetmode" {
			_afada.InsetmodeAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "spt" {
			_ggcgf, _bbcbd := _e.ParseFloat(_deed.Value, 64)
			if _bbcbd != nil {
				return _bbcbd
			}
			_bbdbe := float32(_ggcgf)
			_afada.SptAttr = &_bbdbe
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "borderbottomcolor" {
			_cffcf, _eagcg := _deed.Value, error(nil)
			if _eagcg != nil {
				return _eagcg
			}
			_afada.BorderbottomcolorAttr = &_cffcf
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "oleicon" {
			_afada.OleiconAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "dgmlayout" {
			_afada.DgmlayoutAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "bwmode" {
			_afada.BwmodeAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "bwnormal" {
			_afada.BwnormalAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "bwpure" {
			_afada.BwpureAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "connectortype" {
			_afada.ConnectortypeAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "button" {
			_afada.ButtonAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _deed.Name.Local == "allowincell" {
			_afada.AllowincellAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Local == "href" {
			_fabad, _cbaab := _deed.Value, error(nil)
			if _cbaab != nil {
				return _cbaab
			}
			_afada.HrefAttr = &_fabad
			continue
		}
		if _deed.Name.Local == "coordsize" {
			_bgdd, _deaga := _deed.Value, error(nil)
			if _deaga != nil {
				return _deaga
			}
			_afada.CoordsizeAttr = &_bgdd
			continue
		}
		if _deed.Name.Local == "style" {
			_egfcd, _fadaa := _deed.Value, error(nil)
			if _fadaa != nil {
				return _fadaa
			}
			_afada.StyleAttr = &_egfcd
			continue
		}
		if _deed.Name.Local == "stroked" {
			_afada.StrokedAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Local == "id" {
			_fbafe, _cadad := _deed.Value, error(nil)
			if _cadad != nil {
				return _cadad
			}
			_afada.IdAttr = &_fbafe
			continue
		}
		if _deed.Name.Local == "strokeweight" {
			_gcgbe, _ebebg := _deed.Value, error(nil)
			if _ebebg != nil {
				return _ebebg
			}
			_afada.StrokeweightAttr = &_gcgbe
			continue
		}
		if _deed.Name.Local == "print" {
			_afada.PrintAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Local == "chromakey" {
			_ccgee, _afbd := _deed.Value, error(nil)
			if _afbd != nil {
				return _afbd
			}
			_afada.ChromakeyAttr = &_ccgee
			continue
		}
		if _deed.Name.Local == "fillcolor" {
			_afefb, _egfeg := _deed.Value, error(nil)
			if _egfeg != nil {
				return _egfeg
			}
			_afada.FillcolorAttr = &_afefb
			continue
		}
		if _deed.Name.Local == "coordorigin" {
			_efafb, _aebeb := _deed.Value, error(nil)
			if _aebeb != nil {
				return _aebeb
			}
			_afada.CoordoriginAttr = &_efafb
			continue
		}
		if _deed.Name.Local == "opacity" {
			_adegb, _acfdd := _deed.Value, error(nil)
			if _acfdd != nil {
				return _acfdd
			}
			_afada.OpacityAttr = &_adegb
			continue
		}
		if _deed.Name.Local == "strokecolor" {
			_gdcca, _gebba := _deed.Value, error(nil)
			if _gebba != nil {
				return _gebba
			}
			_afada.StrokecolorAttr = &_gdcca
			continue
		}
		if _deed.Name.Local == "insetpen" {
			_afada.InsetpenAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Local == "filled" {
			_afada.FilledAttr.UnmarshalXMLAttr(_deed)
			continue
		}
		if _deed.Name.Local == "wrapcoords" {
			_dgaaf, _becdc := _deed.Value, error(nil)
			if _becdc != nil {
				return _becdc
			}
			_afada.WrapcoordsAttr = &_dgaaf
			continue
		}
		if _deed.Name.Local == "arcsize" {
			_bdcfaa, _agedae := _deed.Value, error(nil)
			if _agedae != nil {
				return _agedae
			}
			_afada.ArcsizeAttr = &_bdcfaa
			continue
		}
		if _deed.Name.Local == "title" {
			_bebeb, _agbbf := _deed.Value, error(nil)
			if _agbbf != nil {
				return _agbbf
			}
			_afada.TitleAttr = &_bebeb
			continue
		}
		if _deed.Name.Local == "class" {
			_bedcg, _fgdba := _deed.Value, error(nil)
			if _fgdba != nil {
				return _fgdba
			}
			_afada.ClassAttr = &_bedcg
			continue
		}
		if _deed.Name.Local == "target" {
			_adcde, _bdfac := _deed.Value, error(nil)
			if _bdfac != nil {
				return _bdfac
			}
			_afada.TargetAttr = &_adcde
			continue
		}
		if _deed.Name.Local == "alt" {
			_ebcdd, _gaaaag := _deed.Value, error(nil)
			if _gaaaag != nil {
				return _gaaaag
			}
			_afada.AltAttr = &_ebcdd
			continue
		}
	}
_deaaa:
	for {
		_ddbd, _fdfda := d.Token()
		if _fdfda != nil {
			return _fdfda
		}
		switch _aabce := _ddbd.(type) {
		case _b.StartElement:
			switch _aabce.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_cddgc := NewEG_ShapeElements()
				_cddgc.Path = NewPath()
				if _gedff := d.DecodeElement(_cddgc.Path, &_aabce); _gedff != nil {
					return _gedff
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _cddgc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_aafdcb := NewEG_ShapeElements()
				_aafdcb.Formulas = NewFormulas()
				if _fcgcb := d.DecodeElement(_aafdcb.Formulas, &_aabce); _fcgcb != nil {
					return _fcgcb
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _aafdcb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_ebcb := NewEG_ShapeElements()
				_ebcb.Handles = NewHandles()
				if _dgead := d.DecodeElement(_ebcb.Handles, &_aabce); _dgead != nil {
					return _dgead
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _ebcb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_aaagff := NewEG_ShapeElements()
				_aaagff.Fill = NewFill()
				if _gbegd := d.DecodeElement(_aaagff.Fill, &_aabce); _gbegd != nil {
					return _gbegd
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _aaagff)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_cbgbe := NewEG_ShapeElements()
				_cbgbe.Stroke = NewStroke()
				if _becf := d.DecodeElement(_cbgbe.Stroke, &_aabce); _becf != nil {
					return _becf
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _cbgbe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_cdabca := NewEG_ShapeElements()
				_cdabca.Shadow = NewShadow()
				if _ccgaa := d.DecodeElement(_cdabca.Shadow, &_aabce); _ccgaa != nil {
					return _ccgaa
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _cdabca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_ccfbb := NewEG_ShapeElements()
				_ccfbb.Textbox = NewTextbox()
				if _daeaa := d.DecodeElement(_ccfbb.Textbox, &_aabce); _daeaa != nil {
					return _daeaa
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _ccfbb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_aebcgc := NewEG_ShapeElements()
				_aebcgc.Textpath = NewTextpath()
				if _cfeaf := d.DecodeElement(_aebcgc.Textpath, &_aabce); _cfeaf != nil {
					return _cfeaf
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _aebcgc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_ffccd := NewEG_ShapeElements()
				_ffccd.Imagedata = NewImagedata()
				if _gebfd := d.DecodeElement(_ffccd.Imagedata, &_aabce); _gebfd != nil {
					return _gebfd
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _ffccd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_ccbcd := NewEG_ShapeElements()
				_ccbcd.Skew = NewOfcSkew()
				if _dcffa := d.DecodeElement(_ccbcd.Skew, &_aabce); _dcffa != nil {
					return _dcffa
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _ccbcd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_gfebbg := NewEG_ShapeElements()
				_gfebbg.Extrusion = NewOfcExtrusion()
				if _dcefe := d.DecodeElement(_gfebbg.Extrusion, &_aabce); _dcefe != nil {
					return _dcefe
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _gfebbg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_gbfca := NewEG_ShapeElements()
				_gbfca.Callout = NewOfcCallout()
				if _bbdcc := d.DecodeElement(_gbfca.Callout, &_aabce); _bbdcc != nil {
					return _bbdcc
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _gbfca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_fdagc := NewEG_ShapeElements()
				_fdagc.Lock = NewOfcLock()
				if _gagebe := d.DecodeElement(_fdagc.Lock, &_aabce); _gagebe != nil {
					return _gagebe
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _fdagc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_gbfef := NewEG_ShapeElements()
				_gbfef.Clippath = NewOfcClippath()
				if _eddac := d.DecodeElement(_gbfef.Clippath, &_aabce); _eddac != nil {
					return _eddac
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _gbfef)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_cfeea := NewEG_ShapeElements()
				_cfeea.Signatureline = NewOfcSignatureline()
				if _egebb := d.DecodeElement(_cfeea.Signatureline, &_aabce); _egebb != nil {
					return _egebb
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _cfeea)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_fccdf := NewEG_ShapeElements()
				_fccdf.Wrap = _a.NewWrap()
				if _aabad := d.DecodeElement(_fccdf.Wrap, &_aabce); _aabad != nil {
					return _aabad
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _fccdf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_agdcf := NewEG_ShapeElements()
				_agdcf.Anchorlock = _a.NewAnchorlock()
				if _debab := d.DecodeElement(_agdcf.Anchorlock, &_aabce); _debab != nil {
					return _debab
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _agdcf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_ggade := NewEG_ShapeElements()
				_ggade.Bordertop = _a.NewBordertop()
				if _edeff := d.DecodeElement(_ggade.Bordertop, &_aabce); _edeff != nil {
					return _edeff
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _ggade)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_cgaed := NewEG_ShapeElements()
				_cgaed.Borderbottom = _a.NewBorderbottom()
				if _fggbe := d.DecodeElement(_cgaed.Borderbottom, &_aabce); _fggbe != nil {
					return _fggbe
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _cgaed)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_deeba := NewEG_ShapeElements()
				_deeba.Borderleft = _a.NewBorderleft()
				if _gcbdd := d.DecodeElement(_deeba.Borderleft, &_aabce); _gcbdd != nil {
					return _gcbdd
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _deeba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_fgab := NewEG_ShapeElements()
				_fgab.Borderright = _a.NewBorderright()
				if _added := d.DecodeElement(_fgab.Borderright, &_aabce); _added != nil {
					return _added
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _fgab)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_ffbce := NewEG_ShapeElements()
				_ffbce.ClientData = _c.NewClientData()
				if _ecfbc := d.DecodeElement(_ffbce.ClientData, &_aabce); _ecfbc != nil {
					return _ecfbc
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _ffbce)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_becge := NewEG_ShapeElements()
				_becge.Textdata = _bf.NewTextdata()
				if _gbddff := d.DecodeElement(_becge.Textdata, &_aabce); _gbddff != nil {
					return _gbddff
				}
				_afada.EG_ShapeElements = append(_afada.EG_ShapeElements, _becge)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element on Roundrect \u0025v", _aabce.Name)
				if _aggbbb := d.Skip(); _aggbbb != nil {
					return _aggbbb
				}
			}
		case _b.EndElement:
			break _deaaa
		case _b.CharData:
		}
	}
	return nil
}
func (_bece *CT_Shape) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _gacbe := range start.Attr {
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "regroupid" {
			_gccd, _gdcbc := _e.ParseInt(_gacbe.Value, 10, 64)
			if _gdcbc != nil {
				return _gdcbc
			}
			_bece.RegroupidAttr = &_gccd
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "doubleclicknotify" {
			_bece.DoubleclicknotifyAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "clip" {
			_bece.ClipAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "button" {
			_bece.ButtonAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "userhidden" {
			_bece.UserhiddenAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "bullet" {
			_bece.BulletAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "gfxdata" {
			_cdeae, _aaeda := _gacbe.Value, error(nil)
			if _aaeda != nil {
				return _aaeda
			}
			_bece.GfxdataAttr = &_cdeae
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "hr" {
			_bece.HrAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "ole" {
			_bece.OleAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "allowincell" {
			_bece.AllowincellAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "borderleftcolor" {
			_gbebd, _gfggb := _gacbe.Value, error(nil)
			if _gfggb != nil {
				return _gfggb
			}
			_bece.BorderleftcolorAttr = &_gbebd
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "hrpct" {
			_fdddb, _dgcg := _e.ParseFloat(_gacbe.Value, 64)
			if _dgcg != nil {
				return _dgcg
			}
			_cadgcb := float32(_fdddb)
			_bece.HrpctAttr = &_cadgcb
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "dgmnodekind" {
			_dgbbb, _bgafb := _e.ParseInt(_gacbe.Value, 10, 64)
			if _bgafb != nil {
				return _bgafb
			}
			_bece.DgmnodekindAttr = &_dgbbb
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "insetmode" {
			_bece.InsetmodeAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "userdrawn" {
			_bece.UserdrawnAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "connectortype" {
			_bece.ConnectortypeAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "borderrightcolor" {
			_fgac, _cdbgg := _gacbe.Value, error(nil)
			if _cdbgg != nil {
				return _cdbgg
			}
			_bece.BorderrightcolorAttr = &_fgac
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "preferrelative" {
			_bece.PreferrelativeAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "hrnoshade" {
			_bece.HrnoshadeAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "dgmlayoutmru" {
			_bece.DgmlayoutmruAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "oned" {
			_bece.OnedAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "hralign" {
			_bece.HralignAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "bwmode" {
			_bece.BwmodeAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "allowoverlap" {
			_bece.AllowoverlapAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "bordertopcolor" {
			_abfd, _acdb := _gacbe.Value, error(nil)
			if _acdb != nil {
				return _acdb
			}
			_bece.BordertopcolorAttr = &_abfd
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "bwnormal" {
			_bece.BwnormalAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "borderbottomcolor" {
			_ecbeg, _bacba := _gacbe.Value, error(nil)
			if _bacba != nil {
				return _bacba
			}
			_bece.BorderbottomcolorAttr = &_ecbeg
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "cliptowrap" {
			_bece.CliptowrapAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "dgmlayout" {
			_bece.DgmlayoutAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "spt" {
			_cgbae, _abaf := _e.ParseFloat(_gacbe.Value, 64)
			if _abaf != nil {
				return _abaf
			}
			_dgada := float32(_cgbae)
			_bece.SptAttr = &_dgada
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "oleicon" {
			_bece.OleiconAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "forcedash" {
			_bece.ForcedashAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "bwpure" {
			_bece.BwpureAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "spid" {
			_gabbe, _efde := _gacbe.Value, error(nil)
			if _efde != nil {
				return _efde
			}
			_bece.SpidAttr = &_gabbe
			continue
		}
		if _gacbe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gacbe.Name.Local == "hrstd" {
			_bece.HrstdAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Local == "target" {
			_gbaag, _cbddd := _gacbe.Value, error(nil)
			if _cbddd != nil {
				return _cbddd
			}
			_bece.TargetAttr = &_gbaag
			continue
		}
		if _gacbe.Name.Local == "wrapcoords" {
			_gdfge, _bfaec := _gacbe.Value, error(nil)
			if _bfaec != nil {
				return _bfaec
			}
			_bece.WrapcoordsAttr = &_gdfge
			continue
		}
		if _gacbe.Name.Local == "opacity" {
			_gbeff, _fcfaf := _gacbe.Value, error(nil)
			if _fcfaf != nil {
				return _fcfaf
			}
			_bece.OpacityAttr = &_gbeff
			continue
		}
		if _gacbe.Name.Local == "coordorigin" {
			_fbbef, _dacfd := _gacbe.Value, error(nil)
			if _dacfd != nil {
				return _dacfd
			}
			_bece.CoordoriginAttr = &_fbbef
			continue
		}
		if _gacbe.Name.Local == "strokecolor" {
			_aaeeg, _eggb := _gacbe.Value, error(nil)
			if _eggb != nil {
				return _eggb
			}
			_bece.StrokecolorAttr = &_aaeeg
			continue
		}
		if _gacbe.Name.Local == "coordsize" {
			_dgcb, _ggebb := _gacbe.Value, error(nil)
			if _ggebb != nil {
				return _ggebb
			}
			_bece.CoordsizeAttr = &_dgcb
			continue
		}
		if _gacbe.Name.Local == "insetpen" {
			_bece.InsetpenAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Local == "alt" {
			_agace, _ffcec := _gacbe.Value, error(nil)
			if _ffcec != nil {
				return _ffcec
			}
			_bece.AltAttr = &_agace
			continue
		}
		if _gacbe.Name.Local == "filled" {
			_bece.FilledAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Local == "title" {
			_fece, _eaaaf := _gacbe.Value, error(nil)
			if _eaaaf != nil {
				return _eaaaf
			}
			_bece.TitleAttr = &_fece
			continue
		}
		if _gacbe.Name.Local == "style" {
			_eadbb, _bdgdg := _gacbe.Value, error(nil)
			if _bdgdg != nil {
				return _bdgdg
			}
			_bece.StyleAttr = &_eadbb
			continue
		}
		if _gacbe.Name.Local == "print" {
			_bece.PrintAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Local == "stroked" {
			_bece.StrokedAttr.UnmarshalXMLAttr(_gacbe)
			continue
		}
		if _gacbe.Name.Local == "strokeweight" {
			_accd, _dcad := _gacbe.Value, error(nil)
			if _dcad != nil {
				return _dcad
			}
			_bece.StrokeweightAttr = &_accd
			continue
		}
		if _gacbe.Name.Local == "chromakey" {
			_aefgg, _cgabb := _gacbe.Value, error(nil)
			if _cgabb != nil {
				return _cgabb
			}
			_bece.ChromakeyAttr = &_aefgg
			continue
		}
		if _gacbe.Name.Local == "path" {
			_fdcgc, _gdcdf := _gacbe.Value, error(nil)
			if _gdcdf != nil {
				return _gdcdf
			}
			_bece.PathAttr = &_fdcgc
			continue
		}
		if _gacbe.Name.Local == "id" {
			_gfffa, _fffd := _gacbe.Value, error(nil)
			if _fffd != nil {
				return _fffd
			}
			_bece.IdAttr = &_gfffa
			continue
		}
		if _gacbe.Name.Local == "class" {
			_afaf, _abccd := _gacbe.Value, error(nil)
			if _abccd != nil {
				return _abccd
			}
			_bece.ClassAttr = &_afaf
			continue
		}
		if _gacbe.Name.Local == "href" {
			_bcbad, _afaea := _gacbe.Value, error(nil)
			if _afaea != nil {
				return _afaea
			}
			_bece.HrefAttr = &_bcbad
			continue
		}
		if _gacbe.Name.Local == "equationxml" {
			_gfeaf, _eaded := _gacbe.Value, error(nil)
			if _eaded != nil {
				return _eaded
			}
			_bece.EquationxmlAttr = &_gfeaf
			continue
		}
		if _gacbe.Name.Local == "type" {
			_bebc, _eagbe := _gacbe.Value, error(nil)
			if _eagbe != nil {
				return _eagbe
			}
			_bece.TypeAttr = &_bebc
			continue
		}
		if _gacbe.Name.Local == "adj" {
			_bbbfc, _befbdf := _gacbe.Value, error(nil)
			if _befbdf != nil {
				return _befbdf
			}
			_bece.AdjAttr = &_bbbfc
			continue
		}
		if _gacbe.Name.Local == "fillcolor" {
			_edeba, _dacb := _gacbe.Value, error(nil)
			if _dacb != nil {
				return _dacb
			}
			_bece.FillcolorAttr = &_edeba
			continue
		}
	}
_ffeg:
	for {
		_ggae, _cbdefa := d.Token()
		if _cbdefa != nil {
			return _cbdefa
		}
		switch _ffbg := _ggae.(type) {
		case _b.StartElement:
			switch _ffbg.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "ink"}:
				_cfgdb := NewOfcInk()
				if _bfdfa := d.DecodeElement(_cfgdb, &_ffbg); _bfdfa != nil {
					return _bfdfa
				}
				_bece.Ink = append(_bece.Ink, _cfgdb)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "iscomment"}:
				_cffba := _bf.NewIscomment()
				if _bfbdg := d.DecodeElement(_cffba, &_ffbg); _bfbdg != nil {
					return _bfbdg
				}
				_bece.Iscomment = append(_bece.Iscomment, _cffba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "equationxml"}:
				_eadba := NewOfcEquationxml()
				if _agbg := d.DecodeElement(_eadba, &_ffbg); _agbg != nil {
					return _agbg
				}
				_bece.Equationxml = append(_bece.Equationxml, _eadba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_gbagc := NewEG_ShapeElements()
				_gbagc.Path = NewPath()
				if _ddbgb := d.DecodeElement(_gbagc.Path, &_ffbg); _ddbgb != nil {
					return _ddbgb
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _gbagc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_cdbc := NewEG_ShapeElements()
				_cdbc.Formulas = NewFormulas()
				if _dabge := d.DecodeElement(_cdbc.Formulas, &_ffbg); _dabge != nil {
					return _dabge
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _cdbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_acba := NewEG_ShapeElements()
				_acba.Handles = NewHandles()
				if _gbdff := d.DecodeElement(_acba.Handles, &_ffbg); _gbdff != nil {
					return _gbdff
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _acba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_egdbb := NewEG_ShapeElements()
				_egdbb.Fill = NewFill()
				if _cagf := d.DecodeElement(_egdbb.Fill, &_ffbg); _cagf != nil {
					return _cagf
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _egdbb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_gdddcb := NewEG_ShapeElements()
				_gdddcb.Stroke = NewStroke()
				if _ffgc := d.DecodeElement(_gdddcb.Stroke, &_ffbg); _ffgc != nil {
					return _ffgc
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _gdddcb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_gbaede := NewEG_ShapeElements()
				_gbaede.Shadow = NewShadow()
				if _abed := d.DecodeElement(_gbaede.Shadow, &_ffbg); _abed != nil {
					return _abed
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _gbaede)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_beddb := NewEG_ShapeElements()
				_beddb.Textbox = NewTextbox()
				if _ebcdf := d.DecodeElement(_beddb.Textbox, &_ffbg); _ebcdf != nil {
					return _ebcdf
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _beddb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_gggbd := NewEG_ShapeElements()
				_gggbd.Textpath = NewTextpath()
				if _feed := d.DecodeElement(_gggbd.Textpath, &_ffbg); _feed != nil {
					return _feed
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _gggbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_bcdbg := NewEG_ShapeElements()
				_bcdbg.Imagedata = NewImagedata()
				if _dacg := d.DecodeElement(_bcdbg.Imagedata, &_ffbg); _dacg != nil {
					return _dacg
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _bcdbg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_dbgac := NewEG_ShapeElements()
				_dbgac.Skew = NewOfcSkew()
				if _aacdd := d.DecodeElement(_dbgac.Skew, &_ffbg); _aacdd != nil {
					return _aacdd
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _dbgac)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_ddbc := NewEG_ShapeElements()
				_ddbc.Extrusion = NewOfcExtrusion()
				if _cdbf := d.DecodeElement(_ddbc.Extrusion, &_ffbg); _cdbf != nil {
					return _cdbf
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _ddbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_afaaa := NewEG_ShapeElements()
				_afaaa.Callout = NewOfcCallout()
				if _ddfa := d.DecodeElement(_afaaa.Callout, &_ffbg); _ddfa != nil {
					return _ddfa
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _afaaa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_dgfc := NewEG_ShapeElements()
				_dgfc.Lock = NewOfcLock()
				if _acega := d.DecodeElement(_dgfc.Lock, &_ffbg); _acega != nil {
					return _acega
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _dgfc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_cgbeg := NewEG_ShapeElements()
				_cgbeg.Clippath = NewOfcClippath()
				if _cega := d.DecodeElement(_cgbeg.Clippath, &_ffbg); _cega != nil {
					return _cega
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _cgbeg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_cegc := NewEG_ShapeElements()
				_cegc.Signatureline = NewOfcSignatureline()
				if _efabbb := d.DecodeElement(_cegc.Signatureline, &_ffbg); _efabbb != nil {
					return _efabbb
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _cegc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_faeb := NewEG_ShapeElements()
				_faeb.Wrap = _a.NewWrap()
				if _egead := d.DecodeElement(_faeb.Wrap, &_ffbg); _egead != nil {
					return _egead
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _faeb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_eadde := NewEG_ShapeElements()
				_eadde.Anchorlock = _a.NewAnchorlock()
				if _cacfe := d.DecodeElement(_eadde.Anchorlock, &_ffbg); _cacfe != nil {
					return _cacfe
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _eadde)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_cbfc := NewEG_ShapeElements()
				_cbfc.Bordertop = _a.NewBordertop()
				if _fafaf := d.DecodeElement(_cbfc.Bordertop, &_ffbg); _fafaf != nil {
					return _fafaf
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _cbfc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_gbfdd := NewEG_ShapeElements()
				_gbfdd.Borderbottom = _a.NewBorderbottom()
				if _aeacg := d.DecodeElement(_gbfdd.Borderbottom, &_ffbg); _aeacg != nil {
					return _aeacg
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _gbfdd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_cdfed := NewEG_ShapeElements()
				_cdfed.Borderleft = _a.NewBorderleft()
				if _badcb := d.DecodeElement(_cdfed.Borderleft, &_ffbg); _badcb != nil {
					return _badcb
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _cdfed)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_effdd := NewEG_ShapeElements()
				_effdd.Borderright = _a.NewBorderright()
				if _cdddc := d.DecodeElement(_effdd.Borderright, &_ffbg); _cdddc != nil {
					return _cdddc
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _effdd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_ebdba := NewEG_ShapeElements()
				_ebdba.ClientData = _c.NewClientData()
				if _gcgc := d.DecodeElement(_ebdba.ClientData, &_ffbg); _gcgc != nil {
					return _gcgc
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _ebdba)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_efdcb := NewEG_ShapeElements()
				_efdcb.Textdata = _bf.NewTextdata()
				if _cfdfg := d.DecodeElement(_efdcb.Textdata, &_ffbg); _cfdfg != nil {
					return _cfdfg
				}
				_bece.EG_ShapeElements = append(_bece.EG_ShapeElements, _efdcb)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Shape\u0020\u0025v", _ffbg.Name)
				if _bcfac := d.Skip(); _bcfac != nil {
					return _bcfac
				}
			}
		case _b.EndElement:
			break _ffeg
		case _b.CharData:
		}
	}
	return nil
}

type Line struct{ CT_Line }

func (_eacbe *ST_StrokeLineStyle) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_eecdgd, _gbdde := d.Token()
	if _gbdde != nil {
		return _gbdde
	}
	if _fdegbc, _gdbac := _eecdgd.(_b.EndElement); _gdbac && _fdegbc.Name == start.Name {
		*_eacbe = 1
		return nil
	}
	if _effeg, _gcaac := _eecdgd.(_b.CharData); !_gcaac {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _eecdgd)
	} else {
		switch string(_effeg) {
		case "":
			*_eacbe = 0
		case "single":
			*_eacbe = 1
		case "thinThin":
			*_eacbe = 2
		case "thinThick":
			*_eacbe = 3
		case "thickThin":
			*_eacbe = 4
		case "thickBetweenThin":
			*_eacbe = 5
		}
	}
	_eecdgd, _gbdde = d.Token()
	if _gbdde != nil {
		return _gbdde
	}
	if _cdagf, _acfbc := _eecdgd.(_b.EndElement); _acfbc && _cdagf.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _eecdgd)
}
func (_acgfe *OfcCT_R) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bbaac := range start.Attr {
		if _bbaac.Name.Local == "id" {
			_gbecc, _dacbb := _bbaac.Value, error(nil)
			if _dacbb != nil {
				return _dacbb
			}
			_acgfe.IdAttr = _gbecc
			continue
		}
		if _bbaac.Name.Local == "type" {
			_acgfe.TypeAttr.UnmarshalXMLAttr(_bbaac)
			continue
		}
		if _bbaac.Name.Local == "how" {
			_acgfe.HowAttr.UnmarshalXMLAttr(_bbaac)
			continue
		}
		if _bbaac.Name.Local == "idref" {
			_fgcgf, _dcbec := _bbaac.Value, error(nil)
			if _dcbec != nil {
				return _dcbec
			}
			_acgfe.IdrefAttr = &_fgcgf
			continue
		}
	}
_ggead:
	for {
		_adbba, _afafa := d.Token()
		if _afafa != nil {
			return _afafa
		}
		switch _abcfb := _adbba.(type) {
		case _b.StartElement:
			switch _abcfb.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "proxy"}:
				_gbbaf := NewOfcCT_Proxy()
				if _dfdgg := d.DecodeElement(_gbbaf, &_abcfb); _dfdgg != nil {
					return _dfdgg
				}
				_acgfe.Proxy = append(_acgfe.Proxy, _gbbaf)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020OfcCT_R\u0020\u0025v", _abcfb.Name)
				if _bfcbf := d.Skip(); _bfcbf != nil {
					return _bfcbf
				}
			}
		case _b.EndElement:
			break _ggead
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the OfcBottom and its children, prefixing error messages with path
func (_efgeed *OfcBottom) ValidateWithPath(path string) error {
	if _fccba := _efgeed.OfcCT_StrokeChild.ValidateWithPath(path); _fccba != nil {
		return _fccba
	}
	return nil
}
func NewOfcSignatureline() *OfcSignatureline {
	_eefgd := &OfcSignatureline{}
	_eefgd.OfcCT_SignatureLine = *NewOfcCT_SignatureLine()
	return _eefgd
}
func NewOfcCT_Skew() *OfcCT_Skew { _eaed := &OfcCT_Skew{}; return _eaed }
func NewCT_F() *CT_F             { _ecbc := &CT_F{}; return _ecbc }
func (_fgcacaf *OfcColumn) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:column"
	return _fgcacaf.OfcCT_StrokeChild.MarshalXML(e, start)
}
func (_eccad OfcST_ExtrusionRender) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_egeea := _b.Attr{}
	_egeea.Name = name
	switch _eccad {
	case OfcST_ExtrusionRenderUnset:
		_egeea.Value = ""
	case OfcST_ExtrusionRenderSolid:
		_egeea.Value = "solid"
	case OfcST_ExtrusionRenderWireFrame:
		_egeea.Value = "wireFrame"
	case OfcST_ExtrusionRenderBoundingCube:
		_egeea.Value = "boundingCube"
	}
	return _egeea, nil
}
func (_faefa *OfcOLEObject) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:OLEObject"
	return _faefa.OfcCT_OLEObject.MarshalXML(e, start)
}
func (_aegedb OfcST_HrAlign) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_aegedb.String(), start)
}
func (_edbebd OfcST_ExtrusionType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_edbebd.String(), start)
}
func (_faaee *OfcST_HrAlign) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bbfge, _ecfeb := d.Token()
	if _ecfeb != nil {
		return _ecfeb
	}
	if _ebafe, _ceaf := _bbfge.(_b.EndElement); _ceaf && _ebafe.Name == start.Name {
		*_faaee = 1
		return nil
	}
	if _geacc, _gacgc := _bbfge.(_b.CharData); !_gacgc {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bbfge)
	} else {
		switch string(_geacc) {
		case "":
			*_faaee = 0
		case "left":
			*_faaee = 1
		case "right":
			*_faaee = 2
		case "center":
			*_faaee = 3
		}
	}
	_bbfge, _ecfeb = d.Token()
	if _ecfeb != nil {
		return _ecfeb
	}
	if _aggc, _afefe := _bbfge.(_b.EndElement); _afefe && _aggc.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bbfge)
}
func (_debac *OfcST_OLEUpdateMode) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_debac = 0
	case "Always":
		*_debac = 1
	case "OnCall":
		*_debac = 2
	}
	return nil
}
func (_dcaefe OfcST_ConnectorType) Validate() error { return _dcaefe.ValidateWithPath("") }
func (_ceac *CT_Rect) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ceac.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_ceac.HrefAttr)})
	}
	if _ceac.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_ceac.TargetAttr)})
	}
	if _ceac.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_ceac.ClassAttr)})
	}
	if _ceac.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_ceac.TitleAttr)})
	}
	if _ceac.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_ceac.AltAttr)})
	}
	if _ceac.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_ceac.CoordsizeAttr)})
	}
	if _ceac.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_ceac.CoordoriginAttr)})
	}
	if _ceac.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_ceac.WrapcoordsAttr)})
	}
	if _ceac.PrintAttr != _eb.ST_TrueFalseUnset {
		_dfecb, _bddae := _ceac.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _bddae != nil {
			return _bddae
		}
		start.Attr = append(start.Attr, _dfecb)
	}
	if _ceac.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_ceac.IdAttr)})
	}
	if _ceac.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_ceac.StyleAttr)})
	}
	if _ceac.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_ceac.SpidAttr)})
	}
	if _ceac.OnedAttr != _eb.ST_TrueFalseUnset {
		_acce, _bbcc := _ceac.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _bbcc != nil {
			return _bbcc
		}
		start.Attr = append(start.Attr, _acce)
	}
	if _ceac.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_ceac.RegroupidAttr)})
	}
	if _ceac.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_geecf, _bdfag := _ceac.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _bdfag != nil {
			return _bdfag
		}
		start.Attr = append(start.Attr, _geecf)
	}
	if _ceac.ButtonAttr != _eb.ST_TrueFalseUnset {
		_fceb, _degc := _ceac.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _degc != nil {
			return _degc
		}
		start.Attr = append(start.Attr, _fceb)
	}
	if _ceac.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_bfcaf, _adbbb := _ceac.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _adbbb != nil {
			return _adbbb
		}
		start.Attr = append(start.Attr, _bfcaf)
	}
	if _ceac.BulletAttr != _eb.ST_TrueFalseUnset {
		_agabd, _gegf := _ceac.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _gegf != nil {
			return _gegf
		}
		start.Attr = append(start.Attr, _agabd)
	}
	if _ceac.HrAttr != _eb.ST_TrueFalseUnset {
		_dfbbc, _dgde := _ceac.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _dgde != nil {
			return _dgde
		}
		start.Attr = append(start.Attr, _dfbbc)
	}
	if _ceac.HrstdAttr != _eb.ST_TrueFalseUnset {
		_fddcf, _ccbbe := _ceac.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _ccbbe != nil {
			return _ccbbe
		}
		start.Attr = append(start.Attr, _fddcf)
	}
	if _ceac.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_efagc, _aeda := _ceac.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _aeda != nil {
			return _aeda
		}
		start.Attr = append(start.Attr, _efagc)
	}
	if _ceac.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_ceac.HrpctAttr)})
	}
	if _ceac.HralignAttr != OfcST_HrAlignUnset {
		_fccgg, _ebgca := _ceac.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _ebgca != nil {
			return _ebgca
		}
		start.Attr = append(start.Attr, _fccgg)
	}
	if _ceac.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_aeaa, _fbcd := _ceac.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _fbcd != nil {
			return _fbcd
		}
		start.Attr = append(start.Attr, _aeaa)
	}
	if _ceac.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_ddfdd, _cacgb := _ceac.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _cacgb != nil {
			return _cacgb
		}
		start.Attr = append(start.Attr, _ddfdd)
	}
	if _ceac.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_affab, _edcad := _ceac.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _edcad != nil {
			return _edcad
		}
		start.Attr = append(start.Attr, _affab)
	}
	if _ceac.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_ceac.BordertopcolorAttr)})
	}
	if _ceac.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_ceac.BorderleftcolorAttr)})
	}
	if _ceac.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_ceac.BorderbottomcolorAttr)})
	}
	if _ceac.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_ceac.BorderrightcolorAttr)})
	}
	if _ceac.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_fbdfb, _gabcb := _ceac.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _gabcb != nil {
			return _gabcb
		}
		start.Attr = append(start.Attr, _fbdfb)
	}
	if _ceac.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_ceac.DgmnodekindAttr)})
	}
	if _ceac.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_caba, _bbcac := _ceac.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _bbcac != nil {
			return _bbcac
		}
		start.Attr = append(start.Attr, _caba)
	}
	if _ceac.InsetmodeAttr != OfcST_InsetModeUnset {
		_ebfa, _gbede := _ceac.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _gbede != nil {
			return _gbede
		}
		start.Attr = append(start.Attr, _ebfa)
	}
	if _ceac.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_ceac.OpacityAttr)})
	}
	if _ceac.StrokedAttr != _eb.ST_TrueFalseUnset {
		_gfcgf, _dgfe := _ceac.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _dgfe != nil {
			return _dgfe
		}
		start.Attr = append(start.Attr, _gfcgf)
	}
	if _ceac.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_ceac.StrokecolorAttr)})
	}
	if _ceac.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_ceac.StrokeweightAttr)})
	}
	if _ceac.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_aebe, _gfdce := _ceac.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _gfdce != nil {
			return _gfdce
		}
		start.Attr = append(start.Attr, _aebe)
	}
	if _ceac.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_ceac.ChromakeyAttr)})
	}
	if _ceac.FilledAttr != _eb.ST_TrueFalseUnset {
		_ddagf, _ebgfe := _ceac.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _ebgfe != nil {
			return _ebgfe
		}
		start.Attr = append(start.Attr, _ddagf)
	}
	if _ceac.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_ceac.FillcolorAttr)})
	}
	if _ceac.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_ceac.SptAttr)})
	}
	if _ceac.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_feee, _bfafg := _ceac.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _bfafg != nil {
			return _bfafg
		}
		start.Attr = append(start.Attr, _feee)
	}
	if _ceac.BwmodeAttr != OfcST_BWModeUnset {
		_afeb, _cgag := _ceac.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _cgag != nil {
			return _cgag
		}
		start.Attr = append(start.Attr, _afeb)
	}
	if _ceac.BwpureAttr != OfcST_BWModeUnset {
		_dfgde, _aebd := _ceac.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _aebd != nil {
			return _aebd
		}
		start.Attr = append(start.Attr, _dfgde)
	}
	if _ceac.BwnormalAttr != OfcST_BWModeUnset {
		_ddad, _dffg := _ceac.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _dffg != nil {
			return _dffg
		}
		start.Attr = append(start.Attr, _ddad)
	}
	if _ceac.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_fgec, _gfcga := _ceac.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _gfcga != nil {
			return _gfcga
		}
		start.Attr = append(start.Attr, _fgec)
	}
	if _ceac.OleiconAttr != _eb.ST_TrueFalseUnset {
		_ebafab, _abdg := _ceac.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _abdg != nil {
			return _abdg
		}
		start.Attr = append(start.Attr, _ebafab)
	}
	if _ceac.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_ggegd, _ebcc := _ceac.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _ebcc != nil {
			return _ebcc
		}
		start.Attr = append(start.Attr, _ggegd)
	}
	if _ceac.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_fbde, _cbed := _ceac.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _cbed != nil {
			return _cbed
		}
		start.Attr = append(start.Attr, _fbde)
	}
	if _ceac.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_bgcga, _aacc := _ceac.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _aacc != nil {
			return _aacc
		}
		start.Attr = append(start.Attr, _bgcga)
	}
	if _ceac.ClipAttr != _eb.ST_TrueFalseUnset {
		_bfaef, _adbeb := _ceac.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _adbeb != nil {
			return _adbeb
		}
		start.Attr = append(start.Attr, _bfaef)
	}
	e.EncodeToken(start)
	if _ceac.EG_ShapeElements != nil {
		for _, _bfge := range _ceac.EG_ShapeElements {
			_bfge.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Oval and its children, prefixing error messages with path
func (_bfbfe *Oval) ValidateWithPath(path string) error {
	if _gggec := _bfbfe.CT_Oval.ValidateWithPath(path); _gggec != nil {
		return _gggec
	}
	return nil
}
func (_eceg *AG_OfficeCoreAttributes) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _eceg.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_eceg.SpidAttr)})
	}
	if _eceg.OnedAttr != _eb.ST_TrueFalseUnset {
		_agc, _aaffg := _eceg.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _aaffg != nil {
			return _aaffg
		}
		start.Attr = append(start.Attr, _agc)
	}
	if _eceg.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_eceg.RegroupidAttr)})
	}
	if _eceg.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_eac, _dae := _eceg.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _dae != nil {
			return _dae
		}
		start.Attr = append(start.Attr, _eac)
	}
	if _eceg.ButtonAttr != _eb.ST_TrueFalseUnset {
		_gdeg, _gac := _eceg.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _gac != nil {
			return _gac
		}
		start.Attr = append(start.Attr, _gdeg)
	}
	if _eceg.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_cbc, _cce := _eceg.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _cce != nil {
			return _cce
		}
		start.Attr = append(start.Attr, _cbc)
	}
	if _eceg.BulletAttr != _eb.ST_TrueFalseUnset {
		_ffe, _fadd := _eceg.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _fadd != nil {
			return _fadd
		}
		start.Attr = append(start.Attr, _ffe)
	}
	if _eceg.HrAttr != _eb.ST_TrueFalseUnset {
		_acad, _adda := _eceg.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _adda != nil {
			return _adda
		}
		start.Attr = append(start.Attr, _acad)
	}
	if _eceg.HrstdAttr != _eb.ST_TrueFalseUnset {
		_dabc, _eab := _eceg.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _eab != nil {
			return _eab
		}
		start.Attr = append(start.Attr, _dabc)
	}
	if _eceg.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_efge, _feaa := _eceg.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _feaa != nil {
			return _feaa
		}
		start.Attr = append(start.Attr, _efge)
	}
	if _eceg.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_eceg.HrpctAttr)})
	}
	if _eceg.HralignAttr != OfcST_HrAlignUnset {
		_ebac, _gebg := _eceg.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _gebg != nil {
			return _gebg
		}
		start.Attr = append(start.Attr, _ebac)
	}
	if _eceg.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_efab, _bfcb := _eceg.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _bfcb != nil {
			return _bfcb
		}
		start.Attr = append(start.Attr, _efab)
	}
	if _eceg.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_ecce, _daf := _eceg.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _daf != nil {
			return _daf
		}
		start.Attr = append(start.Attr, _ecce)
	}
	if _eceg.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_gcdd, _edg := _eceg.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _edg != nil {
			return _edg
		}
		start.Attr = append(start.Attr, _gcdd)
	}
	if _eceg.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_eceg.BordertopcolorAttr)})
	}
	if _eceg.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_eceg.BorderleftcolorAttr)})
	}
	if _eceg.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_eceg.BorderbottomcolorAttr)})
	}
	if _eceg.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_eceg.BorderrightcolorAttr)})
	}
	if _eceg.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_ceg, _ecaa := _eceg.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _ecaa != nil {
			return _ecaa
		}
		start.Attr = append(start.Attr, _ceg)
	}
	if _eceg.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_eceg.DgmnodekindAttr)})
	}
	if _eceg.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_bdbg, _gcbe := _eceg.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _gcbe != nil {
			return _gcbe
		}
		start.Attr = append(start.Attr, _bdbg)
	}
	if _eceg.InsetmodeAttr != OfcST_InsetModeUnset {
		_gag, _bfef := _eceg.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _bfef != nil {
			return _bfef
		}
		start.Attr = append(start.Attr, _gag)
	}
	return nil
}

const (
	OfcST_RTypeUnset     OfcST_RType = 0
	OfcST_RTypeArc       OfcST_RType = 1
	OfcST_RTypeCallout   OfcST_RType = 2
	OfcST_RTypeConnector OfcST_RType = 3
	OfcST_RTypeAlign     OfcST_RType = 4
)

func (_efcgc *OfcST_BWMode) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_efcgc = 0
	case "color":
		*_efcgc = 1
	case "auto":
		*_efcgc = 2
	case "grayScale":
		*_efcgc = 3
	case "lightGrayscale":
		*_efcgc = 4
	case "inverseGray":
		*_efcgc = 5
	case "grayOutline":
		*_efcgc = 6
	case "highContrast":
		*_efcgc = 7
	case "black":
		*_efcgc = 8
	case "white":
		*_efcgc = 9
	case "hide":
		*_efcgc = 10
	case "undrawn":
		*_efcgc = 11
	case "blackTextAndLines":
		*_efcgc = 12
	}
	return nil
}
func (_fgbfgg *OfcInk) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:ink"
	return _fgbfgg.OfcCT_Ink.MarshalXML(e, start)
}

// Validate validates the OfcCT_RelationTable and its children
func (_fgdbc *OfcCT_RelationTable) Validate() error {
	return _fgdbc.ValidateWithPath("OfcCT_RelationTable")
}

// ValidateWithPath validates the OfcComplex and its children, prefixing error messages with path
func (_gdfdc *OfcComplex) ValidateWithPath(path string) error {
	if _gbdg := _gdfdc.OfcCT_Complex.ValidateWithPath(path); _gbdg != nil {
		return _gbdg
	}
	return nil
}
func (_edegb ST_StrokeArrowWidth) ValidateWithPath(path string) error {
	switch _edegb {
	case 0, 1, 2, 3:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_edegb))
	}
	return nil
}
func (_aafce ST_StrokeLineStyle) Validate() error { return _aafce.ValidateWithPath("") }

// Validate validates the OfcLeft and its children
func (_dcffea *OfcLeft) Validate() error           { return _dcffea.ValidateWithPath("OfcLeft") }
func (_becfb OfcST_DiagramLayout) Validate() error { return _becfb.ValidateWithPath("") }

type OfcCT_Entry struct {
	NewAttr *int32
	OldAttr *int32
}

func (_gfegb ST_FillType) String() string {
	switch _gfegb {
	case 0:
		return ""
	case 1:
		return "solid"
	case 2:
		return "gradient"
	case 3:
		return "gradientRadial"
	case 4:
		return "tile"
	case 5:
		return "pattern"
	case 6:
		return "frame"
	}
	return ""
}
func (_gdebe *Path) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _gdebe.CT_Path.MarshalXML(e, start)
}

// ValidateWithPath validates the Textbox and its children, prefixing error messages with path
func (_eebe *Textbox) ValidateWithPath(path string) error {
	if _agfa := _eebe.CT_Textbox.ValidateWithPath(path); _agfa != nil {
		return _agfa
	}
	return nil
}

type AG_Type struct{ TypeAttr *string }

func (_ecda OfcST_Angle) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_cfedd := _b.Attr{}
	_cfedd.Name = name
	switch _ecda {
	case OfcST_AngleUnset:
		_cfedd.Value = ""
	case OfcST_AngleAny:
		_cfedd.Value = "any"
	case OfcST_Angle30:
		_cfedd.Value = "30"
	case OfcST_Angle45:
		_cfedd.Value = "45"
	case OfcST_Angle60:
		_cfedd.Value = "60"
	case OfcST_Angle90:
		_cfedd.Value = "90"
	case OfcST_AngleAuto:
		_cfedd.Value = "auto"
	}
	return _cfedd, nil
}
func (_acbbcf OfcST_OLEDrawAspect) String() string {
	switch _acbbcf {
	case 0:
		return ""
	case 1:
		return "Content"
	case 2:
		return "Icon"
	}
	return ""
}
func (_ddage *CT_Line) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ddage.FromAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "from"}, Value: _f.Sprintf("\u0025v", *_ddage.FromAttr)})
	}
	if _ddage.ToAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "to"}, Value: _f.Sprintf("\u0025v", *_ddage.ToAttr)})
	}
	if _ddage.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_ddage.HrefAttr)})
	}
	if _ddage.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_ddage.TargetAttr)})
	}
	if _ddage.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_ddage.ClassAttr)})
	}
	if _ddage.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_ddage.TitleAttr)})
	}
	if _ddage.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_ddage.AltAttr)})
	}
	if _ddage.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_ddage.CoordsizeAttr)})
	}
	if _ddage.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_ddage.CoordoriginAttr)})
	}
	if _ddage.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_ddage.WrapcoordsAttr)})
	}
	if _ddage.PrintAttr != _eb.ST_TrueFalseUnset {
		_dbga, _aaea := _ddage.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _aaea != nil {
			return _aaea
		}
		start.Attr = append(start.Attr, _dbga)
	}
	if _ddage.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_ddage.IdAttr)})
	}
	if _ddage.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_ddage.StyleAttr)})
	}
	if _ddage.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_ddage.SpidAttr)})
	}
	if _ddage.OnedAttr != _eb.ST_TrueFalseUnset {
		_bdbdf, _babb := _ddage.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _babb != nil {
			return _babb
		}
		start.Attr = append(start.Attr, _bdbdf)
	}
	if _ddage.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_ddage.RegroupidAttr)})
	}
	if _ddage.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_eddce, _gddg := _ddage.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _gddg != nil {
			return _gddg
		}
		start.Attr = append(start.Attr, _eddce)
	}
	if _ddage.ButtonAttr != _eb.ST_TrueFalseUnset {
		_cccg, _bafa := _ddage.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _bafa != nil {
			return _bafa
		}
		start.Attr = append(start.Attr, _cccg)
	}
	if _ddage.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_fagcc, _cbab := _ddage.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _cbab != nil {
			return _cbab
		}
		start.Attr = append(start.Attr, _fagcc)
	}
	if _ddage.BulletAttr != _eb.ST_TrueFalseUnset {
		_bbab, _eacbc := _ddage.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _eacbc != nil {
			return _eacbc
		}
		start.Attr = append(start.Attr, _bbab)
	}
	if _ddage.HrAttr != _eb.ST_TrueFalseUnset {
		_aaeee, _bffe := _ddage.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _bffe != nil {
			return _bffe
		}
		start.Attr = append(start.Attr, _aaeee)
	}
	if _ddage.HrstdAttr != _eb.ST_TrueFalseUnset {
		_ddcbe, _eecg := _ddage.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _eecg != nil {
			return _eecg
		}
		start.Attr = append(start.Attr, _ddcbe)
	}
	if _ddage.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_gebf, _ggecc := _ddage.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _ggecc != nil {
			return _ggecc
		}
		start.Attr = append(start.Attr, _gebf)
	}
	if _ddage.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_ddage.HrpctAttr)})
	}
	if _ddage.HralignAttr != OfcST_HrAlignUnset {
		_acfd, _fbbe := _ddage.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _fbbe != nil {
			return _fbbe
		}
		start.Attr = append(start.Attr, _acfd)
	}
	if _ddage.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_aeee, _ccfgg := _ddage.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _ccfgg != nil {
			return _ccfgg
		}
		start.Attr = append(start.Attr, _aeee)
	}
	if _ddage.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_eecb, _bebed := _ddage.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _bebed != nil {
			return _bebed
		}
		start.Attr = append(start.Attr, _eecb)
	}
	if _ddage.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_dddf, _fcfc := _ddage.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _fcfc != nil {
			return _fcfc
		}
		start.Attr = append(start.Attr, _dddf)
	}
	if _ddage.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_ddage.BordertopcolorAttr)})
	}
	if _ddage.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_ddage.BorderleftcolorAttr)})
	}
	if _ddage.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_ddage.BorderbottomcolorAttr)})
	}
	if _ddage.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_ddage.BorderrightcolorAttr)})
	}
	if _ddage.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_efgc, _edec := _ddage.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _edec != nil {
			return _edec
		}
		start.Attr = append(start.Attr, _efgc)
	}
	if _ddage.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_ddage.DgmnodekindAttr)})
	}
	if _ddage.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_cgfc, _ggfff := _ddage.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _ggfff != nil {
			return _ggfff
		}
		start.Attr = append(start.Attr, _cgfc)
	}
	if _ddage.InsetmodeAttr != OfcST_InsetModeUnset {
		_gdaa, _gbfdc := _ddage.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _gbfdc != nil {
			return _gbfdc
		}
		start.Attr = append(start.Attr, _gdaa)
	}
	if _ddage.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_ddage.OpacityAttr)})
	}
	if _ddage.StrokedAttr != _eb.ST_TrueFalseUnset {
		_dffec, _bbcde := _ddage.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _bbcde != nil {
			return _bbcde
		}
		start.Attr = append(start.Attr, _dffec)
	}
	if _ddage.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_ddage.StrokecolorAttr)})
	}
	if _ddage.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_ddage.StrokeweightAttr)})
	}
	if _ddage.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_ebbg, _bbfag := _ddage.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _bbfag != nil {
			return _bbfag
		}
		start.Attr = append(start.Attr, _ebbg)
	}
	if _ddage.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_ddage.ChromakeyAttr)})
	}
	if _ddage.FilledAttr != _eb.ST_TrueFalseUnset {
		_afce, _cffdg := _ddage.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _cffdg != nil {
			return _cffdg
		}
		start.Attr = append(start.Attr, _afce)
	}
	if _ddage.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_ddage.FillcolorAttr)})
	}
	if _ddage.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_ddage.SptAttr)})
	}
	if _ddage.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_ecgdd, _adeg := _ddage.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _adeg != nil {
			return _adeg
		}
		start.Attr = append(start.Attr, _ecgdd)
	}
	if _ddage.BwmodeAttr != OfcST_BWModeUnset {
		_fcee, _cbcaf := _ddage.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _cbcaf != nil {
			return _cbcaf
		}
		start.Attr = append(start.Attr, _fcee)
	}
	if _ddage.BwpureAttr != OfcST_BWModeUnset {
		_decd, _fgce := _ddage.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _fgce != nil {
			return _fgce
		}
		start.Attr = append(start.Attr, _decd)
	}
	if _ddage.BwnormalAttr != OfcST_BWModeUnset {
		_fgff, _efce := _ddage.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _efce != nil {
			return _efce
		}
		start.Attr = append(start.Attr, _fgff)
	}
	if _ddage.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_cdca, _fcadc := _ddage.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _fcadc != nil {
			return _fcadc
		}
		start.Attr = append(start.Attr, _cdca)
	}
	if _ddage.OleiconAttr != _eb.ST_TrueFalseUnset {
		_cbefd, _fbdda := _ddage.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _fbdda != nil {
			return _fbdda
		}
		start.Attr = append(start.Attr, _cbefd)
	}
	if _ddage.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_begdg, _bdgga := _ddage.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _bdgga != nil {
			return _bdgga
		}
		start.Attr = append(start.Attr, _begdg)
	}
	if _ddage.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_gbadb, _geedb := _ddage.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _geedb != nil {
			return _geedb
		}
		start.Attr = append(start.Attr, _gbadb)
	}
	if _ddage.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_acgd, _bdag := _ddage.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _bdag != nil {
			return _bdag
		}
		start.Attr = append(start.Attr, _acgd)
	}
	if _ddage.ClipAttr != _eb.ST_TrueFalseUnset {
		_aefg, _fgfdf := _ddage.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _fgfdf != nil {
			return _fgfdf
		}
		start.Attr = append(start.Attr, _aefg)
	}
	e.EncodeToken(start)
	if _ddage.EG_ShapeElements != nil {
		for _, _befb := range _ddage.EG_ShapeElements {
			_befb.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_cgbe *CT_Image) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ggecd := range start.Attr {
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "dgmnodekind" {
			_ecad, _fffc := _e.ParseInt(_ggecd.Value, 10, 64)
			if _fffc != nil {
				return _fffc
			}
			_cgbe.DgmnodekindAttr = &_ecad
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "bullet" {
			_cgbe.BulletAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "hr" {
			_cgbe.HrAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "oleicon" {
			_cgbe.OleiconAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "hrstd" {
			_cgbe.HrstdAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "clip" {
			_cgbe.ClipAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "hrnoshade" {
			_cgbe.HrnoshadeAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "preferrelative" {
			_cgbe.PreferrelativeAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "hrpct" {
			_edag, _ggga := _e.ParseFloat(_ggecd.Value, 64)
			if _ggga != nil {
				return _ggga
			}
			_ddeb := float32(_edag)
			_cgbe.HrpctAttr = &_ddeb
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "ole" {
			_cgbe.OleAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "hralign" {
			_cgbe.HralignAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "bwpure" {
			_cgbe.BwpureAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "dgmlayout" {
			_cgbe.DgmlayoutAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "insetmode" {
			_cgbe.InsetmodeAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "spid" {
			_dcgdg, _eaea := _ggecd.Value, error(nil)
			if _eaea != nil {
				return _eaea
			}
			_cgbe.SpidAttr = &_dcgdg
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "borderbottomcolor" {
			_eeafff, _dffe := _ggecd.Value, error(nil)
			if _dffe != nil {
				return _dffe
			}
			_cgbe.BorderbottomcolorAttr = &_eeafff
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "allowoverlap" {
			_cgbe.AllowoverlapAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "doubleclicknotify" {
			_cgbe.DoubleclicknotifyAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "dgmlayoutmru" {
			_cgbe.DgmlayoutmruAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "userhidden" {
			_cgbe.UserhiddenAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "allowincell" {
			_cgbe.AllowincellAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "spt" {
			_gfeab, _cadgc := _e.ParseFloat(_ggecd.Value, 64)
			if _cadgc != nil {
				return _cadgc
			}
			_gdagf := float32(_gfeab)
			_cgbe.SptAttr = &_gdagf
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "borderleftcolor" {
			_cgegc, _cfgdg := _ggecd.Value, error(nil)
			if _cfgdg != nil {
				return _cfgdg
			}
			_cgbe.BorderleftcolorAttr = &_cgegc
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "userdrawn" {
			_cgbe.UserdrawnAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "cliptowrap" {
			_cgbe.CliptowrapAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "borderrightcolor" {
			_aegd, _bfba := _ggecd.Value, error(nil)
			if _bfba != nil {
				return _bfba
			}
			_cgbe.BorderrightcolorAttr = &_aegd
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "connectortype" {
			_cgbe.ConnectortypeAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "button" {
			_cgbe.ButtonAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "forcedash" {
			_cgbe.ForcedashAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "regroupid" {
			_ddcd, _fdeda := _e.ParseInt(_ggecd.Value, 10, 64)
			if _fdeda != nil {
				return _fdeda
			}
			_cgbe.RegroupidAttr = &_ddcd
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "oned" {
			_cgbe.OnedAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "bwmode" {
			_cgbe.BwmodeAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "bwnormal" {
			_cgbe.BwnormalAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggecd.Name.Local == "bordertopcolor" {
			_egdd, _beaa := _ggecd.Value, error(nil)
			if _beaa != nil {
				return _beaa
			}
			_cgbe.BordertopcolorAttr = &_egdd
			continue
		}
		if _ggecd.Name.Local == "print" {
			_cgbe.PrintAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Local == "target" {
			_dfbbg, _gccbc := _ggecd.Value, error(nil)
			if _gccbc != nil {
				return _gccbc
			}
			_cgbe.TargetAttr = &_dfbbg
			continue
		}
		if _ggecd.Name.Local == "stroked" {
			_cgbe.StrokedAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Local == "coordorigin" {
			_gfde, _fdggb := _ggecd.Value, error(nil)
			if _fdggb != nil {
				return _fdggb
			}
			_cgbe.CoordoriginAttr = &_gfde
			continue
		}
		if _ggecd.Name.Local == "strokeweight" {
			_fbdde, _ccegg := _ggecd.Value, error(nil)
			if _ccegg != nil {
				return _ccegg
			}
			_cgbe.StrokeweightAttr = &_fbdde
			continue
		}
		if _ggecd.Name.Local == "coordsize" {
			_cebe, _fagd := _ggecd.Value, error(nil)
			if _fagd != nil {
				return _fagd
			}
			_cgbe.CoordsizeAttr = &_cebe
			continue
		}
		if _ggecd.Name.Local == "chromakey" {
			_bbfg, _adag := _ggecd.Value, error(nil)
			if _adag != nil {
				return _adag
			}
			_cgbe.ChromakeyAttr = &_bbfg
			continue
		}
		if _ggecd.Name.Local == "alt" {
			_ffaf, _ddga := _ggecd.Value, error(nil)
			if _ddga != nil {
				return _ddga
			}
			_cgbe.AltAttr = &_ffaf
			continue
		}
		if _ggecd.Name.Local == "fillcolor" {
			_fagg, _eegc := _ggecd.Value, error(nil)
			if _eegc != nil {
				return _eegc
			}
			_cgbe.FillcolorAttr = &_fagg
			continue
		}
		if _ggecd.Name.Local == "src" {
			_dcea, _edebg := _ggecd.Value, error(nil)
			if _edebg != nil {
				return _edebg
			}
			_cgbe.SrcAttr = &_dcea
			continue
		}
		if _ggecd.Name.Local == "wrapcoords" {
			_dddg, _fabe := _ggecd.Value, error(nil)
			if _fabe != nil {
				return _fabe
			}
			_cgbe.WrapcoordsAttr = &_dddg
			continue
		}
		if _ggecd.Name.Local == "title" {
			_dbdcf, _bdgebf := _ggecd.Value, error(nil)
			if _bdgebf != nil {
				return _bdgebf
			}
			_cgbe.TitleAttr = &_dbdcf
			continue
		}
		if _ggecd.Name.Local == "style" {
			_bgfb, _cbacb := _ggecd.Value, error(nil)
			if _cbacb != nil {
				return _cbacb
			}
			_cgbe.StyleAttr = &_bgfb
			continue
		}
		if _ggecd.Name.Local == "cropright" {
			_agde, _ceedd := _ggecd.Value, error(nil)
			if _ceedd != nil {
				return _ceedd
			}
			_cgbe.CroprightAttr = &_agde
			continue
		}
		if _ggecd.Name.Local == "insetpen" {
			_cgbe.InsetpenAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Local == "cropleft" {
			_eage, _daag := _ggecd.Value, error(nil)
			if _daag != nil {
				return _daag
			}
			_cgbe.CropleftAttr = &_eage
			continue
		}
		if _ggecd.Name.Local == "gain" {
			_dgfd, _dcfe := _ggecd.Value, error(nil)
			if _dcfe != nil {
				return _dcfe
			}
			_cgbe.GainAttr = &_dgfd
			continue
		}
		if _ggecd.Name.Local == "strokecolor" {
			_ebeb, _cfagd := _ggecd.Value, error(nil)
			if _cfagd != nil {
				return _cfagd
			}
			_cgbe.StrokecolorAttr = &_ebeb
			continue
		}
		if _ggecd.Name.Local == "class" {
			_gadf, _bgcd := _ggecd.Value, error(nil)
			if _bgcd != nil {
				return _bgcd
			}
			_cgbe.ClassAttr = &_gadf
			continue
		}
		if _ggecd.Name.Local == "id" {
			_dbfeg, _ffgd := _ggecd.Value, error(nil)
			if _ffgd != nil {
				return _ffgd
			}
			_cgbe.IdAttr = &_dbfeg
			continue
		}
		if _ggecd.Name.Local == "cropbottom" {
			_dbcc, _cege := _ggecd.Value, error(nil)
			if _cege != nil {
				return _cege
			}
			_cgbe.CropbottomAttr = &_dbcc
			continue
		}
		if _ggecd.Name.Local == "filled" {
			_cgbe.FilledAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Local == "grayscale" {
			_cgbe.GrayscaleAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Local == "blacklevel" {
			_cegfad, _fgcac := _ggecd.Value, error(nil)
			if _fgcac != nil {
				return _fgcac
			}
			_cgbe.BlacklevelAttr = &_cegfad
			continue
		}
		if _ggecd.Name.Local == "href" {
			_bgefc, _dgag := _ggecd.Value, error(nil)
			if _dgag != nil {
				return _dgag
			}
			_cgbe.HrefAttr = &_bgefc
			continue
		}
		if _ggecd.Name.Local == "bilevel" {
			_cgbe.BilevelAttr.UnmarshalXMLAttr(_ggecd)
			continue
		}
		if _ggecd.Name.Local == "croptop" {
			_egac, _aebc := _ggecd.Value, error(nil)
			if _aebc != nil {
				return _aebc
			}
			_cgbe.CroptopAttr = &_egac
			continue
		}
		if _ggecd.Name.Local == "opacity" {
			_dadae, _agad := _ggecd.Value, error(nil)
			if _agad != nil {
				return _agad
			}
			_cgbe.OpacityAttr = &_dadae
			continue
		}
		if _ggecd.Name.Local == "gamma" {
			_gbeb, _fefb := _ggecd.Value, error(nil)
			if _fefb != nil {
				return _fefb
			}
			_cgbe.GammaAttr = &_gbeb
			continue
		}
	}
_dedf:
	for {
		_feea, _babd := d.Token()
		if _babd != nil {
			return _babd
		}
		switch _aggbb := _feea.(type) {
		case _b.StartElement:
			switch _aggbb.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_acada := NewEG_ShapeElements()
				_acada.Path = NewPath()
				if _fbdf := d.DecodeElement(_acada.Path, &_aggbb); _fbdf != nil {
					return _fbdf
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _acada)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_gecc := NewEG_ShapeElements()
				_gecc.Formulas = NewFormulas()
				if _edba := d.DecodeElement(_gecc.Formulas, &_aggbb); _edba != nil {
					return _edba
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _gecc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_dddbf := NewEG_ShapeElements()
				_dddbf.Handles = NewHandles()
				if _bdbf := d.DecodeElement(_dddbf.Handles, &_aggbb); _bdbf != nil {
					return _bdbf
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _dddbf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_abfe := NewEG_ShapeElements()
				_abfe.Fill = NewFill()
				if _caeff := d.DecodeElement(_abfe.Fill, &_aggbb); _caeff != nil {
					return _caeff
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _abfe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_bdddb := NewEG_ShapeElements()
				_bdddb.Stroke = NewStroke()
				if _dgbc := d.DecodeElement(_bdddb.Stroke, &_aggbb); _dgbc != nil {
					return _dgbc
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _bdddb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_cage := NewEG_ShapeElements()
				_cage.Shadow = NewShadow()
				if _egdfb := d.DecodeElement(_cage.Shadow, &_aggbb); _egdfb != nil {
					return _egdfb
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _cage)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_cfbd := NewEG_ShapeElements()
				_cfbd.Textbox = NewTextbox()
				if _dafd := d.DecodeElement(_cfbd.Textbox, &_aggbb); _dafd != nil {
					return _dafd
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _cfbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_eeggg := NewEG_ShapeElements()
				_eeggg.Textpath = NewTextpath()
				if _aaaa := d.DecodeElement(_eeggg.Textpath, &_aggbb); _aaaa != nil {
					return _aaaa
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _eeggg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_dadf := NewEG_ShapeElements()
				_dadf.Imagedata = NewImagedata()
				if _beedd := d.DecodeElement(_dadf.Imagedata, &_aggbb); _beedd != nil {
					return _beedd
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _dadf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_dcfa := NewEG_ShapeElements()
				_dcfa.Skew = NewOfcSkew()
				if _fccga := d.DecodeElement(_dcfa.Skew, &_aggbb); _fccga != nil {
					return _fccga
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _dcfa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_ecdeg := NewEG_ShapeElements()
				_ecdeg.Extrusion = NewOfcExtrusion()
				if _effd := d.DecodeElement(_ecdeg.Extrusion, &_aggbb); _effd != nil {
					return _effd
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _ecdeg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_gdce := NewEG_ShapeElements()
				_gdce.Callout = NewOfcCallout()
				if _egdb := d.DecodeElement(_gdce.Callout, &_aggbb); _egdb != nil {
					return _egdb
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _gdce)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_aefe := NewEG_ShapeElements()
				_aefe.Lock = NewOfcLock()
				if _bged := d.DecodeElement(_aefe.Lock, &_aggbb); _bged != nil {
					return _bged
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _aefe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_acfba := NewEG_ShapeElements()
				_acfba.Clippath = NewOfcClippath()
				if _cdee := d.DecodeElement(_acfba.Clippath, &_aggbb); _cdee != nil {
					return _cdee
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _acfba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_dfec := NewEG_ShapeElements()
				_dfec.Signatureline = NewOfcSignatureline()
				if _gcfg := d.DecodeElement(_dfec.Signatureline, &_aggbb); _gcfg != nil {
					return _gcfg
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _dfec)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_aedcf := NewEG_ShapeElements()
				_aedcf.Wrap = _a.NewWrap()
				if _fdbg := d.DecodeElement(_aedcf.Wrap, &_aggbb); _fdbg != nil {
					return _fdbg
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _aedcf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_bbcd := NewEG_ShapeElements()
				_bbcd.Anchorlock = _a.NewAnchorlock()
				if _dbef := d.DecodeElement(_bbcd.Anchorlock, &_aggbb); _dbef != nil {
					return _dbef
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _bbcd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_fefbc := NewEG_ShapeElements()
				_fefbc.Bordertop = _a.NewBordertop()
				if _gaga := d.DecodeElement(_fefbc.Bordertop, &_aggbb); _gaga != nil {
					return _gaga
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _fefbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_fecg := NewEG_ShapeElements()
				_fecg.Borderbottom = _a.NewBorderbottom()
				if _gedda := d.DecodeElement(_fecg.Borderbottom, &_aggbb); _gedda != nil {
					return _gedda
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _fecg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_bgdb := NewEG_ShapeElements()
				_bgdb.Borderleft = _a.NewBorderleft()
				if _fbacf := d.DecodeElement(_bgdb.Borderleft, &_aggbb); _fbacf != nil {
					return _fbacf
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _bgdb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_eebc := NewEG_ShapeElements()
				_eebc.Borderright = _a.NewBorderright()
				if _fefaa := d.DecodeElement(_eebc.Borderright, &_aggbb); _fefaa != nil {
					return _fefaa
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _eebc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_gebged := NewEG_ShapeElements()
				_gebged.ClientData = _c.NewClientData()
				if _debe := d.DecodeElement(_gebged.ClientData, &_aggbb); _debe != nil {
					return _debe
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _gebged)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_cccf := NewEG_ShapeElements()
				_cccf.Textdata = _bf.NewTextdata()
				if _cbca := d.DecodeElement(_cccf.Textdata, &_aggbb); _cbca != nil {
					return _cbca
				}
				_cgbe.EG_ShapeElements = append(_cgbe.EG_ShapeElements, _cccf)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Image\u0020\u0025v", _aggbb.Name)
				if _eddf := d.Skip(); _eddf != nil {
					return _eddf
				}
			}
		case _b.EndElement:
			break _dedf
		case _b.CharData:
		}
	}
	return nil
}
func (_acgab *OfcCallout) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _acgab.OfcCT_Callout.MarshalXML(e, start)
}

// Validate validates the OfcCT_Complex and its children
func (_caccd *OfcCT_Complex) Validate() error { return _caccd.ValidateWithPath("OfcCT_Complex") }

// Validate validates the OfcCT_Skew and its children
func (_gecdc *OfcCT_Skew) Validate() error { return _gecdc.ValidateWithPath("OfcCT_Skew") }

// ValidateWithPath validates the CT_Curve and its children, prefixing error messages with path
func (_cffc *CT_Curve) ValidateWithPath(path string) error {
	for _bgad, _gbde := range _cffc.EG_ShapeElements {
		if _gagdf := _gbde.ValidateWithPath(_f.Sprintf("\u0025s\u002fEG_ShapeElements\u005b\u0025d\u005d", path, _bgad)); _gagdf != nil {
			return _gagdf
		}
	}
	if _bdfcag := _cffc.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _bdfcag != nil {
		return _bdfcag
	}
	if _gged := _cffc.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _gged != nil {
		return _gged
	}
	if _cegg := _cffc.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _cegg != nil {
		return _cegg
	}
	if _acdde := _cffc.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _acdde != nil {
		return _acdde
	}
	if _dgged := _cffc.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _dgged != nil {
		return _dgged
	}
	if _ddfc := _cffc.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _ddfc != nil {
		return _ddfc
	}
	if _cacc := _cffc.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _cacc != nil {
		return _cacc
	}
	if _daeea := _cffc.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _daeea != nil {
		return _daeea
	}
	if _fdeg := _cffc.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _fdeg != nil {
		return _fdeg
	}
	if _ceebe := _cffc.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _ceebe != nil {
		return _ceebe
	}
	if _cfbf := _cffc.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _cfbf != nil {
		return _cfbf
	}
	if _bfed := _cffc.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _bfed != nil {
		return _bfed
	}
	if _dbdb := _cffc.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _dbdb != nil {
		return _dbdb
	}
	if _cafb := _cffc.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _cafb != nil {
		return _cafb
	}
	if _fefe := _cffc.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _fefe != nil {
		return _fefe
	}
	if _ccedg := _cffc.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _ccedg != nil {
		return _ccedg
	}
	if _bdfb := _cffc.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _bdfb != nil {
		return _bdfb
	}
	if _bbec := _cffc.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _bbec != nil {
		return _bbec
	}
	if _dfdf := _cffc.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _dfdf != nil {
		return _dfdf
	}
	if _bagd := _cffc.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _bagd != nil {
		return _bagd
	}
	if _geed := _cffc.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _geed != nil {
		return _geed
	}
	if _gbbfd := _cffc.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _gbbfd != nil {
		return _gbbfd
	}
	if _efbb := _cffc.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _efbb != nil {
		return _efbb
	}
	if _aabe := _cffc.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _aabe != nil {
		return _aabe
	}
	if _fffg := _cffc.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _fffg != nil {
		return _fffg
	}
	if _efaf := _cffc.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _efaf != nil {
		return _efaf
	}
	if _ddcb := _cffc.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _ddcb != nil {
		return _ddcb
	}
	if _ffaaa := _cffc.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _ffaaa != nil {
		return _ffaaa
	}
	if _cgc := _cffc.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _cgc != nil {
		return _cgc
	}
	return nil
}

// ValidateWithPath validates the CT_Arc and its children, prefixing error messages with path
func (_dabga *CT_Arc) ValidateWithPath(path string) error {
	for _faccf, _gea := range _dabga.EG_ShapeElements {
		if _cabfa := _gea.ValidateWithPath(_f.Sprintf("\u0025s\u002fEG_ShapeElements\u005b\u0025d\u005d", path, _faccf)); _cabfa != nil {
			return _cabfa
		}
	}
	if _cdce := _dabga.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _cdce != nil {
		return _cdce
	}
	if _cagd := _dabga.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _cagd != nil {
		return _cagd
	}
	if _bbag := _dabga.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _bbag != nil {
		return _bbag
	}
	if _dfcc := _dabga.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _dfcc != nil {
		return _dfcc
	}
	if _cgd := _dabga.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _cgd != nil {
		return _cgd
	}
	if _fgbe := _dabga.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _fgbe != nil {
		return _fgbe
	}
	if _bad := _dabga.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _bad != nil {
		return _bad
	}
	if _dfgf := _dabga.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _dfgf != nil {
		return _dfgf
	}
	if _feab := _dabga.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _feab != nil {
		return _feab
	}
	if _gccb := _dabga.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _gccb != nil {
		return _gccb
	}
	if _abcd := _dabga.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _abcd != nil {
		return _abcd
	}
	if _bfcf := _dabga.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _bfcf != nil {
		return _bfcf
	}
	if _eddg := _dabga.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _eddg != nil {
		return _eddg
	}
	if _cfde := _dabga.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _cfde != nil {
		return _cfde
	}
	if _fegg := _dabga.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _fegg != nil {
		return _fegg
	}
	if _dccd := _dabga.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _dccd != nil {
		return _dccd
	}
	if _dffc := _dabga.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _dffc != nil {
		return _dffc
	}
	if _bag := _dabga.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _bag != nil {
		return _bag
	}
	if _bgcc := _dabga.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _bgcc != nil {
		return _bgcc
	}
	if _ggfa := _dabga.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _ggfa != nil {
		return _ggfa
	}
	if _eafd := _dabga.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _eafd != nil {
		return _eafd
	}
	if _gffdb := _dabga.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _gffdb != nil {
		return _gffdb
	}
	if _beb := _dabga.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _beb != nil {
		return _beb
	}
	if _fggc := _dabga.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _fggc != nil {
		return _fggc
	}
	if _fdcef := _dabga.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _fdcef != nil {
		return _fdcef
	}
	if _eddga := _dabga.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _eddga != nil {
		return _eddga
	}
	if _fcda := _dabga.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _fcda != nil {
		return _fcda
	}
	if _fded := _dabga.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _fded != nil {
		return _fded
	}
	if _gdag := _dabga.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _gdag != nil {
		return _gdag
	}
	return nil
}
func NewArc() *Arc { _edfe := &Arc{}; _edfe.CT_Arc = *NewCT_Arc(); return _edfe }
func (_dgcea OfcST_OLEUpdateMode) ValidateWithPath(path string) error {
	switch _dgcea {
	case 0, 1, 2:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dgcea))
	}
	return nil
}

type OfcClippath struct{ OfcCT_ClipPath }

func (_df *AG_ImageAttributes) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _df.SrcAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "src"}, Value: _f.Sprintf("\u0025v", *_df.SrcAttr)})
	}
	if _df.CropleftAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cropleft"}, Value: _f.Sprintf("\u0025v", *_df.CropleftAttr)})
	}
	if _df.CroptopAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "croptop"}, Value: _f.Sprintf("\u0025v", *_df.CroptopAttr)})
	}
	if _df.CroprightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cropright"}, Value: _f.Sprintf("\u0025v", *_df.CroprightAttr)})
	}
	if _df.CropbottomAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cropbottom"}, Value: _f.Sprintf("\u0025v", *_df.CropbottomAttr)})
	}
	if _df.GainAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "gain"}, Value: _f.Sprintf("\u0025v", *_df.GainAttr)})
	}
	if _df.BlacklevelAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "blacklevel"}, Value: _f.Sprintf("\u0025v", *_df.BlacklevelAttr)})
	}
	if _df.GammaAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "gamma"}, Value: _f.Sprintf("\u0025v", *_df.GammaAttr)})
	}
	if _df.GrayscaleAttr != _eb.ST_TrueFalseUnset {
		_gfc, _bcg := _df.GrayscaleAttr.MarshalXMLAttr(_b.Name{Local: "grayscale"})
		if _bcg != nil {
			return _bcg
		}
		start.Attr = append(start.Attr, _gfc)
	}
	if _df.BilevelAttr != _eb.ST_TrueFalseUnset {
		_bgd, _gbge := _df.BilevelAttr.MarshalXMLAttr(_b.Name{Local: "bilevel"})
		if _gbge != nil {
			return _gbge
		}
		start.Attr = append(start.Attr, _bgd)
	}
	return nil
}

// Validate validates the Line and its children
func (_egcdcb *Line) Validate() error { return _egcdcb.ValidateWithPath("Line") }

// ValidateWithPath validates the OfcLeft and its children, prefixing error messages with path
func (_cgbea *OfcLeft) ValidateWithPath(path string) error {
	if _ceeg := _cgbea.OfcCT_StrokeChild.ValidateWithPath(path); _ceeg != nil {
		return _ceeg
	}
	return nil
}
func NewOfcCT_RegroupTable() *OfcCT_RegroupTable { _fcfbd := &OfcCT_RegroupTable{}; return _fcfbd }

// ValidateWithPath validates the OfcFill and its children, prefixing error messages with path
func (_efdad *OfcFill) ValidateWithPath(path string) error {
	if _dccgb := _efdad.OfcCT_Fill.ValidateWithPath(path); _dccgb != nil {
		return _dccgb
	}
	return nil
}
func (_ecbcg ST_StrokeLineStyle) ValidateWithPath(path string) error {
	switch _ecbcg {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ecbcg))
	}
	return nil
}
func (_dage *OfcST_DiagramLayout) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dage = 0
	case "0":
		*_dage = 1
	case "1":
		*_dage = 2
	case "2":
		*_dage = 3
	case "3":
		*_dage = 4
	}
	return nil
}

type OfcCT_ShapeLayout struct {
	Idmap        *OfcCT_IdMap
	Regrouptable *OfcCT_RegroupTable
	Rules        *OfcCT_Rules
	ExtAttr      ST_Ext
}

func (_bcfdeb OfcST_ExtrusionRender) String() string {
	switch _bcfdeb {
	case 0:
		return ""
	case 1:
		return "solid"
	case 2:
		return "wireFrame"
	case 3:
		return "boundingCube"
	}
	return ""
}

// Validate validates the AG_Id and its children
func (_bbb *AG_Id) Validate() error { return _bbb.ValidateWithPath("AG_Id") }
func (_dbeea *OfcFill) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dbeea.OfcCT_Fill = *NewOfcCT_Fill()
	for _, _gfecb := range start.Attr {
		if _gfecb.Name.Local == "type" {
			_dbeea.TypeAttr.UnmarshalXMLAttr(_gfecb)
			continue
		}
		if _gfecb.Name.Local == "ext" {
			_dbeea.ExtAttr.UnmarshalXMLAttr(_gfecb)
			continue
		}
	}
	for {
		_ddcf, _ecaaf := d.Token()
		if _ecaaf != nil {
			return _f.Errorf("parsing\u0020OfcFill:\u0020\u0025s", _ecaaf)
		}
		if _daeff, _edfed := _ddcf.(_b.EndElement); _edfed && _daeff.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bfeae *OfcST_InsetMode) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_bfeae = 0
	case "auto":
		*_bfeae = 1
	case "custom":
		*_bfeae = 2
	}
	return nil
}
func (_bfcd *CT_F) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _aced := range start.Attr {
		if _aced.Name.Local == "eqn" {
			_dde, _agcgd := _aced.Value, error(nil)
			if _agcgd != nil {
				return _agcgd
			}
			_bfcd.EqnAttr = &_dde
			continue
		}
	}
	for {
		_cfda, _dgad := d.Token()
		if _dgad != nil {
			return _f.Errorf("parsing\u0020CT_F:\u0020\u0025s", _dgad)
		}
		if _bfee, _gadcd := _cfda.(_b.EndElement); _gadcd && _bfee.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Shadow() *CT_Shadow { _dffdc := &CT_Shadow{}; return _dffdc }

type Polyline struct{ CT_PolyLine }

func (_bbaff OfcST_ColorMode) Validate() error { return _bbaff.ValidateWithPath("") }
func (_egagg OfcST_BWMode) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_dbcbeb := _b.Attr{}
	_dbcbeb.Name = name
	switch _egagg {
	case OfcST_BWModeUnset:
		_dbcbeb.Value = ""
	case OfcST_BWModeColor:
		_dbcbeb.Value = "color"
	case OfcST_BWModeAuto:
		_dbcbeb.Value = "auto"
	case OfcST_BWModeGrayScale:
		_dbcbeb.Value = "grayScale"
	case OfcST_BWModeLightGrayscale:
		_dbcbeb.Value = "lightGrayscale"
	case OfcST_BWModeInverseGray:
		_dbcbeb.Value = "inverseGray"
	case OfcST_BWModeGrayOutline:
		_dbcbeb.Value = "grayOutline"
	case OfcST_BWModeHighContrast:
		_dbcbeb.Value = "highContrast"
	case OfcST_BWModeBlack:
		_dbcbeb.Value = "black"
	case OfcST_BWModeWhite:
		_dbcbeb.Value = "white"
	case OfcST_BWModeHide:
		_dbcbeb.Value = "hide"
	case OfcST_BWModeUndrawn:
		_dbcbeb.Value = "undrawn"
	case OfcST_BWModeBlackTextAndLines:
		_dbcbeb.Value = "blackTextAndLines"
	}
	return _dbcbeb, nil
}

// Validate validates the OfcFill and its children
func (_ggfc *OfcFill) Validate() error { return _ggfc.ValidateWithPath("OfcFill") }

type ST_StrokeArrowWidth byte
type AG_Adj struct{ AdjAttr *string }

func NewImage() *Image { _fadeb := &Image{}; _fadeb.CT_Image = *NewCT_Image(); return _fadeb }

// Validate validates the Path and its children
func (_bgfbf *Path) Validate() error { return _bgfbf.ValidateWithPath("Path") }
func (_fbfdf OfcST_DiagramLayout) ValidateWithPath(path string) error {
	switch _fbfdf {
	case 0, 1, 2, 3, 4:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fbfdf))
	}
	return nil
}

// Validate validates the OfcDiagram and its children
func (_cbbbc *OfcDiagram) Validate() error { return _cbbbc.ValidateWithPath("OfcDiagram") }

// Validate validates the OfcCT_ShapeLayout and its children
func (_caece *OfcCT_ShapeLayout) Validate() error {
	return _caece.ValidateWithPath("OfcCT_ShapeLayout")
}

// Validate validates the Shadow and its children
func (_dfagfd *Shadow) Validate() error { return _dfagfd.ValidateWithPath("Shadow") }
func (_dbdcd OfcST_BWMode) ValidateWithPath(path string) error {
	switch _dbdcd {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dbdcd))
	}
	return nil
}
func (_ggcgb *CT_Shadow) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ggcgb.OnAttr != _eb.ST_TrueFalseUnset {
		_gecd, _geea := _ggcgb.OnAttr.MarshalXMLAttr(_b.Name{Local: "on"})
		if _geea != nil {
			return _geea
		}
		start.Attr = append(start.Attr, _gecd)
	}
	if _ggcgb.TypeAttr != ST_ShadowTypeUnset {
		_fabd, _afbab := _ggcgb.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _afbab != nil {
			return _afbab
		}
		start.Attr = append(start.Attr, _fabd)
	}
	if _ggcgb.ObscuredAttr != _eb.ST_TrueFalseUnset {
		_bgdbd, _fgafa := _ggcgb.ObscuredAttr.MarshalXMLAttr(_b.Name{Local: "obscured"})
		if _fgafa != nil {
			return _fgafa
		}
		start.Attr = append(start.Attr, _bgdbd)
	}
	if _ggcgb.ColorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "color"}, Value: _f.Sprintf("\u0025v", *_ggcgb.ColorAttr)})
	}
	if _ggcgb.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_ggcgb.OpacityAttr)})
	}
	if _ggcgb.OffsetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "offset"}, Value: _f.Sprintf("\u0025v", *_ggcgb.OffsetAttr)})
	}
	if _ggcgb.Color2Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "color2"}, Value: _f.Sprintf("\u0025v", *_ggcgb.Color2Attr)})
	}
	if _ggcgb.Offset2Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "offset2"}, Value: _f.Sprintf("\u0025v", *_ggcgb.Offset2Attr)})
	}
	if _ggcgb.OriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "origin"}, Value: _f.Sprintf("\u0025v", *_ggcgb.OriginAttr)})
	}
	if _ggcgb.MatrixAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "matrix"}, Value: _f.Sprintf("\u0025v", *_ggcgb.MatrixAttr)})
	}
	if _ggcgb.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_ggcgb.IdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the OfcEquationxml and its children, prefixing error messages with path
func (_egag *OfcEquationxml) ValidateWithPath(path string) error {
	if _beffe := _egag.OfcCT_EquationXml.ValidateWithPath(path); _beffe != nil {
		return _beffe
	}
	return nil
}

// Validate validates the OfcCT_ColorMru and its children
func (_eadade *OfcCT_ColorMru) Validate() error { return _eadade.ValidateWithPath("OfcCT_ColorMru") }
func (_efcaa *Polyline) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_efcaa.CT_PolyLine = *NewCT_PolyLine()
	for _, _cbdfd := range start.Attr {
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "userdrawn" {
			_efcaa.UserdrawnAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "clip" {
			_efcaa.ClipAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "userhidden" {
			_efcaa.UserhiddenAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "insetmode" {
			_efcaa.InsetmodeAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "bullet" {
			_efcaa.BulletAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "preferrelative" {
			_efcaa.PreferrelativeAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "hr" {
			_efcaa.HrAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "oleicon" {
			_efcaa.OleiconAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "hrstd" {
			_efcaa.HrstdAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "hrnoshade" {
			_efcaa.HrnoshadeAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "bordertopcolor" {
			_deafb, _fefec := _cbdfd.Value, error(nil)
			if _fefec != nil {
				return _fefec
			}
			_efcaa.BordertopcolorAttr = &_deafb
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "dgmlayout" {
			_efcaa.DgmlayoutAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "allowoverlap" {
			_efcaa.AllowoverlapAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "bwnormal" {
			_efcaa.BwnormalAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "cliptowrap" {
			_efcaa.CliptowrapAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "borderbottomcolor" {
			_deabf, _abbdfd := _cbdfd.Value, error(nil)
			if _abbdfd != nil {
				return _abbdfd
			}
			_efcaa.BorderbottomcolorAttr = &_deabf
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "oned" {
			_efcaa.OnedAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "dgmlayoutmru" {
			_efcaa.DgmlayoutmruAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "regroupid" {
			_caabc, _gaec := _e.ParseInt(_cbdfd.Value, 10, 64)
			if _gaec != nil {
				return _gaec
			}
			_efcaa.RegroupidAttr = &_caabc
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "allowincell" {
			_efcaa.AllowincellAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "hrpct" {
			_fcdafa, _abagb := _e.ParseFloat(_cbdfd.Value, 64)
			if _abagb != nil {
				return _abagb
			}
			_degf := float32(_fcdafa)
			_efcaa.HrpctAttr = &_degf
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "button" {
			_efcaa.ButtonAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "spid" {
			_bcaac, _gbbce := _cbdfd.Value, error(nil)
			if _gbbce != nil {
				return _gbbce
			}
			_efcaa.SpidAttr = &_bcaac
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "spt" {
			_bfgbc, _bgacb := _e.ParseFloat(_cbdfd.Value, 64)
			if _bgacb != nil {
				return _bgacb
			}
			_bbdgc := float32(_bfgbc)
			_efcaa.SptAttr = &_bbdgc
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "borderleftcolor" {
			_bgdfd, _agbeg := _cbdfd.Value, error(nil)
			if _agbeg != nil {
				return _agbeg
			}
			_efcaa.BorderleftcolorAttr = &_bgdfd
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "ole" {
			_efcaa.OleAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "borderrightcolor" {
			_bacbdb, _dgbd := _cbdfd.Value, error(nil)
			if _dgbd != nil {
				return _dgbd
			}
			_efcaa.BorderrightcolorAttr = &_bacbdb
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "bwmode" {
			_efcaa.BwmodeAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "dgmnodekind" {
			_eedc, _cbeca := _e.ParseInt(_cbdfd.Value, 10, 64)
			if _cbeca != nil {
				return _cbeca
			}
			_efcaa.DgmnodekindAttr = &_eedc
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "forcedash" {
			_efcaa.ForcedashAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "bwpure" {
			_efcaa.BwpureAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "connectortype" {
			_efcaa.ConnectortypeAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "doubleclicknotify" {
			_efcaa.DoubleclicknotifyAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbdfd.Name.Local == "hralign" {
			_efcaa.HralignAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Local == "coordsize" {
			_fdgcc, _gcddd := _cbdfd.Value, error(nil)
			if _gcddd != nil {
				return _gcddd
			}
			_efcaa.CoordsizeAttr = &_fdgcc
			continue
		}
		if _cbdfd.Name.Local == "style" {
			_fefdeg, _egeef := _cbdfd.Value, error(nil)
			if _egeef != nil {
				return _egeef
			}
			_efcaa.StyleAttr = &_fefdeg
			continue
		}
		if _cbdfd.Name.Local == "id" {
			_aabbd, _caeffe := _cbdfd.Value, error(nil)
			if _caeffe != nil {
				return _caeffe
			}
			_efcaa.IdAttr = &_aabbd
			continue
		}
		if _cbdfd.Name.Local == "stroked" {
			_efcaa.StrokedAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Local == "print" {
			_efcaa.PrintAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Local == "strokeweight" {
			_fedc, _bbadgd := _cbdfd.Value, error(nil)
			if _bbadgd != nil {
				return _bbadgd
			}
			_efcaa.StrokeweightAttr = &_fedc
			continue
		}
		if _cbdfd.Name.Local == "wrapcoords" {
			_befdc, _ddefe := _cbdfd.Value, error(nil)
			if _ddefe != nil {
				return _ddefe
			}
			_efcaa.WrapcoordsAttr = &_befdc
			continue
		}
		if _cbdfd.Name.Local == "chromakey" {
			_afgg, _geabd := _cbdfd.Value, error(nil)
			if _geabd != nil {
				return _geabd
			}
			_efcaa.ChromakeyAttr = &_afgg
			continue
		}
		if _cbdfd.Name.Local == "fillcolor" {
			_daebd, _eecbdf := _cbdfd.Value, error(nil)
			if _eecbdf != nil {
				return _eecbdf
			}
			_efcaa.FillcolorAttr = &_daebd
			continue
		}
		if _cbdfd.Name.Local == "alt" {
			_decgcf, _dcgec := _cbdfd.Value, error(nil)
			if _dcgec != nil {
				return _dcgec
			}
			_efcaa.AltAttr = &_decgcf
			continue
		}
		if _cbdfd.Name.Local == "opacity" {
			_gdaef, _cefgg := _cbdfd.Value, error(nil)
			if _cefgg != nil {
				return _cefgg
			}
			_efcaa.OpacityAttr = &_gdaef
			continue
		}
		if _cbdfd.Name.Local == "strokecolor" {
			_gaeee, _dcgfa := _cbdfd.Value, error(nil)
			if _dcgfa != nil {
				return _dcgfa
			}
			_efcaa.StrokecolorAttr = &_gaeee
			continue
		}
		if _cbdfd.Name.Local == "insetpen" {
			_efcaa.InsetpenAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Local == "filled" {
			_efcaa.FilledAttr.UnmarshalXMLAttr(_cbdfd)
			continue
		}
		if _cbdfd.Name.Local == "coordorigin" {
			_afbgf, _geefg := _cbdfd.Value, error(nil)
			if _geefg != nil {
				return _geefg
			}
			_efcaa.CoordoriginAttr = &_afbgf
			continue
		}
		if _cbdfd.Name.Local == "title" {
			_ecfeg, _acbcdb := _cbdfd.Value, error(nil)
			if _acbcdb != nil {
				return _acbcdb
			}
			_efcaa.TitleAttr = &_ecfeg
			continue
		}
		if _cbdfd.Name.Local == "class" {
			_afafd, _bddee := _cbdfd.Value, error(nil)
			if _bddee != nil {
				return _bddee
			}
			_efcaa.ClassAttr = &_afafd
			continue
		}
		if _cbdfd.Name.Local == "target" {
			_efedf, _fcbee := _cbdfd.Value, error(nil)
			if _fcbee != nil {
				return _fcbee
			}
			_efcaa.TargetAttr = &_efedf
			continue
		}
		if _cbdfd.Name.Local == "href" {
			_adcbg, _fbaefa := _cbdfd.Value, error(nil)
			if _fbaefa != nil {
				return _fbaefa
			}
			_efcaa.HrefAttr = &_adcbg
			continue
		}
		if _cbdfd.Name.Local == "points" {
			_ecbcd, _afcfc := _cbdfd.Value, error(nil)
			if _afcfc != nil {
				return _afcfc
			}
			_efcaa.PointsAttr = &_ecbcd
			continue
		}
	}
_fefadd:
	for {
		_ebdab, _cfdcc := d.Token()
		if _cfdcc != nil {
			return _cfdcc
		}
		switch _dfbaec := _ebdab.(type) {
		case _b.StartElement:
			switch _dfbaec.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "ink"}:
				_dadg := NewOfcInk()
				if _affbac := d.DecodeElement(_dadg, &_dfbaec); _affbac != nil {
					return _affbac
				}
				_efcaa.Ink = append(_efcaa.Ink, _dadg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_cfbfe := NewEG_ShapeElements()
				_cfbfe.Path = NewPath()
				if _dedba := d.DecodeElement(_cfbfe.Path, &_dfbaec); _dedba != nil {
					return _dedba
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _cfbfe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_cfecg := NewEG_ShapeElements()
				_cfecg.Formulas = NewFormulas()
				if _cccea := d.DecodeElement(_cfecg.Formulas, &_dfbaec); _cccea != nil {
					return _cccea
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _cfecg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_ccegge := NewEG_ShapeElements()
				_ccegge.Handles = NewHandles()
				if _feccfe := d.DecodeElement(_ccegge.Handles, &_dfbaec); _feccfe != nil {
					return _feccfe
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _ccegge)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_agbfa := NewEG_ShapeElements()
				_agbfa.Fill = NewFill()
				if _gebdb := d.DecodeElement(_agbfa.Fill, &_dfbaec); _gebdb != nil {
					return _gebdb
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _agbfa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_feaab := NewEG_ShapeElements()
				_feaab.Stroke = NewStroke()
				if _eafec := d.DecodeElement(_feaab.Stroke, &_dfbaec); _eafec != nil {
					return _eafec
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _feaab)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_cfeca := NewEG_ShapeElements()
				_cfeca.Shadow = NewShadow()
				if _agdga := d.DecodeElement(_cfeca.Shadow, &_dfbaec); _agdga != nil {
					return _agdga
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _cfeca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_fedcd := NewEG_ShapeElements()
				_fedcd.Textbox = NewTextbox()
				if _ddcbg := d.DecodeElement(_fedcd.Textbox, &_dfbaec); _ddcbg != nil {
					return _ddcbg
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _fedcd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_aaega := NewEG_ShapeElements()
				_aaega.Textpath = NewTextpath()
				if _gdabc := d.DecodeElement(_aaega.Textpath, &_dfbaec); _gdabc != nil {
					return _gdabc
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _aaega)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_gacfga := NewEG_ShapeElements()
				_gacfga.Imagedata = NewImagedata()
				if _ecgcc := d.DecodeElement(_gacfga.Imagedata, &_dfbaec); _ecgcc != nil {
					return _ecgcc
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _gacfga)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_ggced := NewEG_ShapeElements()
				_ggced.Skew = NewOfcSkew()
				if _cbdfbg := d.DecodeElement(_ggced.Skew, &_dfbaec); _cbdfbg != nil {
					return _cbdfbg
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _ggced)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_eaae := NewEG_ShapeElements()
				_eaae.Extrusion = NewOfcExtrusion()
				if _aagcb := d.DecodeElement(_eaae.Extrusion, &_dfbaec); _aagcb != nil {
					return _aagcb
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _eaae)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_fgcge := NewEG_ShapeElements()
				_fgcge.Callout = NewOfcCallout()
				if _fbef := d.DecodeElement(_fgcge.Callout, &_dfbaec); _fbef != nil {
					return _fbef
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _fgcge)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_gebdef := NewEG_ShapeElements()
				_gebdef.Lock = NewOfcLock()
				if _cdggea := d.DecodeElement(_gebdef.Lock, &_dfbaec); _cdggea != nil {
					return _cdggea
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _gebdef)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_bdccd := NewEG_ShapeElements()
				_bdccd.Clippath = NewOfcClippath()
				if _gebdg := d.DecodeElement(_bdccd.Clippath, &_dfbaec); _gebdg != nil {
					return _gebdg
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _bdccd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_gdeba := NewEG_ShapeElements()
				_gdeba.Signatureline = NewOfcSignatureline()
				if _afcee := d.DecodeElement(_gdeba.Signatureline, &_dfbaec); _afcee != nil {
					return _afcee
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _gdeba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_bcebdg := NewEG_ShapeElements()
				_bcebdg.Wrap = _a.NewWrap()
				if _agcag := d.DecodeElement(_bcebdg.Wrap, &_dfbaec); _agcag != nil {
					return _agcag
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _bcebdg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_ceegd := NewEG_ShapeElements()
				_ceegd.Anchorlock = _a.NewAnchorlock()
				if _bgeb := d.DecodeElement(_ceegd.Anchorlock, &_dfbaec); _bgeb != nil {
					return _bgeb
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _ceegd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_egfgf := NewEG_ShapeElements()
				_egfgf.Bordertop = _a.NewBordertop()
				if _ccecg := d.DecodeElement(_egfgf.Bordertop, &_dfbaec); _ccecg != nil {
					return _ccecg
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _egfgf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_aacbc := NewEG_ShapeElements()
				_aacbc.Borderbottom = _a.NewBorderbottom()
				if _abdc := d.DecodeElement(_aacbc.Borderbottom, &_dfbaec); _abdc != nil {
					return _abdc
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _aacbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_cffddc := NewEG_ShapeElements()
				_cffddc.Borderleft = _a.NewBorderleft()
				if _deae := d.DecodeElement(_cffddc.Borderleft, &_dfbaec); _deae != nil {
					return _deae
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _cffddc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_afgfg := NewEG_ShapeElements()
				_afgfg.Borderright = _a.NewBorderright()
				if _faedb := d.DecodeElement(_afgfg.Borderright, &_dfbaec); _faedb != nil {
					return _faedb
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _afgfg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_afcab := NewEG_ShapeElements()
				_afcab.ClientData = _c.NewClientData()
				if _efegb := d.DecodeElement(_afcab.ClientData, &_dfbaec); _efegb != nil {
					return _efegb
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _afcab)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_gggfg := NewEG_ShapeElements()
				_gggfg.Textdata = _bf.NewTextdata()
				if _cadca := d.DecodeElement(_gggfg.Textdata, &_dfbaec); _cadca != nil {
					return _cadca
				}
				_efcaa.EG_ShapeElements = append(_efcaa.EG_ShapeElements, _gggfg)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Polyline\u0020\u0025v", _dfbaec.Name)
				if _dfbfg := d.Skip(); _dfbfg != nil {
					return _dfbfg
				}
			}
		case _b.EndElement:
			break _fefadd
		case _b.CharData:
		}
	}
	return nil
}
func (_ecccc OfcST_HrAlign) ValidateWithPath(path string) error {
	switch _ecccc {
	case 0, 1, 2, 3:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ecccc))
	}
	return nil
}
func (_dgeac OfcST_InsetMode) String() string {
	switch _dgeac {
	case 0:
		return ""
	case 1:
		return "auto"
	case 2:
		return "custom"
	}
	return ""
}

type OfcCT_RegroupTable struct {
	Entry   []*OfcCT_Entry
	ExtAttr ST_Ext
}

func (_acgaf OfcST_ExtrusionRender) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_acgaf.String(), start)
}
func NewAG_ImageAttributes() *AG_ImageAttributes { _fdca := &AG_ImageAttributes{}; return _fdca }

// ValidateWithPath validates the OfcCT_Callout and its children, prefixing error messages with path
func (_edaf *OfcCT_Callout) ValidateWithPath(path string) error {
	if _cggbd := _edaf.OnAttr.ValidateWithPath(path + "\u002fOnAttr"); _cggbd != nil {
		return _cggbd
	}
	if _efef := _edaf.AngleAttr.ValidateWithPath(path + "\u002fAngleAttr"); _efef != nil {
		return _efef
	}
	if _caaa := _edaf.DropautoAttr.ValidateWithPath(path + "\u002fDropautoAttr"); _caaa != nil {
		return _caaa
	}
	if _eccd := _edaf.LengthspecifiedAttr.ValidateWithPath(path + "/LengthspecifiedAttr"); _eccd != nil {
		return _eccd
	}
	if _feabgf := _edaf.AccentbarAttr.ValidateWithPath(path + "\u002fAccentbarAttr"); _feabgf != nil {
		return _feabgf
	}
	if _fgbgd := _edaf.TextborderAttr.ValidateWithPath(path + "\u002fTextborderAttr"); _fgbgd != nil {
		return _fgbgd
	}
	if _adbca := _edaf.MinusxAttr.ValidateWithPath(path + "/MinusxAttr"); _adbca != nil {
		return _adbca
	}
	if _gfdae := _edaf.MinusyAttr.ValidateWithPath(path + "/MinusyAttr"); _gfdae != nil {
		return _gfdae
	}
	if _accadc := _edaf.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _accadc != nil {
		return _accadc
	}
	return nil
}

const (
	OfcST_AngleUnset OfcST_Angle = 0
	OfcST_AngleAny   OfcST_Angle = 1
	OfcST_Angle30    OfcST_Angle = 2
	OfcST_Angle45    OfcST_Angle = 3
	OfcST_Angle60    OfcST_Angle = 4
	OfcST_Angle90    OfcST_Angle = 5
	OfcST_AngleAuto  OfcST_Angle = 6
)

func (_cadgb OfcST_CalloutPlacement) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_cadgb.String(), start)
}
func (_gadad *CT_Textbox) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bfggc := range start.Attr {
		if _bfggc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfggc.Name.Local == "singleclick" {
			_gadad.SingleclickAttr.UnmarshalXMLAttr(_bfggc)
			continue
		}
		if _bfggc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfggc.Name.Local == "insetmode" {
			_gadad.InsetmodeAttr.UnmarshalXMLAttr(_bfggc)
			continue
		}
		if _bfggc.Name.Local == "inset" {
			_cabba, _eedeg := _bfggc.Value, error(nil)
			if _eedeg != nil {
				return _eedeg
			}
			_gadad.InsetAttr = &_cabba
			continue
		}
		if _bfggc.Name.Local == "id" {
			_agdb, _gafgd := _bfggc.Value, error(nil)
			if _gafgd != nil {
				return _gafgd
			}
			_gadad.IdAttr = &_agdb
			continue
		}
		if _bfggc.Name.Local == "style" {
			_edbd, _ccdbe := _bfggc.Value, error(nil)
			if _ccdbe != nil {
				return _ccdbe
			}
			_gadad.StyleAttr = &_edbd
			continue
		}
	}
_fcafc:
	for {
		_ddac, _gdde := d.Token()
		if _gdde != nil {
			return _gdde
		}
		switch _cbafb := _ddac.(type) {
		case _b.StartElement:
			switch _cbafb.Name {
			case _b.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fwordprocessingml\u002f2006\u002fmain", Local: "txbxContent"}, _b.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg/ooxml\u002fwordprocessingml\u002fmain", Local: "txbxContent"}:
				_gadad.TxbxContent = _ebg.NewTxbxContent()
				if _bdbggd := d.DecodeElement(_gadad.TxbxContent, &_cbafb); _bdbggd != nil {
					return _bdbggd
				}
			default:
				if _afgdb, _aafaa := _ba.CreateElement(_cbafb); _aafaa != nil {
					return _aafaa
				} else {
					if _dfefg := d.DecodeElement(_afgdb, &_cbafb); _dfefg != nil {
						return _dfefg
					}
					_gadad.Any = _afgdb
				}
			}
		case _b.EndElement:
			break _fcafc
		case _b.CharData:
		}
	}
	return nil
}
func (_aad *AG_Chromakey) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _egf := range start.Attr {
		if _egf.Name.Local == "chromakey" {
			_agg, _eeg := _egf.Value, error(nil)
			if _eeg != nil {
				return _eeg
			}
			_aad.ChromakeyAttr = &_agg
			continue
		}
	}
	for {
		_afegd, _efc := d.Token()
		if _efc != nil {
			return _f.Errorf("parsing\u0020AG_Chromakey:\u0020\u0025s", _efc)
		}
		if _abda, _aaf := _afegd.(_b.EndElement); _aaf && _abda.Name == start.Name {
			break
		}
	}
	return nil
}
func NewOfcCT_Lock() *OfcCT_Lock { _ddgeb := &OfcCT_Lock{}; return _ddgeb }
func (_cefaaa OfcST_ExtrusionPlane) String() string {
	switch _cefaaa {
	case 0:
		return ""
	case 1:
		return "XY"
	case 2:
		return "ZX"
	case 3:
		return "YZ"
	}
	return ""
}
func (_abcab OfcST_ScreenSize) Validate() error { return _abcab.ValidateWithPath("") }
func (_fcebf *ST_StrokeArrowType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fcebf = 0
	case "none":
		*_fcebf = 1
	case "block":
		*_fcebf = 2
	case "classic":
		*_fcebf = 3
	case "oval":
		*_fcebf = 4
	case "diamond":
		*_fcebf = 5
	case "open":
		*_fcebf = 6
	}
	return nil
}

// ValidateWithPath validates the Path and its children, prefixing error messages with path
func (_gfcec *Path) ValidateWithPath(path string) error {
	if _gbcfe := _gfcec.CT_Path.ValidateWithPath(path); _gbcfe != nil {
		return _gbcfe
	}
	return nil
}
func NewCT_Path() *CT_Path { _bbce := &CT_Path{}; return _bbce }

type ST_EditAs byte

func (_ffedg OfcST_ExtrusionPlane) Validate() error { return _ffedg.ValidateWithPath("") }
func (_cbfbd *OfcST_ConnectType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_cbfbd = 0
	case "none":
		*_cbfbd = 1
	case "rect":
		*_cbfbd = 2
	case "segments":
		*_cbfbd = 3
	case "custom":
		*_cbfbd = 4
	}
	return nil
}
func (_efgeg *OfcST_ConnectorType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bcbfe, _cfdec := d.Token()
	if _cfdec != nil {
		return _cfdec
	}
	if _cccgf, _cafgb := _bcbfe.(_b.EndElement); _cafgb && _cccgf.Name == start.Name {
		*_efgeg = 1
		return nil
	}
	if _dbdccc, _ggbcc := _bcbfe.(_b.CharData); !_ggbcc {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bcbfe)
	} else {
		switch string(_dbdccc) {
		case "":
			*_efgeg = 0
		case "none":
			*_efgeg = 1
		case "straight":
			*_efgeg = 2
		case "elbow":
			*_efgeg = 3
		case "curved":
			*_efgeg = 4
		}
	}
	_bcbfe, _cfdec = d.Token()
	if _cfdec != nil {
		return _cfdec
	}
	if _gebdf, _bbfgf := _bcbfe.(_b.EndElement); _bbfgf && _gebdf.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bcbfe)
}

// Validate validates the CT_Shapetype and its children
func (_afdca *CT_Shapetype) Validate() error { return _afdca.ValidateWithPath("CT_Shapetype") }
func (_ffaac *ST_EditAs) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gcegdb, _dgbea := d.Token()
	if _dgbea != nil {
		return _dgbea
	}
	if _aggfb, _babebf := _gcegdb.(_b.EndElement); _babebf && _aggfb.Name == start.Name {
		*_ffaac = 1
		return nil
	}
	if _bdfe, _dcbce := _gcegdb.(_b.CharData); !_dcbce {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gcegdb)
	} else {
		switch string(_bdfe) {
		case "":
			*_ffaac = 0
		case "canvas":
			*_ffaac = 1
		case "orgchart":
			*_ffaac = 2
		case "radial":
			*_ffaac = 3
		case "cycle":
			*_ffaac = 4
		case "stacked":
			*_ffaac = 5
		case "venn":
			*_ffaac = 6
		case "bullseye":
			*_ffaac = 7
		}
	}
	_gcegdb, _dgbea = d.Token()
	if _dgbea != nil {
		return _dgbea
	}
	if _fadecg, _feddg := _gcegdb.(_b.EndElement); _feddg && _fadecg.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gcegdb)
}
func (_dgadb *OfcCT_RegroupTable) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bcgcad := range start.Attr {
		if _bcgcad.Name.Local == "ext" {
			_dgadb.ExtAttr.UnmarshalXMLAttr(_bcgcad)
			continue
		}
	}
_agccff:
	for {
		_egcbd, _fgffb := d.Token()
		if _fgffb != nil {
			return _fgffb
		}
		switch _gbbb := _egcbd.(type) {
		case _b.StartElement:
			switch _gbbb.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "entry"}:
				_cabfac := NewOfcCT_Entry()
				if _cgdaba := d.DecodeElement(_cabfac, &_gbbb); _cgdaba != nil {
					return _cgdaba
				}
				_dgadb.Entry = append(_dgadb.Entry, _cabfac)
			default:
				_ba.Log("skipping\u0020unsupported element\u0020on\u0020OfcCT_RegroupTable\u0020\u0025v", _gbbb.Name)
				if _adebe := d.Skip(); _adebe != nil {
					return _adebe
				}
			}
		case _b.EndElement:
			break _agccff
		case _b.CharData:
		}
	}
	return nil
}
func (_cbfgd *CT_Shapetype) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _cbfgd.MasterAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:master"}, Value: _f.Sprintf("\u0025v", *_cbfgd.MasterAttr)})
	}
	if _cbfgd.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_cbfgd.HrefAttr)})
	}
	if _cbfgd.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_cbfgd.TargetAttr)})
	}
	if _cbfgd.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_cbfgd.ClassAttr)})
	}
	if _cbfgd.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_cbfgd.TitleAttr)})
	}
	if _cbfgd.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_cbfgd.AltAttr)})
	}
	if _cbfgd.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_cbfgd.CoordsizeAttr)})
	}
	if _cbfgd.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_cbfgd.CoordoriginAttr)})
	}
	if _cbfgd.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_cbfgd.WrapcoordsAttr)})
	}
	if _cbfgd.PrintAttr != _eb.ST_TrueFalseUnset {
		_fegbc, _cagag := _cbfgd.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _cagag != nil {
			return _cagag
		}
		start.Attr = append(start.Attr, _fegbc)
	}
	if _cbfgd.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_cbfgd.IdAttr)})
	}
	if _cbfgd.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_cbfgd.StyleAttr)})
	}
	if _cbfgd.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_cbfgd.SpidAttr)})
	}
	if _cbfgd.OnedAttr != _eb.ST_TrueFalseUnset {
		_fgbf, _cbbga := _cbfgd.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _cbbga != nil {
			return _cbbga
		}
		start.Attr = append(start.Attr, _fgbf)
	}
	if _cbfgd.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_cbfgd.RegroupidAttr)})
	}
	if _cbfgd.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_gbee, _ebbc := _cbfgd.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _ebbc != nil {
			return _ebbc
		}
		start.Attr = append(start.Attr, _gbee)
	}
	if _cbfgd.ButtonAttr != _eb.ST_TrueFalseUnset {
		_gbdd, _gafefc := _cbfgd.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _gafefc != nil {
			return _gafefc
		}
		start.Attr = append(start.Attr, _gbdd)
	}
	if _cbfgd.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_efgd, _ccaff := _cbfgd.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _ccaff != nil {
			return _ccaff
		}
		start.Attr = append(start.Attr, _efgd)
	}
	if _cbfgd.BulletAttr != _eb.ST_TrueFalseUnset {
		_dffdf, _ecadfe := _cbfgd.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _ecadfe != nil {
			return _ecadfe
		}
		start.Attr = append(start.Attr, _dffdf)
	}
	if _cbfgd.HrAttr != _eb.ST_TrueFalseUnset {
		_fgceg, _cbaa := _cbfgd.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _cbaa != nil {
			return _cbaa
		}
		start.Attr = append(start.Attr, _fgceg)
	}
	if _cbfgd.HrstdAttr != _eb.ST_TrueFalseUnset {
		_eafdc, _bfcaa := _cbfgd.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _bfcaa != nil {
			return _bfcaa
		}
		start.Attr = append(start.Attr, _eafdc)
	}
	if _cbfgd.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_ebef, _aaef := _cbfgd.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _aaef != nil {
			return _aaef
		}
		start.Attr = append(start.Attr, _ebef)
	}
	if _cbfgd.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_cbfgd.HrpctAttr)})
	}
	if _cbfgd.HralignAttr != OfcST_HrAlignUnset {
		_bgab, _deaag := _cbfgd.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _deaag != nil {
			return _deaag
		}
		start.Attr = append(start.Attr, _bgab)
	}
	if _cbfgd.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_bbdfb, _eadad := _cbfgd.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _eadad != nil {
			return _eadad
		}
		start.Attr = append(start.Attr, _bbdfb)
	}
	if _cbfgd.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_adbef, _ecge := _cbfgd.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _ecge != nil {
			return _ecge
		}
		start.Attr = append(start.Attr, _adbef)
	}
	if _cbfgd.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_cdcd, _cegdg := _cbfgd.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _cegdg != nil {
			return _cegdg
		}
		start.Attr = append(start.Attr, _cdcd)
	}
	if _cbfgd.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_cbfgd.BordertopcolorAttr)})
	}
	if _cbfgd.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_cbfgd.BorderleftcolorAttr)})
	}
	if _cbfgd.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_cbfgd.BorderbottomcolorAttr)})
	}
	if _cbfgd.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_cbfgd.BorderrightcolorAttr)})
	}
	if _cbfgd.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_fgde, _ddgdf := _cbfgd.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _ddgdf != nil {
			return _ddgdf
		}
		start.Attr = append(start.Attr, _fgde)
	}
	if _cbfgd.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_cbfgd.DgmnodekindAttr)})
	}
	if _cbfgd.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_cdfag, _gbece := _cbfgd.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _gbece != nil {
			return _gbece
		}
		start.Attr = append(start.Attr, _cdfag)
	}
	if _cbfgd.InsetmodeAttr != OfcST_InsetModeUnset {
		_baeaf, _dcbge := _cbfgd.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _dcbge != nil {
			return _dcbge
		}
		start.Attr = append(start.Attr, _baeaf)
	}
	if _cbfgd.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_cbfgd.OpacityAttr)})
	}
	if _cbfgd.StrokedAttr != _eb.ST_TrueFalseUnset {
		_aebge, _cabaa := _cbfgd.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _cabaa != nil {
			return _cabaa
		}
		start.Attr = append(start.Attr, _aebge)
	}
	if _cbfgd.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_cbfgd.StrokecolorAttr)})
	}
	if _cbfgd.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_cbfgd.StrokeweightAttr)})
	}
	if _cbfgd.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_aaaeg, _ddee := _cbfgd.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _ddee != nil {
			return _ddee
		}
		start.Attr = append(start.Attr, _aaaeg)
	}
	if _cbfgd.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_cbfgd.ChromakeyAttr)})
	}
	if _cbfgd.FilledAttr != _eb.ST_TrueFalseUnset {
		_feafg, _aaefe := _cbfgd.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _aaefe != nil {
			return _aaefe
		}
		start.Attr = append(start.Attr, _feafg)
	}
	if _cbfgd.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_cbfgd.FillcolorAttr)})
	}
	if _cbfgd.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_cbfgd.SptAttr)})
	}
	if _cbfgd.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_aedeb, _bcbbb := _cbfgd.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _bcbbb != nil {
			return _bcbbb
		}
		start.Attr = append(start.Attr, _aedeb)
	}
	if _cbfgd.BwmodeAttr != OfcST_BWModeUnset {
		_gada, _gfecg := _cbfgd.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _gfecg != nil {
			return _gfecg
		}
		start.Attr = append(start.Attr, _gada)
	}
	if _cbfgd.BwpureAttr != OfcST_BWModeUnset {
		_dfdfg, _baba := _cbfgd.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _baba != nil {
			return _baba
		}
		start.Attr = append(start.Attr, _dfdfg)
	}
	if _cbfgd.BwnormalAttr != OfcST_BWModeUnset {
		_dbcca, _dfbf := _cbfgd.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _dfbf != nil {
			return _dfbf
		}
		start.Attr = append(start.Attr, _dbcca)
	}
	if _cbfgd.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_gcdff, _cbgea := _cbfgd.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _cbgea != nil {
			return _cbgea
		}
		start.Attr = append(start.Attr, _gcdff)
	}
	if _cbfgd.OleiconAttr != _eb.ST_TrueFalseUnset {
		_fcbbd, _babbg := _cbfgd.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _babbg != nil {
			return _babbg
		}
		start.Attr = append(start.Attr, _fcbbd)
	}
	if _cbfgd.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_egbd, _ffebg := _cbfgd.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _ffebg != nil {
			return _ffebg
		}
		start.Attr = append(start.Attr, _egbd)
	}
	if _cbfgd.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_fbcfd, _cabdb := _cbfgd.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _cabdb != nil {
			return _cabdb
		}
		start.Attr = append(start.Attr, _fbcfd)
	}
	if _cbfgd.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_gaeab, _fecgf := _cbfgd.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _fecgf != nil {
			return _fecgf
		}
		start.Attr = append(start.Attr, _gaeab)
	}
	if _cbfgd.ClipAttr != _eb.ST_TrueFalseUnset {
		_bfbb, _bfbdbe := _cbfgd.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _bfbdbe != nil {
			return _bfbdbe
		}
		start.Attr = append(start.Attr, _bfbb)
	}
	if _cbfgd.AdjAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "adj"}, Value: _f.Sprintf("\u0025v", *_cbfgd.AdjAttr)})
	}
	if _cbfgd.PathAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "path"}, Value: _f.Sprintf("\u0025v", *_cbfgd.PathAttr)})
	}
	e.EncodeToken(start)
	if _cbfgd.EG_ShapeElements != nil {
		for _, _dfgc := range _cbfgd.EG_ShapeElements {
			_dfgc.MarshalXML(e, _b.StartElement{})
		}
	}
	if _cbfgd.Complex != nil {
		_eeacd := _b.StartElement{Name: _b.Name{Local: "o:complex"}}
		e.EncodeElement(_cbfgd.Complex, _eeacd)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the OfcInk and its children, prefixing error messages with path
func (_dfgcfc *OfcInk) ValidateWithPath(path string) error {
	if _ebbf := _dfgcfc.OfcCT_Ink.ValidateWithPath(path); _ebbf != nil {
		return _ebbf
	}
	return nil
}
func NewCT_Handles() *CT_Handles { _gcbd := &CT_Handles{}; return _gcbd }

type CT_TextPath struct {
	OnAttr       _eb.ST_TrueFalse
	FitshapeAttr _eb.ST_TrueFalse
	FitpathAttr  _eb.ST_TrueFalse
	TrimAttr     _eb.ST_TrueFalse
	XscaleAttr   _eb.ST_TrueFalse
	StringAttr   *string
	IdAttr       *string
	StyleAttr    *string
}

// Validate validates the AG_Path and its children
func (_gacc *AG_Path) Validate() error { return _gacc.ValidateWithPath("AG_Path") }

type CT_RoundRect struct {
	ArcsizeAttr           *string
	EG_ShapeElements      []*EG_ShapeElements
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
	OpacityAttr           *string
	StrokedAttr           _eb.ST_TrueFalse
	StrokecolorAttr       *string
	StrokeweightAttr      *string
	InsetpenAttr          _eb.ST_TrueFalse
	ChromakeyAttr         *string
	FilledAttr            _eb.ST_TrueFalse
	FillcolorAttr         *string
	SptAttr               *float32
	ConnectortypeAttr     OfcST_ConnectorType
	BwmodeAttr            OfcST_BWMode
	BwpureAttr            OfcST_BWMode
	BwnormalAttr          OfcST_BWMode
	ForcedashAttr         _eb.ST_TrueFalse
	OleiconAttr           _eb.ST_TrueFalse
	OleAttr               _eb.ST_TrueFalseBlank
	PreferrelativeAttr    _eb.ST_TrueFalse
	CliptowrapAttr        _eb.ST_TrueFalse
	ClipAttr              _eb.ST_TrueFalse
}

func (_cbbce *OfcCT_R) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", _cbbce.IdAttr)})
	if _cbbce.TypeAttr != OfcST_RTypeUnset {
		_bgaee, _dbdfe := _cbbce.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _dbdfe != nil {
			return _dbdfe
		}
		start.Attr = append(start.Attr, _bgaee)
	}
	if _cbbce.HowAttr != OfcST_HowUnset {
		_beef, _aagef := _cbbce.HowAttr.MarshalXMLAttr(_b.Name{Local: "how"})
		if _aagef != nil {
			return _aagef
		}
		start.Attr = append(start.Attr, _beef)
	}
	if _cbbce.IdrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "idref"}, Value: _f.Sprintf("\u0025v", *_cbbce.IdrefAttr)})
	}
	e.EncodeToken(start)
	if _cbbce.Proxy != nil {
		_gdagb := _b.StartElement{Name: _b.Name{Local: "o:proxy"}}
		for _, _edddg := range _cbbce.Proxy {
			e.EncodeElement(_edddg, _gdagb)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the OfcCT_Rules and its children
func (_efbfb *OfcCT_Rules) Validate() error { return _efbfb.ValidateWithPath("OfcCT_Rules") }
func (_fedbd OfcST_ExtrusionPlane) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_fedbd.String(), start)
}

// ValidateWithPath validates the Imagedata and its children, prefixing error messages with path
func (_ecdgb *Imagedata) ValidateWithPath(path string) error {
	if _fgccd := _ecdgb.CT_ImageData.ValidateWithPath(path); _fgccd != nil {
		return _fgccd
	}
	return nil
}

// ValidateWithPath validates the CT_H and its children, prefixing error messages with path
func (_bfcea *CT_H) ValidateWithPath(path string) error {
	if _bed := _bfcea.InvxAttr.ValidateWithPath(path + "\u002fInvxAttr"); _bed != nil {
		return _bed
	}
	if _aceg := _bfcea.InvyAttr.ValidateWithPath(path + "\u002fInvyAttr"); _aceg != nil {
		return _aceg
	}
	if _fffa := _bfcea.SwitchAttr.ValidateWithPath(path + "/SwitchAttr"); _fffa != nil {
		return _fffa
	}
	return nil
}

// ValidateWithPath validates the AG_Style and its children, prefixing error messages with path
func (_accab *AG_Style) ValidateWithPath(path string) error { return nil }

type Textbox struct{ CT_Textbox }

// Validate validates the AG_Style and its children
func (_egff *AG_Style) Validate() error       { return _egff.ValidateWithPath("AG_Style") }
func (_dfebf OfcST_FillType) Validate() error { return _dfebf.ValidateWithPath("") }
func NewOfcShapedefaults() *OfcShapedefaults {
	_fceda := &OfcShapedefaults{}
	_fceda.OfcCT_ShapeDefaults = *NewOfcCT_ShapeDefaults()
	return _fceda
}
func (_addgf *OfcST_BWMode) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_afcbeb, _gcaeb := d.Token()
	if _gcaeb != nil {
		return _gcaeb
	}
	if _egcgbd, _cfcaf := _afcbeb.(_b.EndElement); _cfcaf && _egcgbd.Name == start.Name {
		*_addgf = 1
		return nil
	}
	if _aaccg, _fdegd := _afcbeb.(_b.CharData); !_fdegd {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _afcbeb)
	} else {
		switch string(_aaccg) {
		case "":
			*_addgf = 0
		case "color":
			*_addgf = 1
		case "auto":
			*_addgf = 2
		case "grayScale":
			*_addgf = 3
		case "lightGrayscale":
			*_addgf = 4
		case "inverseGray":
			*_addgf = 5
		case "grayOutline":
			*_addgf = 6
		case "highContrast":
			*_addgf = 7
		case "black":
			*_addgf = 8
		case "white":
			*_addgf = 9
		case "hide":
			*_addgf = 10
		case "undrawn":
			*_addgf = 11
		case "blackTextAndLines":
			*_addgf = 12
		}
	}
	_afcbeb, _gcaeb = d.Token()
	if _gcaeb != nil {
		return _gcaeb
	}
	if _gbce, _cabgae := _afcbeb.(_b.EndElement); _cabgae && _gbce.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _afcbeb)
}

// Validate validates the AG_Ext and its children
func (_eag *AG_Ext) Validate() error { return _eag.ValidateWithPath("AG_Ext") }
func (_edgef *ST_FillType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fbagc, _fcaacd := d.Token()
	if _fcaacd != nil {
		return _fcaacd
	}
	if _cacfa, _aeegf := _fbagc.(_b.EndElement); _aeegf && _cacfa.Name == start.Name {
		*_edgef = 1
		return nil
	}
	if _bgead, _gfegg := _fbagc.(_b.CharData); !_gfegg {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _fbagc)
	} else {
		switch string(_bgead) {
		case "":
			*_edgef = 0
		case "solid":
			*_edgef = 1
		case "gradient":
			*_edgef = 2
		case "gradientRadial":
			*_edgef = 3
		case "tile":
			*_edgef = 4
		case "pattern":
			*_edgef = 5
		case "frame":
			*_edgef = 6
		}
	}
	_fbagc, _fcaacd = d.Token()
	if _fcaacd != nil {
		return _fcaacd
	}
	if _gccdc, _ebdgc := _fbagc.(_b.EndElement); _ebdgc && _gccdc.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _fbagc)
}
func (_edbf OfcST_RType) ValidateWithPath(path string) error {
	switch _edbf {
	case 0, 1, 2, 3, 4:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_edbf))
	}
	return nil
}
func (_gdeecc OfcST_ScreenSize) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_accfc := _b.Attr{}
	_accfc.Name = name
	switch _gdeecc {
	case OfcST_ScreenSizeUnset:
		_accfc.Value = ""
	case OfcST_ScreenSize544x376:
		_accfc.Value = "544\u002c376"
	case OfcST_ScreenSize640x480:
		_accfc.Value = "640\u002c480"
	case OfcST_ScreenSize720x512:
		_accfc.Value = "720\u002c512"
	case OfcST_ScreenSize800x600:
		_accfc.Value = "800\u002c600"
	case OfcST_ScreenSize1024x768:
		_accfc.Value = "1024\u002c768"
	case OfcST_ScreenSize1152x862:
		_accfc.Value = "1152\u002c862"
	}
	return _accfc, nil
}
func (_acbg *OfcFill) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:fill"
	return _acbg.OfcCT_Fill.MarshalXML(e, start)
}

// ValidateWithPath validates the AG_Adj and its children, prefixing error messages with path
func (_cca *AG_Adj) ValidateWithPath(path string) error { return nil }
func (_fcdd *Group) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _fcdd.CT_Group.MarshalXML(e, start)
}

// ValidateWithPath validates the Stroke and its children, prefixing error messages with path
func (_afgecc *Stroke) ValidateWithPath(path string) error {
	if _gbgf := _afgecc.CT_Stroke.ValidateWithPath(path); _gbgf != nil {
		return _gbgf
	}
	return nil
}
func NewOval() *Oval   { _ecec := &Oval{}; _ecec.CT_Oval = *NewCT_Oval(); return _ecec }
func NewAG_Id() *AG_Id { _egfb := &AG_Id{}; return _egfb }

// ValidateWithPath validates the CT_Fill and its children, prefixing error messages with path
func (_fagbf *CT_Fill) ValidateWithPath(path string) error {
	if _eeaff := _fagbf.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _eeaff != nil {
		return _eeaff
	}
	if _bagc := _fagbf.OnAttr.ValidateWithPath(path + "\u002fOnAttr"); _bagc != nil {
		return _bagc
	}
	if _ged := _fagbf.AspectAttr.ValidateWithPath(path + "/AspectAttr"); _ged != nil {
		return _ged
	}
	if _fddf := _fagbf.AlignshapeAttr.ValidateWithPath(path + "\u002fAlignshapeAttr"); _fddf != nil {
		return _fddf
	}
	if _gdbdc := _fagbf.MethodAttr.ValidateWithPath(path + "/MethodAttr"); _gdbdc != nil {
		return _gdbdc
	}
	if _addd := _fagbf.DetectmouseclickAttr.ValidateWithPath(path + "/DetectmouseclickAttr"); _addd != nil {
		return _addd
	}
	if _egcf := _fagbf.RecolorAttr.ValidateWithPath(path + "\u002fRecolorAttr"); _egcf != nil {
		return _egcf
	}
	if _cefe := _fagbf.RotateAttr.ValidateWithPath(path + "/RotateAttr"); _cefe != nil {
		return _cefe
	}
	if _fagbf.Fill != nil {
		if _efeb := _fagbf.Fill.ValidateWithPath(path + "\u002fFill"); _efeb != nil {
			return _efeb
		}
	}
	return nil
}
func NewTextpath() *Textpath {
	_edcba := &Textpath{}
	_edcba.CT_TextPath = *NewCT_TextPath()
	return _edcba
}
func (_cceb *Rect) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _cceb.CT_Rect.MarshalXML(e, start)
}

const (
	ST_StrokeArrowWidthUnset  ST_StrokeArrowWidth = 0
	ST_StrokeArrowWidthNarrow ST_StrokeArrowWidth = 1
	ST_StrokeArrowWidthMedium ST_StrokeArrowWidth = 2
	ST_StrokeArrowWidthWide   ST_StrokeArrowWidth = 3
)

// ValidateWithPath validates the OfcSignatureline and its children, prefixing error messages with path
func (_ggada *OfcSignatureline) ValidateWithPath(path string) error {
	if _gfac := _ggada.OfcCT_SignatureLine.ValidateWithPath(path); _gfac != nil {
		return _gfac
	}
	return nil
}
func (_efcae *ST_EditAs) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_efcae = 0
	case "canvas":
		*_efcae = 1
	case "orgchart":
		*_efcae = 2
	case "radial":
		*_efcae = 3
	case "cycle":
		*_efcae = 4
	case "stacked":
		*_efcae = 5
	case "venn":
		*_efcae = 6
	case "bullseye":
		*_efcae = 7
	}
	return nil
}

// Validate validates the OfcCT_Extrusion and its children
func (_dedea *OfcCT_Extrusion) Validate() error { return _dedea.ValidateWithPath("OfcCT_Extrusion") }
func (_bbced OfcST_ConnectorType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bbced.String(), start)
}
func (_bdacb OfcST_OLEType) ValidateWithPath(path string) error {
	switch _bdacb {
	case 0, 1, 2:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bdacb))
	}
	return nil
}
func NewCT_ImageData() *CT_ImageData { _adcd := &CT_ImageData{}; return _adcd }

// ValidateWithPath validates the OfcCT_Diagram and its children, prefixing error messages with path
func (_caefff *OfcCT_Diagram) ValidateWithPath(path string) error {
	if _bfgbg := _caefff.AutoformatAttr.ValidateWithPath(path + "\u002fAutoformatAttr"); _bfgbg != nil {
		return _bfgbg
	}
	if _beagd := _caefff.ReverseAttr.ValidateWithPath(path + "\u002fReverseAttr"); _beagd != nil {
		return _beagd
	}
	if _effa := _caefff.AutolayoutAttr.ValidateWithPath(path + "\u002fAutolayoutAttr"); _effa != nil {
		return _effa
	}
	if _caefff.Relationtable != nil {
		if _eefbd := _caefff.Relationtable.ValidateWithPath(path + "\u002fRelationtable"); _eefbd != nil {
			return _eefbd
		}
	}
	if _dgaae := _caefff.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _dgaae != nil {
		return _dgaae
	}
	return nil
}

// Validate validates the Imagedata and its children
func (_fddaaf *Imagedata) Validate() error { return _fddaaf.ValidateWithPath("Imagedata") }

// Validate validates the CT_PolyLine and its children
func (_aage *CT_PolyLine) Validate() error { return _aage.ValidateWithPath("CT_PolyLine") }
func (_dbgga OfcST_ConnectType) String() string {
	switch _dbgga {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "rect"
	case 3:
		return "segments"
	case 4:
		return "custom"
	}
	return ""
}
func (_beaag ST_StrokeArrowLength) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_beaag.String(), start)
}
func (_dddedb ST_StrokeJoinStyle) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_dddedb.String(), start)
}
func (_acaege *OfcDiagram) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_acaege.OfcCT_Diagram = *NewOfcCT_Diagram()
	for _, _ebeef := range start.Attr {
		if _ebeef.Name.Local == "dgmstyle" {
			_edgb, _acbbcb := _e.ParseInt(_ebeef.Value, 10, 64)
			if _acbbcb != nil {
				return _acbbcb
			}
			_acaege.DgmstyleAttr = &_edgb
			continue
		}
		if _ebeef.Name.Local == "autoformat" {
			_acaege.AutoformatAttr.UnmarshalXMLAttr(_ebeef)
			continue
		}
		if _ebeef.Name.Local == "reverse" {
			_acaege.ReverseAttr.UnmarshalXMLAttr(_ebeef)
			continue
		}
		if _ebeef.Name.Local == "autolayout" {
			_acaege.AutolayoutAttr.UnmarshalXMLAttr(_ebeef)
			continue
		}
		if _ebeef.Name.Local == "dgmscalex" {
			_fgfec, _ggafd := _e.ParseInt(_ebeef.Value, 10, 64)
			if _ggafd != nil {
				return _ggafd
			}
			_acaege.DgmscalexAttr = &_fgfec
			continue
		}
		if _ebeef.Name.Local == "dgmscaley" {
			_caefa, _fgfgb := _e.ParseInt(_ebeef.Value, 10, 64)
			if _fgfgb != nil {
				return _fgfgb
			}
			_acaege.DgmscaleyAttr = &_caefa
			continue
		}
		if _ebeef.Name.Local == "dgmfontsize" {
			_fcbac, _gdef := _e.ParseInt(_ebeef.Value, 10, 64)
			if _gdef != nil {
				return _gdef
			}
			_acaege.DgmfontsizeAttr = &_fcbac
			continue
		}
		if _ebeef.Name.Local == "constrainbounds" {
			_gcffda, _ccdc := _ebeef.Value, error(nil)
			if _ccdc != nil {
				return _ccdc
			}
			_acaege.ConstrainboundsAttr = &_gcffda
			continue
		}
		if _ebeef.Name.Local == "dgmbasetextscale" {
			_febdg, _bbcea := _e.ParseInt(_ebeef.Value, 10, 64)
			if _bbcea != nil {
				return _bbcea
			}
			_acaege.DgmbasetextscaleAttr = &_febdg
			continue
		}
		if _ebeef.Name.Local == "ext" {
			_acaege.ExtAttr.UnmarshalXMLAttr(_ebeef)
			continue
		}
	}
_dadaf:
	for {
		_afcdd, _adafg := d.Token()
		if _adafg != nil {
			return _adafg
		}
		switch _gagcf := _afcdd.(type) {
		case _b.StartElement:
			switch _gagcf.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "relationtable"}:
				_acaege.Relationtable = NewOfcCT_RelationTable()
				if _cfbgg := d.DecodeElement(_acaege.Relationtable, &_gagcf); _cfbgg != nil {
					return _cfbgg
				}
			default:
				_ba.Log("skipping unsupported\u0020element\u0020on\u0020OfcDiagram\u0020\u0025v", _gagcf.Name)
				if _efddc := d.Skip(); _efddc != nil {
					return _efddc
				}
			}
		case _b.EndElement:
			break _dadaf
		case _b.CharData:
		}
	}
	return nil
}

// Validate validates the AG_CoreAttributes and its children
func (_efg *AG_CoreAttributes) Validate() error { return _efg.ValidateWithPath("AG_CoreAttributes") }
func (_cdead *ST_StrokeLineStyle) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_cdead = 0
	case "single":
		*_cdead = 1
	case "thinThin":
		*_cdead = 2
	case "thinThick":
		*_cdead = 3
	case "thickThin":
		*_cdead = 4
	case "thickBetweenThin":
		*_cdead = 5
	}
	return nil
}
func (_bedg ST_ShadowType) ValidateWithPath(path string) error {
	switch _bedg {
	case 0, 1, 2, 3, 4:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bedg))
	}
	return nil
}
func (_eagcgg ST_ImageAspect) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gdeea := _b.Attr{}
	_gdeea.Name = name
	switch _eagcgg {
	case ST_ImageAspectUnset:
		_gdeea.Value = ""
	case ST_ImageAspectIgnore:
		_gdeea.Value = "ignore"
	case ST_ImageAspectAtMost:
		_gdeea.Value = "atMost"
	case ST_ImageAspectAtLeast:
		_gdeea.Value = "atLeast"
	}
	return _gdeea, nil
}
func (_eegdd *OfcCT_ShapeDefaults) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _abbfb := range start.Attr {
		if _abbfb.Name.Local == "spidmax" {
			_acgce, _gdagfe := _e.ParseInt(_abbfb.Value, 10, 64)
			if _gdagfe != nil {
				return _gdagfe
			}
			_eegdd.SpidmaxAttr = &_acgce
			continue
		}
		if _abbfb.Name.Local == "allowincell" {
			_eegdd.AllowincellAttr.UnmarshalXMLAttr(_abbfb)
			continue
		}
		if _abbfb.Name.Local == "strokecolor" {
			_bffg, _feaadc := _abbfb.Value, error(nil)
			if _feaadc != nil {
				return _feaadc
			}
			_eegdd.StrokecolorAttr = &_bffg
			continue
		}
		if _abbfb.Name.Local == "stroke" {
			_eegdd.StrokeAttr.UnmarshalXMLAttr(_abbfb)
			continue
		}
		if _abbfb.Name.Local == "fillcolor" {
			_bgaaa, _bcbed := _abbfb.Value, error(nil)
			if _bcbed != nil {
				return _bcbed
			}
			_eegdd.FillcolorAttr = &_bgaaa
			continue
		}
		if _abbfb.Name.Local == "fill" {
			_eegdd.FillAttr.UnmarshalXMLAttr(_abbfb)
			continue
		}
		if _abbfb.Name.Local == "style" {
			_ggbgd, _bbgff := _abbfb.Value, error(nil)
			if _bbgff != nil {
				return _bbgff
			}
			_eegdd.StyleAttr = &_ggbgd
			continue
		}
		if _abbfb.Name.Local == "ext" {
			_eegdd.ExtAttr.UnmarshalXMLAttr(_abbfb)
			continue
		}
	}
_gdbef:
	for {
		_aeegb, _ffagd := d.Token()
		if _ffagd != nil {
			return _ffagd
		}
		switch _ffdac := _aeegb.(type) {
		case _b.StartElement:
			switch _ffdac.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_eegdd.Fill = NewFill()
				if _ffge := d.DecodeElement(_eegdd.Fill, &_ffdac); _ffge != nil {
					return _ffge
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_eegdd.Stroke = NewStroke()
				if _bbgbc := d.DecodeElement(_eegdd.Stroke, &_ffdac); _bbgbc != nil {
					return _bbgbc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_eegdd.Textbox = NewTextbox()
				if _cbage := d.DecodeElement(_eegdd.Textbox, &_ffdac); _cbage != nil {
					return _cbage
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_eegdd.Shadow = NewShadow()
				if _egcaf := d.DecodeElement(_eegdd.Shadow, &_ffdac); _egcaf != nil {
					return _egcaf
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_eegdd.Skew = NewOfcSkew()
				if _cefbf := d.DecodeElement(_eegdd.Skew, &_ffdac); _cefbf != nil {
					return _cefbf
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_eegdd.Extrusion = NewOfcExtrusion()
				if _caaga := d.DecodeElement(_eegdd.Extrusion, &_ffdac); _caaga != nil {
					return _caaga
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_eegdd.Callout = NewOfcCallout()
				if _fgcdce := d.DecodeElement(_eegdd.Callout, &_ffdac); _fgcdce != nil {
					return _fgcdce
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_eegdd.Lock = NewOfcLock()
				if _afcdf := d.DecodeElement(_eegdd.Lock, &_ffdac); _afcdf != nil {
					return _afcdf
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "colormru"}:
				_eegdd.Colormru = NewOfcCT_ColorMru()
				if _ecaef := d.DecodeElement(_eegdd.Colormru, &_ffdac); _ecaef != nil {
					return _ecaef
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "colormenu"}:
				_eegdd.Colormenu = NewOfcCT_ColorMenu()
				if _ebega := d.DecodeElement(_eegdd.Colormenu, &_ffdac); _ebega != nil {
					return _ebega
				}
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020OfcCT_ShapeDefaults\u0020\u0025v", _ffdac.Name)
				if _begcc := d.Skip(); _begcc != nil {
					return _begcc
				}
			}
		case _b.EndElement:
			break _gdbef
		case _b.CharData:
		}
	}
	return nil
}

type OfcST_How byte

func (_ggbga *OfcCT_StrokeChild) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ebccg := range start.Attr {
		if _ebccg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebccg.Name.Local == "href" {
			_bgdca, _dcdcf := _ebccg.Value, error(nil)
			if _dcdcf != nil {
				return _dcdcf
			}
			_ggbga.HrefAttr = &_bgdca
			continue
		}
		if _ebccg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebccg.Name.Local == "forcedash" {
			_ggbga.ForcedashAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebccg.Name.Local == "title" {
			_fdcbd, _abeaf := _ebccg.Value, error(nil)
			if _abeaf != nil {
				return _abeaf
			}
			_ggbga.TitleAttr = &_fdcbd
			continue
		}
		if _ebccg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebccg.Name.Local == "althref" {
			_bdcbd, _bfgce := _ebccg.Value, error(nil)
			if _bfgce != nil {
				return _bfgce
			}
			_ggbga.AlthrefAttr = &_bdcbd
			continue
		}
		if _ebccg.Name.Local == "imageaspect" {
			_ggbga.ImageaspectAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "startarrow" {
			_ggbga.StartarrowAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "linestyle" {
			_ggbga.LinestyleAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "startarrowwidth" {
			_ggbga.StartarrowwidthAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "joinstyle" {
			_ggbga.JoinstyleAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "startarrowlength" {
			_ggbga.StartarrowlengthAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "dashstyle" {
			_bbccf, _fgbdf := _ebccg.Value, error(nil)
			if _fgbdf != nil {
				return _fgbdf
			}
			_ggbga.DashstyleAttr = &_bbccf
			continue
		}
		if _ebccg.Name.Local == "endarrow" {
			_ggbga.EndarrowAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "filltype" {
			_ggbga.FilltypeAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "endarrowwidth" {
			_ggbga.EndarrowwidthAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "opacity" {
			_geeaa, _efbfg := _ebccg.Value, error(nil)
			if _efbfg != nil {
				return _efbfg
			}
			_ggbga.OpacityAttr = &_geeaa
			continue
		}
		if _ebccg.Name.Local == "color" {
			_faeef, _cbadg := _ebccg.Value, error(nil)
			if _cbadg != nil {
				return _cbadg
			}
			_ggbga.ColorAttr = &_faeef
			continue
		}
		if _ebccg.Name.Local == "insetpen" {
			_ggbga.InsetpenAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "endarrowlength" {
			_ggbga.EndarrowlengthAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "ext" {
			_ggbga.ExtAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "endcap" {
			_ggbga.EndcapAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "color2" {
			_cgccf, _gaefe := _ebccg.Value, error(nil)
			if _gaefe != nil {
				return _gaefe
			}
			_ggbga.Color2Attr = &_cgccf
			continue
		}
		if _ebccg.Name.Local == "imagealignshape" {
			_ggbga.ImagealignshapeAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
		if _ebccg.Name.Local == "weight" {
			_dgdgf, _fbfbc := _ebccg.Value, error(nil)
			if _fbfbc != nil {
				return _fbfbc
			}
			_ggbga.WeightAttr = &_dgdgf
			continue
		}
		if _ebccg.Name.Local == "src" {
			_bdgcg, _bffb := _ebccg.Value, error(nil)
			if _bffb != nil {
				return _bffb
			}
			_ggbga.SrcAttr = &_bdgcg
			continue
		}
		if _ebccg.Name.Local == "imagesize" {
			_gcgbc, _ggaac := _ebccg.Value, error(nil)
			if _ggaac != nil {
				return _ggaac
			}
			_ggbga.ImagesizeAttr = &_gcgbc
			continue
		}
		if _ebccg.Name.Local == "miterlimit" {
			_efbe, _aaaee := _e.ParseFloat(_ebccg.Value, 64)
			if _aaaee != nil {
				return _aaaee
			}
			_ggbga.MiterlimitAttr = &_efbe
			continue
		}
		if _ebccg.Name.Local == "on" {
			_ggbga.OnAttr.UnmarshalXMLAttr(_ebccg)
			continue
		}
	}
	for {
		_gegbe, _fccbbf := d.Token()
		if _fccbbf != nil {
			return _f.Errorf("parsing\u0020OfcCT_StrokeChild: \u0025s", _fccbbf)
		}
		if _fdae, _ggdecg := _gegbe.(_b.EndElement); _ggdecg && _fdae.Name == start.Name {
			break
		}
	}
	return nil
}

type Shapetype struct{ CT_Shapetype }

func (_fgaeg *Roundrect) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _fgaeg.CT_RoundRect.MarshalXML(e, start)
}
func (_acgg *Oval) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_acgg.CT_Oval = *NewCT_Oval()
	for _, _bccbc := range start.Attr {
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "bordertopcolor" {
			_cbcfbg, _edfab := _bccbc.Value, error(nil)
			if _edfab != nil {
				return _edfab
			}
			_acgg.BordertopcolorAttr = &_cbcfbg
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "bullet" {
			_acgg.BulletAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "hr" {
			_acgg.HrAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "cliptowrap" {
			_acgg.CliptowrapAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "hrstd" {
			_acgg.HrstdAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "ole" {
			_acgg.OleAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "hrnoshade" {
			_acgg.HrnoshadeAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "oned" {
			_acgg.OnedAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "hrpct" {
			_gddbg, _geegd := _e.ParseFloat(_bccbc.Value, 64)
			if _geegd != nil {
				return _geegd
			}
			_bgfda := float32(_gddbg)
			_acgg.HrpctAttr = &_bgfda
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "oleicon" {
			_acgg.OleiconAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "borderbottomcolor" {
			_dgdaf, _fefad := _bccbc.Value, error(nil)
			if _fefad != nil {
				return _fefad
			}
			_acgg.BorderbottomcolorAttr = &_dgdaf
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "dgmlayoutmru" {
			_acgg.DgmlayoutmruAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "regroupid" {
			_fdegb, _eggba := _e.ParseInt(_bccbc.Value, 10, 64)
			if _eggba != nil {
				return _eggba
			}
			_acgg.RegroupidAttr = &_fdegb
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "clip" {
			_acgg.ClipAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "hralign" {
			_acgg.HralignAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "preferrelative" {
			_acgg.PreferrelativeAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "dgmlayout" {
			_acgg.DgmlayoutAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "doubleclicknotify" {
			_acgg.DoubleclicknotifyAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "insetmode" {
			_acgg.InsetmodeAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "button" {
			_acgg.ButtonAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "userdrawn" {
			_acgg.UserdrawnAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "allowincell" {
			_acgg.AllowincellAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "spt" {
			_cbgca, _ffgdd := _e.ParseFloat(_bccbc.Value, 64)
			if _ffgdd != nil {
				return _ffgdd
			}
			_fcgeb := float32(_cbgca)
			_acgg.SptAttr = &_fcgeb
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "borderleftcolor" {
			_gggff, _fffdc := _bccbc.Value, error(nil)
			if _fffdc != nil {
				return _fffdc
			}
			_acgg.BorderleftcolorAttr = &_gggff
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "connectortype" {
			_acgg.ConnectortypeAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "borderrightcolor" {
			_afdgc, _dbbe := _bccbc.Value, error(nil)
			if _dbbe != nil {
				return _dbbe
			}
			_acgg.BorderrightcolorAttr = &_afdgc
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "spid" {
			_afffge, _ccdeg := _bccbc.Value, error(nil)
			if _ccdeg != nil {
				return _ccdeg
			}
			_acgg.SpidAttr = &_afffge
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "dgmnodekind" {
			_degbf, _fedff := _e.ParseInt(_bccbc.Value, 10, 64)
			if _fedff != nil {
				return _fedff
			}
			_acgg.DgmnodekindAttr = &_degbf
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "bwpure" {
			_acgg.BwpureAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "forcedash" {
			_acgg.ForcedashAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "bwnormal" {
			_acgg.BwnormalAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "bwmode" {
			_acgg.BwmodeAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "userhidden" {
			_acgg.UserhiddenAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bccbc.Name.Local == "allowoverlap" {
			_acgg.AllowoverlapAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Local == "target" {
			_fbfd, _fffec := _bccbc.Value, error(nil)
			if _fffec != nil {
				return _fffec
			}
			_acgg.TargetAttr = &_fbfd
			continue
		}
		if _bccbc.Name.Local == "coordorigin" {
			_ecdgg, _agefg := _bccbc.Value, error(nil)
			if _agefg != nil {
				return _agefg
			}
			_acgg.CoordoriginAttr = &_ecdgg
			continue
		}
		if _bccbc.Name.Local == "stroked" {
			_acgg.StrokedAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Local == "coordsize" {
			_bebcd, _gbeca := _bccbc.Value, error(nil)
			if _gbeca != nil {
				return _gbeca
			}
			_acgg.CoordsizeAttr = &_bebcd
			continue
		}
		if _bccbc.Name.Local == "strokeweight" {
			_cgbfb, _gfadb := _bccbc.Value, error(nil)
			if _gfadb != nil {
				return _gfadb
			}
			_acgg.StrokeweightAttr = &_cgbfb
			continue
		}
		if _bccbc.Name.Local == "style" {
			_baceag, _gdgee := _bccbc.Value, error(nil)
			if _gdgee != nil {
				return _gdgee
			}
			_acgg.StyleAttr = &_baceag
			continue
		}
		if _bccbc.Name.Local == "chromakey" {
			_dbbc, _cgfdee := _bccbc.Value, error(nil)
			if _cgfdee != nil {
				return _cgfdee
			}
			_acgg.ChromakeyAttr = &_dbbc
			continue
		}
		if _bccbc.Name.Local == "fillcolor" {
			_cdaba, _egffb := _bccbc.Value, error(nil)
			if _egffb != nil {
				return _egffb
			}
			_acgg.FillcolorAttr = &_cdaba
			continue
		}
		if _bccbc.Name.Local == "opacity" {
			_abgag, _cecea := _bccbc.Value, error(nil)
			if _cecea != nil {
				return _cecea
			}
			_acgg.OpacityAttr = &_abgag
			continue
		}
		if _bccbc.Name.Local == "wrapcoords" {
			_degbga, _fbabe := _bccbc.Value, error(nil)
			if _fbabe != nil {
				return _fbabe
			}
			_acgg.WrapcoordsAttr = &_degbga
			continue
		}
		if _bccbc.Name.Local == "strokecolor" {
			_gbaec, _dcceg := _bccbc.Value, error(nil)
			if _dcceg != nil {
				return _dcceg
			}
			_acgg.StrokecolorAttr = &_gbaec
			continue
		}
		if _bccbc.Name.Local == "insetpen" {
			_acgg.InsetpenAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Local == "href" {
			_defb, _gcca := _bccbc.Value, error(nil)
			if _gcca != nil {
				return _gcca
			}
			_acgg.HrefAttr = &_defb
			continue
		}
		if _bccbc.Name.Local == "id" {
			_bdafcg, _fbbb := _bccbc.Value, error(nil)
			if _fbbb != nil {
				return _fbbb
			}
			_acgg.IdAttr = &_bdafcg
			continue
		}
		if _bccbc.Name.Local == "print" {
			_acgg.PrintAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
		if _bccbc.Name.Local == "alt" {
			_gfgae, _efage := _bccbc.Value, error(nil)
			if _efage != nil {
				return _efage
			}
			_acgg.AltAttr = &_gfgae
			continue
		}
		if _bccbc.Name.Local == "title" {
			_ccfga, _egafe := _bccbc.Value, error(nil)
			if _egafe != nil {
				return _egafe
			}
			_acgg.TitleAttr = &_ccfga
			continue
		}
		if _bccbc.Name.Local == "class" {
			_fagaec, _bbafg := _bccbc.Value, error(nil)
			if _bbafg != nil {
				return _bbafg
			}
			_acgg.ClassAttr = &_fagaec
			continue
		}
		if _bccbc.Name.Local == "filled" {
			_acgg.FilledAttr.UnmarshalXMLAttr(_bccbc)
			continue
		}
	}
_agdeb:
	for {
		_eccee, _aagfd := d.Token()
		if _aagfd != nil {
			return _aagfd
		}
		switch _eegcg := _eccee.(type) {
		case _b.StartElement:
			switch _eegcg.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_adcdbd := NewEG_ShapeElements()
				_adcdbd.Path = NewPath()
				if _bggdf := d.DecodeElement(_adcdbd.Path, &_eegcg); _bggdf != nil {
					return _bggdf
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _adcdbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_dfdfc := NewEG_ShapeElements()
				_dfdfc.Formulas = NewFormulas()
				if _dcefab := d.DecodeElement(_dfdfc.Formulas, &_eegcg); _dcefab != nil {
					return _dcefab
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _dfdfc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_eacgc := NewEG_ShapeElements()
				_eacgc.Handles = NewHandles()
				if _accfa := d.DecodeElement(_eacgc.Handles, &_eegcg); _accfa != nil {
					return _accfa
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _eacgc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_gagcab := NewEG_ShapeElements()
				_gagcab.Fill = NewFill()
				if _adeec := d.DecodeElement(_gagcab.Fill, &_eegcg); _adeec != nil {
					return _adeec
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _gagcab)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_abdeb := NewEG_ShapeElements()
				_abdeb.Stroke = NewStroke()
				if _ggedad := d.DecodeElement(_abdeb.Stroke, &_eegcg); _ggedad != nil {
					return _ggedad
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _abdeb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_ccfeg := NewEG_ShapeElements()
				_ccfeg.Shadow = NewShadow()
				if _ggddb := d.DecodeElement(_ccfeg.Shadow, &_eegcg); _ggddb != nil {
					return _ggddb
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _ccfeg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_bdggd := NewEG_ShapeElements()
				_bdggd.Textbox = NewTextbox()
				if _bbefa := d.DecodeElement(_bdggd.Textbox, &_eegcg); _bbefa != nil {
					return _bbefa
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _bdggd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_acgdg := NewEG_ShapeElements()
				_acgdg.Textpath = NewTextpath()
				if _bddeg := d.DecodeElement(_acgdg.Textpath, &_eegcg); _bddeg != nil {
					return _bddeg
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _acgdg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_fdcag := NewEG_ShapeElements()
				_fdcag.Imagedata = NewImagedata()
				if _eeefg := d.DecodeElement(_fdcag.Imagedata, &_eegcg); _eeefg != nil {
					return _eeefg
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _fdcag)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_dgdgfd := NewEG_ShapeElements()
				_dgdgfd.Skew = NewOfcSkew()
				if _bgge := d.DecodeElement(_dgdgfd.Skew, &_eegcg); _bgge != nil {
					return _bgge
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _dgdgfd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_fbdba := NewEG_ShapeElements()
				_fbdba.Extrusion = NewOfcExtrusion()
				if _cdgfe := d.DecodeElement(_fbdba.Extrusion, &_eegcg); _cdgfe != nil {
					return _cdgfe
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _fbdba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_afced := NewEG_ShapeElements()
				_afced.Callout = NewOfcCallout()
				if _cfcfa := d.DecodeElement(_afced.Callout, &_eegcg); _cfcfa != nil {
					return _cfcfa
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _afced)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_ddaaf := NewEG_ShapeElements()
				_ddaaf.Lock = NewOfcLock()
				if _bbbefe := d.DecodeElement(_ddaaf.Lock, &_eegcg); _bbbefe != nil {
					return _bbbefe
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _ddaaf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_abfbd := NewEG_ShapeElements()
				_abfbd.Clippath = NewOfcClippath()
				if _babac := d.DecodeElement(_abfbd.Clippath, &_eegcg); _babac != nil {
					return _babac
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _abfbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_fafgc := NewEG_ShapeElements()
				_fafgc.Signatureline = NewOfcSignatureline()
				if _fefdec := d.DecodeElement(_fafgc.Signatureline, &_eegcg); _fefdec != nil {
					return _fefdec
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _fafgc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_aaaga := NewEG_ShapeElements()
				_aaaga.Wrap = _a.NewWrap()
				if _ebdbbe := d.DecodeElement(_aaaga.Wrap, &_eegcg); _ebdbbe != nil {
					return _ebdbbe
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _aaaga)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_feefe := NewEG_ShapeElements()
				_feefe.Anchorlock = _a.NewAnchorlock()
				if _dfbe := d.DecodeElement(_feefe.Anchorlock, &_eegcg); _dfbe != nil {
					return _dfbe
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _feefe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_ceabd := NewEG_ShapeElements()
				_ceabd.Bordertop = _a.NewBordertop()
				if _eggda := d.DecodeElement(_ceabd.Bordertop, &_eegcg); _eggda != nil {
					return _eggda
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _ceabd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_gfege := NewEG_ShapeElements()
				_gfege.Borderbottom = _a.NewBorderbottom()
				if _cafbbb := d.DecodeElement(_gfege.Borderbottom, &_eegcg); _cafbbb != nil {
					return _cafbbb
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _gfege)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_cdddcb := NewEG_ShapeElements()
				_cdddcb.Borderleft = _a.NewBorderleft()
				if _ggabb := d.DecodeElement(_cdddcb.Borderleft, &_eegcg); _ggabb != nil {
					return _ggabb
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _cdddcb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_ddgbg := NewEG_ShapeElements()
				_ddgbg.Borderright = _a.NewBorderright()
				if _dggac := d.DecodeElement(_ddgbg.Borderright, &_eegcg); _dggac != nil {
					return _dggac
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _ddgbg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_dfage := NewEG_ShapeElements()
				_dfage.ClientData = _c.NewClientData()
				if _fbbgfc := d.DecodeElement(_dfage.ClientData, &_eegcg); _fbbgfc != nil {
					return _fbbgfc
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _dfage)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_efgbb := NewEG_ShapeElements()
				_efgbb.Textdata = _bf.NewTextdata()
				if _dddfg := d.DecodeElement(_efgbb.Textdata, &_eegcg); _dddfg != nil {
					return _dddfg
				}
				_acgg.EG_ShapeElements = append(_acgg.EG_ShapeElements, _efgbb)
			default:
				_ba.Log("skipping\u0020unsupported element\u0020on\u0020Oval\u0020\u0025v", _eegcg.Name)
				if _cfcdff := d.Skip(); _cfcdff != nil {
					return _cfcdff
				}
			}
		case _b.EndElement:
			break _agdeb
		case _b.CharData:
		}
	}
	return nil
}
func (_fbc *AG_StrokeAttributes) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ecee := range start.Attr {
		if _ecee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecee.Name.Local == "relid" {
			_fdgd, _cfg := _ecee.Value, error(nil)
			if _cfg != nil {
				return _cfg
			}
			_fbc.RelidAttr = &_fdgd
			continue
		}
		if _ecee.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _ecee.Name.Local == "id" {
			_bcbb, _adga := _ecee.Value, error(nil)
			if _adga != nil {
				return _adga
			}
			_fbc.IdAttr = &_bcbb
			continue
		}
		if _ecee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecee.Name.Local == "forcedash" {
			_fbc.ForcedashAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecee.Name.Local == "title" {
			_fbac, _debc := _ecee.Value, error(nil)
			if _debc != nil {
				return _debc
			}
			_fbc.TitleAttr = &_fbac
			continue
		}
		if _ecee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecee.Name.Local == "althref" {
			_begg, _gebcd := _ecee.Value, error(nil)
			if _gebcd != nil {
				return _gebcd
			}
			_fbc.AlthrefAttr = &_begg
			continue
		}
		if _ecee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecee.Name.Local == "href" {
			_dcee, _caea := _ecee.Value, error(nil)
			if _caea != nil {
				return _caea
			}
			_fbc.HrefAttr = &_dcee
			continue
		}
		if _ecee.Name.Local == "on" {
			_fbc.OnAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "startarrowlength" {
			_fbc.StartarrowlengthAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "endarrow" {
			_fbc.EndarrowAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "dashstyle" {
			_afb, _bced := _ecee.Value, error(nil)
			if _bced != nil {
				return _bced
			}
			_fbc.DashstyleAttr = &_afb
			continue
		}
		if _ecee.Name.Local == "endarrowwidth" {
			_fbc.EndarrowwidthAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "src" {
			_bbad, _dbb := _ecee.Value, error(nil)
			if _dbb != nil {
				return _dbb
			}
			_fbc.SrcAttr = &_bbad
			continue
		}
		if _ecee.Name.Local == "endarrowlength" {
			_fbc.EndarrowlengthAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "imagesize" {
			_eaad, _ebdg := _ecee.Value, error(nil)
			if _ebdg != nil {
				return _ebdg
			}
			_fbc.ImagesizeAttr = &_eaad
			continue
		}
		if _ecee.Name.Local == "miterlimit" {
			_faag, _fddaa := _e.ParseFloat(_ecee.Value, 64)
			if _fddaa != nil {
				return _fddaa
			}
			_fbc.MiterlimitAttr = &_faag
			continue
		}
		if _ecee.Name.Local == "joinstyle" {
			_fbc.JoinstyleAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "startarrowwidth" {
			_fbc.StartarrowwidthAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "endcap" {
			_fbc.EndcapAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "filltype" {
			_fbc.FilltypeAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "imageaspect" {
			_fbc.ImageaspectAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "imagealignshape" {
			_fbc.ImagealignshapeAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "startarrow" {
			_fbc.StartarrowAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "linestyle" {
			_fbc.LinestyleAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "opacity" {
			_cdbb, _fbbg := _ecee.Value, error(nil)
			if _fbbg != nil {
				return _fbbg
			}
			_fbc.OpacityAttr = &_cdbb
			continue
		}
		if _ecee.Name.Local == "color" {
			_bdgg, _gdeec := _ecee.Value, error(nil)
			if _gdeec != nil {
				return _gdeec
			}
			_fbc.ColorAttr = &_bdgg
			continue
		}
		if _ecee.Name.Local == "weight" {
			_cdgb, _ggcc := _ecee.Value, error(nil)
			if _ggcc != nil {
				return _ggcc
			}
			_fbc.WeightAttr = &_cdgb
			continue
		}
		if _ecee.Name.Local == "insetpen" {
			_fbc.InsetpenAttr.UnmarshalXMLAttr(_ecee)
			continue
		}
		if _ecee.Name.Local == "color2" {
			_gabg, _dggef := _ecee.Value, error(nil)
			if _dggef != nil {
				return _dggef
			}
			_fbc.Color2Attr = &_gabg
			continue
		}
	}
	for {
		_faec, _edf := d.Token()
		if _edf != nil {
			return _f.Errorf("parsing\u0020AG_StrokeAttributes:\u0020\u0025s", _edf)
		}
		if _ebgf, _dbdd := _faec.(_b.EndElement); _dbdd && _ebgf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_eaaec ST_StrokeLineStyle) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_eaaec.String(), start)
}
func (_efggge ST_FillMethod) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_cbbdb := _b.Attr{}
	_cbbdb.Name = name
	switch _efggge {
	case ST_FillMethodUnset:
		_cbbdb.Value = ""
	case ST_FillMethodNone:
		_cbbdb.Value = "none"
	case ST_FillMethodLinear:
		_cbbdb.Value = "linear"
	case ST_FillMethodSigma:
		_cbbdb.Value = "sigma"
	case ST_FillMethodAny:
		_cbbdb.Value = "any"
	case ST_FillMethodLinearSigma:
		_cbbdb.Value = "linear\u0020sigma"
	}
	return _cbbdb, nil
}

type OfcRight struct{ OfcCT_StrokeChild }

func NewOfcDiagram() *OfcDiagram {
	_eeebe := &OfcDiagram{}
	_eeebe.OfcCT_Diagram = *NewOfcCT_Diagram()
	return _eeebe
}
func (_dbded ST_StrokeArrowLength) Validate() error { return _dbded.ValidateWithPath("") }

// Validate validates the CT_Fill and its children
func (_ccfbf *CT_Fill) Validate() error { return _ccfbf.ValidateWithPath("CT_Fill") }
func NewOfcExtrusion() *OfcExtrusion {
	_fggafe := &OfcExtrusion{}
	_fggafe.OfcCT_Extrusion = *NewOfcCT_Extrusion()
	return _fggafe
}

const (
	OfcST_ConnectTypeUnset    OfcST_ConnectType = 0
	OfcST_ConnectTypeNone     OfcST_ConnectType = 1
	OfcST_ConnectTypeRect     OfcST_ConnectType = 2
	OfcST_ConnectTypeSegments OfcST_ConnectType = 3
	OfcST_ConnectTypeCustom   OfcST_ConnectType = 4
)

type CT_Rect struct {
	EG_ShapeElements      []*EG_ShapeElements
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
	OpacityAttr           *string
	StrokedAttr           _eb.ST_TrueFalse
	StrokecolorAttr       *string
	StrokeweightAttr      *string
	InsetpenAttr          _eb.ST_TrueFalse
	ChromakeyAttr         *string
	FilledAttr            _eb.ST_TrueFalse
	FillcolorAttr         *string
	SptAttr               *float32
	ConnectortypeAttr     OfcST_ConnectorType
	BwmodeAttr            OfcST_BWMode
	BwpureAttr            OfcST_BWMode
	BwnormalAttr          OfcST_BWMode
	ForcedashAttr         _eb.ST_TrueFalse
	OleiconAttr           _eb.ST_TrueFalse
	OleAttr               _eb.ST_TrueFalseBlank
	PreferrelativeAttr    _eb.ST_TrueFalse
	CliptowrapAttr        _eb.ST_TrueFalse
	ClipAttr              _eb.ST_TrueFalse
}

func (_bfacg OfcST_ExtrusionType) ValidateWithPath(path string) error {
	switch _bfacg {
	case 0, 1, 2:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bfacg))
	}
	return nil
}

// ValidateWithPath validates the OfcClippath and its children, prefixing error messages with path
func (_beebe *OfcClippath) ValidateWithPath(path string) error {
	if _gbgda := _beebe.OfcCT_ClipPath.ValidateWithPath(path); _gbgda != nil {
		return _gbgda
	}
	return nil
}
func NewOfcBottom() *OfcBottom {
	_abdde := &OfcBottom{}
	_abdde.OfcCT_StrokeChild = *NewOfcCT_StrokeChild()
	return _abdde
}

const (
	OfcST_HrAlignUnset  OfcST_HrAlign = 0
	OfcST_HrAlignLeft   OfcST_HrAlign = 1
	OfcST_HrAlignRight  OfcST_HrAlign = 2
	OfcST_HrAlignCenter OfcST_HrAlign = 3
)

type AG_StrokeAttributes struct {
	OnAttr               _eb.ST_TrueFalse
	WeightAttr           *string
	ColorAttr            *string
	OpacityAttr          *string
	LinestyleAttr        ST_StrokeLineStyle
	MiterlimitAttr       *float64
	JoinstyleAttr        ST_StrokeJoinStyle
	EndcapAttr           ST_StrokeEndCap
	DashstyleAttr        *string
	FilltypeAttr         ST_FillType
	SrcAttr              *string
	ImageaspectAttr      ST_ImageAspect
	ImagesizeAttr        *string
	ImagealignshapeAttr  _eb.ST_TrueFalse
	Color2Attr           *string
	StartarrowAttr       ST_StrokeArrowType
	StartarrowwidthAttr  ST_StrokeArrowWidth
	StartarrowlengthAttr ST_StrokeArrowLength
	EndarrowAttr         ST_StrokeArrowType
	EndarrowwidthAttr    ST_StrokeArrowWidth
	EndarrowlengthAttr   ST_StrokeArrowLength
	HrefAttr             *string
	AlthrefAttr          *string
	TitleAttr            *string
	ForcedashAttr        _eb.ST_TrueFalse
	IdAttr               *string
	InsetpenAttr         _eb.ST_TrueFalse
	RelidAttr            *string
}

func (_bgdcag *Textpath) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bgdcag.CT_TextPath = *NewCT_TextPath()
	for _, _ffegea := range start.Attr {
		if _ffegea.Name.Local == "on" {
			_bgdcag.OnAttr.UnmarshalXMLAttr(_ffegea)
			continue
		}
		if _ffegea.Name.Local == "fitshape" {
			_bgdcag.FitshapeAttr.UnmarshalXMLAttr(_ffegea)
			continue
		}
		if _ffegea.Name.Local == "fitpath" {
			_bgdcag.FitpathAttr.UnmarshalXMLAttr(_ffegea)
			continue
		}
		if _ffegea.Name.Local == "trim" {
			_bgdcag.TrimAttr.UnmarshalXMLAttr(_ffegea)
			continue
		}
		if _ffegea.Name.Local == "xscale" {
			_bgdcag.XscaleAttr.UnmarshalXMLAttr(_ffegea)
			continue
		}
		if _ffegea.Name.Local == "string" {
			_eedgf, _ggdeg := _ffegea.Value, error(nil)
			if _ggdeg != nil {
				return _ggdeg
			}
			_bgdcag.StringAttr = &_eedgf
			continue
		}
		if _ffegea.Name.Local == "id" {
			_ccfege, _babbe := _ffegea.Value, error(nil)
			if _babbe != nil {
				return _babbe
			}
			_bgdcag.IdAttr = &_ccfege
			continue
		}
		if _ffegea.Name.Local == "style" {
			_gedee, _fbfbb := _ffegea.Value, error(nil)
			if _fbfbb != nil {
				return _fbfbb
			}
			_bgdcag.StyleAttr = &_gedee
			continue
		}
	}
	for {
		_abeb, _eefbg := d.Token()
		if _eefbg != nil {
			return _f.Errorf("parsing\u0020Textpath: \u0025s", _eefbg)
		}
		if _babbc, _cbcfg := _abeb.(_b.EndElement); _cbcfg && _babbc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dbgdf *ST_FillType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dbgdf = 0
	case "solid":
		*_dbgdf = 1
	case "gradient":
		*_dbgdf = 2
	case "gradientRadial":
		*_dbgdf = 3
	case "tile":
		*_dbgdf = 4
	case "pattern":
		*_dbgdf = 5
	case "frame":
		*_dbgdf = 6
	}
	return nil
}

// Validate validates the OfcCT_Entry and its children
func (_eefd *OfcCT_Entry) Validate() error { return _eefd.ValidateWithPath("OfcCT_Entry") }

type CT_Background struct {
	BwmodeAttr           OfcST_BWMode
	BwpureAttr           OfcST_BWMode
	BwnormalAttr         OfcST_BWMode
	TargetscreensizeAttr OfcST_ScreenSize
	Fill                 *Fill
	IdAttr               *string
	FilledAttr           _eb.ST_TrueFalse
	FillcolorAttr        *string
}

func (_caegge OfcST_ColorMode) ValidateWithPath(path string) error {
	switch _caegge {
	case 0, 1, 2:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_caegge))
	}
	return nil
}

// Validate validates the OfcCallout and its children
func (_eddag *OfcCallout) Validate() error { return _eddag.ValidateWithPath("OfcCallout") }
func (_bffac ST_ImageAspect) String() string {
	switch _bffac {
	case 0:
		return ""
	case 1:
		return "ignore"
	case 2:
		return "atMost"
	case 3:
		return "atLeast"
	}
	return ""
}

type OfcFill struct{ OfcCT_Fill }

// Validate validates the EG_ShapeElements and its children
func (_dggf *EG_ShapeElements) Validate() error { return _dggf.ValidateWithPath("EG_ShapeElements") }

// ValidateWithPath validates the Roundrect and its children, prefixing error messages with path
func (_cddde *Roundrect) ValidateWithPath(path string) error {
	if _dccdbc := _cddde.CT_RoundRect.ValidateWithPath(path); _dccdbc != nil {
		return _dccdbc
	}
	return nil
}
func (_ddff *CT_Stroke) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ddff.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_ddff.IdAttr)})
	}
	if _ddff.OnAttr != _eb.ST_TrueFalseUnset {
		_decec, _deaae := _ddff.OnAttr.MarshalXMLAttr(_b.Name{Local: "on"})
		if _deaae != nil {
			return _deaae
		}
		start.Attr = append(start.Attr, _decec)
	}
	if _ddff.WeightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "weight"}, Value: _f.Sprintf("\u0025v", *_ddff.WeightAttr)})
	}
	if _ddff.ColorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "color"}, Value: _f.Sprintf("\u0025v", *_ddff.ColorAttr)})
	}
	if _ddff.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_ddff.OpacityAttr)})
	}
	if _ddff.LinestyleAttr != ST_StrokeLineStyleUnset {
		_feede, _egccf := _ddff.LinestyleAttr.MarshalXMLAttr(_b.Name{Local: "linestyle"})
		if _egccf != nil {
			return _egccf
		}
		start.Attr = append(start.Attr, _feede)
	}
	if _ddff.MiterlimitAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "miterlimit"}, Value: _f.Sprintf("\u0025v", *_ddff.MiterlimitAttr)})
	}
	if _ddff.JoinstyleAttr != ST_StrokeJoinStyleUnset {
		_fgag, _gbfec := _ddff.JoinstyleAttr.MarshalXMLAttr(_b.Name{Local: "joinstyle"})
		if _gbfec != nil {
			return _gbfec
		}
		start.Attr = append(start.Attr, _fgag)
	}
	if _ddff.EndcapAttr != ST_StrokeEndCapUnset {
		_decdff, _geced := _ddff.EndcapAttr.MarshalXMLAttr(_b.Name{Local: "endcap"})
		if _geced != nil {
			return _geced
		}
		start.Attr = append(start.Attr, _decdff)
	}
	if _ddff.DashstyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "dashstyle"}, Value: _f.Sprintf("\u0025v", *_ddff.DashstyleAttr)})
	}
	if _ddff.FilltypeAttr != ST_FillTypeUnset {
		_dgef, _fcgfd := _ddff.FilltypeAttr.MarshalXMLAttr(_b.Name{Local: "filltype"})
		if _fcgfd != nil {
			return _fcgfd
		}
		start.Attr = append(start.Attr, _dgef)
	}
	if _ddff.SrcAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "src"}, Value: _f.Sprintf("\u0025v", *_ddff.SrcAttr)})
	}
	if _ddff.ImageaspectAttr != ST_ImageAspectUnset {
		_efbcf, _gdfgb := _ddff.ImageaspectAttr.MarshalXMLAttr(_b.Name{Local: "imageaspect"})
		if _gdfgb != nil {
			return _gdfgb
		}
		start.Attr = append(start.Attr, _efbcf)
	}
	if _ddff.ImagesizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "imagesize"}, Value: _f.Sprintf("\u0025v", *_ddff.ImagesizeAttr)})
	}
	if _ddff.ImagealignshapeAttr != _eb.ST_TrueFalseUnset {
		_fcbc, _bbcdb := _ddff.ImagealignshapeAttr.MarshalXMLAttr(_b.Name{Local: "imagealignshape"})
		if _bbcdb != nil {
			return _bbcdb
		}
		start.Attr = append(start.Attr, _fcbc)
	}
	if _ddff.Color2Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "color2"}, Value: _f.Sprintf("\u0025v", *_ddff.Color2Attr)})
	}
	if _ddff.StartarrowAttr != ST_StrokeArrowTypeUnset {
		_dgfgg, _cgged := _ddff.StartarrowAttr.MarshalXMLAttr(_b.Name{Local: "startarrow"})
		if _cgged != nil {
			return _cgged
		}
		start.Attr = append(start.Attr, _dgfgg)
	}
	if _ddff.StartarrowwidthAttr != ST_StrokeArrowWidthUnset {
		_egfad, _fadaf := _ddff.StartarrowwidthAttr.MarshalXMLAttr(_b.Name{Local: "startarrowwidth"})
		if _fadaf != nil {
			return _fadaf
		}
		start.Attr = append(start.Attr, _egfad)
	}
	if _ddff.StartarrowlengthAttr != ST_StrokeArrowLengthUnset {
		_gafeg, _efbfd := _ddff.StartarrowlengthAttr.MarshalXMLAttr(_b.Name{Local: "startarrowlength"})
		if _efbfd != nil {
			return _efbfd
		}
		start.Attr = append(start.Attr, _gafeg)
	}
	if _ddff.EndarrowAttr != ST_StrokeArrowTypeUnset {
		_ggef, _efggf := _ddff.EndarrowAttr.MarshalXMLAttr(_b.Name{Local: "endarrow"})
		if _efggf != nil {
			return _efggf
		}
		start.Attr = append(start.Attr, _ggef)
	}
	if _ddff.EndarrowwidthAttr != ST_StrokeArrowWidthUnset {
		_bcfde, _fabg := _ddff.EndarrowwidthAttr.MarshalXMLAttr(_b.Name{Local: "endarrowwidth"})
		if _fabg != nil {
			return _fabg
		}
		start.Attr = append(start.Attr, _bcfde)
	}
	if _ddff.EndarrowlengthAttr != ST_StrokeArrowLengthUnset {
		_ffafb, _beceg := _ddff.EndarrowlengthAttr.MarshalXMLAttr(_b.Name{Local: "endarrowlength"})
		if _beceg != nil {
			return _beceg
		}
		start.Attr = append(start.Attr, _ffafb)
	}
	if _ddff.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:href"}, Value: _f.Sprintf("\u0025v", *_ddff.HrefAttr)})
	}
	if _ddff.AlthrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:althref"}, Value: _f.Sprintf("\u0025v", *_ddff.AlthrefAttr)})
	}
	if _ddff.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:title"}, Value: _f.Sprintf("\u0025v", *_ddff.TitleAttr)})
	}
	if _ddff.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_gcdca, _bgdcf := _ddff.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _bgdcf != nil {
			return _bgdcf
		}
		start.Attr = append(start.Attr, _gcdca)
	}
	if _ddff.RIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:id"}, Value: _f.Sprintf("\u0025v", *_ddff.RIdAttr)})
	}
	if _ddff.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_cbdcf, _afcfb := _ddff.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _afcfb != nil {
			return _afcfb
		}
		start.Attr = append(start.Attr, _cbdcf)
	}
	if _ddff.RelidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:relid"}, Value: _f.Sprintf("\u0025v", *_ddff.RelidAttr)})
	}
	e.EncodeToken(start)
	if _ddff.Left != nil {
		_ecegd := _b.StartElement{Name: _b.Name{Local: "o:left"}}
		e.EncodeElement(_ddff.Left, _ecegd)
	}
	if _ddff.Top != nil {
		_cfge := _b.StartElement{Name: _b.Name{Local: "o:top"}}
		e.EncodeElement(_ddff.Top, _cfge)
	}
	if _ddff.Right != nil {
		_ccfbff := _b.StartElement{Name: _b.Name{Local: "o:right"}}
		e.EncodeElement(_ddff.Right, _ccfbff)
	}
	if _ddff.Bottom != nil {
		_acffe := _b.StartElement{Name: _b.Name{Local: "o:bottom"}}
		e.EncodeElement(_ddff.Bottom, _acffe)
	}
	if _ddff.Column != nil {
		_eddbc := _b.StartElement{Name: _b.Name{Local: "o:column"}}
		e.EncodeElement(_ddff.Column, _eddbc)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_eebee OfcST_ScreenSize) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_eebee.String(), start)
}
func NewPolyline() *Polyline {
	_dddaad := &Polyline{}
	_dddaad.CT_PolyLine = *NewCT_PolyLine()
	return _dddaad
}
func (_fgc *AG_Chromakey) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _fgc.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_fgc.ChromakeyAttr)})
	}
	return nil
}

type Curve struct{ CT_Curve }

func (_edebb *OfcSignatureline) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:signatureline"
	return _edebb.OfcCT_SignatureLine.MarshalXML(e, start)
}

// ValidateWithPath validates the OfcDiagram and its children, prefixing error messages with path
func (_cfafc *OfcDiagram) ValidateWithPath(path string) error {
	if _dagfb := _cfafc.OfcCT_Diagram.ValidateWithPath(path); _dagfb != nil {
		return _dagfb
	}
	return nil
}

// ValidateWithPath validates the Shadow and its children, prefixing error messages with path
func (_baacaa *Shadow) ValidateWithPath(path string) error {
	if _ddgc := _baacaa.CT_Shadow.ValidateWithPath(path); _ddgc != nil {
		return _ddgc
	}
	return nil
}

// Validate validates the OfcCT_EquationXml and its children
func (_bdgcb *OfcCT_EquationXml) Validate() error {
	return _bdgcb.ValidateWithPath("OfcCT_EquationXml")
}
func (_fcdab *OfcST_RType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fcdab = 0
	case "arc":
		*_fcdab = 1
	case "callout":
		*_fcdab = 2
	case "connector":
		*_fcdab = 3
	case "align":
		*_fcdab = 4
	}
	return nil
}
func (_agbfgf OfcST_FillType) ValidateWithPath(path string) error {
	switch _agbfgf {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_agbfgf))
	}
	return nil
}
func (_cebfc *OfcST_How) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_cebfc = 0
	case "top":
		*_cebfc = 1
	case "middle":
		*_cebfc = 2
	case "bottom":
		*_cebfc = 3
	case "left":
		*_cebfc = 4
	case "center":
		*_cebfc = 5
	case "right":
		*_cebfc = 6
	}
	return nil
}

type AG_OfficeShapeAttributes struct {
	SptAttr            *float32
	ConnectortypeAttr  OfcST_ConnectorType
	BwmodeAttr         OfcST_BWMode
	BwpureAttr         OfcST_BWMode
	BwnormalAttr       OfcST_BWMode
	ForcedashAttr      _eb.ST_TrueFalse
	OleiconAttr        _eb.ST_TrueFalse
	OleAttr            _eb.ST_TrueFalseBlank
	PreferrelativeAttr _eb.ST_TrueFalse
	CliptowrapAttr     _eb.ST_TrueFalse
	ClipAttr           _eb.ST_TrueFalse
}

func (_edbgg OfcST_ColorMode) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_baabg := _b.Attr{}
	_baabg.Name = name
	switch _edbgg {
	case OfcST_ColorModeUnset:
		_baabg.Value = ""
	case OfcST_ColorModeAuto:
		_baabg.Value = "auto"
	case OfcST_ColorModeCustom:
		_baabg.Value = "custom"
	}
	return _baabg, nil
}

type OfcCT_Diagram struct {
	DgmstyleAttr         *int64
	AutoformatAttr       _eb.ST_TrueFalse
	ReverseAttr          _eb.ST_TrueFalse
	AutolayoutAttr       _eb.ST_TrueFalse
	DgmscalexAttr        *int64
	DgmscaleyAttr        *int64
	DgmfontsizeAttr      *int64
	ConstrainboundsAttr  *string
	DgmbasetextscaleAttr *int64
	Relationtable        *OfcCT_RelationTable
	ExtAttr              ST_Ext
}

func NewOfcCT_IdMap() *OfcCT_IdMap               { _gdcfe := &OfcCT_IdMap{}; return _gdcfe }
func (_facg ST_StrokeArrowType) Validate() error { return _facg.ValidateWithPath("") }

const (
	OfcST_DiagramLayoutUnset OfcST_DiagramLayout = 0
	OfcST_DiagramLayout0     OfcST_DiagramLayout = 1
	OfcST_DiagramLayout1     OfcST_DiagramLayout = 2
	OfcST_DiagramLayout2     OfcST_DiagramLayout = 3
	OfcST_DiagramLayout3     OfcST_DiagramLayout = 4
)

func (_bacec *CT_PolyLine) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bacec.PointsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "points"}, Value: _f.Sprintf("\u0025v", *_bacec.PointsAttr)})
	}
	if _bacec.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_bacec.HrefAttr)})
	}
	if _bacec.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_bacec.TargetAttr)})
	}
	if _bacec.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_bacec.ClassAttr)})
	}
	if _bacec.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_bacec.TitleAttr)})
	}
	if _bacec.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_bacec.AltAttr)})
	}
	if _bacec.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_bacec.CoordsizeAttr)})
	}
	if _bacec.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_bacec.CoordoriginAttr)})
	}
	if _bacec.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_bacec.WrapcoordsAttr)})
	}
	if _bacec.PrintAttr != _eb.ST_TrueFalseUnset {
		_fdeb, _edca := _bacec.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _edca != nil {
			return _edca
		}
		start.Attr = append(start.Attr, _fdeb)
	}
	if _bacec.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_bacec.IdAttr)})
	}
	if _bacec.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_bacec.StyleAttr)})
	}
	if _bacec.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_bacec.SpidAttr)})
	}
	if _bacec.OnedAttr != _eb.ST_TrueFalseUnset {
		_eafac, _baadg := _bacec.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _baadg != nil {
			return _baadg
		}
		start.Attr = append(start.Attr, _eafac)
	}
	if _bacec.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_bacec.RegroupidAttr)})
	}
	if _bacec.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_daaf, _ddbac := _bacec.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _ddbac != nil {
			return _ddbac
		}
		start.Attr = append(start.Attr, _daaf)
	}
	if _bacec.ButtonAttr != _eb.ST_TrueFalseUnset {
		_eade, _acfa := _bacec.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _acfa != nil {
			return _acfa
		}
		start.Attr = append(start.Attr, _eade)
	}
	if _bacec.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_gdacd, _ddfd := _bacec.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _ddfd != nil {
			return _ddfd
		}
		start.Attr = append(start.Attr, _gdacd)
	}
	if _bacec.BulletAttr != _eb.ST_TrueFalseUnset {
		_ggcg, _debfb := _bacec.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _debfb != nil {
			return _debfb
		}
		start.Attr = append(start.Attr, _ggcg)
	}
	if _bacec.HrAttr != _eb.ST_TrueFalseUnset {
		_baac, _fcde := _bacec.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _fcde != nil {
			return _fcde
		}
		start.Attr = append(start.Attr, _baac)
	}
	if _bacec.HrstdAttr != _eb.ST_TrueFalseUnset {
		_dbca, _cbdef := _bacec.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _cbdef != nil {
			return _cbdef
		}
		start.Attr = append(start.Attr, _dbca)
	}
	if _bacec.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_fdbdc, _bfdcd := _bacec.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _bfdcd != nil {
			return _bfdcd
		}
		start.Attr = append(start.Attr, _fdbdc)
	}
	if _bacec.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_bacec.HrpctAttr)})
	}
	if _bacec.HralignAttr != OfcST_HrAlignUnset {
		_cacef, _ddge := _bacec.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _ddge != nil {
			return _ddge
		}
		start.Attr = append(start.Attr, _cacef)
	}
	if _bacec.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_acebee, _bbca := _bacec.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _bbca != nil {
			return _bbca
		}
		start.Attr = append(start.Attr, _acebee)
	}
	if _bacec.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_bdaba, _ebbgc := _bacec.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _ebbgc != nil {
			return _ebbgc
		}
		start.Attr = append(start.Attr, _bdaba)
	}
	if _bacec.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_gbecb, _cacb := _bacec.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _cacb != nil {
			return _cacb
		}
		start.Attr = append(start.Attr, _gbecb)
	}
	if _bacec.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_bacec.BordertopcolorAttr)})
	}
	if _bacec.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_bacec.BorderleftcolorAttr)})
	}
	if _bacec.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_bacec.BorderbottomcolorAttr)})
	}
	if _bacec.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_bacec.BorderrightcolorAttr)})
	}
	if _bacec.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_bfgab, _gbfe := _bacec.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _gbfe != nil {
			return _gbfe
		}
		start.Attr = append(start.Attr, _bfgab)
	}
	if _bacec.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_bacec.DgmnodekindAttr)})
	}
	if _bacec.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_eecad, _bgaa := _bacec.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _bgaa != nil {
			return _bgaa
		}
		start.Attr = append(start.Attr, _eecad)
	}
	if _bacec.InsetmodeAttr != OfcST_InsetModeUnset {
		_fdab, _cdbg := _bacec.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _cdbg != nil {
			return _cdbg
		}
		start.Attr = append(start.Attr, _fdab)
	}
	if _bacec.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_bacec.OpacityAttr)})
	}
	if _bacec.StrokedAttr != _eb.ST_TrueFalseUnset {
		_fcgc, _gcddf := _bacec.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _gcddf != nil {
			return _gcddf
		}
		start.Attr = append(start.Attr, _fcgc)
	}
	if _bacec.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_bacec.StrokecolorAttr)})
	}
	if _bacec.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_bacec.StrokeweightAttr)})
	}
	if _bacec.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_eadeb, _dgda := _bacec.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _dgda != nil {
			return _dgda
		}
		start.Attr = append(start.Attr, _eadeb)
	}
	if _bacec.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_bacec.ChromakeyAttr)})
	}
	if _bacec.FilledAttr != _eb.ST_TrueFalseUnset {
		_cbgeg, _bdcb := _bacec.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _bdcb != nil {
			return _bdcb
		}
		start.Attr = append(start.Attr, _cbgeg)
	}
	if _bacec.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_bacec.FillcolorAttr)})
	}
	if _bacec.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_bacec.SptAttr)})
	}
	if _bacec.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_dcaef, _dacfa := _bacec.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _dacfa != nil {
			return _dacfa
		}
		start.Attr = append(start.Attr, _dcaef)
	}
	if _bacec.BwmodeAttr != OfcST_BWModeUnset {
		_addcf, _dcagg := _bacec.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _dcagg != nil {
			return _dcagg
		}
		start.Attr = append(start.Attr, _addcf)
	}
	if _bacec.BwpureAttr != OfcST_BWModeUnset {
		_faede, _acgdb := _bacec.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _acgdb != nil {
			return _acgdb
		}
		start.Attr = append(start.Attr, _faede)
	}
	if _bacec.BwnormalAttr != OfcST_BWModeUnset {
		_befbd, _bfgac := _bacec.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _bfgac != nil {
			return _bfgac
		}
		start.Attr = append(start.Attr, _befbd)
	}
	if _bacec.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_faddf, _bgcccb := _bacec.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _bgcccb != nil {
			return _bgcccb
		}
		start.Attr = append(start.Attr, _faddf)
	}
	if _bacec.OleiconAttr != _eb.ST_TrueFalseUnset {
		_bafed, _daded := _bacec.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _daded != nil {
			return _daded
		}
		start.Attr = append(start.Attr, _bafed)
	}
	if _bacec.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_geab, _cdffc := _bacec.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _cdffc != nil {
			return _cdffc
		}
		start.Attr = append(start.Attr, _geab)
	}
	if _bacec.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_gcgf, _caga := _bacec.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _caga != nil {
			return _caga
		}
		start.Attr = append(start.Attr, _gcgf)
	}
	if _bacec.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_gfffe, _fcgd := _bacec.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _fcgd != nil {
			return _fcgd
		}
		start.Attr = append(start.Attr, _gfffe)
	}
	if _bacec.ClipAttr != _eb.ST_TrueFalseUnset {
		_dgac, _dbaag := _bacec.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _dbaag != nil {
			return _dbaag
		}
		start.Attr = append(start.Attr, _dgac)
	}
	e.EncodeToken(start)
	if _bacec.Ink != nil {
		_gffbc := _b.StartElement{Name: _b.Name{Local: "o:ink"}}
		for _, _gffde := range _bacec.Ink {
			e.EncodeElement(_gffde, _gffbc)
		}
	}
	if _bacec.EG_ShapeElements != nil {
		for _, _egfe := range _bacec.EG_ShapeElements {
			_egfe.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type ST_FillType byte

func (_afbc *Line) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _afbc.CT_Line.MarshalXML(e, start)
}

// Validate validates the Curve and its children
func (_acgf *Curve) Validate() error { return _acgf.ValidateWithPath("Curve") }

// ValidateWithPath validates the AG_OfficeCoreAttributes and its children, prefixing error messages with path
func (_aadg *AG_OfficeCoreAttributes) ValidateWithPath(path string) error {
	if _gaca := _aadg.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _gaca != nil {
		return _gaca
	}
	if _dbaa := _aadg.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _dbaa != nil {
		return _dbaa
	}
	if _aadb := _aadg.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _aadb != nil {
		return _aadb
	}
	if _baff := _aadg.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _baff != nil {
		return _baff
	}
	if _bfced := _aadg.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _bfced != nil {
		return _bfced
	}
	if _cae := _aadg.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _cae != nil {
		return _cae
	}
	if _gbfc := _aadg.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _gbfc != nil {
		return _gbfc
	}
	if _fbag := _aadg.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _fbag != nil {
		return _fbag
	}
	if _gacf := _aadg.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _gacf != nil {
		return _gacf
	}
	if _ffb := _aadg.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _ffb != nil {
		return _ffb
	}
	if _cbcd := _aadg.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _cbcd != nil {
		return _cbcd
	}
	if _aef := _aadg.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _aef != nil {
		return _aef
	}
	if _cagc := _aadg.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _cagc != nil {
		return _cagc
	}
	if _ced := _aadg.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _ced != nil {
		return _ced
	}
	if _cda := _aadg.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _cda != nil {
		return _cda
	}
	return nil
}

// Validate validates the OfcOLEObject and its children
func (_gffbb *OfcOLEObject) Validate() error { return _gffbb.ValidateWithPath("OfcOLEObject") }

const (
	OfcST_ExtrusionPlaneUnset OfcST_ExtrusionPlane = 0
	OfcST_ExtrusionPlaneXY    OfcST_ExtrusionPlane = 1
	OfcST_ExtrusionPlaneZX    OfcST_ExtrusionPlane = 2
	OfcST_ExtrusionPlaneYZ    OfcST_ExtrusionPlane = 3
)

// Validate validates the OfcCT_Relation and its children
func (_fbbdc *OfcCT_Relation) Validate() error { return _fbbdc.ValidateWithPath("OfcCT_Relation") }
func (_gadg *OfcCT_EquationXml) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _edfge := range start.Attr {
		if _edfge.Name.Local == "contentType" {
			_gdbaf, _bbafe := _edfge.Value, error(nil)
			if _bbafe != nil {
				return _bbafe
			}
			_gadg.ContentTypeAttr = &_gdbaf
			continue
		}
	}
_fdaae:
	for {
		_fbgae, _dfgbc := d.Token()
		if _dfgbc != nil {
			return _dfgbc
		}
		switch _agfde := _fbgae.(type) {
		case _b.StartElement:
			switch _agfde.Name {
			default:
				if _gcdebc, _bbfaf := _ba.CreateElement(_agfde); _bbfaf != nil {
					return _bbfaf
				} else {
					if _bacea := d.DecodeElement(_gcdebc, &_agfde); _bacea != nil {
						return _bacea
					}
					_gadg.Any = _gcdebc
				}
			}
		case _b.EndElement:
			break _fdaae
		case _b.CharData:
		}
	}
	return nil
}

const (
	ST_ShadowTypeUnset       ST_ShadowType = 0
	ST_ShadowTypeSingle      ST_ShadowType = 1
	ST_ShadowTypeDouble      ST_ShadowType = 2
	ST_ShadowTypeEmboss      ST_ShadowType = 3
	ST_ShadowTypePerspective ST_ShadowType = 4
)

func (_gdgcac ST_StrokeJoinStyle) Validate() error { return _gdgcac.ValidateWithPath("") }

// ValidateWithPath validates the Polyline and its children, prefixing error messages with path
func (_ddafc *Polyline) ValidateWithPath(path string) error {
	if _egdcg := _ddafc.CT_PolyLine.ValidateWithPath(path); _egdcg != nil {
		return _egdcg
	}
	return nil
}

// Validate validates the OfcTop and its children
func (_bdcge *OfcTop) Validate() error { return _bdcge.ValidateWithPath("OfcTop") }
func (_gecga *OfcCT_Complex) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ccga := range start.Attr {
		if _ccga.Name.Local == "ext" {
			_gecga.ExtAttr.UnmarshalXMLAttr(_ccga)
			continue
		}
	}
	for {
		_aggda, _aaead := d.Token()
		if _aaead != nil {
			return _f.Errorf("parsing\u0020OfcCT_Complex:\u0020\u0025s", _aaead)
		}
		if _addcc, _dgfaf := _aggda.(_b.EndElement); _dgfaf && _addcc.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_Formulas and its children
func (_fdacf *CT_Formulas) Validate() error   { return _fdacf.ValidateWithPath("CT_Formulas") }
func (_dedbe ST_ImageAspect) Validate() error { return _dedbe.ValidateWithPath("") }
func (_aedda *OfcCT_IdMap) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _geagb := range start.Attr {
		if _geagb.Name.Local == "data" {
			_ebgfc, _gdgcg := _geagb.Value, error(nil)
			if _gdgcg != nil {
				return _gdgcg
			}
			_aedda.DataAttr = &_ebgfc
			continue
		}
		if _geagb.Name.Local == "ext" {
			_aedda.ExtAttr.UnmarshalXMLAttr(_geagb)
			continue
		}
	}
	for {
		_bcbgd, _dbdgg := d.Token()
		if _dbdgg != nil {
			return _f.Errorf("parsing\u0020OfcCT_IdMap:\u0020\u0025s", _dbdgg)
		}
		if _gcdffb, _bbddd := _bcbgd.(_b.EndElement); _bbddd && _gcdffb.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Curve struct {
	FromAttr              *string
	Control1Attr          *string
	Control2Attr          *string
	ToAttr                *string
	EG_ShapeElements      []*EG_ShapeElements
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
	OpacityAttr           *string
	StrokedAttr           _eb.ST_TrueFalse
	StrokecolorAttr       *string
	StrokeweightAttr      *string
	InsetpenAttr          _eb.ST_TrueFalse
	ChromakeyAttr         *string
	FilledAttr            _eb.ST_TrueFalse
	FillcolorAttr         *string
	SptAttr               *float32
	ConnectortypeAttr     OfcST_ConnectorType
	BwmodeAttr            OfcST_BWMode
	BwpureAttr            OfcST_BWMode
	BwnormalAttr          OfcST_BWMode
	ForcedashAttr         _eb.ST_TrueFalse
	OleiconAttr           _eb.ST_TrueFalse
	OleAttr               _eb.ST_TrueFalseBlank
	PreferrelativeAttr    _eb.ST_TrueFalse
	CliptowrapAttr        _eb.ST_TrueFalse
	ClipAttr              _eb.ST_TrueFalse
}

func (_cdeab OfcST_FillType) String() string {
	switch _cdeab {
	case 0:
		return ""
	case 1:
		return "gradientCenter"
	case 2:
		return "solid"
	case 3:
		return "pattern"
	case 4:
		return "tile"
	case 5:
		return "frame"
	case 6:
		return "gradientUnscaled"
	case 7:
		return "gradientRadial"
	case 8:
		return "gradient"
	case 9:
		return "background"
	}
	return ""
}
func (_bgdbc *Textbox) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _bgdbc.CT_Textbox.MarshalXML(e, start)
}
func (_bfffc *OfcShapedefaults) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bfffc.OfcCT_ShapeDefaults = *NewOfcCT_ShapeDefaults()
	for _, _fafg := range start.Attr {
		if _fafg.Name.Local == "spidmax" {
			_aace, _deba := _e.ParseInt(_fafg.Value, 10, 64)
			if _deba != nil {
				return _deba
			}
			_bfffc.SpidmaxAttr = &_aace
			continue
		}
		if _fafg.Name.Local == "allowincell" {
			_bfffc.AllowincellAttr.UnmarshalXMLAttr(_fafg)
			continue
		}
		if _fafg.Name.Local == "strokecolor" {
			_gebbc, _gggbdf := _fafg.Value, error(nil)
			if _gggbdf != nil {
				return _gggbdf
			}
			_bfffc.StrokecolorAttr = &_gebbc
			continue
		}
		if _fafg.Name.Local == "stroke" {
			_bfffc.StrokeAttr.UnmarshalXMLAttr(_fafg)
			continue
		}
		if _fafg.Name.Local == "fillcolor" {
			_agecae, _fgcfd := _fafg.Value, error(nil)
			if _fgcfd != nil {
				return _fgcfd
			}
			_bfffc.FillcolorAttr = &_agecae
			continue
		}
		if _fafg.Name.Local == "fill" {
			_bfffc.FillAttr.UnmarshalXMLAttr(_fafg)
			continue
		}
		if _fafg.Name.Local == "style" {
			_cafgg, _eabbg := _fafg.Value, error(nil)
			if _eabbg != nil {
				return _eabbg
			}
			_bfffc.StyleAttr = &_cafgg
			continue
		}
		if _fafg.Name.Local == "ext" {
			_bfffc.ExtAttr.UnmarshalXMLAttr(_fafg)
			continue
		}
	}
_afbga:
	for {
		_babde, _dbagd := d.Token()
		if _dbagd != nil {
			return _dbagd
		}
		switch _caadg := _babde.(type) {
		case _b.StartElement:
			switch _caadg.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_bfffc.Fill = NewFill()
				if _bbcg := d.DecodeElement(_bfffc.Fill, &_caadg); _bbcg != nil {
					return _bbcg
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_bfffc.Stroke = NewStroke()
				if _fcgbg := d.DecodeElement(_bfffc.Stroke, &_caadg); _fcgbg != nil {
					return _fcgbg
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_bfffc.Textbox = NewTextbox()
				if _abfc := d.DecodeElement(_bfffc.Textbox, &_caadg); _abfc != nil {
					return _abfc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_bfffc.Shadow = NewShadow()
				if _abgdd := d.DecodeElement(_bfffc.Shadow, &_caadg); _abgdd != nil {
					return _abgdd
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_bfffc.Skew = NewOfcSkew()
				if _faccfb := d.DecodeElement(_bfffc.Skew, &_caadg); _faccfb != nil {
					return _faccfb
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_bfffc.Extrusion = NewOfcExtrusion()
				if _edacc := d.DecodeElement(_bfffc.Extrusion, &_caadg); _edacc != nil {
					return _edacc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_bfffc.Callout = NewOfcCallout()
				if _ceadc := d.DecodeElement(_bfffc.Callout, &_caadg); _ceadc != nil {
					return _ceadc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_bfffc.Lock = NewOfcLock()
				if _edeg := d.DecodeElement(_bfffc.Lock, &_caadg); _edeg != nil {
					return _edeg
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "colormru"}:
				_bfffc.Colormru = NewOfcCT_ColorMru()
				if _baebe := d.DecodeElement(_bfffc.Colormru, &_caadg); _baebe != nil {
					return _baebe
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "colormenu"}:
				_bfffc.Colormenu = NewOfcCT_ColorMenu()
				if _edgag := d.DecodeElement(_bfffc.Colormenu, &_caadg); _edgag != nil {
					return _edgag
				}
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020OfcShapedefaults\u0020\u0025v", _caadg.Name)
				if _gcee := d.Skip(); _gcee != nil {
					return _gcee
				}
			}
		case _b.EndElement:
			break _afbga
		case _b.CharData:
		}
	}
	return nil
}
func NewImagedata() *Imagedata {
	_ceffd := &Imagedata{}
	_ceffd.CT_ImageData = *NewCT_ImageData()
	return _ceffd
}
func (_deabdc ST_StrokeEndCap) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_cgdabc := _b.Attr{}
	_cgdabc.Name = name
	switch _deabdc {
	case ST_StrokeEndCapUnset:
		_cgdabc.Value = ""
	case ST_StrokeEndCapFlat:
		_cgdabc.Value = "flat"
	case ST_StrokeEndCapSquare:
		_cgdabc.Value = "square"
	case ST_StrokeEndCapRound:
		_cgdabc.Value = "round"
	}
	return _cgdabc, nil
}

// ValidateWithPath validates the OfcCT_IdMap and its children, prefixing error messages with path
func (_bfecc *OfcCT_IdMap) ValidateWithPath(path string) error {
	if _ffcgc := _bfecc.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _ffcgc != nil {
		return _ffcgc
	}
	return nil
}

type Formulas struct{ CT_Formulas }
type AG_AllCoreAttributes struct {
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
}

// Validate validates the Arc and its children
func (_cfabf *Arc) Validate() error { return _cfabf.ValidateWithPath("Arc") }
func (_cgbc *ST_ShadowType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_cgbc = 0
	case "single":
		*_cgbc = 1
	case "double":
		*_cgbc = 2
	case "emboss":
		*_cgbc = 3
	case "perspective":
		*_cgbc = 4
	}
	return nil
}
func (_faccc *OfcCallout) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_faccc.OfcCT_Callout = *NewOfcCT_Callout()
	for _, _gbafca := range start.Attr {
		if _gbafca.Name.Local == "lengthspecified" {
			_faccc.LengthspecifiedAttr.UnmarshalXMLAttr(_gbafca)
			continue
		}
		if _gbafca.Name.Local == "on" {
			_faccc.OnAttr.UnmarshalXMLAttr(_gbafca)
			continue
		}
		if _gbafca.Name.Local == "gap" {
			_cebd, _fdgc := _gbafca.Value, error(nil)
			if _fdgc != nil {
				return _fdgc
			}
			_faccc.GapAttr = &_cebd
			continue
		}
		if _gbafca.Name.Local == "angle" {
			_faccc.AngleAttr.UnmarshalXMLAttr(_gbafca)
			continue
		}
		if _gbafca.Name.Local == "dropauto" {
			_faccc.DropautoAttr.UnmarshalXMLAttr(_gbafca)
			continue
		}
		if _gbafca.Name.Local == "drop" {
			_fffcb, _gfbeb := _gbafca.Value, error(nil)
			if _gfbeb != nil {
				return _gfbeb
			}
			_faccc.DropAttr = &_fffcb
			continue
		}
		if _gbafca.Name.Local == "distance" {
			_eaaba, _ecbef := _gbafca.Value, error(nil)
			if _ecbef != nil {
				return _ecbef
			}
			_faccc.DistanceAttr = &_eaaba
			continue
		}
		if _gbafca.Name.Local == "type" {
			_afcce, _gabff := _gbafca.Value, error(nil)
			if _gabff != nil {
				return _gabff
			}
			_faccc.TypeAttr = &_afcce
			continue
		}
		if _gbafca.Name.Local == "length" {
			_febfc, _dcbcg := _gbafca.Value, error(nil)
			if _dcbcg != nil {
				return _dcbcg
			}
			_faccc.LengthAttr = &_febfc
			continue
		}
		if _gbafca.Name.Local == "accentbar" {
			_faccc.AccentbarAttr.UnmarshalXMLAttr(_gbafca)
			continue
		}
		if _gbafca.Name.Local == "textborder" {
			_faccc.TextborderAttr.UnmarshalXMLAttr(_gbafca)
			continue
		}
		if _gbafca.Name.Local == "minusx" {
			_faccc.MinusxAttr.UnmarshalXMLAttr(_gbafca)
			continue
		}
		if _gbafca.Name.Local == "minusy" {
			_faccc.MinusyAttr.UnmarshalXMLAttr(_gbafca)
			continue
		}
		if _gbafca.Name.Local == "ext" {
			_faccc.ExtAttr.UnmarshalXMLAttr(_gbafca)
			continue
		}
	}
	for {
		_effcg, _fbcbca := d.Token()
		if _fbcbca != nil {
			return _f.Errorf("parsing\u0020OfcCallout:\u0020%s", _fbcbca)
		}
		if _gdbad, _badgb := _effcg.(_b.EndElement); _badgb && _gdbad.Name == start.Name {
			break
		}
	}
	return nil
}
func NewAG_Ext() *AG_Ext { _gabc := &AG_Ext{}; _gabc.ExtAttr = ST_Ext(1); return _gabc }
func (_addda OfcST_ConnectType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_addda.String(), start)
}

const (
	OfcST_OLEUpdateModeUnset  OfcST_OLEUpdateMode = 0
	OfcST_OLEUpdateModeAlways OfcST_OLEUpdateMode = 1
	OfcST_OLEUpdateModeOnCall OfcST_OLEUpdateMode = 2
)

type OfcST_ConnectorType byte

func (_agceec OfcST_How) Validate() error { return _agceec.ValidateWithPath("") }

// ValidateWithPath validates the AG_ShapeAttributes and its children, prefixing error messages with path
func (_fbb *AG_ShapeAttributes) ValidateWithPath(path string) error {
	if _affc := _fbb.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _affc != nil {
		return _affc
	}
	if _cgf := _fbb.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _cgf != nil {
		return _cgf
	}
	if _dfe := _fbb.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _dfe != nil {
		return _dfe
	}
	return nil
}
func NewOfcCT_Relation() *OfcCT_Relation { _gfdb := &OfcCT_Relation{}; return _gfdb }

// ValidateWithPath validates the CT_Shadow and its children, prefixing error messages with path
func (_cfdfa *CT_Shadow) ValidateWithPath(path string) error {
	if _cgadd := _cfdfa.OnAttr.ValidateWithPath(path + "\u002fOnAttr"); _cgadd != nil {
		return _cgadd
	}
	if _aaeb := _cfdfa.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _aaeb != nil {
		return _aaeb
	}
	if _fbfbe := _cfdfa.ObscuredAttr.ValidateWithPath(path + "\u002fObscuredAttr"); _fbfbe != nil {
		return _fbfbe
	}
	return nil
}
func (_bdegf *ST_StrokeEndCap) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bgfcc, _ebeea := d.Token()
	if _ebeea != nil {
		return _ebeea
	}
	if _gdcda, _afcad := _bgfcc.(_b.EndElement); _afcad && _gdcda.Name == start.Name {
		*_bdegf = 1
		return nil
	}
	if _bacbgb, _faggd := _bgfcc.(_b.CharData); !_faggd {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bgfcc)
	} else {
		switch string(_bacbgb) {
		case "":
			*_bdegf = 0
		case "flat":
			*_bdegf = 1
		case "square":
			*_bdegf = 2
		case "round":
			*_bdegf = 3
		}
	}
	_bgfcc, _ebeea = d.Token()
	if _ebeea != nil {
		return _ebeea
	}
	if _eeag, _acbef := _bgfcc.(_b.EndElement); _acbef && _eeag.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bgfcc)
}

// ValidateWithPath validates the OfcCT_Skew and its children, prefixing error messages with path
func (_gfgd *OfcCT_Skew) ValidateWithPath(path string) error {
	if _gbafc := _gfgd.OnAttr.ValidateWithPath(path + "\u002fOnAttr"); _gbafc != nil {
		return _gbafc
	}
	if _agfdagf := _gfgd.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _agfdagf != nil {
		return _agfdagf
	}
	return nil
}
func NewAG_Chromakey() *AG_Chromakey { _bba := &AG_Chromakey{}; return _bba }
func (_eebcd OfcST_ScreenSize) ValidateWithPath(path string) error {
	switch _eebcd {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eebcd))
	}
	return nil
}
func NewCT_Stroke() *CT_Stroke { _ddda := &CT_Stroke{}; return _ddda }
func (_afec *AG_StrokeAttributes) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _afec.OnAttr != _eb.ST_TrueFalseUnset {
		_daad, _bafe := _afec.OnAttr.MarshalXMLAttr(_b.Name{Local: "on"})
		if _bafe != nil {
			return _bafe
		}
		start.Attr = append(start.Attr, _daad)
	}
	if _afec.WeightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "weight"}, Value: _f.Sprintf("\u0025v", *_afec.WeightAttr)})
	}
	if _afec.ColorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "color"}, Value: _f.Sprintf("\u0025v", *_afec.ColorAttr)})
	}
	if _afec.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_afec.OpacityAttr)})
	}
	if _afec.LinestyleAttr != ST_StrokeLineStyleUnset {
		_ecd, _fegb := _afec.LinestyleAttr.MarshalXMLAttr(_b.Name{Local: "linestyle"})
		if _fegb != nil {
			return _fegb
		}
		start.Attr = append(start.Attr, _ecd)
	}
	if _afec.MiterlimitAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "miterlimit"}, Value: _f.Sprintf("\u0025v", *_afec.MiterlimitAttr)})
	}
	if _afec.JoinstyleAttr != ST_StrokeJoinStyleUnset {
		_egcb, _eabe := _afec.JoinstyleAttr.MarshalXMLAttr(_b.Name{Local: "joinstyle"})
		if _eabe != nil {
			return _eabe
		}
		start.Attr = append(start.Attr, _egcb)
	}
	if _afec.EndcapAttr != ST_StrokeEndCapUnset {
		_facc, _cdec := _afec.EndcapAttr.MarshalXMLAttr(_b.Name{Local: "endcap"})
		if _cdec != nil {
			return _cdec
		}
		start.Attr = append(start.Attr, _facc)
	}
	if _afec.DashstyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "dashstyle"}, Value: _f.Sprintf("\u0025v", *_afec.DashstyleAttr)})
	}
	if _afec.FilltypeAttr != ST_FillTypeUnset {
		_gbgb, _acdd := _afec.FilltypeAttr.MarshalXMLAttr(_b.Name{Local: "filltype"})
		if _acdd != nil {
			return _acdd
		}
		start.Attr = append(start.Attr, _gbgb)
	}
	if _afec.SrcAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "src"}, Value: _f.Sprintf("\u0025v", *_afec.SrcAttr)})
	}
	if _afec.ImageaspectAttr != ST_ImageAspectUnset {
		_bddf, _bfde := _afec.ImageaspectAttr.MarshalXMLAttr(_b.Name{Local: "imageaspect"})
		if _bfde != nil {
			return _bfde
		}
		start.Attr = append(start.Attr, _bddf)
	}
	if _afec.ImagesizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "imagesize"}, Value: _f.Sprintf("\u0025v", *_afec.ImagesizeAttr)})
	}
	if _afec.ImagealignshapeAttr != _eb.ST_TrueFalseUnset {
		_fgcd, _dacd := _afec.ImagealignshapeAttr.MarshalXMLAttr(_b.Name{Local: "imagealignshape"})
		if _dacd != nil {
			return _dacd
		}
		start.Attr = append(start.Attr, _fgcd)
	}
	if _afec.Color2Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "color2"}, Value: _f.Sprintf("\u0025v", *_afec.Color2Attr)})
	}
	if _afec.StartarrowAttr != ST_StrokeArrowTypeUnset {
		_bcgcf, _agee := _afec.StartarrowAttr.MarshalXMLAttr(_b.Name{Local: "startarrow"})
		if _agee != nil {
			return _agee
		}
		start.Attr = append(start.Attr, _bcgcf)
	}
	if _afec.StartarrowwidthAttr != ST_StrokeArrowWidthUnset {
		_cbce, _bdbd := _afec.StartarrowwidthAttr.MarshalXMLAttr(_b.Name{Local: "startarrowwidth"})
		if _bdbd != nil {
			return _bdbd
		}
		start.Attr = append(start.Attr, _cbce)
	}
	if _afec.StartarrowlengthAttr != ST_StrokeArrowLengthUnset {
		_adfb, _gecb := _afec.StartarrowlengthAttr.MarshalXMLAttr(_b.Name{Local: "startarrowlength"})
		if _gecb != nil {
			return _gecb
		}
		start.Attr = append(start.Attr, _adfb)
	}
	if _afec.EndarrowAttr != ST_StrokeArrowTypeUnset {
		_cece, _egca := _afec.EndarrowAttr.MarshalXMLAttr(_b.Name{Local: "endarrow"})
		if _egca != nil {
			return _egca
		}
		start.Attr = append(start.Attr, _cece)
	}
	if _afec.EndarrowwidthAttr != ST_StrokeArrowWidthUnset {
		_cac, _feaaf := _afec.EndarrowwidthAttr.MarshalXMLAttr(_b.Name{Local: "endarrowwidth"})
		if _feaaf != nil {
			return _feaaf
		}
		start.Attr = append(start.Attr, _cac)
	}
	if _afec.EndarrowlengthAttr != ST_StrokeArrowLengthUnset {
		_cgac, _cggb := _afec.EndarrowlengthAttr.MarshalXMLAttr(_b.Name{Local: "endarrowlength"})
		if _cggb != nil {
			return _cggb
		}
		start.Attr = append(start.Attr, _cgac)
	}
	if _afec.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:href"}, Value: _f.Sprintf("\u0025v", *_afec.HrefAttr)})
	}
	if _afec.AlthrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:althref"}, Value: _f.Sprintf("\u0025v", *_afec.AlthrefAttr)})
	}
	if _afec.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:title"}, Value: _f.Sprintf("\u0025v", *_afec.TitleAttr)})
	}
	if _afec.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_cbgd, _bcbc := _afec.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _bcbc != nil {
			return _bcbc
		}
		start.Attr = append(start.Attr, _cbgd)
	}
	if _afec.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:id"}, Value: _f.Sprintf("\u0025v", *_afec.IdAttr)})
	}
	if _afec.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_fdg, _dfd := _afec.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _dfd != nil {
			return _dfd
		}
		start.Attr = append(start.Attr, _fdg)
	}
	if _afec.RelidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:relid"}, Value: _f.Sprintf("\u0025v", *_afec.RelidAttr)})
	}
	return nil
}
func (_ebe *AG_AllShapeAttributes) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bbd := range start.Attr {
		if _bbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbd.Name.Local == "connectortype" {
			_ebe.ConnectortypeAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbd.Name.Local == "bwpure" {
			_ebe.BwpureAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbd.Name.Local == "cliptowrap" {
			_ebe.CliptowrapAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbd.Name.Local == "preferrelative" {
			_ebe.PreferrelativeAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbd.Name.Local == "ole" {
			_ebe.OleAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbd.Name.Local == "oleicon" {
			_ebe.OleiconAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbd.Name.Local == "forcedash" {
			_ebe.ForcedashAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbd.Name.Local == "bwnormal" {
			_ebe.BwnormalAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbd.Name.Local == "spt" {
			_acc, _bce := _e.ParseFloat(_bbd.Value, 64)
			if _bce != nil {
				return _bce
			}
			_dead := float32(_acc)
			_ebe.SptAttr = &_dead
			continue
		}
		if _bbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbd.Name.Local == "clip" {
			_ebe.ClipAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbd.Name.Local == "bwmode" {
			_ebe.BwmodeAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Local == "stroked" {
			_ebe.StrokedAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Local == "fillcolor" {
			_baf, _gba := _bbd.Value, error(nil)
			if _gba != nil {
				return _gba
			}
			_ebe.FillcolorAttr = &_baf
			continue
		}
		if _bbd.Name.Local == "filled" {
			_ebe.FilledAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Local == "chromakey" {
			_deaa, _daa := _bbd.Value, error(nil)
			if _daa != nil {
				return _daa
			}
			_ebe.ChromakeyAttr = &_deaa
			continue
		}
		if _bbd.Name.Local == "insetpen" {
			_ebe.InsetpenAttr.UnmarshalXMLAttr(_bbd)
			continue
		}
		if _bbd.Name.Local == "strokeweight" {
			_gcf, _fdc := _bbd.Value, error(nil)
			if _fdc != nil {
				return _fdc
			}
			_ebe.StrokeweightAttr = &_gcf
			continue
		}
		if _bbd.Name.Local == "strokecolor" {
			_bbc, _cfa := _bbd.Value, error(nil)
			if _cfa != nil {
				return _cfa
			}
			_ebe.StrokecolorAttr = &_bbc
			continue
		}
		if _bbd.Name.Local == "opacity" {
			_ccg, _abc := _bbd.Value, error(nil)
			if _abc != nil {
				return _abc
			}
			_ebe.OpacityAttr = &_ccg
			continue
		}
	}
	for {
		_cgad, _bfda := d.Token()
		if _bfda != nil {
			return _f.Errorf("parsing\u0020AG_AllShapeAttributes:\u0020\u0025s", _bfda)
		}
		if _age, _gdd := _cgad.(_b.EndElement); _gdd && _age.Name == start.Name {
			break
		}
	}
	return nil
}
func (_caace OfcST_CalloutPlacement) Validate() error { return _caace.ValidateWithPath("") }
func (_faffb *OfcLeft) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:left"
	return _faffb.OfcCT_StrokeChild.MarshalXML(e, start)
}
func (_efbf *CT_H) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _aaca := range start.Attr {
		if _aaca.Name.Local == "position" {
			_addab, _daff := _aaca.Value, error(nil)
			if _daff != nil {
				return _daff
			}
			_efbf.PositionAttr = &_addab
			continue
		}
		if _aaca.Name.Local == "polar" {
			_aada, _egffd := _aaca.Value, error(nil)
			if _egffd != nil {
				return _egffd
			}
			_efbf.PolarAttr = &_aada
			continue
		}
		if _aaca.Name.Local == "map" {
			_fbec, _cedea := _aaca.Value, error(nil)
			if _cedea != nil {
				return _cedea
			}
			_efbf.MapAttr = &_fbec
			continue
		}
		if _aaca.Name.Local == "invx" {
			_efbf.InvxAttr.UnmarshalXMLAttr(_aaca)
			continue
		}
		if _aaca.Name.Local == "invy" {
			_efbf.InvyAttr.UnmarshalXMLAttr(_aaca)
			continue
		}
		if _aaca.Name.Local == "switch" {
			_efbf.SwitchAttr.UnmarshalXMLAttr(_aaca)
			continue
		}
		if _aaca.Name.Local == "xrange" {
			_ebda, _fdgfb := _aaca.Value, error(nil)
			if _fdgfb != nil {
				return _fdgfb
			}
			_efbf.XrangeAttr = &_ebda
			continue
		}
		if _aaca.Name.Local == "yrange" {
			_gece, _cdfa := _aaca.Value, error(nil)
			if _cdfa != nil {
				return _cdfa
			}
			_efbf.YrangeAttr = &_gece
			continue
		}
		if _aaca.Name.Local == "radiusrange" {
			_aeff, _bgee := _aaca.Value, error(nil)
			if _bgee != nil {
				return _bgee
			}
			_efbf.RadiusrangeAttr = &_aeff
			continue
		}
	}
	for {
		_fdba, _gdda := d.Token()
		if _gdda != nil {
			return _f.Errorf("parsing\u0020CT_H:\u0020\u0025s", _gdda)
		}
		if _dbcg, _bagb := _fdba.(_b.EndElement); _bagb && _dbcg.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_Arc() *CT_Arc { _debf := &CT_Arc{}; return _debf }
func (_deabd *OfcTop) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_deabd.OfcCT_StrokeChild = *NewOfcCT_StrokeChild()
	for _, _adebab := range start.Attr {
		if _adebab.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _adebab.Name.Local == "href" {
			_abacg, _cfff := _adebab.Value, error(nil)
			if _cfff != nil {
				return _cfff
			}
			_deabd.HrefAttr = &_abacg
			continue
		}
		if _adebab.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _adebab.Name.Local == "forcedash" {
			_deabd.ForcedashAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _adebab.Name.Local == "title" {
			_bgffg, _aafdd := _adebab.Value, error(nil)
			if _aafdd != nil {
				return _aafdd
			}
			_deabd.TitleAttr = &_bgffg
			continue
		}
		if _adebab.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _adebab.Name.Local == "althref" {
			_eegdc, _caeb := _adebab.Value, error(nil)
			if _caeb != nil {
				return _caeb
			}
			_deabd.AlthrefAttr = &_eegdc
			continue
		}
		if _adebab.Name.Local == "imageaspect" {
			_deabd.ImageaspectAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "startarrow" {
			_deabd.StartarrowAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "linestyle" {
			_deabd.LinestyleAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "startarrowwidth" {
			_deabd.StartarrowwidthAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "joinstyle" {
			_deabd.JoinstyleAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "startarrowlength" {
			_deabd.StartarrowlengthAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "dashstyle" {
			_bcggbc, _ddce := _adebab.Value, error(nil)
			if _ddce != nil {
				return _ddce
			}
			_deabd.DashstyleAttr = &_bcggbc
			continue
		}
		if _adebab.Name.Local == "endarrow" {
			_deabd.EndarrowAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "filltype" {
			_deabd.FilltypeAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "endarrowwidth" {
			_deabd.EndarrowwidthAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "opacity" {
			_dddaa, _aafda := _adebab.Value, error(nil)
			if _aafda != nil {
				return _aafda
			}
			_deabd.OpacityAttr = &_dddaa
			continue
		}
		if _adebab.Name.Local == "color" {
			_fagab, _dcdbe := _adebab.Value, error(nil)
			if _dcdbe != nil {
				return _dcdbe
			}
			_deabd.ColorAttr = &_fagab
			continue
		}
		if _adebab.Name.Local == "insetpen" {
			_deabd.InsetpenAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "endarrowlength" {
			_deabd.EndarrowlengthAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "ext" {
			_deabd.ExtAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "endcap" {
			_deabd.EndcapAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "color2" {
			_efbfa, _affca := _adebab.Value, error(nil)
			if _affca != nil {
				return _affca
			}
			_deabd.Color2Attr = &_efbfa
			continue
		}
		if _adebab.Name.Local == "imagealignshape" {
			_deabd.ImagealignshapeAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
		if _adebab.Name.Local == "weight" {
			_ecgfg, _bbcgg := _adebab.Value, error(nil)
			if _bbcgg != nil {
				return _bbcgg
			}
			_deabd.WeightAttr = &_ecgfg
			continue
		}
		if _adebab.Name.Local == "src" {
			_agca, _cfbb := _adebab.Value, error(nil)
			if _cfbb != nil {
				return _cfbb
			}
			_deabd.SrcAttr = &_agca
			continue
		}
		if _adebab.Name.Local == "imagesize" {
			_fcbbg, _eddgb := _adebab.Value, error(nil)
			if _eddgb != nil {
				return _eddgb
			}
			_deabd.ImagesizeAttr = &_fcbbg
			continue
		}
		if _adebab.Name.Local == "miterlimit" {
			_aafacf, _cfed := _e.ParseFloat(_adebab.Value, 64)
			if _cfed != nil {
				return _cfed
			}
			_deabd.MiterlimitAttr = &_aafacf
			continue
		}
		if _adebab.Name.Local == "on" {
			_deabd.OnAttr.UnmarshalXMLAttr(_adebab)
			continue
		}
	}
	for {
		_ebdgg, _dddeg := d.Token()
		if _dddeg != nil {
			return _f.Errorf("parsing\u0020OfcTop:\u0020\u0025s", _dddeg)
		}
		if _dfcff, _gbebf := _ebdgg.(_b.EndElement); _gbebf && _dfcff.Name == start.Name {
			break
		}
	}
	return nil
}
func (_becdf OfcST_ConnectType) Validate() error { return _becdf.ValidateWithPath("") }

// ValidateWithPath validates the OfcCT_Ink and its children, prefixing error messages with path
func (_faecf *OfcCT_Ink) ValidateWithPath(path string) error {
	if _ebabg := _faecf.AnnotationAttr.ValidateWithPath(path + "\u002fAnnotationAttr"); _ebabg != nil {
		return _ebabg
	}
	return nil
}
func (_fdgaf ST_ShadowType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bfdgc := _b.Attr{}
	_bfdgc.Name = name
	switch _fdgaf {
	case ST_ShadowTypeUnset:
		_bfdgc.Value = ""
	case ST_ShadowTypeSingle:
		_bfdgc.Value = "single"
	case ST_ShadowTypeDouble:
		_bfdgc.Value = "double"
	case ST_ShadowTypeEmboss:
		_bfdgc.Value = "emboss"
	case ST_ShadowTypePerspective:
		_bfdgc.Value = "perspective"
	}
	return _bfdgc, nil
}
func NewOfcCT_Complex() *OfcCT_Complex { _cebaa := &OfcCT_Complex{}; return _cebaa }

// Validate validates the CT_TextPath and its children
func (_fadec *CT_TextPath) Validate() error { return _fadec.ValidateWithPath("CT_TextPath") }

// ValidateWithPath validates the OfcCT_RelationTable and its children, prefixing error messages with path
func (_dccaa *OfcCT_RelationTable) ValidateWithPath(path string) error {
	for _cdffgb, _fbgda := range _dccaa.Rel {
		if _fbdbf := _fbgda.ValidateWithPath(_f.Sprintf("\u0025s\u002fRel\u005b\u0025d\u005d", path, _cdffgb)); _fbdbf != nil {
			return _fbdbf
		}
	}
	if _gcbcg := _dccaa.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _gcbcg != nil {
		return _gcbcg
	}
	return nil
}
func (_fbeg *OfcCT_Rules) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ffdad := range start.Attr {
		if _ffdad.Name.Local == "ext" {
			_fbeg.ExtAttr.UnmarshalXMLAttr(_ffdad)
			continue
		}
	}
_eaecf:
	for {
		_gcgaf, _agcd := d.Token()
		if _agcd != nil {
			return _agcd
		}
		switch _begga := _gcgaf.(type) {
		case _b.StartElement:
			switch _begga.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "r"}:
				_ggdea := NewOfcCT_R()
				if _ggcae := d.DecodeElement(_ggdea, &_begga); _ggcae != nil {
					return _ggcae
				}
				_fbeg.R = append(_fbeg.R, _ggdea)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020OfcCT_Rules\u0020\u0025v", _begga.Name)
				if _begda := d.Skip(); _begda != nil {
					return _begda
				}
			}
		case _b.EndElement:
			break _eaecf
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Image and its children, prefixing error messages with path
func (_ebaa *CT_Image) ValidateWithPath(path string) error {
	for _cefb, _cgee := range _ebaa.EG_ShapeElements {
		if _bcabf := _cgee.ValidateWithPath(_f.Sprintf("\u0025s\u002fEG_ShapeElements\u005b\u0025d\u005d", path, _cefb)); _bcabf != nil {
			return _bcabf
		}
	}
	if _febc := _ebaa.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _febc != nil {
		return _febc
	}
	if _acaga := _ebaa.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _acaga != nil {
		return _acaga
	}
	if _egcc := _ebaa.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _egcc != nil {
		return _egcc
	}
	if _gdea := _ebaa.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _gdea != nil {
		return _gdea
	}
	if _gcdg := _ebaa.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _gcdg != nil {
		return _gcdg
	}
	if _ceceb := _ebaa.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _ceceb != nil {
		return _ceceb
	}
	if _dcegg := _ebaa.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _dcegg != nil {
		return _dcegg
	}
	if _bcbg := _ebaa.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _bcbg != nil {
		return _bcbg
	}
	if _fdbf := _ebaa.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _fdbf != nil {
		return _fdbf
	}
	if _fbdg := _ebaa.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _fbdg != nil {
		return _fbdg
	}
	if _fdag := _ebaa.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _fdag != nil {
		return _fdag
	}
	if _efad := _ebaa.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _efad != nil {
		return _efad
	}
	if _cdef := _ebaa.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _cdef != nil {
		return _cdef
	}
	if _cbcb := _ebaa.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _cbcb != nil {
		return _cbcb
	}
	if _ebdb := _ebaa.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _ebdb != nil {
		return _ebdb
	}
	if _fdbc := _ebaa.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _fdbc != nil {
		return _fdbc
	}
	if _cbgc := _ebaa.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _cbgc != nil {
		return _cbgc
	}
	if _acegf := _ebaa.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _acegf != nil {
		return _acegf
	}
	if _bedf := _ebaa.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _bedf != nil {
		return _bedf
	}
	if _acdcd := _ebaa.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _acdcd != nil {
		return _acdcd
	}
	if _fdgfd := _ebaa.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _fdgfd != nil {
		return _fdgfd
	}
	if _abcf := _ebaa.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _abcf != nil {
		return _abcf
	}
	if _cbbd := _ebaa.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _cbbd != nil {
		return _cbbd
	}
	if _bgefb := _ebaa.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _bgefb != nil {
		return _bgefb
	}
	if _cgdg := _ebaa.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _cgdg != nil {
		return _cgdg
	}
	if _bacbg := _ebaa.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _bacbg != nil {
		return _bacbg
	}
	if _gffb := _ebaa.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _gffb != nil {
		return _gffb
	}
	if _eged := _ebaa.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _eged != nil {
		return _eged
	}
	if _ecbdd := _ebaa.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _ecbdd != nil {
		return _ecbdd
	}
	if _ccede := _ebaa.GrayscaleAttr.ValidateWithPath(path + "\u002fGrayscaleAttr"); _ccede != nil {
		return _ccede
	}
	if _fddeb := _ebaa.BilevelAttr.ValidateWithPath(path + "\u002fBilevelAttr"); _fddeb != nil {
		return _fddeb
	}
	return nil
}

type ST_StrokeLineStyle byte

func NewAG_Type() *AG_Type { _fcgb := &AG_Type{}; return _fcgb }

// Validate validates the OfcShapedefaults and its children
func (_cfcef *OfcShapedefaults) Validate() error { return _cfcef.ValidateWithPath("OfcShapedefaults") }
func NewShadow() *Shadow                         { _cecd := &Shadow{}; _cecd.CT_Shadow = *NewCT_Shadow(); return _cecd }
func (_cdgff *OfcCT_RegroupTable) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _cdgff.ExtAttr != ST_ExtUnset {
		_fefdb, _feca := _cdgff.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _feca != nil {
			return _feca
		}
		start.Attr = append(start.Attr, _fefdb)
	}
	e.EncodeToken(start)
	if _cdgff.Entry != nil {
		_cdfbf := _b.StartElement{Name: _b.Name{Local: "o:entry"}}
		for _, _adbee := range _cdgff.Entry {
			e.EncodeElement(_adbee, _cdfbf)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_F and its children
func (_ddfg *CT_F) Validate() error { return _ddfg.ValidateWithPath("CT_F") }
func (_edcaf *OfcSkew) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_edcaf.OfcCT_Skew = *NewOfcCT_Skew()
	for _, _dbaad := range start.Attr {
		if _dbaad.Name.Local == "id" {
			_eaccc, _fcbfc := _dbaad.Value, error(nil)
			if _fcbfc != nil {
				return _fcbfc
			}
			_edcaf.IdAttr = &_eaccc
			continue
		}
		if _dbaad.Name.Local == "on" {
			_edcaf.OnAttr.UnmarshalXMLAttr(_dbaad)
			continue
		}
		if _dbaad.Name.Local == "offset" {
			_caedc, _eecgc := _dbaad.Value, error(nil)
			if _eecgc != nil {
				return _eecgc
			}
			_edcaf.OffsetAttr = &_caedc
			continue
		}
		if _dbaad.Name.Local == "origin" {
			_cbbfb, _bebcb := _dbaad.Value, error(nil)
			if _bebcb != nil {
				return _bebcb
			}
			_edcaf.OriginAttr = &_cbbfb
			continue
		}
		if _dbaad.Name.Local == "matrix" {
			_fccbe, _fgeef := _dbaad.Value, error(nil)
			if _fgeef != nil {
				return _fgeef
			}
			_edcaf.MatrixAttr = &_fccbe
			continue
		}
		if _dbaad.Name.Local == "ext" {
			_edcaf.ExtAttr.UnmarshalXMLAttr(_dbaad)
			continue
		}
	}
	for {
		_afad, _dbdfde := d.Token()
		if _dbdfde != nil {
			return _f.Errorf("parsing\u0020OfcSkew:\u0020\u0025s", _dbdfde)
		}
		if _gcgfe, _ddcff := _afad.(_b.EndElement); _ddcff && _gcgfe.Name == start.Name {
			break
		}
	}
	return nil
}
func NewOfcRight() *OfcRight {
	_eggfd := &OfcRight{}
	_eggfd.OfcCT_StrokeChild = *NewOfcCT_StrokeChild()
	return _eggfd
}
func NewOfcCT_Proxy() *OfcCT_Proxy { _ggaff := &OfcCT_Proxy{}; return _ggaff }
func (_bgfec *Curve) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bgfec.CT_Curve = *NewCT_Curve()
	for _, _faccbd := range start.Attr {
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "allowoverlap" {
			_bgfec.AllowoverlapAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "regroupid" {
			_acgc, _cded := _e.ParseInt(_faccbd.Value, 10, 64)
			if _cded != nil {
				return _cded
			}
			_bgfec.RegroupidAttr = &_acgc
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "dgmlayout" {
			_bgfec.DgmlayoutAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "doubleclicknotify" {
			_bgfec.DoubleclicknotifyAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "preferrelative" {
			_bgfec.PreferrelativeAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "button" {
			_bgfec.ButtonAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "ole" {
			_bgfec.OleAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "userhidden" {
			_bgfec.UserhiddenAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "forcedash" {
			_bgfec.ForcedashAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "bullet" {
			_bgfec.BulletAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "bwpure" {
			_bgfec.BwpureAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "clip" {
			_bgfec.ClipAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "borderbottomcolor" {
			_gecea, _eedge := _faccbd.Value, error(nil)
			if _eedge != nil {
				return _eedge
			}
			_bgfec.BorderbottomcolorAttr = &_gecea
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "bwnormal" {
			_bgfec.BwnormalAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "hralign" {
			_bgfec.HralignAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "hr" {
			_bgfec.HrAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "bordertopcolor" {
			_dcgbfb, _fdcfd := _faccbd.Value, error(nil)
			if _fdcfd != nil {
				return _fdcfd
			}
			_bgfec.BordertopcolorAttr = &_dcgbfb
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "dgmnodekind" {
			_bcgf, _ageecf := _e.ParseInt(_faccbd.Value, 10, 64)
			if _ageecf != nil {
				return _ageecf
			}
			_bgfec.DgmnodekindAttr = &_bcgf
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "borderrightcolor" {
			_cddac, _eaff := _faccbd.Value, error(nil)
			if _eaff != nil {
				return _eaff
			}
			_bgfec.BorderrightcolorAttr = &_cddac
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "spid" {
			_gdeca, _adcdb := _faccbd.Value, error(nil)
			if _adcdb != nil {
				return _adcdb
			}
			_bgfec.SpidAttr = &_gdeca
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "hrpct" {
			_fdeed, _ededd := _e.ParseFloat(_faccbd.Value, 64)
			if _ededd != nil {
				return _ededd
			}
			_dabba := float32(_fdeed)
			_bgfec.HrpctAttr = &_dabba
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "hrstd" {
			_bgfec.HrstdAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "cliptowrap" {
			_bgfec.CliptowrapAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "allowincell" {
			_bgfec.AllowincellAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "dgmlayoutmru" {
			_bgfec.DgmlayoutmruAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "userdrawn" {
			_bgfec.UserdrawnAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "oleicon" {
			_bgfec.OleiconAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "borderleftcolor" {
			_fcdeed, _agff := _faccbd.Value, error(nil)
			if _agff != nil {
				return _agff
			}
			_bgfec.BorderleftcolorAttr = &_fcdeed
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "spt" {
			_egaeg, _gggea := _e.ParseFloat(_faccbd.Value, 64)
			if _gggea != nil {
				return _gggea
			}
			_adbf := float32(_egaeg)
			_bgfec.SptAttr = &_adbf
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "bwmode" {
			_bgfec.BwmodeAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "connectortype" {
			_bgfec.ConnectortypeAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "insetmode" {
			_bgfec.InsetmodeAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "oned" {
			_bgfec.OnedAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _faccbd.Name.Local == "hrnoshade" {
			_bgfec.HrnoshadeAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Local == "title" {
			_aebbd, _ccgga := _faccbd.Value, error(nil)
			if _ccgga != nil {
				return _ccgga
			}
			_bgfec.TitleAttr = &_aebbd
			continue
		}
		if _faccbd.Name.Local == "wrapcoords" {
			_efcge, _bgbfe := _faccbd.Value, error(nil)
			if _bgbfe != nil {
				return _bgbfe
			}
			_bgfec.WrapcoordsAttr = &_efcge
			continue
		}
		if _faccbd.Name.Local == "style" {
			_fbbgfe, _cgeag := _faccbd.Value, error(nil)
			if _cgeag != nil {
				return _cgeag
			}
			_bgfec.StyleAttr = &_fbbgfe
			continue
		}
		if _faccbd.Name.Local == "coordorigin" {
			_afffg, _cefda := _faccbd.Value, error(nil)
			if _cefda != nil {
				return _cefda
			}
			_bgfec.CoordoriginAttr = &_afffg
			continue
		}
		if _faccbd.Name.Local == "print" {
			_bgfec.PrintAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Local == "coordsize" {
			_bfcc, _gabcbf := _faccbd.Value, error(nil)
			if _gabcbf != nil {
				return _gabcbf
			}
			_bgfec.CoordsizeAttr = &_bfcc
			continue
		}
		if _faccbd.Name.Local == "stroked" {
			_bgfec.StrokedAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Local == "alt" {
			_afcfd, _bfgfe := _faccbd.Value, error(nil)
			if _bfgfe != nil {
				return _bfgfe
			}
			_bgfec.AltAttr = &_afcfd
			continue
		}
		if _faccbd.Name.Local == "strokeweight" {
			_afbea, _ddgbf := _faccbd.Value, error(nil)
			if _ddgbf != nil {
				return _ddgbf
			}
			_bgfec.StrokeweightAttr = &_afbea
			continue
		}
		if _faccbd.Name.Local == "control1" {
			_eggce, _beccf := _faccbd.Value, error(nil)
			if _beccf != nil {
				return _beccf
			}
			_bgfec.Control1Attr = &_eggce
			continue
		}
		if _faccbd.Name.Local == "chromakey" {
			_bgbfa, _dcdcb := _faccbd.Value, error(nil)
			if _dcdcb != nil {
				return _dcdcb
			}
			_bgfec.ChromakeyAttr = &_bgbfa
			continue
		}
		if _faccbd.Name.Local == "fillcolor" {
			_bdeg, _faedee := _faccbd.Value, error(nil)
			if _faedee != nil {
				return _faedee
			}
			_bgfec.FillcolorAttr = &_bdeg
			continue
		}
		if _faccbd.Name.Local == "id" {
			_eegce, _abaee := _faccbd.Value, error(nil)
			if _abaee != nil {
				return _abaee
			}
			_bgfec.IdAttr = &_eegce
			continue
		}
		if _faccbd.Name.Local == "opacity" {
			_caacf, _abee := _faccbd.Value, error(nil)
			if _abee != nil {
				return _abee
			}
			_bgfec.OpacityAttr = &_caacf
			continue
		}
		if _faccbd.Name.Local == "strokecolor" {
			_dfcda, _cgde := _faccbd.Value, error(nil)
			if _cgde != nil {
				return _cgde
			}
			_bgfec.StrokecolorAttr = &_dfcda
			continue
		}
		if _faccbd.Name.Local == "class" {
			_bbcce, _dcec := _faccbd.Value, error(nil)
			if _dcec != nil {
				return _dcec
			}
			_bgfec.ClassAttr = &_bbcce
			continue
		}
		if _faccbd.Name.Local == "filled" {
			_bgfec.FilledAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
		if _faccbd.Name.Local == "from" {
			_begea, _cefec := _faccbd.Value, error(nil)
			if _cefec != nil {
				return _cefec
			}
			_bgfec.FromAttr = &_begea
			continue
		}
		if _faccbd.Name.Local == "target" {
			_ccbbf, _cfdc := _faccbd.Value, error(nil)
			if _cfdc != nil {
				return _cfdc
			}
			_bgfec.TargetAttr = &_ccbbf
			continue
		}
		if _faccbd.Name.Local == "href" {
			_edfgf, _fbaeeb := _faccbd.Value, error(nil)
			if _fbaeeb != nil {
				return _fbaeeb
			}
			_bgfec.HrefAttr = &_edfgf
			continue
		}
		if _faccbd.Name.Local == "to" {
			_caegc, _ccgf := _faccbd.Value, error(nil)
			if _ccgf != nil {
				return _ccgf
			}
			_bgfec.ToAttr = &_caegc
			continue
		}
		if _faccbd.Name.Local == "control2" {
			_fdeac, _dgagc := _faccbd.Value, error(nil)
			if _dgagc != nil {
				return _dgagc
			}
			_bgfec.Control2Attr = &_fdeac
			continue
		}
		if _faccbd.Name.Local == "insetpen" {
			_bgfec.InsetpenAttr.UnmarshalXMLAttr(_faccbd)
			continue
		}
	}
_adcdd:
	for {
		_ebadb, _eabb := d.Token()
		if _eabb != nil {
			return _eabb
		}
		switch _dcbef := _ebadb.(type) {
		case _b.StartElement:
			switch _dcbef.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_ffcbd := NewEG_ShapeElements()
				_ffcbd.Path = NewPath()
				if _aebbb := d.DecodeElement(_ffcbd.Path, &_dcbef); _aebbb != nil {
					return _aebbb
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _ffcbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_afgb := NewEG_ShapeElements()
				_afgb.Formulas = NewFormulas()
				if _ebbed := d.DecodeElement(_afgb.Formulas, &_dcbef); _ebbed != nil {
					return _ebbed
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _afgb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_bbgfa := NewEG_ShapeElements()
				_bbgfa.Handles = NewHandles()
				if _ddbe := d.DecodeElement(_bbgfa.Handles, &_dcbef); _ddbe != nil {
					return _ddbe
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _bbgfa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_ceebea := NewEG_ShapeElements()
				_ceebea.Fill = NewFill()
				if _aeaeg := d.DecodeElement(_ceebea.Fill, &_dcbef); _aeaeg != nil {
					return _aeaeg
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _ceebea)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_bgfecb := NewEG_ShapeElements()
				_bgfecb.Stroke = NewStroke()
				if _bcfc := d.DecodeElement(_bgfecb.Stroke, &_dcbef); _bcfc != nil {
					return _bcfc
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _bgfecb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_agecd := NewEG_ShapeElements()
				_agecd.Shadow = NewShadow()
				if _aaccf := d.DecodeElement(_agecd.Shadow, &_dcbef); _aaccf != nil {
					return _aaccf
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _agecd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_ccaca := NewEG_ShapeElements()
				_ccaca.Textbox = NewTextbox()
				if _dfbga := d.DecodeElement(_ccaca.Textbox, &_dcbef); _dfbga != nil {
					return _dfbga
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _ccaca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_caec := NewEG_ShapeElements()
				_caec.Textpath = NewTextpath()
				if _gbfab := d.DecodeElement(_caec.Textpath, &_dcbef); _gbfab != nil {
					return _gbfab
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _caec)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_bafc := NewEG_ShapeElements()
				_bafc.Imagedata = NewImagedata()
				if _bbedc := d.DecodeElement(_bafc.Imagedata, &_dcbef); _bbedc != nil {
					return _bbedc
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _bafc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_dabgge := NewEG_ShapeElements()
				_dabgge.Skew = NewOfcSkew()
				if _bgded := d.DecodeElement(_dabgge.Skew, &_dcbef); _bgded != nil {
					return _bgded
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _dabgge)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_cgdde := NewEG_ShapeElements()
				_cgdde.Extrusion = NewOfcExtrusion()
				if _ecfea := d.DecodeElement(_cgdde.Extrusion, &_dcbef); _ecfea != nil {
					return _ecfea
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _cgdde)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_fgbba := NewEG_ShapeElements()
				_fgbba.Callout = NewOfcCallout()
				if _geae := d.DecodeElement(_fgbba.Callout, &_dcbef); _geae != nil {
					return _geae
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _fgbba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_fcfag := NewEG_ShapeElements()
				_fcfag.Lock = NewOfcLock()
				if _efbff := d.DecodeElement(_fcfag.Lock, &_dcbef); _efbff != nil {
					return _efbff
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _fcfag)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_cgeb := NewEG_ShapeElements()
				_cgeb.Clippath = NewOfcClippath()
				if _aaddg := d.DecodeElement(_cgeb.Clippath, &_dcbef); _aaddg != nil {
					return _aaddg
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _cgeb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_caeaed := NewEG_ShapeElements()
				_caeaed.Signatureline = NewOfcSignatureline()
				if _dadfe := d.DecodeElement(_caeaed.Signatureline, &_dcbef); _dadfe != nil {
					return _dadfe
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _caeaed)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_cgagd := NewEG_ShapeElements()
				_cgagd.Wrap = _a.NewWrap()
				if _cacdd := d.DecodeElement(_cgagd.Wrap, &_dcbef); _cacdd != nil {
					return _cacdd
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _cgagd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_efcd := NewEG_ShapeElements()
				_efcd.Anchorlock = _a.NewAnchorlock()
				if _eabdg := d.DecodeElement(_efcd.Anchorlock, &_dcbef); _eabdg != nil {
					return _eabdg
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _efcd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_dbacf := NewEG_ShapeElements()
				_dbacf.Bordertop = _a.NewBordertop()
				if _dgadg := d.DecodeElement(_dbacf.Bordertop, &_dcbef); _dgadg != nil {
					return _dgadg
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _dbacf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_facbg := NewEG_ShapeElements()
				_facbg.Borderbottom = _a.NewBorderbottom()
				if _gdedfd := d.DecodeElement(_facbg.Borderbottom, &_dcbef); _gdedfd != nil {
					return _gdedfd
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _facbg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_dacad := NewEG_ShapeElements()
				_dacad.Borderleft = _a.NewBorderleft()
				if _fedfg := d.DecodeElement(_dacad.Borderleft, &_dcbef); _fedfg != nil {
					return _fedfg
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _dacad)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_ddbf := NewEG_ShapeElements()
				_ddbf.Borderright = _a.NewBorderright()
				if _aggge := d.DecodeElement(_ddbf.Borderright, &_dcbef); _aggge != nil {
					return _aggge
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _ddbf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_ddgad := NewEG_ShapeElements()
				_ddgad.ClientData = _c.NewClientData()
				if _fbbea := d.DecodeElement(_ddgad.ClientData, &_dcbef); _fbbea != nil {
					return _fbbea
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _ddgad)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_gddbc := NewEG_ShapeElements()
				_gddbc.Textdata = _bf.NewTextdata()
				if _abdga := d.DecodeElement(_gddbc.Textdata, &_dcbef); _abdga != nil {
					return _abdga
				}
				_bgfec.EG_ShapeElements = append(_bgfec.EG_ShapeElements, _gddbc)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on Curve \u0025v", _dcbef.Name)
				if _fbdb := d.Skip(); _fbdb != nil {
					return _fbdb
				}
			}
		case _b.EndElement:
			break _adcdd
		case _b.CharData:
		}
	}
	return nil
}
func (_ccgce *Textpath) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _ccgce.CT_TextPath.MarshalXML(e, start)
}
func (_fdaa *CT_Image) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _fdaa.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_fdaa.HrefAttr)})
	}
	if _fdaa.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_fdaa.TargetAttr)})
	}
	if _fdaa.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_fdaa.ClassAttr)})
	}
	if _fdaa.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_fdaa.TitleAttr)})
	}
	if _fdaa.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_fdaa.AltAttr)})
	}
	if _fdaa.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_fdaa.CoordsizeAttr)})
	}
	if _fdaa.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_fdaa.CoordoriginAttr)})
	}
	if _fdaa.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_fdaa.WrapcoordsAttr)})
	}
	if _fdaa.PrintAttr != _eb.ST_TrueFalseUnset {
		_cedg, _baage := _fdaa.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _baage != nil {
			return _baage
		}
		start.Attr = append(start.Attr, _cedg)
	}
	if _fdaa.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_fdaa.IdAttr)})
	}
	if _fdaa.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_fdaa.StyleAttr)})
	}
	if _fdaa.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_fdaa.SpidAttr)})
	}
	if _fdaa.OnedAttr != _eb.ST_TrueFalseUnset {
		_fegd, _gebge := _fdaa.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _gebge != nil {
			return _gebge
		}
		start.Attr = append(start.Attr, _fegd)
	}
	if _fdaa.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_fdaa.RegroupidAttr)})
	}
	if _fdaa.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_gfea, _cacaf := _fdaa.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _cacaf != nil {
			return _cacaf
		}
		start.Attr = append(start.Attr, _gfea)
	}
	if _fdaa.ButtonAttr != _eb.ST_TrueFalseUnset {
		_acfbd, _ebddg := _fdaa.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _ebddg != nil {
			return _ebddg
		}
		start.Attr = append(start.Attr, _acfbd)
	}
	if _fdaa.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_gdbaa, _gbag := _fdaa.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _gbag != nil {
			return _gbag
		}
		start.Attr = append(start.Attr, _gdbaa)
	}
	if _fdaa.BulletAttr != _eb.ST_TrueFalseUnset {
		_bgef, _dfccc := _fdaa.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _dfccc != nil {
			return _dfccc
		}
		start.Attr = append(start.Attr, _bgef)
	}
	if _fdaa.HrAttr != _eb.ST_TrueFalseUnset {
		_dccc, _dcab := _fdaa.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _dcab != nil {
			return _dcab
		}
		start.Attr = append(start.Attr, _dccc)
	}
	if _fdaa.HrstdAttr != _eb.ST_TrueFalseUnset {
		_dffac, _efbde := _fdaa.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _efbde != nil {
			return _efbde
		}
		start.Attr = append(start.Attr, _dffac)
	}
	if _fdaa.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_abac, _bbfdc := _fdaa.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _bbfdc != nil {
			return _bbfdc
		}
		start.Attr = append(start.Attr, _abac)
	}
	if _fdaa.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_fdaa.HrpctAttr)})
	}
	if _fdaa.HralignAttr != OfcST_HrAlignUnset {
		_eabc, _edeb := _fdaa.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _edeb != nil {
			return _edeb
		}
		start.Attr = append(start.Attr, _eabc)
	}
	if _fdaa.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_gdbfa, _afag := _fdaa.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _afag != nil {
			return _afag
		}
		start.Attr = append(start.Attr, _gdbfa)
	}
	if _fdaa.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_bdffg, _dgade := _fdaa.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _dgade != nil {
			return _dgade
		}
		start.Attr = append(start.Attr, _bdffg)
	}
	if _fdaa.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_bedc, _gbdab := _fdaa.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _gbdab != nil {
			return _gbdab
		}
		start.Attr = append(start.Attr, _bedc)
	}
	if _fdaa.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_fdaa.BordertopcolorAttr)})
	}
	if _fdaa.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_fdaa.BorderleftcolorAttr)})
	}
	if _fdaa.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_fdaa.BorderbottomcolorAttr)})
	}
	if _fdaa.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_fdaa.BorderrightcolorAttr)})
	}
	if _fdaa.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_bcefd, _abbbf := _fdaa.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _abbbf != nil {
			return _abbbf
		}
		start.Attr = append(start.Attr, _bcefd)
	}
	if _fdaa.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_fdaa.DgmnodekindAttr)})
	}
	if _fdaa.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_fdgg, _gacd := _fdaa.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _gacd != nil {
			return _gacd
		}
		start.Attr = append(start.Attr, _fdgg)
	}
	if _fdaa.InsetmodeAttr != OfcST_InsetModeUnset {
		_def, _ccdf := _fdaa.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _ccdf != nil {
			return _ccdf
		}
		start.Attr = append(start.Attr, _def)
	}
	if _fdaa.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_fdaa.OpacityAttr)})
	}
	if _fdaa.StrokedAttr != _eb.ST_TrueFalseUnset {
		_ceddb, _edfa := _fdaa.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _edfa != nil {
			return _edfa
		}
		start.Attr = append(start.Attr, _ceddb)
	}
	if _fdaa.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_fdaa.StrokecolorAttr)})
	}
	if _fdaa.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_fdaa.StrokeweightAttr)})
	}
	if _fdaa.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_adaa, _fcdc := _fdaa.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _fcdc != nil {
			return _fcdc
		}
		start.Attr = append(start.Attr, _adaa)
	}
	if _fdaa.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_fdaa.ChromakeyAttr)})
	}
	if _fdaa.FilledAttr != _eb.ST_TrueFalseUnset {
		_feeg, _cgfa := _fdaa.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _cgfa != nil {
			return _cgfa
		}
		start.Attr = append(start.Attr, _feeg)
	}
	if _fdaa.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_fdaa.FillcolorAttr)})
	}
	if _fdaa.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_fdaa.SptAttr)})
	}
	if _fdaa.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_gebeb, _ebcd := _fdaa.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _ebcd != nil {
			return _ebcd
		}
		start.Attr = append(start.Attr, _gebeb)
	}
	if _fdaa.BwmodeAttr != OfcST_BWModeUnset {
		_gdedc, _gacagg := _fdaa.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _gacagg != nil {
			return _gacagg
		}
		start.Attr = append(start.Attr, _gdedc)
	}
	if _fdaa.BwpureAttr != OfcST_BWModeUnset {
		_afagd, _dcff := _fdaa.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _dcff != nil {
			return _dcff
		}
		start.Attr = append(start.Attr, _afagd)
	}
	if _fdaa.BwnormalAttr != OfcST_BWModeUnset {
		_cggc, _fbga := _fdaa.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _fbga != nil {
			return _fbga
		}
		start.Attr = append(start.Attr, _cggc)
	}
	if _fdaa.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_bgcge, _acag := _fdaa.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _acag != nil {
			return _acag
		}
		start.Attr = append(start.Attr, _bgcge)
	}
	if _fdaa.OleiconAttr != _eb.ST_TrueFalseUnset {
		_faddb, _ccdge := _fdaa.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _ccdge != nil {
			return _ccdge
		}
		start.Attr = append(start.Attr, _faddb)
	}
	if _fdaa.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_bdec, _ccfbc := _fdaa.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _ccfbc != nil {
			return _ccfbc
		}
		start.Attr = append(start.Attr, _bdec)
	}
	if _fdaa.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_fcbeb, _cabfaa := _fdaa.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _cabfaa != nil {
			return _cabfaa
		}
		start.Attr = append(start.Attr, _fcbeb)
	}
	if _fdaa.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_degd, _fecc := _fdaa.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _fecc != nil {
			return _fecc
		}
		start.Attr = append(start.Attr, _degd)
	}
	if _fdaa.ClipAttr != _eb.ST_TrueFalseUnset {
		_acebe, _fdegf := _fdaa.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _fdegf != nil {
			return _fdegf
		}
		start.Attr = append(start.Attr, _acebe)
	}
	if _fdaa.SrcAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "src"}, Value: _f.Sprintf("\u0025v", *_fdaa.SrcAttr)})
	}
	if _fdaa.CropleftAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cropleft"}, Value: _f.Sprintf("\u0025v", *_fdaa.CropleftAttr)})
	}
	if _fdaa.CroptopAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "croptop"}, Value: _f.Sprintf("\u0025v", *_fdaa.CroptopAttr)})
	}
	if _fdaa.CroprightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cropright"}, Value: _f.Sprintf("\u0025v", *_fdaa.CroprightAttr)})
	}
	if _fdaa.CropbottomAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cropbottom"}, Value: _f.Sprintf("\u0025v", *_fdaa.CropbottomAttr)})
	}
	if _fdaa.GainAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "gain"}, Value: _f.Sprintf("\u0025v", *_fdaa.GainAttr)})
	}
	if _fdaa.BlacklevelAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "blacklevel"}, Value: _f.Sprintf("\u0025v", *_fdaa.BlacklevelAttr)})
	}
	if _fdaa.GammaAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "gamma"}, Value: _f.Sprintf("\u0025v", *_fdaa.GammaAttr)})
	}
	if _fdaa.GrayscaleAttr != _eb.ST_TrueFalseUnset {
		_eec, _ccad := _fdaa.GrayscaleAttr.MarshalXMLAttr(_b.Name{Local: "grayscale"})
		if _ccad != nil {
			return _ccad
		}
		start.Attr = append(start.Attr, _eec)
	}
	if _fdaa.BilevelAttr != _eb.ST_TrueFalseUnset {
		_fegbe, _gaea := _fdaa.BilevelAttr.MarshalXMLAttr(_b.Name{Local: "bilevel"})
		if _gaea != nil {
			return _gaea
		}
		start.Attr = append(start.Attr, _fegbe)
	}
	e.EncodeToken(start)
	if _fdaa.EG_ShapeElements != nil {
		for _, _bcdg := range _fdaa.EG_ShapeElements {
			_bcdg.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_gdcb *Arc) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _gdcb.CT_Arc.MarshalXML(e, start)
}
func (_dfded *OfcST_OLEType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cdgbcf, _gadbgf := d.Token()
	if _gadbgf != nil {
		return _gadbgf
	}
	if _badgc, _geebe := _cdgbcf.(_b.EndElement); _geebe && _badgc.Name == start.Name {
		*_dfded = 1
		return nil
	}
	if _gefbf, _adacd := _cdgbcf.(_b.CharData); !_adacd {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cdgbcf)
	} else {
		switch string(_gefbf) {
		case "":
			*_dfded = 0
		case "Embed":
			*_dfded = 1
		case "Link":
			*_dfded = 2
		}
	}
	_cdgbcf, _gadbgf = d.Token()
	if _gadbgf != nil {
		return _gadbgf
	}
	if _bgbfae, _gcffa := _cdgbcf.(_b.EndElement); _gcffa && _bgbfae.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cdgbcf)
}
func (_bafcg *OfcST_HrAlign) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_bafcg = 0
	case "left":
		*_bafcg = 1
	case "right":
		*_bafcg = 2
	case "center":
		*_bafcg = 3
	}
	return nil
}
func (_eafda *OfcShapelayout) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_eafda.OfcCT_ShapeLayout = *NewOfcCT_ShapeLayout()
	for _, _ccfaa := range start.Attr {
		if _ccfaa.Name.Local == "ext" {
			_eafda.ExtAttr.UnmarshalXMLAttr(_ccfaa)
			continue
		}
	}
_feaba:
	for {
		_cfafb, _beaae := d.Token()
		if _beaae != nil {
			return _beaae
		}
		switch _fegfe := _cfafb.(type) {
		case _b.StartElement:
			switch _fegfe.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "idmap"}:
				_eafda.Idmap = NewOfcCT_IdMap()
				if _bfgafc := d.DecodeElement(_eafda.Idmap, &_fegfe); _bfgafc != nil {
					return _bfgafc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "regrouptable"}:
				_eafda.Regrouptable = NewOfcCT_RegroupTable()
				if _ebdfff := d.DecodeElement(_eafda.Regrouptable, &_fegfe); _ebdfff != nil {
					return _ebdfff
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "rules"}:
				_eafda.Rules = NewOfcCT_Rules()
				if _dcbea := d.DecodeElement(_eafda.Rules, &_fegfe); _dcbea != nil {
					return _dcbea
				}
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020OfcShapelayout\u0020\u0025v", _fegfe.Name)
				if _efgea := d.Skip(); _efgea != nil {
					return _efgea
				}
			}
		case _b.EndElement:
			break _feaba
		case _b.CharData:
		}
	}
	return nil
}

type OfcCT_Rules struct {
	R       []*OfcCT_R
	ExtAttr ST_Ext
}

func (_fdcfg ST_StrokeArrowLength) ValidateWithPath(path string) error {
	switch _fdcfg {
	case 0, 1, 2, 3:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fdcfg))
	}
	return nil
}
func (_facef *OfcST_ExtrusionType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dccgg, _bgfaf := d.Token()
	if _bgfaf != nil {
		return _bgfaf
	}
	if _abbfde, _aadbe := _dccgg.(_b.EndElement); _aadbe && _abbfde.Name == start.Name {
		*_facef = 1
		return nil
	}
	if _fcgfdd, _fgecg := _dccgg.(_b.CharData); !_fgecg {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dccgg)
	} else {
		switch string(_fcgfdd) {
		case "":
			*_facef = 0
		case "perspective":
			*_facef = 1
		case "parallel":
			*_facef = 2
		}
	}
	_dccgg, _bgfaf = d.Token()
	if _bgfaf != nil {
		return _bgfaf
	}
	if _cbggd, _cfba := _dccgg.(_b.EndElement); _cfba && _cbggd.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dccgg)
}

// ValidateWithPath validates the AG_StrokeAttributes and its children, prefixing error messages with path
func (_gcaa *AG_StrokeAttributes) ValidateWithPath(path string) error {
	if _afgf := _gcaa.OnAttr.ValidateWithPath(path + "\u002fOnAttr"); _afgf != nil {
		return _afgf
	}
	if _ggf := _gcaa.LinestyleAttr.ValidateWithPath(path + "\u002fLinestyleAttr"); _ggf != nil {
		return _ggf
	}
	if _fff := _gcaa.JoinstyleAttr.ValidateWithPath(path + "\u002fJoinstyleAttr"); _fff != nil {
		return _fff
	}
	if _fbg := _gcaa.EndcapAttr.ValidateWithPath(path + "/EndcapAttr"); _fbg != nil {
		return _fbg
	}
	if _eff := _gcaa.FilltypeAttr.ValidateWithPath(path + "\u002fFilltypeAttr"); _eff != nil {
		return _eff
	}
	if _fggd := _gcaa.ImageaspectAttr.ValidateWithPath(path + "\u002fImageaspectAttr"); _fggd != nil {
		return _fggd
	}
	if _eeec := _gcaa.ImagealignshapeAttr.ValidateWithPath(path + "/ImagealignshapeAttr"); _eeec != nil {
		return _eeec
	}
	if _eagd := _gcaa.StartarrowAttr.ValidateWithPath(path + "\u002fStartarrowAttr"); _eagd != nil {
		return _eagd
	}
	if _aacb := _gcaa.StartarrowwidthAttr.ValidateWithPath(path + "/StartarrowwidthAttr"); _aacb != nil {
		return _aacb
	}
	if _cbb := _gcaa.StartarrowlengthAttr.ValidateWithPath(path + "/StartarrowlengthAttr"); _cbb != nil {
		return _cbb
	}
	if _gae := _gcaa.EndarrowAttr.ValidateWithPath(path + "\u002fEndarrowAttr"); _gae != nil {
		return _gae
	}
	if _eedg := _gcaa.EndarrowwidthAttr.ValidateWithPath(path + "\u002fEndarrowwidthAttr"); _eedg != nil {
		return _eedg
	}
	if _bdddg := _gcaa.EndarrowlengthAttr.ValidateWithPath(path + "\u002fEndarrowlengthAttr"); _bdddg != nil {
		return _bdddg
	}
	if _eagb := _gcaa.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _eagb != nil {
		return _eagb
	}
	if _fbd := _gcaa.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _fbd != nil {
		return _fbd
	}
	return nil
}
func (_egdbe *OfcComplex) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:complex"
	return _egdbe.OfcCT_Complex.MarshalXML(e, start)
}

// Validate validates the Textpath and its children
func (_baga *Textpath) Validate() error { return _baga.ValidateWithPath("Textpath") }

// Validate validates the AG_StrokeAttributes and its children
func (_caf *AG_StrokeAttributes) Validate() error {
	return _caf.ValidateWithPath("AG_StrokeAttributes")
}
func (_abcec *ST_StrokeArrowLength) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cdebc, _gfcca := d.Token()
	if _gfcca != nil {
		return _gfcca
	}
	if _gdbbe, _ggdae := _cdebc.(_b.EndElement); _ggdae && _gdbbe.Name == start.Name {
		*_abcec = 1
		return nil
	}
	if _cbddg, _dgbba := _cdebc.(_b.CharData); !_dgbba {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cdebc)
	} else {
		switch string(_cbddg) {
		case "":
			*_abcec = 0
		case "short":
			*_abcec = 1
		case "medium":
			*_abcec = 2
		case "long":
			*_abcec = 3
		}
	}
	_cdebc, _gfcca = d.Token()
	if _gfcca != nil {
		return _gfcca
	}
	if _beagfd, _bbggf := _cdebc.(_b.EndElement); _bbggf && _beagfd.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cdebc)
}
func (_bcgga ST_EditAs) ValidateWithPath(path string) error {
	switch _bcgga {
	case 0, 1, 2, 3, 4, 5, 6, 7:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bcgga))
	}
	return nil
}
func (_gfbfc *OfcST_InsetMode) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gfbce, _cefgd := d.Token()
	if _cefgd != nil {
		return _cefgd
	}
	if _dedga, _ddgce := _gfbce.(_b.EndElement); _ddgce && _dedga.Name == start.Name {
		*_gfbfc = 1
		return nil
	}
	if _dfaf, _eabgb := _gfbce.(_b.CharData); !_eabgb {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gfbce)
	} else {
		switch string(_dfaf) {
		case "":
			*_gfbfc = 0
		case "auto":
			*_gfbfc = 1
		case "custom":
			*_gfbfc = 2
		}
	}
	_gfbce, _cefgd = d.Token()
	if _cefgd != nil {
		return _cefgd
	}
	if _cegag, _gcfff := _gfbce.(_b.EndElement); _gcfff && _cegag.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gfbce)
}
func NewOfcCT_OLEObject() *OfcCT_OLEObject { _cfbe := &OfcCT_OLEObject{}; return _cfbe }

type OfcDiagram struct{ OfcCT_Diagram }

func (_ecbgd *CT_Stroke) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _beaad := range start.Attr {
		if _beaad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _beaad.Name.Local == "relid" {
			_fbcgg, _egcef := _beaad.Value, error(nil)
			if _egcef != nil {
				return _egcef
			}
			_ecbgd.RelidAttr = &_fbcgg
			continue
		}
		if _beaad.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _beaad.Name.Local == "id" {
			_gedbd, _fbgdb := _beaad.Value, error(nil)
			if _fbgdb != nil {
				return _fbgdb
			}
			_ecbgd.RIdAttr = &_gedbd
			continue
		}
		if _beaad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _beaad.Name.Local == "forcedash" {
			_ecbgd.ForcedashAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _beaad.Name.Local == "title" {
			_cgege, _gfagf := _beaad.Value, error(nil)
			if _gfagf != nil {
				return _gfagf
			}
			_ecbgd.TitleAttr = &_cgege
			continue
		}
		if _beaad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _beaad.Name.Local == "althref" {
			_dcbcc, _cfggg := _beaad.Value, error(nil)
			if _cfggg != nil {
				return _cfggg
			}
			_ecbgd.AlthrefAttr = &_dcbcc
			continue
		}
		if _beaad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _beaad.Name.Local == "href" {
			_agaf, _bgccf := _beaad.Value, error(nil)
			if _bgccf != nil {
				return _bgccf
			}
			_ecbgd.HrefAttr = &_agaf
			continue
		}
		if _beaad.Name.Local == "imagesize" {
			_geeae, _daabb := _beaad.Value, error(nil)
			if _daabb != nil {
				return _daabb
			}
			_ecbgd.ImagesizeAttr = &_geeae
			continue
		}
		if _beaad.Name.Local == "startarrowlength" {
			_ecbgd.StartarrowlengthAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "joinstyle" {
			_ecbgd.JoinstyleAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "endarrow" {
			_ecbgd.EndarrowAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "dashstyle" {
			_bbea, _addgg := _beaad.Value, error(nil)
			if _addgg != nil {
				return _addgg
			}
			_ecbgd.DashstyleAttr = &_bbea
			continue
		}
		if _beaad.Name.Local == "endarrowwidth" {
			_ecbgd.EndarrowwidthAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "src" {
			_bcfdc, _bgeea := _beaad.Value, error(nil)
			if _bgeea != nil {
				return _bgeea
			}
			_ecbgd.SrcAttr = &_bcfdc
			continue
		}
		if _beaad.Name.Local == "endarrowlength" {
			_ecbgd.EndarrowlengthAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "linestyle" {
			_ecbgd.LinestyleAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "opacity" {
			_dbdg, _dcdca := _beaad.Value, error(nil)
			if _dcdca != nil {
				return _dcdca
			}
			_ecbgd.OpacityAttr = &_dbdg
			continue
		}
		if _beaad.Name.Local == "weight" {
			_cdadb, _aegcg := _beaad.Value, error(nil)
			if _aegcg != nil {
				return _aegcg
			}
			_ecbgd.WeightAttr = &_cdadb
			continue
		}
		if _beaad.Name.Local == "id" {
			_eecgb, _fddec := _beaad.Value, error(nil)
			if _fddec != nil {
				return _fddec
			}
			_ecbgd.IdAttr = &_eecgb
			continue
		}
		if _beaad.Name.Local == "miterlimit" {
			_bgbfd, _feccdf := _e.ParseFloat(_beaad.Value, 64)
			if _feccdf != nil {
				return _feccdf
			}
			_ecbgd.MiterlimitAttr = &_bgbfd
			continue
		}
		if _beaad.Name.Local == "color" {
			_gdfe, _febcc := _beaad.Value, error(nil)
			if _febcc != nil {
				return _febcc
			}
			_ecbgd.ColorAttr = &_gdfe
			continue
		}
		if _beaad.Name.Local == "imageaspect" {
			_ecbgd.ImageaspectAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "filltype" {
			_ecbgd.FilltypeAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "on" {
			_ecbgd.OnAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "startarrowwidth" {
			_ecbgd.StartarrowwidthAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "insetpen" {
			_ecbgd.InsetpenAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "imagealignshape" {
			_ecbgd.ImagealignshapeAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "startarrow" {
			_ecbgd.StartarrowAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "endcap" {
			_ecbgd.EndcapAttr.UnmarshalXMLAttr(_beaad)
			continue
		}
		if _beaad.Name.Local == "color2" {
			_dacaf, _acfeg := _beaad.Value, error(nil)
			if _acfeg != nil {
				return _acfeg
			}
			_ecbgd.Color2Attr = &_dacaf
			continue
		}
	}
_beccg:
	for {
		_gdgab, _fegda := d.Token()
		if _fegda != nil {
			return _fegda
		}
		switch _bfgd := _gdgab.(type) {
		case _b.StartElement:
			switch _bfgd.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "left"}:
				_ecbgd.Left = NewOfcLeft()
				if _dgfege := d.DecodeElement(_ecbgd.Left, &_bfgd); _dgfege != nil {
					return _dgfege
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "top"}:
				_ecbgd.Top = NewOfcTop()
				if _dffgc := d.DecodeElement(_ecbgd.Top, &_bfgd); _dffgc != nil {
					return _dffgc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "right"}:
				_ecbgd.Right = NewOfcRight()
				if _addbc := d.DecodeElement(_ecbgd.Right, &_bfgd); _addbc != nil {
					return _addbc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "bottom"}:
				_ecbgd.Bottom = NewOfcBottom()
				if _gdede := d.DecodeElement(_ecbgd.Bottom, &_bfgd); _gdede != nil {
					return _gdede
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "column"}:
				_ecbgd.Column = NewOfcColumn()
				if _gggaab := d.DecodeElement(_ecbgd.Column, &_bfgd); _gggaab != nil {
					return _gggaab
				}
			default:
				_ba.Log("skipping\u0020unsupported\u0020element on CT_Stroke \u0025v", _bfgd.Name)
				if _eddda := d.Skip(); _eddda != nil {
					return _eddda
				}
			}
		case _b.EndElement:
			break _beccg
		case _b.CharData:
		}
	}
	return nil
}
func (_gfae ST_StrokeEndCap) Validate() error { return _gfae.ValidateWithPath("") }

// Validate validates the OfcCT_Fill and its children
func (_ccgdd *OfcCT_Fill) Validate() error { return _ccgdd.ValidateWithPath("OfcCT_Fill") }
func (_dfgee OfcST_ExtrusionPlane) ValidateWithPath(path string) error {
	switch _dfgee {
	case 0, 1, 2, 3:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dfgee))
	}
	return nil
}
func NewCT_Background() *CT_Background { _fab := &CT_Background{}; return _fab }

// Validate validates the CT_Arc and its children
func (_acbc *CT_Arc) Validate() error { return _acbc.ValidateWithPath("CT_Arc") }
func (_fccacd *OfcCT_ColorMru) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dcaee := range start.Attr {
		if _dcaee.Name.Local == "colors" {
			_fbfcd, _dfddga := _dcaee.Value, error(nil)
			if _dfddga != nil {
				return _dfddga
			}
			_fccacd.ColorsAttr = &_fbfcd
			continue
		}
		if _dcaee.Name.Local == "ext" {
			_fccacd.ExtAttr.UnmarshalXMLAttr(_dcaee)
			continue
		}
	}
	for {
		_bgec, _cbebe := d.Token()
		if _cbebe != nil {
			return _f.Errorf("parsing\u0020OfcCT_ColorMru:\u0020\u0025s", _cbebe)
		}
		if _gcbb, _cfabb := _bgec.(_b.EndElement); _cfabb && _gcbb.Name == start.Name {
			break
		}
	}
	return nil
}
func NewShape() *Shape { _ceabe := &Shape{}; _ceabe.CT_Shape = *NewCT_Shape(); return _ceabe }

// ValidateWithPath validates the OfcCT_StrokeChild and its children, prefixing error messages with path
func (_ceccc *OfcCT_StrokeChild) ValidateWithPath(path string) error {
	if _ggad := _ceccc.OnAttr.ValidateWithPath(path + "\u002fOnAttr"); _ggad != nil {
		return _ggad
	}
	if _gabef := _ceccc.LinestyleAttr.ValidateWithPath(path + "\u002fLinestyleAttr"); _gabef != nil {
		return _gabef
	}
	if _badd := _ceccc.JoinstyleAttr.ValidateWithPath(path + "\u002fJoinstyleAttr"); _badd != nil {
		return _badd
	}
	if _feedc := _ceccc.EndcapAttr.ValidateWithPath(path + "/EndcapAttr"); _feedc != nil {
		return _feedc
	}
	if _acfea := _ceccc.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _acfea != nil {
		return _acfea
	}
	if _abgdc := _ceccc.FilltypeAttr.ValidateWithPath(path + "\u002fFilltypeAttr"); _abgdc != nil {
		return _abgdc
	}
	if _edbaa := _ceccc.ImageaspectAttr.ValidateWithPath(path + "\u002fImageaspectAttr"); _edbaa != nil {
		return _edbaa
	}
	if _dgdec := _ceccc.ImagealignshapeAttr.ValidateWithPath(path + "/ImagealignshapeAttr"); _dgdec != nil {
		return _dgdec
	}
	if _bbedg := _ceccc.StartarrowAttr.ValidateWithPath(path + "\u002fStartarrowAttr"); _bbedg != nil {
		return _bbedg
	}
	if _bfgaf := _ceccc.StartarrowwidthAttr.ValidateWithPath(path + "/StartarrowwidthAttr"); _bfgaf != nil {
		return _bfgaf
	}
	if _fdcgg := _ceccc.StartarrowlengthAttr.ValidateWithPath(path + "/StartarrowlengthAttr"); _fdcgg != nil {
		return _fdcgg
	}
	if _bbeeg := _ceccc.EndarrowAttr.ValidateWithPath(path + "\u002fEndarrowAttr"); _bbeeg != nil {
		return _bbeeg
	}
	if _cggcb := _ceccc.EndarrowwidthAttr.ValidateWithPath(path + "\u002fEndarrowwidthAttr"); _cggcb != nil {
		return _cggcb
	}
	if _afdbf := _ceccc.EndarrowlengthAttr.ValidateWithPath(path + "\u002fEndarrowlengthAttr"); _afdbf != nil {
		return _afdbf
	}
	if _bbcdeb := _ceccc.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _bbcdeb != nil {
		return _bbcdeb
	}
	if _fgacd := _ceccc.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _fgacd != nil {
		return _fgacd
	}
	return nil
}

// Validate validates the OfcCT_Diagram and its children
func (_feec *OfcCT_Diagram) Validate() error { return _feec.ValidateWithPath("OfcCT_Diagram") }

type ST_StrokeArrowLength byte

// ValidateWithPath validates the OfcShapelayout and its children, prefixing error messages with path
func (_becd *OfcShapelayout) ValidateWithPath(path string) error {
	if _bcbag := _becd.OfcCT_ShapeLayout.ValidateWithPath(path); _bcbag != nil {
		return _bcbag
	}
	return nil
}
func (_cgcac *OfcST_RType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_acfcd, _dfedbd := d.Token()
	if _dfedbd != nil {
		return _dfedbd
	}
	if _cgdac, _bgcb := _acfcd.(_b.EndElement); _bgcb && _cgdac.Name == start.Name {
		*_cgcac = 1
		return nil
	}
	if _fdfaa, _bfccc := _acfcd.(_b.CharData); !_bfccc {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _acfcd)
	} else {
		switch string(_fdfaa) {
		case "":
			*_cgcac = 0
		case "arc":
			*_cgcac = 1
		case "callout":
			*_cgcac = 2
		case "connector":
			*_cgcac = 3
		case "align":
			*_cgcac = 4
		}
	}
	_acfcd, _dfedbd = d.Token()
	if _dfedbd != nil {
		return _dfedbd
	}
	if _beda, _ecgee := _acfcd.(_b.EndElement); _ecgee && _beda.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _acfcd)
}

// ValidateWithPath validates the OfcCT_ColorMenu and its children, prefixing error messages with path
func (_egeab *OfcCT_ColorMenu) ValidateWithPath(path string) error {
	if _bgbfc := _egeab.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _bgbfc != nil {
		return _bgbfc
	}
	return nil
}
func (_beefg *Polyline) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _beefg.CT_PolyLine.MarshalXML(e, start)
}

type Stroke struct{ CT_Stroke }
type Textpath struct{ CT_TextPath }

// ValidateWithPath validates the CT_PolyLine and its children, prefixing error messages with path
func (_eaga *CT_PolyLine) ValidateWithPath(path string) error {
	for _adbb, _beggg := range _eaga.Ink {
		if _cdbe := _beggg.ValidateWithPath(_f.Sprintf("\u0025s\u002fInk\u005b\u0025d\u005d", path, _adbb)); _cdbe != nil {
			return _cdbe
		}
	}
	for _afage, _dddea := range _eaga.EG_ShapeElements {
		if _gfbfa := _dddea.ValidateWithPath(_f.Sprintf("\u0025s\u002fEG_ShapeElements\u005b\u0025d\u005d", path, _afage)); _gfbfa != nil {
			return _gfbfa
		}
	}
	if _fbacfg := _eaga.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _fbacfg != nil {
		return _fbacfg
	}
	if _adaca := _eaga.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _adaca != nil {
		return _adaca
	}
	if _fadbc := _eaga.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _fadbc != nil {
		return _fadbc
	}
	if _egea := _eaga.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _egea != nil {
		return _egea
	}
	if _eecc := _eaga.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _eecc != nil {
		return _eecc
	}
	if _aedfg := _eaga.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _aedfg != nil {
		return _aedfg
	}
	if _fdfab := _eaga.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _fdfab != nil {
		return _fdfab
	}
	if _badeg := _eaga.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _badeg != nil {
		return _badeg
	}
	if _bddea := _eaga.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _bddea != nil {
		return _bddea
	}
	if _efebb := _eaga.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _efebb != nil {
		return _efebb
	}
	if _dcgdc := _eaga.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _dcgdc != nil {
		return _dcgdc
	}
	if _ggcf := _eaga.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _ggcf != nil {
		return _ggcf
	}
	if _daeeb := _eaga.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _daeeb != nil {
		return _daeeb
	}
	if _gbcf := _eaga.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _gbcf != nil {
		return _gbcf
	}
	if _ecadf := _eaga.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _ecadf != nil {
		return _ecadf
	}
	if _begc := _eaga.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _begc != nil {
		return _begc
	}
	if _fdfd := _eaga.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _fdfd != nil {
		return _fdfd
	}
	if _bceg := _eaga.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _bceg != nil {
		return _bceg
	}
	if _feffd := _eaga.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _feffd != nil {
		return _feffd
	}
	if _agab := _eaga.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _agab != nil {
		return _agab
	}
	if _bbgf := _eaga.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _bbgf != nil {
		return _bbgf
	}
	if _eeedg := _eaga.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _eeedg != nil {
		return _eeedg
	}
	if _gfgc := _eaga.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _gfgc != nil {
		return _gfgc
	}
	if _cgfea := _eaga.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _cgfea != nil {
		return _cgfea
	}
	if _ceaee := _eaga.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _ceaee != nil {
		return _ceaee
	}
	if _gbca := _eaga.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _gbca != nil {
		return _gbca
	}
	if _egeae := _eaga.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _egeae != nil {
		return _egeae
	}
	if _gdebc := _eaga.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _gdebc != nil {
		return _gdebc
	}
	if _fdeeg := _eaga.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _fdeeg != nil {
		return _fdeeg
	}
	return nil
}

type OfcCT_IdMap struct {
	DataAttr *string
	ExtAttr  ST_Ext
}
type AG_AllShapeAttributes struct {
	OpacityAttr        *string
	StrokedAttr        _eb.ST_TrueFalse
	StrokecolorAttr    *string
	StrokeweightAttr   *string
	InsetpenAttr       _eb.ST_TrueFalse
	ChromakeyAttr      *string
	FilledAttr         _eb.ST_TrueFalse
	FillcolorAttr      *string
	SptAttr            *float32
	ConnectortypeAttr  OfcST_ConnectorType
	BwmodeAttr         OfcST_BWMode
	BwpureAttr         OfcST_BWMode
	BwnormalAttr       OfcST_BWMode
	ForcedashAttr      _eb.ST_TrueFalse
	OleiconAttr        _eb.ST_TrueFalse
	OleAttr            _eb.ST_TrueFalseBlank
	PreferrelativeAttr _eb.ST_TrueFalse
	CliptowrapAttr     _eb.ST_TrueFalse
	ClipAttr           _eb.ST_TrueFalse
}

// ValidateWithPath validates the OfcShapedefaults and its children, prefixing error messages with path
func (_ecdbdc *OfcShapedefaults) ValidateWithPath(path string) error {
	if _cccdg := _ecdbdc.OfcCT_ShapeDefaults.ValidateWithPath(path); _cccdg != nil {
		return _cccdg
	}
	return nil
}
func NewOfcComplex() *OfcComplex {
	_fdga := &OfcComplex{}
	_fdga.OfcCT_Complex = *NewOfcCT_Complex()
	return _fdga
}
func (_cadbg *OfcComplex) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cadbg.OfcCT_Complex = *NewOfcCT_Complex()
	for _, _gaeea := range start.Attr {
		if _gaeea.Name.Local == "ext" {
			_cadbg.ExtAttr.UnmarshalXMLAttr(_gaeea)
			continue
		}
	}
	for {
		_fafbgd, _ggaad := d.Token()
		if _ggaad != nil {
			return _f.Errorf("parsing\u0020OfcComplex:\u0020%s", _ggaad)
		}
		if _gaeb, _ffee := _fafbgd.(_b.EndElement); _ffee && _gaeb.Name == start.Name {
			break
		}
	}
	return nil
}

type OfcLock struct{ OfcCT_Lock }

// ValidateWithPath validates the Shape and its children, prefixing error messages with path
func (_ebgcfg *Shape) ValidateWithPath(path string) error {
	if _ggda := _ebgcfg.CT_Shape.ValidateWithPath(path); _ggda != nil {
		return _ggda
	}
	return nil
}
func (_egeed *OfcST_ExtrusionRender) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_caeaf, _cbafbg := d.Token()
	if _cbafbg != nil {
		return _cbafbg
	}
	if _fbabab, _gaeff := _caeaf.(_b.EndElement); _gaeff && _fbabab.Name == start.Name {
		*_egeed = 1
		return nil
	}
	if _eeaga, _abfda := _caeaf.(_b.CharData); !_abfda {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _caeaf)
	} else {
		switch string(_eeaga) {
		case "":
			*_egeed = 0
		case "solid":
			*_egeed = 1
		case "wireFrame":
			*_egeed = 2
		case "boundingCube":
			*_egeed = 3
		}
	}
	_caeaf, _cbafbg = d.Token()
	if _cbafbg != nil {
		return _cbafbg
	}
	if _gadce, _cgga := _caeaf.(_b.EndElement); _cgga && _gadce.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _caeaf)
}

type ST_StrokeArrowType byte

func (_aabdf ST_StrokeArrowType) String() string {
	switch _aabdf {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "block"
	case 3:
		return "classic"
	case 4:
		return "oval"
	case 5:
		return "diamond"
	case 6:
		return "open"
	}
	return ""
}

const (
	ST_StrokeJoinStyleUnset ST_StrokeJoinStyle = 0
	ST_StrokeJoinStyleRound ST_StrokeJoinStyle = 1
	ST_StrokeJoinStyleBevel ST_StrokeJoinStyle = 2
	ST_StrokeJoinStyleMiter ST_StrokeJoinStyle = 3
)

type OfcShapelayout struct{ OfcCT_ShapeLayout }

// ValidateWithPath validates the Formulas and its children, prefixing error messages with path
func (_dbedfe *Formulas) ValidateWithPath(path string) error {
	if _afegb := _dbedfe.CT_Formulas.ValidateWithPath(path); _afegb != nil {
		return _afegb
	}
	return nil
}
func (_fccc OfcST_ExtrusionPlane) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bebebd := _b.Attr{}
	_bebebd.Name = name
	switch _fccc {
	case OfcST_ExtrusionPlaneUnset:
		_bebebd.Value = ""
	case OfcST_ExtrusionPlaneXY:
		_bebebd.Value = "XY"
	case OfcST_ExtrusionPlaneZX:
		_bebebd.Value = "ZX"
	case OfcST_ExtrusionPlaneYZ:
		_bebebd.Value = "YZ"
	}
	return _bebebd, nil
}

// Validate validates the OfcLock and its children
func (_eecbd *OfcLock) Validate() error { return _eecbd.ValidateWithPath("OfcLock") }
func (_cdacbf *Stroke) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cdacbf.CT_Stroke = *NewCT_Stroke()
	for _, _caefc := range start.Attr {
		if _caefc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caefc.Name.Local == "relid" {
			_bbfca, _bacef := _caefc.Value, error(nil)
			if _bacef != nil {
				return _bacef
			}
			_cdacbf.RelidAttr = &_bbfca
			continue
		}
		if _caefc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _caefc.Name.Local == "id" {
			_gafadd, _cdbfg := _caefc.Value, error(nil)
			if _cdbfg != nil {
				return _cdbfg
			}
			_cdacbf.RIdAttr = &_gafadd
			continue
		}
		if _caefc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caefc.Name.Local == "forcedash" {
			_cdacbf.ForcedashAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caefc.Name.Local == "title" {
			_bfgdb, _dabda := _caefc.Value, error(nil)
			if _dabda != nil {
				return _dabda
			}
			_cdacbf.TitleAttr = &_bfgdb
			continue
		}
		if _caefc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caefc.Name.Local == "althref" {
			_egbg, _gecaad := _caefc.Value, error(nil)
			if _gecaad != nil {
				return _gecaad
			}
			_cdacbf.AlthrefAttr = &_egbg
			continue
		}
		if _caefc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caefc.Name.Local == "href" {
			_dcfce, _cfdgf := _caefc.Value, error(nil)
			if _cfdgf != nil {
				return _cfdgf
			}
			_cdacbf.HrefAttr = &_dcfce
			continue
		}
		if _caefc.Name.Local == "imagesize" {
			_eedee, _ggcdcf := _caefc.Value, error(nil)
			if _ggcdcf != nil {
				return _ggcdcf
			}
			_cdacbf.ImagesizeAttr = &_eedee
			continue
		}
		if _caefc.Name.Local == "startarrowlength" {
			_cdacbf.StartarrowlengthAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "joinstyle" {
			_cdacbf.JoinstyleAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "endarrow" {
			_cdacbf.EndarrowAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "dashstyle" {
			_ggcaea, _fceab := _caefc.Value, error(nil)
			if _fceab != nil {
				return _fceab
			}
			_cdacbf.DashstyleAttr = &_ggcaea
			continue
		}
		if _caefc.Name.Local == "endarrowwidth" {
			_cdacbf.EndarrowwidthAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "src" {
			_bbddf, _gadbg := _caefc.Value, error(nil)
			if _gadbg != nil {
				return _gadbg
			}
			_cdacbf.SrcAttr = &_bbddf
			continue
		}
		if _caefc.Name.Local == "endarrowlength" {
			_cdacbf.EndarrowlengthAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "linestyle" {
			_cdacbf.LinestyleAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "opacity" {
			_cegga, _efdacc := _caefc.Value, error(nil)
			if _efdacc != nil {
				return _efdacc
			}
			_cdacbf.OpacityAttr = &_cegga
			continue
		}
		if _caefc.Name.Local == "weight" {
			_cccaf, _ffgda := _caefc.Value, error(nil)
			if _ffgda != nil {
				return _ffgda
			}
			_cdacbf.WeightAttr = &_cccaf
			continue
		}
		if _caefc.Name.Local == "id" {
			_ageed, _ceda := _caefc.Value, error(nil)
			if _ceda != nil {
				return _ceda
			}
			_cdacbf.IdAttr = &_ageed
			continue
		}
		if _caefc.Name.Local == "miterlimit" {
			_gfdbe, _afgce := _e.ParseFloat(_caefc.Value, 64)
			if _afgce != nil {
				return _afgce
			}
			_cdacbf.MiterlimitAttr = &_gfdbe
			continue
		}
		if _caefc.Name.Local == "color" {
			_eaeda, _cggcdf := _caefc.Value, error(nil)
			if _cggcdf != nil {
				return _cggcdf
			}
			_cdacbf.ColorAttr = &_eaeda
			continue
		}
		if _caefc.Name.Local == "imageaspect" {
			_cdacbf.ImageaspectAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "filltype" {
			_cdacbf.FilltypeAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "on" {
			_cdacbf.OnAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "startarrowwidth" {
			_cdacbf.StartarrowwidthAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "insetpen" {
			_cdacbf.InsetpenAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "imagealignshape" {
			_cdacbf.ImagealignshapeAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "startarrow" {
			_cdacbf.StartarrowAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "endcap" {
			_cdacbf.EndcapAttr.UnmarshalXMLAttr(_caefc)
			continue
		}
		if _caefc.Name.Local == "color2" {
			_dcbag, _dgcbed := _caefc.Value, error(nil)
			if _dgcbed != nil {
				return _dgcbed
			}
			_cdacbf.Color2Attr = &_dcbag
			continue
		}
	}
_fafdfd:
	for {
		_gbbdd, _acdff := d.Token()
		if _acdff != nil {
			return _acdff
		}
		switch _dffbc := _gbbdd.(type) {
		case _b.StartElement:
			switch _dffbc.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "left"}:
				_cdacbf.Left = NewOfcLeft()
				if _dgffb := d.DecodeElement(_cdacbf.Left, &_dffbc); _dgffb != nil {
					return _dgffb
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "top"}:
				_cdacbf.Top = NewOfcTop()
				if _eefc := d.DecodeElement(_cdacbf.Top, &_dffbc); _eefc != nil {
					return _eefc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "right"}:
				_cdacbf.Right = NewOfcRight()
				if _eecdgg := d.DecodeElement(_cdacbf.Right, &_dffbc); _eecdgg != nil {
					return _eecdgg
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "bottom"}:
				_cdacbf.Bottom = NewOfcBottom()
				if _dbaace := d.DecodeElement(_cdacbf.Bottom, &_dffbc); _dbaace != nil {
					return _dbaace
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "column"}:
				_cdacbf.Column = NewOfcColumn()
				if _ccgfc := d.DecodeElement(_cdacbf.Column, &_dffbc); _ccgfc != nil {
					return _ccgfc
				}
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Stroke\u0020\u0025v", _dffbc.Name)
				if _cbgbeb := d.Skip(); _cbgbeb != nil {
					return _cbgbeb
				}
			}
		case _b.EndElement:
			break _fafdfd
		case _b.CharData:
		}
	}
	return nil
}

type CT_Shadow struct {
	OnAttr       _eb.ST_TrueFalse
	TypeAttr     ST_ShadowType
	ObscuredAttr _eb.ST_TrueFalse
	ColorAttr    *string
	OpacityAttr  *string
	OffsetAttr   *string
	Color2Attr   *string
	Offset2Attr  *string
	OriginAttr   *string
	MatrixAttr   *string
	IdAttr       *string
}
type OfcST_RType byte

const (
	OfcST_OLEDrawAspectUnset   OfcST_OLEDrawAspect = 0
	OfcST_OLEDrawAspectContent OfcST_OLEDrawAspect = 1
	OfcST_OLEDrawAspectIcon    OfcST_OLEDrawAspect = 2
)

// ValidateWithPath validates the Handles and its children, prefixing error messages with path
func (_gdbdd *Handles) ValidateWithPath(path string) error {
	if _bfbc := _gdbdd.CT_Handles.ValidateWithPath(path); _bfbc != nil {
		return _bfbc
	}
	return nil
}

type OfcCT_Skew struct {
	IdAttr     *string
	OnAttr     _eb.ST_TrueFalse
	OffsetAttr *string
	OriginAttr *string
	MatrixAttr *string
	ExtAttr    ST_Ext
}
type ST_ImageAspect byte

// Validate validates the OfcColumn and its children
func (_aagg *OfcColumn) Validate() error { return _aagg.ValidateWithPath("OfcColumn") }

type CT_PolyLine struct {
	PointsAttr            *string
	Ink                   []*OfcInk
	EG_ShapeElements      []*EG_ShapeElements
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
	OpacityAttr           *string
	StrokedAttr           _eb.ST_TrueFalse
	StrokecolorAttr       *string
	StrokeweightAttr      *string
	InsetpenAttr          _eb.ST_TrueFalse
	ChromakeyAttr         *string
	FilledAttr            _eb.ST_TrueFalse
	FillcolorAttr         *string
	SptAttr               *float32
	ConnectortypeAttr     OfcST_ConnectorType
	BwmodeAttr            OfcST_BWMode
	BwpureAttr            OfcST_BWMode
	BwnormalAttr          OfcST_BWMode
	ForcedashAttr         _eb.ST_TrueFalse
	OleiconAttr           _eb.ST_TrueFalse
	OleAttr               _eb.ST_TrueFalseBlank
	PreferrelativeAttr    _eb.ST_TrueFalse
	CliptowrapAttr        _eb.ST_TrueFalse
	ClipAttr              _eb.ST_TrueFalse
}

// Validate validates the OfcCT_SignatureLine and its children
func (_abfbca *OfcCT_SignatureLine) Validate() error {
	return _abfbca.ValidateWithPath("OfcCT_SignatureLine")
}

type ST_StrokeJoinStyle byte

func NewAG_Path() *AG_Path             { _cedc := &AG_Path{}; return _cedc }
func NewOfcCT_Callout() *OfcCT_Callout { _aeceb := &OfcCT_Callout{}; return _aeceb }

// ValidateWithPath validates the OfcLock and its children, prefixing error messages with path
func (_eagg *OfcLock) ValidateWithPath(path string) error {
	if _cgbag := _eagg.OfcCT_Lock.ValidateWithPath(path); _cgbag != nil {
		return _cgbag
	}
	return nil
}
func (_fa *AG_AllCoreAttributes) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _fa.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_fa.HrefAttr)})
	}
	if _fa.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_fa.TargetAttr)})
	}
	if _fa.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_fa.ClassAttr)})
	}
	if _fa.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_fa.TitleAttr)})
	}
	if _fa.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_fa.AltAttr)})
	}
	if _fa.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_fa.CoordsizeAttr)})
	}
	if _fa.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_fa.CoordoriginAttr)})
	}
	if _fa.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_fa.WrapcoordsAttr)})
	}
	if _fa.PrintAttr != _eb.ST_TrueFalseUnset {
		_cg, _gc := _fa.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _gc != nil {
			return _gc
		}
		start.Attr = append(start.Attr, _cg)
	}
	if _fa.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_fa.IdAttr)})
	}
	if _fa.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_fa.StyleAttr)})
	}
	if _fa.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_fa.SpidAttr)})
	}
	if _fa.OnedAttr != _eb.ST_TrueFalseUnset {
		_fd, _be := _fa.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _be != nil {
			return _be
		}
		start.Attr = append(start.Attr, _fd)
	}
	if _fa.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_fa.RegroupidAttr)})
	}
	if _fa.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_gfb, _bdc := _fa.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _bdc != nil {
			return _bdc
		}
		start.Attr = append(start.Attr, _gfb)
	}
	if _fa.ButtonAttr != _eb.ST_TrueFalseUnset {
		_gb, _fdd := _fa.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _fdd != nil {
			return _fdd
		}
		start.Attr = append(start.Attr, _gb)
	}
	if _fa.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_geb, _ee := _fa.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _ee != nil {
			return _ee
		}
		start.Attr = append(start.Attr, _geb)
	}
	if _fa.BulletAttr != _eb.ST_TrueFalseUnset {
		_cb, _ed := _fa.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _ed != nil {
			return _ed
		}
		start.Attr = append(start.Attr, _cb)
	}
	if _fa.HrAttr != _eb.ST_TrueFalseUnset {
		_ec, _bdb := _fa.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _bdb != nil {
			return _bdb
		}
		start.Attr = append(start.Attr, _ec)
	}
	if _fa.HrstdAttr != _eb.ST_TrueFalseUnset {
		_cf, _ad := _fa.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _ad != nil {
			return _ad
		}
		start.Attr = append(start.Attr, _cf)
	}
	if _fa.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_cff, _fdda := _fa.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _fdda != nil {
			return _fdda
		}
		start.Attr = append(start.Attr, _cff)
	}
	if _fa.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_fa.HrpctAttr)})
	}
	if _fa.HralignAttr != OfcST_HrAlignUnset {
		_gcc, _bbe := _fa.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _bbe != nil {
			return _bbe
		}
		start.Attr = append(start.Attr, _gcc)
	}
	if _fa.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_cffd, _bfd := _fa.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _bfd != nil {
			return _bfd
		}
		start.Attr = append(start.Attr, _cffd)
	}
	if _fa.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_fe, _ebd := _fa.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _ebd != nil {
			return _ebd
		}
		start.Attr = append(start.Attr, _fe)
	}
	if _fa.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_ef, _fae := _fa.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _fae != nil {
			return _fae
		}
		start.Attr = append(start.Attr, _ef)
	}
	if _fa.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_fa.BordertopcolorAttr)})
	}
	if _fa.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_fa.BorderleftcolorAttr)})
	}
	if _fa.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_fa.BorderbottomcolorAttr)})
	}
	if _fa.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_fa.BorderrightcolorAttr)})
	}
	if _fa.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_cge, _eeb := _fa.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _eeb != nil {
			return _eeb
		}
		start.Attr = append(start.Attr, _cge)
	}
	if _fa.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_fa.DgmnodekindAttr)})
	}
	if _fa.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_efa, _bfe := _fa.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _bfe != nil {
			return _bfe
		}
		start.Attr = append(start.Attr, _efa)
	}
	if _fa.InsetmodeAttr != OfcST_InsetModeUnset {
		_bdd, _ae := _fa.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _ae != nil {
			return _ae
		}
		start.Attr = append(start.Attr, _bdd)
	}
	return nil
}
func NewRoundrect() *Roundrect {
	_fabff := &Roundrect{}
	_fabff.CT_RoundRect = *NewCT_RoundRect()
	return _fabff
}

const (
	ST_EditAsUnset    ST_EditAs = 0
	ST_EditAsCanvas   ST_EditAs = 1
	ST_EditAsOrgchart ST_EditAs = 2
	ST_EditAsRadial   ST_EditAs = 3
	ST_EditAsCycle    ST_EditAs = 4
	ST_EditAsStacked  ST_EditAs = 5
	ST_EditAsVenn     ST_EditAs = 6
	ST_EditAsBullseye ST_EditAs = 7
)

func (_gddbgd *OfcST_DiagramLayout) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_adge, _defgg := d.Token()
	if _defgg != nil {
		return _defgg
	}
	if _dbcfdb, _daaae := _adge.(_b.EndElement); _daaae && _dbcfdb.Name == start.Name {
		*_gddbgd = 1
		return nil
	}
	if _fcdga, _ddbad := _adge.(_b.CharData); !_ddbad {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _adge)
	} else {
		switch string(_fcdga) {
		case "":
			*_gddbgd = 0
		case "0":
			*_gddbgd = 1
		case "1":
			*_gddbgd = 2
		case "2":
			*_gddbgd = 3
		case "3":
			*_gddbgd = 4
		}
	}
	_adge, _defgg = d.Token()
	if _defgg != nil {
		return _defgg
	}
	if _bbeca, _ggeee := _adge.(_b.EndElement); _ggeee && _bbeca.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _adge)
}
func (_faaef *ST_StrokeJoinStyle) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_faaef = 0
	case "round":
		*_faaef = 1
	case "bevel":
		*_faaef = 2
	case "miter":
		*_faaef = 3
	}
	return nil
}
func (_agccg *CT_ImageData) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _agccg.EmbosscolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "embosscolor"}, Value: _f.Sprintf("\u0025v", *_agccg.EmbosscolorAttr)})
	}
	if _agccg.RecolortargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "recolortarget"}, Value: _f.Sprintf("\u0025v", *_agccg.RecolortargetAttr)})
	}
	if _agccg.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:href"}, Value: _f.Sprintf("\u0025v", *_agccg.HrefAttr)})
	}
	if _agccg.AlthrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:althref"}, Value: _f.Sprintf("\u0025v", *_agccg.AlthrefAttr)})
	}
	if _agccg.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:title"}, Value: _f.Sprintf("\u0025v", *_agccg.TitleAttr)})
	}
	if _agccg.OleidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:oleid"}, Value: _f.Sprintf("\u0025v", *_agccg.OleidAttr)})
	}
	if _agccg.DetectmouseclickAttr != _eb.ST_TrueFalseUnset {
		_effbe, _geedd := _agccg.DetectmouseclickAttr.MarshalXMLAttr(_b.Name{Local: "o:detectmouseclick"})
		if _geedd != nil {
			return _geedd
		}
		start.Attr = append(start.Attr, _effbe)
	}
	if _agccg.MovieAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:movie"}, Value: _f.Sprintf("\u0025v", *_agccg.MovieAttr)})
	}
	if _agccg.RelidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:relid"}, Value: _f.Sprintf("\u0025v", *_agccg.RelidAttr)})
	}
	if _agccg.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:id"}, Value: _f.Sprintf("\u0025v", *_agccg.IdAttr)})
	}
	if _agccg.PictAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:pict"}, Value: _f.Sprintf("\u0025v", *_agccg.PictAttr)})
	}
	if _agccg.RHrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "r:href"}, Value: _f.Sprintf("\u0025v", *_agccg.RHrefAttr)})
	}
	if _agccg.SIdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_agccg.SIdAttr)})
	}
	if _agccg.SrcAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "src"}, Value: _f.Sprintf("\u0025v", *_agccg.SrcAttr)})
	}
	if _agccg.CropleftAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cropleft"}, Value: _f.Sprintf("\u0025v", *_agccg.CropleftAttr)})
	}
	if _agccg.CroptopAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "croptop"}, Value: _f.Sprintf("\u0025v", *_agccg.CroptopAttr)})
	}
	if _agccg.CroprightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cropright"}, Value: _f.Sprintf("\u0025v", *_agccg.CroprightAttr)})
	}
	if _agccg.CropbottomAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "cropbottom"}, Value: _f.Sprintf("\u0025v", *_agccg.CropbottomAttr)})
	}
	if _agccg.GainAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "gain"}, Value: _f.Sprintf("\u0025v", *_agccg.GainAttr)})
	}
	if _agccg.BlacklevelAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "blacklevel"}, Value: _f.Sprintf("\u0025v", *_agccg.BlacklevelAttr)})
	}
	if _agccg.GammaAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "gamma"}, Value: _f.Sprintf("\u0025v", *_agccg.GammaAttr)})
	}
	if _agccg.GrayscaleAttr != _eb.ST_TrueFalseUnset {
		_cdad, _bgag := _agccg.GrayscaleAttr.MarshalXMLAttr(_b.Name{Local: "grayscale"})
		if _bgag != nil {
			return _bgag
		}
		start.Attr = append(start.Attr, _cdad)
	}
	if _agccg.BilevelAttr != _eb.ST_TrueFalseUnset {
		_abcc, _ceea := _agccg.BilevelAttr.MarshalXMLAttr(_b.Name{Local: "bilevel"})
		if _ceea != nil {
			return _ceea
		}
		start.Attr = append(start.Attr, _abcc)
	}
	if _agccg.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_agccg.ChromakeyAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type OfcCT_ClipPath struct{ VAttr string }

func (_adfbdd *OfcEquationxml) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_adfbdd.OfcCT_EquationXml = *NewOfcCT_EquationXml()
	for _, _gecab := range start.Attr {
		if _gecab.Name.Local == "contentType" {
			_afgec, _gccgff := _gecab.Value, error(nil)
			if _gccgff != nil {
				return _gccgff
			}
			_adfbdd.ContentTypeAttr = &_afgec
			continue
		}
	}
_aaecff:
	for {
		_cabed, _cgbad := d.Token()
		if _cgbad != nil {
			return _cgbad
		}
		switch _ddfef := _cabed.(type) {
		case _b.StartElement:
			switch _ddfef.Name {
			default:
				if _cbbagc, _abfa := _ba.CreateElement(_ddfef); _abfa != nil {
					return _abfa
				} else {
					if _ggcbc := d.DecodeElement(_cbbagc, &_ddfef); _ggcbc != nil {
						return _ggcbc
					}
					_adfbdd.Any = _cbbagc
				}
			}
		case _b.EndElement:
			break _aaecff
		case _b.CharData:
		}
	}
	return nil
}
func (_gfce *EG_ShapeElements) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_gfbfaa:
	for {
		_dbccd, _cfgf := d.Token()
		if _cfgf != nil {
			return _cfgf
		}
		switch _fcbgf := _dbccd.(type) {
		case _b.StartElement:
			switch _fcbgf.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_gfce.Path = NewPath()
				if _eccac := d.DecodeElement(_gfce.Path, &_fcbgf); _eccac != nil {
					return _eccac
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_gfce.Formulas = NewFormulas()
				if _dbdef := d.DecodeElement(_gfce.Formulas, &_fcbgf); _dbdef != nil {
					return _dbdef
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_gfce.Handles = NewHandles()
				if _cgbaf := d.DecodeElement(_gfce.Handles, &_fcbgf); _cgbaf != nil {
					return _cgbaf
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_gfce.Fill = NewFill()
				if _gebaa := d.DecodeElement(_gfce.Fill, &_fcbgf); _gebaa != nil {
					return _gebaa
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_gfce.Stroke = NewStroke()
				if _cfdeb := d.DecodeElement(_gfce.Stroke, &_fcbgf); _cfdeb != nil {
					return _cfdeb
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_gfce.Shadow = NewShadow()
				if _agggd := d.DecodeElement(_gfce.Shadow, &_fcbgf); _agggd != nil {
					return _agggd
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_gfce.Textbox = NewTextbox()
				if _bgagd := d.DecodeElement(_gfce.Textbox, &_fcbgf); _bgagd != nil {
					return _bgagd
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_gfce.Textpath = NewTextpath()
				if _fdcb := d.DecodeElement(_gfce.Textpath, &_fcbgf); _fdcb != nil {
					return _fdcb
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_gfce.Imagedata = NewImagedata()
				if _aaddd := d.DecodeElement(_gfce.Imagedata, &_fcbgf); _aaddd != nil {
					return _aaddd
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_gfce.Skew = NewOfcSkew()
				if _fdcbg := d.DecodeElement(_gfce.Skew, &_fcbgf); _fdcbg != nil {
					return _fdcbg
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_gfce.Extrusion = NewOfcExtrusion()
				if _bfbe := d.DecodeElement(_gfce.Extrusion, &_fcbgf); _bfbe != nil {
					return _bfbe
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_gfce.Callout = NewOfcCallout()
				if _dgdbe := d.DecodeElement(_gfce.Callout, &_fcbgf); _dgdbe != nil {
					return _dgdbe
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_gfce.Lock = NewOfcLock()
				if _bdbfd := d.DecodeElement(_gfce.Lock, &_fcbgf); _bdbfd != nil {
					return _bdbfd
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_gfce.Clippath = NewOfcClippath()
				if _aacfg := d.DecodeElement(_gfce.Clippath, &_fcbgf); _aacfg != nil {
					return _aacfg
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_gfce.Signatureline = NewOfcSignatureline()
				if _cbbb := d.DecodeElement(_gfce.Signatureline, &_fcbgf); _cbbb != nil {
					return _cbbb
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_gfce.Wrap = _a.NewWrap()
				if _dbdcc := d.DecodeElement(_gfce.Wrap, &_fcbgf); _dbdcc != nil {
					return _dbdcc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_gfce.Anchorlock = _a.NewAnchorlock()
				if _ddea := d.DecodeElement(_gfce.Anchorlock, &_fcbgf); _ddea != nil {
					return _ddea
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_gfce.Bordertop = _a.NewBordertop()
				if _fegdc := d.DecodeElement(_gfce.Bordertop, &_fcbgf); _fegdc != nil {
					return _fegdc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_gfce.Borderbottom = _a.NewBorderbottom()
				if _cdefb := d.DecodeElement(_gfce.Borderbottom, &_fcbgf); _cdefb != nil {
					return _cdefb
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_gfce.Borderleft = _a.NewBorderleft()
				if _dgcdf := d.DecodeElement(_gfce.Borderleft, &_fcbgf); _dgcdf != nil {
					return _dgcdf
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_gfce.Borderright = _a.NewBorderright()
				if _dbdf := d.DecodeElement(_gfce.Borderright, &_fcbgf); _dbdf != nil {
					return _dbdf
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_gfce.ClientData = _c.NewClientData()
				if _gggbc := d.DecodeElement(_gfce.ClientData, &_fcbgf); _gggbc != nil {
					return _gggbc
				}
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_gfce.Textdata = _bf.NewTextdata()
				if _deafd := d.DecodeElement(_gfce.Textdata, &_fcbgf); _deafd != nil {
					return _deafd
				}
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020EG_ShapeElements\u0020\u0025v", _fcbgf.Name)
				if _fbacg := d.Skip(); _fbacg != nil {
					return _fbacg
				}
			}
		case _b.EndElement:
			break _gfbfaa
		case _b.CharData:
		}
	}
	return nil
}

type CT_F struct{ EqnAttr *string }

func (_baca *CT_Shape) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _baca.GfxdataAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:gfxdata"}, Value: _f.Sprintf("\u0025v", *_baca.GfxdataAttr)})
	}
	if _baca.EquationxmlAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "equationxml"}, Value: _f.Sprintf("\u0025v", *_baca.EquationxmlAttr)})
	}
	if _baca.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_baca.HrefAttr)})
	}
	if _baca.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_baca.TargetAttr)})
	}
	if _baca.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_baca.ClassAttr)})
	}
	if _baca.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_baca.TitleAttr)})
	}
	if _baca.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_baca.AltAttr)})
	}
	if _baca.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_baca.CoordsizeAttr)})
	}
	if _baca.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_baca.CoordoriginAttr)})
	}
	if _baca.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_baca.WrapcoordsAttr)})
	}
	if _baca.PrintAttr != _eb.ST_TrueFalseUnset {
		_badga, _egfa := _baca.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _egfa != nil {
			return _egfa
		}
		start.Attr = append(start.Attr, _badga)
	}
	if _baca.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_baca.IdAttr)})
	}
	if _baca.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_baca.StyleAttr)})
	}
	if _baca.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_baca.SpidAttr)})
	}
	if _baca.OnedAttr != _eb.ST_TrueFalseUnset {
		_gebde, _fefba := _baca.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _fefba != nil {
			return _fefba
		}
		start.Attr = append(start.Attr, _gebde)
	}
	if _baca.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_baca.RegroupidAttr)})
	}
	if _baca.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_cgcb, _accad := _baca.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _accad != nil {
			return _accad
		}
		start.Attr = append(start.Attr, _cgcb)
	}
	if _baca.ButtonAttr != _eb.ST_TrueFalseUnset {
		_feabg, _cdgfcg := _baca.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _cdgfcg != nil {
			return _cdgfcg
		}
		start.Attr = append(start.Attr, _feabg)
	}
	if _baca.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_fcfde, _agga := _baca.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _agga != nil {
			return _agga
		}
		start.Attr = append(start.Attr, _fcfde)
	}
	if _baca.BulletAttr != _eb.ST_TrueFalseUnset {
		_dcfdd, _fdaf := _baca.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _fdaf != nil {
			return _fdaf
		}
		start.Attr = append(start.Attr, _dcfdd)
	}
	if _baca.HrAttr != _eb.ST_TrueFalseUnset {
		_aeac, _afcea := _baca.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _afcea != nil {
			return _afcea
		}
		start.Attr = append(start.Attr, _aeac)
	}
	if _baca.HrstdAttr != _eb.ST_TrueFalseUnset {
		_ddecg, _faaab := _baca.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _faaab != nil {
			return _faaab
		}
		start.Attr = append(start.Attr, _ddecg)
	}
	if _baca.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_abfeg, _babf := _baca.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _babf != nil {
			return _babf
		}
		start.Attr = append(start.Attr, _abfeg)
	}
	if _baca.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_baca.HrpctAttr)})
	}
	if _baca.HralignAttr != OfcST_HrAlignUnset {
		_agdd, _geag := _baca.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _geag != nil {
			return _geag
		}
		start.Attr = append(start.Attr, _agdd)
	}
	if _baca.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_cgaa, _efggg := _baca.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _efggg != nil {
			return _efggg
		}
		start.Attr = append(start.Attr, _cgaa)
	}
	if _baca.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_abgeae, _gfbd := _baca.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _gfbd != nil {
			return _gfbd
		}
		start.Attr = append(start.Attr, _abgeae)
	}
	if _baca.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_fbaa, _bgbe := _baca.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _bgbe != nil {
			return _bgbe
		}
		start.Attr = append(start.Attr, _fbaa)
	}
	if _baca.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_baca.BordertopcolorAttr)})
	}
	if _baca.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_baca.BorderleftcolorAttr)})
	}
	if _baca.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_baca.BorderbottomcolorAttr)})
	}
	if _baca.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_baca.BorderrightcolorAttr)})
	}
	if _baca.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_dbade, _bdcd := _baca.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _bdcd != nil {
			return _bdcd
		}
		start.Attr = append(start.Attr, _dbade)
	}
	if _baca.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_baca.DgmnodekindAttr)})
	}
	if _baca.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_ffggb, _dcfee := _baca.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _dcfee != nil {
			return _dcfee
		}
		start.Attr = append(start.Attr, _ffggb)
	}
	if _baca.InsetmodeAttr != OfcST_InsetModeUnset {
		_fada, _adgd := _baca.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _adgd != nil {
			return _adgd
		}
		start.Attr = append(start.Attr, _fada)
	}
	if _baca.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_baca.OpacityAttr)})
	}
	if _baca.StrokedAttr != _eb.ST_TrueFalseUnset {
		_bedd, _dggce := _baca.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _dggce != nil {
			return _dggce
		}
		start.Attr = append(start.Attr, _bedd)
	}
	if _baca.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_baca.StrokecolorAttr)})
	}
	if _baca.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_baca.StrokeweightAttr)})
	}
	if _baca.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_bdaca, _fdfg := _baca.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _fdfg != nil {
			return _fdfg
		}
		start.Attr = append(start.Attr, _bdaca)
	}
	if _baca.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_baca.ChromakeyAttr)})
	}
	if _baca.FilledAttr != _eb.ST_TrueFalseUnset {
		_dcgdce, _aceae := _baca.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _aceae != nil {
			return _aceae
		}
		start.Attr = append(start.Attr, _dcgdce)
	}
	if _baca.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_baca.FillcolorAttr)})
	}
	if _baca.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_baca.SptAttr)})
	}
	if _baca.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_dfac, _ggfde := _baca.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _ggfde != nil {
			return _ggfde
		}
		start.Attr = append(start.Attr, _dfac)
	}
	if _baca.BwmodeAttr != OfcST_BWModeUnset {
		_adgge, _eecab := _baca.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _eecab != nil {
			return _eecab
		}
		start.Attr = append(start.Attr, _adgge)
	}
	if _baca.BwpureAttr != OfcST_BWModeUnset {
		_fafc, _bbgb := _baca.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _bbgb != nil {
			return _bbgb
		}
		start.Attr = append(start.Attr, _fafc)
	}
	if _baca.BwnormalAttr != OfcST_BWModeUnset {
		_dcda, _dadde := _baca.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _dadde != nil {
			return _dadde
		}
		start.Attr = append(start.Attr, _dcda)
	}
	if _baca.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_bdggc, _feebd := _baca.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _feebd != nil {
			return _feebd
		}
		start.Attr = append(start.Attr, _bdggc)
	}
	if _baca.OleiconAttr != _eb.ST_TrueFalseUnset {
		_gbabd, _gdfae := _baca.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _gdfae != nil {
			return _gdfae
		}
		start.Attr = append(start.Attr, _gbabd)
	}
	if _baca.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_adeb, _fcbf := _baca.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _fcbf != nil {
			return _fcbf
		}
		start.Attr = append(start.Attr, _adeb)
	}
	if _baca.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_dceba, _debb := _baca.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _debb != nil {
			return _debb
		}
		start.Attr = append(start.Attr, _dceba)
	}
	if _baca.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_faacc, _aabba := _baca.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _aabba != nil {
			return _aabba
		}
		start.Attr = append(start.Attr, _faacc)
	}
	if _baca.ClipAttr != _eb.ST_TrueFalseUnset {
		_cfbg, _debfd := _baca.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _debfd != nil {
			return _debfd
		}
		start.Attr = append(start.Attr, _cfbg)
	}
	if _baca.TypeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "type"}, Value: _f.Sprintf("\u0025v", *_baca.TypeAttr)})
	}
	if _baca.AdjAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "adj"}, Value: _f.Sprintf("\u0025v", *_baca.AdjAttr)})
	}
	if _baca.PathAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "path"}, Value: _f.Sprintf("\u0025v", *_baca.PathAttr)})
	}
	e.EncodeToken(start)
	if _baca.Ink != nil {
		_egbeb := _b.StartElement{Name: _b.Name{Local: "o:ink"}}
		for _, _abgb := range _baca.Ink {
			e.EncodeElement(_abgb, _egbeb)
		}
	}
	if _baca.Iscomment != nil {
		_eaaga := _b.StartElement{Name: _b.Name{Local: "ur:iscomment"}}
		for _, _fggad := range _baca.Iscomment {
			e.EncodeElement(_fggad, _eaaga)
		}
	}
	if _baca.Equationxml != nil {
		_fccd := _b.StartElement{Name: _b.Name{Local: "o:equationxml"}}
		for _, _aefbc := range _baca.Equationxml {
			e.EncodeElement(_aefbc, _fccd)
		}
	}
	if _baca.EG_ShapeElements != nil {
		for _, _gbfdb := range _baca.EG_ShapeElements {
			_gbfdb.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_ddg *AG_OfficeCoreAttributes) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _egae := range start.Attr {
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "hralign" {
			_ddg.HralignAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "allowincell" {
			_ddg.AllowincellAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "oned" {
			_ddg.OnedAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "allowoverlap" {
			_ddg.AllowoverlapAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "doubleclicknotify" {
			_ddg.DoubleclicknotifyAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "userdrawn" {
			_ddg.UserdrawnAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "userhidden" {
			_ddg.UserhiddenAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "bordertopcolor" {
			_gdbb, _gbgec := _egae.Value, error(nil)
			if _gbgec != nil {
				return _gbgec
			}
			_ddg.BordertopcolorAttr = &_gdbb
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "hr" {
			_ddg.HrAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "borderleftcolor" {
			_bddd, _fcbb := _egae.Value, error(nil)
			if _fcbb != nil {
				return _fcbb
			}
			_ddg.BorderleftcolorAttr = &_bddd
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "borderrightcolor" {
			_gebe, _ddd := _egae.Value, error(nil)
			if _ddd != nil {
				return _ddd
			}
			_ddg.BorderrightcolorAttr = &_gebe
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "dgmnodekind" {
			_gebb, _eege := _e.ParseInt(_egae.Value, 10, 64)
			if _eege != nil {
				return _eege
			}
			_ddg.DgmnodekindAttr = &_gebb
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "bullet" {
			_ddg.BulletAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "borderbottomcolor" {
			_afdc, _aaa := _egae.Value, error(nil)
			if _aaa != nil {
				return _aaa
			}
			_ddg.BorderbottomcolorAttr = &_afdc
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "insetmode" {
			_ddg.InsetmodeAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "button" {
			_ddg.ButtonAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "dgmlayout" {
			_ddg.DgmlayoutAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "spid" {
			_gdc, _cegf := _egae.Value, error(nil)
			if _cegf != nil {
				return _cegf
			}
			_ddg.SpidAttr = &_gdc
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "dgmlayoutmru" {
			_ddg.DgmlayoutmruAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "hrstd" {
			_ddg.HrstdAttr.UnmarshalXMLAttr(_egae)
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "hrpct" {
			_aaab, _afdcf := _e.ParseFloat(_egae.Value, 64)
			if _afdcf != nil {
				return _afdcf
			}
			_agb := float32(_aaab)
			_ddg.HrpctAttr = &_agb
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "regroupid" {
			_acde, _dgcd := _e.ParseInt(_egae.Value, 10, 64)
			if _dgcd != nil {
				return _dgcd
			}
			_ddg.RegroupidAttr = &_acde
			continue
		}
		if _egae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _egae.Name.Local == "hrnoshade" {
			_ddg.HrnoshadeAttr.UnmarshalXMLAttr(_egae)
			continue
		}
	}
	for {
		_dff, _adg := d.Token()
		if _adg != nil {
			return _f.Errorf("parsing AG_OfficeCoreAttributes:\u0020%s", _adg)
		}
		if _agfg, _adec := _dff.(_b.EndElement); _adec && _agfg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_geda OfcST_ExtrusionRender) Validate() error { return _geda.ValidateWithPath("") }
func (_aead *Image) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _aead.CT_Image.MarshalXML(e, start)
}
func (_cgbfg *OfcST_Angle) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_egcdcf, _efabf := d.Token()
	if _efabf != nil {
		return _efabf
	}
	if _ccab, _fggdf := _egcdcf.(_b.EndElement); _fggdf && _ccab.Name == start.Name {
		*_cgbfg = 1
		return nil
	}
	if _gddbd, _dddc := _egcdcf.(_b.CharData); !_dddc {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _egcdcf)
	} else {
		switch string(_gddbd) {
		case "":
			*_cgbfg = 0
		case "any":
			*_cgbfg = 1
		case "30":
			*_cgbfg = 2
		case "45":
			*_cgbfg = 3
		case "60":
			*_cgbfg = 4
		case "90":
			*_cgbfg = 5
		case "auto":
			*_cgbfg = 6
		}
	}
	_egcdcf, _efabf = d.Token()
	if _efabf != nil {
		return _efabf
	}
	if _cbefb, _cdacbd := _egcdcf.(_b.EndElement); _cdacbd && _cbefb.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _egcdcf)
}
func (_fbfdb ST_StrokeArrowType) ValidateWithPath(path string) error {
	switch _fbfdb {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_fbfdb))
	}
	return nil
}
func NewAG_Adj() *AG_Adj { _g := &AG_Adj{}; return _g }

// Validate validates the CT_Oval and its children
func (_dagde *CT_Oval) Validate() error { return _dagde.ValidateWithPath("CT_Oval") }

// Validate validates the CT_Handles and its children
func (_abcbc *CT_Handles) Validate() error { return _abcbc.ValidateWithPath("CT_Handles") }
func (_ccgae *OfcEquationxml) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:equationxml"
	return _ccgae.OfcCT_EquationXml.MarshalXML(e, start)
}

const (
	OfcST_InsetModeUnset  OfcST_InsetMode = 0
	OfcST_InsetModeAuto   OfcST_InsetMode = 1
	OfcST_InsetModeCustom OfcST_InsetMode = 2
)

func (_fdebde *OfcCT_Callout) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _cbcecb := range start.Attr {
		if _cbcecb.Name.Local == "lengthspecified" {
			_fdebde.LengthspecifiedAttr.UnmarshalXMLAttr(_cbcecb)
			continue
		}
		if _cbcecb.Name.Local == "on" {
			_fdebde.OnAttr.UnmarshalXMLAttr(_cbcecb)
			continue
		}
		if _cbcecb.Name.Local == "gap" {
			_cfdd, _fgbee := _cbcecb.Value, error(nil)
			if _fgbee != nil {
				return _fgbee
			}
			_fdebde.GapAttr = &_cfdd
			continue
		}
		if _cbcecb.Name.Local == "angle" {
			_fdebde.AngleAttr.UnmarshalXMLAttr(_cbcecb)
			continue
		}
		if _cbcecb.Name.Local == "dropauto" {
			_fdebde.DropautoAttr.UnmarshalXMLAttr(_cbcecb)
			continue
		}
		if _cbcecb.Name.Local == "drop" {
			_cdffg, _eadbd := _cbcecb.Value, error(nil)
			if _eadbd != nil {
				return _eadbd
			}
			_fdebde.DropAttr = &_cdffg
			continue
		}
		if _cbcecb.Name.Local == "distance" {
			_afde, _bdeb := _cbcecb.Value, error(nil)
			if _bdeb != nil {
				return _bdeb
			}
			_fdebde.DistanceAttr = &_afde
			continue
		}
		if _cbcecb.Name.Local == "type" {
			_ecccg, _bgacd := _cbcecb.Value, error(nil)
			if _bgacd != nil {
				return _bgacd
			}
			_fdebde.TypeAttr = &_ecccg
			continue
		}
		if _cbcecb.Name.Local == "length" {
			_cabca, _gfgad := _cbcecb.Value, error(nil)
			if _gfgad != nil {
				return _gfgad
			}
			_fdebde.LengthAttr = &_cabca
			continue
		}
		if _cbcecb.Name.Local == "accentbar" {
			_fdebde.AccentbarAttr.UnmarshalXMLAttr(_cbcecb)
			continue
		}
		if _cbcecb.Name.Local == "textborder" {
			_fdebde.TextborderAttr.UnmarshalXMLAttr(_cbcecb)
			continue
		}
		if _cbcecb.Name.Local == "minusx" {
			_fdebde.MinusxAttr.UnmarshalXMLAttr(_cbcecb)
			continue
		}
		if _cbcecb.Name.Local == "minusy" {
			_fdebde.MinusyAttr.UnmarshalXMLAttr(_cbcecb)
			continue
		}
		if _cbcecb.Name.Local == "ext" {
			_fdebde.ExtAttr.UnmarshalXMLAttr(_cbcecb)
			continue
		}
	}
	for {
		_dacab, _bgbeb := d.Token()
		if _bgbeb != nil {
			return _f.Errorf("parsing\u0020OfcCT_Callout:\u0020\u0025s", _bgbeb)
		}
		if _bgfba, _dbefb := _dacab.(_b.EndElement); _dbefb && _bgfba.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Background and its children, prefixing error messages with path
func (_aabfb *CT_Background) ValidateWithPath(path string) error {
	if _fabf := _aabfb.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _fabf != nil {
		return _fabf
	}
	if _cdcec := _aabfb.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _cdcec != nil {
		return _cdcec
	}
	if _dcag := _aabfb.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _dcag != nil {
		return _dcag
	}
	if _dgdb := _aabfb.TargetscreensizeAttr.ValidateWithPath(path + "/TargetscreensizeAttr"); _dgdb != nil {
		return _dgdb
	}
	if _aabfb.Fill != nil {
		if _geee := _aabfb.Fill.ValidateWithPath(path + "\u002fFill"); _geee != nil {
			return _geee
		}
	}
	if _dbfea := _aabfb.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _dbfea != nil {
		return _dbfea
	}
	return nil
}

const (
	OfcST_ColorModeUnset  OfcST_ColorMode = 0
	OfcST_ColorModeAuto   OfcST_ColorMode = 1
	OfcST_ColorModeCustom OfcST_ColorMode = 2
)

func (_adcf *CT_Handles) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_gfgab:
	for {
		_cfefd, _cbgaf := d.Token()
		if _cbgaf != nil {
			return _cbgaf
		}
		switch _gefff := _cfefd.(type) {
		case _b.StartElement:
			switch _gefff.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "h"}:
				_abdf := NewCT_H()
				if _bdfa := d.DecodeElement(_abdf, &_gefff); _bdfa != nil {
					return _bdfa
				}
				_adcf.H = append(_adcf.H, _abdf)
			default:
				_ba.Log("skipping unsupported\u0020element\u0020on\u0020CT_Handles\u0020\u0025v", _gefff.Name)
				if _eddgab := d.Skip(); _eddgab != nil {
					return _eddgab
				}
			}
		case _b.EndElement:
			break _gfgab
		case _b.CharData:
		}
	}
	return nil
}
func (_ebddd OfcST_OLEType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_ebddd.String(), start)
}

// Validate validates the OfcCT_ClipPath and its children
func (_defe *OfcCT_ClipPath) Validate() error { return _defe.ValidateWithPath("OfcCT_ClipPath") }
func (_afcba *ST_FillMethod) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_afcba = 0
	case "none":
		*_afcba = 1
	case "linear":
		*_afcba = 2
	case "sigma":
		*_afcba = 3
	case "any":
		*_afcba = 4
	case "linear\u0020sigma":
		*_afcba = 5
	}
	return nil
}
func (_dbdgd *Oval) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _dbdgd.CT_Oval.MarshalXML(e, start)
}
func (_abafg ST_StrokeArrowType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_abafg.String(), start)
}
func NewOfcCT_Rules() *OfcCT_Rules { _ggbcf := &OfcCT_Rules{}; return _ggbcf }
func (_ecab *OfcCT_Fill) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _affd := range start.Attr {
		if _affd.Name.Local == "type" {
			_ecab.TypeAttr.UnmarshalXMLAttr(_affd)
			continue
		}
		if _affd.Name.Local == "ext" {
			_ecab.ExtAttr.UnmarshalXMLAttr(_affd)
			continue
		}
	}
	for {
		_aeaecd, _fdddg := d.Token()
		if _fdddg != nil {
			return _f.Errorf("parsing\u0020OfcCT_Fill:\u0020%s", _fdddg)
		}
		if _fbda, _egfabd := _aeaecd.(_b.EndElement); _egfabd && _fbda.Name == start.Name {
			break
		}
	}
	return nil
}
func NewOfcCT_ColorMru() *OfcCT_ColorMru { _afccc := &OfcCT_ColorMru{}; return _afccc }
func (_gbedc ST_FillType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gedgb := _b.Attr{}
	_gedgb.Name = name
	switch _gbedc {
	case ST_FillTypeUnset:
		_gedgb.Value = ""
	case ST_FillTypeSolid:
		_gedgb.Value = "solid"
	case ST_FillTypeGradient:
		_gedgb.Value = "gradient"
	case ST_FillTypeGradientRadial:
		_gedgb.Value = "gradientRadial"
	case ST_FillTypeTile:
		_gedgb.Value = "tile"
	case ST_FillTypePattern:
		_gedgb.Value = "pattern"
	case ST_FillTypeFrame:
		_gedgb.Value = "frame"
	}
	return _gedgb, nil
}
func (_edgfa OfcST_OLEUpdateMode) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_ffdega := _b.Attr{}
	_ffdega.Name = name
	switch _edgfa {
	case OfcST_OLEUpdateModeUnset:
		_ffdega.Value = ""
	case OfcST_OLEUpdateModeAlways:
		_ffdega.Value = "Always"
	case OfcST_OLEUpdateModeOnCall:
		_ffdega.Value = "OnCall"
	}
	return _ffdega, nil
}

// ValidateWithPath validates the CT_Path and its children, prefixing error messages with path
func (_baad *CT_Path) ValidateWithPath(path string) error {
	if _edfff := _baad.FillokAttr.ValidateWithPath(path + "/FillokAttr"); _edfff != nil {
		return _edfff
	}
	if _acaab := _baad.StrokeokAttr.ValidateWithPath(path + "\u002fStrokeokAttr"); _acaab != nil {
		return _acaab
	}
	if _dcbbc := _baad.ShadowokAttr.ValidateWithPath(path + "\u002fShadowokAttr"); _dcbbc != nil {
		return _dcbbc
	}
	if _cbfb := _baad.ArrowokAttr.ValidateWithPath(path + "\u002fArrowokAttr"); _cbfb != nil {
		return _cbfb
	}
	if _dgaf := _baad.GradientshapeokAttr.ValidateWithPath(path + "/GradientshapeokAttr"); _dgaf != nil {
		return _dgaf
	}
	if _gbgd := _baad.TextpathokAttr.ValidateWithPath(path + "\u002fTextpathokAttr"); _gbgd != nil {
		return _gbgd
	}
	if _gggc := _baad.InsetpenokAttr.ValidateWithPath(path + "\u002fInsetpenokAttr"); _gggc != nil {
		return _gggc
	}
	if _gfede := _baad.ConnecttypeAttr.ValidateWithPath(path + "\u002fConnecttypeAttr"); _gfede != nil {
		return _gfede
	}
	if _aeeg := _baad.ExtrusionokAttr.ValidateWithPath(path + "\u002fExtrusionokAttr"); _aeeg != nil {
		return _aeeg
	}
	return nil
}
func (_bcfee ST_ImageAspect) ValidateWithPath(path string) error {
	switch _bcfee {
	case 0, 1, 2, 3:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bcfee))
	}
	return nil
}

type CT_Group struct {
	EditasAttr            ST_EditAs
	TablepropertiesAttr   *string
	TablelimitsAttr       *string
	Group                 []*Group
	Shape                 []*Shape
	Shapetype             []*Shapetype
	Arc                   []*Arc
	Curve                 []*Curve
	Image                 []*Image
	Line                  []*Line
	Oval                  []*Oval
	Polyline              []*Polyline
	Rect                  []*Rect
	Roundrect             []*Roundrect
	Diagram               []*OfcDiagram
	EG_ShapeElements      []*EG_ShapeElements
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
	FilledAttr            _eb.ST_TrueFalse
	FillcolorAttr         *string
}

func (_dedbb *OfcLock) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _dedbb.OfcCT_Lock.MarshalXML(e, start)
}
func (_abaeb OfcST_OLEDrawAspect) Validate() error { return _abaeb.ValidateWithPath("") }
func (_eaafd ST_StrokeArrowLength) String() string {
	switch _eaafd {
	case 0:
		return ""
	case 1:
		return "short"
	case 2:
		return "medium"
	case 3:
		return "long"
	}
	return ""
}

type CT_Fill struct {
	TypeAttr             ST_FillType
	OnAttr               _eb.ST_TrueFalse
	ColorAttr            *string
	OpacityAttr          *string
	Color2Attr           *string
	SrcAttr              *string
	HrefAttr             *string
	AlthrefAttr          *string
	SizeAttr             *string
	OriginAttr           *string
	PositionAttr         *string
	AspectAttr           ST_ImageAspect
	ColorsAttr           *string
	AngleAttr            *float64
	AlignshapeAttr       _eb.ST_TrueFalse
	FocusAttr            *string
	FocussizeAttr        *string
	FocuspositionAttr    *string
	MethodAttr           ST_FillMethod
	DetectmouseclickAttr _eb.ST_TrueFalse
	TitleAttr            *string
	Opacity2Attr         *string
	RecolorAttr          _eb.ST_TrueFalse
	RotateAttr           _eb.ST_TrueFalse
	IdAttr               *string
	RelidAttr            *string
	Fill                 *OfcFill
	SIdAttr              *string
}

func (_cedfa ST_ShadowType) Validate() error { return _cedfa.ValidateWithPath("") }
func (_bcbef *OfcCT_Callout) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bcbef.OnAttr != _eb.ST_TrueFalseUnset {
		_gcdac, _edbae := _bcbef.OnAttr.MarshalXMLAttr(_b.Name{Local: "on"})
		if _edbae != nil {
			return _edbae
		}
		start.Attr = append(start.Attr, _gcdac)
	}
	if _bcbef.TypeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "type"}, Value: _f.Sprintf("\u0025v", *_bcbef.TypeAttr)})
	}
	if _bcbef.GapAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "gap"}, Value: _f.Sprintf("\u0025v", *_bcbef.GapAttr)})
	}
	if _bcbef.AngleAttr != OfcST_AngleUnset {
		_cfccb, _gdcdd := _bcbef.AngleAttr.MarshalXMLAttr(_b.Name{Local: "angle"})
		if _gdcdd != nil {
			return _gdcdd
		}
		start.Attr = append(start.Attr, _cfccb)
	}
	if _bcbef.DropautoAttr != _eb.ST_TrueFalseUnset {
		_baefg, _ffef := _bcbef.DropautoAttr.MarshalXMLAttr(_b.Name{Local: "dropauto"})
		if _ffef != nil {
			return _ffef
		}
		start.Attr = append(start.Attr, _baefg)
	}
	if _bcbef.DropAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "drop"}, Value: _f.Sprintf("\u0025v", *_bcbef.DropAttr)})
	}
	if _bcbef.DistanceAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "distance"}, Value: _f.Sprintf("\u0025v", *_bcbef.DistanceAttr)})
	}
	if _bcbef.LengthspecifiedAttr != _eb.ST_TrueFalseUnset {
		_egde, _fgbdgb := _bcbef.LengthspecifiedAttr.MarshalXMLAttr(_b.Name{Local: "lengthspecified"})
		if _fgbdgb != nil {
			return _fgbdgb
		}
		start.Attr = append(start.Attr, _egde)
	}
	if _bcbef.LengthAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "length"}, Value: _f.Sprintf("\u0025v", *_bcbef.LengthAttr)})
	}
	if _bcbef.AccentbarAttr != _eb.ST_TrueFalseUnset {
		_afcbe, _cccbe := _bcbef.AccentbarAttr.MarshalXMLAttr(_b.Name{Local: "accentbar"})
		if _cccbe != nil {
			return _cccbe
		}
		start.Attr = append(start.Attr, _afcbe)
	}
	if _bcbef.TextborderAttr != _eb.ST_TrueFalseUnset {
		_aagc, _dfaae := _bcbef.TextborderAttr.MarshalXMLAttr(_b.Name{Local: "textborder"})
		if _dfaae != nil {
			return _dfaae
		}
		start.Attr = append(start.Attr, _aagc)
	}
	if _bcbef.MinusxAttr != _eb.ST_TrueFalseUnset {
		_eecdg, _dgca := _bcbef.MinusxAttr.MarshalXMLAttr(_b.Name{Local: "minusx"})
		if _dgca != nil {
			return _dgca
		}
		start.Attr = append(start.Attr, _eecdg)
	}
	if _bcbef.MinusyAttr != _eb.ST_TrueFalseUnset {
		_acdg, _dgfcf := _bcbef.MinusyAttr.MarshalXMLAttr(_b.Name{Local: "minusy"})
		if _dgfcf != nil {
			return _dgfcf
		}
		start.Attr = append(start.Attr, _acdg)
	}
	if _bcbef.ExtAttr != ST_ExtUnset {
		_ddfddc, _ddcbb := _bcbef.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _ddcbb != nil {
			return _ddcbb
		}
		start.Attr = append(start.Attr, _ddfddc)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type OfcCT_R struct {
	IdAttr    string
	TypeAttr  OfcST_RType
	HowAttr   OfcST_How
	IdrefAttr *string
	Proxy     []*OfcCT_Proxy
}
type OfcEquationxml struct{ OfcCT_EquationXml }

func (_baeeec *ST_StrokeArrowWidth) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_baeeec = 0
	case "narrow":
		*_baeeec = 1
	case "medium":
		*_baeeec = 2
	case "wide":
		*_baeeec = 3
	}
	return nil
}

type OfcCT_Lock struct {
	PositionAttr      _eb.ST_TrueFalse
	SelectionAttr     _eb.ST_TrueFalse
	GroupingAttr      _eb.ST_TrueFalse
	UngroupingAttr    _eb.ST_TrueFalse
	RotationAttr      _eb.ST_TrueFalse
	CroppingAttr      _eb.ST_TrueFalse
	VerticiesAttr     _eb.ST_TrueFalse
	AdjusthandlesAttr _eb.ST_TrueFalse
	TextAttr          _eb.ST_TrueFalse
	AspectratioAttr   _eb.ST_TrueFalse
	ShapetypeAttr     _eb.ST_TrueFalse
	ExtAttr           ST_Ext
}

func NewOfcEquationxml() *OfcEquationxml {
	_decfaa := &OfcEquationxml{}
	_decfaa.OfcCT_EquationXml = *NewOfcCT_EquationXml()
	return _decfaa
}
func (_ccebb OfcST_ExtrusionRender) ValidateWithPath(path string) error {
	switch _ccebb {
	case 0, 1, 2, 3:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_ccebb))
	}
	return nil
}
func (_cdceg *Curve) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _cdceg.CT_Curve.MarshalXML(e, start)
}
func NewOfcOLEObject() *OfcOLEObject {
	_eaeb := &OfcOLEObject{}
	_eaeb.OfcCT_OLEObject = *NewOfcCT_OLEObject()
	return _eaeb
}

type OfcST_BWMode byte

func NewCT_RoundRect() *CT_RoundRect { _fbgb := &CT_RoundRect{}; return _fbgb }

// Validate validates the OfcCT_Lock and its children
func (_dbedb *OfcCT_Lock) Validate() error { return _dbedb.ValidateWithPath("OfcCT_Lock") }
func (_fgfe *CT_ImageData) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dbee := range start.Attr {
		if _dbee.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _dbee.Name.Local == "pict" || _dbee.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _dbee.Name.Local == "pict" {
			_fedd, _cfbdd := _dbee.Value, error(nil)
			if _cfbdd != nil {
				return _cfbdd
			}
			_fgfe.PictAttr = &_fedd
			continue
		}
		if _dbee.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _dbee.Name.Local == "href" || _dbee.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _dbee.Name.Local == "href" {
			_cfac, _fbgf := _dbee.Value, error(nil)
			if _fbgf != nil {
				return _fbgf
			}
			_fgfe.RHrefAttr = &_cfac
			continue
		}
		if _dbee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dbee.Name.Local == "href" {
			_gdge, _bage := _dbee.Value, error(nil)
			if _bage != nil {
				return _bage
			}
			_fgfe.HrefAttr = &_gdge
			continue
		}
		if _dbee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dbee.Name.Local == "althref" {
			_bbbef, _ebagg := _dbee.Value, error(nil)
			if _ebagg != nil {
				return _ebagg
			}
			_fgfe.AlthrefAttr = &_bbbef
			continue
		}
		if _dbee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dbee.Name.Local == "title" {
			_aaabf, _dcaed := _dbee.Value, error(nil)
			if _dcaed != nil {
				return _dcaed
			}
			_fgfe.TitleAttr = &_aaabf
			continue
		}
		if _dbee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dbee.Name.Local == "oleid" {
			_ccbd, _ebgc := _e.ParseFloat(_dbee.Value, 64)
			if _ebgc != nil {
				return _ebgc
			}
			_cdcb := float32(_ccbd)
			_fgfe.OleidAttr = &_cdcb
			continue
		}
		if _dbee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dbee.Name.Local == "detectmouseclick" {
			_fgfe.DetectmouseclickAttr.UnmarshalXMLAttr(_dbee)
			continue
		}
		if _dbee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dbee.Name.Local == "movie" {
			_dbff, _abga := _e.ParseFloat(_dbee.Value, 64)
			if _abga != nil {
				return _abga
			}
			_adcfa := float32(_dbff)
			_fgfe.MovieAttr = &_adcfa
			continue
		}
		if _dbee.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dbee.Name.Local == "relid" {
			_fafbe, _bagg := _dbee.Value, error(nil)
			if _bagg != nil {
				return _bagg
			}
			_fgfe.RelidAttr = &_fafbe
			continue
		}
		if _dbee.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _dbee.Name.Local == "id" || _dbee.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _dbee.Name.Local == "id" {
			_fcbebf, _agdg := _dbee.Value, error(nil)
			if _agdg != nil {
				return _agdg
			}
			_fgfe.IdAttr = &_fcbebf
			continue
		}
		if _dbee.Name.Local == "id" {
			_daec, _gdafd := _dbee.Value, error(nil)
			if _gdafd != nil {
				return _gdafd
			}
			_fgfe.SIdAttr = &_daec
			continue
		}
		if _dbee.Name.Local == "cropbottom" {
			_cbdd, _aecce := _dbee.Value, error(nil)
			if _aecce != nil {
				return _aecce
			}
			_fgfe.CropbottomAttr = &_cbdd
			continue
		}
		if _dbee.Name.Local == "embosscolor" {
			_ffgf, _gbga := _dbee.Value, error(nil)
			if _gbga != nil {
				return _gbga
			}
			_fgfe.EmbosscolorAttr = &_ffgf
			continue
		}
		if _dbee.Name.Local == "src" {
			_fbfeb, _gfgb := _dbee.Value, error(nil)
			if _gfgb != nil {
				return _gfgb
			}
			_fgfe.SrcAttr = &_fbfeb
			continue
		}
		if _dbee.Name.Local == "cropleft" {
			_fffe, _dggc := _dbee.Value, error(nil)
			if _dggc != nil {
				return _dggc
			}
			_fgfe.CropleftAttr = &_fffe
			continue
		}
		if _dbee.Name.Local == "croptop" {
			_dceaa, _eeeb := _dbee.Value, error(nil)
			if _eeeb != nil {
				return _eeeb
			}
			_fgfe.CroptopAttr = &_dceaa
			continue
		}
		if _dbee.Name.Local == "cropright" {
			_agba, _dcbc := _dbee.Value, error(nil)
			if _dcbc != nil {
				return _dcbc
			}
			_fgfe.CroprightAttr = &_agba
			continue
		}
		if _dbee.Name.Local == "recolortarget" {
			_gdcf, _ffdfc := _dbee.Value, error(nil)
			if _ffdfc != nil {
				return _ffdfc
			}
			_fgfe.RecolortargetAttr = &_gdcf
			continue
		}
		if _dbee.Name.Local == "gain" {
			_cbae, _gfffb := _dbee.Value, error(nil)
			if _gfffb != nil {
				return _gfffb
			}
			_fgfe.GainAttr = &_cbae
			continue
		}
		if _dbee.Name.Local == "blacklevel" {
			_bgce, _agbe := _dbee.Value, error(nil)
			if _agbe != nil {
				return _agbe
			}
			_fgfe.BlacklevelAttr = &_bgce
			continue
		}
		if _dbee.Name.Local == "gamma" {
			_ffgb, _bebe := _dbee.Value, error(nil)
			if _bebe != nil {
				return _bebe
			}
			_fgfe.GammaAttr = &_ffgb
			continue
		}
		if _dbee.Name.Local == "grayscale" {
			_fgfe.GrayscaleAttr.UnmarshalXMLAttr(_dbee)
			continue
		}
		if _dbee.Name.Local == "bilevel" {
			_fgfe.BilevelAttr.UnmarshalXMLAttr(_dbee)
			continue
		}
		if _dbee.Name.Local == "chromakey" {
			_ebfd, _gbbff := _dbee.Value, error(nil)
			if _gbbff != nil {
				return _gbbff
			}
			_fgfe.ChromakeyAttr = &_ebfd
			continue
		}
	}
	for {
		_gabdc, _bbdac := d.Token()
		if _bbdac != nil {
			return _f.Errorf("parsing\u0020CT_ImageData:\u0020\u0025s", _bbdac)
		}
		if _gdgb, _feefg := _gabdc.(_b.EndElement); _feefg && _gdgb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_aedae OfcST_BWMode) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_aedae.String(), start)
}

// ValidateWithPath validates the OfcCT_Proxy and its children, prefixing error messages with path
func (_dgea *OfcCT_Proxy) ValidateWithPath(path string) error {
	if _begfe := _dgea.StartAttr.ValidateWithPath(path + "\u002fStartAttr"); _begfe != nil {
		return _begfe
	}
	if _cgdb := _dgea.EndAttr.ValidateWithPath(path + "\u002fEndAttr"); _cgdb != nil {
		return _cgdb
	}
	return nil
}

// ValidateWithPath validates the CT_F and its children, prefixing error messages with path
func (_dfa *CT_F) ValidateWithPath(path string) error { return nil }

const (
	OfcST_CalloutPlacementUnset  OfcST_CalloutPlacement = 0
	OfcST_CalloutPlacementTop    OfcST_CalloutPlacement = 1
	OfcST_CalloutPlacementCenter OfcST_CalloutPlacement = 2
	OfcST_CalloutPlacementBottom OfcST_CalloutPlacement = 3
	OfcST_CalloutPlacementUser   OfcST_CalloutPlacement = 4
)

func (_ageda *CT_Shadow) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dcfdfc := range start.Attr {
		if _dcfdfc.Name.Local == "on" {
			_ageda.OnAttr.UnmarshalXMLAttr(_dcfdfc)
			continue
		}
		if _dcfdfc.Name.Local == "type" {
			_ageda.TypeAttr.UnmarshalXMLAttr(_dcfdfc)
			continue
		}
		if _dcfdfc.Name.Local == "obscured" {
			_ageda.ObscuredAttr.UnmarshalXMLAttr(_dcfdfc)
			continue
		}
		if _dcfdfc.Name.Local == "color" {
			_acceg, _agcfb := _dcfdfc.Value, error(nil)
			if _agcfb != nil {
				return _agcfb
			}
			_ageda.ColorAttr = &_acceg
			continue
		}
		if _dcfdfc.Name.Local == "opacity" {
			_dbbac, _gbbc := _dcfdfc.Value, error(nil)
			if _gbbc != nil {
				return _gbbc
			}
			_ageda.OpacityAttr = &_dbbac
			continue
		}
		if _dcfdfc.Name.Local == "offset" {
			_fceg, _agce := _dcfdfc.Value, error(nil)
			if _agce != nil {
				return _agce
			}
			_ageda.OffsetAttr = &_fceg
			continue
		}
		if _dcfdfc.Name.Local == "color2" {
			_fbff, _bede := _dcfdfc.Value, error(nil)
			if _bede != nil {
				return _bede
			}
			_ageda.Color2Attr = &_fbff
			continue
		}
		if _dcfdfc.Name.Local == "offset2" {
			_dcfge, _aebb := _dcfdfc.Value, error(nil)
			if _aebb != nil {
				return _aebb
			}
			_ageda.Offset2Attr = &_dcfge
			continue
		}
		if _dcfdfc.Name.Local == "origin" {
			_gbedb, _fdeff := _dcfdfc.Value, error(nil)
			if _fdeff != nil {
				return _fdeff
			}
			_ageda.OriginAttr = &_gbedb
			continue
		}
		if _dcfdfc.Name.Local == "matrix" {
			_adaf, _eeffd := _dcfdfc.Value, error(nil)
			if _eeffd != nil {
				return _eeffd
			}
			_ageda.MatrixAttr = &_adaf
			continue
		}
		if _dcfdfc.Name.Local == "id" {
			_egbec, _feead := _dcfdfc.Value, error(nil)
			if _feead != nil {
				return _feead
			}
			_ageda.IdAttr = &_egbec
			continue
		}
	}
	for {
		_bagba, _acac := d.Token()
		if _acac != nil {
			return _f.Errorf("parsing\u0020CT_Shadow:\u0020\u0025s", _acac)
		}
		if _dadbf, _gdfab := _bagba.(_b.EndElement); _gdfab && _dadbf.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the OfcCT_Lock and its children, prefixing error messages with path
func (_badbg *OfcCT_Lock) ValidateWithPath(path string) error {
	if _aefege := _badbg.PositionAttr.ValidateWithPath(path + "\u002fPositionAttr"); _aefege != nil {
		return _aefege
	}
	if _affdb := _badbg.SelectionAttr.ValidateWithPath(path + "\u002fSelectionAttr"); _affdb != nil {
		return _affdb
	}
	if _agegc := _badbg.GroupingAttr.ValidateWithPath(path + "\u002fGroupingAttr"); _agegc != nil {
		return _agegc
	}
	if _cabgc := _badbg.UngroupingAttr.ValidateWithPath(path + "\u002fUngroupingAttr"); _cabgc != nil {
		return _cabgc
	}
	if _edfefa := _badbg.RotationAttr.ValidateWithPath(path + "\u002fRotationAttr"); _edfefa != nil {
		return _edfefa
	}
	if _dcbab := _badbg.CroppingAttr.ValidateWithPath(path + "\u002fCroppingAttr"); _dcbab != nil {
		return _dcbab
	}
	if _afgc := _badbg.VerticiesAttr.ValidateWithPath(path + "\u002fVerticiesAttr"); _afgc != nil {
		return _afgc
	}
	if _dbegg := _badbg.AdjusthandlesAttr.ValidateWithPath(path + "\u002fAdjusthandlesAttr"); _dbegg != nil {
		return _dbegg
	}
	if _fcdg := _badbg.TextAttr.ValidateWithPath(path + "\u002fTextAttr"); _fcdg != nil {
		return _fcdg
	}
	if _egee := _badbg.AspectratioAttr.ValidateWithPath(path + "\u002fAspectratioAttr"); _egee != nil {
		return _egee
	}
	if _cedgf := _badbg.ShapetypeAttr.ValidateWithPath(path + "\u002fShapetypeAttr"); _cedgf != nil {
		return _cedgf
	}
	if _gdfgfg := _badbg.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _gdfgfg != nil {
		return _gdfgfg
	}
	return nil
}

// Validate validates the CT_Textbox and its children
func (_deece *CT_Textbox) Validate() error { return _deece.ValidateWithPath("CT_Textbox") }
func NewCT_Textbox() *CT_Textbox           { _cabb := &CT_Textbox{}; return _cabb }
func (_fcdabb *OfcST_ConnectorType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fcdabb = 0
	case "none":
		*_fcdabb = 1
	case "straight":
		*_fcdabb = 2
	case "elbow":
		*_fcdabb = 3
	case "curved":
		*_fcdabb = 4
	}
	return nil
}
func (_dbfdg *ST_Ext) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dbfdg = 0
	case "view":
		*_dbfdg = 1
	case "edit":
		*_dbfdg = 2
	case "backwardCompatible":
		*_dbfdg = 3
	}
	return nil
}
func NewGroup() *Group { _adbgde := &Group{}; _adbgde.CT_Group = *NewCT_Group(); return _adbgde }
func (_bgdab *CT_Textbox) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bgdab.InsetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "inset"}, Value: _f.Sprintf("\u0025v", *_bgdab.InsetAttr)})
	}
	if _bgdab.SingleclickAttr != _eb.ST_TrueFalseUnset {
		_ffcef, _bfgefa := _bgdab.SingleclickAttr.MarshalXMLAttr(_b.Name{Local: "o:singleclick"})
		if _bfgefa != nil {
			return _bfgefa
		}
		start.Attr = append(start.Attr, _ffcef)
	}
	if _bgdab.InsetmodeAttr != OfcST_InsetModeUnset {
		_cddgf, _ffdcb := _bgdab.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _ffdcb != nil {
			return _ffdcb
		}
		start.Attr = append(start.Attr, _cddgf)
	}
	if _bgdab.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_bgdab.IdAttr)})
	}
	if _bgdab.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_bgdab.StyleAttr)})
	}
	e.EncodeToken(start)
	if _bgdab.TxbxContent != nil {
		_cggca := _b.StartElement{Name: _b.Name{Local: "w:txbxContent"}}
		e.EncodeElement(_bgdab.TxbxContent, _cggca)
	}
	if _bgdab.Any != nil {
		_bgdab.Any.MarshalXML(e, _b.StartElement{})
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the OfcCT_EquationXml and its children, prefixing error messages with path
func (_gdebg *OfcCT_EquationXml) ValidateWithPath(path string) error { return nil }
func (_bgdae *OfcST_ExtrusionPlane) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_bgdae = 0
	case "XY":
		*_bgdae = 1
	case "ZX":
		*_bgdae = 2
	case "YZ":
		*_bgdae = 3
	}
	return nil
}

type OfcLeft struct{ OfcCT_StrokeChild }

// Validate validates the AG_Adj and its children
func (_gf *AG_Adj) Validate() error { return _gf.ValidateWithPath("AG_Adj") }
func (_abedff OfcST_OLEDrawAspect) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_abedff.String(), start)
}
func (_cecab OfcST_InsetMode) ValidateWithPath(path string) error {
	switch _cecab {
	case 0, 1, 2:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cecab))
	}
	return nil
}

const (
	OfcST_ConnectorTypeUnset    OfcST_ConnectorType = 0
	OfcST_ConnectorTypeNone     OfcST_ConnectorType = 1
	OfcST_ConnectorTypeStraight OfcST_ConnectorType = 2
	OfcST_ConnectorTypeElbow    OfcST_ConnectorType = 3
	OfcST_ConnectorTypeCurved   OfcST_ConnectorType = 4
)

func (_ggegda OfcST_ConnectorType) String() string {
	switch _ggegda {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "straight"
	case 3:
		return "elbow"
	case 4:
		return "curved"
	}
	return ""
}
func (_caade OfcST_RType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_fbecd := _b.Attr{}
	_fbecd.Name = name
	switch _caade {
	case OfcST_RTypeUnset:
		_fbecd.Value = ""
	case OfcST_RTypeArc:
		_fbecd.Value = "arc"
	case OfcST_RTypeCallout:
		_fbecd.Value = "callout"
	case OfcST_RTypeConnector:
		_fbecd.Value = "connector"
	case OfcST_RTypeAlign:
		_fbecd.Value = "align"
	}
	return _fbecd, nil
}

// ValidateWithPath validates the AG_AllShapeAttributes and its children, prefixing error messages with path
func (_afeg *AG_AllShapeAttributes) ValidateWithPath(path string) error {
	if _ede := _afeg.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _ede != nil {
		return _ede
	}
	if _add := _afeg.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _add != nil {
		return _add
	}
	if _cag := _afeg.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _cag != nil {
		return _cag
	}
	if _dedb := _afeg.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _dedb != nil {
		return _dedb
	}
	if _dec := _afeg.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _dec != nil {
		return _dec
	}
	if _gefd := _afeg.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _gefd != nil {
		return _gefd
	}
	if _cbga := _afeg.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _cbga != nil {
		return _cbga
	}
	if _bcde := _afeg.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _bcde != nil {
		return _bcde
	}
	if _bbde := _afeg.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _bbde != nil {
		return _bbde
	}
	if _cgg := _afeg.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _cgg != nil {
		return _cgg
	}
	if _fcg := _afeg.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _fcg != nil {
		return _fcg
	}
	if _cfag := _afeg.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _cfag != nil {
		return _cfag
	}
	if _cfd := _afeg.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _cfd != nil {
		return _cfd
	}
	return nil
}
func (_dbcec ST_FillMethod) String() string {
	switch _dbcec {
	case 0:
		return ""
	case 1:
		return "none"
	case 2:
		return "linear"
	case 3:
		return "sigma"
	case 4:
		return "any"
	case 5:
		return "linear\u0020sigma"
	}
	return ""
}
func (_ffceca *OfcCT_ColorMenu) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bgdcd := range start.Attr {
		if _bgdcd.Name.Local == "strokecolor" {
			_abca, _dbeg := _bgdcd.Value, error(nil)
			if _dbeg != nil {
				return _dbeg
			}
			_ffceca.StrokecolorAttr = &_abca
			continue
		}
		if _bgdcd.Name.Local == "fillcolor" {
			_bddb, _gageb := _bgdcd.Value, error(nil)
			if _gageb != nil {
				return _gageb
			}
			_ffceca.FillcolorAttr = &_bddb
			continue
		}
		if _bgdcd.Name.Local == "shadowcolor" {
			_eeeg, _gaeeg := _bgdcd.Value, error(nil)
			if _gaeeg != nil {
				return _gaeeg
			}
			_ffceca.ShadowcolorAttr = &_eeeg
			continue
		}
		if _bgdcd.Name.Local == "extrusioncolor" {
			_ffda, _cfdeg := _bgdcd.Value, error(nil)
			if _cfdeg != nil {
				return _cfdeg
			}
			_ffceca.ExtrusioncolorAttr = &_ffda
			continue
		}
		if _bgdcd.Name.Local == "ext" {
			_ffceca.ExtAttr.UnmarshalXMLAttr(_bgdcd)
			continue
		}
	}
	for {
		_eafgd, _gaafe := d.Token()
		if _gaafe != nil {
			return _f.Errorf("parsing OfcCT_ColorMenu:\u0020\u0025s", _gaafe)
		}
		if _bcafa, _cbagg := _eafgd.(_b.EndElement); _cbagg && _bcafa.Name == start.Name {
			break
		}
	}
	return nil
}

type OfcCT_ColorMru struct {
	ColorsAttr *string
	ExtAttr    ST_Ext
}

func (_cbcfa OfcST_DiagramLayout) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_cbcfa.String(), start)
}
func (_bacbe *OfcST_ExtrusionPlane) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gfdeba, _bbga := d.Token()
	if _bbga != nil {
		return _bbga
	}
	if _afab, _dgefce := _gfdeba.(_b.EndElement); _dgefce && _afab.Name == start.Name {
		*_bacbe = 1
		return nil
	}
	if _edae, _agfbec := _gfdeba.(_b.CharData); !_agfbec {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gfdeba)
	} else {
		switch string(_edae) {
		case "":
			*_bacbe = 0
		case "XY":
			*_bacbe = 1
		case "ZX":
			*_bacbe = 2
		case "YZ":
			*_bacbe = 3
		}
	}
	_gfdeba, _bbga = d.Token()
	if _bbga != nil {
		return _bbga
	}
	if _efgef, _cedef := _gfdeba.(_b.EndElement); _cedef && _efgef.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gfdeba)
}
func (_gbdae OfcST_HrAlign) Validate() error { return _gbdae.ValidateWithPath("") }
func (_ggccd *OfcClippath) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:clippath"
	return _ggccd.OfcCT_ClipPath.MarshalXML(e, start)
}
func (_gccc ST_FillMethod) ValidateWithPath(path string) error {
	switch _gccc {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_gccc))
	}
	return nil
}

const (
	ST_StrokeLineStyleUnset            ST_StrokeLineStyle = 0
	ST_StrokeLineStyleSingle           ST_StrokeLineStyle = 1
	ST_StrokeLineStyleThinThin         ST_StrokeLineStyle = 2
	ST_StrokeLineStyleThinThick        ST_StrokeLineStyle = 3
	ST_StrokeLineStyleThickThin        ST_StrokeLineStyle = 4
	ST_StrokeLineStyleThickBetweenThin ST_StrokeLineStyle = 5
)

func (_ffbef *ST_StrokeArrowType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gabgg, _aagec := d.Token()
	if _aagec != nil {
		return _aagec
	}
	if _egcbdc, _efebbg := _gabgg.(_b.EndElement); _efebbg && _egcbdc.Name == start.Name {
		*_ffbef = 1
		return nil
	}
	if _fgcca, _ddecf := _gabgg.(_b.CharData); !_ddecf {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _gabgg)
	} else {
		switch string(_fgcca) {
		case "":
			*_ffbef = 0
		case "none":
			*_ffbef = 1
		case "block":
			*_ffbef = 2
		case "classic":
			*_ffbef = 3
		case "oval":
			*_ffbef = 4
		case "diamond":
			*_ffbef = 5
		case "open":
			*_ffbef = 6
		}
	}
	_gabgg, _aagec = d.Token()
	if _aagec != nil {
		return _aagec
	}
	if _ebffd, _ecaec := _gabgg.(_b.EndElement); _ecaec && _ebffd.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _gabgg)
}

type OfcCT_Ink struct {
	IAttr           *string
	AnnotationAttr  _eb.ST_TrueFalse
	ContentTypeAttr *string
}

// Validate validates the Oval and its children
func (_aggbbe *Oval) Validate() error { return _aggbbe.ValidateWithPath("Oval") }

type OfcOLEObject struct{ OfcCT_OLEObject }
type OfcST_OLEType byte

func NewFormulas() *Formulas {
	_dffdg := &Formulas{}
	_dffdg.CT_Formulas = *NewCT_Formulas()
	return _dffdg
}
func (_bdcdf OfcST_InsetMode) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_ecbag := _b.Attr{}
	_ecbag.Name = name
	switch _bdcdf {
	case OfcST_InsetModeUnset:
		_ecbag.Value = ""
	case OfcST_InsetModeAuto:
		_ecbag.Value = "auto"
	case OfcST_InsetModeCustom:
		_ecbag.Value = "custom"
	}
	return _ecbag, nil
}
func (_cfaa *OfcCT_Entry) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dagga := range start.Attr {
		if _dagga.Name.Local == "new" {
			_gfgfd, _gbfbb := _e.ParseInt(_dagga.Value, 10, 32)
			if _gbfbb != nil {
				return _gbfbb
			}
			_ecdga := int32(_gfgfd)
			_cfaa.NewAttr = &_ecdga
			continue
		}
		if _dagga.Name.Local == "old" {
			_ccdff, _gbaabf := _e.ParseInt(_dagga.Value, 10, 32)
			if _gbaabf != nil {
				return _gbaabf
			}
			_ecdbd := int32(_ccdff)
			_cfaa.OldAttr = &_ecdbd
			continue
		}
	}
	for {
		_decaa, _caaac := d.Token()
		if _caaac != nil {
			return _f.Errorf("parsing\u0020OfcCT_Entry:\u0020\u0025s", _caaac)
		}
		if _dgddg, _edgg := _decaa.(_b.EndElement); _edgg && _dgddg.Name == start.Name {
			break
		}
	}
	return nil
}

type OfcST_ConnectType byte

func (_gecba *OfcST_ScreenSize) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_gecba = 0
	case "544\u002c376":
		*_gecba = 1
	case "640\u002c480":
		*_gecba = 2
	case "720\u002c512":
		*_gecba = 3
	case "800\u002c600":
		*_gecba = 4
	case "1024\u002c768":
		*_gecba = 5
	case "1152\u002c862":
		*_gecba = 6
	}
	return nil
}
func (_ffcgb *OfcCT_ShapeLayout) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ggdbe := range start.Attr {
		if _ggdbe.Name.Local == "ext" {
			_ffcgb.ExtAttr.UnmarshalXMLAttr(_ggdbe)
			continue
		}
	}
_fbbgg:
	for {
		_bgecg, _ccdgfd := d.Token()
		if _ccdgfd != nil {
			return _ccdgfd
		}
		switch _gcaaa := _bgecg.(type) {
		case _b.StartElement:
			switch _gcaaa.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "idmap"}:
				_ffcgb.Idmap = NewOfcCT_IdMap()
				if _fccbb := d.DecodeElement(_ffcgb.Idmap, &_gcaaa); _fccbb != nil {
					return _fccbb
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "regrouptable"}:
				_ffcgb.Regrouptable = NewOfcCT_RegroupTable()
				if _afecd := d.DecodeElement(_ffcgb.Regrouptable, &_gcaaa); _afecd != nil {
					return _afecd
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "rules"}:
				_ffcgb.Rules = NewOfcCT_Rules()
				if _cccd := d.DecodeElement(_ffcgb.Rules, &_gcaaa); _cccd != nil {
					return _cccd
				}
			default:
				_ba.Log("skipping unsupported\u0020element\u0020on\u0020OfcCT_ShapeLayout\u0020\u0025v", _gcaaa.Name)
				if _eeccba := d.Skip(); _eeccba != nil {
					return _eeccba
				}
			}
		case _b.EndElement:
			break _fbbgg
		case _b.CharData:
		}
	}
	return nil
}
func (_bebdg *OfcCT_OLEObject) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _fcec := range start.Attr {
		if _fcec.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _fcec.Name.Local == "id" || _fcec.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _fcec.Name.Local == "id" {
			_fagdc, _gdffa := _fcec.Value, error(nil)
			if _gdffa != nil {
				return _gdffa
			}
			_bebdg.IdAttr = &_fagdc
			continue
		}
		if _fcec.Name.Local == "Type" {
			_bebdg.TypeAttr.UnmarshalXMLAttr(_fcec)
			continue
		}
		if _fcec.Name.Local == "ProgID" {
			_gbddf, _dagfc := _fcec.Value, error(nil)
			if _dagfc != nil {
				return _dagfc
			}
			_bebdg.ProgIDAttr = &_gbddf
			continue
		}
		if _fcec.Name.Local == "ShapeID" {
			_ecbgc, _gcbgg := _fcec.Value, error(nil)
			if _gcbgg != nil {
				return _gcbgg
			}
			_bebdg.ShapeIDAttr = &_ecbgc
			continue
		}
		if _fcec.Name.Local == "DrawAspect" {
			_bebdg.DrawAspectAttr.UnmarshalXMLAttr(_fcec)
			continue
		}
		if _fcec.Name.Local == "ObjectID" {
			_fbcdc, _fddbff := _fcec.Value, error(nil)
			if _fddbff != nil {
				return _fddbff
			}
			_bebdg.ObjectIDAttr = &_fbcdc
			continue
		}
		if _fcec.Name.Local == "UpdateMode" {
			_bebdg.UpdateModeAttr.UnmarshalXMLAttr(_fcec)
			continue
		}
	}
_cacde:
	for {
		_ebcf, _fbece := d.Token()
		if _fbece != nil {
			return _fbece
		}
		switch _bfbdc := _ebcf.(type) {
		case _b.StartElement:
			switch _bfbdc.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "LinkType"}:
				_bebdg.LinkType = new(string)
				if _ceaae := d.DecodeElement(_bebdg.LinkType, &_bfbdc); _ceaae != nil {
					return _ceaae
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "LockedField"}:
				_bebdg.LockedField = _eb.ST_TrueFalseBlankUnset
				if _gggbcc := d.DecodeElement(&_bebdg.LockedField, &_bfbdc); _gggbcc != nil {
					return _gggbcc
				}
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "FieldCodes"}:
				_bebdg.FieldCodes = new(string)
				if _ccgfe := d.DecodeElement(_bebdg.FieldCodes, &_bfbdc); _ccgfe != nil {
					return _ccgfe
				}
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020OfcCT_OLEObject\u0020\u0025v", _bfbdc.Name)
				if _abedfc := d.Skip(); _abedfc != nil {
					return _abedfc
				}
			}
		case _b.EndElement:
			break _cacde
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the OfcCT_Complex and its children, prefixing error messages with path
func (_cbgdc *OfcCT_Complex) ValidateWithPath(path string) error {
	if _gdfgf := _cbgdc.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _gdfgf != nil {
		return _gdfgf
	}
	return nil
}
func (_bgbc OfcST_ConnectType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_dbfee := _b.Attr{}
	_dbfee.Name = name
	switch _bgbc {
	case OfcST_ConnectTypeUnset:
		_dbfee.Value = ""
	case OfcST_ConnectTypeNone:
		_dbfee.Value = "none"
	case OfcST_ConnectTypeRect:
		_dbfee.Value = "rect"
	case OfcST_ConnectTypeSegments:
		_dbfee.Value = "segments"
	case OfcST_ConnectTypeCustom:
		_dbfee.Value = "custom"
	}
	return _dbfee, nil
}
func (_ccca *CT_Curve) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ccca.FromAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "from"}, Value: _f.Sprintf("\u0025v", *_ccca.FromAttr)})
	}
	if _ccca.Control1Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "control1"}, Value: _f.Sprintf("\u0025v", *_ccca.Control1Attr)})
	}
	if _ccca.Control2Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "control2"}, Value: _f.Sprintf("\u0025v", *_ccca.Control2Attr)})
	}
	if _ccca.ToAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "to"}, Value: _f.Sprintf("\u0025v", *_ccca.ToAttr)})
	}
	if _ccca.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_ccca.HrefAttr)})
	}
	if _ccca.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_ccca.TargetAttr)})
	}
	if _ccca.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_ccca.ClassAttr)})
	}
	if _ccca.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_ccca.TitleAttr)})
	}
	if _ccca.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_ccca.AltAttr)})
	}
	if _ccca.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_ccca.CoordsizeAttr)})
	}
	if _ccca.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_ccca.CoordoriginAttr)})
	}
	if _ccca.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_ccca.WrapcoordsAttr)})
	}
	if _ccca.PrintAttr != _eb.ST_TrueFalseUnset {
		_fagc, _dbgg := _ccca.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _dbgg != nil {
			return _dbgg
		}
		start.Attr = append(start.Attr, _fagc)
	}
	if _ccca.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_ccca.IdAttr)})
	}
	if _ccca.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_ccca.StyleAttr)})
	}
	if _ccca.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_ccca.SpidAttr)})
	}
	if _ccca.OnedAttr != _eb.ST_TrueFalseUnset {
		_gdab, _edgac := _ccca.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _edgac != nil {
			return _edgac
		}
		start.Attr = append(start.Attr, _gdab)
	}
	if _ccca.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_ccca.RegroupidAttr)})
	}
	if _ccca.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_ffabg, _gebeg := _ccca.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _gebeg != nil {
			return _gebeg
		}
		start.Attr = append(start.Attr, _ffabg)
	}
	if _ccca.ButtonAttr != _eb.ST_TrueFalseUnset {
		_dabgg, _bgb := _ccca.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _bgb != nil {
			return _bgb
		}
		start.Attr = append(start.Attr, _dabgg)
	}
	if _ccca.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_bea, _adee := _ccca.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _adee != nil {
			return _adee
		}
		start.Attr = append(start.Attr, _bea)
	}
	if _ccca.BulletAttr != _eb.ST_TrueFalseUnset {
		_fdcee, _eeda := _ccca.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _eeda != nil {
			return _eeda
		}
		start.Attr = append(start.Attr, _fdcee)
	}
	if _ccca.HrAttr != _eb.ST_TrueFalseUnset {
		_gccg, _gdae := _ccca.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _gdae != nil {
			return _gdae
		}
		start.Attr = append(start.Attr, _gccg)
	}
	if _ccca.HrstdAttr != _eb.ST_TrueFalseUnset {
		_bdff, _fbbd := _ccca.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _fbbd != nil {
			return _fbbd
		}
		start.Attr = append(start.Attr, _bdff)
	}
	if _ccca.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_bbda, _afba := _ccca.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _afba != nil {
			return _afba
		}
		start.Attr = append(start.Attr, _bbda)
	}
	if _ccca.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_ccca.HrpctAttr)})
	}
	if _ccca.HralignAttr != OfcST_HrAlignUnset {
		_eaeg, _bcga := _ccca.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _bcga != nil {
			return _bcga
		}
		start.Attr = append(start.Attr, _eaeg)
	}
	if _ccca.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_dfda, _dfgfd := _ccca.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _dfgfd != nil {
			return _dfgfd
		}
		start.Attr = append(start.Attr, _dfda)
	}
	if _ccca.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_cbcdd, _ebf := _ccca.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _ebf != nil {
			return _ebf
		}
		start.Attr = append(start.Attr, _cbcdd)
	}
	if _ccca.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_bdcf, _adab := _ccca.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _adab != nil {
			return _adab
		}
		start.Attr = append(start.Attr, _bdcf)
	}
	if _ccca.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_ccca.BordertopcolorAttr)})
	}
	if _ccca.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_ccca.BorderleftcolorAttr)})
	}
	if _ccca.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_ccca.BorderbottomcolorAttr)})
	}
	if _ccca.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_ccca.BorderrightcolorAttr)})
	}
	if _ccca.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_bbgcg, _daga := _ccca.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _daga != nil {
			return _daga
		}
		start.Attr = append(start.Attr, _bbgcg)
	}
	if _ccca.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_ccca.DgmnodekindAttr)})
	}
	if _ccca.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_gbda, _bfad := _ccca.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _bfad != nil {
			return _bfad
		}
		start.Attr = append(start.Attr, _gbda)
	}
	if _ccca.InsetmodeAttr != OfcST_InsetModeUnset {
		_gaaa, _eddd := _ccca.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _eddd != nil {
			return _eddd
		}
		start.Attr = append(start.Attr, _gaaa)
	}
	if _ccca.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_ccca.OpacityAttr)})
	}
	if _ccca.StrokedAttr != _eb.ST_TrueFalseUnset {
		_cgda, _bfaa := _ccca.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _bfaa != nil {
			return _bfaa
		}
		start.Attr = append(start.Attr, _cgda)
	}
	if _ccca.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_ccca.StrokecolorAttr)})
	}
	if _ccca.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_ccca.StrokeweightAttr)})
	}
	if _ccca.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_cbba, _gadd := _ccca.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _gadd != nil {
			return _gadd
		}
		start.Attr = append(start.Attr, _cbba)
	}
	if _ccca.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_ccca.ChromakeyAttr)})
	}
	if _ccca.FilledAttr != _eb.ST_TrueFalseUnset {
		_bfca, _dcgc := _ccca.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _dcgc != nil {
			return _dcgc
		}
		start.Attr = append(start.Attr, _bfca)
	}
	if _ccca.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_ccca.FillcolorAttr)})
	}
	if _ccca.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_ccca.SptAttr)})
	}
	if _ccca.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_bef, _fgbc := _ccca.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _fgbc != nil {
			return _fgbc
		}
		start.Attr = append(start.Attr, _bef)
	}
	if _ccca.BwmodeAttr != OfcST_BWModeUnset {
		_efdc, _effbf := _ccca.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _effbf != nil {
			return _effbf
		}
		start.Attr = append(start.Attr, _efdc)
	}
	if _ccca.BwpureAttr != OfcST_BWModeUnset {
		_cacf, _cbfdd := _ccca.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _cbfdd != nil {
			return _cbfdd
		}
		start.Attr = append(start.Attr, _cacf)
	}
	if _ccca.BwnormalAttr != OfcST_BWModeUnset {
		_fdge, _dgbe := _ccca.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _dgbe != nil {
			return _dgbe
		}
		start.Attr = append(start.Attr, _fdge)
	}
	if _ccca.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_ceed, _aceb := _ccca.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _aceb != nil {
			return _aceb
		}
		start.Attr = append(start.Attr, _ceed)
	}
	if _ccca.OleiconAttr != _eb.ST_TrueFalseUnset {
		_gbab, _acfe := _ccca.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _acfe != nil {
			return _acfe
		}
		start.Attr = append(start.Attr, _gbab)
	}
	if _ccca.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_dgbeg, _ceeb := _ccca.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _ceeb != nil {
			return _ceeb
		}
		start.Attr = append(start.Attr, _dgbeg)
	}
	if _ccca.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_dccde, _dege := _ccca.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _dege != nil {
			return _dege
		}
		start.Attr = append(start.Attr, _dccde)
	}
	if _ccca.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_cbff, _fddd := _ccca.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _fddd != nil {
			return _fddd
		}
		start.Attr = append(start.Attr, _cbff)
	}
	if _ccca.ClipAttr != _eb.ST_TrueFalseUnset {
		_cfee, _badb := _ccca.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _badb != nil {
			return _badb
		}
		start.Attr = append(start.Attr, _cfee)
	}
	e.EncodeToken(start)
	if _ccca.EG_ShapeElements != nil {
		for _, _gafd := range _ccca.EG_ShapeElements {
			_gafd.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_aecaa *OfcCT_IdMap) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _aecaa.DataAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "data"}, Value: _f.Sprintf("\u0025v", *_aecaa.DataAttr)})
	}
	if _aecaa.ExtAttr != ST_ExtUnset {
		_bceda, _bbgcaa := _aecaa.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _bbgcaa != nil {
			return _bbgcaa
		}
		start.Attr = append(start.Attr, _bceda)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_ddgb *Arc) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ddgb.CT_Arc = *NewCT_Arc()
	for _, _eegg := range start.Attr {
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "userdrawn" {
			_ddgb.UserdrawnAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "button" {
			_ddgb.ButtonAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "dgmlayoutmru" {
			_ddgb.DgmlayoutmruAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "userhidden" {
			_ddgb.UserhiddenAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "cliptowrap" {
			_ddgb.CliptowrapAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "bullet" {
			_ddgb.BulletAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "ole" {
			_ddgb.OleAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "hr" {
			_ddgb.HrAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "spid" {
			_eaf, _ebea := _eegg.Value, error(nil)
			if _ebea != nil {
				return _ebea
			}
			_ddgb.SpidAttr = &_eaf
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "hrstd" {
			_ddgb.HrstdAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "bwnormal" {
			_ddgb.BwnormalAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "bordertopcolor" {
			_ecgd, _cbe := _eegg.Value, error(nil)
			if _cbe != nil {
				return _cbe
			}
			_ddgb.BordertopcolorAttr = &_ecgd
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "dgmlayout" {
			_ddgb.DgmlayoutAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "forcedash" {
			_ddgb.ForcedashAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "allowoverlap" {
			_ddgb.AllowoverlapAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "hrnoshade" {
			_ddgb.HrnoshadeAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "preferrelative" {
			_ddgb.PreferrelativeAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "borderbottomcolor" {
			_afcf, _aadd := _eegg.Value, error(nil)
			if _aadd != nil {
				return _aadd
			}
			_ddgb.BorderbottomcolorAttr = &_afcf
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "oned" {
			_ddgb.OnedAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "dgmnodekind" {
			_fgge, _cabc := _e.ParseInt(_eegg.Value, 10, 64)
			if _cabc != nil {
				return _cabc
			}
			_ddgb.DgmnodekindAttr = &_fgge
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "regroupid" {
			_dceg, _cbcdf := _e.ParseInt(_eegg.Value, 10, 64)
			if _cbcdf != nil {
				return _cbcdf
			}
			_ddgb.RegroupidAttr = &_dceg
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "allowincell" {
			_ddgb.AllowincellAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "hrpct" {
			_bdbga, _gafg := _e.ParseFloat(_eegg.Value, 64)
			if _gafg != nil {
				return _gafg
			}
			_eacb := float32(_bdbga)
			_ddgb.HrpctAttr = &_eacb
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "clip" {
			_ddgb.ClipAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "insetmode" {
			_ddgb.InsetmodeAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "borderleftcolor" {
			_dfed, _adgg := _eegg.Value, error(nil)
			if _adgg != nil {
				return _adgg
			}
			_ddgb.BorderleftcolorAttr = &_dfed
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "oleicon" {
			_ddgb.OleiconAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "borderrightcolor" {
			_eeaf, _cdde := _eegg.Value, error(nil)
			if _cdde != nil {
				return _cdde
			}
			_ddgb.BorderrightcolorAttr = &_eeaf
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "connectortype" {
			_ddgb.ConnectortypeAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "bwpure" {
			_ddgb.BwpureAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "bwmode" {
			_ddgb.BwmodeAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "spt" {
			_bfgc, _eafa := _e.ParseFloat(_eegg.Value, 64)
			if _eafa != nil {
				return _eafa
			}
			_ecbg := float32(_bfgc)
			_ddgb.SptAttr = &_ecbg
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "doubleclicknotify" {
			_ddgb.DoubleclicknotifyAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _eegg.Name.Local == "hralign" {
			_ddgb.HralignAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Local == "endAngle" {
			_fbcc, _abff := _e.ParseFloat(_eegg.Value, 64)
			if _abff != nil {
				return _abff
			}
			_ddgb.EndAngleAttr = &_fbcc
			continue
		}
		if _eegg.Name.Local == "id" {
			_dcc, _eede := _eegg.Value, error(nil)
			if _eede != nil {
				return _eede
			}
			_ddgb.IdAttr = &_dcc
			continue
		}
		if _eegg.Name.Local == "alt" {
			_fffb, _cbfd := _eegg.Value, error(nil)
			if _cbfd != nil {
				return _cbfd
			}
			_ddgb.AltAttr = &_fffb
			continue
		}
		if _eegg.Name.Local == "print" {
			_ddgb.PrintAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Local == "stroked" {
			_ddgb.StrokedAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Local == "wrapcoords" {
			_dbba, _dbc := _eegg.Value, error(nil)
			if _dbc != nil {
				return _dbc
			}
			_ddgb.WrapcoordsAttr = &_dbba
			continue
		}
		if _eegg.Name.Local == "strokeweight" {
			_gdcc, _bcef := _eegg.Value, error(nil)
			if _bcef != nil {
				return _bcef
			}
			_ddgb.StrokeweightAttr = &_gdcc
			continue
		}
		if _eegg.Name.Local == "coordorigin" {
			_fafd, _ead := _eegg.Value, error(nil)
			if _ead != nil {
				return _ead
			}
			_ddgb.CoordoriginAttr = &_fafd
			continue
		}
		if _eegg.Name.Local == "chromakey" {
			_cbag, _cdgc := _eegg.Value, error(nil)
			if _cdgc != nil {
				return _cdgc
			}
			_ddgb.ChromakeyAttr = &_cbag
			continue
		}
		if _eegg.Name.Local == "fillcolor" {
			_ceb, _bffc := _eegg.Value, error(nil)
			if _bffc != nil {
				return _bffc
			}
			_ddgb.FillcolorAttr = &_ceb
			continue
		}
		if _eegg.Name.Local == "style" {
			_edge, _agfec := _eegg.Value, error(nil)
			if _agfec != nil {
				return _agfec
			}
			_ddgb.StyleAttr = &_edge
			continue
		}
		if _eegg.Name.Local == "opacity" {
			_fef, _fgf := _eegg.Value, error(nil)
			if _fgf != nil {
				return _fgf
			}
			_ddgb.OpacityAttr = &_fef
			continue
		}
		if _eegg.Name.Local == "strokecolor" {
			_gagd, _eaac := _eegg.Value, error(nil)
			if _eaac != nil {
				return _eaac
			}
			_ddgb.StrokecolorAttr = &_gagd
			continue
		}
		if _eegg.Name.Local == "insetpen" {
			_ddgb.InsetpenAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
		if _eegg.Name.Local == "startAngle" {
			_cdgbg, _acfb := _e.ParseFloat(_eegg.Value, 64)
			if _acfb != nil {
				return _acfb
			}
			_ddgb.StartAngleAttr = &_cdgbg
			continue
		}
		if _eegg.Name.Local == "coordsize" {
			_bcab, _fcc := _eegg.Value, error(nil)
			if _fcc != nil {
				return _fcc
			}
			_ddgb.CoordsizeAttr = &_bcab
			continue
		}
		if _eegg.Name.Local == "title" {
			_gdbf, _gddb := _eegg.Value, error(nil)
			if _gddb != nil {
				return _gddb
			}
			_ddgb.TitleAttr = &_gdbf
			continue
		}
		if _eegg.Name.Local == "class" {
			_acaa, _fag := _eegg.Value, error(nil)
			if _fag != nil {
				return _fag
			}
			_ddgb.ClassAttr = &_acaa
			continue
		}
		if _eegg.Name.Local == "target" {
			_fadf, _bcdcg := _eegg.Value, error(nil)
			if _bcdcg != nil {
				return _bcdcg
			}
			_ddgb.TargetAttr = &_fadf
			continue
		}
		if _eegg.Name.Local == "href" {
			_abge, _bfgcc := _eegg.Value, error(nil)
			if _bfgcc != nil {
				return _bfgcc
			}
			_ddgb.HrefAttr = &_abge
			continue
		}
		if _eegg.Name.Local == "filled" {
			_ddgb.FilledAttr.UnmarshalXMLAttr(_eegg)
			continue
		}
	}
_bbdf:
	for {
		_gabb, _bcf := d.Token()
		if _bcf != nil {
			return _bcf
		}
		switch _bbbg := _gabb.(type) {
		case _b.StartElement:
			switch _bbbg.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_dcde := NewEG_ShapeElements()
				_dcde.Path = NewPath()
				if _gda := d.DecodeElement(_dcde.Path, &_bbbg); _gda != nil {
					return _gda
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _dcde)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_efd := NewEG_ShapeElements()
				_efd.Formulas = NewFormulas()
				if _gffd := d.DecodeElement(_efd.Formulas, &_bbbg); _gffd != nil {
					return _gffd
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _efd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_fgfa := NewEG_ShapeElements()
				_fgfa.Handles = NewHandles()
				if _caeae := d.DecodeElement(_fgfa.Handles, &_bbbg); _caeae != nil {
					return _caeae
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _fgfa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_dbfe := NewEG_ShapeElements()
				_dbfe.Fill = NewFill()
				if _gdg := d.DecodeElement(_dbfe.Fill, &_bbbg); _gdg != nil {
					return _gdg
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _dbfe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_efabe := NewEG_ShapeElements()
				_efabe.Stroke = NewStroke()
				if _fade := d.DecodeElement(_efabe.Stroke, &_bbbg); _fade != nil {
					return _fade
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _efabe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_dbbb := NewEG_ShapeElements()
				_dbbb.Shadow = NewShadow()
				if _eefa := d.DecodeElement(_dbbb.Shadow, &_bbbg); _eefa != nil {
					return _eefa
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _dbbb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_aedc := NewEG_ShapeElements()
				_aedc.Textbox = NewTextbox()
				if _agcg := d.DecodeElement(_aedc.Textbox, &_bbbg); _agcg != nil {
					return _agcg
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _aedc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_ageec := NewEG_ShapeElements()
				_ageec.Textpath = NewTextpath()
				if _edfee := d.DecodeElement(_ageec.Textpath, &_bbbg); _edfee != nil {
					return _edfee
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _ageec)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_effb := NewEG_ShapeElements()
				_effb.Imagedata = NewImagedata()
				if _cbcec := d.DecodeElement(_effb.Imagedata, &_bbbg); _cbcec != nil {
					return _cbcec
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _effb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_efabb := NewEG_ShapeElements()
				_efabb.Skew = NewOfcSkew()
				if _bgf := d.DecodeElement(_efabb.Skew, &_bbbg); _bgf != nil {
					return _bgf
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _efabb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_cgea := NewEG_ShapeElements()
				_cgea.Extrusion = NewOfcExtrusion()
				if _dfg := d.DecodeElement(_cgea.Extrusion, &_bbbg); _dfg != nil {
					return _dfg
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _cgea)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_gfcd := NewEG_ShapeElements()
				_gfcd.Callout = NewOfcCallout()
				if _baee := d.DecodeElement(_gfcd.Callout, &_bbbg); _baee != nil {
					return _baee
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _gfcd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_cdc := NewEG_ShapeElements()
				_cdc.Lock = NewOfcLock()
				if _edga := d.DecodeElement(_cdc.Lock, &_bbbg); _edga != nil {
					return _edga
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _cdc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_bga := NewEG_ShapeElements()
				_bga.Clippath = NewOfcClippath()
				if _aabf := d.DecodeElement(_bga.Clippath, &_bbbg); _aabf != nil {
					return _aabf
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _bga)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_edac := NewEG_ShapeElements()
				_edac.Signatureline = NewOfcSignatureline()
				if _gddd := d.DecodeElement(_edac.Signatureline, &_bbbg); _gddd != nil {
					return _gddd
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _edac)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_dcdf := NewEG_ShapeElements()
				_dcdf.Wrap = _a.NewWrap()
				if _ecba := d.DecodeElement(_dcdf.Wrap, &_bbbg); _ecba != nil {
					return _ecba
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _dcdf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_dcg := NewEG_ShapeElements()
				_dcg.Anchorlock = _a.NewAnchorlock()
				if _gcg := d.DecodeElement(_dcg.Anchorlock, &_bbbg); _gcg != nil {
					return _gcg
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _dcg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_acdc := NewEG_ShapeElements()
				_acdc.Bordertop = _a.NewBordertop()
				if _bde := d.DecodeElement(_acdc.Bordertop, &_bbbg); _bde != nil {
					return _bde
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _acdc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_ecgg := NewEG_ShapeElements()
				_ecgg.Borderbottom = _a.NewBorderbottom()
				if _cbbc := d.DecodeElement(_ecgg.Borderbottom, &_bbbg); _cbbc != nil {
					return _cbbc
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _ecgg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_deaab := NewEG_ShapeElements()
				_deaab.Borderleft = _a.NewBorderleft()
				if _baeeb := d.DecodeElement(_deaab.Borderleft, &_bbbg); _baeeb != nil {
					return _baeeb
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _deaab)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_cdgg := NewEG_ShapeElements()
				_cdgg.Borderright = _a.NewBorderright()
				if _gfaf := d.DecodeElement(_cdgg.Borderright, &_bbbg); _gfaf != nil {
					return _gfaf
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _cdgg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_edb := NewEG_ShapeElements()
				_edb.ClientData = _c.NewClientData()
				if _cdbbg := d.DecodeElement(_edb.ClientData, &_bbbg); _cdbbg != nil {
					return _cdbbg
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _edb)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_egcg := NewEG_ShapeElements()
				_egcg.Textdata = _bf.NewTextdata()
				if _ebb := d.DecodeElement(_egcg.Textdata, &_bbbg); _ebb != nil {
					return _ebb
				}
				_ddgb.EG_ShapeElements = append(_ddgb.EG_ShapeElements, _egcg)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Arc\u0020\u0025v", _bbbg.Name)
				if _gfg := d.Skip(); _gfg != nil {
					return _gfg
				}
			}
		case _b.EndElement:
			break _bbdf
		case _b.CharData:
		}
	}
	return nil
}
func NewOfcClippath() *OfcClippath {
	_agabb := &OfcClippath{}
	_agabb.OfcCT_ClipPath = *NewOfcCT_ClipPath()
	return _agabb
}
func (_bfa *AG_Adj) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bfa.AdjAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "adj"}, Value: _f.Sprintf("\u0025v", *_bfa.AdjAttr)})
	}
	return nil
}

// ValidateWithPath validates the AG_Id and its children, prefixing error messages with path
func (_bae *AG_Id) ValidateWithPath(path string) error { return nil }

type OfcCT_RelationTable struct {
	Rel     []*OfcCT_Relation
	ExtAttr ST_Ext
}

// ValidateWithPath validates the OfcCT_ClipPath and its children, prefixing error messages with path
func (_fdbdcg *OfcCT_ClipPath) ValidateWithPath(path string) error { return nil }

// ValidateWithPath validates the OfcCT_R and its children, prefixing error messages with path
func (_afdec *OfcCT_R) ValidateWithPath(path string) error {
	if _eeacab := _afdec.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _eeacab != nil {
		return _eeacab
	}
	if _eaafg := _afdec.HowAttr.ValidateWithPath(path + "\u002fHowAttr"); _eaafg != nil {
		return _eaafg
	}
	for _aedaf, _adcbc := range _afdec.Proxy {
		if _ceaea := _adcbc.ValidateWithPath(_f.Sprintf("\u0025s\u002fProxy\u005b\u0025d\u005d", path, _aedaf)); _ceaea != nil {
			return _ceaea
		}
	}
	return nil
}

// Validate validates the OfcShapelayout and its children
func (_aggfc *OfcShapelayout) Validate() error { return _aggfc.ValidateWithPath("OfcShapelayout") }
func (_gdbbb *CT_Shapetype) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ecaeb := range start.Attr {
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "bordertopcolor" {
			_baedd, _ebdbgb := _ecaeb.Value, error(nil)
			if _ebdbgb != nil {
				return _ebdbgb
			}
			_gdbbb.BordertopcolorAttr = &_baedd
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "master" {
			_ceaad, _gcdgg := _ecaeb.Value, error(nil)
			if _gcdgg != nil {
				return _gcdgg
			}
			_gdbbb.MasterAttr = &_ceaad
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "borderleftcolor" {
			_cdbd, _egaa := _ecaeb.Value, error(nil)
			if _egaa != nil {
				return _egaa
			}
			_gdbbb.BorderleftcolorAttr = &_cdbd
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "bullet" {
			_gdbbb.BulletAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "hr" {
			_gdbbb.HrAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "clip" {
			_gdbbb.ClipAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "hrstd" {
			_gdbbb.HrstdAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "spid" {
			_aaebf, _ffcc := _ecaeb.Value, error(nil)
			if _ffcc != nil {
				return _ffcc
			}
			_gdbbb.SpidAttr = &_aaebf
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "hrnoshade" {
			_gdbbb.HrnoshadeAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "regroupid" {
			_bggc, _bbbff := _e.ParseInt(_ecaeb.Value, 10, 64)
			if _bbbff != nil {
				return _bbbff
			}
			_gdbbb.RegroupidAttr = &_bggc
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "dgmlayout" {
			_gdbbb.DgmlayoutAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "cliptowrap" {
			_gdbbb.CliptowrapAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "allowoverlap" {
			_gdbbb.AllowoverlapAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "insetmode" {
			_gdbbb.InsetmodeAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "userhidden" {
			_gdbbb.UserhiddenAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "borderbottomcolor" {
			_cdab, _cfbdg := _ecaeb.Value, error(nil)
			if _cfbdg != nil {
				return _cfbdg
			}
			_gdbbb.BorderbottomcolorAttr = &_cdab
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "bwpure" {
			_gdbbb.BwpureAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "dgmlayoutmru" {
			_gdbbb.DgmlayoutmruAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "preferrelative" {
			_gdbbb.PreferrelativeAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "allowincell" {
			_gdbbb.AllowincellAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "hrpct" {
			_ffag, _dbcfd := _e.ParseFloat(_ecaeb.Value, 64)
			if _dbcfd != nil {
				return _dbcfd
			}
			_fdbbb := float32(_ffag)
			_gdbbb.HrpctAttr = &_fdbbb
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "button" {
			_gdbbb.ButtonAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "userdrawn" {
			_gdbbb.UserdrawnAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "bwnormal" {
			_gdbbb.BwnormalAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "spt" {
			_egfee, _dbgaca := _e.ParseFloat(_ecaeb.Value, 64)
			if _dbgaca != nil {
				return _dbgaca
			}
			_cdgce := float32(_egfee)
			_gdbbb.SptAttr = &_cdgce
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "connectortype" {
			_gdbbb.ConnectortypeAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "borderrightcolor" {
			_fdgdf, _ffabf := _ecaeb.Value, error(nil)
			if _ffabf != nil {
				return _ffabf
			}
			_gdbbb.BorderrightcolorAttr = &_fdgdf
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "oleicon" {
			_gdbbb.OleiconAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "dgmnodekind" {
			_aeaba, _gfddd := _e.ParseInt(_ecaeb.Value, 10, 64)
			if _gfddd != nil {
				return _gfddd
			}
			_gdbbb.DgmnodekindAttr = &_aeaba
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "oned" {
			_gdbbb.OnedAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "bwmode" {
			_gdbbb.BwmodeAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "ole" {
			_gdbbb.OleAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "forcedash" {
			_gdbbb.ForcedashAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "doubleclicknotify" {
			_gdbbb.DoubleclicknotifyAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ecaeb.Name.Local == "hralign" {
			_gdbbb.HralignAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Local == "wrapcoords" {
			_bacbd, _fgea := _ecaeb.Value, error(nil)
			if _fgea != nil {
				return _fgea
			}
			_gdbbb.WrapcoordsAttr = &_bacbd
			continue
		}
		if _ecaeb.Name.Local == "coordsize" {
			_fddca, _gabcc := _ecaeb.Value, error(nil)
			if _gabcc != nil {
				return _gabcc
			}
			_gdbbb.CoordsizeAttr = &_fddca
			continue
		}
		if _ecaeb.Name.Local == "stroked" {
			_gdbbb.StrokedAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Local == "alt" {
			_accf, _eeddg := _ecaeb.Value, error(nil)
			if _eeddg != nil {
				return _eeddg
			}
			_gdbbb.AltAttr = &_accf
			continue
		}
		if _ecaeb.Name.Local == "strokeweight" {
			_aedac, _dfceg := _ecaeb.Value, error(nil)
			if _dfceg != nil {
				return _dfceg
			}
			_gdbbb.StrokeweightAttr = &_aedac
			continue
		}
		if _ecaeb.Name.Local == "style" {
			_gaee, _gfgbc := _ecaeb.Value, error(nil)
			if _gfgbc != nil {
				return _gfgbc
			}
			_gdbbb.StyleAttr = &_gaee
			continue
		}
		if _ecaeb.Name.Local == "chromakey" {
			_fdbaa, _bcfd := _ecaeb.Value, error(nil)
			if _bcfd != nil {
				return _bcfd
			}
			_gdbbb.ChromakeyAttr = &_fdbaa
			continue
		}
		if _ecaeb.Name.Local == "id" {
			_ccefc, _bacce := _ecaeb.Value, error(nil)
			if _bacce != nil {
				return _bacce
			}
			_gdbbb.IdAttr = &_ccefc
			continue
		}
		if _ecaeb.Name.Local == "target" {
			_cdfb, _bgbde := _ecaeb.Value, error(nil)
			if _bgbde != nil {
				return _bgbde
			}
			_gdbbb.TargetAttr = &_cdfb
			continue
		}
		if _ecaeb.Name.Local == "class" {
			_eaeae, _ccdgf := _ecaeb.Value, error(nil)
			if _ccdgf != nil {
				return _ccdgf
			}
			_gdbbb.ClassAttr = &_eaeae
			continue
		}
		if _ecaeb.Name.Local == "insetpen" {
			_gdbbb.InsetpenAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Local == "print" {
			_gdbbb.PrintAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Local == "filled" {
			_gdbbb.FilledAttr.UnmarshalXMLAttr(_ecaeb)
			continue
		}
		if _ecaeb.Name.Local == "strokecolor" {
			_gbcb, _bgfbg := _ecaeb.Value, error(nil)
			if _bgfbg != nil {
				return _bgfbg
			}
			_gdbbb.StrokecolorAttr = &_gbcb
			continue
		}
		if _ecaeb.Name.Local == "title" {
			_bgcfg, _adcfag := _ecaeb.Value, error(nil)
			if _adcfag != nil {
				return _adcfag
			}
			_gdbbb.TitleAttr = &_bgcfg
			continue
		}
		if _ecaeb.Name.Local == "opacity" {
			_ggdec, _adff := _ecaeb.Value, error(nil)
			if _adff != nil {
				return _adff
			}
			_gdbbb.OpacityAttr = &_ggdec
			continue
		}
		if _ecaeb.Name.Local == "adj" {
			_gadeg, _fbdfbg := _ecaeb.Value, error(nil)
			if _fbdfbg != nil {
				return _fbdfbg
			}
			_gdbbb.AdjAttr = &_gadeg
			continue
		}
		if _ecaeb.Name.Local == "path" {
			_beeaf, _eebd := _ecaeb.Value, error(nil)
			if _eebd != nil {
				return _eebd
			}
			_gdbbb.PathAttr = &_beeaf
			continue
		}
		if _ecaeb.Name.Local == "href" {
			_ebad, _bgbbb := _ecaeb.Value, error(nil)
			if _bgbbb != nil {
				return _bgbbb
			}
			_gdbbb.HrefAttr = &_ebad
			continue
		}
		if _ecaeb.Name.Local == "coordorigin" {
			_geeff, _gbagg := _ecaeb.Value, error(nil)
			if _gbagg != nil {
				return _gbagg
			}
			_gdbbb.CoordoriginAttr = &_geeff
			continue
		}
		if _ecaeb.Name.Local == "fillcolor" {
			_bacga, _bbgbg := _ecaeb.Value, error(nil)
			if _bbgbg != nil {
				return _bbgbg
			}
			_gdbbb.FillcolorAttr = &_bacga
			continue
		}
	}
_eedfc:
	for {
		_decdf, _fbcfg := d.Token()
		if _fbcfg != nil {
			return _fbcfg
		}
		switch _fdfe := _decdf.(type) {
		case _b.StartElement:
			switch _fdfe.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_eagbb := NewEG_ShapeElements()
				_eagbb.Path = NewPath()
				if _agagd := d.DecodeElement(_eagbb.Path, &_fdfe); _agagd != nil {
					return _agagd
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _eagbb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_gcgdf := NewEG_ShapeElements()
				_gcgdf.Formulas = NewFormulas()
				if _bbfdg := d.DecodeElement(_gcgdf.Formulas, &_fdfe); _bbfdg != nil {
					return _bbfdg
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _gcgdf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_ffaga := NewEG_ShapeElements()
				_ffaga.Handles = NewHandles()
				if _dfaag := d.DecodeElement(_ffaga.Handles, &_fdfe); _dfaag != nil {
					return _dfaag
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _ffaga)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_baeab := NewEG_ShapeElements()
				_baeab.Fill = NewFill()
				if _aecg := d.DecodeElement(_baeab.Fill, &_fdfe); _aecg != nil {
					return _aecg
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _baeab)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_bggaf := NewEG_ShapeElements()
				_bggaf.Stroke = NewStroke()
				if _bfcafb := d.DecodeElement(_bggaf.Stroke, &_fdfe); _bfcafb != nil {
					return _bfcafb
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _bggaf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_bgbded := NewEG_ShapeElements()
				_bgbded.Shadow = NewShadow()
				if _bfafa := d.DecodeElement(_bgbded.Shadow, &_fdfe); _bfafa != nil {
					return _bfafa
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _bgbded)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_gcgabf := NewEG_ShapeElements()
				_gcgabf.Textbox = NewTextbox()
				if _bccg := d.DecodeElement(_gcgabf.Textbox, &_fdfe); _bccg != nil {
					return _bccg
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _gcgabf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_efcca := NewEG_ShapeElements()
				_efcca.Textpath = NewTextpath()
				if _dfbd := d.DecodeElement(_efcca.Textpath, &_fdfe); _dfbd != nil {
					return _dfbd
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _efcca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_dfcga := NewEG_ShapeElements()
				_dfcga.Imagedata = NewImagedata()
				if _dgaa := d.DecodeElement(_dfcga.Imagedata, &_fdfe); _dgaa != nil {
					return _dgaa
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _dfcga)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_fcbd := NewEG_ShapeElements()
				_fcbd.Skew = NewOfcSkew()
				if _cdgda := d.DecodeElement(_fcbd.Skew, &_fdfe); _cdgda != nil {
					return _cdgda
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _fcbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_cfad := NewEG_ShapeElements()
				_cfad.Extrusion = NewOfcExtrusion()
				if _eeccb := d.DecodeElement(_cfad.Extrusion, &_fdfe); _eeccb != nil {
					return _eeccb
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _cfad)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_agda := NewEG_ShapeElements()
				_agda.Callout = NewOfcCallout()
				if _fgfcf := d.DecodeElement(_agda.Callout, &_fdfe); _fgfcf != nil {
					return _fgfcf
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _agda)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_gecff := NewEG_ShapeElements()
				_gecff.Lock = NewOfcLock()
				if _efbbg := d.DecodeElement(_gecff.Lock, &_fdfe); _efbbg != nil {
					return _efbbg
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _gecff)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_cagb := NewEG_ShapeElements()
				_cagb.Clippath = NewOfcClippath()
				if _cbacf := d.DecodeElement(_cagb.Clippath, &_fdfe); _cbacf != nil {
					return _cbacf
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _cagb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_afgd := NewEG_ShapeElements()
				_afgd.Signatureline = NewOfcSignatureline()
				if _edccb := d.DecodeElement(_afgd.Signatureline, &_fdfe); _edccb != nil {
					return _edccb
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _afgd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_gcegf := NewEG_ShapeElements()
				_gcegf.Wrap = _a.NewWrap()
				if _dcabf := d.DecodeElement(_gcegf.Wrap, &_fdfe); _dcabf != nil {
					return _dcabf
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _gcegf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_eeebg := NewEG_ShapeElements()
				_eeebg.Anchorlock = _a.NewAnchorlock()
				if _eafg := d.DecodeElement(_eeebg.Anchorlock, &_fdfe); _eafg != nil {
					return _eafg
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _eeebg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_bbbd := NewEG_ShapeElements()
				_bbbd.Bordertop = _a.NewBordertop()
				if _efecd := d.DecodeElement(_bbbd.Bordertop, &_fdfe); _efecd != nil {
					return _efecd
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _bbbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_ddeda := NewEG_ShapeElements()
				_ddeda.Borderbottom = _a.NewBorderbottom()
				if _cddgb := d.DecodeElement(_ddeda.Borderbottom, &_fdfe); _cddgb != nil {
					return _cddgb
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _ddeda)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_aecge := NewEG_ShapeElements()
				_aecge.Borderleft = _a.NewBorderleft()
				if _cbda := d.DecodeElement(_aecge.Borderleft, &_fdfe); _cbda != nil {
					return _cbda
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _aecge)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_bgbee := NewEG_ShapeElements()
				_bgbee.Borderright = _a.NewBorderright()
				if _ecbec := d.DecodeElement(_bgbee.Borderright, &_fdfe); _ecbec != nil {
					return _ecbec
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _bgbee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_adafd := NewEG_ShapeElements()
				_adafd.ClientData = _c.NewClientData()
				if _afdg := d.DecodeElement(_adafd.ClientData, &_fdfe); _afdg != nil {
					return _afdg
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _adafd)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_ceeff := NewEG_ShapeElements()
				_ceeff.Textdata = _bf.NewTextdata()
				if _edceb := d.DecodeElement(_ceeff.Textdata, &_fdfe); _edceb != nil {
					return _edceb
				}
				_gdbbb.EG_ShapeElements = append(_gdbbb.EG_ShapeElements, _ceeff)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "complex"}:
				_gdbbb.Complex = NewOfcComplex()
				if _effcd := d.DecodeElement(_gdbbb.Complex, &_fdfe); _effcd != nil {
					return _effcd
				}
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Shapetype\u0020\u0025v", _fdfe.Name)
				if _acbeea := d.Skip(); _acbeea != nil {
					return _acbeea
				}
			}
		case _b.EndElement:
			break _eedfc
		case _b.CharData:
		}
	}
	return nil
}

// Validate validates the Image and its children
func (_bcfce *Image) Validate() error { return _bcfce.ValidateWithPath("Image") }

// Validate validates the CT_RoundRect and its children
func (_bedcc *CT_RoundRect) Validate() error { return _bedcc.ValidateWithPath("CT_RoundRect") }

// ValidateWithPath validates the Curve and its children, prefixing error messages with path
func (_ggedf *Curve) ValidateWithPath(path string) error {
	if _cgead := _ggedf.CT_Curve.ValidateWithPath(path); _cgead != nil {
		return _cgead
	}
	return nil
}

type Arc struct{ CT_Arc }

func (_aggf *Background) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_aggf.CT_Background = *NewCT_Background()
	for _, _affa := range start.Attr {
		if _affa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affa.Name.Local == "bwmode" {
			_aggf.BwmodeAttr.UnmarshalXMLAttr(_affa)
			continue
		}
		if _affa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affa.Name.Local == "bwpure" {
			_aggf.BwpureAttr.UnmarshalXMLAttr(_affa)
			continue
		}
		if _affa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affa.Name.Local == "bwnormal" {
			_aggf.BwnormalAttr.UnmarshalXMLAttr(_affa)
			continue
		}
		if _affa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affa.Name.Local == "targetscreensize" {
			_aggf.TargetscreensizeAttr.UnmarshalXMLAttr(_affa)
			continue
		}
		if _affa.Name.Local == "id" {
			_cffb, _ecae := _affa.Value, error(nil)
			if _ecae != nil {
				return _ecae
			}
			_aggf.IdAttr = &_cffb
			continue
		}
		if _affa.Name.Local == "filled" {
			_aggf.FilledAttr.UnmarshalXMLAttr(_affa)
			continue
		}
		if _affa.Name.Local == "fillcolor" {
			_gbba, _fbdd := _affa.Value, error(nil)
			if _fbdd != nil {
				return _fbdd
			}
			_aggf.FillcolorAttr = &_gbba
			continue
		}
	}
_cceg:
	for {
		_bdgc, _deec := d.Token()
		if _deec != nil {
			return _deec
		}
		switch _ddaf := _bdgc.(type) {
		case _b.StartElement:
			switch _ddaf.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_aggf.Fill = NewFill()
				if _fcaf := d.DecodeElement(_aggf.Fill, &_ddaf); _fcaf != nil {
					return _fcaf
				}
			default:
				_ba.Log("skipping unsupported\u0020element\u0020on\u0020Background\u0020\u0025v", _ddaf.Name)
				if _deac := d.Skip(); _deac != nil {
					return _deac
				}
			}
		case _b.EndElement:
			break _cceg
		case _b.CharData:
		}
	}
	return nil
}
func (_ecbd *CT_Fill) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _gafe := range start.Attr {
		if _gafe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gafe.Name.Local == "detectmouseclick" {
			_ecbd.DetectmouseclickAttr.UnmarshalXMLAttr(_gafe)
			continue
		}
		if _gafe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gafe.Name.Local == "relid" {
			_adbe, _ecgf := _gafe.Value, error(nil)
			if _ecgf != nil {
				return _ecgf
			}
			_ecbd.RelidAttr = &_adbe
			continue
		}
		if _gafe.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _gafe.Name.Local == "id" || _gafe.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _gafe.Name.Local == "id" {
			_dgcec, _ecffe := _gafe.Value, error(nil)
			if _ecffe != nil {
				return _ecffe
			}
			_ecbd.IdAttr = &_dgcec
			continue
		}
		if _gafe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gafe.Name.Local == "opacity2" {
			_egcd, _dcgcb := _gafe.Value, error(nil)
			if _dcgcb != nil {
				return _dcgcb
			}
			_ecbd.Opacity2Attr = &_egcd
			continue
		}
		if _gafe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gafe.Name.Local == "title" {
			_dgdbb, _gfee := _gafe.Value, error(nil)
			if _gfee != nil {
				return _gfee
			}
			_ecbd.TitleAttr = &_dgdbb
			continue
		}
		if _gafe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gafe.Name.Local == "href" {
			_ebfe, _ffcg := _gafe.Value, error(nil)
			if _ffcg != nil {
				return _ffcg
			}
			_ecbd.HrefAttr = &_ebfe
			continue
		}
		if _gafe.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gafe.Name.Local == "althref" {
			_cdcc, _aece := _gafe.Value, error(nil)
			if _aece != nil {
				return _aece
			}
			_ecbd.AlthrefAttr = &_cdcc
			continue
		}
		if _gafe.Name.Local == "alignshape" {
			_ecbd.AlignshapeAttr.UnmarshalXMLAttr(_gafe)
			continue
		}
		if _gafe.Name.Local == "method" {
			_ecbd.MethodAttr.UnmarshalXMLAttr(_gafe)
			continue
		}
		if _gafe.Name.Local == "size" {
			_bbgcd, _dbcf := _gafe.Value, error(nil)
			if _dbcf != nil {
				return _dbcf
			}
			_ecbd.SizeAttr = &_bbgcd
			continue
		}
		if _gafe.Name.Local == "position" {
			_fbee, _cbffc := _gafe.Value, error(nil)
			if _cbffc != nil {
				return _cbffc
			}
			_ecbd.PositionAttr = &_fbee
			continue
		}
		if _gafe.Name.Local == "src" {
			_gega, _ggeba := _gafe.Value, error(nil)
			if _ggeba != nil {
				return _ggeba
			}
			_ecbd.SrcAttr = &_gega
			continue
		}
		if _gafe.Name.Local == "colors" {
			_ffea, _eegeb := _gafe.Value, error(nil)
			if _eegeb != nil {
				return _eegeb
			}
			_ecbd.ColorsAttr = &_ffea
			continue
		}
		if _gafe.Name.Local == "color2" {
			_abgd, _dcbg := _gafe.Value, error(nil)
			if _dcbg != nil {
				return _dcbg
			}
			_ecbd.Color2Attr = &_abgd
			continue
		}
		if _gafe.Name.Local == "type" {
			_ecbd.TypeAttr.UnmarshalXMLAttr(_gafe)
			continue
		}
		if _gafe.Name.Local == "focussize" {
			_ebafa, _gbfd := _gafe.Value, error(nil)
			if _gbfd != nil {
				return _gbfd
			}
			_ecbd.FocussizeAttr = &_ebafa
			continue
		}
		if _gafe.Name.Local == "focusposition" {
			_afbf, _cceef := _gafe.Value, error(nil)
			if _cceef != nil {
				return _cceef
			}
			_ecbd.FocuspositionAttr = &_afbf
			continue
		}
		if _gafe.Name.Local == "origin" {
			_fcba, _dbgef := _gafe.Value, error(nil)
			if _dbgef != nil {
				return _dbgef
			}
			_ecbd.OriginAttr = &_fcba
			continue
		}
		if _gafe.Name.Local == "aspect" {
			_ecbd.AspectAttr.UnmarshalXMLAttr(_gafe)
			continue
		}
		if _gafe.Name.Local == "angle" {
			_deca, _bdgd := _e.ParseFloat(_gafe.Value, 64)
			if _bdgd != nil {
				return _bdgd
			}
			_ecbd.AngleAttr = &_deca
			continue
		}
		if _gafe.Name.Local == "focus" {
			_dcded, _afae := _gafe.Value, error(nil)
			if _afae != nil {
				return _afae
			}
			_ecbd.FocusAttr = &_dcded
			continue
		}
		if _gafe.Name.Local == "recolor" {
			_ecbd.RecolorAttr.UnmarshalXMLAttr(_gafe)
			continue
		}
		if _gafe.Name.Local == "rotate" {
			_ecbd.RotateAttr.UnmarshalXMLAttr(_gafe)
			continue
		}
		if _gafe.Name.Local == "opacity" {
			_gbac, _gfbc := _gafe.Value, error(nil)
			if _gfbc != nil {
				return _gfbc
			}
			_ecbd.OpacityAttr = &_gbac
			continue
		}
		if _gafe.Name.Local == "color" {
			_fgfd, _gfgaf := _gafe.Value, error(nil)
			if _gfgaf != nil {
				return _gfgaf
			}
			_ecbd.ColorAttr = &_fgfd
			continue
		}
		if _gafe.Name.Local == "on" {
			_ecbd.OnAttr.UnmarshalXMLAttr(_gafe)
			continue
		}
		if _gafe.Name.Local == "id" {
			_ggdfa, _bcfa := _gafe.Value, error(nil)
			if _bcfa != nil {
				return _bcfa
			}
			_ecbd.SIdAttr = &_ggdfa
			continue
		}
	}
_dcgd:
	for {
		_beba, _dbec := d.Token()
		if _dbec != nil {
			return _dbec
		}
		switch _ebc := _beba.(type) {
		case _b.StartElement:
			switch _ebc.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "fill"}:
				_ecbd.Fill = NewOfcFill()
				if _adce := d.DecodeElement(_ecbd.Fill, &_ebc); _adce != nil {
					return _adce
				}
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Fill\u0020\u0025v", _ebc.Name)
				if _ggde := d.Skip(); _ggde != nil {
					return _ggde
				}
			}
		case _b.EndElement:
			break _dcgd
		case _b.CharData:
		}
	}
	return nil
}
func NewCT_Group() *CT_Group { _gaded := &CT_Group{}; return _gaded }
func (_dggbf ST_StrokeEndCap) ValidateWithPath(path string) error {
	switch _dggbf {
	case 0, 1, 2, 3:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_dggbf))
	}
	return nil
}
func (_dbf *AG_Id) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _fdce := range start.Attr {
		if _fdce.Name.Local == "id" {
			_ccd, _gecf := _fdce.Value, error(nil)
			if _gecf != nil {
				return _gecf
			}
			_dbf.IdAttr = &_ccd
			continue
		}
	}
	for {
		_ebge, _deb := d.Token()
		if _deb != nil {
			return _f.Errorf("parsing\u0020AG_Id:\u0020\u0025s", _deb)
		}
		if _abf, _febe := _ebge.(_b.EndElement); _febe && _abf.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the OfcExtrusion and its children, prefixing error messages with path
func (_fcdec *OfcExtrusion) ValidateWithPath(path string) error {
	if _geaed := _fcdec.OfcCT_Extrusion.ValidateWithPath(path); _geaed != nil {
		return _geaed
	}
	return nil
}

// Validate validates the CT_Stroke and its children
func (_adffb *CT_Stroke) Validate() error { return _adffb.ValidateWithPath("CT_Stroke") }
func (_dabbgd *OfcST_Angle) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dabbgd = 0
	case "any":
		*_dabbgd = 1
	case "30":
		*_dabbgd = 2
	case "45":
		*_dabbgd = 3
	case "60":
		*_dabbgd = 4
	case "90":
		*_dabbgd = 5
	case "auto":
		*_dabbgd = 6
	}
	return nil
}
func NewAG_StrokeAttributes() *AG_StrokeAttributes { _fgb := &AG_StrokeAttributes{}; return _fgb }

// Validate validates the OfcSignatureline and its children
func (_dbacb *OfcSignatureline) Validate() error { return _dbacb.ValidateWithPath("OfcSignatureline") }

type OfcCT_ColorMenu struct {
	StrokecolorAttr    *string
	FillcolorAttr      *string
	ShadowcolorAttr    *string
	ExtrusioncolorAttr *string
	ExtAttr            ST_Ext
}
type OfcCT_Proxy struct {
	StartAttr      _eb.ST_TrueFalseBlank
	EndAttr        _eb.ST_TrueFalseBlank
	IdrefAttr      *string
	ConnectlocAttr *int32
}

func (_afdbg *OfcCT_ClipPath) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "v"}, Value: _f.Sprintf("\u0025v", _afdbg.VAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_fefea *OfcCT_Complex) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _fefea.ExtAttr != ST_ExtUnset {
		_cebf, _facd := _fefea.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _facd != nil {
			return _facd
		}
		start.Attr = append(start.Attr, _cebf)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the Fill and its children
func (_gabccc *Fill) Validate() error { return _gabccc.ValidateWithPath("Fill") }
func (_ddedaf *ST_StrokeArrowLength) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_ddedaf = 0
	case "short":
		*_ddedaf = 1
	case "medium":
		*_ddedaf = 2
	case "long":
		*_ddedaf = 3
	}
	return nil
}

// Validate validates the OfcRight and its children
func (_cefdb *OfcRight) Validate() error { return _cefdb.ValidateWithPath("OfcRight") }

type AG_Chromakey struct{ ChromakeyAttr *string }

func (_egefe OfcST_FillType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_egefe.String(), start)
}
func (_gaecga *ST_Ext) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dgadd, _dbbbcd := d.Token()
	if _dbbbcd != nil {
		return _dbbbcd
	}
	if _bccba, _cgfgg := _dgadd.(_b.EndElement); _cgfgg && _bccba.Name == start.Name {
		*_gaecga = 1
		return nil
	}
	if _fafda, _edcab := _dgadd.(_b.CharData); !_edcab {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dgadd)
	} else {
		switch string(_fafda) {
		case "":
			*_gaecga = 0
		case "view":
			*_gaecga = 1
		case "edit":
			*_gaecga = 2
		case "backwardCompatible":
			*_gaecga = 3
		}
	}
	_dgadd, _dbbbcd = d.Token()
	if _dbbbcd != nil {
		return _dbbbcd
	}
	if _defbd, _dgefg := _dgadd.(_b.EndElement); _dgefg && _defbd.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dgadd)
}

type CT_Oval struct {
	EG_ShapeElements      []*EG_ShapeElements
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
	OpacityAttr           *string
	StrokedAttr           _eb.ST_TrueFalse
	StrokecolorAttr       *string
	StrokeweightAttr      *string
	InsetpenAttr          _eb.ST_TrueFalse
	ChromakeyAttr         *string
	FilledAttr            _eb.ST_TrueFalse
	FillcolorAttr         *string
	SptAttr               *float32
	ConnectortypeAttr     OfcST_ConnectorType
	BwmodeAttr            OfcST_BWMode
	BwpureAttr            OfcST_BWMode
	BwnormalAttr          OfcST_BWMode
	ForcedashAttr         _eb.ST_TrueFalse
	OleiconAttr           _eb.ST_TrueFalse
	OleAttr               _eb.ST_TrueFalseBlank
	PreferrelativeAttr    _eb.ST_TrueFalse
	CliptowrapAttr        _eb.ST_TrueFalse
	ClipAttr              _eb.ST_TrueFalse
}

func (_bdgdf *OfcCT_RelationTable) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _aacad := range start.Attr {
		if _aacad.Name.Local == "ext" {
			_bdgdf.ExtAttr.UnmarshalXMLAttr(_aacad)
			continue
		}
	}
_gefa:
	for {
		_acacd, _gace := d.Token()
		if _gace != nil {
			return _gace
		}
		switch _gdbfe := _acacd.(type) {
		case _b.StartElement:
			switch _gdbfe.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "rel"}:
				_bgcad := NewOfcCT_Relation()
				if _fgcgd := d.DecodeElement(_bgcad, &_gdbfe); _fgcgd != nil {
					return _fgcgd
				}
				_bdgdf.Rel = append(_bdgdf.Rel, _bgcad)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020OfcCT_RelationTable\u0020\u0025v", _gdbfe.Name)
				if _baggb := d.Skip(); _baggb != nil {
					return _baggb
				}
			}
		case _b.EndElement:
			break _gefa
		case _b.CharData:
		}
	}
	return nil
}

type Shape struct{ CT_Shape }
type OfcInk struct{ OfcCT_Ink }

// Validate validates the OfcComplex and its children
func (_aagfe *OfcComplex) Validate() error { return _aagfe.ValidateWithPath("OfcComplex") }

// ValidateWithPath validates the CT_Group and its children, prefixing error messages with path
func (_ffabd *CT_Group) ValidateWithPath(path string) error {
	if _feac := _ffabd.EditasAttr.ValidateWithPath(path + "/EditasAttr"); _feac != nil {
		return _feac
	}
	for _gedf, _fabfb := range _ffabd.Group {
		if _acae := _fabfb.ValidateWithPath(_f.Sprintf("\u0025s\u002fGroup\u005b\u0025d\u005d", path, _gedf)); _acae != nil {
			return _acae
		}
	}
	for _aaeg, _ggdb := range _ffabd.Shape {
		if _ddgf := _ggdb.ValidateWithPath(_f.Sprintf("\u0025s\u002fShape\u005b\u0025d\u005d", path, _aaeg)); _ddgf != nil {
			return _ddgf
		}
	}
	for _ddecd, _fabfd := range _ffabd.Shapetype {
		if _ccfd := _fabfd.ValidateWithPath(_f.Sprintf("\u0025s/Shapetype\u005b\u0025d\u005d", path, _ddecd)); _ccfd != nil {
			return _ccfd
		}
	}
	for _beebf, _dabb := range _ffabd.Arc {
		if _adbda := _dabb.ValidateWithPath(_f.Sprintf("\u0025s\u002fArc\u005b\u0025d\u005d", path, _beebf)); _adbda != nil {
			return _adbda
		}
	}
	for _abdb, _bcagc := range _ffabd.Curve {
		if _bgga := _bcagc.ValidateWithPath(_f.Sprintf("\u0025s\u002fCurve\u005b\u0025d\u005d", path, _abdb)); _bgga != nil {
			return _bgga
		}
	}
	for _cgfd, _dbbd := range _ffabd.Image {
		if _cafg := _dbbd.ValidateWithPath(_f.Sprintf("\u0025s\u002fImage\u005b\u0025d\u005d", path, _cgfd)); _cafg != nil {
			return _cafg
		}
	}
	for _efcb, _adfbf := range _ffabd.Line {
		if _ggfd := _adfbf.ValidateWithPath(_f.Sprintf("%s\u002fLine\u005b\u0025d\u005d", path, _efcb)); _ggfd != nil {
			return _ggfd
		}
	}
	for _edded, _ddbbf := range _ffabd.Oval {
		if _gccea := _ddbbf.ValidateWithPath(_f.Sprintf("%s\u002fOval\u005b\u0025d\u005d", path, _edded)); _gccea != nil {
			return _gccea
		}
	}
	for _aafdg, _ccff := range _ffabd.Polyline {
		if _dggg := _ccff.ValidateWithPath(_f.Sprintf("\u0025s\u002fPolyline\u005b\u0025d\u005d", path, _aafdg)); _dggg != nil {
			return _dggg
		}
	}
	for _caab, _bafd := range _ffabd.Rect {
		if _cgba := _bafd.ValidateWithPath(_f.Sprintf("%s\u002fRect\u005b\u0025d\u005d", path, _caab)); _cgba != nil {
			return _cgba
		}
	}
	for _cgcg, _abde := range _ffabd.Roundrect {
		if _aabc := _abde.ValidateWithPath(_f.Sprintf("\u0025s/Roundrect\u005b\u0025d\u005d", path, _cgcg)); _aabc != nil {
			return _aabc
		}
	}
	for _effgf, _cdda := range _ffabd.Diagram {
		if _fbfe := _cdda.ValidateWithPath(_f.Sprintf("\u0025s\u002fDiagram\u005b\u0025d\u005d", path, _effgf)); _fbfe != nil {
			return _fbfe
		}
	}
	for _bgafe, _dddd := range _ffabd.EG_ShapeElements {
		if _ebbd := _dddd.ValidateWithPath(_f.Sprintf("\u0025s\u002fEG_ShapeElements\u005b\u0025d\u005d", path, _bgafe)); _ebbd != nil {
			return _ebbd
		}
	}
	if _dbfg := _ffabd.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _dbfg != nil {
		return _dbfg
	}
	if _dgfg := _ffabd.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _dgfg != nil {
		return _dgfg
	}
	if _fgbd := _ffabd.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _fgbd != nil {
		return _fgbd
	}
	if _ffdb := _ffabd.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _ffdb != nil {
		return _ffdb
	}
	if _edee := _ffabd.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _edee != nil {
		return _edee
	}
	if _bgcg := _ffabd.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _bgcg != nil {
		return _bgcg
	}
	if _dcge := _ffabd.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _dcge != nil {
		return _dcge
	}
	if _geca := _ffabd.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _geca != nil {
		return _geca
	}
	if _begba := _ffabd.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _begba != nil {
		return _begba
	}
	if _fgfcb := _ffabd.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _fgfcb != nil {
		return _fgfcb
	}
	if _gafc := _ffabd.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _gafc != nil {
		return _gafc
	}
	if _cffg := _ffabd.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _cffg != nil {
		return _cffg
	}
	if _adggb := _ffabd.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _adggb != nil {
		return _adggb
	}
	if _afgfb := _ffabd.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _afgfb != nil {
		return _afgfb
	}
	if _bace := _ffabd.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _bace != nil {
		return _bace
	}
	if _gbbaed := _ffabd.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _gbbaed != nil {
		return _gbbaed
	}
	if _eddgad := _ffabd.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _eddgad != nil {
		return _eddgad
	}
	return nil
}
func (_addcd *OfcCT_RelationTable) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _addcd.ExtAttr != ST_ExtUnset {
		_gadbed, _gegfb := _addcd.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _gegfb != nil {
			return _gegfb
		}
		start.Attr = append(start.Attr, _gadbed)
	}
	e.EncodeToken(start)
	if _addcd.Rel != nil {
		_gggd := _b.StartElement{Name: _b.Name{Local: "o:rel"}}
		for _, _abcgc := range _addcd.Rel {
			e.EncodeElement(_abcgc, _gggd)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_ceead *Shapetype) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _ceead.CT_Shapetype.MarshalXML(e, start)
}

type OfcST_ColorMode byte

const (
	OfcST_ExtrusionRenderUnset        OfcST_ExtrusionRender = 0
	OfcST_ExtrusionRenderSolid        OfcST_ExtrusionRender = 1
	OfcST_ExtrusionRenderWireFrame    OfcST_ExtrusionRender = 2
	OfcST_ExtrusionRenderBoundingCube OfcST_ExtrusionRender = 3
)

func (_bbfa *AG_Fill) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dcd := range start.Attr {
		if _dcd.Name.Local == "filled" {
			_bbfa.FilledAttr.UnmarshalXMLAttr(_dcd)
			continue
		}
		if _dcd.Name.Local == "fillcolor" {
			_gcce, _ade := _dcd.Value, error(nil)
			if _ade != nil {
				return _ade
			}
			_bbfa.FillcolorAttr = &_gcce
			continue
		}
	}
	for {
		_bca, _bfg := d.Token()
		if _bfg != nil {
			return _f.Errorf("parsing\u0020AG_Fill:\u0020\u0025s", _bfg)
		}
		if _gff, _bda := _bca.(_b.EndElement); _bda && _gff.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_H() *CT_H { _eegb := &CT_H{}; return _eegb }
func (_edfg *CT_TextPath) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bacbaf := range start.Attr {
		if _bacbaf.Name.Local == "on" {
			_edfg.OnAttr.UnmarshalXMLAttr(_bacbaf)
			continue
		}
		if _bacbaf.Name.Local == "fitshape" {
			_edfg.FitshapeAttr.UnmarshalXMLAttr(_bacbaf)
			continue
		}
		if _bacbaf.Name.Local == "fitpath" {
			_edfg.FitpathAttr.UnmarshalXMLAttr(_bacbaf)
			continue
		}
		if _bacbaf.Name.Local == "trim" {
			_edfg.TrimAttr.UnmarshalXMLAttr(_bacbaf)
			continue
		}
		if _bacbaf.Name.Local == "xscale" {
			_edfg.XscaleAttr.UnmarshalXMLAttr(_bacbaf)
			continue
		}
		if _bacbaf.Name.Local == "string" {
			_fbaee, _ffdc := _bacbaf.Value, error(nil)
			if _ffdc != nil {
				return _ffdc
			}
			_edfg.StringAttr = &_fbaee
			continue
		}
		if _bacbaf.Name.Local == "id" {
			_bgae, _cfdaa := _bacbaf.Value, error(nil)
			if _cfdaa != nil {
				return _cfdaa
			}
			_edfg.IdAttr = &_bgae
			continue
		}
		if _bacbaf.Name.Local == "style" {
			_cageg, _ggffa := _bacbaf.Value, error(nil)
			if _ggffa != nil {
				return _ggffa
			}
			_edfg.StyleAttr = &_cageg
			continue
		}
	}
	for {
		_ebefe, _eefac := d.Token()
		if _eefac != nil {
			return _f.Errorf("parsing\u0020CT_TextPath:\u0020\u0025s", _eefac)
		}
		if _bcfgg, _dgdaa := _ebefe.(_b.EndElement); _dgdaa && _bcfgg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_baeaeb *Handles) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_baeaeb.CT_Handles = *NewCT_Handles()
_cadb:
	for {
		_bfgb, _gfdca := d.Token()
		if _gfdca != nil {
			return _gfdca
		}
		switch _caag := _bfgb.(type) {
		case _b.StartElement:
			switch _caag.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "h"}:
				_fcdf := NewCT_H()
				if _edgebg := d.DecodeElement(_fcdf, &_caag); _edgebg != nil {
					return _edgebg
				}
				_baeaeb.H = append(_baeaeb.H, _fcdf)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020Handles\u0020\u0025v", _caag.Name)
				if _ggeda := d.Skip(); _ggeda != nil {
					return _ggeda
				}
			}
		case _b.EndElement:
			break _cadb
		case _b.CharData:
		}
	}
	return nil
}

// Validate validates the CT_H and its children
func (_fedb *CT_H) Validate() error { return _fedb.ValidateWithPath("CT_H") }
func NewOfcCT_Entry() *OfcCT_Entry  { _cecba := &OfcCT_Entry{}; return _cecba }
func (_gcfca *CT_Path) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _gcfca.VAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "v"}, Value: _f.Sprintf("\u0025v", *_gcfca.VAttr)})
	}
	if _gcfca.LimoAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "limo"}, Value: _f.Sprintf("\u0025v", *_gcfca.LimoAttr)})
	}
	if _gcfca.TextboxrectAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "textboxrect"}, Value: _f.Sprintf("\u0025v", *_gcfca.TextboxrectAttr)})
	}
	if _gcfca.FillokAttr != _eb.ST_TrueFalseUnset {
		_acebd, _ffgg := _gcfca.FillokAttr.MarshalXMLAttr(_b.Name{Local: "fillok"})
		if _ffgg != nil {
			return _ffgg
		}
		start.Attr = append(start.Attr, _acebd)
	}
	if _gcfca.StrokeokAttr != _eb.ST_TrueFalseUnset {
		_dfae, _bdgf := _gcfca.StrokeokAttr.MarshalXMLAttr(_b.Name{Local: "strokeok"})
		if _bdgf != nil {
			return _bdgf
		}
		start.Attr = append(start.Attr, _dfae)
	}
	if _gcfca.ShadowokAttr != _eb.ST_TrueFalseUnset {
		_dffb, _fccaf := _gcfca.ShadowokAttr.MarshalXMLAttr(_b.Name{Local: "shadowok"})
		if _fccaf != nil {
			return _fccaf
		}
		start.Attr = append(start.Attr, _dffb)
	}
	if _gcfca.ArrowokAttr != _eb.ST_TrueFalseUnset {
		_dcfc, _bade := _gcfca.ArrowokAttr.MarshalXMLAttr(_b.Name{Local: "arrowok"})
		if _bade != nil {
			return _bade
		}
		start.Attr = append(start.Attr, _dcfc)
	}
	if _gcfca.GradientshapeokAttr != _eb.ST_TrueFalseUnset {
		_ebga, _fggaf := _gcfca.GradientshapeokAttr.MarshalXMLAttr(_b.Name{Local: "gradientshapeok"})
		if _fggaf != nil {
			return _fggaf
		}
		start.Attr = append(start.Attr, _ebga)
	}
	if _gcfca.TextpathokAttr != _eb.ST_TrueFalseUnset {
		_bafac, _feaad := _gcfca.TextpathokAttr.MarshalXMLAttr(_b.Name{Local: "textpathok"})
		if _feaad != nil {
			return _feaad
		}
		start.Attr = append(start.Attr, _bafac)
	}
	if _gcfca.InsetpenokAttr != _eb.ST_TrueFalseUnset {
		_bccc, _gdagg := _gcfca.InsetpenokAttr.MarshalXMLAttr(_b.Name{Local: "insetpenok"})
		if _gdagg != nil {
			return _gdagg
		}
		start.Attr = append(start.Attr, _bccc)
	}
	if _gcfca.ConnecttypeAttr != OfcST_ConnectTypeUnset {
		_daca, _abba := _gcfca.ConnecttypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connecttype"})
		if _abba != nil {
			return _abba
		}
		start.Attr = append(start.Attr, _daca)
	}
	if _gcfca.ConnectlocsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:connectlocs"}, Value: _f.Sprintf("\u0025v", *_gcfca.ConnectlocsAttr)})
	}
	if _gcfca.ConnectanglesAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:connectangles"}, Value: _f.Sprintf("\u0025v", *_gcfca.ConnectanglesAttr)})
	}
	if _gcfca.ExtrusionokAttr != _eb.ST_TrueFalseUnset {
		_ccbcb, _gbed := _gcfca.ExtrusionokAttr.MarshalXMLAttr(_b.Name{Local: "o:extrusionok"})
		if _gbed != nil {
			return _gbed
		}
		start.Attr = append(start.Attr, _ccbcb)
	}
	if _gcfca.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_gcfca.IdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_ffdcd *Shadow) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _ffdcd.CT_Shadow.MarshalXML(e, start)
}
func NewCT_Fill() *CT_Fill { _gdac := &CT_Fill{}; return _gdac }
func (_bbfbc OfcST_RType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bbfbc.String(), start)
}
func (_fdebe *OfcST_OLEType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_fdebe = 0
	case "Embed":
		*_fdebe = 1
	case "Link":
		*_fdebe = 2
	}
	return nil
}
func (_bgedf *OfcCT_StrokeChild) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bgedf.OnAttr != _eb.ST_TrueFalseUnset {
		_dfffa, _abcdab := _bgedf.OnAttr.MarshalXMLAttr(_b.Name{Local: "on"})
		if _abcdab != nil {
			return _abcdab
		}
		start.Attr = append(start.Attr, _dfffa)
	}
	if _bgedf.WeightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "weight"}, Value: _f.Sprintf("\u0025v", *_bgedf.WeightAttr)})
	}
	if _bgedf.ColorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "color"}, Value: _f.Sprintf("\u0025v", *_bgedf.ColorAttr)})
	}
	if _bgedf.Color2Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "color2"}, Value: _f.Sprintf("\u0025v", *_bgedf.Color2Attr)})
	}
	if _bgedf.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_bgedf.OpacityAttr)})
	}
	if _bgedf.LinestyleAttr != ST_StrokeLineStyleUnset {
		_fdedd, _afaeda := _bgedf.LinestyleAttr.MarshalXMLAttr(_b.Name{Local: "v:linestyle"})
		if _afaeda != nil {
			return _afaeda
		}
		start.Attr = append(start.Attr, _fdedd)
	}
	if _bgedf.MiterlimitAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "miterlimit"}, Value: _f.Sprintf("\u0025v", *_bgedf.MiterlimitAttr)})
	}
	if _bgedf.JoinstyleAttr != ST_StrokeJoinStyleUnset {
		_eaefe, _baccea := _bgedf.JoinstyleAttr.MarshalXMLAttr(_b.Name{Local: "v:joinstyle"})
		if _baccea != nil {
			return _baccea
		}
		start.Attr = append(start.Attr, _eaefe)
	}
	if _bgedf.EndcapAttr != ST_StrokeEndCapUnset {
		_cddeb, _fadff := _bgedf.EndcapAttr.MarshalXMLAttr(_b.Name{Local: "v:endcap"})
		if _fadff != nil {
			return _fadff
		}
		start.Attr = append(start.Attr, _cddeb)
	}
	if _bgedf.DashstyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "dashstyle"}, Value: _f.Sprintf("\u0025v", *_bgedf.DashstyleAttr)})
	}
	if _bgedf.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_gecedg, _cabbd := _bgedf.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _cabbd != nil {
			return _cabbd
		}
		start.Attr = append(start.Attr, _gecedg)
	}
	if _bgedf.FilltypeAttr != ST_FillTypeUnset {
		_aeggd, _bdcfa := _bgedf.FilltypeAttr.MarshalXMLAttr(_b.Name{Local: "v:filltype"})
		if _bdcfa != nil {
			return _bdcfa
		}
		start.Attr = append(start.Attr, _aeggd)
	}
	if _bgedf.SrcAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "src"}, Value: _f.Sprintf("\u0025v", *_bgedf.SrcAttr)})
	}
	if _bgedf.ImageaspectAttr != ST_ImageAspectUnset {
		_gcgbd, _feceb := _bgedf.ImageaspectAttr.MarshalXMLAttr(_b.Name{Local: "v:imageaspect"})
		if _feceb != nil {
			return _feceb
		}
		start.Attr = append(start.Attr, _gcgbd)
	}
	if _bgedf.ImagesizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "imagesize"}, Value: _f.Sprintf("\u0025v", *_bgedf.ImagesizeAttr)})
	}
	if _bgedf.ImagealignshapeAttr != _eb.ST_TrueFalseUnset {
		_aadda, _gffce := _bgedf.ImagealignshapeAttr.MarshalXMLAttr(_b.Name{Local: "imagealignshape"})
		if _gffce != nil {
			return _gffce
		}
		start.Attr = append(start.Attr, _aadda)
	}
	if _bgedf.StartarrowAttr != ST_StrokeArrowTypeUnset {
		_abggaf, _bfffe := _bgedf.StartarrowAttr.MarshalXMLAttr(_b.Name{Local: "v:startarrow"})
		if _bfffe != nil {
			return _bfffe
		}
		start.Attr = append(start.Attr, _abggaf)
	}
	if _bgedf.StartarrowwidthAttr != ST_StrokeArrowWidthUnset {
		_eedec, _bfcegf := _bgedf.StartarrowwidthAttr.MarshalXMLAttr(_b.Name{Local: "v:startarrowwidth"})
		if _bfcegf != nil {
			return _bfcegf
		}
		start.Attr = append(start.Attr, _eedec)
	}
	if _bgedf.StartarrowlengthAttr != ST_StrokeArrowLengthUnset {
		_aafac, _cgfbd := _bgedf.StartarrowlengthAttr.MarshalXMLAttr(_b.Name{Local: "v:startarrowlength"})
		if _cgfbd != nil {
			return _cgfbd
		}
		start.Attr = append(start.Attr, _aafac)
	}
	if _bgedf.EndarrowAttr != ST_StrokeArrowTypeUnset {
		_edbga, _effdb := _bgedf.EndarrowAttr.MarshalXMLAttr(_b.Name{Local: "v:endarrow"})
		if _effdb != nil {
			return _effdb
		}
		start.Attr = append(start.Attr, _edbga)
	}
	if _bgedf.EndarrowwidthAttr != ST_StrokeArrowWidthUnset {
		_acefe, _fbgdg := _bgedf.EndarrowwidthAttr.MarshalXMLAttr(_b.Name{Local: "v:endarrowwidth"})
		if _fbgdg != nil {
			return _fbgdg
		}
		start.Attr = append(start.Attr, _acefe)
	}
	if _bgedf.EndarrowlengthAttr != ST_StrokeArrowLengthUnset {
		_egfga, _bdbfdd := _bgedf.EndarrowlengthAttr.MarshalXMLAttr(_b.Name{Local: "v:endarrowlength"})
		if _bdbfdd != nil {
			return _bdbfdd
		}
		start.Attr = append(start.Attr, _egfga)
	}
	if _bgedf.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:href"}, Value: _f.Sprintf("\u0025v", *_bgedf.HrefAttr)})
	}
	if _bgedf.AlthrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:althref"}, Value: _f.Sprintf("\u0025v", *_bgedf.AlthrefAttr)})
	}
	if _bgedf.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:title"}, Value: _f.Sprintf("\u0025v", *_bgedf.TitleAttr)})
	}
	if _bgedf.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_aeged, _ecgfbb := _bgedf.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _ecgfbb != nil {
			return _ecgfbb
		}
		start.Attr = append(start.Attr, _aeged)
	}
	if _bgedf.ExtAttr != ST_ExtUnset {
		_dacade, _gegbb := _bgedf.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _gegbb != nil {
			return _gegbb
		}
		start.Attr = append(start.Attr, _dacade)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewCT_Curve() *CT_Curve { _eddc := &CT_Curve{}; return _eddc }
func (_fgca *Background) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:ur"}, Value: "urn:schemas-microsoft\u002dcom:office:powerpoint"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:urn"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:word"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:w"}, Value: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fwordprocessingml\u002f2006\u002fmain"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:x"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:excel"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "v:background"
	return _fgca.CT_Background.MarshalXML(e, start)
}
func (_gdaac ST_ImageAspect) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_gdaac.String(), start)
}

// Validate validates the Background and its children
func (_dada *Background) Validate() error { return _dada.ValidateWithPath("Background") }
func (_egbce OfcST_ConnectorType) ValidateWithPath(path string) error {
	switch _egbce {
	case 0, 1, 2, 3, 4:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_egbce))
	}
	return nil
}

// ValidateWithPath validates the OfcCT_Fill and its children, prefixing error messages with path
func (_acbbd *OfcCT_Fill) ValidateWithPath(path string) error {
	if _cdega := _acbbd.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _cdega != nil {
		return _cdega
	}
	if _bdfaf := _acbbd.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _bdfaf != nil {
		return _bdfaf
	}
	return nil
}

type OfcST_DiagramLayout byte

func (_addbd *OfcLeft) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_addbd.OfcCT_StrokeChild = *NewOfcCT_StrokeChild()
	for _, _bdcg := range start.Attr {
		if _bdcg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdcg.Name.Local == "href" {
			_bffge, _cdeef := _bdcg.Value, error(nil)
			if _cdeef != nil {
				return _cdeef
			}
			_addbd.HrefAttr = &_bffge
			continue
		}
		if _bdcg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdcg.Name.Local == "forcedash" {
			_addbd.ForcedashAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdcg.Name.Local == "title" {
			_cbgcg, _fcfcd := _bdcg.Value, error(nil)
			if _fcfcd != nil {
				return _fcfcd
			}
			_addbd.TitleAttr = &_cbgcg
			continue
		}
		if _bdcg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bdcg.Name.Local == "althref" {
			_geccg, _agafb := _bdcg.Value, error(nil)
			if _agafb != nil {
				return _agafb
			}
			_addbd.AlthrefAttr = &_geccg
			continue
		}
		if _bdcg.Name.Local == "imageaspect" {
			_addbd.ImageaspectAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "startarrow" {
			_addbd.StartarrowAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "linestyle" {
			_addbd.LinestyleAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "startarrowwidth" {
			_addbd.StartarrowwidthAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "joinstyle" {
			_addbd.JoinstyleAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "startarrowlength" {
			_addbd.StartarrowlengthAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "dashstyle" {
			_dadea, _dcadb := _bdcg.Value, error(nil)
			if _dcadb != nil {
				return _dcadb
			}
			_addbd.DashstyleAttr = &_dadea
			continue
		}
		if _bdcg.Name.Local == "endarrow" {
			_addbd.EndarrowAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "filltype" {
			_addbd.FilltypeAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "endarrowwidth" {
			_addbd.EndarrowwidthAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "opacity" {
			_ceacb, _eddfb := _bdcg.Value, error(nil)
			if _eddfb != nil {
				return _eddfb
			}
			_addbd.OpacityAttr = &_ceacb
			continue
		}
		if _bdcg.Name.Local == "color" {
			_adace, _dgbf := _bdcg.Value, error(nil)
			if _dgbf != nil {
				return _dgbf
			}
			_addbd.ColorAttr = &_adace
			continue
		}
		if _bdcg.Name.Local == "insetpen" {
			_addbd.InsetpenAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "endarrowlength" {
			_addbd.EndarrowlengthAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "ext" {
			_addbd.ExtAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "endcap" {
			_addbd.EndcapAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "color2" {
			_dcccd, _cadbc := _bdcg.Value, error(nil)
			if _cadbc != nil {
				return _cadbc
			}
			_addbd.Color2Attr = &_dcccd
			continue
		}
		if _bdcg.Name.Local == "imagealignshape" {
			_addbd.ImagealignshapeAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
		if _bdcg.Name.Local == "weight" {
			_acdca, _bfacba := _bdcg.Value, error(nil)
			if _bfacba != nil {
				return _bfacba
			}
			_addbd.WeightAttr = &_acdca
			continue
		}
		if _bdcg.Name.Local == "src" {
			_gdgbd, _gdece := _bdcg.Value, error(nil)
			if _gdece != nil {
				return _gdece
			}
			_addbd.SrcAttr = &_gdgbd
			continue
		}
		if _bdcg.Name.Local == "imagesize" {
			_cdgbc, _gcgcf := _bdcg.Value, error(nil)
			if _gcgcf != nil {
				return _gcgcf
			}
			_addbd.ImagesizeAttr = &_cdgbc
			continue
		}
		if _bdcg.Name.Local == "miterlimit" {
			_ffgec, _ccfa := _e.ParseFloat(_bdcg.Value, 64)
			if _ccfa != nil {
				return _ccfa
			}
			_addbd.MiterlimitAttr = &_ffgec
			continue
		}
		if _bdcg.Name.Local == "on" {
			_addbd.OnAttr.UnmarshalXMLAttr(_bdcg)
			continue
		}
	}
	for {
		_daead, _fdcd := d.Token()
		if _fdcd != nil {
			return _f.Errorf("parsing\u0020OfcLeft:\u0020\u0025s", _fdcd)
		}
		if _cfcdf, _aebfe := _daead.(_b.EndElement); _aebfe && _cfcdf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cgbf *OfcCT_Lock) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _cceff := range start.Attr {
		if _cceff.Name.Local == "position" {
			_cgbf.PositionAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
		if _cceff.Name.Local == "selection" {
			_cgbf.SelectionAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
		if _cceff.Name.Local == "grouping" {
			_cgbf.GroupingAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
		if _cceff.Name.Local == "ungrouping" {
			_cgbf.UngroupingAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
		if _cceff.Name.Local == "rotation" {
			_cgbf.RotationAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
		if _cceff.Name.Local == "cropping" {
			_cgbf.CroppingAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
		if _cceff.Name.Local == "verticies" {
			_cgbf.VerticiesAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
		if _cceff.Name.Local == "adjusthandles" {
			_cgbf.AdjusthandlesAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
		if _cceff.Name.Local == "text" {
			_cgbf.TextAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
		if _cceff.Name.Local == "aspectratio" {
			_cgbf.AspectratioAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
		if _cceff.Name.Local == "shapetype" {
			_cgbf.ShapetypeAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
		if _cceff.Name.Local == "ext" {
			_cgbf.ExtAttr.UnmarshalXMLAttr(_cceff)
			continue
		}
	}
	for {
		_agegd, _gaag := d.Token()
		if _gaag != nil {
			return _f.Errorf("parsing\u0020OfcCT_Lock:\u0020%s", _gaag)
		}
		if _fgdaf, _cffde := _agegd.(_b.EndElement); _cffde && _fgdaf.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCT_PolyLine() *CT_PolyLine { _bfefd := &CT_PolyLine{}; return _bfefd }
func (_egcda ST_StrokeArrowType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_cgfed := _b.Attr{}
	_cgfed.Name = name
	switch _egcda {
	case ST_StrokeArrowTypeUnset:
		_cgfed.Value = ""
	case ST_StrokeArrowTypeNone:
		_cgfed.Value = "none"
	case ST_StrokeArrowTypeBlock:
		_cgfed.Value = "block"
	case ST_StrokeArrowTypeClassic:
		_cgfed.Value = "classic"
	case ST_StrokeArrowTypeOval:
		_cgfed.Value = "oval"
	case ST_StrokeArrowTypeDiamond:
		_cgfed.Value = "diamond"
	case ST_StrokeArrowTypeOpen:
		_cgfed.Value = "open"
	}
	return _cgfed, nil
}

type AG_Style struct{ StyleAttr *string }

func (_cfeg *AG_OfficeShapeAttributes) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _caa := range start.Attr {
		if _caa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caa.Name.Local == "spt" {
			_acg, _ddb := _e.ParseFloat(_caa.Value, 64)
			if _ddb != nil {
				return _ddb
			}
			_fcbbf := float32(_acg)
			_cfeg.SptAttr = &_fcbbf
			continue
		}
		if _caa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caa.Name.Local == "connectortype" {
			_cfeg.ConnectortypeAttr.UnmarshalXMLAttr(_caa)
			continue
		}
		if _caa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caa.Name.Local == "bwmode" {
			_cfeg.BwmodeAttr.UnmarshalXMLAttr(_caa)
			continue
		}
		if _caa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caa.Name.Local == "bwpure" {
			_cfeg.BwpureAttr.UnmarshalXMLAttr(_caa)
			continue
		}
		if _caa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caa.Name.Local == "bwnormal" {
			_cfeg.BwnormalAttr.UnmarshalXMLAttr(_caa)
			continue
		}
		if _caa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caa.Name.Local == "forcedash" {
			_cfeg.ForcedashAttr.UnmarshalXMLAttr(_caa)
			continue
		}
		if _caa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caa.Name.Local == "oleicon" {
			_cfeg.OleiconAttr.UnmarshalXMLAttr(_caa)
			continue
		}
		if _caa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caa.Name.Local == "ole" {
			_cfeg.OleAttr.UnmarshalXMLAttr(_caa)
			continue
		}
		if _caa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caa.Name.Local == "preferrelative" {
			_cfeg.PreferrelativeAttr.UnmarshalXMLAttr(_caa)
			continue
		}
		if _caa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caa.Name.Local == "cliptowrap" {
			_cfeg.CliptowrapAttr.UnmarshalXMLAttr(_caa)
			continue
		}
		if _caa.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _caa.Name.Local == "clip" {
			_cfeg.ClipAttr.UnmarshalXMLAttr(_caa)
			continue
		}
	}
	for {
		_fgdb, _cgef := d.Token()
		if _cgef != nil {
			return _f.Errorf("parsing AG_OfficeShapeAttributes:\u0020%s", _cgef)
		}
		if _gfba, _aegg := _fgdb.(_b.EndElement); _aegg && _gfba.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gd *AG_AllShapeAttributes) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _gd.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_gd.OpacityAttr)})
	}
	if _gd.StrokedAttr != _eb.ST_TrueFalseUnset {
		_dgge, _cga := _gd.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _cga != nil {
			return _cga
		}
		start.Attr = append(start.Attr, _dgge)
	}
	if _gd.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_gd.StrokecolorAttr)})
	}
	if _gd.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_gd.StrokeweightAttr)})
	}
	if _gd.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_gec, _adcc := _gd.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _adcc != nil {
			return _adcc
		}
		start.Attr = append(start.Attr, _gec)
	}
	if _gd.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_gd.ChromakeyAttr)})
	}
	if _gd.FilledAttr != _eb.ST_TrueFalseUnset {
		_ece, _aa := _gd.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _aa != nil {
			return _aa
		}
		start.Attr = append(start.Attr, _ece)
	}
	if _gd.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_gd.FillcolorAttr)})
	}
	if _gd.SptAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spt"}, Value: _f.Sprintf("\u0025v", *_gd.SptAttr)})
	}
	if _gd.ConnectortypeAttr != OfcST_ConnectorTypeUnset {
		_gcb, _gbb := _gd.ConnectortypeAttr.MarshalXMLAttr(_b.Name{Local: "o:connectortype"})
		if _gbb != nil {
			return _gbb
		}
		start.Attr = append(start.Attr, _gcb)
	}
	if _gd.BwmodeAttr != OfcST_BWModeUnset {
		_fea, _gefg := _gd.BwmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:bwmode"})
		if _gefg != nil {
			return _gefg
		}
		start.Attr = append(start.Attr, _fea)
	}
	if _gd.BwpureAttr != OfcST_BWModeUnset {
		_aba, _adf := _gd.BwpureAttr.MarshalXMLAttr(_b.Name{Local: "o:bwpure"})
		if _adf != nil {
			return _adf
		}
		start.Attr = append(start.Attr, _aba)
	}
	if _gd.BwnormalAttr != OfcST_BWModeUnset {
		_fc, _ccf := _gd.BwnormalAttr.MarshalXMLAttr(_b.Name{Local: "o:bwnormal"})
		if _ccf != nil {
			return _ccf
		}
		start.Attr = append(start.Attr, _fc)
	}
	if _gd.ForcedashAttr != _eb.ST_TrueFalseUnset {
		_aed, _dc := _gd.ForcedashAttr.MarshalXMLAttr(_b.Name{Local: "o:forcedash"})
		if _dc != nil {
			return _dc
		}
		start.Attr = append(start.Attr, _aed)
	}
	if _gd.OleiconAttr != _eb.ST_TrueFalseUnset {
		_gaf, _bac := _gd.OleiconAttr.MarshalXMLAttr(_b.Name{Local: "o:oleicon"})
		if _bac != nil {
			return _bac
		}
		start.Attr = append(start.Attr, _gaf)
	}
	if _gd.OleAttr != _eb.ST_TrueFalseBlankUnset {
		_aab, _ebaf := _gd.OleAttr.MarshalXMLAttr(_b.Name{Local: "o:ole"})
		if _ebaf != nil {
			return _ebaf
		}
		start.Attr = append(start.Attr, _aab)
	}
	if _gd.PreferrelativeAttr != _eb.ST_TrueFalseUnset {
		_abg, _fad := _gd.PreferrelativeAttr.MarshalXMLAttr(_b.Name{Local: "o:preferrelative"})
		if _fad != nil {
			return _fad
		}
		start.Attr = append(start.Attr, _abg)
	}
	if _gd.CliptowrapAttr != _eb.ST_TrueFalseUnset {
		_fgd, _ded := _gd.CliptowrapAttr.MarshalXMLAttr(_b.Name{Local: "o:cliptowrap"})
		if _ded != nil {
			return _ded
		}
		start.Attr = append(start.Attr, _fgd)
	}
	if _gd.ClipAttr != _eb.ST_TrueFalseUnset {
		_ace, _egc := _gd.ClipAttr.MarshalXMLAttr(_b.Name{Local: "o:clip"})
		if _egc != nil {
			return _egc
		}
		start.Attr = append(start.Attr, _ace)
	}
	return nil
}

type Background struct{ CT_Background }

// Validate validates the OfcCT_StrokeChild and its children
func (_aafaaa *OfcCT_StrokeChild) Validate() error {
	return _aafaaa.ValidateWithPath("OfcCT_StrokeChild")
}

// Validate validates the AG_ImageAttributes and its children
func (_bdga *AG_ImageAttributes) Validate() error {
	return _bdga.ValidateWithPath("AG_ImageAttributes")
}

type ST_StrokeEndCap byte

// Validate validates the AG_Fill and its children
func (_cab *AG_Fill) Validate() error { return _cab.ValidateWithPath("AG_Fill") }
func (_eedbc *Shapetype) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_eedbc.CT_Shapetype = *NewCT_Shapetype()
	for _, _ddafg := range start.Attr {
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "bordertopcolor" {
			_ccdbedb, _cacfef := _ddafg.Value, error(nil)
			if _cacfef != nil {
				return _cacfef
			}
			_eedbc.BordertopcolorAttr = &_ccdbedb
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "master" {
			_baeebb, _ddebc := _ddafg.Value, error(nil)
			if _ddebc != nil {
				return _ddebc
			}
			_eedbc.MasterAttr = &_baeebb
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "borderleftcolor" {
			_afdba, _baggbce := _ddafg.Value, error(nil)
			if _baggbce != nil {
				return _baggbce
			}
			_eedbc.BorderleftcolorAttr = &_afdba
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "bullet" {
			_eedbc.BulletAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "hr" {
			_eedbc.HrAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "clip" {
			_eedbc.ClipAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "hrstd" {
			_eedbc.HrstdAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "spid" {
			_affbf, _dgfgc := _ddafg.Value, error(nil)
			if _dgfgc != nil {
				return _dgfgc
			}
			_eedbc.SpidAttr = &_affbf
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "hrnoshade" {
			_eedbc.HrnoshadeAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "regroupid" {
			_gcab, _aedg := _e.ParseInt(_ddafg.Value, 10, 64)
			if _aedg != nil {
				return _aedg
			}
			_eedbc.RegroupidAttr = &_gcab
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "dgmlayout" {
			_eedbc.DgmlayoutAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "cliptowrap" {
			_eedbc.CliptowrapAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "allowoverlap" {
			_eedbc.AllowoverlapAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "insetmode" {
			_eedbc.InsetmodeAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "userhidden" {
			_eedbc.UserhiddenAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "borderbottomcolor" {
			_bdaee, _bgfad := _ddafg.Value, error(nil)
			if _bgfad != nil {
				return _bgfad
			}
			_eedbc.BorderbottomcolorAttr = &_bdaee
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "bwpure" {
			_eedbc.BwpureAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "dgmlayoutmru" {
			_eedbc.DgmlayoutmruAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "preferrelative" {
			_eedbc.PreferrelativeAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "allowincell" {
			_eedbc.AllowincellAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "hrpct" {
			_deeef, _bebb := _e.ParseFloat(_ddafg.Value, 64)
			if _bebb != nil {
				return _bebb
			}
			_bafad := float32(_deeef)
			_eedbc.HrpctAttr = &_bafad
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "button" {
			_eedbc.ButtonAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "userdrawn" {
			_eedbc.UserdrawnAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "bwnormal" {
			_eedbc.BwnormalAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "spt" {
			_gfedg, _edcbg := _e.ParseFloat(_ddafg.Value, 64)
			if _edcbg != nil {
				return _edcbg
			}
			_dceggd := float32(_gfedg)
			_eedbc.SptAttr = &_dceggd
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "connectortype" {
			_eedbc.ConnectortypeAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "borderrightcolor" {
			_cagea, _agcfg := _ddafg.Value, error(nil)
			if _agcfg != nil {
				return _agcfg
			}
			_eedbc.BorderrightcolorAttr = &_cagea
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "oleicon" {
			_eedbc.OleiconAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "dgmnodekind" {
			_dgedf, _gefef := _e.ParseInt(_ddafg.Value, 10, 64)
			if _gefef != nil {
				return _gefef
			}
			_eedbc.DgmnodekindAttr = &_dgedf
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "oned" {
			_eedbc.OnedAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "bwmode" {
			_eedbc.BwmodeAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "ole" {
			_eedbc.OleAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "forcedash" {
			_eedbc.ForcedashAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "doubleclicknotify" {
			_eedbc.DoubleclicknotifyAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ddafg.Name.Local == "hralign" {
			_eedbc.HralignAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Local == "wrapcoords" {
			_eecce, _dfebb := _ddafg.Value, error(nil)
			if _dfebb != nil {
				return _dfebb
			}
			_eedbc.WrapcoordsAttr = &_eecce
			continue
		}
		if _ddafg.Name.Local == "coordsize" {
			_eece, _dgcaf := _ddafg.Value, error(nil)
			if _dgcaf != nil {
				return _dgcaf
			}
			_eedbc.CoordsizeAttr = &_eece
			continue
		}
		if _ddafg.Name.Local == "stroked" {
			_eedbc.StrokedAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Local == "alt" {
			_bgece, _ecgdb := _ddafg.Value, error(nil)
			if _ecgdb != nil {
				return _ecgdb
			}
			_eedbc.AltAttr = &_bgece
			continue
		}
		if _ddafg.Name.Local == "strokeweight" {
			_gcbbe, _fbeb := _ddafg.Value, error(nil)
			if _fbeb != nil {
				return _fbeb
			}
			_eedbc.StrokeweightAttr = &_gcbbe
			continue
		}
		if _ddafg.Name.Local == "style" {
			_beaec, _ddgfg := _ddafg.Value, error(nil)
			if _ddgfg != nil {
				return _ddgfg
			}
			_eedbc.StyleAttr = &_beaec
			continue
		}
		if _ddafg.Name.Local == "chromakey" {
			_egabf, _dcgbe := _ddafg.Value, error(nil)
			if _dcgbe != nil {
				return _dcgbe
			}
			_eedbc.ChromakeyAttr = &_egabf
			continue
		}
		if _ddafg.Name.Local == "id" {
			_gddcd, _ccadf := _ddafg.Value, error(nil)
			if _ccadf != nil {
				return _ccadf
			}
			_eedbc.IdAttr = &_gddcd
			continue
		}
		if _ddafg.Name.Local == "target" {
			_cfbce, _gaecd := _ddafg.Value, error(nil)
			if _gaecd != nil {
				return _gaecd
			}
			_eedbc.TargetAttr = &_cfbce
			continue
		}
		if _ddafg.Name.Local == "class" {
			_cgecg, _cdaaa := _ddafg.Value, error(nil)
			if _cdaaa != nil {
				return _cdaaa
			}
			_eedbc.ClassAttr = &_cgecg
			continue
		}
		if _ddafg.Name.Local == "insetpen" {
			_eedbc.InsetpenAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Local == "print" {
			_eedbc.PrintAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Local == "filled" {
			_eedbc.FilledAttr.UnmarshalXMLAttr(_ddafg)
			continue
		}
		if _ddafg.Name.Local == "strokecolor" {
			_ffdgc, _deeca := _ddafg.Value, error(nil)
			if _deeca != nil {
				return _deeca
			}
			_eedbc.StrokecolorAttr = &_ffdgc
			continue
		}
		if _ddafg.Name.Local == "title" {
			_gfbcb, _cecdb := _ddafg.Value, error(nil)
			if _cecdb != nil {
				return _cecdb
			}
			_eedbc.TitleAttr = &_gfbcb
			continue
		}
		if _ddafg.Name.Local == "opacity" {
			_bdbba, _aeegbg := _ddafg.Value, error(nil)
			if _aeegbg != nil {
				return _aeegbg
			}
			_eedbc.OpacityAttr = &_bdbba
			continue
		}
		if _ddafg.Name.Local == "adj" {
			_fgba, _fdgce := _ddafg.Value, error(nil)
			if _fdgce != nil {
				return _fdgce
			}
			_eedbc.AdjAttr = &_fgba
			continue
		}
		if _ddafg.Name.Local == "path" {
			_agdaf, _eafgc := _ddafg.Value, error(nil)
			if _eafgc != nil {
				return _eafgc
			}
			_eedbc.PathAttr = &_agdaf
			continue
		}
		if _ddafg.Name.Local == "href" {
			_fdbaf, _gaba := _ddafg.Value, error(nil)
			if _gaba != nil {
				return _gaba
			}
			_eedbc.HrefAttr = &_fdbaf
			continue
		}
		if _ddafg.Name.Local == "coordorigin" {
			_agcgg, _cbdfge := _ddafg.Value, error(nil)
			if _cbdfge != nil {
				return _cbdfge
			}
			_eedbc.CoordoriginAttr = &_agcgg
			continue
		}
		if _ddafg.Name.Local == "fillcolor" {
			_ecaca, _bedce := _ddafg.Value, error(nil)
			if _bedce != nil {
				return _bedce
			}
			_eedbc.FillcolorAttr = &_ecaca
			continue
		}
	}
_dcabg:
	for {
		_eagea, _dbfb := d.Token()
		if _dbfb != nil {
			return _dbfb
		}
		switch _fggab := _eagea.(type) {
		case _b.StartElement:
			switch _fggab.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_ddedb := NewEG_ShapeElements()
				_ddedb.Path = NewPath()
				if _fgeee := d.DecodeElement(_ddedb.Path, &_fggab); _fgeee != nil {
					return _fgeee
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _ddedb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_ffege := NewEG_ShapeElements()
				_ffege.Formulas = NewFormulas()
				if _bafgf := d.DecodeElement(_ffege.Formulas, &_fggab); _bafgf != nil {
					return _bafgf
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _ffege)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_bdgfb := NewEG_ShapeElements()
				_bdgfb.Handles = NewHandles()
				if _cbdfdg := d.DecodeElement(_bdgfb.Handles, &_fggab); _cbdfdg != nil {
					return _cbdfdg
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _bdgfb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_cddbg := NewEG_ShapeElements()
				_cddbg.Fill = NewFill()
				if _gdfcc := d.DecodeElement(_cddbg.Fill, &_fggab); _gdfcc != nil {
					return _gdfcc
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _cddbg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_aaebb := NewEG_ShapeElements()
				_aaebb.Stroke = NewStroke()
				if _gffaf := d.DecodeElement(_aaebb.Stroke, &_fggab); _gffaf != nil {
					return _gffaf
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _aaebb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_afcgb := NewEG_ShapeElements()
				_afcgb.Shadow = NewShadow()
				if _gbfcbf := d.DecodeElement(_afcgb.Shadow, &_fggab); _gbfcbf != nil {
					return _gbfcbf
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _afcgb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_ddegc := NewEG_ShapeElements()
				_ddegc.Textbox = NewTextbox()
				if _ecgffe := d.DecodeElement(_ddegc.Textbox, &_fggab); _ecgffe != nil {
					return _ecgffe
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _ddegc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_bdcff := NewEG_ShapeElements()
				_bdcff.Textpath = NewTextpath()
				if _ggffb := d.DecodeElement(_bdcff.Textpath, &_fggab); _ggffb != nil {
					return _ggffb
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _bdcff)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_gggab := NewEG_ShapeElements()
				_gggab.Imagedata = NewImagedata()
				if _bbfec := d.DecodeElement(_gggab.Imagedata, &_fggab); _bbfec != nil {
					return _bbfec
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _gggab)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_geaff := NewEG_ShapeElements()
				_geaff.Skew = NewOfcSkew()
				if _ffbe := d.DecodeElement(_geaff.Skew, &_fggab); _ffbe != nil {
					return _ffbe
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _geaff)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_cbfbe := NewEG_ShapeElements()
				_cbfbe.Extrusion = NewOfcExtrusion()
				if _ggbge := d.DecodeElement(_cbfbe.Extrusion, &_fggab); _ggbge != nil {
					return _ggbge
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _cbfbe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_eaadb := NewEG_ShapeElements()
				_eaadb.Callout = NewOfcCallout()
				if _cdedg := d.DecodeElement(_eaadb.Callout, &_fggab); _cdedg != nil {
					return _cdedg
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _eaadb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_acafa := NewEG_ShapeElements()
				_acafa.Lock = NewOfcLock()
				if _bgefba := d.DecodeElement(_acafa.Lock, &_fggab); _bgefba != nil {
					return _bgefba
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _acafa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_fgbbb := NewEG_ShapeElements()
				_fgbbb.Clippath = NewOfcClippath()
				if _gaabd := d.DecodeElement(_fgbbb.Clippath, &_fggab); _gaabd != nil {
					return _gaabd
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _fgbbb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_caefd := NewEG_ShapeElements()
				_caefd.Signatureline = NewOfcSignatureline()
				if _dacda := d.DecodeElement(_caefd.Signatureline, &_fggab); _dacda != nil {
					return _dacda
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _caefd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_fdgfbd := NewEG_ShapeElements()
				_fdgfbd.Wrap = _a.NewWrap()
				if _afagda := d.DecodeElement(_fdgfbd.Wrap, &_fggab); _afagda != nil {
					return _afagda
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _fdgfbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_bbagd := NewEG_ShapeElements()
				_bbagd.Anchorlock = _a.NewAnchorlock()
				if _gedffb := d.DecodeElement(_bbagd.Anchorlock, &_fggab); _gedffb != nil {
					return _gedffb
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _bbagd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_fcebb := NewEG_ShapeElements()
				_fcebb.Bordertop = _a.NewBordertop()
				if _abfea := d.DecodeElement(_fcebb.Bordertop, &_fggab); _abfea != nil {
					return _abfea
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _fcebb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_befdce := NewEG_ShapeElements()
				_befdce.Borderbottom = _a.NewBorderbottom()
				if _cgfae := d.DecodeElement(_befdce.Borderbottom, &_fggab); _cgfae != nil {
					return _cgfae
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _befdce)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_aggeg := NewEG_ShapeElements()
				_aggeg.Borderleft = _a.NewBorderleft()
				if _acaeged := d.DecodeElement(_aggeg.Borderleft, &_fggab); _acaeged != nil {
					return _acaeged
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _aggeg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_gcgfgb := NewEG_ShapeElements()
				_gcgfgb.Borderright = _a.NewBorderright()
				if _gaecg := d.DecodeElement(_gcgfgb.Borderright, &_fggab); _gaecg != nil {
					return _gaecg
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _gcgfgb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_gadgd := NewEG_ShapeElements()
				_gadgd.ClientData = _c.NewClientData()
				if _cecfc := d.DecodeElement(_gadgd.ClientData, &_fggab); _cecfc != nil {
					return _cecfc
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _gadgd)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_fdefb := NewEG_ShapeElements()
				_fdefb.Textdata = _bf.NewTextdata()
				if _bdcgg := d.DecodeElement(_fdefb.Textdata, &_fggab); _bdcgg != nil {
					return _bdcgg
				}
				_eedbc.EG_ShapeElements = append(_eedbc.EG_ShapeElements, _fdefb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "complex"}:
				_eedbc.Complex = NewOfcComplex()
				if _aabg := d.DecodeElement(_eedbc.Complex, &_fggab); _aabg != nil {
					return _aabg
				}
			default:
				_ba.Log("skipping\u0020unsupported\u0020element on Shapetype \u0025v", _fggab.Name)
				if _cdgec := d.Skip(); _cdgec != nil {
					return _cdgec
				}
			}
		case _b.EndElement:
			break _dcabg
		case _b.CharData:
		}
	}
	return nil
}

type Shadow struct{ CT_Shadow }

// ValidateWithPath validates the EG_ShapeElements and its children, prefixing error messages with path
func (_gcbaa *EG_ShapeElements) ValidateWithPath(path string) error {
	if _gcbaa.Path != nil {
		if _eacde := _gcbaa.Path.ValidateWithPath(path + "\u002fPath"); _eacde != nil {
			return _eacde
		}
	}
	if _gcbaa.Formulas != nil {
		if _cbcbea := _gcbaa.Formulas.ValidateWithPath(path + "\u002fFormulas"); _cbcbea != nil {
			return _cbcbea
		}
	}
	if _gcbaa.Handles != nil {
		if _cafac := _gcbaa.Handles.ValidateWithPath(path + "\u002fHandles"); _cafac != nil {
			return _cafac
		}
	}
	if _gcbaa.Fill != nil {
		if _bcccc := _gcbaa.Fill.ValidateWithPath(path + "\u002fFill"); _bcccc != nil {
			return _bcccc
		}
	}
	if _gcbaa.Stroke != nil {
		if _adddf := _gcbaa.Stroke.ValidateWithPath(path + "\u002fStroke"); _adddf != nil {
			return _adddf
		}
	}
	if _gcbaa.Shadow != nil {
		if _bgafg := _gcbaa.Shadow.ValidateWithPath(path + "\u002fShadow"); _bgafg != nil {
			return _bgafg
		}
	}
	if _gcbaa.Textbox != nil {
		if _ebacbb := _gcbaa.Textbox.ValidateWithPath(path + "\u002fTextbox"); _ebacbb != nil {
			return _ebacbb
		}
	}
	if _gcbaa.Textpath != nil {
		if _afdge := _gcbaa.Textpath.ValidateWithPath(path + "\u002fTextpath"); _afdge != nil {
			return _afdge
		}
	}
	if _gcbaa.Imagedata != nil {
		if _egfda := _gcbaa.Imagedata.ValidateWithPath(path + "\u002fImagedata"); _egfda != nil {
			return _egfda
		}
	}
	if _gcbaa.Skew != nil {
		if _gbeec := _gcbaa.Skew.ValidateWithPath(path + "\u002fSkew"); _gbeec != nil {
			return _gbeec
		}
	}
	if _gcbaa.Extrusion != nil {
		if _fcfe := _gcbaa.Extrusion.ValidateWithPath(path + "\u002fExtrusion"); _fcfe != nil {
			return _fcfe
		}
	}
	if _gcbaa.Callout != nil {
		if _fdfea := _gcbaa.Callout.ValidateWithPath(path + "\u002fCallout"); _fdfea != nil {
			return _fdfea
		}
	}
	if _gcbaa.Lock != nil {
		if _agbd := _gcbaa.Lock.ValidateWithPath(path + "\u002fLock"); _agbd != nil {
			return _agbd
		}
	}
	if _gcbaa.Clippath != nil {
		if _faffc := _gcbaa.Clippath.ValidateWithPath(path + "\u002fClippath"); _faffc != nil {
			return _faffc
		}
	}
	if _gcbaa.Signatureline != nil {
		if _beff := _gcbaa.Signatureline.ValidateWithPath(path + "\u002fSignatureline"); _beff != nil {
			return _beff
		}
	}
	if _gcbaa.Wrap != nil {
		if _ddgbba := _gcbaa.Wrap.ValidateWithPath(path + "\u002fWrap"); _ddgbba != nil {
			return _ddgbba
		}
	}
	if _gcbaa.Anchorlock != nil {
		if _efdf := _gcbaa.Anchorlock.ValidateWithPath(path + "/Anchorlock"); _efdf != nil {
			return _efdf
		}
	}
	if _gcbaa.Bordertop != nil {
		if _dacce := _gcbaa.Bordertop.ValidateWithPath(path + "\u002fBordertop"); _dacce != nil {
			return _dacce
		}
	}
	if _gcbaa.Borderbottom != nil {
		if _ggcdc := _gcbaa.Borderbottom.ValidateWithPath(path + "\u002fBorderbottom"); _ggcdc != nil {
			return _ggcdc
		}
	}
	if _gcbaa.Borderleft != nil {
		if _edbce := _gcbaa.Borderleft.ValidateWithPath(path + "/Borderleft"); _edbce != nil {
			return _edbce
		}
	}
	if _gcbaa.Borderright != nil {
		if _fgdge := _gcbaa.Borderright.ValidateWithPath(path + "\u002fBorderright"); _fgdge != nil {
			return _fgdge
		}
	}
	if _gcbaa.ClientData != nil {
		if _fbeeb := _gcbaa.ClientData.ValidateWithPath(path + "/ClientData"); _fbeeb != nil {
			return _fbeeb
		}
	}
	if _gcbaa.Textdata != nil {
		if _aega := _gcbaa.Textdata.ValidateWithPath(path + "\u002fTextdata"); _aega != nil {
			return _aega
		}
	}
	return nil
}

// Validate validates the AG_OfficeShapeAttributes and its children
func (_cdf *AG_OfficeShapeAttributes) Validate() error {
	return _cdf.ValidateWithPath("AG_OfficeShapeAttributes")
}

// ValidateWithPath validates the CT_RoundRect and its children, prefixing error messages with path
func (_gaaf *CT_RoundRect) ValidateWithPath(path string) error {
	for _gdgce, _ffce := range _gaaf.EG_ShapeElements {
		if _ebfg := _ffce.ValidateWithPath(_f.Sprintf("\u0025s\u002fEG_ShapeElements\u005b\u0025d\u005d", path, _gdgce)); _ebfg != nil {
			return _ebfg
		}
	}
	if _ecdeb := _gaaf.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _ecdeb != nil {
		return _ecdeb
	}
	if _ccde := _gaaf.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _ccde != nil {
		return _ccde
	}
	if _fabbe := _gaaf.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _fabbe != nil {
		return _fabbe
	}
	if _fgfdb := _gaaf.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _fgfdb != nil {
		return _fgfdb
	}
	if _fagbe := _gaaf.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _fagbe != nil {
		return _fagbe
	}
	if _acbee := _gaaf.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _acbee != nil {
		return _acbee
	}
	if _accce := _gaaf.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _accce != nil {
		return _accce
	}
	if _eggdc := _gaaf.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _eggdc != nil {
		return _eggdc
	}
	if _feeb := _gaaf.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _feeb != nil {
		return _feeb
	}
	if _gdbfag := _gaaf.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _gdbfag != nil {
		return _gdbfag
	}
	if _gcfgg := _gaaf.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _gcfgg != nil {
		return _gcfgg
	}
	if _dgfeb := _gaaf.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _dgfeb != nil {
		return _dgfeb
	}
	if _becc := _gaaf.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _becc != nil {
		return _becc
	}
	if _ccafc := _gaaf.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _ccafc != nil {
		return _ccafc
	}
	if _egfgc := _gaaf.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _egfgc != nil {
		return _egfgc
	}
	if _dafac := _gaaf.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _dafac != nil {
		return _dafac
	}
	if _edbeb := _gaaf.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _edbeb != nil {
		return _edbeb
	}
	if _cbfe := _gaaf.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _cbfe != nil {
		return _cbfe
	}
	if _dedfe := _gaaf.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _dedfe != nil {
		return _dedfe
	}
	if _gage := _gaaf.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _gage != nil {
		return _gage
	}
	if _afdbb := _gaaf.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _afdbb != nil {
		return _afdbb
	}
	if _faae := _gaaf.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _faae != nil {
		return _faae
	}
	if _geceb := _gaaf.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _geceb != nil {
		return _geceb
	}
	if _fcgfc := _gaaf.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _fcgfc != nil {
		return _fcgfc
	}
	if _dgdc := _gaaf.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _dgdc != nil {
		return _dgdc
	}
	if _ecgaf := _gaaf.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _ecgaf != nil {
		return _ecgaf
	}
	if _aeag := _gaaf.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _aeag != nil {
		return _aeag
	}
	if _aecb := _gaaf.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _aecb != nil {
		return _aecb
	}
	if _cbfg := _gaaf.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _cbfg != nil {
		return _cbfg
	}
	return nil
}
func (_bafde ST_StrokeArrowLength) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bbgdd := _b.Attr{}
	_bbgdd.Name = name
	switch _bafde {
	case ST_StrokeArrowLengthUnset:
		_bbgdd.Value = ""
	case ST_StrokeArrowLengthShort:
		_bbgdd.Value = "short"
	case ST_StrokeArrowLengthMedium:
		_bbgdd.Value = "medium"
	case ST_StrokeArrowLengthLong:
		_bbgdd.Value = "long"
	}
	return _bbgdd, nil
}
func (_eeaaa *Line) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_eeaaa.CT_Line = *NewCT_Line()
	for _, _bbegc := range start.Attr {
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "userdrawn" {
			_eeaaa.UserdrawnAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "button" {
			_eeaaa.ButtonAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "dgmlayoutmru" {
			_eeaaa.DgmlayoutmruAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "userhidden" {
			_eeaaa.UserhiddenAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "cliptowrap" {
			_eeaaa.CliptowrapAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "bullet" {
			_eeaaa.BulletAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "ole" {
			_eeaaa.OleAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "hr" {
			_eeaaa.HrAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "spid" {
			_gggce, _afdgef := _bbegc.Value, error(nil)
			if _afdgef != nil {
				return _afdgef
			}
			_eeaaa.SpidAttr = &_gggce
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "hrstd" {
			_eeaaa.HrstdAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "bwnormal" {
			_eeaaa.BwnormalAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "bordertopcolor" {
			_gaeeb, _fdfge := _bbegc.Value, error(nil)
			if _fdfge != nil {
				return _fdfge
			}
			_eeaaa.BordertopcolorAttr = &_gaeeb
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "dgmlayout" {
			_eeaaa.DgmlayoutAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "forcedash" {
			_eeaaa.ForcedashAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "allowoverlap" {
			_eeaaa.AllowoverlapAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "hrnoshade" {
			_eeaaa.HrnoshadeAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "preferrelative" {
			_eeaaa.PreferrelativeAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "borderbottomcolor" {
			_gbefg, _acga := _bbegc.Value, error(nil)
			if _acga != nil {
				return _acga
			}
			_eeaaa.BorderbottomcolorAttr = &_gbefg
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "oned" {
			_eeaaa.OnedAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "dgmnodekind" {
			_bbgfb, _aedb := _e.ParseInt(_bbegc.Value, 10, 64)
			if _aedb != nil {
				return _aedb
			}
			_eeaaa.DgmnodekindAttr = &_bbgfb
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "regroupid" {
			_gbaf, _affba := _e.ParseInt(_bbegc.Value, 10, 64)
			if _affba != nil {
				return _affba
			}
			_eeaaa.RegroupidAttr = &_gbaf
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "allowincell" {
			_eeaaa.AllowincellAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "hrpct" {
			_fcbdf, _bbcdc := _e.ParseFloat(_bbegc.Value, 64)
			if _bbcdc != nil {
				return _bbcdc
			}
			_dgeeg := float32(_fcbdf)
			_eeaaa.HrpctAttr = &_dgeeg
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "clip" {
			_eeaaa.ClipAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "insetmode" {
			_eeaaa.InsetmodeAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "borderleftcolor" {
			_aagea, _eedff := _bbegc.Value, error(nil)
			if _eedff != nil {
				return _eedff
			}
			_eeaaa.BorderleftcolorAttr = &_aagea
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "oleicon" {
			_eeaaa.OleiconAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "borderrightcolor" {
			_agge, _dbaef := _bbegc.Value, error(nil)
			if _dbaef != nil {
				return _dbaef
			}
			_eeaaa.BorderrightcolorAttr = &_agge
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "connectortype" {
			_eeaaa.ConnectortypeAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "bwpure" {
			_eeaaa.BwpureAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "bwmode" {
			_eeaaa.BwmodeAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "spt" {
			_aaagf, _dcabce := _e.ParseFloat(_bbegc.Value, 64)
			if _dcabce != nil {
				return _dcabce
			}
			_dbagg := float32(_aaagf)
			_eeaaa.SptAttr = &_dbagg
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "doubleclicknotify" {
			_eeaaa.DoubleclicknotifyAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bbegc.Name.Local == "hralign" {
			_eeaaa.HralignAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Local == "to" {
			_aacfc, _dgddd := _bbegc.Value, error(nil)
			if _dgddd != nil {
				return _dgddd
			}
			_eeaaa.ToAttr = &_aacfc
			continue
		}
		if _bbegc.Name.Local == "id" {
			_egbca, _dfecbf := _bbegc.Value, error(nil)
			if _dfecbf != nil {
				return _dfecbf
			}
			_eeaaa.IdAttr = &_egbca
			continue
		}
		if _bbegc.Name.Local == "alt" {
			_abdbc, _dcdeb := _bbegc.Value, error(nil)
			if _dcdeb != nil {
				return _dcdeb
			}
			_eeaaa.AltAttr = &_abdbc
			continue
		}
		if _bbegc.Name.Local == "print" {
			_eeaaa.PrintAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Local == "stroked" {
			_eeaaa.StrokedAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Local == "wrapcoords" {
			_dfdgd, _egced := _bbegc.Value, error(nil)
			if _egced != nil {
				return _egced
			}
			_eeaaa.WrapcoordsAttr = &_dfdgd
			continue
		}
		if _bbegc.Name.Local == "strokeweight" {
			_cgebc, _dcace := _bbegc.Value, error(nil)
			if _dcace != nil {
				return _dcace
			}
			_eeaaa.StrokeweightAttr = &_cgebc
			continue
		}
		if _bbegc.Name.Local == "coordorigin" {
			_fcddf, _bdbfc := _bbegc.Value, error(nil)
			if _bdbfc != nil {
				return _bdbfc
			}
			_eeaaa.CoordoriginAttr = &_fcddf
			continue
		}
		if _bbegc.Name.Local == "chromakey" {
			_bacbgd, _bddgg := _bbegc.Value, error(nil)
			if _bddgg != nil {
				return _bddgg
			}
			_eeaaa.ChromakeyAttr = &_bacbgd
			continue
		}
		if _bbegc.Name.Local == "fillcolor" {
			_cadag, _daffa := _bbegc.Value, error(nil)
			if _daffa != nil {
				return _daffa
			}
			_eeaaa.FillcolorAttr = &_cadag
			continue
		}
		if _bbegc.Name.Local == "style" {
			_ccacg, _dfcb := _bbegc.Value, error(nil)
			if _dfcb != nil {
				return _dfcb
			}
			_eeaaa.StyleAttr = &_ccacg
			continue
		}
		if _bbegc.Name.Local == "opacity" {
			_egcbe, _affgd := _bbegc.Value, error(nil)
			if _affgd != nil {
				return _affgd
			}
			_eeaaa.OpacityAttr = &_egcbe
			continue
		}
		if _bbegc.Name.Local == "strokecolor" {
			_ecgfb, _bada := _bbegc.Value, error(nil)
			if _bada != nil {
				return _bada
			}
			_eeaaa.StrokecolorAttr = &_ecgfb
			continue
		}
		if _bbegc.Name.Local == "insetpen" {
			_eeaaa.InsetpenAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
		if _bbegc.Name.Local == "from" {
			_aebgg, _dede := _bbegc.Value, error(nil)
			if _dede != nil {
				return _dede
			}
			_eeaaa.FromAttr = &_aebgg
			continue
		}
		if _bbegc.Name.Local == "coordsize" {
			_ccgc, _dcdaa := _bbegc.Value, error(nil)
			if _dcdaa != nil {
				return _dcdaa
			}
			_eeaaa.CoordsizeAttr = &_ccgc
			continue
		}
		if _bbegc.Name.Local == "title" {
			_ebcgf, _edbeg := _bbegc.Value, error(nil)
			if _edbeg != nil {
				return _edbeg
			}
			_eeaaa.TitleAttr = &_ebcgf
			continue
		}
		if _bbegc.Name.Local == "class" {
			_aeggg, _dgcgb := _bbegc.Value, error(nil)
			if _dgcgb != nil {
				return _dgcgb
			}
			_eeaaa.ClassAttr = &_aeggg
			continue
		}
		if _bbegc.Name.Local == "target" {
			_geddd, _ccaee := _bbegc.Value, error(nil)
			if _ccaee != nil {
				return _ccaee
			}
			_eeaaa.TargetAttr = &_geddd
			continue
		}
		if _bbegc.Name.Local == "href" {
			_ffad, _agbca := _bbegc.Value, error(nil)
			if _agbca != nil {
				return _agbca
			}
			_eeaaa.HrefAttr = &_ffad
			continue
		}
		if _bbegc.Name.Local == "filled" {
			_eeaaa.FilledAttr.UnmarshalXMLAttr(_bbegc)
			continue
		}
	}
_cgefd:
	for {
		_bfag, _dbfd := d.Token()
		if _dbfd != nil {
			return _dbfd
		}
		switch _caddg := _bfag.(type) {
		case _b.StartElement:
			switch _caddg.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_edcd := NewEG_ShapeElements()
				_edcd.Path = NewPath()
				if _cabdg := d.DecodeElement(_edcd.Path, &_caddg); _cabdg != nil {
					return _cabdg
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _edcd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_eggbc := NewEG_ShapeElements()
				_eggbc.Formulas = NewFormulas()
				if _feddf := d.DecodeElement(_eggbc.Formulas, &_caddg); _feddf != nil {
					return _feddf
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _eggbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_acceb := NewEG_ShapeElements()
				_acceb.Handles = NewHandles()
				if _aacaa := d.DecodeElement(_acceb.Handles, &_caddg); _aacaa != nil {
					return _aacaa
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _acceb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_bbeea := NewEG_ShapeElements()
				_bbeea.Fill = NewFill()
				if _bcff := d.DecodeElement(_bbeea.Fill, &_caddg); _bcff != nil {
					return _bcff
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _bbeea)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_cabgaf := NewEG_ShapeElements()
				_cabgaf.Stroke = NewStroke()
				if _fdebc := d.DecodeElement(_cabgaf.Stroke, &_caddg); _fdebc != nil {
					return _fdebc
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _cabgaf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_ceggd := NewEG_ShapeElements()
				_ceggd.Shadow = NewShadow()
				if _cefg := d.DecodeElement(_ceggd.Shadow, &_caddg); _cefg != nil {
					return _cefg
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _ceggd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_eafeb := NewEG_ShapeElements()
				_eafeb.Textbox = NewTextbox()
				if _daed := d.DecodeElement(_eafeb.Textbox, &_caddg); _daed != nil {
					return _daed
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _eafeb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_aabda := NewEG_ShapeElements()
				_aabda.Textpath = NewTextpath()
				if _dgba := d.DecodeElement(_aabda.Textpath, &_caddg); _dgba != nil {
					return _dgba
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _aabda)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_bagca := NewEG_ShapeElements()
				_bagca.Imagedata = NewImagedata()
				if _fgfge := d.DecodeElement(_bagca.Imagedata, &_caddg); _fgfge != nil {
					return _fgfge
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _bagca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_bdee := NewEG_ShapeElements()
				_bdee.Skew = NewOfcSkew()
				if _ddffb := d.DecodeElement(_bdee.Skew, &_caddg); _ddffb != nil {
					return _ddffb
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _bdee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_agfdd := NewEG_ShapeElements()
				_agfdd.Extrusion = NewOfcExtrusion()
				if _gbcd := d.DecodeElement(_agfdd.Extrusion, &_caddg); _gbcd != nil {
					return _gbcd
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _agfdd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_fedga := NewEG_ShapeElements()
				_fedga.Callout = NewOfcCallout()
				if _ebecg := d.DecodeElement(_fedga.Callout, &_caddg); _ebecg != nil {
					return _ebecg
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _fedga)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_gdgcff := NewEG_ShapeElements()
				_gdgcff.Lock = NewOfcLock()
				if _dccdb := d.DecodeElement(_gdgcff.Lock, &_caddg); _dccdb != nil {
					return _dccdb
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _gdgcff)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_dbdda := NewEG_ShapeElements()
				_dbdda.Clippath = NewOfcClippath()
				if _faafe := d.DecodeElement(_dbdda.Clippath, &_caddg); _faafe != nil {
					return _faafe
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _dbdda)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_edcbc := NewEG_ShapeElements()
				_edcbc.Signatureline = NewOfcSignatureline()
				if _bbegb := d.DecodeElement(_edcbc.Signatureline, &_caddg); _bbegb != nil {
					return _bbegb
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _edcbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_cbdfb := NewEG_ShapeElements()
				_cbdfb.Wrap = _a.NewWrap()
				if _eddbcd := d.DecodeElement(_cbdfb.Wrap, &_caddg); _eddbcd != nil {
					return _eddbcd
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _cbdfb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_aaafc := NewEG_ShapeElements()
				_aaafc.Anchorlock = _a.NewAnchorlock()
				if _eaabd := d.DecodeElement(_aaafc.Anchorlock, &_caddg); _eaabd != nil {
					return _eaabd
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _aaafc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_dfcf := NewEG_ShapeElements()
				_dfcf.Bordertop = _a.NewBordertop()
				if _dcfgd := d.DecodeElement(_dfcf.Bordertop, &_caddg); _dcfgd != nil {
					return _dcfgd
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _dfcf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_bgcaf := NewEG_ShapeElements()
				_bgcaf.Borderbottom = _a.NewBorderbottom()
				if _caeeb := d.DecodeElement(_bgcaf.Borderbottom, &_caddg); _caeeb != nil {
					return _caeeb
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _bgcaf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_caggd := NewEG_ShapeElements()
				_caggd.Borderleft = _a.NewBorderleft()
				if _bcad := d.DecodeElement(_caggd.Borderleft, &_caddg); _bcad != nil {
					return _bcad
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _caggd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_fbgcc := NewEG_ShapeElements()
				_fbgcc.Borderright = _a.NewBorderright()
				if _dgefc := d.DecodeElement(_fbgcc.Borderright, &_caddg); _dgefc != nil {
					return _dgefc
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _fbgcc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_gddbb := NewEG_ShapeElements()
				_gddbb.ClientData = _c.NewClientData()
				if _bdgae := d.DecodeElement(_gddbb.ClientData, &_caddg); _bdgae != nil {
					return _bdgae
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _gddbb)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_bgabe := NewEG_ShapeElements()
				_bgabe.Textdata = _bf.NewTextdata()
				if _ccdga := d.DecodeElement(_bgabe.Textdata, &_caddg); _ccdga != nil {
					return _ccdga
				}
				_eeaaa.EG_ShapeElements = append(_eeaaa.EG_ShapeElements, _bgabe)
			default:
				_ba.Log("skipping\u0020unsupported element\u0020on\u0020Line\u0020\u0025v", _caddg.Name)
				if _abbgg := d.Skip(); _abbgg != nil {
					return _abbgg
				}
			}
		case _b.EndElement:
			break _cgefd
		case _b.CharData:
		}
	}
	return nil
}
func NewAG_OfficeCoreAttributes() *AG_OfficeCoreAttributes {
	_egab := &AG_OfficeCoreAttributes{}
	return _egab
}
func (_bfgfd *OfcCT_Entry) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _bfgfd.NewAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "new"}, Value: _f.Sprintf("\u0025v", *_bfgfd.NewAttr)})
	}
	if _bfgfd.OldAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "old"}, Value: _f.Sprintf("\u0025v", *_bfgfd.OldAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_dbe *AG_Fill) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _dbe.FilledAttr != _eb.ST_TrueFalseUnset {
		_bfce, _eea := _dbe.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _eea != nil {
			return _eea
		}
		start.Attr = append(start.Attr, _bfce)
	}
	if _dbe.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_dbe.FillcolorAttr)})
	}
	return nil
}
func (_bgfdab ST_StrokeJoinStyle) String() string {
	switch _bgfdab {
	case 0:
		return ""
	case 1:
		return "round"
	case 2:
		return "bevel"
	case 3:
		return "miter"
	}
	return ""
}

type ST_ShadowType byte

func (_eecfef *Shape) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _eecfef.CT_Shape.MarshalXML(e, start)
}
func NewCT_TextPath() *CT_TextPath { _dccea := &CT_TextPath{}; return _dccea }
func (_gdffaa *OfcExtrusion) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _gdffaa.OfcCT_Extrusion.MarshalXML(e, start)
}

// ValidateWithPath validates the CT_Formulas and its children, prefixing error messages with path
func (_gbef *CT_Formulas) ValidateWithPath(path string) error {
	for _eacd, _dfga := range _gbef.F {
		if _beed := _dfga.ValidateWithPath(_f.Sprintf("\u0025s\u002fF\u005b\u0025d\u005d", path, _eacd)); _beed != nil {
			return _beed
		}
	}
	return nil
}
func (_gcdcf *Shadow) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_gcdcf.CT_Shadow = *NewCT_Shadow()
	for _, _degea := range start.Attr {
		if _degea.Name.Local == "on" {
			_gcdcf.OnAttr.UnmarshalXMLAttr(_degea)
			continue
		}
		if _degea.Name.Local == "type" {
			_gcdcf.TypeAttr.UnmarshalXMLAttr(_degea)
			continue
		}
		if _degea.Name.Local == "obscured" {
			_gcdcf.ObscuredAttr.UnmarshalXMLAttr(_degea)
			continue
		}
		if _degea.Name.Local == "color" {
			_gfdf, _bbdde := _degea.Value, error(nil)
			if _bbdde != nil {
				return _bbdde
			}
			_gcdcf.ColorAttr = &_gfdf
			continue
		}
		if _degea.Name.Local == "opacity" {
			_cbffe, _gfcdd := _degea.Value, error(nil)
			if _gfcdd != nil {
				return _gfcdd
			}
			_gcdcf.OpacityAttr = &_cbffe
			continue
		}
		if _degea.Name.Local == "offset" {
			_bfdcb, _cgddd := _degea.Value, error(nil)
			if _cgddd != nil {
				return _cgddd
			}
			_gcdcf.OffsetAttr = &_bfdcb
			continue
		}
		if _degea.Name.Local == "color2" {
			_gbfgb, _agbfg := _degea.Value, error(nil)
			if _agbfg != nil {
				return _agbfg
			}
			_gcdcf.Color2Attr = &_gbfgb
			continue
		}
		if _degea.Name.Local == "offset2" {
			_ffcge, _cecaa := _degea.Value, error(nil)
			if _cecaa != nil {
				return _cecaa
			}
			_gcdcf.Offset2Attr = &_ffcge
			continue
		}
		if _degea.Name.Local == "origin" {
			_ddbab, _aecd := _degea.Value, error(nil)
			if _aecd != nil {
				return _aecd
			}
			_gcdcf.OriginAttr = &_ddbab
			continue
		}
		if _degea.Name.Local == "matrix" {
			_gfced, _fbfcc := _degea.Value, error(nil)
			if _fbfcc != nil {
				return _fbfcc
			}
			_gcdcf.MatrixAttr = &_gfced
			continue
		}
		if _degea.Name.Local == "id" {
			_ggagf, _eegdf := _degea.Value, error(nil)
			if _eegdf != nil {
				return _eegdf
			}
			_gcdcf.IdAttr = &_ggagf
			continue
		}
	}
	for {
		_bfgec, _ffbgb := d.Token()
		if _ffbgb != nil {
			return _f.Errorf("parsing\u0020Shadow:\u0020\u0025s", _ffbgb)
		}
		if _ffaaac, _caecbg := _bfgec.(_b.EndElement); _caecbg && _ffaaac.Name == start.Name {
			break
		}
	}
	return nil
}
func (_dfeac *OfcInk) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dfeac.OfcCT_Ink = *NewOfcCT_Ink()
	for _, _eebbg := range start.Attr {
		if _eebbg.Name.Local == "i" {
			_gbace, _gcaagg := _eebbg.Value, error(nil)
			if _gcaagg != nil {
				return _gcaagg
			}
			_dfeac.IAttr = &_gbace
			continue
		}
		if _eebbg.Name.Local == "annotation" {
			_dfeac.AnnotationAttr.UnmarshalXMLAttr(_eebbg)
			continue
		}
		if _eebbg.Name.Local == "contentType" {
			_fcfce, _bdce := _eebbg.Value, error(nil)
			if _bdce != nil {
				return _bdce
			}
			_dfeac.ContentTypeAttr = &_fcfce
			continue
		}
	}
	for {
		_cgfgc, _dfbad := d.Token()
		if _dfbad != nil {
			return _f.Errorf("parsing\u0020OfcInk:\u0020\u0025s", _dfbad)
		}
		if _aabde, _ggefe := _cgfgc.(_b.EndElement); _ggefe && _aabde.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the OfcCT_SignatureLine and its children, prefixing error messages with path
func (_acfde *OfcCT_SignatureLine) ValidateWithPath(path string) error {
	if _begdb := _acfde.IssignaturelineAttr.ValidateWithPath(path + "/IssignaturelineAttr"); _begdb != nil {
		return _begdb
	}
	if _acfde.IdAttr != nil {
		if !_eb.ST_GuidPatternRe.MatchString(*_acfde.IdAttr) {
			return _f.Errorf("\u0025s/m\u002eIdAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _eb.ST_GuidPatternRe, *_acfde.IdAttr)
		}
	}
	if _acfde.ProvidAttr != nil {
		if !_eb.ST_GuidPatternRe.MatchString(*_acfde.ProvidAttr) {
			return _f.Errorf("\u0025s\u002fm\u002eProvidAttr\u0020must\u0020match\u0020\u0027\u0025s\u0027\u0020\u0028have\u0020\u0025v\u0029", path, _eb.ST_GuidPatternRe, *_acfde.ProvidAttr)
		}
	}
	if _dbeff := _acfde.SigninginstructionssetAttr.ValidateWithPath(path + "/SigninginstructionssetAttr"); _dbeff != nil {
		return _dbeff
	}
	if _fbagd := _acfde.AllowcommentsAttr.ValidateWithPath(path + "\u002fAllowcommentsAttr"); _fbagd != nil {
		return _fbagd
	}
	if _afdag := _acfde.ShowsigndateAttr.ValidateWithPath(path + "\u002fShowsigndateAttr"); _afdag != nil {
		return _afdag
	}
	if _caff := _acfde.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _caff != nil {
		return _caff
	}
	return nil
}
func (_bdddgb OfcST_FillType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_fdeea := _b.Attr{}
	_fdeea.Name = name
	switch _bdddgb {
	case OfcST_FillTypeUnset:
		_fdeea.Value = ""
	case OfcST_FillTypeGradientCenter:
		_fdeea.Value = "gradientCenter"
	case OfcST_FillTypeSolid:
		_fdeea.Value = "solid"
	case OfcST_FillTypePattern:
		_fdeea.Value = "pattern"
	case OfcST_FillTypeTile:
		_fdeea.Value = "tile"
	case OfcST_FillTypeFrame:
		_fdeea.Value = "frame"
	case OfcST_FillTypeGradientUnscaled:
		_fdeea.Value = "gradientUnscaled"
	case OfcST_FillTypeGradientRadial:
		_fdeea.Value = "gradientRadial"
	case OfcST_FillTypeGradient:
		_fdeea.Value = "gradient"
	case OfcST_FillTypeBackground:
		_fdeea.Value = "background"
	}
	return _fdeea, nil
}

type OfcST_HrAlign byte

func (_bgeg OfcST_RType) Validate() error        { return _bgeg.ValidateWithPath("") }
func NewAG_ShapeAttributes() *AG_ShapeAttributes { _cabf := &AG_ShapeAttributes{}; return _cabf }

type ST_FillMethod byte

func NewCT_Rect() *CT_Rect { _adcb := &CT_Rect{}; return _adcb }
func (_gcad OfcST_HrAlign) String() string {
	switch _gcad {
	case 0:
		return ""
	case 1:
		return "left"
	case 2:
		return "right"
	case 3:
		return "center"
	}
	return ""
}

const (
	OfcST_OLETypeUnset OfcST_OLEType = 0
	OfcST_OLETypeEmbed OfcST_OLEType = 1
	OfcST_OLETypeLink  OfcST_OLEType = 2
)

func (_eagf OfcST_ExtrusionType) Validate() error { return _eagf.ValidateWithPath("") }

type OfcST_ExtrusionType byte

// ValidateWithPath validates the OfcRight and its children, prefixing error messages with path
func (_fgee *OfcRight) ValidateWithPath(path string) error {
	if _effgd := _fgee.OfcCT_StrokeChild.ValidateWithPath(path); _effgd != nil {
		return _effgd
	}
	return nil
}
func NewEG_ShapeElements() *EG_ShapeElements { _deee := &EG_ShapeElements{}; return _deee }
func (_bgba *OfcST_ColorMode) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_bgba = 0
	case "auto":
		*_bgba = 1
	case "custom":
		*_bgba = 2
	}
	return nil
}
func (_adceb ST_FillType) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_adceb.String(), start)
}
func (_baffd OfcST_Angle) Validate() error { return _baffd.ValidateWithPath("") }

// Validate validates the CT_Curve and its children
func (_bdfca *CT_Curve) Validate() error { return _bdfca.ValidateWithPath("CT_Curve") }
func (_acgbg OfcST_OLEDrawAspect) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_ddgef := _b.Attr{}
	_ddgef.Name = name
	switch _acgbg {
	case OfcST_OLEDrawAspectUnset:
		_ddgef.Value = ""
	case OfcST_OLEDrawAspectContent:
		_ddgef.Value = "Content"
	case OfcST_OLEDrawAspectIcon:
		_ddgef.Value = "Icon"
	}
	return _ddgef, nil
}
func (_dfgba *ST_ShadowType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ddddb, _dbfbg := d.Token()
	if _dbfbg != nil {
		return _dbfbg
	}
	if _dggacg, _baede := _ddddb.(_b.EndElement); _baede && _dggacg.Name == start.Name {
		*_dfgba = 1
		return nil
	}
	if _cgaad, _fddcff := _ddddb.(_b.CharData); !_fddcff {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ddddb)
	} else {
		switch string(_cgaad) {
		case "":
			*_dfgba = 0
		case "single":
			*_dfgba = 1
		case "double":
			*_dfgba = 2
		case "emboss":
			*_dfgba = 3
		case "perspective":
			*_dfgba = 4
		}
	}
	_ddddb, _dbfbg = d.Token()
	if _dbfbg != nil {
		return _dbfbg
	}
	if _dgfcb, _bfbaa := _ddddb.(_b.EndElement); _bfbaa && _dgfcb.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ddddb)
}

type OfcBottom struct{ OfcCT_StrokeChild }

func (_aefdd *OfcCT_Diagram) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _aefdd.DgmstyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "dgmstyle"}, Value: _f.Sprintf("\u0025v", *_aefdd.DgmstyleAttr)})
	}
	if _aefdd.AutoformatAttr != _eb.ST_TrueFalseUnset {
		_fcedc, _cedge := _aefdd.AutoformatAttr.MarshalXMLAttr(_b.Name{Local: "autoformat"})
		if _cedge != nil {
			return _cedge
		}
		start.Attr = append(start.Attr, _fcedc)
	}
	if _aefdd.ReverseAttr != _eb.ST_TrueFalseUnset {
		_gaaaa, _fefeg := _aefdd.ReverseAttr.MarshalXMLAttr(_b.Name{Local: "reverse"})
		if _fefeg != nil {
			return _fefeg
		}
		start.Attr = append(start.Attr, _gaaaa)
	}
	if _aefdd.AutolayoutAttr != _eb.ST_TrueFalseUnset {
		_gbdfb, _fega := _aefdd.AutolayoutAttr.MarshalXMLAttr(_b.Name{Local: "autolayout"})
		if _fega != nil {
			return _fega
		}
		start.Attr = append(start.Attr, _gbdfb)
	}
	if _aefdd.DgmscalexAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "dgmscalex"}, Value: _f.Sprintf("\u0025v", *_aefdd.DgmscalexAttr)})
	}
	if _aefdd.DgmscaleyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "dgmscaley"}, Value: _f.Sprintf("\u0025v", *_aefdd.DgmscaleyAttr)})
	}
	if _aefdd.DgmfontsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "dgmfontsize"}, Value: _f.Sprintf("\u0025v", *_aefdd.DgmfontsizeAttr)})
	}
	if _aefdd.ConstrainboundsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "constrainbounds"}, Value: _f.Sprintf("\u0025v", *_aefdd.ConstrainboundsAttr)})
	}
	if _aefdd.DgmbasetextscaleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "dgmbasetextscale"}, Value: _f.Sprintf("\u0025v", *_aefdd.DgmbasetextscaleAttr)})
	}
	if _aefdd.ExtAttr != ST_ExtUnset {
		_cdgde, _cabda := _aefdd.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _cabda != nil {
			return _cabda
		}
		start.Attr = append(start.Attr, _cdgde)
	}
	e.EncodeToken(start)
	if _aefdd.Relationtable != nil {
		_dgcfe := _b.StartElement{Name: _b.Name{Local: "o:relationtable"}}
		e.EncodeElement(_aefdd.Relationtable, _dgcfe)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_cfged *OfcCT_Ink) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _cfged.IAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "i"}, Value: _f.Sprintf("\u0025v", *_cfged.IAttr)})
	}
	if _cfged.AnnotationAttr != _eb.ST_TrueFalseUnset {
		_cbdge, _dgdad := _cfged.AnnotationAttr.MarshalXMLAttr(_b.Name{Local: "annotation"})
		if _dgdad != nil {
			return _dgdad
		}
		start.Attr = append(start.Attr, _cbdge)
	}
	if _cfged.ContentTypeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "contentType"}, Value: _f.Sprintf("\u0025v", *_cfged.ContentTypeAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// Validate validates the OfcCT_RegroupTable and its children
func (_cggcd *OfcCT_RegroupTable) Validate() error {
	return _cggcd.ValidateWithPath("OfcCT_RegroupTable")
}

type CT_Arc struct {
	StartAngleAttr        *float64
	EndAngleAttr          *float64
	EG_ShapeElements      []*EG_ShapeElements
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
	OpacityAttr           *string
	StrokedAttr           _eb.ST_TrueFalse
	StrokecolorAttr       *string
	StrokeweightAttr      *string
	InsetpenAttr          _eb.ST_TrueFalse
	ChromakeyAttr         *string
	FilledAttr            _eb.ST_TrueFalse
	FillcolorAttr         *string
	SptAttr               *float32
	ConnectortypeAttr     OfcST_ConnectorType
	BwmodeAttr            OfcST_BWMode
	BwpureAttr            OfcST_BWMode
	BwnormalAttr          OfcST_BWMode
	ForcedashAttr         _eb.ST_TrueFalse
	OleiconAttr           _eb.ST_TrueFalse
	OleAttr               _eb.ST_TrueFalseBlank
	PreferrelativeAttr    _eb.ST_TrueFalse
	CliptowrapAttr        _eb.ST_TrueFalse
	ClipAttr              _eb.ST_TrueFalse
}

func (_ddbcf *OfcCT_Diagram) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ddeca := range start.Attr {
		if _ddeca.Name.Local == "dgmstyle" {
			_egfc, _fgaaf := _e.ParseInt(_ddeca.Value, 10, 64)
			if _fgaaf != nil {
				return _fgaaf
			}
			_ddbcf.DgmstyleAttr = &_egfc
			continue
		}
		if _ddeca.Name.Local == "autoformat" {
			_ddbcf.AutoformatAttr.UnmarshalXMLAttr(_ddeca)
			continue
		}
		if _ddeca.Name.Local == "reverse" {
			_ddbcf.ReverseAttr.UnmarshalXMLAttr(_ddeca)
			continue
		}
		if _ddeca.Name.Local == "autolayout" {
			_ddbcf.AutolayoutAttr.UnmarshalXMLAttr(_ddeca)
			continue
		}
		if _ddeca.Name.Local == "dgmscalex" {
			_ebafc, _cafga := _e.ParseInt(_ddeca.Value, 10, 64)
			if _cafga != nil {
				return _cafga
			}
			_ddbcf.DgmscalexAttr = &_ebafc
			continue
		}
		if _ddeca.Name.Local == "dgmscaley" {
			_edef, _dfefa := _e.ParseInt(_ddeca.Value, 10, 64)
			if _dfefa != nil {
				return _dfefa
			}
			_ddbcf.DgmscaleyAttr = &_edef
			continue
		}
		if _ddeca.Name.Local == "dgmfontsize" {
			_acdcg, _aafeb := _e.ParseInt(_ddeca.Value, 10, 64)
			if _aafeb != nil {
				return _aafeb
			}
			_ddbcf.DgmfontsizeAttr = &_acdcg
			continue
		}
		if _ddeca.Name.Local == "constrainbounds" {
			_bgfdf, _gefce := _ddeca.Value, error(nil)
			if _gefce != nil {
				return _gefce
			}
			_ddbcf.ConstrainboundsAttr = &_bgfdf
			continue
		}
		if _ddeca.Name.Local == "dgmbasetextscale" {
			_fddee, _ccbf := _e.ParseInt(_ddeca.Value, 10, 64)
			if _ccbf != nil {
				return _ccbf
			}
			_ddbcf.DgmbasetextscaleAttr = &_fddee
			continue
		}
		if _ddeca.Name.Local == "ext" {
			_ddbcf.ExtAttr.UnmarshalXMLAttr(_ddeca)
			continue
		}
	}
_fbcfc:
	for {
		_egaaf, _ddfe := d.Token()
		if _ddfe != nil {
			return _ddfe
		}
		switch _fcfec := _egaaf.(type) {
		case _b.StartElement:
			switch _fcfec.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "relationtable"}:
				_ddbcf.Relationtable = NewOfcCT_RelationTable()
				if _ccbfg := d.DecodeElement(_ddbcf.Relationtable, &_fcfec); _ccbfg != nil {
					return _ccbfg
				}
			default:
				_ba.Log("skipping unsupported element\u0020on\u0020OfcCT_Diagram \u0025v", _fcfec.Name)
				if _acace := d.Skip(); _acace != nil {
					return _acace
				}
			}
		case _b.EndElement:
			break _fbcfc
		case _b.CharData:
		}
	}
	return nil
}
func NewOfcCT_EquationXml() *OfcCT_EquationXml { _aadf := &OfcCT_EquationXml{}; return _aadf }
func (_aeddb *OfcCT_Skew) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _aeddb.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_aeddb.IdAttr)})
	}
	if _aeddb.OnAttr != _eb.ST_TrueFalseUnset {
		_cgcd, _bafeab := _aeddb.OnAttr.MarshalXMLAttr(_b.Name{Local: "on"})
		if _bafeab != nil {
			return _bafeab
		}
		start.Attr = append(start.Attr, _cgcd)
	}
	if _aeddb.OffsetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "offset"}, Value: _f.Sprintf("\u0025v", *_aeddb.OffsetAttr)})
	}
	if _aeddb.OriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "origin"}, Value: _f.Sprintf("\u0025v", *_aeddb.OriginAttr)})
	}
	if _aeddb.MatrixAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "matrix"}, Value: _f.Sprintf("\u0025v", *_aeddb.MatrixAttr)})
	}
	if _aeddb.ExtAttr != ST_ExtUnset {
		_beeag, _deaadg := _aeddb.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _deaadg != nil {
			return _deaadg
		}
		start.Attr = append(start.Attr, _beeag)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type OfcSkew struct{ OfcCT_Skew }

func (_bbff *CT_Formulas) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_ebed:
	for {
		_gbaab, _dade := d.Token()
		if _dade != nil {
			return _dade
		}
		switch _bfff := _gbaab.(type) {
		case _b.StartElement:
			switch _bfff.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "f"}:
				_fgdc := NewCT_F()
				if _dfgd := d.DecodeElement(_fgdc, &_bfff); _dfgd != nil {
					return _dfgd
				}
				_bbff.F = append(_bbff.F, _fgdc)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Formulas\u0020\u0025v", _bfff.Name)
				if _ffdd := d.Skip(); _ffdd != nil {
					return _ffdd
				}
			}
		case _b.EndElement:
			break _ebed
		case _b.CharData:
		}
	}
	return nil
}
func (_gggg *AG_ShapeAttributes) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _gggg.OpacityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "opacity"}, Value: _f.Sprintf("\u0025v", *_gggg.OpacityAttr)})
	}
	if _gggg.StrokedAttr != _eb.ST_TrueFalseUnset {
		_fee, _dee := _gggg.StrokedAttr.MarshalXMLAttr(_b.Name{Local: "stroked"})
		if _dee != nil {
			return _dee
		}
		start.Attr = append(start.Attr, _fee)
	}
	if _gggg.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_gggg.StrokecolorAttr)})
	}
	if _gggg.StrokeweightAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokeweight"}, Value: _f.Sprintf("\u0025v", *_gggg.StrokeweightAttr)})
	}
	if _gggg.InsetpenAttr != _eb.ST_TrueFalseUnset {
		_ffaag, _fegf := _gggg.InsetpenAttr.MarshalXMLAttr(_b.Name{Local: "insetpen"})
		if _fegf != nil {
			return _fegf
		}
		start.Attr = append(start.Attr, _ffaag)
	}
	if _gggg.ChromakeyAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "chromakey"}, Value: _f.Sprintf("\u0025v", *_gggg.ChromakeyAttr)})
	}
	if _gggg.FilledAttr != _eb.ST_TrueFalseUnset {
		_daab, _abdd := _gggg.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _abdd != nil {
			return _abdd
		}
		start.Attr = append(start.Attr, _daab)
	}
	if _gggg.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_gggg.FillcolorAttr)})
	}
	return nil
}

// ValidateWithPath validates the AG_Type and its children, prefixing error messages with path
func (_dfff *AG_Type) ValidateWithPath(path string) error { return nil }

const (
	ST_ImageAspectUnset   ST_ImageAspect = 0
	ST_ImageAspectIgnore  ST_ImageAspect = 1
	ST_ImageAspectAtMost  ST_ImageAspect = 2
	ST_ImageAspectAtLeast ST_ImageAspect = 3
)

type OfcCT_ShapeDefaults struct {
	SpidmaxAttr     *int64
	StyleAttr       *string
	FillAttr        _eb.ST_TrueFalse
	FillcolorAttr   *string
	StrokeAttr      _eb.ST_TrueFalse
	StrokecolorAttr *string
	AllowincellAttr _eb.ST_TrueFalse
	Fill            *Fill
	Stroke          *Stroke
	Textbox         *Textbox
	Shadow          *Shadow
	Skew            *OfcSkew
	Extrusion       *OfcExtrusion
	Callout         *OfcCallout
	Lock            *OfcLock
	Colormru        *OfcCT_ColorMru
	Colormenu       *OfcCT_ColorMenu
	ExtAttr         ST_Ext
}

func (_cdedf *OfcCT_Ink) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _decca := range start.Attr {
		if _decca.Name.Local == "i" {
			_gaef, _fafaba := _decca.Value, error(nil)
			if _fafaba != nil {
				return _fafaba
			}
			_cdedf.IAttr = &_gaef
			continue
		}
		if _decca.Name.Local == "annotation" {
			_cdedf.AnnotationAttr.UnmarshalXMLAttr(_decca)
			continue
		}
		if _decca.Name.Local == "contentType" {
			_febfa, _gbfbf := _decca.Value, error(nil)
			if _gbfbf != nil {
				return _gbfbf
			}
			_cdedf.ContentTypeAttr = &_febfa
			continue
		}
	}
	for {
		_cbdfg, _abbfd := d.Token()
		if _abbfd != nil {
			return _f.Errorf("parsing\u0020OfcCT_Ink:\u0020\u0025s", _abbfd)
		}
		if _edbegg, _abdae := _cbdfg.(_b.EndElement); _abdae && _edbegg.Name == start.Name {
			break
		}
	}
	return nil
}
func NewCurve() *Curve { _accac := &Curve{}; _accac.CT_Curve = *NewCT_Curve(); return _accac }

// ValidateWithPath validates the CT_Textbox and its children, prefixing error messages with path
func (_ecfbb *CT_Textbox) ValidateWithPath(path string) error {
	if _deadf := _ecfbb.SingleclickAttr.ValidateWithPath(path + "\u002fSingleclickAttr"); _deadf != nil {
		return _deadf
	}
	if _baccg := _ecfbb.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _baccg != nil {
		return _baccg
	}
	if _ecfbb.TxbxContent != nil {
		if _baeae := _ecfbb.TxbxContent.ValidateWithPath(path + "\u002fTxbxContent"); _baeae != nil {
			return _baeae
		}
	}
	return nil
}
func (_efgdga OfcST_How) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_efgdga.String(), start)
}
func (_eecbb *OfcShapelayout) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:shapelayout"
	return _eecbb.OfcCT_ShapeLayout.MarshalXML(e, start)
}

type OfcCT_OLEObject struct {
	TypeAttr       OfcST_OLEType
	ProgIDAttr     *string
	ShapeIDAttr    *string
	DrawAspectAttr OfcST_OLEDrawAspect
	ObjectIDAttr   *string
	IdAttr         *string
	UpdateModeAttr OfcST_OLEUpdateMode
	LinkType       *string
	LockedField    _eb.ST_TrueFalseBlank
	FieldCodes     *string
}

func NewOfcCT_ShapeDefaults() *OfcCT_ShapeDefaults { _gfaae := &OfcCT_ShapeDefaults{}; return _gfaae }

// Validate validates the AG_AllShapeAttributes and its children
func (_fdb *AG_AllShapeAttributes) Validate() error {
	return _fdb.ValidateWithPath("AG_AllShapeAttributes")
}
func (_efccag *OfcSkew) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _efccag.OfcCT_Skew.MarshalXML(e, start)
}
func (_addedc *OfcST_FillType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_addedc = 0
	case "gradientCenter":
		*_addedc = 1
	case "solid":
		*_addedc = 2
	case "pattern":
		*_addedc = 3
	case "tile":
		*_addedc = 4
	case "frame":
		*_addedc = 5
	case "gradientUnscaled":
		*_addedc = 6
	case "gradientRadial":
		*_addedc = 7
	case "gradient":
		*_addedc = 8
	case "background":
		*_addedc = 9
	}
	return nil
}
func NewOfcTop() *OfcTop {
	_cabbg := &OfcTop{}
	_cabbg.OfcCT_StrokeChild = *NewOfcCT_StrokeChild()
	return _cabbg
}
func (_ffdda ST_StrokeLineStyle) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gdafa := _b.Attr{}
	_gdafa.Name = name
	switch _ffdda {
	case ST_StrokeLineStyleUnset:
		_gdafa.Value = ""
	case ST_StrokeLineStyleSingle:
		_gdafa.Value = "single"
	case ST_StrokeLineStyleThinThin:
		_gdafa.Value = "thinThin"
	case ST_StrokeLineStyleThinThick:
		_gdafa.Value = "thinThick"
	case ST_StrokeLineStyleThickThin:
		_gdafa.Value = "thickThin"
	case ST_StrokeLineStyleThickBetweenThin:
		_gdafa.Value = "thickBetweenThin"
	}
	return _gdafa, nil
}
func NewLine() *Line                               { _faaf := &Line{}; _faaf.CT_Line = *NewCT_Line(); return _faaf }
func NewOfcCT_RelationTable() *OfcCT_RelationTable { _gbcaf := &OfcCT_RelationTable{}; return _gbcaf }
func (_gaecb *OfcST_ColorMode) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dddae, _caffg := d.Token()
	if _caffg != nil {
		return _caffg
	}
	if _dgfaa, _gecdf := _dddae.(_b.EndElement); _gecdf && _dgfaa.Name == start.Name {
		*_gaecb = 1
		return nil
	}
	if _caabg, _ffadf := _dddae.(_b.CharData); !_ffadf {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _dddae)
	} else {
		switch string(_caabg) {
		case "":
			*_gaecb = 0
		case "auto":
			*_gaecb = 1
		case "custom":
			*_gaecb = 2
		}
	}
	_dddae, _caffg = d.Token()
	if _caffg != nil {
		return _caffg
	}
	if _ecacfc, _gbaba := _dddae.(_b.EndElement); _gbaba && _ecacfc.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _dddae)
}
func (_agbf *AG_Type) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _egdg := range start.Attr {
		if _egdg.Name.Local == "type" {
			_abgg, _gdbe := _egdg.Value, error(nil)
			if _gdbe != nil {
				return _gdbe
			}
			_agbf.TypeAttr = &_abgg
			continue
		}
	}
	for {
		_dcdd, _dabd := d.Token()
		if _dabd != nil {
			return _f.Errorf("parsing\u0020AG_Type:\u0020\u0025s", _dabd)
		}
		if _efbd, _aeb := _dcdd.(_b.EndElement); _aeb && _efbd.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_H struct {
	PositionAttr    *string
	PolarAttr       *string
	MapAttr         *string
	InvxAttr        _eb.ST_TrueFalse
	InvyAttr        _eb.ST_TrueFalse
	SwitchAttr      _eb.ST_TrueFalseBlank
	XrangeAttr      *string
	YrangeAttr      *string
	RadiusrangeAttr *string
}

// Validate validates the Formulas and its children
func (_badf *Formulas) Validate() error { return _badf.ValidateWithPath("Formulas") }

// Validate validates the Rect and its children
func (_fgaagc *Rect) Validate() error { return _fgaagc.ValidateWithPath("Rect") }
func (_fcfd *CT_Oval) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bfcad := range start.Attr {
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "bordertopcolor" {
			_afbeg, _abcba := _bfcad.Value, error(nil)
			if _abcba != nil {
				return _abcba
			}
			_fcfd.BordertopcolorAttr = &_afbeg
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "bullet" {
			_fcfd.BulletAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "hr" {
			_fcfd.HrAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "cliptowrap" {
			_fcfd.CliptowrapAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "hrstd" {
			_fcfd.HrstdAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "ole" {
			_fcfd.OleAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "hrnoshade" {
			_fcfd.HrnoshadeAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "oned" {
			_fcfd.OnedAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "hrpct" {
			_fbacd, _eeaffb := _e.ParseFloat(_bfcad.Value, 64)
			if _eeaffb != nil {
				return _eeaffb
			}
			_gefbc := float32(_fbacd)
			_fcfd.HrpctAttr = &_gefbc
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "oleicon" {
			_fcfd.OleiconAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "borderbottomcolor" {
			_eeeff, _addg := _bfcad.Value, error(nil)
			if _addg != nil {
				return _addg
			}
			_fcfd.BorderbottomcolorAttr = &_eeeff
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "dgmlayoutmru" {
			_fcfd.DgmlayoutmruAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "regroupid" {
			_cadf, _bbebb := _e.ParseInt(_bfcad.Value, 10, 64)
			if _bbebb != nil {
				return _bbebb
			}
			_fcfd.RegroupidAttr = &_cadf
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "clip" {
			_fcfd.ClipAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "hralign" {
			_fcfd.HralignAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "preferrelative" {
			_fcfd.PreferrelativeAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "dgmlayout" {
			_fcfd.DgmlayoutAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "doubleclicknotify" {
			_fcfd.DoubleclicknotifyAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "insetmode" {
			_fcfd.InsetmodeAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "button" {
			_fcfd.ButtonAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "userdrawn" {
			_fcfd.UserdrawnAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "allowincell" {
			_fcfd.AllowincellAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "spt" {
			_ddbgg, _dcfg := _e.ParseFloat(_bfcad.Value, 64)
			if _dcfg != nil {
				return _dcfg
			}
			_bafg := float32(_ddbgg)
			_fcfd.SptAttr = &_bafg
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "borderleftcolor" {
			_ecgff, _cbee := _bfcad.Value, error(nil)
			if _cbee != nil {
				return _cbee
			}
			_fcfd.BorderleftcolorAttr = &_ecgff
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "connectortype" {
			_fcfd.ConnectortypeAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "borderrightcolor" {
			_gfdc, _adde := _bfcad.Value, error(nil)
			if _adde != nil {
				return _adde
			}
			_fcfd.BorderrightcolorAttr = &_gfdc
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "spid" {
			_abea, _gefbb := _bfcad.Value, error(nil)
			if _gefbb != nil {
				return _gefbb
			}
			_fcfd.SpidAttr = &_abea
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "dgmnodekind" {
			_dcdg, _cafc := _e.ParseInt(_bfcad.Value, 10, 64)
			if _cafc != nil {
				return _cafc
			}
			_fcfd.DgmnodekindAttr = &_dcdg
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "bwpure" {
			_fcfd.BwpureAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "forcedash" {
			_fcfd.ForcedashAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "bwnormal" {
			_fcfd.BwnormalAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "bwmode" {
			_fcfd.BwmodeAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "userhidden" {
			_fcfd.UserhiddenAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfcad.Name.Local == "allowoverlap" {
			_fcfd.AllowoverlapAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Local == "target" {
			_bgda, _ceaa := _bfcad.Value, error(nil)
			if _ceaa != nil {
				return _ceaa
			}
			_fcfd.TargetAttr = &_bgda
			continue
		}
		if _bfcad.Name.Local == "coordorigin" {
			_aeeee, _dgebf := _bfcad.Value, error(nil)
			if _dgebf != nil {
				return _dgebf
			}
			_fcfd.CoordoriginAttr = &_aeeee
			continue
		}
		if _bfcad.Name.Local == "stroked" {
			_fcfd.StrokedAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Local == "coordsize" {
			_abcda, _acec := _bfcad.Value, error(nil)
			if _acec != nil {
				return _acec
			}
			_fcfd.CoordsizeAttr = &_abcda
			continue
		}
		if _bfcad.Name.Local == "strokeweight" {
			_gggaa, _ggcdg := _bfcad.Value, error(nil)
			if _ggcdg != nil {
				return _ggcdg
			}
			_fcfd.StrokeweightAttr = &_gggaa
			continue
		}
		if _bfcad.Name.Local == "style" {
			_adba, _eccc := _bfcad.Value, error(nil)
			if _eccc != nil {
				return _eccc
			}
			_fcfd.StyleAttr = &_adba
			continue
		}
		if _bfcad.Name.Local == "chromakey" {
			_dadd, _decf := _bfcad.Value, error(nil)
			if _decf != nil {
				return _decf
			}
			_fcfd.ChromakeyAttr = &_dadd
			continue
		}
		if _bfcad.Name.Local == "fillcolor" {
			_fdad, _eaeab := _bfcad.Value, error(nil)
			if _eaeab != nil {
				return _eaeab
			}
			_fcfd.FillcolorAttr = &_fdad
			continue
		}
		if _bfcad.Name.Local == "opacity" {
			_faaag, _afaa := _bfcad.Value, error(nil)
			if _afaa != nil {
				return _afaa
			}
			_fcfd.OpacityAttr = &_faaag
			continue
		}
		if _bfcad.Name.Local == "wrapcoords" {
			_fbgg, _baeea := _bfcad.Value, error(nil)
			if _baeea != nil {
				return _baeea
			}
			_fcfd.WrapcoordsAttr = &_fbgg
			continue
		}
		if _bfcad.Name.Local == "strokecolor" {
			_gcac, _gefc := _bfcad.Value, error(nil)
			if _gefc != nil {
				return _gefc
			}
			_fcfd.StrokecolorAttr = &_gcac
			continue
		}
		if _bfcad.Name.Local == "insetpen" {
			_fcfd.InsetpenAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Local == "href" {
			_bebf, _beea := _bfcad.Value, error(nil)
			if _beea != nil {
				return _beea
			}
			_fcfd.HrefAttr = &_bebf
			continue
		}
		if _bfcad.Name.Local == "id" {
			_dafg, _faac := _bfcad.Value, error(nil)
			if _faac != nil {
				return _faac
			}
			_fcfd.IdAttr = &_dafg
			continue
		}
		if _bfcad.Name.Local == "print" {
			_fcfd.PrintAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
		if _bfcad.Name.Local == "alt" {
			_aagd, _ccbc := _bfcad.Value, error(nil)
			if _ccbc != nil {
				return _ccbc
			}
			_fcfd.AltAttr = &_aagd
			continue
		}
		if _bfcad.Name.Local == "title" {
			_cgcc, _fdff := _bfcad.Value, error(nil)
			if _fdff != nil {
				return _fdff
			}
			_fcfd.TitleAttr = &_cgcc
			continue
		}
		if _bfcad.Name.Local == "class" {
			_fdbee, _faagb := _bfcad.Value, error(nil)
			if _faagb != nil {
				return _faagb
			}
			_fcfd.ClassAttr = &_fdbee
			continue
		}
		if _bfcad.Name.Local == "filled" {
			_fcfd.FilledAttr.UnmarshalXMLAttr(_bfcad)
			continue
		}
	}
_adaga:
	for {
		_abcff, _afdbe := d.Token()
		if _afdbe != nil {
			return _afdbe
		}
		switch _egccd := _abcff.(type) {
		case _b.StartElement:
			switch _egccd.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_cegb := NewEG_ShapeElements()
				_cegb.Path = NewPath()
				if _gcea := d.DecodeElement(_cegb.Path, &_egccd); _gcea != nil {
					return _gcea
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _cegb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_faddbd := NewEG_ShapeElements()
				_faddbd.Formulas = NewFormulas()
				if _gefcf := d.DecodeElement(_faddbd.Formulas, &_egccd); _gefcf != nil {
					return _gefcf
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _faddbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_fcdaf := NewEG_ShapeElements()
				_fcdaf.Handles = NewHandles()
				if _faef := d.DecodeElement(_fcdaf.Handles, &_egccd); _faef != nil {
					return _faef
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _fcdaf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_aefeg := NewEG_ShapeElements()
				_aefeg.Fill = NewFill()
				if _bbdb := d.DecodeElement(_aefeg.Fill, &_egccd); _bbdb != nil {
					return _bbdb
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _aefeg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_cdff := NewEG_ShapeElements()
				_cdff.Stroke = NewStroke()
				if _fefd := d.DecodeElement(_cdff.Stroke, &_egccd); _fefd != nil {
					return _fefd
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _cdff)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_agbbc := NewEG_ShapeElements()
				_agbbc.Shadow = NewShadow()
				if _abgga := d.DecodeElement(_agbbc.Shadow, &_egccd); _abgga != nil {
					return _abgga
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _agbbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_gbbg := NewEG_ShapeElements()
				_gbbg.Textbox = NewTextbox()
				if _ffae := d.DecodeElement(_gbbg.Textbox, &_egccd); _ffae != nil {
					return _ffae
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _gbbg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_bagcf := NewEG_ShapeElements()
				_bagcf.Textpath = NewTextpath()
				if _gcaae := d.DecodeElement(_bagcf.Textpath, &_egccd); _gcaae != nil {
					return _gcaae
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _bagcf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_efac := NewEG_ShapeElements()
				_efac.Imagedata = NewImagedata()
				if _dffde := d.DecodeElement(_efac.Imagedata, &_egccd); _dffde != nil {
					return _dffde
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _efac)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_bcba := NewEG_ShapeElements()
				_bcba.Skew = NewOfcSkew()
				if _fgbb := d.DecodeElement(_bcba.Skew, &_egccd); _fgbb != nil {
					return _fgbb
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _bcba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_feccf := NewEG_ShapeElements()
				_feccf.Extrusion = NewOfcExtrusion()
				if _cgegcd := d.DecodeElement(_feccf.Extrusion, &_egccd); _cgegcd != nil {
					return _cgegcd
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _feccf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_babc := NewEG_ShapeElements()
				_babc.Callout = NewOfcCallout()
				if _eabcc := d.DecodeElement(_babc.Callout, &_egccd); _eabcc != nil {
					return _eabcc
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _babc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_bded := NewEG_ShapeElements()
				_bded.Lock = NewOfcLock()
				if _aaec := d.DecodeElement(_bded.Lock, &_egccd); _aaec != nil {
					return _aaec
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _bded)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_faacg := NewEG_ShapeElements()
				_faacg.Clippath = NewOfcClippath()
				if _eaaa := d.DecodeElement(_faacg.Clippath, &_egccd); _eaaa != nil {
					return _eaaa
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _faacg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_dddbg := NewEG_ShapeElements()
				_dddbg.Signatureline = NewOfcSignatureline()
				if _cbcef := d.DecodeElement(_dddbg.Signatureline, &_egccd); _cbcef != nil {
					return _cbcef
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _dddbg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_aaac := NewEG_ShapeElements()
				_aaac.Wrap = _a.NewWrap()
				if _gddcf := d.DecodeElement(_aaac.Wrap, &_egccd); _gddcf != nil {
					return _gddcf
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _aaac)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_cabce := NewEG_ShapeElements()
				_cabce.Anchorlock = _a.NewAnchorlock()
				if _eeee := d.DecodeElement(_cabce.Anchorlock, &_egccd); _eeee != nil {
					return _eeee
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _cabce)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_bgfe := NewEG_ShapeElements()
				_bgfe.Bordertop = _a.NewBordertop()
				if _ecgffd := d.DecodeElement(_bgfe.Bordertop, &_egccd); _ecgffd != nil {
					return _ecgffd
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _bgfe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_accbc := NewEG_ShapeElements()
				_accbc.Borderbottom = _a.NewBorderbottom()
				if _dcfeb := d.DecodeElement(_accbc.Borderbottom, &_egccd); _dcfeb != nil {
					return _dcfeb
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _accbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_ggbf := NewEG_ShapeElements()
				_ggbf.Borderleft = _a.NewBorderleft()
				if _edff := d.DecodeElement(_ggbf.Borderleft, &_egccd); _edff != nil {
					return _edff
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _ggbf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_bdgea := NewEG_ShapeElements()
				_bdgea.Borderright = _a.NewBorderright()
				if _cccb := d.DecodeElement(_bdgea.Borderright, &_egccd); _cccb != nil {
					return _cccb
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _bdgea)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_ceff := NewEG_ShapeElements()
				_ceff.ClientData = _c.NewClientData()
				if _dgagg := d.DecodeElement(_ceff.ClientData, &_egccd); _dgagg != nil {
					return _dgagg
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _ceff)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_fbae := NewEG_ShapeElements()
				_fbae.Textdata = _bf.NewTextdata()
				if _gaeg := d.DecodeElement(_fbae.Textdata, &_egccd); _gaeg != nil {
					return _gaeg
				}
				_fcfd.EG_ShapeElements = append(_fcfd.EG_ShapeElements, _fbae)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Oval\u0020\u0025v", _egccd.Name)
				if _gcfb := d.Skip(); _gcfb != nil {
					return _gcfb
				}
			}
		case _b.EndElement:
			break _adaga
		case _b.CharData:
		}
	}
	return nil
}
func (_egacca *OfcCT_Extrusion) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _egacca.OnAttr != _eb.ST_TrueFalseUnset {
		_fefg, _bcbgg := _egacca.OnAttr.MarshalXMLAttr(_b.Name{Local: "on"})
		if _bcbgg != nil {
			return _bcbgg
		}
		start.Attr = append(start.Attr, _fefg)
	}
	if _egacca.TypeAttr != OfcST_ExtrusionTypeUnset {
		_dddgd, _bcfcf := _egacca.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _bcfcf != nil {
			return _bcfcf
		}
		start.Attr = append(start.Attr, _dddgd)
	}
	if _egacca.RenderAttr != OfcST_ExtrusionRenderUnset {
		_egdcc, _baade := _egacca.RenderAttr.MarshalXMLAttr(_b.Name{Local: "render"})
		if _baade != nil {
			return _baade
		}
		start.Attr = append(start.Attr, _egdcc)
	}
	if _egacca.ViewpointoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "viewpointorigin"}, Value: _f.Sprintf("\u0025v", *_egacca.ViewpointoriginAttr)})
	}
	if _egacca.ViewpointAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "viewpoint"}, Value: _f.Sprintf("\u0025v", *_egacca.ViewpointAttr)})
	}
	if _egacca.PlaneAttr != OfcST_ExtrusionPlaneUnset {
		_fdagg, _abcg := _egacca.PlaneAttr.MarshalXMLAttr(_b.Name{Local: "plane"})
		if _abcg != nil {
			return _abcg
		}
		start.Attr = append(start.Attr, _fdagg)
	}
	if _egacca.SkewangleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "skewangle"}, Value: _f.Sprintf("\u0025v", *_egacca.SkewangleAttr)})
	}
	if _egacca.SkewamtAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "skewamt"}, Value: _f.Sprintf("\u0025v", *_egacca.SkewamtAttr)})
	}
	if _egacca.ForedepthAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "foredepth"}, Value: _f.Sprintf("\u0025v", *_egacca.ForedepthAttr)})
	}
	if _egacca.BackdepthAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "backdepth"}, Value: _f.Sprintf("\u0025v", *_egacca.BackdepthAttr)})
	}
	if _egacca.OrientationAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "orientation"}, Value: _f.Sprintf("\u0025v", *_egacca.OrientationAttr)})
	}
	if _egacca.OrientationangleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "orientationangle"}, Value: _f.Sprintf("\u0025v", *_egacca.OrientationangleAttr)})
	}
	if _egacca.LockrotationcenterAttr != _eb.ST_TrueFalseUnset {
		_gabee, _gcdfc := _egacca.LockrotationcenterAttr.MarshalXMLAttr(_b.Name{Local: "lockrotationcenter"})
		if _gcdfc != nil {
			return _gcdfc
		}
		start.Attr = append(start.Attr, _gabee)
	}
	if _egacca.AutorotationcenterAttr != _eb.ST_TrueFalseUnset {
		_cdcad, _gefdf := _egacca.AutorotationcenterAttr.MarshalXMLAttr(_b.Name{Local: "autorotationcenter"})
		if _gefdf != nil {
			return _gefdf
		}
		start.Attr = append(start.Attr, _cdcad)
	}
	if _egacca.RotationcenterAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "rotationcenter"}, Value: _f.Sprintf("\u0025v", *_egacca.RotationcenterAttr)})
	}
	if _egacca.RotationangleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "rotationangle"}, Value: _f.Sprintf("\u0025v", *_egacca.RotationangleAttr)})
	}
	if _egacca.ColormodeAttr != OfcST_ColorModeUnset {
		_accefd, _gcffd := _egacca.ColormodeAttr.MarshalXMLAttr(_b.Name{Local: "colormode"})
		if _gcffd != nil {
			return _gcffd
		}
		start.Attr = append(start.Attr, _accefd)
	}
	if _egacca.ColorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "color"}, Value: _f.Sprintf("\u0025v", *_egacca.ColorAttr)})
	}
	if _egacca.ShininessAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "shininess"}, Value: _f.Sprintf("\u0025v", *_egacca.ShininessAttr)})
	}
	if _egacca.SpecularityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "specularity"}, Value: _f.Sprintf("\u0025v", *_egacca.SpecularityAttr)})
	}
	if _egacca.DiffusityAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "diffusity"}, Value: _f.Sprintf("\u0025v", *_egacca.DiffusityAttr)})
	}
	if _egacca.MetalAttr != _eb.ST_TrueFalseUnset {
		_efeag, _geeef := _egacca.MetalAttr.MarshalXMLAttr(_b.Name{Local: "metal"})
		if _geeef != nil {
			return _geeef
		}
		start.Attr = append(start.Attr, _efeag)
	}
	if _egacca.EdgeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "edge"}, Value: _f.Sprintf("\u0025v", *_egacca.EdgeAttr)})
	}
	if _egacca.FacetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "facet"}, Value: _f.Sprintf("\u0025v", *_egacca.FacetAttr)})
	}
	if _egacca.LightfaceAttr != _eb.ST_TrueFalseUnset {
		_faeca, _feda := _egacca.LightfaceAttr.MarshalXMLAttr(_b.Name{Local: "lightface"})
		if _feda != nil {
			return _feda
		}
		start.Attr = append(start.Attr, _faeca)
	}
	if _egacca.BrightnessAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "brightness"}, Value: _f.Sprintf("\u0025v", *_egacca.BrightnessAttr)})
	}
	if _egacca.LightpositionAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "lightposition"}, Value: _f.Sprintf("\u0025v", *_egacca.LightpositionAttr)})
	}
	if _egacca.LightlevelAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "lightlevel"}, Value: _f.Sprintf("\u0025v", *_egacca.LightlevelAttr)})
	}
	if _egacca.LightharshAttr != _eb.ST_TrueFalseUnset {
		_ddgdfd, _dcgg := _egacca.LightharshAttr.MarshalXMLAttr(_b.Name{Local: "lightharsh"})
		if _dcgg != nil {
			return _dcgg
		}
		start.Attr = append(start.Attr, _ddgdfd)
	}
	if _egacca.Lightposition2Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "lightposition2"}, Value: _f.Sprintf("\u0025v", *_egacca.Lightposition2Attr)})
	}
	if _egacca.Lightlevel2Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "lightlevel2"}, Value: _f.Sprintf("\u0025v", *_egacca.Lightlevel2Attr)})
	}
	if _egacca.Lightharsh2Attr != _eb.ST_TrueFalseUnset {
		_edfeb, _fafca := _egacca.Lightharsh2Attr.MarshalXMLAttr(_b.Name{Local: "lightharsh2"})
		if _fafca != nil {
			return _fafca
		}
		start.Attr = append(start.Attr, _edfeb)
	}
	if _egacca.ExtAttr != ST_ExtUnset {
		_adcfe, _aefbcg := _egacca.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _aefbcg != nil {
			return _aefbcg
		}
		start.Attr = append(start.Attr, _adcfe)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

const (
	OfcST_BWModeUnset             OfcST_BWMode = 0
	OfcST_BWModeColor             OfcST_BWMode = 1
	OfcST_BWModeAuto              OfcST_BWMode = 2
	OfcST_BWModeGrayScale         OfcST_BWMode = 3
	OfcST_BWModeLightGrayscale    OfcST_BWMode = 4
	OfcST_BWModeInverseGray       OfcST_BWMode = 5
	OfcST_BWModeGrayOutline       OfcST_BWMode = 6
	OfcST_BWModeHighContrast      OfcST_BWMode = 7
	OfcST_BWModeBlack             OfcST_BWMode = 8
	OfcST_BWModeWhite             OfcST_BWMode = 9
	OfcST_BWModeHide              OfcST_BWMode = 10
	OfcST_BWModeUndrawn           OfcST_BWMode = 11
	OfcST_BWModeBlackTextAndLines OfcST_BWMode = 12
)

func (_dgebg OfcST_OLEType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_ebfb := _b.Attr{}
	_ebfb.Name = name
	switch _dgebg {
	case OfcST_OLETypeUnset:
		_ebfb.Value = ""
	case OfcST_OLETypeEmbed:
		_ebfb.Value = "Embed"
	case OfcST_OLETypeLink:
		_ebfb.Value = "Link"
	}
	return _ebfb, nil
}
func (_edebd *Handles) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _edebd.CT_Handles.MarshalXML(e, start)
}

// ValidateWithPath validates the Rect and its children, prefixing error messages with path
func (_dgdgg *Rect) ValidateWithPath(path string) error {
	if _ddace := _dgdgg.CT_Rect.ValidateWithPath(path); _ddace != nil {
		return _ddace
	}
	return nil
}

type AG_ImageAttributes struct {
	SrcAttr        *string
	CropleftAttr   *string
	CroptopAttr    *string
	CroprightAttr  *string
	CropbottomAttr *string
	GainAttr       *string
	BlacklevelAttr *string
	GammaAttr      *string
	GrayscaleAttr  _eb.ST_TrueFalse
	BilevelAttr    _eb.ST_TrueFalse
}
type Handles struct{ CT_Handles }

func (_fbege *OfcCT_ShapeLayout) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _fbege.ExtAttr != ST_ExtUnset {
		_decgb, _fbcbc := _fbege.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _fbcbc != nil {
			return _fbcbc
		}
		start.Attr = append(start.Attr, _decgb)
	}
	e.EncodeToken(start)
	if _fbege.Idmap != nil {
		_fffcg := _b.StartElement{Name: _b.Name{Local: "o:idmap"}}
		e.EncodeElement(_fbege.Idmap, _fffcg)
	}
	if _fbege.Regrouptable != nil {
		_fabae := _b.StartElement{Name: _b.Name{Local: "o:regrouptable"}}
		e.EncodeElement(_fbege.Regrouptable, _fabae)
	}
	if _fbege.Rules != nil {
		_dagc := _b.StartElement{Name: _b.Name{Local: "o:rules"}}
		e.EncodeElement(_fbege.Rules, _dagc)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewOfcSkew() *OfcSkew { _becce := &OfcSkew{}; _becce.OfcCT_Skew = *NewOfcCT_Skew(); return _becce }
func (_fdadd *Stroke) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _fdadd.CT_Stroke.MarshalXML(e, start)
}
func NewHandles() *Handles { _debcc := &Handles{}; _debcc.CT_Handles = *NewCT_Handles(); return _debcc }
func (_ebeec OfcST_Angle) String() string {
	switch _ebeec {
	case 0:
		return ""
	case 1:
		return "any"
	case 2:
		return "30"
	case 3:
		return "45"
	case 4:
		return "60"
	case 5:
		return "90"
	case 6:
		return "auto"
	}
	return ""
}
func (_decce *Path) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_decce.CT_Path = *NewCT_Path()
	for _, _ggac := range start.Attr {
		if _ggac.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggac.Name.Local == "connecttype" {
			_decce.ConnecttypeAttr.UnmarshalXMLAttr(_ggac)
			continue
		}
		if _ggac.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggac.Name.Local == "extrusionok" {
			_decce.ExtrusionokAttr.UnmarshalXMLAttr(_ggac)
			continue
		}
		if _ggac.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggac.Name.Local == "connectangles" {
			_fccab, _efbfc := _ggac.Value, error(nil)
			if _efbfc != nil {
				return _efbfc
			}
			_decce.ConnectanglesAttr = &_fccab
			continue
		}
		if _ggac.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggac.Name.Local == "connectlocs" {
			_egdccf, _gede := _ggac.Value, error(nil)
			if _gede != nil {
				return _gede
			}
			_decce.ConnectlocsAttr = &_egdccf
			continue
		}
		if _ggac.Name.Local == "gradientshapeok" {
			_decce.GradientshapeokAttr.UnmarshalXMLAttr(_ggac)
			continue
		}
		if _ggac.Name.Local == "shadowok" {
			_decce.ShadowokAttr.UnmarshalXMLAttr(_ggac)
			continue
		}
		if _ggac.Name.Local == "arrowok" {
			_decce.ArrowokAttr.UnmarshalXMLAttr(_ggac)
			continue
		}
		if _ggac.Name.Local == "v" {
			_afecc, _cfebg := _ggac.Value, error(nil)
			if _cfebg != nil {
				return _cfebg
			}
			_decce.VAttr = &_afecc
			continue
		}
		if _ggac.Name.Local == "textpathok" {
			_decce.TextpathokAttr.UnmarshalXMLAttr(_ggac)
			continue
		}
		if _ggac.Name.Local == "insetpenok" {
			_decce.InsetpenokAttr.UnmarshalXMLAttr(_ggac)
			continue
		}
		if _ggac.Name.Local == "strokeok" {
			_decce.StrokeokAttr.UnmarshalXMLAttr(_ggac)
			continue
		}
		if _ggac.Name.Local == "fillok" {
			_decce.FillokAttr.UnmarshalXMLAttr(_ggac)
			continue
		}
		if _ggac.Name.Local == "textboxrect" {
			_acdag, _bffa := _ggac.Value, error(nil)
			if _bffa != nil {
				return _bffa
			}
			_decce.TextboxrectAttr = &_acdag
			continue
		}
		if _ggac.Name.Local == "limo" {
			_cdfea, _cffab := _ggac.Value, error(nil)
			if _cffab != nil {
				return _cffab
			}
			_decce.LimoAttr = &_cdfea
			continue
		}
		if _ggac.Name.Local == "id" {
			_gffe, _aecf := _ggac.Value, error(nil)
			if _aecf != nil {
				return _aecf
			}
			_decce.IdAttr = &_gffe
			continue
		}
	}
	for {
		_dgdbd, _gegaf := d.Token()
		if _gegaf != nil {
			return _f.Errorf("parsing\u0020Path:\u0020\u0025s", _gegaf)
		}
		if _eaba, _bdfaa := _dgdbd.(_b.EndElement); _bdfaa && _eaba.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cfbae OfcST_ConnectType) ValidateWithPath(path string) error {
	switch _cfbae {
	case 0, 1, 2, 3, 4:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cfbae))
	}
	return nil
}
func (_bfbbe *Imagedata) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _bfbbe.CT_ImageData.MarshalXML(e, start)
}
func (_cegbgc ST_StrokeEndCap) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_cegbgc.String(), start)
}

const (
	OfcST_ExtrusionTypeUnset       OfcST_ExtrusionType = 0
	OfcST_ExtrusionTypePerspective OfcST_ExtrusionType = 1
	OfcST_ExtrusionTypeParallel    OfcST_ExtrusionType = 2
)

func (_edggf OfcST_OLEType) String() string {
	switch _edggf {
	case 0:
		return ""
	case 1:
		return "Embed"
	case 2:
		return "Link"
	}
	return ""
}
func (_efggfd *ST_ImageAspect) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_efggfd = 0
	case "ignore":
		*_efggfd = 1
	case "atMost":
		*_efggfd = 2
	case "atLeast":
		*_efggfd = 3
	}
	return nil
}
func (_fgeb *Fill) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fgeb.CT_Fill = *NewCT_Fill()
	for _, _dcga := range start.Attr {
		if _dcga.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dcga.Name.Local == "detectmouseclick" {
			_fgeb.DetectmouseclickAttr.UnmarshalXMLAttr(_dcga)
			continue
		}
		if _dcga.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dcga.Name.Local == "relid" {
			_aeaca, _gfagb := _dcga.Value, error(nil)
			if _gfagb != nil {
				return _gfagb
			}
			_fgeb.RelidAttr = &_aeaca
			continue
		}
		if _dcga.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _dcga.Name.Local == "id" || _dcga.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _dcga.Name.Local == "id" {
			_dgfbd, _fgbfc := _dcga.Value, error(nil)
			if _fgbfc != nil {
				return _fgbfc
			}
			_fgeb.IdAttr = &_dgfbd
			continue
		}
		if _dcga.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dcga.Name.Local == "opacity2" {
			_gabcg, _acef := _dcga.Value, error(nil)
			if _acef != nil {
				return _acef
			}
			_fgeb.Opacity2Attr = &_gabcg
			continue
		}
		if _dcga.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dcga.Name.Local == "title" {
			_bcdf, _ggcge := _dcga.Value, error(nil)
			if _ggcge != nil {
				return _ggcge
			}
			_fgeb.TitleAttr = &_bcdf
			continue
		}
		if _dcga.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dcga.Name.Local == "href" {
			_gbgabb, _acbea := _dcga.Value, error(nil)
			if _acbea != nil {
				return _acbea
			}
			_fgeb.HrefAttr = &_gbgabb
			continue
		}
		if _dcga.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dcga.Name.Local == "althref" {
			_ecbaf, _bfaag := _dcga.Value, error(nil)
			if _bfaag != nil {
				return _bfaag
			}
			_fgeb.AlthrefAttr = &_ecbaf
			continue
		}
		if _dcga.Name.Local == "alignshape" {
			_fgeb.AlignshapeAttr.UnmarshalXMLAttr(_dcga)
			continue
		}
		if _dcga.Name.Local == "method" {
			_fgeb.MethodAttr.UnmarshalXMLAttr(_dcga)
			continue
		}
		if _dcga.Name.Local == "size" {
			_gbdfg, _dbdcg := _dcga.Value, error(nil)
			if _dbdcg != nil {
				return _dbdcg
			}
			_fgeb.SizeAttr = &_gbdfg
			continue
		}
		if _dcga.Name.Local == "position" {
			_gbbeb, _dafb := _dcga.Value, error(nil)
			if _dafb != nil {
				return _dafb
			}
			_fgeb.PositionAttr = &_gbbeb
			continue
		}
		if _dcga.Name.Local == "src" {
			_fdcbgf, _ggba := _dcga.Value, error(nil)
			if _ggba != nil {
				return _ggba
			}
			_fgeb.SrcAttr = &_fdcbgf
			continue
		}
		if _dcga.Name.Local == "colors" {
			_fcab, _ebdbd := _dcga.Value, error(nil)
			if _ebdbd != nil {
				return _ebdbd
			}
			_fgeb.ColorsAttr = &_fcab
			continue
		}
		if _dcga.Name.Local == "color2" {
			_deaad, _cdgee := _dcga.Value, error(nil)
			if _cdgee != nil {
				return _cdgee
			}
			_fgeb.Color2Attr = &_deaad
			continue
		}
		if _dcga.Name.Local == "type" {
			_fgeb.TypeAttr.UnmarshalXMLAttr(_dcga)
			continue
		}
		if _dcga.Name.Local == "focussize" {
			_cbdgdf, _bbabe := _dcga.Value, error(nil)
			if _bbabe != nil {
				return _bbabe
			}
			_fgeb.FocussizeAttr = &_cbdgdf
			continue
		}
		if _dcga.Name.Local == "focusposition" {
			_aafg, _gdcbe := _dcga.Value, error(nil)
			if _gdcbe != nil {
				return _gdcbe
			}
			_fgeb.FocuspositionAttr = &_aafg
			continue
		}
		if _dcga.Name.Local == "origin" {
			_febfg, _edagd := _dcga.Value, error(nil)
			if _edagd != nil {
				return _edagd
			}
			_fgeb.OriginAttr = &_febfg
			continue
		}
		if _dcga.Name.Local == "aspect" {
			_fgeb.AspectAttr.UnmarshalXMLAttr(_dcga)
			continue
		}
		if _dcga.Name.Local == "angle" {
			_bdbdg, _bafea := _e.ParseFloat(_dcga.Value, 64)
			if _bafea != nil {
				return _bafea
			}
			_fgeb.AngleAttr = &_bdbdg
			continue
		}
		if _dcga.Name.Local == "focus" {
			_dfedb, _bcgfe := _dcga.Value, error(nil)
			if _bcgfe != nil {
				return _bcgfe
			}
			_fgeb.FocusAttr = &_dfedb
			continue
		}
		if _dcga.Name.Local == "recolor" {
			_fgeb.RecolorAttr.UnmarshalXMLAttr(_dcga)
			continue
		}
		if _dcga.Name.Local == "rotate" {
			_fgeb.RotateAttr.UnmarshalXMLAttr(_dcga)
			continue
		}
		if _dcga.Name.Local == "opacity" {
			_faga, _cdcf := _dcga.Value, error(nil)
			if _cdcf != nil {
				return _cdcf
			}
			_fgeb.OpacityAttr = &_faga
			continue
		}
		if _dcga.Name.Local == "color" {
			_edcae, _adffbg := _dcga.Value, error(nil)
			if _adffbg != nil {
				return _adffbg
			}
			_fgeb.ColorAttr = &_edcae
			continue
		}
		if _dcga.Name.Local == "on" {
			_fgeb.OnAttr.UnmarshalXMLAttr(_dcga)
			continue
		}
		if _dcga.Name.Local == "id" {
			_bfdaa, _gegfe := _dcga.Value, error(nil)
			if _gegfe != nil {
				return _gegfe
			}
			_fgeb.SIdAttr = &_bfdaa
			continue
		}
	}
_ecbae:
	for {
		_edfdc, _egcce := d.Token()
		if _egcce != nil {
			return _egcce
		}
		switch _decgc := _edfdc.(type) {
		case _b.StartElement:
			switch _decgc.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "fill"}:
				_fgeb.Fill = NewOfcFill()
				if _geac := d.DecodeElement(_fgeb.Fill, &_decgc); _geac != nil {
					return _geac
				}
			default:
				_ba.Log("skipping\u0020unsupported element\u0020on\u0020Fill\u0020\u0025v", _decgc.Name)
				if _bdbfa := d.Skip(); _bdbfa != nil {
					return _bdbfa
				}
			}
		case _b.EndElement:
			break _ecbae
		case _b.CharData:
		}
	}
	return nil
}
func (_fbdfa *OfcCT_SignatureLine) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _eceea := range start.Attr {
		if _eceea.Name.Local == "suggestedsigner" {
			_gfgee, _dgeg := _eceea.Value, error(nil)
			if _dgeg != nil {
				return _dgeg
			}
			_fbdfa.SuggestedsignerAttr = &_gfgee
			continue
		}
		if _eceea.Name.Local == "id" {
			_ebgacc, _aeaeea := _eceea.Value, error(nil)
			if _aeaeea != nil {
				return _aeaeea
			}
			_fbdfa.IdAttr = &_ebgacc
			continue
		}
		if _eceea.Name.Local == "provid" {
			_fdage, _dcaf := _eceea.Value, error(nil)
			if _dcaf != nil {
				return _dcaf
			}
			_fbdfa.ProvidAttr = &_fdage
			continue
		}
		if _eceea.Name.Local == "signinginstructionsset" {
			_fbdfa.SigninginstructionssetAttr.UnmarshalXMLAttr(_eceea)
			continue
		}
		if _eceea.Name.Local == "allowcomments" {
			_fbdfa.AllowcommentsAttr.UnmarshalXMLAttr(_eceea)
			continue
		}
		if _eceea.Name.Local == "showsigndate" {
			_fbdfa.ShowsigndateAttr.UnmarshalXMLAttr(_eceea)
			continue
		}
		if _eceea.Name.Local == "issignatureline" {
			_fbdfa.IssignaturelineAttr.UnmarshalXMLAttr(_eceea)
			continue
		}
		if _eceea.Name.Local == "suggestedsigner2" {
			_fbeced, _dfefd := _eceea.Value, error(nil)
			if _dfefd != nil {
				return _dfefd
			}
			_fbdfa.Suggestedsigner2Attr = &_fbeced
			continue
		}
		if _eceea.Name.Local == "suggestedsigneremail" {
			_cdcega, _eddfd := _eceea.Value, error(nil)
			if _eddfd != nil {
				return _eddfd
			}
			_fbdfa.SuggestedsigneremailAttr = &_cdcega
			continue
		}
		if _eceea.Name.Local == "signinginstructions" {
			_begfd, _eaegg := _eceea.Value, error(nil)
			if _eaegg != nil {
				return _eaegg
			}
			_fbdfa.SigninginstructionsAttr = &_begfd
			continue
		}
		if _eceea.Name.Local == "addlxml" {
			_fgaafg, _gaege := _eceea.Value, error(nil)
			if _gaege != nil {
				return _gaege
			}
			_fbdfa.AddlxmlAttr = &_fgaafg
			continue
		}
		if _eceea.Name.Local == "sigprovurl" {
			_adfd, _baegc := _eceea.Value, error(nil)
			if _baegc != nil {
				return _baegc
			}
			_fbdfa.SigprovurlAttr = &_adfd
			continue
		}
		if _eceea.Name.Local == "ext" {
			_fbdfa.ExtAttr.UnmarshalXMLAttr(_eceea)
			continue
		}
	}
	for {
		_fgbcfa, _dace := d.Token()
		if _dace != nil {
			return _f.Errorf("parsing\u0020OfcCT_SignatureLine:\u0020\u0025s", _dace)
		}
		if _eecfe, _cedde := _fgbcfa.(_b.EndElement); _cedde && _eecfe.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bdebb OfcST_InsetMode) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_bdebb.String(), start)
}

type AG_Id struct{ IdAttr *string }

// ValidateWithPath validates the AG_CoreAttributes and its children, prefixing error messages with path
func (_cfdf *AG_CoreAttributes) ValidateWithPath(path string) error {
	if _bgg := _cfdf.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _bgg != nil {
		return _bgg
	}
	return nil
}

// Validate validates the Group and its children
func (_acffa *Group) Validate() error { return _acffa.ValidateWithPath("Group") }
func (_ffaab *Textbox) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ffaab.CT_Textbox = *NewCT_Textbox()
	for _, _ggcaf := range start.Attr {
		if _ggcaf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggcaf.Name.Local == "singleclick" {
			_ffaab.SingleclickAttr.UnmarshalXMLAttr(_ggcaf)
			continue
		}
		if _ggcaf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ggcaf.Name.Local == "insetmode" {
			_ffaab.InsetmodeAttr.UnmarshalXMLAttr(_ggcaf)
			continue
		}
		if _ggcaf.Name.Local == "inset" {
			_eaca, _fbaefb := _ggcaf.Value, error(nil)
			if _fbaefb != nil {
				return _fbaefb
			}
			_ffaab.InsetAttr = &_eaca
			continue
		}
		if _ggcaf.Name.Local == "id" {
			_fcedd, _gaggb := _ggcaf.Value, error(nil)
			if _gaggb != nil {
				return _gaggb
			}
			_ffaab.IdAttr = &_fcedd
			continue
		}
		if _ggcaf.Name.Local == "style" {
			_bddgb, _ggebad := _ggcaf.Value, error(nil)
			if _ggebad != nil {
				return _ggebad
			}
			_ffaab.StyleAttr = &_bddgb
			continue
		}
	}
_ceegc:
	for {
		_cdbgd, _gaffa := d.Token()
		if _gaffa != nil {
			return _gaffa
		}
		switch _ffdfd := _cdbgd.(type) {
		case _b.StartElement:
			switch _ffdfd.Name {
			case _b.Name{Space: "http:\u002f\u002fschemas.openxmlformats\u002eorg\u002fwordprocessingml\u002f2006\u002fmain", Local: "txbxContent"}, _b.Name{Space: "http:\u002f\u002fpurl\u002eoclc\u002eorg/ooxml\u002fwordprocessingml\u002fmain", Local: "txbxContent"}:
				_ffaab.TxbxContent = _ebg.NewTxbxContent()
				if _adbge := d.DecodeElement(_ffaab.TxbxContent, &_ffdfd); _adbge != nil {
					return _adbge
				}
			default:
				if _cadgde, _gfagd := _ba.CreateElement(_ffdfd); _gfagd != nil {
					return _gfagd
				} else {
					if _dacgc := d.DecodeElement(_cadgde, &_ffdfd); _dacgc != nil {
						return _dacgc
					}
					_ffaab.Any = _cadgde
				}
			}
		case _b.EndElement:
			break _ceegc
		case _b.CharData:
		}
	}
	return nil
}

type OfcShapedefaults struct{ OfcCT_ShapeDefaults }

// Validate validates the OfcClippath and its children
func (_gefffdf *OfcClippath) Validate() error { return _gefffdf.ValidateWithPath("OfcClippath") }
func NewCT_Shapetype() *CT_Shapetype          { _eeece := &CT_Shapetype{}; return _eeece }
func (_cddda *OfcDiagram) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:diagram"
	return _cddda.OfcCT_Diagram.MarshalXML(e, start)
}
func (_egbgd *ST_StrokeEndCap) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_egbgd = 0
	case "flat":
		*_egbgd = 1
	case "square":
		*_egbgd = 2
	case "round":
		*_egbgd = 3
	}
	return nil
}

// ValidateWithPath validates the CT_Oval and its children, prefixing error messages with path
func (_feegb *CT_Oval) ValidateWithPath(path string) error {
	for _eeed, _aacd := range _feegb.EG_ShapeElements {
		if _cdfe := _aacd.ValidateWithPath(_f.Sprintf("\u0025s\u002fEG_ShapeElements\u005b\u0025d\u005d", path, _eeed)); _cdfe != nil {
			return _cdfe
		}
	}
	if _gggfb := _feegb.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _gggfb != nil {
		return _gggfb
	}
	if _gddf := _feegb.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _gddf != nil {
		return _gddf
	}
	if _gbebe := _feegb.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _gbebe != nil {
		return _gbebe
	}
	if _dabgc := _feegb.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _dabgc != nil {
		return _dabgc
	}
	if _fdbb := _feegb.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _fdbb != nil {
		return _fdbb
	}
	if _edfef := _feegb.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _edfef != nil {
		return _edfef
	}
	if _aeae := _feegb.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _aeae != nil {
		return _aeae
	}
	if _cadd := _feegb.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _cadd != nil {
		return _cadd
	}
	if _dedg := _feegb.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _dedg != nil {
		return _dedg
	}
	if _ecgge := _feegb.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _ecgge != nil {
		return _ecgge
	}
	if _eabfc := _feegb.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _eabfc != nil {
		return _eabfc
	}
	if _caddc := _feegb.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _caddc != nil {
		return _caddc
	}
	if _bgcf := _feegb.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _bgcf != nil {
		return _bgcf
	}
	if _ebdbg := _feegb.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _ebdbg != nil {
		return _ebdbg
	}
	if _fdfca := _feegb.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _fdfca != nil {
		return _fdfca
	}
	if _cdae := _feegb.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _cdae != nil {
		return _cdae
	}
	if _bcec := _feegb.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _bcec != nil {
		return _bcec
	}
	if _gagdg := _feegb.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _gagdg != nil {
		return _gagdg
	}
	if _dfedc := _feegb.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _dfedc != nil {
		return _dfedc
	}
	if _edcb := _feegb.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _edcb != nil {
		return _edcb
	}
	if _bfacc := _feegb.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _bfacc != nil {
		return _bfacc
	}
	if _bdbeb := _feegb.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _bdbeb != nil {
		return _bdbeb
	}
	if _ddba := _feegb.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _ddba != nil {
		return _ddba
	}
	if _dbcef := _feegb.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _dbcef != nil {
		return _dbcef
	}
	if _cggfb := _feegb.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _cggfb != nil {
		return _cggfb
	}
	if _efddd := _feegb.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _efddd != nil {
		return _efddd
	}
	if _dfge := _feegb.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _dfge != nil {
		return _dfge
	}
	if _bdda := _feegb.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _bdda != nil {
		return _bdda
	}
	if _bcgd := _feegb.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _bcgd != nil {
		return _bcgd
	}
	return nil
}
func (_ebaad *OfcLock) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ebaad.OfcCT_Lock = *NewOfcCT_Lock()
	for _, _ggdce := range start.Attr {
		if _ggdce.Name.Local == "position" {
			_ebaad.PositionAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
		if _ggdce.Name.Local == "selection" {
			_ebaad.SelectionAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
		if _ggdce.Name.Local == "grouping" {
			_ebaad.GroupingAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
		if _ggdce.Name.Local == "ungrouping" {
			_ebaad.UngroupingAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
		if _ggdce.Name.Local == "rotation" {
			_ebaad.RotationAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
		if _ggdce.Name.Local == "cropping" {
			_ebaad.CroppingAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
		if _ggdce.Name.Local == "verticies" {
			_ebaad.VerticiesAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
		if _ggdce.Name.Local == "adjusthandles" {
			_ebaad.AdjusthandlesAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
		if _ggdce.Name.Local == "text" {
			_ebaad.TextAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
		if _ggdce.Name.Local == "aspectratio" {
			_ebaad.AspectratioAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
		if _ggdce.Name.Local == "shapetype" {
			_ebaad.ShapetypeAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
		if _ggdce.Name.Local == "ext" {
			_ebaad.ExtAttr.UnmarshalXMLAttr(_ggdce)
			continue
		}
	}
	for {
		_ebde, _eeeed := d.Token()
		if _eeeed != nil {
			return _f.Errorf("parsing\u0020OfcLock:\u0020\u0025s", _eeeed)
		}
		if _dcegb, _gbdfd := _ebde.(_b.EndElement); _gbdfd && _dcegb.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the OfcCT_ColorMenu and its children
func (_dcfgb *OfcCT_ColorMenu) Validate() error { return _dcfgb.ValidateWithPath("OfcCT_ColorMenu") }
func (_daccee ST_ShadowType) String() string {
	switch _daccee {
	case 0:
		return ""
	case 1:
		return "single"
	case 2:
		return "double"
	case 3:
		return "emboss"
	case 4:
		return "perspective"
	}
	return ""
}

const (
	OfcST_HowUnset  OfcST_How = 0
	OfcST_HowTop    OfcST_How = 1
	OfcST_HowMiddle OfcST_How = 2
	OfcST_HowBottom OfcST_How = 3
	OfcST_HowLeft   OfcST_How = 4
	OfcST_HowCenter OfcST_How = 5
	OfcST_HowRight  OfcST_How = 6
)

func NewOfcCT_Fill() *OfcCT_Fill { _agbaa := &OfcCT_Fill{}; return _agbaa }

type CT_Textbox struct {
	InsetAttr       *string
	SingleclickAttr _eb.ST_TrueFalse
	InsetmodeAttr   OfcST_InsetMode
	TxbxContent     *_ebg.TxbxContent
	Any             _ba.Any
	IdAttr          *string
	StyleAttr       *string
}

// Validate validates the Shapetype and its children
func (_fedgb *Shapetype) Validate() error { return _fedgb.ValidateWithPath("Shapetype") }
func (_ada *CT_Background) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _cgge := range start.Attr {
		if _cgge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cgge.Name.Local == "bwmode" {
			_ada.BwmodeAttr.UnmarshalXMLAttr(_cgge)
			continue
		}
		if _cgge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cgge.Name.Local == "bwpure" {
			_ada.BwpureAttr.UnmarshalXMLAttr(_cgge)
			continue
		}
		if _cgge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cgge.Name.Local == "bwnormal" {
			_ada.BwnormalAttr.UnmarshalXMLAttr(_cgge)
			continue
		}
		if _cgge.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cgge.Name.Local == "targetscreensize" {
			_ada.TargetscreensizeAttr.UnmarshalXMLAttr(_cgge)
			continue
		}
		if _cgge.Name.Local == "id" {
			_fbgc, _fdac := _cgge.Value, error(nil)
			if _fdac != nil {
				return _fdac
			}
			_ada.IdAttr = &_fbgc
			continue
		}
		if _cgge.Name.Local == "filled" {
			_ada.FilledAttr.UnmarshalXMLAttr(_cgge)
			continue
		}
		if _cgge.Name.Local == "fillcolor" {
			_cada, _gfed := _cgge.Value, error(nil)
			if _gfed != nil {
				return _gfed
			}
			_ada.FillcolorAttr = &_cada
			continue
		}
	}
_ageg:
	for {
		_cgfe, _ggeb := d.Token()
		if _ggeb != nil {
			return _ggeb
		}
		switch _aggg := _cgfe.(type) {
		case _b.StartElement:
			switch _aggg.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_ada.Fill = NewFill()
				if _gdbee := d.DecodeElement(_ada.Fill, &_aggg); _gdbee != nil {
					return _gdbee
				}
			default:
				_ba.Log("skipping unsupported element\u0020on\u0020CT_Background \u0025v", _aggg.Name)
				if _adgb := d.Skip(); _adgb != nil {
					return _adgb
				}
			}
		case _b.EndElement:
			break _ageg
		case _b.CharData:
		}
	}
	return nil
}
func (_bdcfg ST_FillMethod) Validate() error { return _bdcfg.ValidateWithPath("") }
func (_dfeg *OfcCT_Relation) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _dfeg.IdsrcAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "idsrc"}, Value: _f.Sprintf("\u0025v", *_dfeg.IdsrcAttr)})
	}
	if _dfeg.IddestAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "iddest"}, Value: _f.Sprintf("\u0025v", *_dfeg.IddestAttr)})
	}
	if _dfeg.IdcntrAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "idcntr"}, Value: _f.Sprintf("\u0025v", *_dfeg.IdcntrAttr)})
	}
	if _dfeg.ExtAttr != ST_ExtUnset {
		_gdceb, _bbfc := _dfeg.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _bbfc != nil {
			return _bbfc
		}
		start.Attr = append(start.Attr, _gdceb)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func init() {
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Shape", NewCT_Shape)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Shapetype", NewCT_Shapetype)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Group", NewCT_Group)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Background", NewCT_Background)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Fill", NewCT_Fill)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Formulas", NewCT_Formulas)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_F", NewCT_F)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Handles", NewCT_Handles)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_H", NewCT_H)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_ImageData", NewCT_ImageData)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Path", NewCT_Path)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Shadow", NewCT_Shadow)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Stroke", NewCT_Stroke)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Textbox", NewCT_Textbox)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_TextPath", NewCT_TextPath)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Arc", NewCT_Arc)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Curve", NewCT_Curve)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Image", NewCT_Image)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Line", NewCT_Line)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Oval", NewCT_Oval)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_PolyLine", NewCT_PolyLine)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_Rect", NewCT_Rect)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "CT_RoundRect", NewCT_RoundRect)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "shape", NewShape)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "shapetype", NewShapetype)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "group", NewGroup)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "background", NewBackground)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "fill", NewFill)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "formulas", NewFormulas)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "handles", NewHandles)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "imagedata", NewImagedata)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "path", NewPath)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "textbox", NewTextbox)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "shadow", NewShadow)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "stroke", NewStroke)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "textpath", NewTextpath)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "arc", NewArc)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "curve", NewCurve)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "image", NewImage)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "line", NewLine)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "oval", NewOval)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "polyline", NewPolyline)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "rect", NewRect)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "roundrect", NewRoundrect)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "EG_ShapeElements", NewEG_ShapeElements)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_Id", NewAG_Id)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_Style", NewAG_Style)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_Type", NewAG_Type)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_Adj", NewAG_Adj)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_Path", NewAG_Path)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_Fill", NewAG_Fill)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_Chromakey", NewAG_Chromakey)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_Ext", NewAG_Ext)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_CoreAttributes", NewAG_CoreAttributes)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_ShapeAttributes", NewAG_ShapeAttributes)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_OfficeCoreAttributes", NewAG_OfficeCoreAttributes)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_OfficeShapeAttributes", NewAG_OfficeShapeAttributes)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_AllCoreAttributes", NewAG_AllCoreAttributes)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_AllShapeAttributes", NewAG_AllShapeAttributes)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_ImageAttributes", NewAG_ImageAttributes)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:vml", "AG_StrokeAttributes", NewAG_StrokeAttributes)
}
func (_ecfg *AG_Path) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ecfg.PathAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "path"}, Value: _f.Sprintf("\u0025v", *_ecfg.PathAttr)})
	}
	return nil
}
func (_eecbc ST_StrokeJoinStyle) ValidateWithPath(path string) error {
	switch _eecbc {
	case 0, 1, 2, 3:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_eecbc))
	}
	return nil
}

// ValidateWithPath validates the CT_Shape and its children, prefixing error messages with path
func (_bfgef *CT_Shape) ValidateWithPath(path string) error {
	for _gccfg, _gbcae := range _bfgef.Ink {
		if _daefb := _gbcae.ValidateWithPath(_f.Sprintf("\u0025s\u002fInk\u005b\u0025d\u005d", path, _gccfg)); _daefb != nil {
			return _daefb
		}
	}
	for _cceed, _bfaeg := range _bfgef.Iscomment {
		if _ebbae := _bfaeg.ValidateWithPath(_f.Sprintf("\u0025s/Iscomment\u005b\u0025d\u005d", path, _cceed)); _ebbae != nil {
			return _ebbae
		}
	}
	for _fecd, _ccbe := range _bfgef.Equationxml {
		if _aeaeb := _ccbe.ValidateWithPath(_f.Sprintf("\u0025s\u002fEquationxml\u005b\u0025d\u005d", path, _fecd)); _aeaeb != nil {
			return _aeaeb
		}
	}
	for _abgaa, _cacff := range _bfgef.EG_ShapeElements {
		if _gbfa := _cacff.ValidateWithPath(_f.Sprintf("\u0025s\u002fEG_ShapeElements\u005b\u0025d\u005d", path, _abgaa)); _gbfa != nil {
			return _gbfa
		}
	}
	if _gcff := _bfgef.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _gcff != nil {
		return _gcff
	}
	if _cbdgd := _bfgef.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _cbdgd != nil {
		return _cbdgd
	}
	if _ccfe := _bfgef.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _ccfe != nil {
		return _ccfe
	}
	if _bgdc := _bfgef.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _bgdc != nil {
		return _bgdc
	}
	if _egcdc := _bfgef.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _egcdc != nil {
		return _egcdc
	}
	if _bdefa := _bfgef.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _bdefa != nil {
		return _bdefa
	}
	if _agdc := _bfgef.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _agdc != nil {
		return _agdc
	}
	if _adbec := _bfgef.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _adbec != nil {
		return _adbec
	}
	if _feccd := _bfgef.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _feccd != nil {
		return _feccd
	}
	if _gaegb := _bfgef.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _gaegb != nil {
		return _gaegb
	}
	if _dadfc := _bfgef.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _dadfc != nil {
		return _dadfc
	}
	if _deacd := _bfgef.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _deacd != nil {
		return _deacd
	}
	if _cagfb := _bfgef.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _cagfb != nil {
		return _cagfb
	}
	if _bceb := _bfgef.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _bceb != nil {
		return _bceb
	}
	if _baaadg := _bfgef.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _baaadg != nil {
		return _baaadg
	}
	if _agcee := _bfgef.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _agcee != nil {
		return _agcee
	}
	if _gbgbd := _bfgef.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _gbgbd != nil {
		return _gbgbd
	}
	if _gbbgg := _bfgef.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _gbbgg != nil {
		return _gbbgg
	}
	if _bddg := _bfgef.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _bddg != nil {
		return _bddg
	}
	if _abedf := _bfgef.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _abedf != nil {
		return _abedf
	}
	if _gfbgb := _bfgef.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _gfbgb != nil {
		return _gfbgb
	}
	if _dfce := _bfgef.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _dfce != nil {
		return _dfce
	}
	if _cafe := _bfgef.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _cafe != nil {
		return _cafe
	}
	if _gfbcc := _bfgef.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _gfbcc != nil {
		return _gfbcc
	}
	if _ffed := _bfgef.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _ffed != nil {
		return _ffed
	}
	if _dcbaa := _bfgef.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _dcbaa != nil {
		return _dcbaa
	}
	if _daaaa := _bfgef.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _daaaa != nil {
		return _daaaa
	}
	if _ffaec := _bfgef.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _ffaec != nil {
		return _ffaec
	}
	if _bdfdb := _bfgef.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _bdfdb != nil {
		return _bdfdb
	}
	return nil
}
func (_acdeb *OfcShapedefaults) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:shapedefaults"
	return _acdeb.OfcCT_ShapeDefaults.MarshalXML(e, start)
}
func NewOfcCT_Extrusion() *OfcCT_Extrusion { _cfadc := &OfcCT_Extrusion{}; return _cfadc }

type CT_Shapetype struct {
	MasterAttr            *string
	EG_ShapeElements      []*EG_ShapeElements
	Complex               *OfcComplex
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
	OpacityAttr           *string
	StrokedAttr           _eb.ST_TrueFalse
	StrokecolorAttr       *string
	StrokeweightAttr      *string
	InsetpenAttr          _eb.ST_TrueFalse
	ChromakeyAttr         *string
	FilledAttr            _eb.ST_TrueFalse
	FillcolorAttr         *string
	SptAttr               *float32
	ConnectortypeAttr     OfcST_ConnectorType
	BwmodeAttr            OfcST_BWMode
	BwpureAttr            OfcST_BWMode
	BwnormalAttr          OfcST_BWMode
	ForcedashAttr         _eb.ST_TrueFalse
	OleiconAttr           _eb.ST_TrueFalse
	OleAttr               _eb.ST_TrueFalseBlank
	PreferrelativeAttr    _eb.ST_TrueFalse
	CliptowrapAttr        _eb.ST_TrueFalse
	ClipAttr              _eb.ST_TrueFalse
	AdjAttr               *string
	PathAttr              *string
}

func (_fbbga *CT_PolyLine) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _ebca := range start.Attr {
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "userdrawn" {
			_fbbga.UserdrawnAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "clip" {
			_fbbga.ClipAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "userhidden" {
			_fbbga.UserhiddenAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "insetmode" {
			_fbbga.InsetmodeAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "bullet" {
			_fbbga.BulletAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "preferrelative" {
			_fbbga.PreferrelativeAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "hr" {
			_fbbga.HrAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "oleicon" {
			_fbbga.OleiconAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "hrstd" {
			_fbbga.HrstdAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "hrnoshade" {
			_fbbga.HrnoshadeAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "bordertopcolor" {
			_dbedf, _egba := _ebca.Value, error(nil)
			if _egba != nil {
				return _egba
			}
			_fbbga.BordertopcolorAttr = &_dbedf
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "dgmlayout" {
			_fbbga.DgmlayoutAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "allowoverlap" {
			_fbbga.AllowoverlapAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "bwnormal" {
			_fbbga.BwnormalAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "cliptowrap" {
			_fbbga.CliptowrapAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "borderbottomcolor" {
			_fedgc, _gcfa := _ebca.Value, error(nil)
			if _gcfa != nil {
				return _gcfa
			}
			_fbbga.BorderbottomcolorAttr = &_fedgc
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "oned" {
			_fbbga.OnedAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "dgmlayoutmru" {
			_fbbga.DgmlayoutmruAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "regroupid" {
			_bgfd, _aeaee := _e.ParseInt(_ebca.Value, 10, 64)
			if _aeaee != nil {
				return _aeaee
			}
			_fbbga.RegroupidAttr = &_bgfd
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "allowincell" {
			_fbbga.AllowincellAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "hrpct" {
			_dggcb, _edcbf := _e.ParseFloat(_ebca.Value, 64)
			if _edcbf != nil {
				return _edcbf
			}
			_aeddg := float32(_dggcb)
			_fbbga.HrpctAttr = &_aeddg
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "button" {
			_fbbga.ButtonAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "spid" {
			_dfgad, _bfbd := _ebca.Value, error(nil)
			if _bfbd != nil {
				return _bfbd
			}
			_fbbga.SpidAttr = &_dfgad
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "spt" {
			_bcacgd, _fegfa := _e.ParseFloat(_ebca.Value, 64)
			if _fegfa != nil {
				return _fegfa
			}
			_cabcf := float32(_bcacgd)
			_fbbga.SptAttr = &_cabcf
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "borderleftcolor" {
			_fbccc, _fcdee := _ebca.Value, error(nil)
			if _fcdee != nil {
				return _fcdee
			}
			_fbbga.BorderleftcolorAttr = &_fbccc
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "ole" {
			_fbbga.OleAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "borderrightcolor" {
			_gagae, _ebggb := _ebca.Value, error(nil)
			if _ebggb != nil {
				return _ebggb
			}
			_fbbga.BorderrightcolorAttr = &_gagae
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "bwmode" {
			_fbbga.BwmodeAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "dgmnodekind" {
			_cagg, _deaac := _e.ParseInt(_ebca.Value, 10, 64)
			if _deaac != nil {
				return _deaac
			}
			_fbbga.DgmnodekindAttr = &_cagg
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "forcedash" {
			_fbbga.ForcedashAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "bwpure" {
			_fbbga.BwpureAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "connectortype" {
			_fbbga.ConnectortypeAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "doubleclicknotify" {
			_fbbga.DoubleclicknotifyAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _ebca.Name.Local == "hralign" {
			_fbbga.HralignAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Local == "coordsize" {
			_gbc, _bcbe := _ebca.Value, error(nil)
			if _bcbe != nil {
				return _bcbe
			}
			_fbbga.CoordsizeAttr = &_gbc
			continue
		}
		if _ebca.Name.Local == "style" {
			_aedec, _bdcbb := _ebca.Value, error(nil)
			if _bdcbb != nil {
				return _bdcbb
			}
			_fbbga.StyleAttr = &_aedec
			continue
		}
		if _ebca.Name.Local == "id" {
			_edcaa, _dbfgb := _ebca.Value, error(nil)
			if _dbfgb != nil {
				return _dbfgb
			}
			_fbbga.IdAttr = &_edcaa
			continue
		}
		if _ebca.Name.Local == "stroked" {
			_fbbga.StrokedAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Local == "print" {
			_fbbga.PrintAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Local == "strokeweight" {
			_fbgcb, _beag := _ebca.Value, error(nil)
			if _beag != nil {
				return _beag
			}
			_fbbga.StrokeweightAttr = &_fbgcb
			continue
		}
		if _ebca.Name.Local == "wrapcoords" {
			_gbaed, _bbegf := _ebca.Value, error(nil)
			if _bbegf != nil {
				return _bbegf
			}
			_fbbga.WrapcoordsAttr = &_gbaed
			continue
		}
		if _ebca.Name.Local == "chromakey" {
			_ebgce, _abcfe := _ebca.Value, error(nil)
			if _abcfe != nil {
				return _abcfe
			}
			_fbbga.ChromakeyAttr = &_ebgce
			continue
		}
		if _ebca.Name.Local == "fillcolor" {
			_ededb, _cbdf := _ebca.Value, error(nil)
			if _cbdf != nil {
				return _cbdf
			}
			_fbbga.FillcolorAttr = &_ededb
			continue
		}
		if _ebca.Name.Local == "alt" {
			_ccac, _gebaf := _ebca.Value, error(nil)
			if _gebaf != nil {
				return _gebaf
			}
			_fbbga.AltAttr = &_ccac
			continue
		}
		if _ebca.Name.Local == "opacity" {
			_dcgb, _fffbd := _ebca.Value, error(nil)
			if _fffbd != nil {
				return _fffbd
			}
			_fbbga.OpacityAttr = &_dcgb
			continue
		}
		if _ebca.Name.Local == "strokecolor" {
			_bdde, _dbgd := _ebca.Value, error(nil)
			if _dbgd != nil {
				return _dbgd
			}
			_fbbga.StrokecolorAttr = &_bdde
			continue
		}
		if _ebca.Name.Local == "insetpen" {
			_fbbga.InsetpenAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Local == "filled" {
			_fbbga.FilledAttr.UnmarshalXMLAttr(_ebca)
			continue
		}
		if _ebca.Name.Local == "coordorigin" {
			_ecfb, _cdeff := _ebca.Value, error(nil)
			if _cdeff != nil {
				return _cdeff
			}
			_fbbga.CoordoriginAttr = &_ecfb
			continue
		}
		if _ebca.Name.Local == "title" {
			_egge, _gfbeec := _ebca.Value, error(nil)
			if _gfbeec != nil {
				return _gfbeec
			}
			_fbbga.TitleAttr = &_egge
			continue
		}
		if _ebca.Name.Local == "class" {
			_fdcad, _bfaf := _ebca.Value, error(nil)
			if _bfaf != nil {
				return _bfaf
			}
			_fbbga.ClassAttr = &_fdcad
			continue
		}
		if _ebca.Name.Local == "target" {
			_gdedf, _fbfb := _ebca.Value, error(nil)
			if _fbfb != nil {
				return _fbfb
			}
			_fbbga.TargetAttr = &_gdedf
			continue
		}
		if _ebca.Name.Local == "href" {
			_cdeb, _gfccc := _ebca.Value, error(nil)
			if _gfccc != nil {
				return _gfccc
			}
			_fbbga.HrefAttr = &_cdeb
			continue
		}
		if _ebca.Name.Local == "points" {
			_ceeab, _ecdd := _ebca.Value, error(nil)
			if _ecdd != nil {
				return _ecdd
			}
			_fbbga.PointsAttr = &_ceeab
			continue
		}
	}
_ecbcc:
	for {
		_edgcc, _dfdff := d.Token()
		if _dfdff != nil {
			return _dfdff
		}
		switch _agbc := _edgcc.(type) {
		case _b.StartElement:
			switch _agbc.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "ink"}:
				_cafca := NewOfcInk()
				if _fcbge := d.DecodeElement(_cafca, &_agbc); _fcbge != nil {
					return _fcbge
				}
				_fbbga.Ink = append(_fbbga.Ink, _cafca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_baaad := NewEG_ShapeElements()
				_baaad.Path = NewPath()
				if _acee := d.DecodeElement(_baaad.Path, &_agbc); _acee != nil {
					return _acee
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _baaad)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_fbcag := NewEG_ShapeElements()
				_fbcag.Formulas = NewFormulas()
				if _ceef := d.DecodeElement(_fbcag.Formulas, &_agbc); _ceef != nil {
					return _ceef
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _fbcag)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_cead := NewEG_ShapeElements()
				_cead.Handles = NewHandles()
				if _bgde := d.DecodeElement(_cead.Handles, &_agbc); _bgde != nil {
					return _bgde
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _cead)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_afcg := NewEG_ShapeElements()
				_afcg.Fill = NewFill()
				if _ecadc := d.DecodeElement(_afcg.Fill, &_agbc); _ecadc != nil {
					return _ecadc
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _afcg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_adad := NewEG_ShapeElements()
				_adad.Stroke = NewStroke()
				if _adcda := d.DecodeElement(_adad.Stroke, &_agbc); _adcda != nil {
					return _adcda
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _adad)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_dgdg := NewEG_ShapeElements()
				_dgdg.Shadow = NewShadow()
				if _acge := d.DecodeElement(_dgdg.Shadow, &_agbc); _acge != nil {
					return _acge
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _dgdg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_afdbc := NewEG_ShapeElements()
				_afdbc.Textbox = NewTextbox()
				if _dcacf := d.DecodeElement(_afdbc.Textbox, &_agbc); _dcacf != nil {
					return _dcacf
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _afdbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_gfag := NewEG_ShapeElements()
				_gfag.Textpath = NewTextpath()
				if _eaag := d.DecodeElement(_gfag.Textpath, &_agbc); _eaag != nil {
					return _eaag
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _gfag)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_dffef := NewEG_ShapeElements()
				_dffef.Imagedata = NewImagedata()
				if _gfebb := d.DecodeElement(_dffef.Imagedata, &_agbc); _gfebb != nil {
					return _gfebb
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _dffef)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_gfcf := NewEG_ShapeElements()
				_gfcf.Skew = NewOfcSkew()
				if _cggec := d.DecodeElement(_gfcf.Skew, &_agbc); _cggec != nil {
					return _cggec
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _gfcf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_efaa := NewEG_ShapeElements()
				_efaa.Extrusion = NewOfcExtrusion()
				if _ddca := d.DecodeElement(_efaa.Extrusion, &_agbc); _ddca != nil {
					return _ddca
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _efaa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_gbabe := NewEG_ShapeElements()
				_gbabe.Callout = NewOfcCallout()
				if _dcabc := d.DecodeElement(_gbabe.Callout, &_agbc); _dcabc != nil {
					return _dcabc
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _gbabe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_aefb := NewEG_ShapeElements()
				_aefb.Lock = NewOfcLock()
				if _efda := d.DecodeElement(_aefb.Lock, &_agbc); _efda != nil {
					return _efda
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _aefb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_aebcg := NewEG_ShapeElements()
				_aebcg.Clippath = NewOfcClippath()
				if _egfd := d.DecodeElement(_aebcg.Clippath, &_agbc); _egfd != nil {
					return _egfd
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _aebcg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_gfcb := NewEG_ShapeElements()
				_gfcb.Signatureline = NewOfcSignatureline()
				if _cdccb := d.DecodeElement(_gfcb.Signatureline, &_agbc); _cdccb != nil {
					return _cdccb
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _gfcb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_gcba := NewEG_ShapeElements()
				_gcba.Wrap = _a.NewWrap()
				if _dfaa := d.DecodeElement(_gcba.Wrap, &_agbc); _dfaa != nil {
					return _dfaa
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _gcba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_cbefc := NewEG_ShapeElements()
				_cbefc.Anchorlock = _a.NewAnchorlock()
				if _cdfg := d.DecodeElement(_cbefc.Anchorlock, &_agbc); _cdfg != nil {
					return _cdfg
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _cbefc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_gdadg := NewEG_ShapeElements()
				_gdadg.Bordertop = _a.NewBordertop()
				if _bcfg := d.DecodeElement(_gdadg.Bordertop, &_agbc); _bcfg != nil {
					return _bcfg
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _gdadg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_ebgfa := NewEG_ShapeElements()
				_ebgfa.Borderbottom = _a.NewBorderbottom()
				if _cfga := d.DecodeElement(_ebgfa.Borderbottom, &_agbc); _cfga != nil {
					return _cfga
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _ebgfa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_edbg := NewEG_ShapeElements()
				_edbg.Borderleft = _a.NewBorderleft()
				if _eadb := d.DecodeElement(_edbg.Borderleft, &_agbc); _eadb != nil {
					return _eadb
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _edbg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_cbcee := NewEG_ShapeElements()
				_cbcee.Borderright = _a.NewBorderright()
				if _cabd := d.DecodeElement(_cbcee.Borderright, &_agbc); _cabd != nil {
					return _cabd
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _cbcee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_aeaec := NewEG_ShapeElements()
				_aeaec.ClientData = _c.NewClientData()
				if _dgbcb := d.DecodeElement(_aeaec.ClientData, &_agbc); _dgbcb != nil {
					return _dgbcb
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _aeaec)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_geaa := NewEG_ShapeElements()
				_geaa.Textdata = _bf.NewTextdata()
				if _bbabg := d.DecodeElement(_geaa.Textdata, &_agbc); _bbabg != nil {
					return _bbabg
				}
				_fbbga.EG_ShapeElements = append(_fbbga.EG_ShapeElements, _geaa)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_PolyLine\u0020\u0025v", _agbc.Name)
				if _dbaaf := d.Skip(); _dbaaf != nil {
					return _dbaaf
				}
			}
		case _b.EndElement:
			break _ecbcc
		case _b.CharData:
		}
	}
	return nil
}
func (_daffea ST_FillType) ValidateWithPath(path string) error {
	switch _daffea {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_daffea))
	}
	return nil
}
func (_dcdb *OfcCT_Relation) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _egceg := range start.Attr {
		if _egceg.Name.Local == "idsrc" {
			_dgcbe, _egef := _egceg.Value, error(nil)
			if _egef != nil {
				return _egef
			}
			_dcdb.IdsrcAttr = &_dgcbe
			continue
		}
		if _egceg.Name.Local == "iddest" {
			_dacfac, _faaad := _egceg.Value, error(nil)
			if _faaad != nil {
				return _faaad
			}
			_dcdb.IddestAttr = &_dacfac
			continue
		}
		if _egceg.Name.Local == "idcntr" {
			_dacff, _cfcf := _egceg.Value, error(nil)
			if _cfcf != nil {
				return _cfcf
			}
			_dcdb.IdcntrAttr = &_dacff
			continue
		}
		if _egceg.Name.Local == "ext" {
			_dcdb.ExtAttr.UnmarshalXMLAttr(_egceg)
			continue
		}
	}
	for {
		_dggbc, _cegge := d.Token()
		if _cegge != nil {
			return _f.Errorf("parsing\u0020OfcCT_Relation:\u0020\u0025s", _cegge)
		}
		if _gfdbf, _badfb := _dggbc.(_b.EndElement); _badfb && _gfdbf.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the OfcCT_OLEObject and its children
func (_fbba *OfcCT_OLEObject) Validate() error { return _fbba.ValidateWithPath("OfcCT_OLEObject") }
func (_cgecc *OfcRight) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:right"
	return _cgecc.OfcCT_StrokeChild.MarshalXML(e, start)
}
func (_cbbg *CT_Formulas) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _cbbg.F != nil {
		_acaag := _b.StartElement{Name: _b.Name{Local: "v:f"}}
		for _, _fgcae := range _cbbg.F {
			e.EncodeElement(_fgcae, _acaag)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type CT_Line struct {
	FromAttr              *string
	ToAttr                *string
	EG_ShapeElements      []*EG_ShapeElements
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
	OpacityAttr           *string
	StrokedAttr           _eb.ST_TrueFalse
	StrokecolorAttr       *string
	StrokeweightAttr      *string
	InsetpenAttr          _eb.ST_TrueFalse
	ChromakeyAttr         *string
	FilledAttr            _eb.ST_TrueFalse
	FillcolorAttr         *string
	SptAttr               *float32
	ConnectortypeAttr     OfcST_ConnectorType
	BwmodeAttr            OfcST_BWMode
	BwpureAttr            OfcST_BWMode
	BwnormalAttr          OfcST_BWMode
	ForcedashAttr         _eb.ST_TrueFalse
	OleiconAttr           _eb.ST_TrueFalse
	OleAttr               _eb.ST_TrueFalseBlank
	PreferrelativeAttr    _eb.ST_TrueFalse
	CliptowrapAttr        _eb.ST_TrueFalse
	ClipAttr              _eb.ST_TrueFalse
}
type OfcExtrusion struct{ OfcCT_Extrusion }

func (_gfbga *OfcST_ConnectType) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_adaag, _bdgac := d.Token()
	if _bdgac != nil {
		return _bdgac
	}
	if _bgfcg, _bdcaa := _adaag.(_b.EndElement); _bdcaa && _bgfcg.Name == start.Name {
		*_gfbga = 1
		return nil
	}
	if _effcc, _ababb := _adaag.(_b.CharData); !_ababb {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _adaag)
	} else {
		switch string(_effcc) {
		case "":
			*_gfbga = 0
		case "none":
			*_gfbga = 1
		case "rect":
			*_gfbga = 2
		case "segments":
			*_gfbga = 3
		case "custom":
			*_gfbga = 4
		}
	}
	_adaag, _bdgac = d.Token()
	if _bdgac != nil {
		return _bdgac
	}
	if _afdea, _accefc := _adaag.(_b.EndElement); _accefc && _afdea.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _adaag)
}
func NewCT_Oval() *CT_Oval { _bcacg := &CT_Oval{}; return _bcacg }

// ValidateWithPath validates the OfcCT_Relation and its children, prefixing error messages with path
func (_dbaac *OfcCT_Relation) ValidateWithPath(path string) error {
	if _ffbbc := _dbaac.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _ffbbc != nil {
		return _ffbbc
	}
	return nil
}
func (_ggaab *Formulas) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _ggaab.CT_Formulas.MarshalXML(e, start)
}

type Path struct{ CT_Path }
type Image struct{ CT_Image }

func NewOfcShapelayout() *OfcShapelayout {
	_bbdc := &OfcShapelayout{}
	_bbdc.OfcCT_ShapeLayout = *NewOfcCT_ShapeLayout()
	return _bbdc
}

type OfcST_ExtrusionPlane byte

func NewCT_Image() *CT_Image { _acbcd := &CT_Image{}; return _acbcd }
func (_bbaded *OfcCT_Extrusion) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _cdgeb := range start.Attr {
		if _cdgeb.Name.Local == "colormode" {
			_bbaded.ColormodeAttr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "color" {
			_cagdd, _aebea := _cdgeb.Value, error(nil)
			if _aebea != nil {
				return _aebea
			}
			_bbaded.ColorAttr = &_cagdd
			continue
		}
		if _cdgeb.Name.Local == "type" {
			_bbaded.TypeAttr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "shininess" {
			_bafb, _fdace := _e.ParseFloat(_cdgeb.Value, 64)
			if _fdace != nil {
				return _fdace
			}
			_beedde := float32(_bafb)
			_bbaded.ShininessAttr = &_beedde
			continue
		}
		if _cdgeb.Name.Local == "viewpointorigin" {
			_cbcf, _aafga := _cdgeb.Value, error(nil)
			if _aafga != nil {
				return _aafga
			}
			_bbaded.ViewpointoriginAttr = &_cbcf
			continue
		}
		if _cdgeb.Name.Local == "specularity" {
			_daaee, _bfgfdg := _cdgeb.Value, error(nil)
			if _bfgfdg != nil {
				return _bfgfdg
			}
			_bbaded.SpecularityAttr = &_daaee
			continue
		}
		if _cdgeb.Name.Local == "plane" {
			_bbaded.PlaneAttr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "diffusity" {
			_cacffg, _bfggd := _cdgeb.Value, error(nil)
			if _bfggd != nil {
				return _bfggd
			}
			_bbaded.DiffusityAttr = &_cacffg
			continue
		}
		if _cdgeb.Name.Local == "skewamt" {
			_beagf, _gdbc := _cdgeb.Value, error(nil)
			if _gdbc != nil {
				return _gdbc
			}
			_bbaded.SkewamtAttr = &_beagf
			continue
		}
		if _cdgeb.Name.Local == "metal" {
			_bbaded.MetalAttr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "backdepth" {
			_decad, _edcada := _cdgeb.Value, error(nil)
			if _edcada != nil {
				return _edcada
			}
			_bbaded.BackdepthAttr = &_decad
			continue
		}
		if _cdgeb.Name.Local == "edge" {
			_aaefd, _dafdc := _cdgeb.Value, error(nil)
			if _dafdc != nil {
				return _dafdc
			}
			_bbaded.EdgeAttr = &_aaefd
			continue
		}
		if _cdgeb.Name.Local == "lightlevel2" {
			_bceed, _bfecd := _cdgeb.Value, error(nil)
			if _bfecd != nil {
				return _bfecd
			}
			_bbaded.Lightlevel2Attr = &_bceed
			continue
		}
		if _cdgeb.Name.Local == "orientationangle" {
			_agggb, _cccc := _e.ParseFloat(_cdgeb.Value, 64)
			if _cccc != nil {
				return _cccc
			}
			_cacba := float32(_agggb)
			_bbaded.OrientationangleAttr = &_cacba
			continue
		}
		if _cdgeb.Name.Local == "on" {
			_bbaded.OnAttr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "lightharsh" {
			_bbaded.LightharshAttr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "lightface" {
			_bbaded.LightfaceAttr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "foredepth" {
			_deded, _ffbcg := _cdgeb.Value, error(nil)
			if _ffbcg != nil {
				return _ffbcg
			}
			_bbaded.ForedepthAttr = &_deded
			continue
		}
		if _cdgeb.Name.Local == "ext" {
			_bbaded.ExtAttr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "autorotationcenter" {
			_bbaded.AutorotationcenterAttr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "facet" {
			_gbfg, _ecebf := _cdgeb.Value, error(nil)
			if _ecebf != nil {
				return _ecebf
			}
			_bbaded.FacetAttr = &_gbfg
			continue
		}
		if _cdgeb.Name.Local == "render" {
			_bbaded.RenderAttr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "lightlevel" {
			_agfea, _dged := _cdgeb.Value, error(nil)
			if _dged != nil {
				return _dged
			}
			_bbaded.LightlevelAttr = &_agfea
			continue
		}
		if _cdgeb.Name.Local == "brightness" {
			_addaf, _agdgb := _cdgeb.Value, error(nil)
			if _agdgb != nil {
				return _agdgb
			}
			_bbaded.BrightnessAttr = &_addaf
			continue
		}
		if _cdgeb.Name.Local == "skewangle" {
			_ebgfg, _dfee := _e.ParseFloat(_cdgeb.Value, 64)
			if _dfee != nil {
				return _dfee
			}
			_dcecb := float32(_ebgfg)
			_bbaded.SkewangleAttr = &_dcecb
			continue
		}
		if _cdgeb.Name.Local == "lightposition2" {
			_feeaa, _fddae := _cdgeb.Value, error(nil)
			if _fddae != nil {
				return _fddae
			}
			_bbaded.Lightposition2Attr = &_feeaa
			continue
		}
		if _cdgeb.Name.Local == "rotationangle" {
			_cbabdd, _ebdbe := _cdgeb.Value, error(nil)
			if _ebdbe != nil {
				return _ebdbe
			}
			_bbaded.RotationangleAttr = &_cbabdd
			continue
		}
		if _cdgeb.Name.Local == "lightharsh2" {
			_bbaded.Lightharsh2Attr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "orientation" {
			_cbbcb, _eeaca := _cdgeb.Value, error(nil)
			if _eeaca != nil {
				return _eeaca
			}
			_bbaded.OrientationAttr = &_cbbcb
			continue
		}
		if _cdgeb.Name.Local == "lockrotationcenter" {
			_bbaded.LockrotationcenterAttr.UnmarshalXMLAttr(_cdgeb)
			continue
		}
		if _cdgeb.Name.Local == "rotationcenter" {
			_edecd, _bbfee := _cdgeb.Value, error(nil)
			if _bbfee != nil {
				return _bbfee
			}
			_bbaded.RotationcenterAttr = &_edecd
			continue
		}
		if _cdgeb.Name.Local == "viewpoint" {
			_ebbdg, _adadc := _cdgeb.Value, error(nil)
			if _adadc != nil {
				return _adadc
			}
			_bbaded.ViewpointAttr = &_ebbdg
			continue
		}
		if _cdgeb.Name.Local == "lightposition" {
			_cabgad, _bdbdb := _cdgeb.Value, error(nil)
			if _bdbdb != nil {
				return _bdbdb
			}
			_bbaded.LightpositionAttr = &_cabgad
			continue
		}
	}
	for {
		_fegdgg, _gfcggc := d.Token()
		if _gfcggc != nil {
			return _f.Errorf("parsing OfcCT_Extrusion:\u0020\u0025s", _gfcggc)
		}
		if _gefgf, _cddb := _fegdgg.(_b.EndElement); _cddb && _gefgf.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Image struct {
	EG_ShapeElements      []*EG_ShapeElements
	HrefAttr              *string
	TargetAttr            *string
	ClassAttr             *string
	TitleAttr             *string
	AltAttr               *string
	CoordsizeAttr         *string
	CoordoriginAttr       *string
	WrapcoordsAttr        *string
	PrintAttr             _eb.ST_TrueFalse
	IdAttr                *string
	StyleAttr             *string
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
	OpacityAttr           *string
	StrokedAttr           _eb.ST_TrueFalse
	StrokecolorAttr       *string
	StrokeweightAttr      *string
	InsetpenAttr          _eb.ST_TrueFalse
	ChromakeyAttr         *string
	FilledAttr            _eb.ST_TrueFalse
	FillcolorAttr         *string
	SptAttr               *float32
	ConnectortypeAttr     OfcST_ConnectorType
	BwmodeAttr            OfcST_BWMode
	BwpureAttr            OfcST_BWMode
	BwnormalAttr          OfcST_BWMode
	ForcedashAttr         _eb.ST_TrueFalse
	OleiconAttr           _eb.ST_TrueFalse
	OleAttr               _eb.ST_TrueFalseBlank
	PreferrelativeAttr    _eb.ST_TrueFalse
	CliptowrapAttr        _eb.ST_TrueFalse
	ClipAttr              _eb.ST_TrueFalse
	SrcAttr               *string
	CropleftAttr          *string
	CroptopAttr           *string
	CroprightAttr         *string
	CropbottomAttr        *string
	GainAttr              *string
	BlacklevelAttr        *string
	GammaAttr             *string
	GrayscaleAttr         _eb.ST_TrueFalse
	BilevelAttr           _eb.ST_TrueFalse
}

func (_fcce *OfcBottom) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:bottom"
	return _fcce.OfcCT_StrokeChild.MarshalXML(e, start)
}

// Validate validates the OfcSkew and its children
func (_abcad *OfcSkew) Validate() error        { return _abcad.ValidateWithPath("OfcSkew") }
func (_gadba ST_EditAs) Validate() error       { return _gadba.ValidateWithPath("") }
func NewAG_CoreAttributes() *AG_CoreAttributes { _ea := &AG_CoreAttributes{}; return _ea }
func (_edgbc ST_EditAs) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_cdba := _b.Attr{}
	_cdba.Name = name
	switch _edgbc {
	case ST_EditAsUnset:
		_cdba.Value = ""
	case ST_EditAsCanvas:
		_cdba.Value = "canvas"
	case ST_EditAsOrgchart:
		_cdba.Value = "orgchart"
	case ST_EditAsRadial:
		_cdba.Value = "radial"
	case ST_EditAsCycle:
		_cdba.Value = "cycle"
	case ST_EditAsStacked:
		_cdba.Value = "stacked"
	case ST_EditAsVenn:
		_cdba.Value = "venn"
	case ST_EditAsBullseye:
		_cdba.Value = "bullseye"
	}
	return _cdba, nil
}

type Imagedata struct{ CT_ImageData }

func (_gggeb OfcST_CalloutPlacement) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_ffgbab := _b.Attr{}
	_ffgbab.Name = name
	switch _gggeb {
	case OfcST_CalloutPlacementUnset:
		_ffgbab.Value = ""
	case OfcST_CalloutPlacementTop:
		_ffgbab.Value = "top"
	case OfcST_CalloutPlacementCenter:
		_ffgbab.Value = "center"
	case OfcST_CalloutPlacementBottom:
		_ffgbab.Value = "bottom"
	case OfcST_CalloutPlacementUser:
		_ffgbab.Value = "user"
	}
	return _ffgbab, nil
}
func (_agcfc ST_FillMethod) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_agcfc.String(), start)
}

// ValidateWithPath validates the OfcCT_Entry and its children, prefixing error messages with path
func (_bgabb *OfcCT_Entry) ValidateWithPath(path string) error { return nil }
func NewFill() *Fill                                           { _agccd := &Fill{}; _agccd.CT_Fill = *NewCT_Fill(); return _agccd }
func NewAG_Fill() *AG_Fill                                     { _ffde := &AG_Fill{}; return _ffde }

// ValidateWithPath validates the CT_Shapetype and its children, prefixing error messages with path
func (_bagff *CT_Shapetype) ValidateWithPath(path string) error {
	for _gdbda, _fbgd := range _bagff.EG_ShapeElements {
		if _afgde := _fbgd.ValidateWithPath(_f.Sprintf("\u0025s\u002fEG_ShapeElements\u005b\u0025d\u005d", path, _gdbda)); _afgde != nil {
			return _afgde
		}
	}
	if _bagff.Complex != nil {
		if _aacae := _bagff.Complex.ValidateWithPath(path + "\u002fComplex"); _aacae != nil {
			return _aacae
		}
	}
	if _bgffc := _bagff.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _bgffc != nil {
		return _bgffc
	}
	if _fcdb := _bagff.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _fcdb != nil {
		return _fcdb
	}
	if _ccddb := _bagff.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _ccddb != nil {
		return _ccddb
	}
	if _gafdb := _bagff.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _gafdb != nil {
		return _gafdb
	}
	if _egfab := _bagff.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _egfab != nil {
		return _egfab
	}
	if _ebcad := _bagff.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _ebcad != nil {
		return _ebcad
	}
	if _acgb := _bagff.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _acgb != nil {
		return _acgb
	}
	if _gebad := _bagff.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _gebad != nil {
		return _gebad
	}
	if _cgeef := _bagff.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _cgeef != nil {
		return _cgeef
	}
	if _dcedb := _bagff.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _dcedb != nil {
		return _dcedb
	}
	if _aegb := _bagff.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _aegb != nil {
		return _aegb
	}
	if _bbdbf := _bagff.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _bbdbf != nil {
		return _bbdbf
	}
	if _egda := _bagff.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _egda != nil {
		return _egda
	}
	if _adfbd := _bagff.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _adfbd != nil {
		return _adfbd
	}
	if _aeacf := _bagff.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _aeacf != nil {
		return _aeacf
	}
	if _cdabc := _bagff.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _cdabc != nil {
		return _cdabc
	}
	if _cdbdb := _bagff.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _cdbdb != nil {
		return _cdbdb
	}
	if _fbcg := _bagff.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _fbcg != nil {
		return _fbcg
	}
	if _fbdgb := _bagff.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _fbdgb != nil {
		return _fbdgb
	}
	if _bcbcd := _bagff.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _bcbcd != nil {
		return _bcbcd
	}
	if _cbcbe := _bagff.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _cbcbe != nil {
		return _cbcbe
	}
	if _abfdf := _bagff.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _abfdf != nil {
		return _abfdf
	}
	if _cfgaf := _bagff.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _cfgaf != nil {
		return _cfgaf
	}
	if _bafda := _bagff.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _bafda != nil {
		return _bafda
	}
	if _aaccc := _bagff.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _aaccc != nil {
		return _aaccc
	}
	if _cacd := _bagff.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _cacd != nil {
		return _cacd
	}
	if _cceee := _bagff.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _cceee != nil {
		return _cceee
	}
	if _ebfdd := _bagff.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _ebfdd != nil {
		return _ebfdd
	}
	if _ggggb := _bagff.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _ggggb != nil {
		return _ggggb
	}
	return nil
}

const (
	ST_StrokeArrowTypeUnset   ST_StrokeArrowType = 0
	ST_StrokeArrowTypeNone    ST_StrokeArrowType = 1
	ST_StrokeArrowTypeBlock   ST_StrokeArrowType = 2
	ST_StrokeArrowTypeClassic ST_StrokeArrowType = 3
	ST_StrokeArrowTypeOval    ST_StrokeArrowType = 4
	ST_StrokeArrowTypeDiamond ST_StrokeArrowType = 5
	ST_StrokeArrowTypeOpen    ST_StrokeArrowType = 6
)

func (_gfbff *OfcCT_Lock) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _gfbff.PositionAttr != _eb.ST_TrueFalseUnset {
		_cdgge, _efadg := _gfbff.PositionAttr.MarshalXMLAttr(_b.Name{Local: "position"})
		if _efadg != nil {
			return _efadg
		}
		start.Attr = append(start.Attr, _cdgge)
	}
	if _gfbff.SelectionAttr != _eb.ST_TrueFalseUnset {
		_gagb, _caabbb := _gfbff.SelectionAttr.MarshalXMLAttr(_b.Name{Local: "selection"})
		if _caabbb != nil {
			return _caabbb
		}
		start.Attr = append(start.Attr, _gagb)
	}
	if _gfbff.GroupingAttr != _eb.ST_TrueFalseUnset {
		_gbbea, _bbba := _gfbff.GroupingAttr.MarshalXMLAttr(_b.Name{Local: "grouping"})
		if _bbba != nil {
			return _bbba
		}
		start.Attr = append(start.Attr, _gbbea)
	}
	if _gfbff.UngroupingAttr != _eb.ST_TrueFalseUnset {
		_deaacg, _cddge := _gfbff.UngroupingAttr.MarshalXMLAttr(_b.Name{Local: "ungrouping"})
		if _cddge != nil {
			return _cddge
		}
		start.Attr = append(start.Attr, _deaacg)
	}
	if _gfbff.RotationAttr != _eb.ST_TrueFalseUnset {
		_fbgbg, _fecb := _gfbff.RotationAttr.MarshalXMLAttr(_b.Name{Local: "rotation"})
		if _fecb != nil {
			return _fecb
		}
		start.Attr = append(start.Attr, _fbgbg)
	}
	if _gfbff.CroppingAttr != _eb.ST_TrueFalseUnset {
		_cacfb, _fbedb := _gfbff.CroppingAttr.MarshalXMLAttr(_b.Name{Local: "cropping"})
		if _fbedb != nil {
			return _fbedb
		}
		start.Attr = append(start.Attr, _cacfb)
	}
	if _gfbff.VerticiesAttr != _eb.ST_TrueFalseUnset {
		_ggedab, _cfdfb := _gfbff.VerticiesAttr.MarshalXMLAttr(_b.Name{Local: "verticies"})
		if _cfdfb != nil {
			return _cfdfb
		}
		start.Attr = append(start.Attr, _ggedab)
	}
	if _gfbff.AdjusthandlesAttr != _eb.ST_TrueFalseUnset {
		_fcbcd, _efabg := _gfbff.AdjusthandlesAttr.MarshalXMLAttr(_b.Name{Local: "adjusthandles"})
		if _efabg != nil {
			return _efabg
		}
		start.Attr = append(start.Attr, _fcbcd)
	}
	if _gfbff.TextAttr != _eb.ST_TrueFalseUnset {
		_gafad, _cddfb := _gfbff.TextAttr.MarshalXMLAttr(_b.Name{Local: "text"})
		if _cddfb != nil {
			return _cddfb
		}
		start.Attr = append(start.Attr, _gafad)
	}
	if _gfbff.AspectratioAttr != _eb.ST_TrueFalseUnset {
		_gddba, _ffgca := _gfbff.AspectratioAttr.MarshalXMLAttr(_b.Name{Local: "aspectratio"})
		if _ffgca != nil {
			return _ffgca
		}
		start.Attr = append(start.Attr, _gddba)
	}
	if _gfbff.ShapetypeAttr != _eb.ST_TrueFalseUnset {
		_afcdb, _eabdgd := _gfbff.ShapetypeAttr.MarshalXMLAttr(_b.Name{Local: "shapetype"})
		if _eabdgd != nil {
			return _eabdgd
		}
		start.Attr = append(start.Attr, _afcdb)
	}
	if _gfbff.ExtAttr != ST_ExtUnset {
		_eecdc, _abcga := _gfbff.ExtAttr.MarshalXMLAttr(_b.Name{Local: "ext"})
		if _abcga != nil {
			return _abcga
		}
		start.Attr = append(start.Attr, _eecdc)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the AG_Fill and its children, prefixing error messages with path
func (_aac *AG_Fill) ValidateWithPath(path string) error {
	if _dce := _aac.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _dce != nil {
		return _dce
	}
	return nil
}

const (
	OfcST_FillTypeUnset            OfcST_FillType = 0
	OfcST_FillTypeGradientCenter   OfcST_FillType = 1
	OfcST_FillTypeSolid            OfcST_FillType = 2
	OfcST_FillTypePattern          OfcST_FillType = 3
	OfcST_FillTypeTile             OfcST_FillType = 4
	OfcST_FillTypeFrame            OfcST_FillType = 5
	OfcST_FillTypeGradientUnscaled OfcST_FillType = 6
	OfcST_FillTypeGradientRadial   OfcST_FillType = 7
	OfcST_FillTypeGradient         OfcST_FillType = 8
	OfcST_FillTypeBackground       OfcST_FillType = 9
)

func (_dgggc OfcST_ExtrusionType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_gdcegg := _b.Attr{}
	_gdcegg.Name = name
	switch _dgggc {
	case OfcST_ExtrusionTypeUnset:
		_gdcegg.Value = ""
	case OfcST_ExtrusionTypePerspective:
		_gdcegg.Value = "perspective"
	case OfcST_ExtrusionTypeParallel:
		_gdcegg.Value = "parallel"
	}
	return _gdcegg, nil
}

type AG_CoreAttributes struct {
	HrefAttr        *string
	TargetAttr      *string
	ClassAttr       *string
	TitleAttr       *string
	AltAttr         *string
	CoordsizeAttr   *string
	CoordoriginAttr *string
	WrapcoordsAttr  *string
	PrintAttr       _eb.ST_TrueFalse
	IdAttr          *string
	StyleAttr       *string
}

// ValidateWithPath validates the OfcCallout and its children, prefixing error messages with path
func (_gaffc *OfcCallout) ValidateWithPath(path string) error {
	if _gcbgcb := _gaffc.OfcCT_Callout.ValidateWithPath(path); _gcbgcb != nil {
		return _gcbgcb
	}
	return nil
}

const (
	ST_FillTypeUnset          ST_FillType = 0
	ST_FillTypeSolid          ST_FillType = 1
	ST_FillTypeGradient       ST_FillType = 2
	ST_FillTypeGradientRadial ST_FillType = 3
	ST_FillTypeTile           ST_FillType = 4
	ST_FillTypePattern        ST_FillType = 5
	ST_FillTypeFrame          ST_FillType = 6
)

func (_dabdga *OfcST_ExtrusionType) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_dabdga = 0
	case "perspective":
		*_dabdga = 1
	case "parallel":
		*_dabdga = 2
	}
	return nil
}
func NewOfcColumn() *OfcColumn {
	_ccag := &OfcColumn{}
	_ccag.OfcCT_StrokeChild = *NewOfcCT_StrokeChild()
	return _ccag
}
func NewOfcCT_SignatureLine() *OfcCT_SignatureLine { _afbg := &OfcCT_SignatureLine{}; return _afbg }
func (_cefga OfcST_How) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bgfbc := _b.Attr{}
	_bgfbc.Name = name
	switch _cefga {
	case OfcST_HowUnset:
		_bgfbc.Value = ""
	case OfcST_HowTop:
		_bgfbc.Value = "top"
	case OfcST_HowMiddle:
		_bgfbc.Value = "middle"
	case OfcST_HowBottom:
		_bgfbc.Value = "bottom"
	case OfcST_HowLeft:
		_bgfbc.Value = "left"
	case OfcST_HowCenter:
		_bgfbc.Value = "center"
	case OfcST_HowRight:
		_bgfbc.Value = "right"
	}
	return _bgfbc, nil
}
func (_bdfdbf OfcST_HrAlign) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_bfeg := _b.Attr{}
	_bfeg.Name = name
	switch _bdfdbf {
	case OfcST_HrAlignUnset:
		_bfeg.Value = ""
	case OfcST_HrAlignLeft:
		_bfeg.Value = "left"
	case OfcST_HrAlignRight:
		_bfeg.Value = "right"
	case OfcST_HrAlignCenter:
		_bfeg.Value = "center"
	}
	return _bfeg, nil
}

// ValidateWithPath validates the AG_Ext and its children, prefixing error messages with path
func (_ecc *AG_Ext) ValidateWithPath(path string) error {
	if _ecc.ExtAttr == ST_ExtUnset {
		return _f.Errorf("\u0025s\u002fExtAttr\u0020is\u0020a\u0020mandatory\u0020field", path)
	}
	if _fddc := _ecc.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _fddc != nil {
		return _fddc
	}
	return nil
}
func (_dggceb *OfcCT_Proxy) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _egdef := range start.Attr {
		if _egdef.Name.Local == "start" {
			_dggceb.StartAttr.UnmarshalXMLAttr(_egdef)
			continue
		}
		if _egdef.Name.Local == "end" {
			_dggceb.EndAttr.UnmarshalXMLAttr(_egdef)
			continue
		}
		if _egdef.Name.Local == "idref" {
			_cdeaef, _cdgcd := _egdef.Value, error(nil)
			if _cdgcd != nil {
				return _cdgcd
			}
			_dggceb.IdrefAttr = &_cdeaef
			continue
		}
		if _egdef.Name.Local == "connectloc" {
			_dccec, _edccf := _e.ParseInt(_egdef.Value, 10, 32)
			if _edccf != nil {
				return _edccf
			}
			_cgeae := int32(_dccec)
			_dggceb.ConnectlocAttr = &_cgeae
			continue
		}
	}
	for {
		_ddgbc, _ebaggd := d.Token()
		if _ebaggd != nil {
			return _f.Errorf("parsing\u0020OfcCT_Proxy:\u0020\u0025s", _ebaggd)
		}
		if _bfdee, _accg := _ddgbc.(_b.EndElement); _accg && _bfdee.Name == start.Name {
			break
		}
	}
	return nil
}

type OfcST_InsetMode byte

// Validate validates the CT_Line and its children
func (_dbgf *CT_Line) Validate() error { return _dbgf.ValidateWithPath("CT_Line") }
func (_ff *AG_AllCoreAttributes) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _cbf := range start.Attr {
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "bullet" {
			_ff.BulletAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "oned" {
			_ff.OnedAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "allowincell" {
			_ff.AllowincellAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "regroupid" {
			_cgeg, _geg := _e.ParseInt(_cbf.Value, 10, 64)
			if _geg != nil {
				return _geg
			}
			_ff.RegroupidAttr = &_cgeg
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "dgmnodekind" {
			_gcd, _fg := _e.ParseInt(_cbf.Value, 10, 64)
			if _fg != nil {
				return _fg
			}
			_ff.DgmnodekindAttr = &_gcd
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "doubleclicknotify" {
			_ff.DoubleclicknotifyAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "borderrightcolor" {
			_bcb, _ga := _cbf.Value, error(nil)
			if _ga != nil {
				return _ga
			}
			_ff.BorderrightcolorAttr = &_bcb
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "button" {
			_ff.ButtonAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "borderleftcolor" {
			_ca, _agf := _cbf.Value, error(nil)
			if _agf != nil {
				return _agf
			}
			_ff.BorderleftcolorAttr = &_ca
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "userhidden" {
			_ff.UserhiddenAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "userdrawn" {
			_ff.UserdrawnAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "spid" {
			_bbf, _bdf := _cbf.Value, error(nil)
			if _bdf != nil {
				return _bdf
			}
			_ff.SpidAttr = &_bbf
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "dgmlayoutmru" {
			_ff.DgmlayoutmruAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "dgmlayout" {
			_ff.DgmlayoutAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "borderbottomcolor" {
			_ce, _dgg := _cbf.Value, error(nil)
			if _dgg != nil {
				return _dgg
			}
			_ff.BorderbottomcolorAttr = &_ce
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "bordertopcolor" {
			_bcd, _gef := _cbf.Value, error(nil)
			if _gef != nil {
				return _gef
			}
			_ff.BordertopcolorAttr = &_bcd
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "allowoverlap" {
			_ff.AllowoverlapAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "insetmode" {
			_ff.InsetmodeAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "hr" {
			_ff.HrAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "hrstd" {
			_ff.HrstdAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "hrnoshade" {
			_ff.HrnoshadeAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "hrpct" {
			_gebc, _gbe := _e.ParseFloat(_cbf.Value, 64)
			if _gbe != nil {
				return _gbe
			}
			_da := float32(_gebc)
			_ff.HrpctAttr = &_da
			continue
		}
		if _cbf.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbf.Name.Local == "hralign" {
			_ff.HralignAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Local == "target" {
			_bfdf, _fac := _cbf.Value, error(nil)
			if _fac != nil {
				return _fac
			}
			_ff.TargetAttr = &_bfdf
			continue
		}
		if _cbf.Name.Local == "style" {
			_gca, _abe := _cbf.Value, error(nil)
			if _abe != nil {
				return _abe
			}
			_ff.StyleAttr = &_gca
			continue
		}
		if _cbf.Name.Local == "id" {
			_ffd, _dac := _cbf.Value, error(nil)
			if _dac != nil {
				return _dac
			}
			_ff.IdAttr = &_ffd
			continue
		}
		if _cbf.Name.Local == "print" {
			_ff.PrintAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Local == "wrapcoords" {
			_ac, _ebdf := _cbf.Value, error(nil)
			if _ebdf != nil {
				return _ebdf
			}
			_ff.WrapcoordsAttr = &_ac
			continue
		}
		if _cbf.Name.Local == "coordorigin" {
			_gfbe, _gege := _cbf.Value, error(nil)
			if _gege != nil {
				return _gege
			}
			_ff.CoordoriginAttr = &_gfbe
			continue
		}
		if _cbf.Name.Local == "coordsize" {
			_fb, _bfc := _cbf.Value, error(nil)
			if _bfc != nil {
				return _bfc
			}
			_ff.CoordsizeAttr = &_fb
			continue
		}
		if _cbf.Name.Local == "alt" {
			_fba, _beg := _cbf.Value, error(nil)
			if _beg != nil {
				return _beg
			}
			_ff.AltAttr = &_fba
			continue
		}
		if _cbf.Name.Local == "title" {
			_abd, _ffa := _cbf.Value, error(nil)
			if _ffa != nil {
				return _ffa
			}
			_ff.TitleAttr = &_abd
			continue
		}
		if _cbf.Name.Local == "class" {
			_bg, _cd := _cbf.Value, error(nil)
			if _cd != nil {
				return _cd
			}
			_ff.ClassAttr = &_bg
			continue
		}
		if _cbf.Name.Local == "href" {
			_eg, _aca := _cbf.Value, error(nil)
			if _aca != nil {
				return _aca
			}
			_ff.HrefAttr = &_eg
			continue
		}
	}
	for {
		_dad, _bff := d.Token()
		if _bff != nil {
			return _f.Errorf("parsing\u0020AG_AllCoreAttributes:\u0020\u0025s", _bff)
		}
		if _afe, _cbg := _dad.(_b.EndElement); _cbg && _afe.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the AG_ShapeAttributes and its children
func (_fcgf *AG_ShapeAttributes) Validate() error {
	return _fcgf.ValidateWithPath("AG_ShapeAttributes")
}

// ValidateWithPath validates the Fill and its children, prefixing error messages with path
func (_ebead *Fill) ValidateWithPath(path string) error {
	if _gaff := _ebead.CT_Fill.ValidateWithPath(path); _gaff != nil {
		return _gaff
	}
	return nil
}
func (_acbgc *OfcTop) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:o"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:office:office"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:r"}, Value: "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:s"}, Value: "http:/\u002fschemas\u002eopenxmlformats\u002eorg/officeDocument\u002f2006\u002fsharedTypes"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:v"}, Value: "urn:schemas\u002dmicrosoft\u002dcom:vml"})
//	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xmlns:xxml"}, Value: "http:\u002f\u002fwww\u002ew3.org/XML\u002f1998/namespace"})
	start.Name.Local = "o:top"
	return _acbgc.OfcCT_StrokeChild.MarshalXML(e, start)
}
func (_ecg *AG_Type) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ecg.TypeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "type"}, Value: _f.Sprintf("\u0025v", *_ecg.TypeAttr)})
	}
	return nil
}
func (_ccdfb *OfcST_ScreenSize) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_feacb, _ffcac := d.Token()
	if _ffcac != nil {
		return _ffcac
	}
	if _badeb, _bcfb := _feacb.(_b.EndElement); _bcfb && _badeb.Name == start.Name {
		*_ccdfb = 1
		return nil
	}
	if _gfdaf, _bdeca := _feacb.(_b.CharData); !_bdeca {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _feacb)
	} else {
		switch string(_gfdaf) {
		case "":
			*_ccdfb = 0
		case "544\u002c376":
			*_ccdfb = 1
		case "640\u002c480":
			*_ccdfb = 2
		case "720\u002c512":
			*_ccdfb = 3
		case "800\u002c600":
			*_ccdfb = 4
		case "1024\u002c768":
			*_ccdfb = 5
		case "1152\u002c862":
			*_ccdfb = 6
		}
	}
	_feacb, _ffcac = d.Token()
	if _ffcac != nil {
		return _ffcac
	}
	if _edea, _acffef := _feacb.(_b.EndElement); _acffef && _edea.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _feacb)
}
func (_efgeeg *Imagedata) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_efgeeg.CT_ImageData = *NewCT_ImageData()
	for _, _bfgdc := range start.Attr {
		if _bfgdc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bfgdc.Name.Local == "pict" || _bfgdc.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bfgdc.Name.Local == "pict" {
			_bcdca, _bfbf := _bfgdc.Value, error(nil)
			if _bfbf != nil {
				return _bfbf
			}
			_efgeeg.PictAttr = &_bcdca
			continue
		}
		if _bfgdc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bfgdc.Name.Local == "href" || _bfgdc.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bfgdc.Name.Local == "href" {
			_bffeag, _fdadf := _bfgdc.Value, error(nil)
			if _fdadf != nil {
				return _fdadf
			}
			_efgeeg.RHrefAttr = &_bffeag
			continue
		}
		if _bfgdc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfgdc.Name.Local == "href" {
			_eefb, _begf := _bfgdc.Value, error(nil)
			if _begf != nil {
				return _begf
			}
			_efgeeg.HrefAttr = &_eefb
			continue
		}
		if _bfgdc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfgdc.Name.Local == "althref" {
			_cgedd, _gedfe := _bfgdc.Value, error(nil)
			if _gedfe != nil {
				return _gedfe
			}
			_efgeeg.AlthrefAttr = &_cgedd
			continue
		}
		if _bfgdc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfgdc.Name.Local == "title" {
			_fagdee, _gedg := _bfgdc.Value, error(nil)
			if _gedg != nil {
				return _gedg
			}
			_efgeeg.TitleAttr = &_fagdee
			continue
		}
		if _bfgdc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfgdc.Name.Local == "oleid" {
			_fgbcg, _gbaaeg := _e.ParseFloat(_bfgdc.Value, 64)
			if _gbaaeg != nil {
				return _gbaaeg
			}
			_gbbfc := float32(_fgbcg)
			_efgeeg.OleidAttr = &_gbbfc
			continue
		}
		if _bfgdc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfgdc.Name.Local == "detectmouseclick" {
			_efgeeg.DetectmouseclickAttr.UnmarshalXMLAttr(_bfgdc)
			continue
		}
		if _bfgdc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfgdc.Name.Local == "movie" {
			_dcaede, _gfged := _e.ParseFloat(_bfgdc.Value, 64)
			if _gfged != nil {
				return _gfged
			}
			_ggaea := float32(_dcaede)
			_efgeeg.MovieAttr = &_ggaea
			continue
		}
		if _bfgdc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _bfgdc.Name.Local == "relid" {
			_fafab, _cafdg := _bfgdc.Value, error(nil)
			if _cafdg != nil {
				return _cafdg
			}
			_efgeeg.RelidAttr = &_fafab
			continue
		}
		if _bfgdc.Name.Space == "http:\u002f/schemas\u002eopenxmlformats\u002eorg\u002fofficeDocument\u002f2006\u002frelationships" && _bfgdc.Name.Local == "id" || _bfgdc.Name.Space == "http:\u002f\u002fpurl.oclc\u002eorg\u002fooxml\u002fofficeDocument\u002frelationships" && _bfgdc.Name.Local == "id" {
			_ecdbb, _bfecf := _bfgdc.Value, error(nil)
			if _bfecf != nil {
				return _bfecf
			}
			_efgeeg.IdAttr = &_ecdbb
			continue
		}
		if _bfgdc.Name.Local == "id" {
			_adcfd, _eecf := _bfgdc.Value, error(nil)
			if _eecf != nil {
				return _eecf
			}
			_efgeeg.SIdAttr = &_adcfd
			continue
		}
		if _bfgdc.Name.Local == "cropbottom" {
			_bggb, _bcegd := _bfgdc.Value, error(nil)
			if _bcegd != nil {
				return _bcegd
			}
			_efgeeg.CropbottomAttr = &_bggb
			continue
		}
		if _bfgdc.Name.Local == "embosscolor" {
			_fcbfg, _egdc := _bfgdc.Value, error(nil)
			if _egdc != nil {
				return _egdc
			}
			_efgeeg.EmbosscolorAttr = &_fcbfg
			continue
		}
		if _bfgdc.Name.Local == "src" {
			_bbef, _ebcdc := _bfgdc.Value, error(nil)
			if _ebcdc != nil {
				return _ebcdc
			}
			_efgeeg.SrcAttr = &_bbef
			continue
		}
		if _bfgdc.Name.Local == "cropleft" {
			_gcag, _debfc := _bfgdc.Value, error(nil)
			if _debfc != nil {
				return _debfc
			}
			_efgeeg.CropleftAttr = &_gcag
			continue
		}
		if _bfgdc.Name.Local == "croptop" {
			_fdbga, _ffgba := _bfgdc.Value, error(nil)
			if _ffgba != nil {
				return _ffgba
			}
			_efgeeg.CroptopAttr = &_fdbga
			continue
		}
		if _bfgdc.Name.Local == "cropright" {
			_gabdb, _cgdab := _bfgdc.Value, error(nil)
			if _cgdab != nil {
				return _cgdab
			}
			_efgeeg.CroprightAttr = &_gabdb
			continue
		}
		if _bfgdc.Name.Local == "recolortarget" {
			_cgedf, _aegdb := _bfgdc.Value, error(nil)
			if _aegdb != nil {
				return _aegdb
			}
			_efgeeg.RecolortargetAttr = &_cgedf
			continue
		}
		if _bfgdc.Name.Local == "gain" {
			_bcaaa, _gfbdf := _bfgdc.Value, error(nil)
			if _gfbdf != nil {
				return _gfbdf
			}
			_efgeeg.GainAttr = &_bcaaa
			continue
		}
		if _bfgdc.Name.Local == "blacklevel" {
			_ggecce, _dcdec := _bfgdc.Value, error(nil)
			if _dcdec != nil {
				return _dcdec
			}
			_efgeeg.BlacklevelAttr = &_ggecce
			continue
		}
		if _bfgdc.Name.Local == "gamma" {
			_ecaac, _ddeg := _bfgdc.Value, error(nil)
			if _ddeg != nil {
				return _ddeg
			}
			_efgeeg.GammaAttr = &_ecaac
			continue
		}
		if _bfgdc.Name.Local == "grayscale" {
			_efgeeg.GrayscaleAttr.UnmarshalXMLAttr(_bfgdc)
			continue
		}
		if _bfgdc.Name.Local == "bilevel" {
			_efgeeg.BilevelAttr.UnmarshalXMLAttr(_bfgdc)
			continue
		}
		if _bfgdc.Name.Local == "chromakey" {
			_ccbbg, _agegg := _bfgdc.Value, error(nil)
			if _agegg != nil {
				return _agegg
			}
			_efgeeg.ChromakeyAttr = &_ccbbg
			continue
		}
	}
	for {
		_aebff, _bgac := d.Token()
		if _bgac != nil {
			return _f.Errorf("parsing\u0020Imagedata:\u0020\u0025s", _bgac)
		}
		if _bfadd, _feedf := _aebff.(_b.EndElement); _feedf && _bfadd.Name == start.Name {
			break
		}
	}
	return nil
}
func NewAG_AllCoreAttributes() *AG_AllCoreAttributes { _ag := &AG_AllCoreAttributes{}; return _ag }

type Fill struct{ CT_Fill }

// Validate validates the OfcCT_Proxy and its children
func (_gbfcc *OfcCT_Proxy) Validate() error { return _gbfcc.ValidateWithPath("OfcCT_Proxy") }
func (_eddca *CT_RoundRect) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _fcae := range start.Attr {
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "userdrawn" {
			_eddca.UserdrawnAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "bordertopcolor" {
			_agec, _befc := _fcae.Value, error(nil)
			if _befc != nil {
				return _befc
			}
			_eddca.BordertopcolorAttr = &_agec
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "userhidden" {
			_eddca.UserhiddenAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "bullet" {
			_eddca.BulletAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "cliptowrap" {
			_eddca.CliptowrapAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "hr" {
			_eddca.HrAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "ole" {
			_eddca.OleAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "hrstd" {
			_eddca.HrstdAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "spid" {
			_agccf, _daafe := _fcae.Value, error(nil)
			if _daafe != nil {
				return _daafe
			}
			_eddca.SpidAttr = &_agccf
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "hrnoshade" {
			_eddca.HrnoshadeAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "forcedash" {
			_eddca.ForcedashAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "borderleftcolor" {
			_gfabb, _efcga := _fcae.Value, error(nil)
			if _efcga != nil {
				return _efcga
			}
			_eddca.BorderleftcolorAttr = &_gfabb
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "dgmnodekind" {
			_fcged, _gbfde := _e.ParseInt(_fcae.Value, 10, 64)
			if _gbfde != nil {
				return _gbfde
			}
			_eddca.DgmnodekindAttr = &_fcged
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "oned" {
			_eddca.OnedAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "clip" {
			_eddca.ClipAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "hrpct" {
			_faeee, _acaagf := _e.ParseFloat(_fcae.Value, 64)
			if _acaagf != nil {
				return _acaagf
			}
			_fcgde := float32(_faeee)
			_eddca.HrpctAttr = &_fcgde
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "preferrelative" {
			_eddca.PreferrelativeAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "borderrightcolor" {
			_egedf, _dgee := _fcae.Value, error(nil)
			if _dgee != nil {
				return _dgee
			}
			_eddca.BorderrightcolorAttr = &_egedf
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "regroupid" {
			_abgc, _eggeg := _e.ParseInt(_fcae.Value, 10, 64)
			if _eggeg != nil {
				return _eggeg
			}
			_eddca.RegroupidAttr = &_abgc
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "dgmlayoutmru" {
			_eddca.DgmlayoutmruAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "doubleclicknotify" {
			_eddca.DoubleclicknotifyAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "allowoverlap" {
			_eddca.AllowoverlapAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "hralign" {
			_eddca.HralignAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "insetmode" {
			_eddca.InsetmodeAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "spt" {
			_fcfa, _fbddef := _e.ParseFloat(_fcae.Value, 64)
			if _fbddef != nil {
				return _fbddef
			}
			_cdgfc := float32(_fcfa)
			_eddca.SptAttr = &_cdgfc
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "borderbottomcolor" {
			_dabgac, _bbed := _fcae.Value, error(nil)
			if _bbed != nil {
				return _bbed
			}
			_eddca.BorderbottomcolorAttr = &_dabgac
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "oleicon" {
			_eddca.OleiconAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "dgmlayout" {
			_eddca.DgmlayoutAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "bwmode" {
			_eddca.BwmodeAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "bwnormal" {
			_eddca.BwnormalAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "bwpure" {
			_eddca.BwpureAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "connectortype" {
			_eddca.ConnectortypeAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "button" {
			_eddca.ButtonAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _fcae.Name.Local == "allowincell" {
			_eddca.AllowincellAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Local == "href" {
			_badc, _fcga := _fcae.Value, error(nil)
			if _fcga != nil {
				return _fcga
			}
			_eddca.HrefAttr = &_badc
			continue
		}
		if _fcae.Name.Local == "coordsize" {
			_gcgab, _afee := _fcae.Value, error(nil)
			if _afee != nil {
				return _afee
			}
			_eddca.CoordsizeAttr = &_gcgab
			continue
		}
		if _fcae.Name.Local == "style" {
			_agcf, _dggeg := _fcae.Value, error(nil)
			if _dggeg != nil {
				return _dggeg
			}
			_eddca.StyleAttr = &_agcf
			continue
		}
		if _fcae.Name.Local == "stroked" {
			_eddca.StrokedAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Local == "id" {
			_ceec, _aeab := _fcae.Value, error(nil)
			if _aeab != nil {
				return _aeab
			}
			_eddca.IdAttr = &_ceec
			continue
		}
		if _fcae.Name.Local == "strokeweight" {
			_eaabc, _fggb := _fcae.Value, error(nil)
			if _fggb != nil {
				return _fggb
			}
			_eddca.StrokeweightAttr = &_eaabc
			continue
		}
		if _fcae.Name.Local == "print" {
			_eddca.PrintAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Local == "chromakey" {
			_daaeb, _faedg := _fcae.Value, error(nil)
			if _faedg != nil {
				return _faedg
			}
			_eddca.ChromakeyAttr = &_daaeb
			continue
		}
		if _fcae.Name.Local == "fillcolor" {
			_dadc, _cgec := _fcae.Value, error(nil)
			if _cgec != nil {
				return _cgec
			}
			_eddca.FillcolorAttr = &_dadc
			continue
		}
		if _fcae.Name.Local == "coordorigin" {
			_bggf, _bebfa := _fcae.Value, error(nil)
			if _bebfa != nil {
				return _bebfa
			}
			_eddca.CoordoriginAttr = &_bggf
			continue
		}
		if _fcae.Name.Local == "opacity" {
			_cebee, _gdfb := _fcae.Value, error(nil)
			if _gdfb != nil {
				return _gdfb
			}
			_eddca.OpacityAttr = &_cebee
			continue
		}
		if _fcae.Name.Local == "strokecolor" {
			_fbgff, _abbf := _fcae.Value, error(nil)
			if _abbf != nil {
				return _abbf
			}
			_eddca.StrokecolorAttr = &_fbgff
			continue
		}
		if _fcae.Name.Local == "insetpen" {
			_eddca.InsetpenAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Local == "filled" {
			_eddca.FilledAttr.UnmarshalXMLAttr(_fcae)
			continue
		}
		if _fcae.Name.Local == "wrapcoords" {
			_aaeac, _ecdc := _fcae.Value, error(nil)
			if _ecdc != nil {
				return _ecdc
			}
			_eddca.WrapcoordsAttr = &_aaeac
			continue
		}
		if _fcae.Name.Local == "arcsize" {
			_ddgbb, _fdef := _fcae.Value, error(nil)
			if _fdef != nil {
				return _fdef
			}
			_eddca.ArcsizeAttr = &_ddgbb
			continue
		}
		if _fcae.Name.Local == "title" {
			_gcgda, _dcfbf := _fcae.Value, error(nil)
			if _dcfbf != nil {
				return _dcfbf
			}
			_eddca.TitleAttr = &_gcgda
			continue
		}
		if _fcae.Name.Local == "class" {
			_cbfdf, _bgfa := _fcae.Value, error(nil)
			if _bgfa != nil {
				return _bgfa
			}
			_eddca.ClassAttr = &_cbfdf
			continue
		}
		if _fcae.Name.Local == "target" {
			_gdceg, _dgagda := _fcae.Value, error(nil)
			if _dgagda != nil {
				return _dgagda
			}
			_eddca.TargetAttr = &_gdceg
			continue
		}
		if _fcae.Name.Local == "alt" {
			_cdaff, _gfdd := _fcae.Value, error(nil)
			if _gfdd != nil {
				return _gfdd
			}
			_eddca.AltAttr = &_cdaff
			continue
		}
	}
_gbgeb:
	for {
		_ccdb, _ffcd := d.Token()
		if _ffcd != nil {
			return _ffcd
		}
		switch _fefde := _ccdb.(type) {
		case _b.StartElement:
			switch _fefde.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_bdecg := NewEG_ShapeElements()
				_bdecg.Path = NewPath()
				if _fdecc := d.DecodeElement(_bdecg.Path, &_fefde); _fdecc != nil {
					return _fdecc
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _bdecg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_daef := NewEG_ShapeElements()
				_daef.Formulas = NewFormulas()
				if _cgca := d.DecodeElement(_daef.Formulas, &_fefde); _cgca != nil {
					return _cgca
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _daef)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_bagdf := NewEG_ShapeElements()
				_bagdf.Handles = NewHandles()
				if _edce := d.DecodeElement(_bagdf.Handles, &_fefde); _edce != nil {
					return _edce
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _bagdf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_acaf := NewEG_ShapeElements()
				_acaf.Fill = NewFill()
				if _gafbb := d.DecodeElement(_acaf.Fill, &_fefde); _gafbb != nil {
					return _gafbb
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _acaf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_fbbdd := NewEG_ShapeElements()
				_fbbdd.Stroke = NewStroke()
				if _ccbdf := d.DecodeElement(_fbbdd.Stroke, &_fefde); _ccbdf != nil {
					return _ccbdf
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _fbbdd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_bbgca := NewEG_ShapeElements()
				_bbgca.Shadow = NewShadow()
				if _aggd := d.DecodeElement(_bbgca.Shadow, &_fefde); _aggd != nil {
					return _aggd
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _bbgca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_gagca := NewEG_ShapeElements()
				_gagca.Textbox = NewTextbox()
				if _cbgb := d.DecodeElement(_gagca.Textbox, &_fefde); _cbgb != nil {
					return _cbgb
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _gagca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_dcfda := NewEG_ShapeElements()
				_dcfda.Textpath = NewTextpath()
				if _bbdg := d.DecodeElement(_dcfda.Textpath, &_fefde); _bbdg != nil {
					return _bbdg
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _dcfda)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_efdcg := NewEG_ShapeElements()
				_efdcg.Imagedata = NewImagedata()
				if _gbgab := d.DecodeElement(_efdcg.Imagedata, &_fefde); _gbgab != nil {
					return _gbgab
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _efdcg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_fccge := NewEG_ShapeElements()
				_fccge.Skew = NewOfcSkew()
				if _gabgc := d.DecodeElement(_fccge.Skew, &_fefde); _gabgc != nil {
					return _gabgc
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _fccge)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_acea := NewEG_ShapeElements()
				_acea.Extrusion = NewOfcExtrusion()
				if _ggag := d.DecodeElement(_acea.Extrusion, &_fefde); _ggag != nil {
					return _ggag
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _acea)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_afcb := NewEG_ShapeElements()
				_afcb.Callout = NewOfcCallout()
				if _face := d.DecodeElement(_afcb.Callout, &_fefde); _face != nil {
					return _face
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _afcb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_fffad := NewEG_ShapeElements()
				_fffad.Lock = NewOfcLock()
				if _egddb := d.DecodeElement(_fffad.Lock, &_fefde); _egddb != nil {
					return _egddb
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _fffad)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_caddf := NewEG_ShapeElements()
				_caddf.Clippath = NewOfcClippath()
				if _afaed := d.DecodeElement(_caddf.Clippath, &_fefde); _afaed != nil {
					return _afaed
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _caddf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_bdgca := NewEG_ShapeElements()
				_bdgca.Signatureline = NewOfcSignatureline()
				if _bbfe := d.DecodeElement(_bdgca.Signatureline, &_fefde); _bbfe != nil {
					return _bbfe
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _bdgca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_gcegdd := NewEG_ShapeElements()
				_gcegdd.Wrap = _a.NewWrap()
				if _dgff := d.DecodeElement(_gcegdd.Wrap, &_fefde); _dgff != nil {
					return _dgff
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _gcegdd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_geddb := NewEG_ShapeElements()
				_geddb.Anchorlock = _a.NewAnchorlock()
				if _cfcabe := d.DecodeElement(_geddb.Anchorlock, &_fefde); _cfcabe != nil {
					return _cfcabe
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _geddb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_cafd := NewEG_ShapeElements()
				_cafd.Bordertop = _a.NewBordertop()
				if _gddaa := d.DecodeElement(_cafd.Bordertop, &_fefde); _gddaa != nil {
					return _gddaa
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _cafd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_faccb := NewEG_ShapeElements()
				_faccb.Borderbottom = _a.NewBorderbottom()
				if _bfdd := d.DecodeElement(_faccb.Borderbottom, &_fefde); _bfdd != nil {
					return _bfdd
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _faccb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_bbgg := NewEG_ShapeElements()
				_bbgg.Borderleft = _a.NewBorderleft()
				if _feae := d.DecodeElement(_bbgg.Borderleft, &_fefde); _feae != nil {
					return _feae
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _bbgg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_cgbd := NewEG_ShapeElements()
				_cgbd.Borderright = _a.NewBorderright()
				if _abfb := d.DecodeElement(_cgbd.Borderright, &_fefde); _abfb != nil {
					return _abfb
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _cgbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_gefffd := NewEG_ShapeElements()
				_gefffd.ClientData = _c.NewClientData()
				if _egeg := d.DecodeElement(_gefffd.ClientData, &_fefde); _egeg != nil {
					return _egeg
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _gefffd)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_cfaeg := NewEG_ShapeElements()
				_cfaeg.Textdata = _bf.NewTextdata()
				if _dgab := d.DecodeElement(_cfaeg.Textdata, &_fefde); _dgab != nil {
					return _dgab
				}
				_eddca.EG_ShapeElements = append(_eddca.EG_ShapeElements, _cfaeg)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_RoundRect\u0020\u0025v", _fefde.Name)
				if _afbfa := d.Skip(); _afbfa != nil {
					return _afbfa
				}
			}
		case _b.EndElement:
			break _gbgeb
		case _b.CharData:
		}
	}
	return nil
}
func (_bcedf OfcST_CalloutPlacement) ValidateWithPath(path string) error {
	switch _bcedf {
	case 0, 1, 2, 3, 4:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_bcedf))
	}
	return nil
}
func (_adbbaf ST_Ext) String() string {
	switch _adbbaf {
	case 0:
		return ""
	case 1:
		return "view"
	case 2:
		return "edit"
	case 3:
		return "backwardCompatible"
	}
	return ""
}
func NewOfcCT_Diagram() *OfcCT_Diagram { _eebb := &OfcCT_Diagram{}; return _eebb }
func (_fageg *Fill) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _fageg.CT_Fill.MarshalXML(e, start)
}

type Group struct{ CT_Group }

func (_debfg OfcST_How) ValidateWithPath(path string) error {
	switch _debfg {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_debfg))
	}
	return nil
}

// ValidateWithPath validates the AG_Chromakey and its children, prefixing error messages with path
func (_bgc *AG_Chromakey) ValidateWithPath(path string) error { return nil }

// Validate validates the OfcCT_R and its children
func (_acfga *OfcCT_R) Validate() error { return _acfga.ValidateWithPath("OfcCT_R") }
func (_cddeff ST_StrokeLineStyle) String() string {
	switch _cddeff {
	case 0:
		return ""
	case 1:
		return "single"
	case 2:
		return "thinThin"
	case 3:
		return "thinThick"
	case 4:
		return "thickThin"
	case 5:
		return "thickBetweenThin"
	}
	return ""
}

// ValidateWithPath validates the OfcCT_ShapeDefaults and its children, prefixing error messages with path
func (_geafb *OfcCT_ShapeDefaults) ValidateWithPath(path string) error {
	if _efbg := _geafb.FillAttr.ValidateWithPath(path + "\u002fFillAttr"); _efbg != nil {
		return _efbg
	}
	if _abbggb := _geafb.StrokeAttr.ValidateWithPath(path + "/StrokeAttr"); _abbggb != nil {
		return _abbggb
	}
	if _gddge := _geafb.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _gddge != nil {
		return _gddge
	}
	if _geafb.Fill != nil {
		if _aeacc := _geafb.Fill.ValidateWithPath(path + "\u002fFill"); _aeacc != nil {
			return _aeacc
		}
	}
	if _geafb.Stroke != nil {
		if _dfab := _geafb.Stroke.ValidateWithPath(path + "\u002fStroke"); _dfab != nil {
			return _dfab
		}
	}
	if _geafb.Textbox != nil {
		if _gebgf := _geafb.Textbox.ValidateWithPath(path + "\u002fTextbox"); _gebgf != nil {
			return _gebgf
		}
	}
	if _geafb.Shadow != nil {
		if _fggafb := _geafb.Shadow.ValidateWithPath(path + "\u002fShadow"); _fggafb != nil {
			return _fggafb
		}
	}
	if _geafb.Skew != nil {
		if _agfdag := _geafb.Skew.ValidateWithPath(path + "\u002fSkew"); _agfdag != nil {
			return _agfdag
		}
	}
	if _geafb.Extrusion != nil {
		if _gbbcb := _geafb.Extrusion.ValidateWithPath(path + "\u002fExtrusion"); _gbbcb != nil {
			return _gbbcb
		}
	}
	if _geafb.Callout != nil {
		if _bgbea := _geafb.Callout.ValidateWithPath(path + "\u002fCallout"); _bgbea != nil {
			return _bgbea
		}
	}
	if _geafb.Lock != nil {
		if _afdf := _geafb.Lock.ValidateWithPath(path + "\u002fLock"); _afdf != nil {
			return _afdf
		}
	}
	if _geafb.Colormru != nil {
		if _gcbgc := _geafb.Colormru.ValidateWithPath(path + "\u002fColormru"); _gcbgc != nil {
			return _gcbgc
		}
	}
	if _geafb.Colormenu != nil {
		if _fbbaa := _geafb.Colormenu.ValidateWithPath(path + "\u002fColormenu"); _fbbaa != nil {
			return _fbbaa
		}
	}
	if _faeg := _geafb.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _faeg != nil {
		return _faeg
	}
	return nil
}

type AG_ShapeAttributes struct {
	OpacityAttr      *string
	StrokedAttr      _eb.ST_TrueFalse
	StrokecolorAttr  *string
	StrokeweightAttr *string
	InsetpenAttr     _eb.ST_TrueFalse
	ChromakeyAttr    *string
	FilledAttr       _eb.ST_TrueFalse
	FillcolorAttr    *string
}

func (_fgeab *EG_ShapeElements) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _fgeab.Path != nil {
		_acfeb := _b.StartElement{Name: _b.Name{Local: "v:path"}}
		e.EncodeElement(_fgeab.Path, _acfeb)
	}
	if _fgeab.Formulas != nil {
		_ddbcg := _b.StartElement{Name: _b.Name{Local: "v:formulas"}}
		e.EncodeElement(_fgeab.Formulas, _ddbcg)
	}
	if _fgeab.Handles != nil {
		_gcdfb := _b.StartElement{Name: _b.Name{Local: "v:handles"}}
		e.EncodeElement(_fgeab.Handles, _gcdfb)
	}
	if _fgeab.Fill != nil {
		_dccbg := _b.StartElement{Name: _b.Name{Local: "v:fill"}}
		e.EncodeElement(_fgeab.Fill, _dccbg)
	}
	if _fgeab.Stroke != nil {
		_dcdgd := _b.StartElement{Name: _b.Name{Local: "v:stroke"}}
		e.EncodeElement(_fgeab.Stroke, _dcdgd)
	}
	if _fgeab.Shadow != nil {
		_dfgb := _b.StartElement{Name: _b.Name{Local: "v:shadow"}}
		e.EncodeElement(_fgeab.Shadow, _dfgb)
	}
	if _fgeab.Textbox != nil {
		_eegcb := _b.StartElement{Name: _b.Name{Local: "v:textbox"}}
		e.EncodeElement(_fgeab.Textbox, _eegcb)
	}
	if _fgeab.Textpath != nil {
		_gagg := _b.StartElement{Name: _b.Name{Local: "v:textpath"}}
		e.EncodeElement(_fgeab.Textpath, _gagg)
	}
	if _fgeab.Imagedata != nil {
		_ffbb := _b.StartElement{Name: _b.Name{Local: "v:imagedata"}}
		e.EncodeElement(_fgeab.Imagedata, _ffbb)
	}
	if _fgeab.Skew != nil {
		_dgabb := _b.StartElement{Name: _b.Name{Local: "o:skew"}}
		e.EncodeElement(_fgeab.Skew, _dgabb)
	}
	if _fgeab.Extrusion != nil {
		_afga := _b.StartElement{Name: _b.Name{Local: "o:extrusion"}}
		e.EncodeElement(_fgeab.Extrusion, _afga)
	}
	if _fgeab.Callout != nil {
		_ageaec := _b.StartElement{Name: _b.Name{Local: "o:callout"}}
		e.EncodeElement(_fgeab.Callout, _ageaec)
	}
	if _fgeab.Lock != nil {
		_gdfcg := _b.StartElement{Name: _b.Name{Local: "o:lock"}}
		e.EncodeElement(_fgeab.Lock, _gdfcg)
	}
	if _fgeab.Clippath != nil {
		_bbdge := _b.StartElement{Name: _b.Name{Local: "o:clippath"}}
		e.EncodeElement(_fgeab.Clippath, _bbdge)
	}
	if _fgeab.Signatureline != nil {
		_fgdg := _b.StartElement{Name: _b.Name{Local: "o:signatureline"}}
		e.EncodeElement(_fgeab.Signatureline, _fgdg)
	}
	if _fgeab.Wrap != nil {
		_ecgae := _b.StartElement{Name: _b.Name{Local: "urn:wrap"}}
		e.EncodeElement(_fgeab.Wrap, _ecgae)
	}
	if _fgeab.Anchorlock != nil {
		_fedge := _b.StartElement{Name: _b.Name{Local: "urn:anchorlock"}}
		e.EncodeElement(_fgeab.Anchorlock, _fedge)
	}
	if _fgeab.Bordertop != nil {
		_aafcd := _b.StartElement{Name: _b.Name{Local: "urn:bordertop"}}
		e.EncodeElement(_fgeab.Bordertop, _aafcd)
	}
	if _fgeab.Borderbottom != nil {
		_dbbf := _b.StartElement{Name: _b.Name{Local: "urn:borderbottom"}}
		e.EncodeElement(_fgeab.Borderbottom, _dbbf)
	}
	if _fgeab.Borderleft != nil {
		_caege := _b.StartElement{Name: _b.Name{Local: "urn:borderleft"}}
		e.EncodeElement(_fgeab.Borderleft, _caege)
	}
	if _fgeab.Borderright != nil {
		_cffa := _b.StartElement{Name: _b.Name{Local: "urn:borderright"}}
		e.EncodeElement(_fgeab.Borderright, _cffa)
	}
	if _fgeab.ClientData != nil {
		_aceba := _b.StartElement{Name: _b.Name{Local: "x:ClientData"}}
		e.EncodeElement(_fgeab.ClientData, _aceba)
	}
	if _fgeab.Textdata != nil {
		_efee := _b.StartElement{Name: _b.Name{Local: "ur:textdata"}}
		e.EncodeElement(_fgeab.Textdata, _efee)
	}
	return nil
}
func (_eaadf OfcST_ExtrusionType) String() string {
	switch _eaadf {
	case 0:
		return ""
	case 1:
		return "perspective"
	case 2:
		return "parallel"
	}
	return ""
}

type OfcST_Angle byte

func (_eacfa *OfcBottom) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_eacfa.OfcCT_StrokeChild = *NewOfcCT_StrokeChild()
	for _, _dggae := range start.Attr {
		if _dggae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dggae.Name.Local == "href" {
			_fgeg, _dgcba := _dggae.Value, error(nil)
			if _dgcba != nil {
				return _dgcba
			}
			_eacfa.HrefAttr = &_fgeg
			continue
		}
		if _dggae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dggae.Name.Local == "forcedash" {
			_eacfa.ForcedashAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dggae.Name.Local == "title" {
			_beceb, _adaec := _dggae.Value, error(nil)
			if _adaec != nil {
				return _adaec
			}
			_eacfa.TitleAttr = &_beceb
			continue
		}
		if _dggae.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _dggae.Name.Local == "althref" {
			_ecbbb, _fbdgf := _dggae.Value, error(nil)
			if _fbdgf != nil {
				return _fbdgf
			}
			_eacfa.AlthrefAttr = &_ecbbb
			continue
		}
		if _dggae.Name.Local == "imageaspect" {
			_eacfa.ImageaspectAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "startarrow" {
			_eacfa.StartarrowAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "linestyle" {
			_eacfa.LinestyleAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "startarrowwidth" {
			_eacfa.StartarrowwidthAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "joinstyle" {
			_eacfa.JoinstyleAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "startarrowlength" {
			_eacfa.StartarrowlengthAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "dashstyle" {
			_ceefg, _bdeed := _dggae.Value, error(nil)
			if _bdeed != nil {
				return _bdeed
			}
			_eacfa.DashstyleAttr = &_ceefg
			continue
		}
		if _dggae.Name.Local == "endarrow" {
			_eacfa.EndarrowAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "filltype" {
			_eacfa.FilltypeAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "endarrowwidth" {
			_eacfa.EndarrowwidthAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "opacity" {
			_fddbf, _gbfcb := _dggae.Value, error(nil)
			if _gbfcb != nil {
				return _gbfcb
			}
			_eacfa.OpacityAttr = &_fddbf
			continue
		}
		if _dggae.Name.Local == "color" {
			_egaea, _aegac := _dggae.Value, error(nil)
			if _aegac != nil {
				return _aegac
			}
			_eacfa.ColorAttr = &_egaea
			continue
		}
		if _dggae.Name.Local == "insetpen" {
			_eacfa.InsetpenAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "endarrowlength" {
			_eacfa.EndarrowlengthAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "ext" {
			_eacfa.ExtAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "endcap" {
			_eacfa.EndcapAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "color2" {
			_adeba, _cabdd := _dggae.Value, error(nil)
			if _cabdd != nil {
				return _cabdd
			}
			_eacfa.Color2Attr = &_adeba
			continue
		}
		if _dggae.Name.Local == "imagealignshape" {
			_eacfa.ImagealignshapeAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
		if _dggae.Name.Local == "weight" {
			_gddcg, _bfcfg := _dggae.Value, error(nil)
			if _bfcfg != nil {
				return _bfcfg
			}
			_eacfa.WeightAttr = &_gddcg
			continue
		}
		if _dggae.Name.Local == "src" {
			_fabaa, _fgbce := _dggae.Value, error(nil)
			if _fgbce != nil {
				return _fgbce
			}
			_eacfa.SrcAttr = &_fabaa
			continue
		}
		if _dggae.Name.Local == "imagesize" {
			_gbagf, _bcee := _dggae.Value, error(nil)
			if _bcee != nil {
				return _bcee
			}
			_eacfa.ImagesizeAttr = &_gbagf
			continue
		}
		if _dggae.Name.Local == "miterlimit" {
			_agfecb, _bddgf := _e.ParseFloat(_dggae.Value, 64)
			if _bddgf != nil {
				return _bddgf
			}
			_eacfa.MiterlimitAttr = &_agfecb
			continue
		}
		if _dggae.Name.Local == "on" {
			_eacfa.OnAttr.UnmarshalXMLAttr(_dggae)
			continue
		}
	}
	for {
		_fddcaa, _cafge := d.Token()
		if _cafge != nil {
			return _f.Errorf("parsing\u0020OfcBottom:\u0020\u0025s", _cafge)
		}
		if _dafaf, _ebgac := _fddcaa.(_b.EndElement); _ebgac && _dafaf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fgdaa ST_StrokeArrowWidth) Validate() error { return _fgdaa.ValidateWithPath("") }
func (_agfbe *OfcST_ExtrusionRender) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_agfbe = 0
	case "solid":
		*_agfbe = 1
	case "wireFrame":
		*_agfbe = 2
	case "boundingCube":
		*_agfbe = 3
	}
	return nil
}

type OfcSignatureline struct{ OfcCT_SignatureLine }
type AG_Ext struct{ ExtAttr ST_Ext }

// ValidateWithPath validates the CT_Handles and its children, prefixing error messages with path
func (_fccg *CT_Handles) ValidateWithPath(path string) error {
	for _eeef, _ddef := range _fccg.H {
		if _cafbb := _ddef.ValidateWithPath(_f.Sprintf("\u0025s\u002fH\u005b\u0025d\u005d", path, _eeef)); _cafbb != nil {
			return _cafbb
		}
	}
	return nil
}
func (_eeffa *CT_Path) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _cbbag := range start.Attr {
		if _cbbag.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbbag.Name.Local == "connecttype" {
			_eeffa.ConnecttypeAttr.UnmarshalXMLAttr(_cbbag)
			continue
		}
		if _cbbag.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbbag.Name.Local == "extrusionok" {
			_eeffa.ExtrusionokAttr.UnmarshalXMLAttr(_cbbag)
			continue
		}
		if _cbbag.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbbag.Name.Local == "connectangles" {
			_dfcg, _bagga := _cbbag.Value, error(nil)
			if _bagga != nil {
				return _bagga
			}
			_eeffa.ConnectanglesAttr = &_dfcg
			continue
		}
		if _cbbag.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _cbbag.Name.Local == "connectlocs" {
			_gcgdc, _fabb := _cbbag.Value, error(nil)
			if _fabb != nil {
				return _fabb
			}
			_eeffa.ConnectlocsAttr = &_gcgdc
			continue
		}
		if _cbbag.Name.Local == "gradientshapeok" {
			_eeffa.GradientshapeokAttr.UnmarshalXMLAttr(_cbbag)
			continue
		}
		if _cbbag.Name.Local == "shadowok" {
			_eeffa.ShadowokAttr.UnmarshalXMLAttr(_cbbag)
			continue
		}
		if _cbbag.Name.Local == "arrowok" {
			_eeffa.ArrowokAttr.UnmarshalXMLAttr(_cbbag)
			continue
		}
		if _cbbag.Name.Local == "v" {
			_fddb, _bdad := _cbbag.Value, error(nil)
			if _bdad != nil {
				return _bdad
			}
			_eeffa.VAttr = &_fddb
			continue
		}
		if _cbbag.Name.Local == "textpathok" {
			_eeffa.TextpathokAttr.UnmarshalXMLAttr(_cbbag)
			continue
		}
		if _cbbag.Name.Local == "insetpenok" {
			_eeffa.InsetpenokAttr.UnmarshalXMLAttr(_cbbag)
			continue
		}
		if _cbbag.Name.Local == "strokeok" {
			_eeffa.StrokeokAttr.UnmarshalXMLAttr(_cbbag)
			continue
		}
		if _cbbag.Name.Local == "fillok" {
			_eeffa.FillokAttr.UnmarshalXMLAttr(_cbbag)
			continue
		}
		if _cbbag.Name.Local == "textboxrect" {
			_edgd, _acecf := _cbbag.Value, error(nil)
			if _acecf != nil {
				return _acecf
			}
			_eeffa.TextboxrectAttr = &_edgd
			continue
		}
		if _cbbag.Name.Local == "limo" {
			_gacgd, _dccb := _cbbag.Value, error(nil)
			if _dccb != nil {
				return _dccb
			}
			_eeffa.LimoAttr = &_gacgd
			continue
		}
		if _cbbag.Name.Local == "id" {
			_gdbg, _bbcec := _cbbag.Value, error(nil)
			if _bbcec != nil {
				return _bbcec
			}
			_eeffa.IdAttr = &_gdbg
			continue
		}
	}
	for {
		_ageb, _dcbbd := d.Token()
		if _dcbbd != nil {
			return _f.Errorf("parsing\u0020CT_Path:\u0020\u0025s", _dcbbd)
		}
		if _debca, _ebdfa := _ageb.(_b.EndElement); _ebdfa && _debca.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_Rect and its children
func (_dgagdb *CT_Rect) Validate() error { return _dgagdb.ValidateWithPath("CT_Rect") }

type OfcST_ScreenSize byte

func (_dgcecd OfcST_ColorMode) String() string {
	switch _dgcecd {
	case 0:
		return ""
	case 1:
		return "auto"
	case 2:
		return "custom"
	}
	return ""
}
func NewOfcLeft() *OfcLeft {
	_afbaf := &OfcLeft{}
	_afbaf.OfcCT_StrokeChild = *NewOfcCT_StrokeChild()
	return _afbaf
}
func NewStroke() *Stroke { _ebdfe := &Stroke{}; _ebdfe.CT_Stroke = *NewCT_Stroke(); return _ebdfe }

// ValidateWithPath validates the CT_Rect and its children, prefixing error messages with path
func (_dfdba *CT_Rect) ValidateWithPath(path string) error {
	for _aagf, _egdfc := range _dfdba.EG_ShapeElements {
		if _cacab := _egdfc.ValidateWithPath(_f.Sprintf("\u0025s\u002fEG_ShapeElements\u005b\u0025d\u005d", path, _aagf)); _cacab != nil {
			return _cacab
		}
	}
	if _dcca := _dfdba.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _dcca != nil {
		return _dcca
	}
	if _bebd := _dfdba.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _bebd != nil {
		return _bebd
	}
	if _gfda := _dfdba.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _gfda != nil {
		return _gfda
	}
	if _egbb := _dfdba.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _egbb != nil {
		return _egbb
	}
	if _acbbcc := _dfdba.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _acbbcc != nil {
		return _acbbcc
	}
	if _cdccg := _dfdba.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _cdccg != nil {
		return _cdccg
	}
	if _dbad := _dfdba.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _dbad != nil {
		return _dbad
	}
	if _bgefd := _dfdba.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _bgefd != nil {
		return _bgefd
	}
	if _ffbc := _dfdba.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _ffbc != nil {
		return _ffbc
	}
	if _baaf := _dfdba.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _baaf != nil {
		return _baaf
	}
	if _feffdg := _dfdba.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _feffdg != nil {
		return _feffdg
	}
	if _efec := _dfdba.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _efec != nil {
		return _efec
	}
	if _bfggef := _dfdba.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _bfggef != nil {
		return _bfggef
	}
	if _dagf := _dfdba.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _dagf != nil {
		return _dagf
	}
	if _aaffgc := _dfdba.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _aaffgc != nil {
		return _aaffgc
	}
	if _gcga := _dfdba.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _gcga != nil {
		return _gcga
	}
	if _ggcba := _dfdba.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _ggcba != nil {
		return _ggcba
	}
	if _fadcc := _dfdba.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _fadcc != nil {
		return _fadcc
	}
	if _cade := _dfdba.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _cade != nil {
		return _cade
	}
	if _edgcb := _dfdba.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _edgcb != nil {
		return _edgcb
	}
	if _baeeg := _dfdba.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _baeeg != nil {
		return _baeeg
	}
	if _fgddf := _dfdba.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _fgddf != nil {
		return _fgddf
	}
	if _aebg := _dfdba.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _aebg != nil {
		return _aebg
	}
	if _daeb := _dfdba.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _daeb != nil {
		return _daeb
	}
	if _bbcab := _dfdba.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _bbcab != nil {
		return _bbcab
	}
	if _bcdb := _dfdba.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _bcdb != nil {
		return _bcdb
	}
	if _gegb := _dfdba.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _gegb != nil {
		return _gegb
	}
	if _efbc := _dfdba.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _efbc != nil {
		return _efbc
	}
	if _gafcb := _dfdba.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _gafcb != nil {
		return _gafcb
	}
	return nil
}

// ValidateWithPath validates the OfcCT_Extrusion and its children, prefixing error messages with path
func (_gadfe *OfcCT_Extrusion) ValidateWithPath(path string) error {
	if _abdfb := _gadfe.OnAttr.ValidateWithPath(path + "\u002fOnAttr"); _abdfb != nil {
		return _abdfb
	}
	if _deegf := _gadfe.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _deegf != nil {
		return _deegf
	}
	if _cdfc := _gadfe.RenderAttr.ValidateWithPath(path + "/RenderAttr"); _cdfc != nil {
		return _cdfc
	}
	if _deggb := _gadfe.PlaneAttr.ValidateWithPath(path + "\u002fPlaneAttr"); _deggb != nil {
		return _deggb
	}
	if _fbadc := _gadfe.LockrotationcenterAttr.ValidateWithPath(path + "\u002fLockrotationcenterAttr"); _fbadc != nil {
		return _fbadc
	}
	if _ebab := _gadfe.AutorotationcenterAttr.ValidateWithPath(path + "\u002fAutorotationcenterAttr"); _ebab != nil {
		return _ebab
	}
	if _acdge := _gadfe.ColormodeAttr.ValidateWithPath(path + "\u002fColormodeAttr"); _acdge != nil {
		return _acdge
	}
	if _ccgd := _gadfe.MetalAttr.ValidateWithPath(path + "\u002fMetalAttr"); _ccgd != nil {
		return _ccgd
	}
	if _bbbb := _gadfe.LightfaceAttr.ValidateWithPath(path + "\u002fLightfaceAttr"); _bbbb != nil {
		return _bbbb
	}
	if _dcabff := _gadfe.LightharshAttr.ValidateWithPath(path + "\u002fLightharshAttr"); _dcabff != nil {
		return _dcabff
	}
	if _abgffg := _gadfe.Lightharsh2Attr.ValidateWithPath(path + "\u002fLightharsh2Attr"); _abgffg != nil {
		return _abgffg
	}
	if _ddddg := _gadfe.ExtAttr.ValidateWithPath(path + "\u002fExtAttr"); _ddddg != nil {
		return _ddddg
	}
	return nil
}

// ValidateWithPath validates the CT_Stroke and its children, prefixing error messages with path
func (_bbadf *CT_Stroke) ValidateWithPath(path string) error {
	if _bbadf.Left != nil {
		if _aeefc := _bbadf.Left.ValidateWithPath(path + "\u002fLeft"); _aeefc != nil {
			return _aeefc
		}
	}
	if _bbadf.Top != nil {
		if _bcebd := _bbadf.Top.ValidateWithPath(path + "\u002fTop"); _bcebd != nil {
			return _bcebd
		}
	}
	if _bbadf.Right != nil {
		if _cebeg := _bbadf.Right.ValidateWithPath(path + "\u002fRight"); _cebeg != nil {
			return _cebeg
		}
	}
	if _bbadf.Bottom != nil {
		if _fdded := _bbadf.Bottom.ValidateWithPath(path + "\u002fBottom"); _fdded != nil {
			return _fdded
		}
	}
	if _bbadf.Column != nil {
		if _ffddf := _bbadf.Column.ValidateWithPath(path + "\u002fColumn"); _ffddf != nil {
			return _ffddf
		}
	}
	if _bgcae := _bbadf.OnAttr.ValidateWithPath(path + "\u002fOnAttr"); _bgcae != nil {
		return _bgcae
	}
	if _dfdd := _bbadf.LinestyleAttr.ValidateWithPath(path + "\u002fLinestyleAttr"); _dfdd != nil {
		return _dfdd
	}
	if _fgged := _bbadf.JoinstyleAttr.ValidateWithPath(path + "\u002fJoinstyleAttr"); _fgged != nil {
		return _fgged
	}
	if _cgff := _bbadf.EndcapAttr.ValidateWithPath(path + "/EndcapAttr"); _cgff != nil {
		return _cgff
	}
	if _afaee := _bbadf.FilltypeAttr.ValidateWithPath(path + "\u002fFilltypeAttr"); _afaee != nil {
		return _afaee
	}
	if _becb := _bbadf.ImageaspectAttr.ValidateWithPath(path + "\u002fImageaspectAttr"); _becb != nil {
		return _becb
	}
	if _daeca := _bbadf.ImagealignshapeAttr.ValidateWithPath(path + "/ImagealignshapeAttr"); _daeca != nil {
		return _daeca
	}
	if _adecb := _bbadf.StartarrowAttr.ValidateWithPath(path + "\u002fStartarrowAttr"); _adecb != nil {
		return _adecb
	}
	if _aabca := _bbadf.StartarrowwidthAttr.ValidateWithPath(path + "/StartarrowwidthAttr"); _aabca != nil {
		return _aabca
	}
	if _gggfc := _bbadf.StartarrowlengthAttr.ValidateWithPath(path + "/StartarrowlengthAttr"); _gggfc != nil {
		return _gggfc
	}
	if _bagee := _bbadf.EndarrowAttr.ValidateWithPath(path + "\u002fEndarrowAttr"); _bagee != nil {
		return _bagee
	}
	if _eecd := _bbadf.EndarrowwidthAttr.ValidateWithPath(path + "\u002fEndarrowwidthAttr"); _eecd != nil {
		return _eecd
	}
	if _gfgca := _bbadf.EndarrowlengthAttr.ValidateWithPath(path + "\u002fEndarrowlengthAttr"); _gfgca != nil {
		return _gfgca
	}
	if _egfeea := _bbadf.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _egfeea != nil {
		return _egfeea
	}
	if _fged := _bbadf.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _fged != nil {
		return _fged
	}
	return nil
}

// Validate validates the OfcCT_Ink and its children
func (_edda *OfcCT_Ink) Validate() error { return _edda.ValidateWithPath("OfcCT_Ink") }

// Validate validates the OfcCT_IdMap and its children
func (_dfdbae *OfcCT_IdMap) Validate() error   { return _dfdbae.ValidateWithPath("OfcCT_IdMap") }
func NewOfcCT_StrokeChild() *OfcCT_StrokeChild { _bgfc := &OfcCT_StrokeChild{}; return _bgfc }

type OfcColumn struct{ OfcCT_StrokeChild }

func (_egfcb OfcST_ColorMode) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_egfcb.String(), start)
}
func (_agfd *AG_CoreAttributes) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _dab := range start.Attr {
		if _dab.Name.Local == "href" {
			_aff, _aggb := _dab.Value, error(nil)
			if _aggb != nil {
				return _aggb
			}
			_agfd.HrefAttr = &_aff
			continue
		}
		if _dab.Name.Local == "target" {
			_dba, _gfeb := _dab.Value, error(nil)
			if _gfeb != nil {
				return _gfeb
			}
			_agfd.TargetAttr = &_dba
			continue
		}
		if _dab.Name.Local == "class" {
			_cef, _gee := _dab.Value, error(nil)
			if _gee != nil {
				return _gee
			}
			_agfd.ClassAttr = &_cef
			continue
		}
		if _dab.Name.Local == "title" {
			_dcf, _acdf := _dab.Value, error(nil)
			if _acdf != nil {
				return _acdf
			}
			_agfd.TitleAttr = &_dcf
			continue
		}
		if _dab.Name.Local == "alt" {
			_bab, _gdb := _dab.Value, error(nil)
			if _gdb != nil {
				return _gdb
			}
			_agfd.AltAttr = &_bab
			continue
		}
		if _dab.Name.Local == "coordsize" {
			_gab, _cde := _dab.Value, error(nil)
			if _cde != nil {
				return _cde
			}
			_agfd.CoordsizeAttr = &_gab
			continue
		}
		if _dab.Name.Local == "coordorigin" {
			_cdgd, _eaa := _dab.Value, error(nil)
			if _eaa != nil {
				return _eaa
			}
			_agfd.CoordoriginAttr = &_cdgd
			continue
		}
		if _dab.Name.Local == "wrapcoords" {
			_fbed, _afd := _dab.Value, error(nil)
			if _afd != nil {
				return _afd
			}
			_agfd.WrapcoordsAttr = &_fbed
			continue
		}
		if _dab.Name.Local == "print" {
			_agfd.PrintAttr.UnmarshalXMLAttr(_dab)
			continue
		}
		if _dab.Name.Local == "id" {
			_ebag, _feb := _dab.Value, error(nil)
			if _feb != nil {
				return _feb
			}
			_agfd.IdAttr = &_ebag
			continue
		}
		if _dab.Name.Local == "style" {
			_dggea, _dgc := _dab.Value, error(nil)
			if _dgc != nil {
				return _dgc
			}
			_agfd.StyleAttr = &_dggea
			continue
		}
	}
	for {
		_ffab, _agfe := d.Token()
		if _agfe != nil {
			return _f.Errorf("parsing\u0020AG_CoreAttributes: \u0025s", _agfe)
		}
		if _ege, _aae := _ffab.(_b.EndElement); _aae && _ege.Name == start.Name {
			break
		}
	}
	return nil
}
func (_eabdc ST_StrokeEndCap) String() string {
	switch _eabdc {
	case 0:
		return ""
	case 1:
		return "flat"
	case 2:
		return "square"
	case 3:
		return "round"
	}
	return ""
}

type OfcCT_Complex struct{ ExtAttr ST_Ext }

func (_fccf OfcST_ConnectorType) MarshalXMLAttr(name _b.Name) (_b.Attr, error) {
	_dacgg := _b.Attr{}
	_dacgg.Name = name
	switch _fccf {
	case OfcST_ConnectorTypeUnset:
		_dacgg.Value = ""
	case OfcST_ConnectorTypeNone:
		_dacgg.Value = "none"
	case OfcST_ConnectorTypeStraight:
		_dacgg.Value = "straight"
	case OfcST_ConnectorTypeElbow:
		_dacgg.Value = "elbow"
	case OfcST_ConnectorTypeCurved:
		_dacgg.Value = "curved"
	}
	return _dacgg, nil
}
func (_eeddd OfcST_ScreenSize) String() string {
	switch _eeddd {
	case 0:
		return ""
	case 1:
		return "544\u002c376"
	case 2:
		return "640\u002c480"
	case 3:
		return "720\u002c512"
	case 4:
		return "800\u002c600"
	case 5:
		return "1024\u002c768"
	case 6:
		return "1152\u002c862"
	}
	return ""
}
func (_bcaag OfcST_OLEUpdateMode) Validate() error { return _bcaag.ValidateWithPath("") }
func (_ffaa *AG_CoreAttributes) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ffaa.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_ffaa.HrefAttr)})
	}
	if _ffaa.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_ffaa.TargetAttr)})
	}
	if _ffaa.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_ffaa.ClassAttr)})
	}
	if _ffaa.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_ffaa.TitleAttr)})
	}
	if _ffaa.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_ffaa.AltAttr)})
	}
	if _ffaa.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_ffaa.CoordsizeAttr)})
	}
	if _ffaa.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_ffaa.CoordoriginAttr)})
	}
	if _ffaa.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_ffaa.WrapcoordsAttr)})
	}
	if _ffaa.PrintAttr != _eb.ST_TrueFalseUnset {
		_abaa, _gfe := _ffaa.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _gfe != nil {
			return _gfe
		}
		start.Attr = append(start.Attr, _abaa)
	}
	if _ffaa.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_ffaa.IdAttr)})
	}
	if _ffaa.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_ffaa.StyleAttr)})
	}
	return nil
}
func (_eafdb *OfcCT_ShapeDefaults) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _eafdb.SpidmaxAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "spidmax"}, Value: _f.Sprintf("\u0025v", *_eafdb.SpidmaxAttr)})
	}
	if _eafdb.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_eafdb.StyleAttr)})
	}
	if _eafdb.FillAttr != _eb.ST_TrueFalseUnset {
		_dfacd, _dgddf := _eafdb.FillAttr.MarshalXMLAttr(_b.Name{Local: "fill"})
		if _dgddf != nil {
			return _dgddf
		}
		start.Attr = append(start.Attr, _dfacd)
	}
	if _eafdb.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_eafdb.FillcolorAttr)})
	}
	if _eafdb.StrokeAttr != _eb.ST_TrueFalseUnset {
		_fcaac, _ffadd := _eafdb.StrokeAttr.MarshalXMLAttr(_b.Name{Local: "stroke"})
		if _ffadd != nil {
			return _ffadd
		}
		start.Attr = append(start.Attr, _fcaac)
	}
	if _eafdb.StrokecolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "strokecolor"}, Value: _f.Sprintf("\u0025v", *_eafdb.StrokecolorAttr)})
	}
	if _eafdb.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_daba, _ffggc := _eafdb.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "allowincell"})
		if _ffggc != nil {
			return _ffggc
		}
		start.Attr = append(start.Attr, _daba)
	}
	if _eafdb.ExtAttr != ST_ExtUnset {
		_cagcb, _ggcga := _eafdb.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _ggcga != nil {
			return _ggcga
		}
		start.Attr = append(start.Attr, _cagcb)
	}
	e.EncodeToken(start)
	if _eafdb.Fill != nil {
		_eeaea := _b.StartElement{Name: _b.Name{Local: "v:fill"}}
		e.EncodeElement(_eafdb.Fill, _eeaea)
	}
	if _eafdb.Stroke != nil {
		_fbegg := _b.StartElement{Name: _b.Name{Local: "v:stroke"}}
		e.EncodeElement(_eafdb.Stroke, _fbegg)
	}
	if _eafdb.Textbox != nil {
		_gead := _b.StartElement{Name: _b.Name{Local: "v:textbox"}}
		e.EncodeElement(_eafdb.Textbox, _gead)
	}
	if _eafdb.Shadow != nil {
		_gcddc := _b.StartElement{Name: _b.Name{Local: "v:shadow"}}
		e.EncodeElement(_eafdb.Shadow, _gcddc)
	}
	if _eafdb.Skew != nil {
		_gfbb := _b.StartElement{Name: _b.Name{Local: "o:skew"}}
		e.EncodeElement(_eafdb.Skew, _gfbb)
	}
	if _eafdb.Extrusion != nil {
		_afccg := _b.StartElement{Name: _b.Name{Local: "o:extrusion"}}
		e.EncodeElement(_eafdb.Extrusion, _afccg)
	}
	if _eafdb.Callout != nil {
		_aegcd := _b.StartElement{Name: _b.Name{Local: "o:callout"}}
		e.EncodeElement(_eafdb.Callout, _aegcd)
	}
	if _eafdb.Lock != nil {
		_gccgf := _b.StartElement{Name: _b.Name{Local: "o:lock"}}
		e.EncodeElement(_eafdb.Lock, _gccgf)
	}
	if _eafdb.Colormru != nil {
		_dfad := _b.StartElement{Name: _b.Name{Local: "o:colormru"}}
		e.EncodeElement(_eafdb.Colormru, _dfad)
	}
	if _eafdb.Colormenu != nil {
		_efcbf := _b.StartElement{Name: _b.Name{Local: "o:colormenu"}}
		e.EncodeElement(_eafdb.Colormenu, _efcbf)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the OfcCT_OLEObject and its children, prefixing error messages with path
func (_fgbdgg *OfcCT_OLEObject) ValidateWithPath(path string) error {
	if _abcgd := _fgbdgg.TypeAttr.ValidateWithPath(path + "\u002fTypeAttr"); _abcgd != nil {
		return _abcgd
	}
	if _edfdf := _fgbdgg.DrawAspectAttr.ValidateWithPath(path + "\u002fDrawAspectAttr"); _edfdf != nil {
		return _edfdf
	}
	if _gcgb := _fgbdgg.UpdateModeAttr.ValidateWithPath(path + "\u002fUpdateModeAttr"); _gcgb != nil {
		return _gcgb
	}
	if _aeece := _fgbdgg.LockedField.ValidateWithPath(path + "\u002fLockedField"); _aeece != nil {
		return _aeece
	}
	return nil
}

// Validate validates the AG_AllCoreAttributes and its children
func (_baa *AG_AllCoreAttributes) Validate() error {
	return _baa.ValidateWithPath("AG_AllCoreAttributes")
}

// ValidateWithPath validates the Shapetype and its children, prefixing error messages with path
func (_feaabb *Shapetype) ValidateWithPath(path string) error {
	if _fdefd := _feaabb.CT_Shapetype.ValidateWithPath(path); _fdefd != nil {
		return _fdefd
	}
	return nil
}
func NewBackground() *Background {
	_cdag := &Background{}
	_cdag.CT_Background = *NewCT_Background()
	return _cdag
}

// ValidateWithPath validates the AG_OfficeShapeAttributes and its children, prefixing error messages with path
func (_gdee *AG_OfficeShapeAttributes) ValidateWithPath(path string) error {
	if _ecf := _gdee.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _ecf != nil {
		return _ecf
	}
	if _gcde := _gdee.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _gcde != nil {
		return _gcde
	}
	if _faf := _gdee.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _faf != nil {
		return _faf
	}
	if _afg := _gdee.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _afg != nil {
		return _afg
	}
	if _caeg := _gdee.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _caeg != nil {
		return _caeg
	}
	if _begd := _gdee.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _begd != nil {
		return _begd
	}
	if _adb := _gdee.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _adb != nil {
		return _adb
	}
	if _acf := _gdee.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _acf != nil {
		return _acf
	}
	if _dbg := _gdee.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _dbg != nil {
		return _dbg
	}
	if _cgae := _gdee.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _cgae != nil {
		return _cgae
	}
	return nil
}
func (_cefd *CT_Group) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _cefd.EditasAttr != ST_EditAsUnset {
		_abbg, _fdcf := _cefd.EditasAttr.MarshalXMLAttr(_b.Name{Local: "editas"})
		if _fdcf != nil {
			return _fdcf
		}
		start.Attr = append(start.Attr, _abbg)
	}
	if _cefd.TablepropertiesAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:tableproperties"}, Value: _f.Sprintf("\u0025v", *_cefd.TablepropertiesAttr)})
	}
	if _cefd.TablelimitsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:tablelimits"}, Value: _f.Sprintf("\u0025v", *_cefd.TablelimitsAttr)})
	}
	if _cefd.HrefAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "href"}, Value: _f.Sprintf("\u0025v", *_cefd.HrefAttr)})
	}
	if _cefd.TargetAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "target"}, Value: _f.Sprintf("\u0025v", *_cefd.TargetAttr)})
	}
	if _cefd.ClassAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "class"}, Value: _f.Sprintf("\u0025v", *_cefd.ClassAttr)})
	}
	if _cefd.TitleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "title"}, Value: _f.Sprintf("\u0025v", *_cefd.TitleAttr)})
	}
	if _cefd.AltAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "alt"}, Value: _f.Sprintf("\u0025v", *_cefd.AltAttr)})
	}
	if _cefd.CoordsizeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordsize"}, Value: _f.Sprintf("\u0025v", *_cefd.CoordsizeAttr)})
	}
	if _cefd.CoordoriginAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "coordorigin"}, Value: _f.Sprintf("\u0025v", *_cefd.CoordoriginAttr)})
	}
	if _cefd.WrapcoordsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "wrapcoords"}, Value: _f.Sprintf("\u0025v", *_cefd.WrapcoordsAttr)})
	}
	if _cefd.PrintAttr != _eb.ST_TrueFalseUnset {
		_bfac, _agfb := _cefd.PrintAttr.MarshalXMLAttr(_b.Name{Local: "print"})
		if _agfb != nil {
			return _agfb
		}
		start.Attr = append(start.Attr, _bfac)
	}
	if _cefd.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_cefd.IdAttr)})
	}
	if _cefd.StyleAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "style"}, Value: _f.Sprintf("\u0025v", *_cefd.StyleAttr)})
	}
	if _cefd.SpidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:spid"}, Value: _f.Sprintf("\u0025v", *_cefd.SpidAttr)})
	}
	if _cefd.OnedAttr != _eb.ST_TrueFalseUnset {
		_befe, _ggcd := _cefd.OnedAttr.MarshalXMLAttr(_b.Name{Local: "o:oned"})
		if _ggcd != nil {
			return _ggcd
		}
		start.Attr = append(start.Attr, _befe)
	}
	if _cefd.RegroupidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:regroupid"}, Value: _f.Sprintf("\u0025v", *_cefd.RegroupidAttr)})
	}
	if _cefd.DoubleclicknotifyAttr != _eb.ST_TrueFalseUnset {
		_dced, _cacca := _cefd.DoubleclicknotifyAttr.MarshalXMLAttr(_b.Name{Local: "o:doubleclicknotify"})
		if _cacca != nil {
			return _cacca
		}
		start.Attr = append(start.Attr, _dced)
	}
	if _cefd.ButtonAttr != _eb.ST_TrueFalseUnset {
		_dece, _acbe := _cefd.ButtonAttr.MarshalXMLAttr(_b.Name{Local: "o:button"})
		if _acbe != nil {
			return _acbe
		}
		start.Attr = append(start.Attr, _dece)
	}
	if _cefd.UserhiddenAttr != _eb.ST_TrueFalseUnset {
		_cfef, _ddde := _cefd.UserhiddenAttr.MarshalXMLAttr(_b.Name{Local: "o:userhidden"})
		if _ddde != nil {
			return _ddde
		}
		start.Attr = append(start.Attr, _cfef)
	}
	if _cefd.BulletAttr != _eb.ST_TrueFalseUnset {
		_efebg, _cgdd := _cefd.BulletAttr.MarshalXMLAttr(_b.Name{Local: "o:bullet"})
		if _cgdd != nil {
			return _cgdd
		}
		start.Attr = append(start.Attr, _efebg)
	}
	if _cefd.HrAttr != _eb.ST_TrueFalseUnset {
		_adfa, _ecaee := _cefd.HrAttr.MarshalXMLAttr(_b.Name{Local: "o:hr"})
		if _ecaee != nil {
			return _ecaee
		}
		start.Attr = append(start.Attr, _adfa)
	}
	if _cefd.HrstdAttr != _eb.ST_TrueFalseUnset {
		_fedfa, _adbd := _cefd.HrstdAttr.MarshalXMLAttr(_b.Name{Local: "o:hrstd"})
		if _adbd != nil {
			return _adbd
		}
		start.Attr = append(start.Attr, _fedfa)
	}
	if _cefd.HrnoshadeAttr != _eb.ST_TrueFalseUnset {
		_bdab, _gdad := _cefd.HrnoshadeAttr.MarshalXMLAttr(_b.Name{Local: "o:hrnoshade"})
		if _gdad != nil {
			return _gdad
		}
		start.Attr = append(start.Attr, _bdab)
	}
	if _cefd.HrpctAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:hrpct"}, Value: _f.Sprintf("\u0025v", *_cefd.HrpctAttr)})
	}
	if _cefd.HralignAttr != OfcST_HrAlignUnset {
		_dded, _aaed := _cefd.HralignAttr.MarshalXMLAttr(_b.Name{Local: "o:hralign"})
		if _aaed != nil {
			return _aaed
		}
		start.Attr = append(start.Attr, _dded)
	}
	if _cefd.AllowincellAttr != _eb.ST_TrueFalseUnset {
		_cdbbc, _acfc := _cefd.AllowincellAttr.MarshalXMLAttr(_b.Name{Local: "o:allowincell"})
		if _acfc != nil {
			return _acfc
		}
		start.Attr = append(start.Attr, _cdbbc)
	}
	if _cefd.AllowoverlapAttr != _eb.ST_TrueFalseUnset {
		_cgb, _aebf := _cefd.AllowoverlapAttr.MarshalXMLAttr(_b.Name{Local: "o:allowoverlap"})
		if _aebf != nil {
			return _aebf
		}
		start.Attr = append(start.Attr, _cgb)
	}
	if _cefd.UserdrawnAttr != _eb.ST_TrueFalseUnset {
		_ccbb, _bbdd := _cefd.UserdrawnAttr.MarshalXMLAttr(_b.Name{Local: "o:userdrawn"})
		if _bbdd != nil {
			return _bbdd
		}
		start.Attr = append(start.Attr, _ccbb)
	}
	if _cefd.BordertopcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:bordertopcolor"}, Value: _f.Sprintf("\u0025v", *_cefd.BordertopcolorAttr)})
	}
	if _cefd.BorderleftcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderleftcolor"}, Value: _f.Sprintf("\u0025v", *_cefd.BorderleftcolorAttr)})
	}
	if _cefd.BorderbottomcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderbottomcolor"}, Value: _f.Sprintf("\u0025v", *_cefd.BorderbottomcolorAttr)})
	}
	if _cefd.BorderrightcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:borderrightcolor"}, Value: _f.Sprintf("\u0025v", *_cefd.BorderrightcolorAttr)})
	}
	if _cefd.DgmlayoutAttr != OfcST_DiagramLayoutUnset {
		_bbadg, _abag := _cefd.DgmlayoutAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayout"})
		if _abag != nil {
			return _abag
		}
		start.Attr = append(start.Attr, _bbadg)
	}
	if _cefd.DgmnodekindAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "o:dgmnodekind"}, Value: _f.Sprintf("\u0025v", *_cefd.DgmnodekindAttr)})
	}
	if _cefd.DgmlayoutmruAttr != OfcST_DiagramLayoutUnset {
		_cebc, _dagg := _cefd.DgmlayoutmruAttr.MarshalXMLAttr(_b.Name{Local: "o:dgmlayoutmru"})
		if _dagg != nil {
			return _dagg
		}
		start.Attr = append(start.Attr, _cebc)
	}
	if _cefd.InsetmodeAttr != OfcST_InsetModeUnset {
		_bcaf, _gafef := _cefd.InsetmodeAttr.MarshalXMLAttr(_b.Name{Local: "o:insetmode"})
		if _gafef != nil {
			return _gafef
		}
		start.Attr = append(start.Attr, _bcaf)
	}
	if _cefd.FilledAttr != _eb.ST_TrueFalseUnset {
		_bcc, _bgfg := _cefd.FilledAttr.MarshalXMLAttr(_b.Name{Local: "filled"})
		if _bgfg != nil {
			return _bgfg
		}
		start.Attr = append(start.Attr, _bcc)
	}
	if _cefd.FillcolorAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "fillcolor"}, Value: _f.Sprintf("\u0025v", *_cefd.FillcolorAttr)})
	}
	e.EncodeToken(start)
	if _cefd.Group != nil {
		_fage := _b.StartElement{Name: _b.Name{Local: "v:group"}}
		for _, _cgbb := range _cefd.Group {
			e.EncodeElement(_cgbb, _fage)
		}
	}
	if _cefd.Shape != nil {
		_gebed := _b.StartElement{Name: _b.Name{Local: "v:shape"}}
		for _, _bbbe := range _cefd.Shape {
			e.EncodeElement(_bbbe, _gebed)
		}
	}
	if _cefd.Shapetype != nil {
		_edgc := _b.StartElement{Name: _b.Name{Local: "v:shapetype"}}
		for _, _fafa := range _cefd.Shapetype {
			e.EncodeElement(_fafa, _edgc)
		}
	}
	if _cefd.Arc != nil {
		_baeg := _b.StartElement{Name: _b.Name{Local: "v:arc"}}
		for _, _abae := range _cefd.Arc {
			e.EncodeElement(_abae, _baeg)
		}
	}
	if _cefd.Curve != nil {
		_gfbg := _b.StartElement{Name: _b.Name{Local: "v:curve"}}
		for _, _aedfa := range _cefd.Curve {
			e.EncodeElement(_aedfa, _gfbg)
		}
	}
	if _cefd.Image != nil {
		_efgg := _b.StartElement{Name: _b.Name{Local: "v:image"}}
		for _, _egdf := range _cefd.Image {
			e.EncodeElement(_egdf, _efgg)
		}
	}
	if _cefd.Line != nil {
		_gcae := _b.StartElement{Name: _b.Name{Local: "v:line"}}
		for _, _ecfa := range _cefd.Line {
			e.EncodeElement(_ecfa, _gcae)
		}
	}
	if _cefd.Oval != nil {
		_ecffd := _b.StartElement{Name: _b.Name{Local: "v:oval"}}
		for _, _bge := range _cefd.Oval {
			e.EncodeElement(_bge, _ecffd)
		}
	}
	if _cefd.Polyline != nil {
		_dfde := _b.StartElement{Name: _b.Name{Local: "v:polyline"}}
		for _, _cbbe := range _cefd.Polyline {
			e.EncodeElement(_cbbe, _dfde)
		}
	}
	if _cefd.Rect != nil {
		_fgfc := _b.StartElement{Name: _b.Name{Local: "v:rect"}}
		for _, _cfca := range _cefd.Rect {
			e.EncodeElement(_cfca, _fgfc)
		}
	}
	if _cefd.Roundrect != nil {
		_ddec := _b.StartElement{Name: _b.Name{Local: "v:roundrect"}}
		for _, _bfgg := range _cefd.Roundrect {
			e.EncodeElement(_bfgg, _ddec)
		}
	}
	if _cefd.Diagram != nil {
		_aabed := _b.StartElement{Name: _b.Name{Local: "o:diagram"}}
		for _, _ddcg := range _cefd.Diagram {
			e.EncodeElement(_ddcg, _aabed)
		}
	}
	if _cefd.EG_ShapeElements != nil {
		for _, _fec := range _cefd.EG_ShapeElements {
			_fec.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_cffe *CT_Group) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _effc := range start.Attr {
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "allowincell" {
			_cffe.AllowincellAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "bullet" {
			_cffe.BulletAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "hr" {
			_cffe.HrAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "oned" {
			_cffe.OnedAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "hralign" {
			_cffe.HralignAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "tablelimits" {
			_gaab, _dcba := _effc.Value, error(nil)
			if _dcba != nil {
				return _dcba
			}
			_cffe.TablelimitsAttr = &_gaab
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "regroupid" {
			_eefe, _edde := _e.ParseInt(_effc.Value, 10, 64)
			if _edde != nil {
				return _edde
			}
			_cffe.RegroupidAttr = &_eefe
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "bordertopcolor" {
			_deea, _feggg := _effc.Value, error(nil)
			if _feggg != nil {
				return _feggg
			}
			_cffe.BordertopcolorAttr = &_deea
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "spid" {
			_faea, _cadg := _effc.Value, error(nil)
			if _cadg != nil {
				return _cadg
			}
			_cffe.SpidAttr = &_faea
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "hrpct" {
			_geeg, _fbab := _e.ParseFloat(_effc.Value, 64)
			if _fbab != nil {
				return _fbab
			}
			_cbeb := float32(_geeg)
			_cffe.HrpctAttr = &_cbeb
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "borderrightcolor" {
			_ecbga, _fgaf := _effc.Value, error(nil)
			if _fgaf != nil {
				return _fgaf
			}
			_cffe.BorderrightcolorAttr = &_ecbga
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "button" {
			_cffe.ButtonAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "hrstd" {
			_cffe.HrstdAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "dgmlayout" {
			_cffe.DgmlayoutAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "userdrawn" {
			_cffe.UserdrawnAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "doubleclicknotify" {
			_cffe.DoubleclicknotifyAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "userhidden" {
			_cffe.UserhiddenAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "borderleftcolor" {
			_ebcg, _fead := _effc.Value, error(nil)
			if _fead != nil {
				return _fead
			}
			_cffe.BorderleftcolorAttr = &_ebcg
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "insetmode" {
			_cffe.InsetmodeAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "allowoverlap" {
			_cffe.AllowoverlapAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "tableproperties" {
			_ffcb, _ggfe := _effc.Value, error(nil)
			if _ggfe != nil {
				return _ggfe
			}
			_cffe.TablepropertiesAttr = &_ffcb
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "hrnoshade" {
			_cffe.HrnoshadeAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "dgmlayoutmru" {
			_cffe.DgmlayoutmruAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "dgmnodekind" {
			_bfae, _cfbc := _e.ParseInt(_effc.Value, 10, 64)
			if _cfbc != nil {
				return _cfbc
			}
			_cffe.DgmnodekindAttr = &_bfae
			continue
		}
		if _effc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _effc.Name.Local == "borderbottomcolor" {
			_cdgbb, _ceba := _effc.Value, error(nil)
			if _ceba != nil {
				return _ceba
			}
			_cffe.BorderbottomcolorAttr = &_cdgbb
			continue
		}
		if _effc.Name.Local == "print" {
			_cffe.PrintAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Local == "title" {
			_fgfba, _cggf := _effc.Value, error(nil)
			if _cggf != nil {
				return _cggf
			}
			_cffe.TitleAttr = &_fgfba
			continue
		}
		if _effc.Name.Local == "coordorigin" {
			_cefee, _dceea := _effc.Value, error(nil)
			if _dceea != nil {
				return _dceea
			}
			_cffe.CoordoriginAttr = &_cefee
			continue
		}
		if _effc.Name.Local == "wrapcoords" {
			_bdbb, _cbbf := _effc.Value, error(nil)
			if _cbbf != nil {
				return _cbbf
			}
			_cffe.WrapcoordsAttr = &_bdbb
			continue
		}
		if _effc.Name.Local == "coordsize" {
			_dafc, _cdaa := _effc.Value, error(nil)
			if _cdaa != nil {
				return _cdaa
			}
			_cffe.CoordsizeAttr = &_dafc
			continue
		}
		if _effc.Name.Local == "style" {
			_edcc, _fegga := _effc.Value, error(nil)
			if _fegga != nil {
				return _fegga
			}
			_cffe.StyleAttr = &_edcc
			continue
		}
		if _effc.Name.Local == "id" {
			_geec, _bdfd := _effc.Value, error(nil)
			if _bdfd != nil {
				return _bdfd
			}
			_cffe.IdAttr = &_geec
			continue
		}
		if _effc.Name.Local == "fillcolor" {
			_bfdaf, _aedfb := _effc.Value, error(nil)
			if _aedfb != nil {
				return _aedfb
			}
			_cffe.FillcolorAttr = &_bfdaf
			continue
		}
		if _effc.Name.Local == "class" {
			_ccgg, _dcdc := _effc.Value, error(nil)
			if _dcdc != nil {
				return _dcdc
			}
			_cffe.ClassAttr = &_ccgg
			continue
		}
		if _effc.Name.Local == "target" {
			_abcdd, _aecee := _effc.Value, error(nil)
			if _aecee != nil {
				return _aecee
			}
			_cffe.TargetAttr = &_abcdd
			continue
		}
		if _effc.Name.Local == "href" {
			_bfdc, _baegb := _effc.Value, error(nil)
			if _baegb != nil {
				return _baegb
			}
			_cffe.HrefAttr = &_bfdc
			continue
		}
		if _effc.Name.Local == "editas" {
			_cffe.EditasAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Local == "filled" {
			_cffe.FilledAttr.UnmarshalXMLAttr(_effc)
			continue
		}
		if _effc.Name.Local == "alt" {
			_egbcg, _ecbe := _effc.Value, error(nil)
			if _ecbe != nil {
				return _ecbe
			}
			_cffe.AltAttr = &_egbcg
			continue
		}
	}
_fdde:
	for {
		_accb, _gefb := d.Token()
		if _gefb != nil {
			return _gefb
		}
		switch _bddfe := _accb.(type) {
		case _b.StartElement:
			switch _bddfe.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "group"}:
				_fdbe := NewGroup()
				if _gfd := d.DecodeElement(_fdbe, &_bddfe); _gfd != nil {
					return _gfd
				}
				_cffe.Group = append(_cffe.Group, _fdbe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shape"}:
				_bdac := NewShape()
				if _cfea := d.DecodeElement(_bdac, &_bddfe); _cfea != nil {
					return _cfea
				}
				_cffe.Shape = append(_cffe.Shape, _bdac)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shapetype"}:
				_gdfg := NewShapetype()
				if _dcedg := d.DecodeElement(_gdfg, &_bddfe); _dcedg != nil {
					return _dcedg
				}
				_cffe.Shapetype = append(_cffe.Shapetype, _gdfg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "arc"}:
				_gdadf := NewArc()
				if _dagd := d.DecodeElement(_gdadf, &_bddfe); _dagd != nil {
					return _dagd
				}
				_cffe.Arc = append(_cffe.Arc, _gdadf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "curve"}:
				_agef := NewCurve()
				if _dbdbe := d.DecodeElement(_agef, &_bddfe); _dbdbe != nil {
					return _dbdbe
				}
				_cffe.Curve = append(_cffe.Curve, _agef)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "image"}:
				_ddaga := NewImage()
				if _accc := d.DecodeElement(_ddaga, &_bddfe); _accc != nil {
					return _accc
				}
				_cffe.Image = append(_cffe.Image, _ddaga)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "line"}:
				_eedf := NewLine()
				if _bbge := d.DecodeElement(_eedf, &_bddfe); _bbge != nil {
					return _bbge
				}
				_cffe.Line = append(_cffe.Line, _eedf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "oval"}:
				_fbca := NewOval()
				if _bfea := d.DecodeElement(_fbca, &_bddfe); _bfea != nil {
					return _bfea
				}
				_cffe.Oval = append(_cffe.Oval, _fbca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "polyline"}:
				_ebagf := NewPolyline()
				if _egdge := d.DecodeElement(_ebagf, &_bddfe); _egdge != nil {
					return _egdge
				}
				_cffe.Polyline = append(_cffe.Polyline, _ebagf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "rect"}:
				_eacf := NewRect()
				if _aaaf := d.DecodeElement(_eacf, &_bddfe); _aaaf != nil {
					return _aaaf
				}
				_cffe.Rect = append(_cffe.Rect, _eacf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "roundrect"}:
				_cacg := NewRoundrect()
				if _gacfg := d.DecodeElement(_cacg, &_bddfe); _gacfg != nil {
					return _gacfg
				}
				_cffe.Roundrect = append(_cffe.Roundrect, _cacg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "diagram"}:
				_ffeaf := NewOfcDiagram()
				if _aaee := d.DecodeElement(_ffeaf, &_bddfe); _aaee != nil {
					return _aaee
				}
				_cffe.Diagram = append(_cffe.Diagram, _ffeaf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_feag := NewEG_ShapeElements()
				_feag.Path = NewPath()
				if _gebef := d.DecodeElement(_feag.Path, &_bddfe); _gebef != nil {
					return _gebef
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _feag)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_eggcd := NewEG_ShapeElements()
				_eggcd.Formulas = NewFormulas()
				if _cegd := d.DecodeElement(_eggcd.Formulas, &_bddfe); _cegd != nil {
					return _cegd
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _eggcd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_dccdg := NewEG_ShapeElements()
				_dccdg.Handles = NewHandles()
				if _caac := d.DecodeElement(_dccdg.Handles, &_bddfe); _caac != nil {
					return _caac
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _dccdg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_gdegb := NewEG_ShapeElements()
				_gdegb.Fill = NewFill()
				if _gedd := d.DecodeElement(_gdegb.Fill, &_bddfe); _gedd != nil {
					return _gedd
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _gdegb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_acbcb := NewEG_ShapeElements()
				_acbcb.Stroke = NewStroke()
				if _adbgd := d.DecodeElement(_acbcb.Stroke, &_bddfe); _adbgd != nil {
					return _adbgd
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _acbcb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_ggee := NewEG_ShapeElements()
				_ggee.Shadow = NewShadow()
				if _ggbc := d.DecodeElement(_ggee.Shadow, &_bddfe); _ggbc != nil {
					return _ggbc
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _ggee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_effca := NewEG_ShapeElements()
				_effca.Textbox = NewTextbox()
				if _ecaf := d.DecodeElement(_effca.Textbox, &_bddfe); _ecaf != nil {
					return _ecaf
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _effca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_fcbe := NewEG_ShapeElements()
				_fcbe.Textpath = NewTextpath()
				if _ffeab := d.DecodeElement(_fcbe.Textpath, &_bddfe); _ffeab != nil {
					return _ffeab
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _fcbe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_cbgae := NewEG_ShapeElements()
				_cbgae.Imagedata = NewImagedata()
				if _dccdgg := d.DecodeElement(_cbgae.Imagedata, &_bddfe); _dccdgg != nil {
					return _dccdgg
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _cbgae)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_dbdc := NewEG_ShapeElements()
				_dbdc.Skew = NewOfcSkew()
				if _fadfc := d.DecodeElement(_dbdc.Skew, &_bddfe); _fadfc != nil {
					return _fadfc
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _dbdc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_ccef := NewEG_ShapeElements()
				_ccef.Extrusion = NewOfcExtrusion()
				if _gabd := d.DecodeElement(_ccef.Extrusion, &_bddfe); _gabd != nil {
					return _gabd
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _ccef)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_gfcc := NewEG_ShapeElements()
				_gfcc.Callout = NewOfcCallout()
				if _cecb := d.DecodeElement(_gfcc.Callout, &_bddfe); _cecb != nil {
					return _cecb
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _gfcc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_ddded := NewEG_ShapeElements()
				_ddded.Lock = NewOfcLock()
				if _gbea := d.DecodeElement(_ddded.Lock, &_bddfe); _gbea != nil {
					return _gbea
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _ddded)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_eced := NewEG_ShapeElements()
				_eced.Clippath = NewOfcClippath()
				if _bbbf := d.DecodeElement(_eced.Clippath, &_bddfe); _bbbf != nil {
					return _bbbf
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _eced)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_dccdeg := NewEG_ShapeElements()
				_dccdeg.Signatureline = NewOfcSignatureline()
				if _dcac := d.DecodeElement(_dccdeg.Signatureline, &_bddfe); _dcac != nil {
					return _dcac
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _dccdeg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_gcdeb := NewEG_ShapeElements()
				_gcdeb.Wrap = _a.NewWrap()
				if _cfgdd := d.DecodeElement(_gcdeb.Wrap, &_bddfe); _cfgdd != nil {
					return _cfgdd
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _gcdeb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_fdbdf := NewEG_ShapeElements()
				_fdbdf.Anchorlock = _a.NewAnchorlock()
				if _deeb := d.DecodeElement(_fdbdf.Anchorlock, &_bddfe); _deeb != nil {
					return _deeb
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _fdbdf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_gedb := NewEG_ShapeElements()
				_gedb.Bordertop = _a.NewBordertop()
				if _gfcde := d.DecodeElement(_gedb.Bordertop, &_bddfe); _gfcde != nil {
					return _gfcde
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _gedb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_feaf := NewEG_ShapeElements()
				_feaf.Borderbottom = _a.NewBorderbottom()
				if _cfaf := d.DecodeElement(_feaf.Borderbottom, &_bddfe); _cfaf != nil {
					return _cfaf
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _feaf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_ecggf := NewEG_ShapeElements()
				_ecggf.Borderleft = _a.NewBorderleft()
				if _ggca := d.DecodeElement(_ecggf.Borderleft, &_bddfe); _ggca != nil {
					return _ggca
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _ecggf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_eaab := NewEG_ShapeElements()
				_eaab.Borderright = _a.NewBorderright()
				if _dfbb := d.DecodeElement(_eaab.Borderright, &_bddfe); _dfbb != nil {
					return _dfbb
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _eaab)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_ecbf := NewEG_ShapeElements()
				_ecbf.ClientData = _c.NewClientData()
				if _bdfbe := d.DecodeElement(_ecbf.ClientData, &_bddfe); _bdfbe != nil {
					return _bdfbe
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _ecbf)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_bfacb := NewEG_ShapeElements()
				_bfacb.Textdata = _bf.NewTextdata()
				if _bgbd := d.DecodeElement(_bfacb.Textdata, &_bddfe); _bgbd != nil {
					return _bgbd
				}
				_cffe.EG_ShapeElements = append(_cffe.EG_ShapeElements, _bfacb)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Group\u0020\u0025v", _bddfe.Name)
				if _bgaf := d.Skip(); _bgaf != nil {
					return _bgaf
				}
			}
		case _b.EndElement:
			break _fdde
		case _b.CharData:
		}
	}
	return nil
}
func (_geadf ST_Ext) ValidateWithPath(path string) error {
	switch _geadf {
	case 0, 1, 2, 3:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_geadf))
	}
	return nil
}
func (_fgafd *OfcCT_Fill) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _fgafd.TypeAttr != OfcST_FillTypeUnset {
		_fgdeb, _aaacg := _fgafd.TypeAttr.MarshalXMLAttr(_b.Name{Local: "type"})
		if _aaacg != nil {
			return _aaacg
		}
		start.Attr = append(start.Attr, _fgdeb)
	}
	if _fgafd.ExtAttr != ST_ExtUnset {
		_agafa, _daeeg := _fgafd.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _daeeg != nil {
			return _daeeg
		}
		start.Attr = append(start.Attr, _agafa)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type AG_OfficeCoreAttributes struct {
	SpidAttr              *string
	OnedAttr              _eb.ST_TrueFalse
	RegroupidAttr         *int64
	DoubleclicknotifyAttr _eb.ST_TrueFalse
	ButtonAttr            _eb.ST_TrueFalse
	UserhiddenAttr        _eb.ST_TrueFalse
	BulletAttr            _eb.ST_TrueFalse
	HrAttr                _eb.ST_TrueFalse
	HrstdAttr             _eb.ST_TrueFalse
	HrnoshadeAttr         _eb.ST_TrueFalse
	HrpctAttr             *float32
	HralignAttr           OfcST_HrAlign
	AllowincellAttr       _eb.ST_TrueFalse
	AllowoverlapAttr      _eb.ST_TrueFalse
	UserdrawnAttr         _eb.ST_TrueFalse
	BordertopcolorAttr    *string
	BorderleftcolorAttr   *string
	BorderbottomcolorAttr *string
	BorderrightcolorAttr  *string
	DgmlayoutAttr         OfcST_DiagramLayout
	DgmnodekindAttr       *int64
	DgmlayoutmruAttr      OfcST_DiagramLayout
	InsetmodeAttr         OfcST_InsetMode
}

func (_abfdb *Shape) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_abfdb.CT_Shape = *NewCT_Shape()
	for _, _affcb := range start.Attr {
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "regroupid" {
			_edcaed, _gbcdc := _e.ParseInt(_affcb.Value, 10, 64)
			if _gbcdc != nil {
				return _gbcdc
			}
			_abfdb.RegroupidAttr = &_edcaed
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "doubleclicknotify" {
			_abfdb.DoubleclicknotifyAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "clip" {
			_abfdb.ClipAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "button" {
			_abfdb.ButtonAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "userhidden" {
			_abfdb.UserhiddenAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "bullet" {
			_abfdb.BulletAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "gfxdata" {
			_baggbc, _cgegbb := _affcb.Value, error(nil)
			if _cgegbb != nil {
				return _cgegbb
			}
			_abfdb.GfxdataAttr = &_baggbc
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "hr" {
			_abfdb.HrAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "ole" {
			_abfdb.OleAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "allowincell" {
			_abfdb.AllowincellAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "borderleftcolor" {
			_dabdge, _ceceae := _affcb.Value, error(nil)
			if _ceceae != nil {
				return _ceceae
			}
			_abfdb.BorderleftcolorAttr = &_dabdge
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "hrpct" {
			_fdbad, _aefce := _e.ParseFloat(_affcb.Value, 64)
			if _aefce != nil {
				return _aefce
			}
			_eeebef := float32(_fdbad)
			_abfdb.HrpctAttr = &_eeebef
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "dgmnodekind" {
			_cagaa, _gbeee := _e.ParseInt(_affcb.Value, 10, 64)
			if _gbeee != nil {
				return _gbeee
			}
			_abfdb.DgmnodekindAttr = &_cagaa
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "insetmode" {
			_abfdb.InsetmodeAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "userdrawn" {
			_abfdb.UserdrawnAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "connectortype" {
			_abfdb.ConnectortypeAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "borderrightcolor" {
			_gccgd, _dcadc := _affcb.Value, error(nil)
			if _dcadc != nil {
				return _dcadc
			}
			_abfdb.BorderrightcolorAttr = &_gccgd
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "preferrelative" {
			_abfdb.PreferrelativeAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "hrnoshade" {
			_abfdb.HrnoshadeAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "dgmlayoutmru" {
			_abfdb.DgmlayoutmruAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "oned" {
			_abfdb.OnedAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "hralign" {
			_abfdb.HralignAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "bwmode" {
			_abfdb.BwmodeAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "allowoverlap" {
			_abfdb.AllowoverlapAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "bordertopcolor" {
			_cabgg, _gfffde := _affcb.Value, error(nil)
			if _gfffde != nil {
				return _gfffde
			}
			_abfdb.BordertopcolorAttr = &_cabgg
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "bwnormal" {
			_abfdb.BwnormalAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "borderbottomcolor" {
			_dafdcc, _fbabfe := _affcb.Value, error(nil)
			if _fbabfe != nil {
				return _fbabfe
			}
			_abfdb.BorderbottomcolorAttr = &_dafdcc
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "cliptowrap" {
			_abfdb.CliptowrapAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "dgmlayout" {
			_abfdb.DgmlayoutAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "spt" {
			_addee, _edccbd := _e.ParseFloat(_affcb.Value, 64)
			if _edccbd != nil {
				return _edccbd
			}
			_efbcbe := float32(_addee)
			_abfdb.SptAttr = &_efbcbe
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "oleicon" {
			_abfdb.OleiconAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "forcedash" {
			_abfdb.ForcedashAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "bwpure" {
			_abfdb.BwpureAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "spid" {
			_babdee, _afdcg := _affcb.Value, error(nil)
			if _afdcg != nil {
				return _afdcg
			}
			_abfdb.SpidAttr = &_babdee
			continue
		}
		if _affcb.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _affcb.Name.Local == "hrstd" {
			_abfdb.HrstdAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Local == "target" {
			_ccbgf, _gbefb := _affcb.Value, error(nil)
			if _gbefb != nil {
				return _gbefb
			}
			_abfdb.TargetAttr = &_ccbgf
			continue
		}
		if _affcb.Name.Local == "wrapcoords" {
			_gdecf, _fafdfe := _affcb.Value, error(nil)
			if _fafdfe != nil {
				return _fafdfe
			}
			_abfdb.WrapcoordsAttr = &_gdecf
			continue
		}
		if _affcb.Name.Local == "opacity" {
			_dafdcg, _edbdd := _affcb.Value, error(nil)
			if _edbdd != nil {
				return _edbdd
			}
			_abfdb.OpacityAttr = &_dafdcg
			continue
		}
		if _affcb.Name.Local == "coordorigin" {
			_edgaf, _gacfgc := _affcb.Value, error(nil)
			if _gacfgc != nil {
				return _gacfgc
			}
			_abfdb.CoordoriginAttr = &_edgaf
			continue
		}
		if _affcb.Name.Local == "strokecolor" {
			_afac, _bdddd := _affcb.Value, error(nil)
			if _bdddd != nil {
				return _bdddd
			}
			_abfdb.StrokecolorAttr = &_afac
			continue
		}
		if _affcb.Name.Local == "coordsize" {
			_bcabc, _ffegf := _affcb.Value, error(nil)
			if _ffegf != nil {
				return _ffegf
			}
			_abfdb.CoordsizeAttr = &_bcabc
			continue
		}
		if _affcb.Name.Local == "insetpen" {
			_abfdb.InsetpenAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Local == "alt" {
			_dcccg, _ddecab := _affcb.Value, error(nil)
			if _ddecab != nil {
				return _ddecab
			}
			_abfdb.AltAttr = &_dcccg
			continue
		}
		if _affcb.Name.Local == "filled" {
			_abfdb.FilledAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Local == "title" {
			_fbaac, _bbbcg := _affcb.Value, error(nil)
			if _bbbcg != nil {
				return _bbbcg
			}
			_abfdb.TitleAttr = &_fbaac
			continue
		}
		if _affcb.Name.Local == "style" {
			_baebb, _fbagaf := _affcb.Value, error(nil)
			if _fbagaf != nil {
				return _fbagaf
			}
			_abfdb.StyleAttr = &_baebb
			continue
		}
		if _affcb.Name.Local == "print" {
			_abfdb.PrintAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Local == "stroked" {
			_abfdb.StrokedAttr.UnmarshalXMLAttr(_affcb)
			continue
		}
		if _affcb.Name.Local == "strokeweight" {
			_efbgd, _deaca := _affcb.Value, error(nil)
			if _deaca != nil {
				return _deaca
			}
			_abfdb.StrokeweightAttr = &_efbgd
			continue
		}
		if _affcb.Name.Local == "chromakey" {
			_aaedd, _fbce := _affcb.Value, error(nil)
			if _fbce != nil {
				return _fbce
			}
			_abfdb.ChromakeyAttr = &_aaedd
			continue
		}
		if _affcb.Name.Local == "path" {
			_abbcg, _bbadd := _affcb.Value, error(nil)
			if _bbadd != nil {
				return _bbadd
			}
			_abfdb.PathAttr = &_abbcg
			continue
		}
		if _affcb.Name.Local == "id" {
			_fdcac, _ffggd := _affcb.Value, error(nil)
			if _ffggd != nil {
				return _ffggd
			}
			_abfdb.IdAttr = &_fdcac
			continue
		}
		if _affcb.Name.Local == "class" {
			_dffbg, _ggggc := _affcb.Value, error(nil)
			if _ggggc != nil {
				return _ggggc
			}
			_abfdb.ClassAttr = &_dffbg
			continue
		}
		if _affcb.Name.Local == "href" {
			_cadgd, _dcebc := _affcb.Value, error(nil)
			if _dcebc != nil {
				return _dcebc
			}
			_abfdb.HrefAttr = &_cadgd
			continue
		}
		if _affcb.Name.Local == "equationxml" {
			_eaafc, _ecgddd := _affcb.Value, error(nil)
			if _ecgddd != nil {
				return _ecgddd
			}
			_abfdb.EquationxmlAttr = &_eaafc
			continue
		}
		if _affcb.Name.Local == "type" {
			_fdgcf, _bgffcf := _affcb.Value, error(nil)
			if _bgffcf != nil {
				return _bgffcf
			}
			_abfdb.TypeAttr = &_fdgcf
			continue
		}
		if _affcb.Name.Local == "adj" {
			_febdga, _fadab := _affcb.Value, error(nil)
			if _fadab != nil {
				return _fadab
			}
			_abfdb.AdjAttr = &_febdga
			continue
		}
		if _affcb.Name.Local == "fillcolor" {
			_agebe, _fafde := _affcb.Value, error(nil)
			if _fafde != nil {
				return _fafde
			}
			_abfdb.FillcolorAttr = &_agebe
			continue
		}
	}
_afcff:
	for {
		_cgecd, _efcgbc := d.Token()
		if _efcgbc != nil {
			return _efcgbc
		}
		switch _ebaggf := _cgecd.(type) {
		case _b.StartElement:
			switch _ebaggf.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "ink"}:
				_cffed := NewOfcInk()
				if _ecefa := d.DecodeElement(_cffed, &_ebaggf); _ecefa != nil {
					return _ecefa
				}
				_abfdb.Ink = append(_abfdb.Ink, _cffed)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "iscomment"}:
				_ggfg := _bf.NewIscomment()
				if _faeae := d.DecodeElement(_ggfg, &_ebaggf); _faeae != nil {
					return _faeae
				}
				_abfdb.Iscomment = append(_abfdb.Iscomment, _ggfg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "equationxml"}:
				_cefaa := NewOfcEquationxml()
				if _ecgea := d.DecodeElement(_cefaa, &_ebaggf); _ecgea != nil {
					return _ecgea
				}
				_abfdb.Equationxml = append(_abfdb.Equationxml, _cefaa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_cdgebf := NewEG_ShapeElements()
				_cdgebf.Path = NewPath()
				if _efae := d.DecodeElement(_cdgebf.Path, &_ebaggf); _efae != nil {
					return _efae
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _cdgebf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_gfeda := NewEG_ShapeElements()
				_gfeda.Formulas = NewFormulas()
				if _cgbg := d.DecodeElement(_gfeda.Formulas, &_ebaggf); _cgbg != nil {
					return _cgbg
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _gfeda)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_daddb := NewEG_ShapeElements()
				_daddb.Handles = NewHandles()
				if _cfdg := d.DecodeElement(_daddb.Handles, &_ebaggf); _cfdg != nil {
					return _cfdg
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _daddb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_feafa := NewEG_ShapeElements()
				_feafa.Fill = NewFill()
				if _gffbd := d.DecodeElement(_feafa.Fill, &_ebaggf); _gffbd != nil {
					return _gffbd
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _feafa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_dbaae := NewEG_ShapeElements()
				_dbaae.Stroke = NewStroke()
				if _gadbf := d.DecodeElement(_dbaae.Stroke, &_ebaggf); _gadbf != nil {
					return _gadbf
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _dbaae)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_ecgafd := NewEG_ShapeElements()
				_ecgafd.Shadow = NewShadow()
				if _dceda := d.DecodeElement(_ecgafd.Shadow, &_ebaggf); _dceda != nil {
					return _dceda
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _ecgafd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_gdafb := NewEG_ShapeElements()
				_gdafb.Textbox = NewTextbox()
				if _dfabc := d.DecodeElement(_gdafb.Textbox, &_ebaggf); _dfabc != nil {
					return _dfabc
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _gdafb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_daac := NewEG_ShapeElements()
				_daac.Textpath = NewTextpath()
				if _dbgab := d.DecodeElement(_daac.Textpath, &_ebaggf); _dbgab != nil {
					return _dbgab
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _daac)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_eebca := NewEG_ShapeElements()
				_eebca.Imagedata = NewImagedata()
				if _fggfb := d.DecodeElement(_eebca.Imagedata, &_ebaggf); _fggfb != nil {
					return _fggfb
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _eebca)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_baae := NewEG_ShapeElements()
				_baae.Skew = NewOfcSkew()
				if _ecbccf := d.DecodeElement(_baae.Skew, &_ebaggf); _ecbccf != nil {
					return _ecbccf
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _baae)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_fdccc := NewEG_ShapeElements()
				_fdccc.Extrusion = NewOfcExtrusion()
				if _gdbcb := d.DecodeElement(_fdccc.Extrusion, &_ebaggf); _gdbcb != nil {
					return _gdbcb
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _fdccc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_dfeb := NewEG_ShapeElements()
				_dfeb.Callout = NewOfcCallout()
				if _deabdb := d.DecodeElement(_dfeb.Callout, &_ebaggf); _deabdb != nil {
					return _deabdb
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _dfeb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_aeaef := NewEG_ShapeElements()
				_aeaef.Lock = NewOfcLock()
				if _cacffgc := d.DecodeElement(_aeaef.Lock, &_ebaggf); _cacffgc != nil {
					return _cacffgc
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _aeaef)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_fffba := NewEG_ShapeElements()
				_fffba.Clippath = NewOfcClippath()
				if _cgfbde := d.DecodeElement(_fffba.Clippath, &_ebaggf); _cgfbde != nil {
					return _cgfbde
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _fffba)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_fdead := NewEG_ShapeElements()
				_fdead.Signatureline = NewOfcSignatureline()
				if _ccead := d.DecodeElement(_fdead.Signatureline, &_ebaggf); _ccead != nil {
					return _ccead
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _fdead)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_fagee := NewEG_ShapeElements()
				_fagee.Wrap = _a.NewWrap()
				if _beebeb := d.DecodeElement(_fagee.Wrap, &_ebaggf); _beebeb != nil {
					return _beebeb
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _fagee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_bgddf := NewEG_ShapeElements()
				_bgddf.Anchorlock = _a.NewAnchorlock()
				if _gggcb := d.DecodeElement(_bgddf.Anchorlock, &_ebaggf); _gggcb != nil {
					return _gggcb
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _bgddf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_dadac := NewEG_ShapeElements()
				_dadac.Bordertop = _a.NewBordertop()
				if _fecf := d.DecodeElement(_dadac.Bordertop, &_ebaggf); _fecf != nil {
					return _fecf
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _dadac)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_gceb := NewEG_ShapeElements()
				_gceb.Borderbottom = _a.NewBorderbottom()
				if _beee := d.DecodeElement(_gceb.Borderbottom, &_ebaggf); _beee != nil {
					return _beee
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _gceb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_ebcdfa := NewEG_ShapeElements()
				_ebcdfa.Borderleft = _a.NewBorderleft()
				if _fccgc := d.DecodeElement(_ebcdfa.Borderleft, &_ebaggf); _fccgc != nil {
					return _fccgc
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _ebcdfa)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_ecfgb := NewEG_ShapeElements()
				_ecfgb.Borderright = _a.NewBorderright()
				if _gffea := d.DecodeElement(_ecfgb.Borderright, &_ebaggf); _gffea != nil {
					return _gffea
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _ecfgb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_gddef := NewEG_ShapeElements()
				_gddef.ClientData = _c.NewClientData()
				if _bbccgg := d.DecodeElement(_gddef.ClientData, &_ebaggf); _bbccgg != nil {
					return _bbccgg
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _gddef)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_gfeee := NewEG_ShapeElements()
				_gfeee.Textdata = _bf.NewTextdata()
				if _gbdeg := d.DecodeElement(_gfeee.Textdata, &_ebaggf); _gbdeg != nil {
					return _gbdeg
				}
				_abfdb.EG_ShapeElements = append(_abfdb.EG_ShapeElements, _gfeee)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on Shape \u0025v", _ebaggf.Name)
				if _eagae := d.Skip(); _eagae != nil {
					return _eagae
				}
			}
		case _b.EndElement:
			break _afcff
		case _b.CharData:
		}
	}
	return nil
}
func (_eacc *CT_Arc) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _gdddc := range start.Attr {
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "userdrawn" {
			_eacc.UserdrawnAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "button" {
			_eacc.ButtonAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "dgmlayoutmru" {
			_eacc.DgmlayoutmruAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "userhidden" {
			_eacc.UserhiddenAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "cliptowrap" {
			_eacc.CliptowrapAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "bullet" {
			_eacc.BulletAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "ole" {
			_eacc.OleAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "hr" {
			_eacc.HrAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "spid" {
			_ceae, _cdea := _gdddc.Value, error(nil)
			if _cdea != nil {
				return _cdea
			}
			_eacc.SpidAttr = &_ceae
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "hrstd" {
			_eacc.HrstdAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "bwnormal" {
			_eacc.BwnormalAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "bordertopcolor" {
			_gdddg, _efe := _gdddc.Value, error(nil)
			if _efe != nil {
				return _efe
			}
			_eacc.BordertopcolorAttr = &_gdddg
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "dgmlayout" {
			_eacc.DgmlayoutAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "forcedash" {
			_eacc.ForcedashAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "allowoverlap" {
			_eacc.AllowoverlapAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "hrnoshade" {
			_eacc.HrnoshadeAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "preferrelative" {
			_eacc.PreferrelativeAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "borderbottomcolor" {
			_ecac, _gcdf := _gdddc.Value, error(nil)
			if _gcdf != nil {
				return _gcdf
			}
			_eacc.BorderbottomcolorAttr = &_ecac
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "oned" {
			_eacc.OnedAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "dgmnodekind" {
			_eadc, _gadc := _e.ParseInt(_gdddc.Value, 10, 64)
			if _gadc != nil {
				return _gadc
			}
			_eacc.DgmnodekindAttr = &_eadc
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "regroupid" {
			_adbc, _bacg := _e.ParseInt(_gdddc.Value, 10, 64)
			if _bacg != nil {
				return _bacg
			}
			_eacc.RegroupidAttr = &_adbc
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "allowincell" {
			_eacc.AllowincellAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "hrpct" {
			_ecacc, _gddc := _e.ParseFloat(_gdddc.Value, 64)
			if _gddc != nil {
				return _gddc
			}
			_dggb := float32(_ecacc)
			_eacc.HrpctAttr = &_dggb
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "clip" {
			_eacc.ClipAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "insetmode" {
			_eacc.InsetmodeAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "borderleftcolor" {
			_addb, _bbgc := _gdddc.Value, error(nil)
			if _bbgc != nil {
				return _bbgc
			}
			_eacc.BorderleftcolorAttr = &_addb
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "oleicon" {
			_eacc.OleiconAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "borderrightcolor" {
			_ggff, _eabg := _gdddc.Value, error(nil)
			if _eabg != nil {
				return _eabg
			}
			_eacc.BorderrightcolorAttr = &_ggff
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "connectortype" {
			_eacc.ConnectortypeAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "bwpure" {
			_eacc.BwpureAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "bwmode" {
			_eacc.BwmodeAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "spt" {
			_ddbb, _gdba := _e.ParseFloat(_gdddc.Value, 64)
			if _gdba != nil {
				return _gdba
			}
			_gdbd := float32(_ddbb)
			_eacc.SptAttr = &_gdbd
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "doubleclicknotify" {
			_eacc.DoubleclicknotifyAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gdddc.Name.Local == "hralign" {
			_eacc.HralignAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Local == "endAngle" {
			_bfdb, _afcd := _e.ParseFloat(_gdddc.Value, 64)
			if _afcd != nil {
				return _afcd
			}
			_eacc.EndAngleAttr = &_bfdb
			continue
		}
		if _gdddc.Name.Local == "id" {
			_feef, _dbbad := _gdddc.Value, error(nil)
			if _dbbad != nil {
				return _dbbad
			}
			_eacc.IdAttr = &_feef
			continue
		}
		if _gdddc.Name.Local == "alt" {
			_dbge, _afff := _gdddc.Value, error(nil)
			if _afff != nil {
				return _afff
			}
			_eacc.AltAttr = &_dbge
			continue
		}
		if _gdddc.Name.Local == "print" {
			_eacc.PrintAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Local == "stroked" {
			_eacc.StrokedAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Local == "wrapcoords" {
			_baed, _ddbg := _gdddc.Value, error(nil)
			if _ddbg != nil {
				return _ddbg
			}
			_eacc.WrapcoordsAttr = &_baed
			continue
		}
		if _gdddc.Name.Local == "strokeweight" {
			_fde, _dffdb := _gdddc.Value, error(nil)
			if _dffdb != nil {
				return _dffdb
			}
			_eacc.StrokeweightAttr = &_fde
			continue
		}
		if _gdddc.Name.Local == "coordorigin" {
			_edd, _dcef := _gdddc.Value, error(nil)
			if _dcef != nil {
				return _dcef
			}
			_eacc.CoordoriginAttr = &_edd
			continue
		}
		if _gdddc.Name.Local == "chromakey" {
			_aaae, _gabe := _gdddc.Value, error(nil)
			if _gabe != nil {
				return _gabe
			}
			_eacc.ChromakeyAttr = &_aaae
			continue
		}
		if _gdddc.Name.Local == "fillcolor" {
			_agfdg, _decc := _gdddc.Value, error(nil)
			if _decc != nil {
				return _decc
			}
			_eacc.FillcolorAttr = &_agfdg
			continue
		}
		if _gdddc.Name.Local == "style" {
			_egg, _effg := _gdddc.Value, error(nil)
			if _effg != nil {
				return _effg
			}
			_eacc.StyleAttr = &_egg
			continue
		}
		if _gdddc.Name.Local == "opacity" {
			_gfab, _cefc := _gdddc.Value, error(nil)
			if _cefc != nil {
				return _cefc
			}
			_eacc.OpacityAttr = &_gfab
			continue
		}
		if _gdddc.Name.Local == "strokecolor" {
			_dcb, _gbae := _gdddc.Value, error(nil)
			if _gbae != nil {
				return _gbae
			}
			_eacc.StrokecolorAttr = &_dcb
			continue
		}
		if _gdddc.Name.Local == "insetpen" {
			_eacc.InsetpenAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
		if _gdddc.Name.Local == "startAngle" {
			_dabg, _agac := _e.ParseFloat(_gdddc.Value, 64)
			if _agac != nil {
				return _agac
			}
			_eacc.StartAngleAttr = &_dabg
			continue
		}
		if _gdddc.Name.Local == "coordsize" {
			_bfga, _dcdeg := _gdddc.Value, error(nil)
			if _dcdeg != nil {
				return _dcdeg
			}
			_eacc.CoordsizeAttr = &_bfga
			continue
		}
		if _gdddc.Name.Local == "title" {
			_egfbb, _eabf := _gdddc.Value, error(nil)
			if _eabf != nil {
				return _eabf
			}
			_eacc.TitleAttr = &_egfbb
			continue
		}
		if _gdddc.Name.Local == "class" {
			_aabd, _faaa := _gdddc.Value, error(nil)
			if _faaa != nil {
				return _faaa
			}
			_eacc.ClassAttr = &_aabd
			continue
		}
		if _gdddc.Name.Local == "target" {
			_baea, _cgab := _gdddc.Value, error(nil)
			if _cgab != nil {
				return _cgab
			}
			_eacc.TargetAttr = &_baea
			continue
		}
		if _gdddc.Name.Local == "href" {
			_ecacf, _cbea := _gdddc.Value, error(nil)
			if _cbea != nil {
				return _cbea
			}
			_eacc.HrefAttr = &_ecacf
			continue
		}
		if _gdddc.Name.Local == "filled" {
			_eacc.FilledAttr.UnmarshalXMLAttr(_gdddc)
			continue
		}
	}
_fgddb:
	for {
		_gfga, _cgfb := d.Token()
		if _cgfb != nil {
			return _cgfb
		}
		switch _gegd := _gfga.(type) {
		case _b.StartElement:
			switch _gegd.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_cbac := NewEG_ShapeElements()
				_cbac.Path = NewPath()
				if _bafeb := d.DecodeElement(_cbac.Path, &_gegd); _bafeb != nil {
					return _bafeb
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _cbac)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_dfef := NewEG_ShapeElements()
				_dfef.Formulas = NewFormulas()
				if _edbb := d.DecodeElement(_dfef.Formulas, &_gegd); _edbb != nil {
					return _edbb
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _dfef)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_baec := NewEG_ShapeElements()
				_baec.Handles = NewHandles()
				if _fcd := d.DecodeElement(_baec.Handles, &_gegd); _fcd != nil {
					return _fcd
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _baec)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_cee := NewEG_ShapeElements()
				_cee.Fill = NewFill()
				if _gbbf := d.DecodeElement(_cee.Fill, &_gegd); _gbbf != nil {
					return _gbbf
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _cee)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_dedbd := NewEG_ShapeElements()
				_dedbd.Stroke = NewStroke()
				if _gcdc := d.DecodeElement(_dedbd.Stroke, &_gegd); _gcdc != nil {
					return _gcdc
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _dedbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_adccg := NewEG_ShapeElements()
				_adccg.Shadow = NewShadow()
				if _cced := d.DecodeElement(_adccg.Shadow, &_gegd); _cced != nil {
					return _cced
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _adccg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_fadea := NewEG_ShapeElements()
				_fadea.Textbox = NewTextbox()
				if _cgaf := d.DecodeElement(_fadea.Textbox, &_gegd); _cgaf != nil {
					return _cgaf
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _fadea)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_cbd := NewEG_ShapeElements()
				_cbd.Textpath = NewTextpath()
				if _efdd := d.DecodeElement(_cbd.Textpath, &_gegd); _efdd != nil {
					return _efdd
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _cbd)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_cfdb := NewEG_ShapeElements()
				_cfdb.Imagedata = NewImagedata()
				if _aacg := d.DecodeElement(_cfdb.Imagedata, &_gegd); _aacg != nil {
					return _aacg
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _cfdb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_ccec := NewEG_ShapeElements()
				_ccec.Skew = NewOfcSkew()
				if _beeb := d.DecodeElement(_ccec.Skew, &_gegd); _beeb != nil {
					return _beeb
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _ccec)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_fagb := NewEG_ShapeElements()
				_fagb.Extrusion = NewOfcExtrusion()
				if _ffdf := d.DecodeElement(_fagb.Extrusion, &_gegd); _ffdf != nil {
					return _ffdf
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _fagb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_aege := NewEG_ShapeElements()
				_aege.Callout = NewOfcCallout()
				if _efgee := d.DecodeElement(_aege.Callout, &_gegd); _efgee != nil {
					return _efgee
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _aege)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_cabe := NewEG_ShapeElements()
				_cabe.Lock = NewOfcLock()
				if _aefd := d.DecodeElement(_cabe.Lock, &_gegd); _aefd != nil {
					return _aefd
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _cabe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_ebbe := NewEG_ShapeElements()
				_ebbe.Clippath = NewOfcClippath()
				if _cggbe := d.DecodeElement(_ebbe.Clippath, &_gegd); _cggbe != nil {
					return _cggbe
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _ebbe)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_eeff := NewEG_ShapeElements()
				_eeff.Signatureline = NewOfcSignatureline()
				if _cddef := d.DecodeElement(_eeff.Signatureline, &_gegd); _cddef != nil {
					return _cddef
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _eeff)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_fbace := NewEG_ShapeElements()
				_fbace.Wrap = _a.NewWrap()
				if _cegfa := d.DecodeElement(_fbace.Wrap, &_gegd); _cegfa != nil {
					return _cegfa
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _fbace)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_bcbcb := NewEG_ShapeElements()
				_bcbcb.Anchorlock = _a.NewAnchorlock()
				if _dfba := d.DecodeElement(_bcbcb.Anchorlock, &_gegd); _dfba != nil {
					return _dfba
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _bcbcb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_gddce := NewEG_ShapeElements()
				_gddce.Bordertop = _a.NewBordertop()
				if _fgfg := d.DecodeElement(_gddce.Bordertop, &_gegd); _fgfg != nil {
					return _fgfg
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _gddce)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_agfef := NewEG_ShapeElements()
				_agfef.Borderbottom = _a.NewBorderbottom()
				if _cdgbgb := d.DecodeElement(_agfef.Borderbottom, &_gegd); _cdgbgb != nil {
					return _cdgbgb
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _agfef)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_cfae := NewEG_ShapeElements()
				_cfae.Borderleft = _a.NewBorderleft()
				if _cbef := d.DecodeElement(_cfae.Borderleft, &_gegd); _cbef != nil {
					return _cbef
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _cfae)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_fegbb := NewEG_ShapeElements()
				_fegbb.Borderright = _a.NewBorderright()
				if _fgga := d.DecodeElement(_fegbb.Borderright, &_gegd); _fgga != nil {
					return _fgga
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _fegbb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_cadc := NewEG_ShapeElements()
				_cadc.ClientData = _c.NewClientData()
				if _gagdd := d.DecodeElement(_cadc.ClientData, &_gegd); _gagdd != nil {
					return _gagdd
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _cadc)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_bec := NewEG_ShapeElements()
				_bec.Textdata = _bf.NewTextdata()
				if _dcbb := d.DecodeElement(_bec.Textdata, &_gegd); _dcbb != nil {
					return _dcbb
				}
				_eacc.EG_ShapeElements = append(_eacc.EG_ShapeElements, _bec)
			default:
				_ba.Log("skipping\u0020unsupported\u0020element\u0020on\u0020CT_Arc\u0020\u0025v", _gegd.Name)
				if _cegfg := d.Skip(); _cegfg != nil {
					return _cegfg
				}
			}
		case _b.EndElement:
			break _fgddb
		case _b.CharData:
		}
	}
	return nil
}
func (_defc OfcST_CalloutPlacement) String() string {
	switch _defc {
	case 0:
		return ""
	case 1:
		return "top"
	case 2:
		return "center"
	case 3:
		return "bottom"
	case 4:
		return "user"
	}
	return ""
}

const (
	OfcST_ScreenSizeUnset    OfcST_ScreenSize = 0
	OfcST_ScreenSize544x376  OfcST_ScreenSize = 1
	OfcST_ScreenSize640x480  OfcST_ScreenSize = 2
	OfcST_ScreenSize720x512  OfcST_ScreenSize = 3
	OfcST_ScreenSize800x600  OfcST_ScreenSize = 4
	OfcST_ScreenSize1024x768 OfcST_ScreenSize = 5
	OfcST_ScreenSize1152x862 OfcST_ScreenSize = 6
)

type OfcST_ExtrusionRender byte

func (_cabgadf *OfcCT_Skew) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	for _, _bcbf := range start.Attr {
		if _bcbf.Name.Local == "id" {
			_cddfd, _daeg := _bcbf.Value, error(nil)
			if _daeg != nil {
				return _daeg
			}
			_cabgadf.IdAttr = &_cddfd
			continue
		}
		if _bcbf.Name.Local == "on" {
			_cabgadf.OnAttr.UnmarshalXMLAttr(_bcbf)
			continue
		}
		if _bcbf.Name.Local == "offset" {
			_adbfb, _ddgebf := _bcbf.Value, error(nil)
			if _ddgebf != nil {
				return _ddgebf
			}
			_cabgadf.OffsetAttr = &_adbfb
			continue
		}
		if _bcbf.Name.Local == "origin" {
			_gaefg, _cfgc := _bcbf.Value, error(nil)
			if _cfgc != nil {
				return _cfgc
			}
			_cabgadf.OriginAttr = &_gaefg
			continue
		}
		if _bcbf.Name.Local == "matrix" {
			_fdaca, _faadd := _bcbf.Value, error(nil)
			if _faadd != nil {
				return _faadd
			}
			_cabgadf.MatrixAttr = &_fdaca
			continue
		}
		if _bcbf.Name.Local == "ext" {
			_cabgadf.ExtAttr.UnmarshalXMLAttr(_bcbf)
			continue
		}
	}
	for {
		_cgdbf, _dbdfd := d.Token()
		if _dbdfd != nil {
			return _f.Errorf("parsing\u0020OfcCT_Skew:\u0020%s", _dbdfd)
		}
		if _gdcac, _dgaaa := _cgdbf.(_b.EndElement); _dgaaa && _gdcac.Name == start.Name {
			break
		}
	}
	return nil
}
func (_feefb ST_EditAs) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_feefb.String(), start)
}
func (_efbffc *ST_ImageAspect) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_ecbgg, _faffge := d.Token()
	if _faffge != nil {
		return _faffge
	}
	if _bgeaf, _ccfae := _ecbgg.(_b.EndElement); _ccfae && _bgeaf.Name == start.Name {
		*_efbffc = 1
		return nil
	}
	if _bebcc, _afbef := _ecbgg.(_b.CharData); !_afbef {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _ecbgg)
	} else {
		switch string(_bebcc) {
		case "":
			*_efbffc = 0
		case "ignore":
			*_efbffc = 1
		case "atMost":
			*_efbffc = 2
		case "atLeast":
			*_efbffc = 3
		}
	}
	_ecbgg, _faffge = d.Token()
	if _faffge != nil {
		return _faffge
	}
	if _aaeag, _eeage := _ecbgg.(_b.EndElement); _eeage && _aaeag.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _ecbgg)
}
func NewRect() *Rect { _gfgcb := &Rect{}; _gfgcb.CT_Rect = *NewCT_Rect(); return _gfgcb }

const (
	ST_ExtUnset              ST_Ext = 0
	ST_ExtView               ST_Ext = 1
	ST_ExtEdit               ST_Ext = 2
	ST_ExtBackwardCompatible ST_Ext = 3
)

// Validate validates the OfcExtrusion and its children
func (_gefcb *OfcExtrusion) Validate() error  { return _gefcb.ValidateWithPath("OfcExtrusion") }
func (_ddafec OfcST_OLEType) Validate() error { return _ddafec.ValidateWithPath("") }

// Validate validates the Shape and its children
func (_ddcea *Shape) Validate() error { return _ddcea.ValidateWithPath("Shape") }

type OfcST_OLEUpdateMode byte
type OfcCT_StrokeChild struct {
	OnAttr               _eb.ST_TrueFalse
	WeightAttr           *string
	ColorAttr            *string
	Color2Attr           *string
	OpacityAttr          *string
	LinestyleAttr        ST_StrokeLineStyle
	MiterlimitAttr       *float64
	JoinstyleAttr        ST_StrokeJoinStyle
	EndcapAttr           ST_StrokeEndCap
	DashstyleAttr        *string
	InsetpenAttr         _eb.ST_TrueFalse
	FilltypeAttr         ST_FillType
	SrcAttr              *string
	ImageaspectAttr      ST_ImageAspect
	ImagesizeAttr        *string
	ImagealignshapeAttr  _eb.ST_TrueFalse
	StartarrowAttr       ST_StrokeArrowType
	StartarrowwidthAttr  ST_StrokeArrowWidth
	StartarrowlengthAttr ST_StrokeArrowLength
	EndarrowAttr         ST_StrokeArrowType
	EndarrowwidthAttr    ST_StrokeArrowWidth
	EndarrowlengthAttr   ST_StrokeArrowLength
	HrefAttr             *string
	AlthrefAttr          *string
	TitleAttr            *string
	ForcedashAttr        _eb.ST_TrueFalse
	ExtAttr              ST_Ext
}

// ValidateWithPath validates the OfcTop and its children, prefixing error messages with path
func (_bbbbf *OfcTop) ValidateWithPath(path string) error {
	if _faege := _bbbbf.OfcCT_StrokeChild.ValidateWithPath(path); _faege != nil {
		return _faege
	}
	return nil
}
func NewCT_Line() *CT_Line { _daae := &CT_Line{}; return _daae }
func (_afef *OfcCT_EquationXml) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _afef.ContentTypeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "contentType"}, Value: _f.Sprintf("\u0025v", *_afef.ContentTypeAttr)})
	}
	e.EncodeToken(start)
	if _afef.Any != nil {
		_afef.Any.MarshalXML(e, _b.StartElement{})
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewOfcCT_ClipPath() *OfcCT_ClipPath { _gbcbb := &OfcCT_ClipPath{}; return _gbcbb }
func (_fafafa *ST_StrokeJoinStyle) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_egdcf, _fbfec := d.Token()
	if _fbfec != nil {
		return _fbfec
	}
	if _fdgfc, _cbddde := _egdcf.(_b.EndElement); _cbddde && _fdgfc.Name == start.Name {
		*_fafafa = 1
		return nil
	}
	if _ebacd, _decga := _egdcf.(_b.CharData); !_decga {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _egdcf)
	} else {
		switch string(_ebacd) {
		case "":
			*_fafafa = 0
		case "round":
			*_fafafa = 1
		case "bevel":
			*_fafafa = 2
		case "miter":
			*_fafafa = 3
		}
	}
	_egdcf, _fbfec = d.Token()
	if _fbfec != nil {
		return _fbfec
	}
	if _efbdb, _ggdceb := _egdcf.(_b.EndElement); _ggdceb && _efbdb.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _egdcf)
}
func (_cggg *OfcSignatureline) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cggg.OfcCT_SignatureLine = *NewOfcCT_SignatureLine()
	for _, _cbeda := range start.Attr {
		if _cbeda.Name.Local == "suggestedsigner" {
			_afgdea, _ccbcf := _cbeda.Value, error(nil)
			if _ccbcf != nil {
				return _ccbcf
			}
			_cggg.SuggestedsignerAttr = &_afgdea
			continue
		}
		if _cbeda.Name.Local == "id" {
			_gfcee, _ccdec := _cbeda.Value, error(nil)
			if _ccdec != nil {
				return _ccdec
			}
			_cggg.IdAttr = &_gfcee
			continue
		}
		if _cbeda.Name.Local == "provid" {
			_bbbba, _eecaaf := _cbeda.Value, error(nil)
			if _eecaaf != nil {
				return _eecaaf
			}
			_cggg.ProvidAttr = &_bbbba
			continue
		}
		if _cbeda.Name.Local == "signinginstructionsset" {
			_cggg.SigninginstructionssetAttr.UnmarshalXMLAttr(_cbeda)
			continue
		}
		if _cbeda.Name.Local == "allowcomments" {
			_cggg.AllowcommentsAttr.UnmarshalXMLAttr(_cbeda)
			continue
		}
		if _cbeda.Name.Local == "showsigndate" {
			_cggg.ShowsigndateAttr.UnmarshalXMLAttr(_cbeda)
			continue
		}
		if _cbeda.Name.Local == "issignatureline" {
			_cggg.IssignaturelineAttr.UnmarshalXMLAttr(_cbeda)
			continue
		}
		if _cbeda.Name.Local == "suggestedsigner2" {
			_ddaae, _aaddgg := _cbeda.Value, error(nil)
			if _aaddgg != nil {
				return _aaddgg
			}
			_cggg.Suggestedsigner2Attr = &_ddaae
			continue
		}
		if _cbeda.Name.Local == "suggestedsigneremail" {
			_eabgd, _faecg := _cbeda.Value, error(nil)
			if _faecg != nil {
				return _faecg
			}
			_cggg.SuggestedsigneremailAttr = &_eabgd
			continue
		}
		if _cbeda.Name.Local == "signinginstructions" {
			_aefgb, _ededc := _cbeda.Value, error(nil)
			if _ededc != nil {
				return _ededc
			}
			_cggg.SigninginstructionsAttr = &_aefgb
			continue
		}
		if _cbeda.Name.Local == "addlxml" {
			_fadde, _fgfab := _cbeda.Value, error(nil)
			if _fgfab != nil {
				return _fgfab
			}
			_cggg.AddlxmlAttr = &_fadde
			continue
		}
		if _cbeda.Name.Local == "sigprovurl" {
			_gefe, _bcebb := _cbeda.Value, error(nil)
			if _bcebb != nil {
				return _bcebb
			}
			_cggg.SigprovurlAttr = &_gefe
			continue
		}
		if _cbeda.Name.Local == "ext" {
			_cggg.ExtAttr.UnmarshalXMLAttr(_cbeda)
			continue
		}
	}
	for {
		_cffbb, _bdadf := d.Token()
		if _bdadf != nil {
			return _f.Errorf("parsing\u0020OfcSignatureline: \u0025s", _bdadf)
		}
		if _edafa, _bcfe := _cffbb.(_b.EndElement); _bcfe && _edafa.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the AG_ImageAttributes and its children, prefixing error messages with path
func (_gde *AG_ImageAttributes) ValidateWithPath(path string) error {
	if _eee := _gde.GrayscaleAttr.ValidateWithPath(path + "\u002fGrayscaleAttr"); _eee != nil {
		return _eee
	}
	if _dgae := _gde.BilevelAttr.ValidateWithPath(path + "\u002fBilevelAttr"); _dgae != nil {
		return _dgae
	}
	return nil
}
func (_bdcbdf *ST_StrokeArrowWidth) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_bdefd, _eebbgg := d.Token()
	if _eebbgg != nil {
		return _eebbgg
	}
	if _fdgcg, _acab := _bdefd.(_b.EndElement); _acab && _fdgcg.Name == start.Name {
		*_bdcbdf = 1
		return nil
	}
	if _ddbea, _gagbg := _bdefd.(_b.CharData); !_gagbg {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _bdefd)
	} else {
		switch string(_ddbea) {
		case "":
			*_bdcbdf = 0
		case "narrow":
			*_bdcbdf = 1
		case "medium":
			*_bdcbdf = 2
		case "wide":
			*_bdcbdf = 3
		}
	}
	_bdefd, _eebbgg = d.Token()
	if _eebbgg != nil {
		return _eebbgg
	}
	if _dffcc, _cfcb := _bdefd.(_b.EndElement); _cfcb && _dffcc.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _bdefd)
}
func NewOfcCT_Ink() *OfcCT_Ink { _dbfgg := &OfcCT_Ink{}; return _dbfgg }

// ValidateWithPath validates the Arc and its children, prefixing error messages with path
func (_bgca *Arc) ValidateWithPath(path string) error {
	if _bdaf := _bgca.CT_Arc.ValidateWithPath(path); _bdaf != nil {
		return _bdaf
	}
	return nil
}
func (_deaef *OfcST_OLEDrawAspect) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_deaef = 0
	case "Content":
		*_deaef = 1
	case "Icon":
		*_deaef = 2
	}
	return nil
}
func (_gfgede OfcST_Angle) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_gfgede.String(), start)
}

type OfcCT_Relation struct {
	IdsrcAttr  *string
	IddestAttr *string
	IdcntrAttr *string
	ExtAttr    ST_Ext
}
type CT_Formulas struct{ F []*CT_F }

func (_aaff *AG_Ext) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_aaff.ExtAttr = ST_Ext(1)
	for _, _ggce := range start.Attr {
		if _ggce.Name.Local == "ext" {
			_aaff.ExtAttr.UnmarshalXMLAttr(_ggce)
			continue
		}
	}
	for {
		_gbg, _cfab := d.Token()
		if _cfab != nil {
			return _f.Errorf("parsing\u0020AG_Ext:\u0020\u0025s", _cfab)
		}
		if _bfec, _ggg := _gbg.(_b.EndElement); _ggg && _bfec.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the AG_Type and its children
func (_ggcb *AG_Type) Validate() error { return _ggcb.ValidateWithPath("AG_Type") }
func (_acgada OfcST_OLEUpdateMode) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return e.EncodeElement(_acgada.String(), start)
}
func (_cgffe OfcST_Angle) ValidateWithPath(path string) error {
	switch _cgffe {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _f.Errorf("\u0025s:\u0020out\u0020of\u0020range value\u0020\u0025d", path, int(_cgffe))
	}
	return nil
}
func (_cafae *OfcColumn) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cafae.OfcCT_StrokeChild = *NewOfcCT_StrokeChild()
	for _, _gbfeca := range start.Attr {
		if _gbfeca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gbfeca.Name.Local == "href" {
			_efdfdd, _cgdbe := _gbfeca.Value, error(nil)
			if _cgdbe != nil {
				return _cgdbe
			}
			_cafae.HrefAttr = &_efdfdd
			continue
		}
		if _gbfeca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gbfeca.Name.Local == "forcedash" {
			_cafae.ForcedashAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gbfeca.Name.Local == "title" {
			_cacgf, _gegfc := _gbfeca.Value, error(nil)
			if _gegfc != nil {
				return _gegfc
			}
			_cafae.TitleAttr = &_cacgf
			continue
		}
		if _gbfeca.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _gbfeca.Name.Local == "althref" {
			_ccgec, _begfc := _gbfeca.Value, error(nil)
			if _begfc != nil {
				return _begfc
			}
			_cafae.AlthrefAttr = &_ccgec
			continue
		}
		if _gbfeca.Name.Local == "imageaspect" {
			_cafae.ImageaspectAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "startarrow" {
			_cafae.StartarrowAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "linestyle" {
			_cafae.LinestyleAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "startarrowwidth" {
			_cafae.StartarrowwidthAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "joinstyle" {
			_cafae.JoinstyleAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "startarrowlength" {
			_cafae.StartarrowlengthAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "dashstyle" {
			_bbefc, _efddf := _gbfeca.Value, error(nil)
			if _efddf != nil {
				return _efddf
			}
			_cafae.DashstyleAttr = &_bbefc
			continue
		}
		if _gbfeca.Name.Local == "endarrow" {
			_cafae.EndarrowAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "filltype" {
			_cafae.FilltypeAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "endarrowwidth" {
			_cafae.EndarrowwidthAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "opacity" {
			_gfca, _cgfdb := _gbfeca.Value, error(nil)
			if _cgfdb != nil {
				return _cgfdb
			}
			_cafae.OpacityAttr = &_gfca
			continue
		}
		if _gbfeca.Name.Local == "color" {
			_cgfbdf, _affbg := _gbfeca.Value, error(nil)
			if _affbg != nil {
				return _affbg
			}
			_cafae.ColorAttr = &_cgfbdf
			continue
		}
		if _gbfeca.Name.Local == "insetpen" {
			_cafae.InsetpenAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "endarrowlength" {
			_cafae.EndarrowlengthAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "ext" {
			_cafae.ExtAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "endcap" {
			_cafae.EndcapAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "color2" {
			_fgacgg, _aebce := _gbfeca.Value, error(nil)
			if _aebce != nil {
				return _aebce
			}
			_cafae.Color2Attr = &_fgacgg
			continue
		}
		if _gbfeca.Name.Local == "imagealignshape" {
			_cafae.ImagealignshapeAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
		if _gbfeca.Name.Local == "weight" {
			_gebff, _cedeb := _gbfeca.Value, error(nil)
			if _cedeb != nil {
				return _cedeb
			}
			_cafae.WeightAttr = &_gebff
			continue
		}
		if _gbfeca.Name.Local == "src" {
			_bccaf, _cfebc := _gbfeca.Value, error(nil)
			if _cfebc != nil {
				return _cfebc
			}
			_cafae.SrcAttr = &_bccaf
			continue
		}
		if _gbfeca.Name.Local == "imagesize" {
			_ggcfa, _ddddc := _gbfeca.Value, error(nil)
			if _ddddc != nil {
				return _ddddc
			}
			_cafae.ImagesizeAttr = &_ggcfa
			continue
		}
		if _gbfeca.Name.Local == "miterlimit" {
			_ddafe, _eabca := _e.ParseFloat(_gbfeca.Value, 64)
			if _eabca != nil {
				return _eabca
			}
			_cafae.MiterlimitAttr = &_ddafe
			continue
		}
		if _gbfeca.Name.Local == "on" {
			_cafae.OnAttr.UnmarshalXMLAttr(_gbfeca)
			continue
		}
	}
	for {
		_cfegb, _gcceb := d.Token()
		if _gcceb != nil {
			return _f.Errorf("parsing\u0020OfcColumn:\u0020\u0025s", _gcceb)
		}
		if _cbfbg, _gbfcf := _cfegb.(_b.EndElement); _gbfcf && _cbfbg.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gcdde *OfcST_CalloutPlacement) UnmarshalXMLAttr(attr _b.Attr) error {
	switch attr.Value {
	case "":
		*_gcdde = 0
	case "top":
		*_gcdde = 1
	case "center":
		*_gcdde = 2
	case "bottom":
		*_gcdde = 3
	case "user":
		*_gcdde = 4
	}
	return nil
}

// Validate validates the CT_Shadow and its children
func (_abggac *CT_Shadow) Validate() error { return _abggac.ValidateWithPath("CT_Shadow") }
func NewAG_AllShapeAttributes() *AG_AllShapeAttributes {
	_bcdc := &AG_AllShapeAttributes{}
	return _bcdc
}

type CT_Handles struct{ H []*CT_H }

func NewShapetype() *Shapetype {
	_edbag := &Shapetype{}
	_edbag.CT_Shapetype = *NewCT_Shapetype()
	return _edbag
}
func (_aecbe *OfcCT_SignatureLine) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _aecbe.IssignaturelineAttr != _eb.ST_TrueFalseUnset {
		_dgded, _aggee := _aecbe.IssignaturelineAttr.MarshalXMLAttr(_b.Name{Local: "issignatureline"})
		if _aggee != nil {
			return _aggee
		}
		start.Attr = append(start.Attr, _dgded)
	}
	if _aecbe.IdAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "id"}, Value: _f.Sprintf("\u0025v", *_aecbe.IdAttr)})
	}
	if _aecbe.ProvidAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "provid"}, Value: _f.Sprintf("\u0025v", *_aecbe.ProvidAttr)})
	}
	if _aecbe.SigninginstructionssetAttr != _eb.ST_TrueFalseUnset {
		_fgaag, _gbadbb := _aecbe.SigninginstructionssetAttr.MarshalXMLAttr(_b.Name{Local: "signinginstructionsset"})
		if _gbadbb != nil {
			return _gbadbb
		}
		start.Attr = append(start.Attr, _fgaag)
	}
	if _aecbe.AllowcommentsAttr != _eb.ST_TrueFalseUnset {
		_agecg, _fgad := _aecbe.AllowcommentsAttr.MarshalXMLAttr(_b.Name{Local: "allowcomments"})
		if _fgad != nil {
			return _fgad
		}
		start.Attr = append(start.Attr, _agecg)
	}
	if _aecbe.ShowsigndateAttr != _eb.ST_TrueFalseUnset {
		_eagdd, _cgegf := _aecbe.ShowsigndateAttr.MarshalXMLAttr(_b.Name{Local: "showsigndate"})
		if _cgegf != nil {
			return _cgegf
		}
		start.Attr = append(start.Attr, _eagdd)
	}
	if _aecbe.SuggestedsignerAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "suggestedsigner"}, Value: _f.Sprintf("\u0025v", *_aecbe.SuggestedsignerAttr)})
	}
	if _aecbe.Suggestedsigner2Attr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "suggestedsigner2"}, Value: _f.Sprintf("\u0025v", *_aecbe.Suggestedsigner2Attr)})
	}
	if _aecbe.SuggestedsigneremailAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "suggestedsigneremail"}, Value: _f.Sprintf("\u0025v", *_aecbe.SuggestedsigneremailAttr)})
	}
	if _aecbe.SigninginstructionsAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "signinginstructions"}, Value: _f.Sprintf("\u0025v", *_aecbe.SigninginstructionsAttr)})
	}
	if _aecbe.AddlxmlAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "addlxml"}, Value: _f.Sprintf("\u0025v", *_aecbe.AddlxmlAttr)})
	}
	if _aecbe.SigprovurlAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "sigprovurl"}, Value: _f.Sprintf("\u0025v", *_aecbe.SigprovurlAttr)})
	}
	if _aecbe.ExtAttr != ST_ExtUnset {
		_dbcd, _cggd := _aecbe.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _cggd != nil {
			return _cggd
		}
		start.Attr = append(start.Attr, _dbcd)
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type OfcST_FillType byte

// ValidateWithPath validates the CT_Line and its children, prefixing error messages with path
func (_caed *CT_Line) ValidateWithPath(path string) error {
	for _eafc, _eddb := range _caed.EG_ShapeElements {
		if _adaeg := _eddb.ValidateWithPath(_f.Sprintf("\u0025s\u002fEG_ShapeElements\u005b\u0025d\u005d", path, _eafc)); _adaeg != nil {
			return _adaeg
		}
	}
	if _ebec := _caed.PrintAttr.ValidateWithPath(path + "\u002fPrintAttr"); _ebec != nil {
		return _ebec
	}
	if _aegf := _caed.OnedAttr.ValidateWithPath(path + "\u002fOnedAttr"); _aegf != nil {
		return _aegf
	}
	if _effbfb := _caed.DoubleclicknotifyAttr.ValidateWithPath(path + "\u002fDoubleclicknotifyAttr"); _effbfb != nil {
		return _effbfb
	}
	if _dbed := _caed.ButtonAttr.ValidateWithPath(path + "/ButtonAttr"); _dbed != nil {
		return _dbed
	}
	if _afge := _caed.UserhiddenAttr.ValidateWithPath(path + "\u002fUserhiddenAttr"); _afge != nil {
		return _afge
	}
	if _bdgab := _caed.BulletAttr.ValidateWithPath(path + "/BulletAttr"); _bdgab != nil {
		return _bdgab
	}
	if _abacc := _caed.HrAttr.ValidateWithPath(path + "\u002fHrAttr"); _abacc != nil {
		return _abacc
	}
	if _baeac := _caed.HrstdAttr.ValidateWithPath(path + "\u002fHrstdAttr"); _baeac != nil {
		return _baeac
	}
	if _faee := _caed.HrnoshadeAttr.ValidateWithPath(path + "\u002fHrnoshadeAttr"); _faee != nil {
		return _faee
	}
	if _ggfda := _caed.HralignAttr.ValidateWithPath(path + "\u002fHralignAttr"); _ggfda != nil {
		return _ggfda
	}
	if _bdca := _caed.AllowincellAttr.ValidateWithPath(path + "\u002fAllowincellAttr"); _bdca != nil {
		return _bdca
	}
	if _bbded := _caed.AllowoverlapAttr.ValidateWithPath(path + "\u002fAllowoverlapAttr"); _bbded != nil {
		return _bbded
	}
	if _eada := _caed.UserdrawnAttr.ValidateWithPath(path + "\u002fUserdrawnAttr"); _eada != nil {
		return _eada
	}
	if _ecef := _caed.DgmlayoutAttr.ValidateWithPath(path + "\u002fDgmlayoutAttr"); _ecef != nil {
		return _ecef
	}
	if _fagde := _caed.DgmlayoutmruAttr.ValidateWithPath(path + "\u002fDgmlayoutmruAttr"); _fagde != nil {
		return _fagde
	}
	if _ddfgc := _caed.InsetmodeAttr.ValidateWithPath(path + "\u002fInsetmodeAttr"); _ddfgc != nil {
		return _ddfgc
	}
	if _bgea := _caed.StrokedAttr.ValidateWithPath(path + "\u002fStrokedAttr"); _bgea != nil {
		return _bgea
	}
	if _addc := _caed.InsetpenAttr.ValidateWithPath(path + "\u002fInsetpenAttr"); _addc != nil {
		return _addc
	}
	if _egaf := _caed.FilledAttr.ValidateWithPath(path + "/FilledAttr"); _egaf != nil {
		return _egaf
	}
	if _aeec := _caed.ConnectortypeAttr.ValidateWithPath(path + "\u002fConnectortypeAttr"); _aeec != nil {
		return _aeec
	}
	if _adac := _caed.BwmodeAttr.ValidateWithPath(path + "/BwmodeAttr"); _adac != nil {
		return _adac
	}
	if _babe := _caed.BwpureAttr.ValidateWithPath(path + "/BwpureAttr"); _babe != nil {
		return _babe
	}
	if _dcefa := _caed.BwnormalAttr.ValidateWithPath(path + "\u002fBwnormalAttr"); _dcefa != nil {
		return _dcefa
	}
	if _gcaf := _caed.ForcedashAttr.ValidateWithPath(path + "\u002fForcedashAttr"); _gcaf != nil {
		return _gcaf
	}
	if _gfeef := _caed.OleiconAttr.ValidateWithPath(path + "\u002fOleiconAttr"); _gfeef != nil {
		return _gfeef
	}
	if _fadc := _caed.OleAttr.ValidateWithPath(path + "\u002fOleAttr"); _fadc != nil {
		return _fadc
	}
	if _aadc := _caed.PreferrelativeAttr.ValidateWithPath(path + "\u002fPreferrelativeAttr"); _aadc != nil {
		return _aadc
	}
	if _abbdf := _caed.CliptowrapAttr.ValidateWithPath(path + "\u002fCliptowrapAttr"); _abbdf != nil {
		return _abbdf
	}
	if _efdb := _caed.ClipAttr.ValidateWithPath(path + "\u002fClipAttr"); _efdb != nil {
		return _efdb
	}
	return nil
}
func (_dcffd *Rect) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dcffd.CT_Rect = *NewCT_Rect()
	for _, _aeege := range start.Attr {
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "bordertopcolor" {
			_gaeba, _cfabg := _aeege.Value, error(nil)
			if _cfabg != nil {
				return _cfabg
			}
			_dcffd.BordertopcolorAttr = &_gaeba
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "bullet" {
			_dcffd.BulletAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "hr" {
			_dcffd.HrAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "cliptowrap" {
			_dcffd.CliptowrapAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "hrstd" {
			_dcffd.HrstdAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "ole" {
			_dcffd.OleAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "hrnoshade" {
			_dcffd.HrnoshadeAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "oned" {
			_dcffd.OnedAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "hrpct" {
			_abdfd, _fafdb := _e.ParseFloat(_aeege.Value, 64)
			if _fafdb != nil {
				return _fafdb
			}
			_dadca := float32(_abdfd)
			_dcffd.HrpctAttr = &_dadca
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "oleicon" {
			_dcffd.OleiconAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "borderbottomcolor" {
			_bgdbg, _cggcg := _aeege.Value, error(nil)
			if _cggcg != nil {
				return _cggcg
			}
			_dcffd.BorderbottomcolorAttr = &_bgdbg
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "dgmlayoutmru" {
			_dcffd.DgmlayoutmruAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "regroupid" {
			_edefd, _dgegc := _e.ParseInt(_aeege.Value, 10, 64)
			if _dgegc != nil {
				return _dgegc
			}
			_dcffd.RegroupidAttr = &_edefd
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "clip" {
			_dcffd.ClipAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "hralign" {
			_dcffd.HralignAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "preferrelative" {
			_dcffd.PreferrelativeAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "dgmlayout" {
			_dcffd.DgmlayoutAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "doubleclicknotify" {
			_dcffd.DoubleclicknotifyAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "insetmode" {
			_dcffd.InsetmodeAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "button" {
			_dcffd.ButtonAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "userdrawn" {
			_dcffd.UserdrawnAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "allowincell" {
			_dcffd.AllowincellAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "spt" {
			_dfbge, _ddcdb := _e.ParseFloat(_aeege.Value, 64)
			if _ddcdb != nil {
				return _ddcdb
			}
			_eeggf := float32(_dfbge)
			_dcffd.SptAttr = &_eeggf
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "borderleftcolor" {
			_bdbda, _fegfac := _aeege.Value, error(nil)
			if _fegfac != nil {
				return _fegfac
			}
			_dcffd.BorderleftcolorAttr = &_bdbda
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "connectortype" {
			_dcffd.ConnectortypeAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "borderrightcolor" {
			_bbgeb, _dbcbe := _aeege.Value, error(nil)
			if _dbcbe != nil {
				return _dbcbe
			}
			_dcffd.BorderrightcolorAttr = &_bbgeb
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "spid" {
			_gedc, _egcgb := _aeege.Value, error(nil)
			if _egcgb != nil {
				return _egcgb
			}
			_dcffd.SpidAttr = &_gedc
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "dgmnodekind" {
			_fagfd, _gebaad := _e.ParseInt(_aeege.Value, 10, 64)
			if _gebaad != nil {
				return _gebaad
			}
			_dcffd.DgmnodekindAttr = &_fagfd
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "bwpure" {
			_dcffd.BwpureAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "forcedash" {
			_dcffd.ForcedashAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "bwnormal" {
			_dcffd.BwnormalAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "bwmode" {
			_dcffd.BwmodeAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "userhidden" {
			_dcffd.UserhiddenAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Space == "urn:schemas\u002dmicrosoft\u002dcom:office:office" && _aeege.Name.Local == "allowoverlap" {
			_dcffd.AllowoverlapAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Local == "target" {
			_dfgbg, _bacfe := _aeege.Value, error(nil)
			if _bacfe != nil {
				return _bacfe
			}
			_dcffd.TargetAttr = &_dfgbg
			continue
		}
		if _aeege.Name.Local == "coordorigin" {
			_edcec, _afdgea := _aeege.Value, error(nil)
			if _afdgea != nil {
				return _afdgea
			}
			_dcffd.CoordoriginAttr = &_edcec
			continue
		}
		if _aeege.Name.Local == "stroked" {
			_dcffd.StrokedAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Local == "coordsize" {
			_ecebc, _ggbfd := _aeege.Value, error(nil)
			if _ggbfd != nil {
				return _ggbfd
			}
			_dcffd.CoordsizeAttr = &_ecebc
			continue
		}
		if _aeege.Name.Local == "strokeweight" {
			_caegg, _dbbag := _aeege.Value, error(nil)
			if _dbbag != nil {
				return _dbbag
			}
			_dcffd.StrokeweightAttr = &_caegg
			continue
		}
		if _aeege.Name.Local == "style" {
			_bfffa, _edaa := _aeege.Value, error(nil)
			if _edaa != nil {
				return _edaa
			}
			_dcffd.StyleAttr = &_bfffa
			continue
		}
		if _aeege.Name.Local == "chromakey" {
			_fbaba, _cffaa := _aeege.Value, error(nil)
			if _cffaa != nil {
				return _cffaa
			}
			_dcffd.ChromakeyAttr = &_fbaba
			continue
		}
		if _aeege.Name.Local == "fillcolor" {
			_fccbg, _fdebdg := _aeege.Value, error(nil)
			if _fdebdg != nil {
				return _fdebdg
			}
			_dcffd.FillcolorAttr = &_fccbg
			continue
		}
		if _aeege.Name.Local == "opacity" {
			_cggba, _bfgdcg := _aeege.Value, error(nil)
			if _bfgdcg != nil {
				return _bfgdcg
			}
			_dcffd.OpacityAttr = &_cggba
			continue
		}
		if _aeege.Name.Local == "wrapcoords" {
			_ffgfa, _cbadc := _aeege.Value, error(nil)
			if _cbadc != nil {
				return _cbadc
			}
			_dcffd.WrapcoordsAttr = &_ffgfa
			continue
		}
		if _aeege.Name.Local == "strokecolor" {
			_efegg, _ffdcf := _aeege.Value, error(nil)
			if _ffdcf != nil {
				return _ffdcf
			}
			_dcffd.StrokecolorAttr = &_efegg
			continue
		}
		if _aeege.Name.Local == "insetpen" {
			_dcffd.InsetpenAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Local == "href" {
			_abdcg, _bbefcb := _aeege.Value, error(nil)
			if _bbefcb != nil {
				return _bbefcb
			}
			_dcffd.HrefAttr = &_abdcg
			continue
		}
		if _aeege.Name.Local == "id" {
			_baeca, _dfcde := _aeege.Value, error(nil)
			if _dfcde != nil {
				return _dfcde
			}
			_dcffd.IdAttr = &_baeca
			continue
		}
		if _aeege.Name.Local == "print" {
			_dcffd.PrintAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
		if _aeege.Name.Local == "alt" {
			_ggcbdb, _ccbfb := _aeege.Value, error(nil)
			if _ccbfb != nil {
				return _ccbfb
			}
			_dcffd.AltAttr = &_ggcbdb
			continue
		}
		if _aeege.Name.Local == "title" {
			_dgcbc, _cabec := _aeege.Value, error(nil)
			if _cabec != nil {
				return _cabec
			}
			_dcffd.TitleAttr = &_dgcbc
			continue
		}
		if _aeege.Name.Local == "class" {
			_dgdedd, _eead := _aeege.Value, error(nil)
			if _eead != nil {
				return _eead
			}
			_dcffd.ClassAttr = &_dgdedd
			continue
		}
		if _aeege.Name.Local == "filled" {
			_dcffd.FilledAttr.UnmarshalXMLAttr(_aeege)
			continue
		}
	}
_dega:
	for {
		_beac, _fcbfe := d.Token()
		if _fcbfe != nil {
			return _fcbfe
		}
		switch _ggfeb := _beac.(type) {
		case _b.StartElement:
			switch _ggfeb.Name {
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "path"}:
				_cgggg := NewEG_ShapeElements()
				_cgggg.Path = NewPath()
				if _efabc := d.DecodeElement(_cgggg.Path, &_ggfeb); _efabc != nil {
					return _efabc
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _cgggg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "formulas"}:
				_cggecc := NewEG_ShapeElements()
				_cggecc.Formulas = NewFormulas()
				if _aafedd := d.DecodeElement(_cggecc.Formulas, &_ggfeb); _aafedd != nil {
					return _aafedd
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _cggecc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "handles"}:
				_ggcab := NewEG_ShapeElements()
				_ggcab.Handles = NewHandles()
				if _abded := d.DecodeElement(_ggcab.Handles, &_ggfeb); _abded != nil {
					return _abded
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _ggcab)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "fill"}:
				_gdeff := NewEG_ShapeElements()
				_gdeff.Fill = NewFill()
				if _bcfgac := d.DecodeElement(_gdeff.Fill, &_ggfeb); _bcfgac != nil {
					return _bcfgac
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _gdeff)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "stroke"}:
				_bbfb := NewEG_ShapeElements()
				_bbfb.Stroke = NewStroke()
				if _fgbdc := d.DecodeElement(_bbfb.Stroke, &_ggfeb); _fgbdc != nil {
					return _fgbdc
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _bbfb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "shadow"}:
				_acdeg := NewEG_ShapeElements()
				_acdeg.Shadow = NewShadow()
				if _adfg := d.DecodeElement(_acdeg.Shadow, &_ggfeb); _adfg != nil {
					return _adfg
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _acdeg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textbox"}:
				_afade := NewEG_ShapeElements()
				_afade.Textbox = NewTextbox()
				if _egcff := d.DecodeElement(_afade.Textbox, &_ggfeb); _egcff != nil {
					return _egcff
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _afade)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "textpath"}:
				_fbaad := NewEG_ShapeElements()
				_fbaad.Textpath = NewTextpath()
				if _defd := d.DecodeElement(_fbaad.Textpath, &_ggfeb); _defd != nil {
					return _defd
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _fbaad)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:vml", Local: "imagedata"}:
				_edcge := NewEG_ShapeElements()
				_edcge.Imagedata = NewImagedata()
				if _gbbdg := d.DecodeElement(_edcge.Imagedata, &_ggfeb); _gbbdg != nil {
					return _gbbdg
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _edcge)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "skew"}:
				_cbcea := NewEG_ShapeElements()
				_cbcea.Skew = NewOfcSkew()
				if _egeb := d.DecodeElement(_cbcea.Skew, &_ggfeb); _egeb != nil {
					return _egeb
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _cbcea)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "extrusion"}:
				_ebcfb := NewEG_ShapeElements()
				_ebcfb.Extrusion = NewOfcExtrusion()
				if _ffede := d.DecodeElement(_ebcfb.Extrusion, &_ggfeb); _ffede != nil {
					return _ffede
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _ebcfb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "callout"}:
				_gcgdaf := NewEG_ShapeElements()
				_gcgdaf.Callout = NewOfcCallout()
				if _adece := d.DecodeElement(_gcgdaf.Callout, &_ggfeb); _adece != nil {
					return _adece
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _gcgdaf)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "lock"}:
				_acadb := NewEG_ShapeElements()
				_acadb.Lock = NewOfcLock()
				if _cdfgc := d.DecodeElement(_acadb.Lock, &_ggfeb); _cdfgc != nil {
					return _cdfgc
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _acadb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "clippath"}:
				_ebcfc := NewEG_ShapeElements()
				_ebcfc.Clippath = NewOfcClippath()
				if _afdd := d.DecodeElement(_ebcfc.Clippath, &_ggfeb); _afdd != nil {
					return _afdd
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _ebcfc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:office", Local: "signatureline"}:
				_gbaaegb := NewEG_ShapeElements()
				_gbaaegb.Signatureline = NewOfcSignatureline()
				if _cefdae := d.DecodeElement(_gbaaegb.Signatureline, &_ggfeb); _cefdae != nil {
					return _cefdae
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _gbaaegb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "wrap"}:
				_dfecbc := NewEG_ShapeElements()
				_dfecbc.Wrap = _a.NewWrap()
				if _dcgcbc := d.DecodeElement(_dfecbc.Wrap, &_ggfeb); _dcgcbc != nil {
					return _dcgcbc
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _dfecbc)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "anchorlock"}:
				_ggfb := NewEG_ShapeElements()
				_ggfb.Anchorlock = _a.NewAnchorlock()
				if _gdcec := d.DecodeElement(_ggfb.Anchorlock, &_ggfeb); _gdcec != nil {
					return _gdcec
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _ggfb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "bordertop"}:
				_dcggg := NewEG_ShapeElements()
				_dcggg.Bordertop = _a.NewBordertop()
				if _cgada := d.DecodeElement(_dcggg.Bordertop, &_ggfeb); _cgada != nil {
					return _cgada
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _dcggg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderbottom"}:
				_abgcg := NewEG_ShapeElements()
				_abgcg.Borderbottom = _a.NewBorderbottom()
				if _geged := d.DecodeElement(_abgcg.Borderbottom, &_ggfeb); _geged != nil {
					return _geged
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _abgcg)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderleft"}:
				_gaffb := NewEG_ShapeElements()
				_gaffb.Borderleft = _a.NewBorderleft()
				if _gacbc := d.DecodeElement(_gaffb.Borderleft, &_ggfeb); _gacbc != nil {
					return _gacbc
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _gaffb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:word", Local: "borderright"}:
				_fdcbdb := NewEG_ShapeElements()
				_fdcbdb.Borderright = _a.NewBorderright()
				if _fgedf := d.DecodeElement(_fdcbdb.Borderright, &_ggfeb); _fgedf != nil {
					return _fgedf
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _fdcbdb)
			case _b.Name{Space: "urn:schemas\u002dmicrosoft\u002dcom:office:excel", Local: "ClientData"}:
				_bbcb := NewEG_ShapeElements()
				_bbcb.ClientData = _c.NewClientData()
				if _efecdg := d.DecodeElement(_bbcb.ClientData, &_ggfeb); _efecdg != nil {
					return _efecdg
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _bbcb)
			case _b.Name{Space: "urn:schemas-microsoft\u002dcom:office:powerpoint", Local: "textdata"}:
				_edeca := NewEG_ShapeElements()
				_edeca.Textdata = _bf.NewTextdata()
				if _dcfab := d.DecodeElement(_edeca.Textdata, &_ggfeb); _dcfab != nil {
					return _dcfab
				}
				_dcffd.EG_ShapeElements = append(_dcffd.EG_ShapeElements, _edeca)
			default:
				_ba.Log("skipping\u0020unsupported element\u0020on\u0020Rect\u0020\u0025v", _ggfeb.Name)
				if _bggcd := d.Skip(); _bggcd != nil {
					return _bggcd
				}
			}
		case _b.EndElement:
			break _dega
		case _b.CharData:
		}
	}
	return nil
}
func NewOfcCT_ColorMenu() *OfcCT_ColorMenu { _febdc := &OfcCT_ColorMenu{}; return _febdc }
func (_ddcab OfcST_BWMode) String() string {
	switch _ddcab {
	case 0:
		return ""
	case 1:
		return "color"
	case 2:
		return "auto"
	case 3:
		return "grayScale"
	case 4:
		return "lightGrayscale"
	case 5:
		return "inverseGray"
	case 6:
		return "grayOutline"
	case 7:
		return "highContrast"
	case 8:
		return "black"
	case 9:
		return "white"
	case 10:
		return "hide"
	case 11:
		return "undrawn"
	case 12:
		return "blackTextAndLines"
	}
	return ""
}
func (_dgadc OfcST_DiagramLayout) String() string {
	switch _dgadc {
	case 0:
		return ""
	case 1:
		return "0"
	case 2:
		return "1"
	case 3:
		return "2"
	case 4:
		return "3"
	}
	return ""
}
func (_fggfc ST_FillType) Validate() error { return _fggfc.ValidateWithPath("") }
func (_fcadf *OfcCT_Rules) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _fcadf.ExtAttr != ST_ExtUnset {
		_gdccf, _abbca := _fcadf.ExtAttr.MarshalXMLAttr(_b.Name{Local: "v:ext"})
		if _abbca != nil {
			return _abbca
		}
		start.Attr = append(start.Attr, _gdccf)
	}
	e.EncodeToken(start)
	if _fcadf.R != nil {
		_eebf := _b.StartElement{Name: _b.Name{Local: "o:r"}}
		for _, _acadagd := range _fcadf.R {
			e.EncodeElement(_acadagd, _eebf)
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_cccge *OfcST_OLEDrawAspect) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_agfga, _fcebfd := d.Token()
	if _fcebfd != nil {
		return _fcebfd
	}
	if _afaec, _deggbb := _agfga.(_b.EndElement); _deggbb && _afaec.Name == start.Name {
		*_cccge = 1
		return nil
	}
	if _ffac, _gcebf := _agfga.(_b.CharData); !_gcebf {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _agfga)
	} else {
		switch string(_ffac) {
		case "":
			*_cccge = 0
		case "Content":
			*_cccge = 1
		case "Icon":
			*_cccge = 2
		}
	}
	_agfga, _fcebfd = d.Token()
	if _fcebfd != nil {
		return _fcebfd
	}
	if _gdcgf, _cdfab := _agfga.(_b.EndElement); _cdfab && _gdcgf.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _agfga)
}
func (_ccdg *CT_H) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	if _ccdg.PositionAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "position"}, Value: _f.Sprintf("\u0025v", *_ccdg.PositionAttr)})
	}
	if _ccdg.PolarAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "polar"}, Value: _f.Sprintf("\u0025v", *_ccdg.PolarAttr)})
	}
	if _ccdg.MapAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "map"}, Value: _f.Sprintf("\u0025v", *_ccdg.MapAttr)})
	}
	if _ccdg.InvxAttr != _eb.ST_TrueFalseUnset {
		_bgfgb, _fcac := _ccdg.InvxAttr.MarshalXMLAttr(_b.Name{Local: "invx"})
		if _fcac != nil {
			return _fcac
		}
		start.Attr = append(start.Attr, _bgfgb)
	}
	if _ccdg.InvyAttr != _eb.ST_TrueFalseUnset {
		_bacb, _ebgbe := _ccdg.InvyAttr.MarshalXMLAttr(_b.Name{Local: "invy"})
		if _ebgbe != nil {
			return _ebgbe
		}
		start.Attr = append(start.Attr, _bacb)
	}
	if _ccdg.SwitchAttr != _eb.ST_TrueFalseBlankUnset {
		_geff, _cbbfd := _ccdg.SwitchAttr.MarshalXMLAttr(_b.Name{Local: "switch"})
		if _cbbfd != nil {
			return _cbbfd
		}
		start.Attr = append(start.Attr, _geff)
	}
	if _ccdg.XrangeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "xrange"}, Value: _f.Sprintf("\u0025v", *_ccdg.XrangeAttr)})
	}
	if _ccdg.YrangeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "yrange"}, Value: _f.Sprintf("\u0025v", *_ccdg.YrangeAttr)})
	}
	if _ccdg.RadiusrangeAttr != nil {
		start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "radiusrange"}, Value: _f.Sprintf("\u0025v", *_ccdg.RadiusrangeAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func (_gadbeb *ST_FillMethod) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cbggf, _ddafga := d.Token()
	if _ddafga != nil {
		return _ddafga
	}
	if _bfede, _cdcga := _cbggf.(_b.EndElement); _cdcga && _bfede.Name == start.Name {
		*_gadbeb = 1
		return nil
	}
	if _ffdeg, _bbadede := _cbggf.(_b.CharData); !_bbadede {
		return _f.Errorf("expected\u0020char\u0020data\u002c\u0020got\u0020\u0025T", _cbggf)
	} else {
		switch string(_ffdeg) {
		case "":
			*_gadbeb = 0
		case "none":
			*_gadbeb = 1
		case "linear":
			*_gadbeb = 2
		case "sigma":
			*_gadbeb = 3
		case "any":
			*_gadbeb = 4
		case "linear\u0020sigma":
			*_gadbeb = 5
		}
	}
	_cbggf, _ddafga = d.Token()
	if _ddafga != nil {
		return _ddafga
	}
	if _cffgd, _bcdad := _cbggf.(_b.EndElement); _bcdad && _cffgd.Name == start.Name {
		return nil
	}
	return _f.Errorf("expected\u0020end\u0020element\u002c\u0020got \u0025v", _cbggf)
}

// Validate validates the OfcCT_ShapeDefaults and its children
func (_ebdgf *OfcCT_ShapeDefaults) Validate() error {
	return _ebdgf.ValidateWithPath("OfcCT_ShapeDefaults")
}

// Validate validates the OfcInk and its children
func (_bbdbd *OfcInk) Validate() error { return _bbdbd.ValidateWithPath("OfcInk") }

// Validate validates the CT_Background and its children
func (_gcegd *CT_Background) Validate() error { return _gcegd.ValidateWithPath("CT_Background") }
func init() {
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_ShapeDefaults", NewOfcCT_ShapeDefaults)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Ink", NewOfcCT_Ink)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_SignatureLine", NewOfcCT_SignatureLine)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_ShapeLayout", NewOfcCT_ShapeLayout)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_IdMap", NewOfcCT_IdMap)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_RegroupTable", NewOfcCT_RegroupTable)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Entry", NewOfcCT_Entry)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Rules", NewOfcCT_Rules)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_R", NewOfcCT_R)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Proxy", NewOfcCT_Proxy)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Diagram", NewOfcCT_Diagram)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_EquationXml", NewOfcCT_EquationXml)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_RelationTable", NewOfcCT_RelationTable)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Relation", NewOfcCT_Relation)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_ColorMru", NewOfcCT_ColorMru)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_ColorMenu", NewOfcCT_ColorMenu)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Skew", NewOfcCT_Skew)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Extrusion", NewOfcCT_Extrusion)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Callout", NewOfcCT_Callout)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Lock", NewOfcCT_Lock)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_OLEObject", NewOfcCT_OLEObject)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Complex", NewOfcCT_Complex)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_StrokeChild", NewOfcCT_StrokeChild)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_ClipPath", NewOfcCT_ClipPath)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "CT_Fill", NewOfcCT_Fill)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "shapedefaults", NewOfcShapedefaults)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "shapelayout", NewOfcShapelayout)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "signatureline", NewOfcSignatureline)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "ink", NewOfcInk)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "diagram", NewOfcDiagram)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "equationxml", NewOfcEquationxml)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "skew", NewOfcSkew)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "extrusion", NewOfcExtrusion)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "callout", NewOfcCallout)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "lock", NewOfcLock)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "OLEObject", NewOfcOLEObject)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "complex", NewOfcComplex)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "left", NewOfcLeft)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "top", NewOfcTop)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "right", NewOfcRight)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "bottom", NewOfcBottom)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "column", NewOfcColumn)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "clippath", NewOfcClippath)
	_ba.RegisterConstructor("urn:schemas\u002dmicrosoft\u002dcom:office:office", "fill", NewOfcFill)
}
